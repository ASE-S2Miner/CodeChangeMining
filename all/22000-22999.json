[{"original_method":"/**\n\t * Get the average of the contents of a {@link List} of {@link BigDecimal} values, excluding null entries\n\t * @param list the {@link List} of {@link BigDecimal} values\n\t * @return the average of the not-null values as a {@link BigDecimal} value\n\t */\n\tpublic static BigDecimal average(List<BigDecimal> list) {\n\t\tBigDecimal total = new BigDecimal(0);\n\t\tList<BigDecimal> notNullEntries = getNotNullEntries(list);\n\t\tif (notNullEntries.size() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tfor (BigDecimal entry : notNullEntries) {\n\t\t\ttotal = total.add(entry);\n\t\t}\n\t\t\n\t\treturn total.divide(new BigDecimal(notNullEntries.size()));\n\t}","id":22000,"modified_method":"/**\n\t * Get the average of the contents of a {@link List} of {@link BigDecimal} values, excluding null entries\n\t * @param list the {@link List} of {@link BigDecimal} values\n\t * @return the average of the not-null values as a {@link BigDecimal} value\n\t */\n\tpublic static BigDecimal average(List<BigDecimal> list) {\n\t\tBigDecimal total = new BigDecimal(0);\n\t\tList<BigDecimal> notNullEntries = getNotNullEntries(list);\n\t\tif (notNullEntries.size() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tfor (BigDecimal entry : notNullEntries) {\n\t\t\ttotal = total.add(entry);\n\t\t}\n\t\t\n\t\treturn total.divide(new BigDecimal(notNullEntries.size()), BigDecimal.ROUND_HALF_UP);\n\t}","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Get the percentage of null entries in a {@link List} of {@link BigDecimal} values\n\t * @param list the {@link List} of {@link BigDecimal} values\n\t * @return the percentage of null values as a {@link BigDecimal} value\n\t */\n\tpublic static BigDecimal percentNull(List<BigDecimal> list) {\n\t\tif (list.size() > 0) {\n\t\t\treturn new BigDecimal(countNull(list)).divide(new BigDecimal(list.size())).multiply(new BigDecimal(100));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","id":22001,"modified_method":"/**\n\t * Get the percentage of null entries in a {@link List} of {@link BigDecimal} values\n\t * @param list the {@link List} of {@link BigDecimal} values\n\t * @return the percentage of null values as a {@link BigDecimal} value\n\t */\n\tpublic static BigDecimal percentNull(List<BigDecimal> list) {\n\t\tif (list.size() > 0) {\n\t\t\treturn new BigDecimal(countNull(list)).divide(new BigDecimal(list.size()), BigDecimal.ROUND_HALF_UP).multiply(new BigDecimal(100));\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Get the median of the contents of a {@link List} of {@link BigDecimal} values, excluding null entries\n\t * @param list the {@link List} of {@link BigDecimal} values\n\t * @return the median of the not-null values as a {@link BigDecimal} value\n\t */\n\tpublic static BigDecimal median(List<BigDecimal> list) {\n\t\tList<BigDecimal> notNullEntries = getNotNullEntries(list);\n\t\tCollections.sort(notNullEntries);\n\t\t\n\t\tif (notNullEntries.size() % 2 == 0) {\n\t\t\t// even number of entries, take the mean of the 2 center ones\n\t\t\tBigDecimal value1, value2;\n\t\t\tvalue1 = notNullEntries.get(notNullEntries.size() / 2);\n\t\t\tvalue2 = notNullEntries.get((notNullEntries.size() / 2) - 1);\n\t\t\treturn value1.add(value2).divide(new BigDecimal(2));\n\t\t} else {\n\t\t\treturn notNullEntries.get(notNullEntries.size() / 2);\n\t\t}\n\t}","id":22002,"modified_method":"/**\n\t * Get the median of the contents of a {@link List} of {@link BigDecimal} values, excluding null entries\n\t * @param list the {@link List} of {@link BigDecimal} values\n\t * @return the median of the not-null values as a {@link BigDecimal} value\n\t */\n\tpublic static BigDecimal median(List<BigDecimal> list) {\n\t\tList<BigDecimal> notNullEntries = getNotNullEntries(list);\n\t\tCollections.sort(notNullEntries);\n\t\t\n\t\tif (notNullEntries.size() % 2 == 0) {\n\t\t\t// even number of entries, take the mean of the 2 center ones\n\t\t\tBigDecimal value1, value2;\n\t\t\tvalue1 = notNullEntries.get(notNullEntries.size() / 2);\n\t\t\tvalue2 = notNullEntries.get((notNullEntries.size() / 2) - 1);\n\t\t\treturn value1.add(value2).divide(new BigDecimal(2), BigDecimal.ROUND_HALF_UP);\n\t\t} else {\n\t\t\treturn notNullEntries.get(notNullEntries.size() / 2);\n\t\t}\n\t}","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Send this PingRequest through the given icmpSocket\n     * @param icmpSocket\n     */\n    public void sendRequest(IcmpSocket icmpSocket) {\n        try {\n            m_expiration = System.currentTimeMillis() + m_timeout;\n            icmpSocket.send(getDatagram());\n        } catch (Throwable t) {\n            m_callback.handleError(this, t);\n        }\n    }","id":22003,"modified_method":"/**\n     * Send this PingRequest through the given icmpSocket\n     * @param icmpSocket\n     */\n    public void sendRequest(IcmpSocket icmpSocket) {\n        try {\n            m_expiration = System.currentTimeMillis() + m_timeout;\n            ICMPEchoPacket iPkt = new ICMPEchoPacket(getTid());\n            iPkt.setIdentity(FILTER_ID);\n            iPkt.setSequenceId(getSequenceId());\n            iPkt.computeChecksum();\n            m_request = iPkt;\n\n            byte[] data = iPkt.toBytes();\n            DatagramPacket packet = new DatagramPacket(data, data.length, getAddress(), 0);\n            icmpSocket.send(packet);\n        } catch (Throwable t) {\n            m_callback.handleError(this, t);\n        }\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PingRequest processTimeout() {\n        PingRequest returnval = null;\n        if (isExpired()) {\n            if (getRetries() > 0) {\n                returnval = new PingRequest(getAddress(), getTimeout(), getRetries() - 1, getSequenceId(), m_callback);\n            } else {\n                m_callback.handleTimeout(getRequest());\n            }\n        }\n        return returnval;\n    }","id":22004,"modified_method":"public PingRequest processTimeout() {\n        PingRequest returnval = null;\n        if (this.isExpired()) {\n            if (this.getRetries() > 0) {\n                returnval = new PingRequest(getAddress(), getTimeout(), getRetries() - 1, getSequenceId(), m_callback);\n            } else {\n                m_callback.handleTimeout(getRequest());\n            }\n        }\n        return returnval;\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPing() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","id":22005,"modified_method":"public void testParallelPing() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        assertTrue(CollectionMath.countNotNull(items) > 0);\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testParallelPingFailure() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_goodHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        Thread.sleep(1000);\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","id":22006,"modified_method":"public void testParallelPingFailure() throws Exception {\n        List<Number> items = m_pinger.parallelPing(m_badHost, 10, Pinger.DEFAULT_TIMEOUT, 50);\n        System.out.println(\"response times = \" + items);\n        System.out.println(\"pings = \" + items.size() + \", passed = \" + CollectionMath.countNotNull(items) + \" (\" + CollectionMath.percentNotNull(items) + \"%), failed = \" + CollectionMath.countNull(items) + \" (\" + CollectionMath.percentNull(items) + \"%), average = \" + (CollectionMath.average(items).floatValue() / 1000F) + \"ms\");\n        assertTrue(CollectionMath.countNotNull(items) == 0);\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSinglePingFailure() throws Exception {\n        assertNull(m_pinger.ping(m_badHost));\n        Thread.sleep(1000);\n    }","id":22007,"modified_method":"public void testSinglePingFailure() throws Exception {\n        assertNull(m_pinger.ping(m_badHost));\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSinglePing() throws Exception {\n        assertTrue(m_pinger.ping(m_goodHost) > 0);\n        Thread.sleep(1000);\n    }","id":22008,"modified_method":"public void testSinglePing() throws Exception {\n        assertTrue(m_pinger.ping(m_goodHost) > 0);\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static long minimumWaitTime() {\n    \tlong now = System.currentTimeMillis();\n    \tlong waitTime = Long.MAX_VALUE;\n    \tsynchronized(waiting) {\n            for (Long tidKey : waiting.keySet()) {\n                long myWait = waiting.get(tidKey).getExpiration() - now;\n                waitTime = Math.min(waitTime, myWait);\n            }\n    \t}\n    \treturn waitTime;\n    }","id":22009,"modified_method":"public long minimumWaitTime() {\n    \tArrayList<PingRequest> pr = null;\n    \tsynchronized(waiting) {\n    \t    if (waiting.size() == 0) {\n    \t        return -1L;\n    \t    }\n    \t    \n            pr = new ArrayList<PingRequest>(waiting.values());\n    \t}\n        Collections.sort(pr, new Comparator<PingRequest>() {\n            public int compare(PingRequest arg0, PingRequest arg1) {\n                if (arg0 == null) {\n                    return -1;\n                } else if (arg1 == null) {\n                    return 1;\n                } else if (arg0.getExpiration() == arg0.getExpiration()) {\n                    return 0;\n                } else {\n                    return (arg1.getExpiration() > arg0.getExpiration()? 1 : -1);\n                }\n            }\n        });\n        ThreadCategory.getInstance(this.getClass()).info(System.currentTimeMillis() + \": \" + pr.size() + \" packets in the queue, lowest is \" + pr.get(0));\n        long waitTime = pr.get(0).getExpiration() - System.currentTimeMillis();\n        if (waitTime < 0) {\n            return 0;\n        } else {\n            return waitTime;\n        }\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Initialize a Pinger object, specifying the timeout and retries.\n     * @param defaultTimeout the timeout, in milliseconds, to wait for returned packets.\n     * @param defaultRetries the number of times to retry a given ping packet\n     * @throws IOException\n     */\n\tpublic Pinger() throws IOException {\n\t\tsynchronized (Pinger.class) {\n\t\t\tif (worker == null) {\n\t\t\t    final FifoQueueImpl<Reply> queue = new FifoQueueImpl<Reply>();\n\t\t\t\ticmpSocket = new IcmpSocket();\n                receiver = new ReplyReceiver(icmpSocket, queue, PingRequest.FILTER_ID);\n                receiver.start();\n\t\t\t\t\n                worker = new Thread(new Runnable() {\n                    public void run() {\n                        for (;;) {\n                        \tlong waitTime = minimumWaitTime();\n                        \tif (waitTime > 0) {\n                        \t    try {\n                                    Reply pong = queue.remove(waitTime);\n                                    processReply(pong);\n                        \t    } catch (InterruptedException ie) {\n                        \t        break;\n                        \t    } catch (FifoQueueException fqe) {\n                        \t        ThreadCategory.getInstance(this.getClass()).error(\"Error processing response queue\", fqe);\n                        \t    }\n                        \t} else {\n                        \t    processTimeouts();\n                        \t}\n                        }\n                    }\n                });\n                worker.setDaemon(true);\n                worker.start();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","id":22010,"modified_method":"/**\n     * Initialize a Pinger object, specifying the timeout and retries.\n     * @param defaultTimeout the timeout, in milliseconds, to wait for returned packets.\n     * @param defaultRetries the number of times to retry a given ping packet\n     * @throws IOException\n     */\n\tpublic Pinger() throws IOException {\n\t\tsynchronized (Pinger.class) {\n\t\t\tif (worker == null) {\n\t\t\t    final FifoQueueImpl<Reply> queue = new FifoQueueImpl<Reply>();\n\t\t\t\ticmpSocket = new IcmpSocket();\n                receiver = new ReplyReceiver(icmpSocket, queue, PingRequest.FILTER_ID);\n                receiver.start();\n\t\t\t\t\n                worker = new Thread(new Runnable() {\n                    public void run() {\n                        for (;;) {\n                        \tlong waitTime = minimumWaitTime();\n                        \tThreadCategory.getInstance(this.getClass()).info(\"minimum wait time: \" + waitTime);\n                        \tif (waitTime > 0) {\n                        \t    try {\n                                    Reply pong = queue.remove(waitTime);\n                                    if (pong != null) {\n                                        processReply(pong);\n                                    }\n                        \t    } catch (InterruptedException ie) {\n                        \t        break;\n                        \t    } catch (FifoQueueException fqe) {\n                        \t        ThreadCategory.getInstance(this.getClass()).error(\"Error processing response queue\", fqe);\n                        \t    }\n                        \t} else if (waitTime == -1L) {\n                        \t    try {\n                                    Thread.sleep(DEFAULT_WAIT_TIME);\n                                } catch (InterruptedException e) {\n                                    ThreadCategory.getInstance(this.getClass()).info(\"interrupted while waiting for new packets to handle\", e);\n                                }\n                        \t} else {\n                        \t    processTimeouts();\n                        \t}\n                        }\n                    }\n                });\n                worker.setDaemon(true);\n                worker.start();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void processTimeouts() {\n\t    synchronized(waiting) {\n\t        for (PingRequest request : waiting.values()) {\n\t            request.processTimeout();\n\t        }\n\t    }\n    }","id":22011,"modified_method":"protected void processTimeouts() {\n        synchronized(waiting) {\n            for (Iterator<Entry<Long, PingRequest>> it = waiting.entrySet().iterator(); it.hasNext(); ) {\n                PingRequest request = it.next().getValue();\n                ThreadCategory.getInstance(this.getClass()).debug(\"checking request \" + request);\n                if (request.isExpired()) {\n                    it.remove();\n                    PingRequest retry = request.processTimeout();\n                    if (retry != null) {\n                        waiting.put(retry.getTid(), retry);\n                        retry.sendRequest(icmpSocket);\n                    }\n                }\n            }\n        }\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void handleTimeout(ICMPEchoPacket packet) {\n\t    bs.signalAll();\n\t}","id":22012,"modified_method":"public void handleTimeout(ICMPEchoPacket packet) {\n\t    ThreadCategory.getInstance(this.getClass()).info(\"timed out pinging \" + packet.getTID() + \"/\" + packet.getSequenceId());\n\t    bs.signalAll();\n\t}","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void handleResponse(ICMPEchoPacket packet) {\n\t    responseTime = packet.getPingRTT();\n\t    bs.signalAll();\n\t}","id":22013,"modified_method":"public void handleResponse(ICMPEchoPacket packet) {\n\t    ThreadCategory.getInstance(this.getClass()).info(\"got response for \" + packet.getTID() + \"/\" + packet.getSequenceId());\n\t    responseTime = packet.getPingRTT();\n\t    bs.signalAll();\n\t}","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void waitFor() throws InterruptedException {\n        bs.waitFor();\n    }","id":22014,"modified_method":"public void waitFor() throws InterruptedException {\n        ThreadCategory.getInstance(this.getClass()).info(\"waiting to finish\");\n        bs.waitFor();\n    }","commit_id":"c48a1002197f9c91ba7772ae86bae0d73684359f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * @return Whether the relations match (in sense of \"be mergable\").\n\t */\n\tprivate boolean match(Relation w1, Relation w2) {\n\t\t// FIXME this is not perfect yet...\n\t\tif (w1.id == 0 || w2.id == 0) {\n\t\t\tif (w1.members.size() != w2.members.size())\n\t\t\t\treturn false;\n\t\t\tfor (RelationMember em : w1.members) {\n\t\t\t\tif (!w2.members.contains(em)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn w1.id == w2.id;\n\t}","id":22015,"modified_method":"private static boolean realMatch(Relation w1, Relation w2) {\n\t\t// FIXME this is not perfect yet...\n\t\tif (w1.members.size() != w2.members.size())\n\t\t\treturn false;\n\t\tfor (RelationMember em : w1.members) {\n\t\t\tif (!w2.members.contains(em)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"3cfa6fcda641bd02e623bc577d8aec0c7f827b0c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * Merge the relation if id matches or if all members match and the\n\t * id of either relation is zero.\n\t */\n\tpublic void visit(Relation other) {\n\t\tfixRelation(other);\n\t\tif (mergeAfterId(ds.relations, relshash, other))\n\t\t\treturn;\n\n\t\tRelation my = null;\n\t\tfor (Relation e : ds.relations) {\n\t\t\tif (match(other, e) && ((mergeds == null) || (!mergeds.relations.contains(e)))) {\n\t\t\t\tmy = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (my == null) {\n\t\t\t// Add the relation\n\t\t\tds.relations.add(other);\n\t\t} else {\n\t\t\tmerged.put(other, my);\n\t\t\tmergeCommon(my, other);\n\t\t\tif (my.modified && !other.modified)\n\t\t\t\treturn;\n\t\t\tboolean same = true;\n\t\t\tif (other.members.size() != my.members.size()) {\n\t\t\t\t\tsame = false;\n\t\t\t} else {\n\t\t\t\tfor (RelationMember em : my.members) {\n\t\t\t\t\tif (!other.members.contains(em)) {\n\t\t\t\t\t\tsame = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!same) {\n\t\t\t\tmy.modified = other.modified;\n\t\t\t}\n\t\t}\n\t}","id":22016,"modified_method":"public void visit(Relation other) {\n\t\tfixRelation(other);\n\t\tgenMerge(other, ds.relations, mergeds.relations, relshash);\n\t}","commit_id":"3cfa6fcda641bd02e623bc577d8aec0c7f827b0c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * Merge the way if id matches or if all nodes match and the\n\t * id is zero of either way.\n\t */\n\tpublic void visit(Way other) {\n\t\tfixWay(other);\n\t\tif (mergeAfterId(ds.ways, wayshash, other))\n\t\t\treturn;\n\n\t\tWay my = null;\n\t\tfor (Way w : ds.ways) {\n\t\t\tif (match(other, w) && ((mergeds == null) || (!mergeds.ways.contains(w)))) {\n\t\t\t\tmy = w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (my == null) {\n\t\t\tds.ways.add(other);\n\t\t} else {\n\t\t\tmerged.put(other, my);\n\t\t\tmergeCommon(my, other);\n\t\t\tif (my.modified && !other.modified)\n\t\t\t\treturn;\n\t\t\tboolean same = true;\n\t\t\tIterator<Node> it = other.nodes.iterator();\n\t\t\tfor (Node n : my.nodes) {\n\t\t\t\tif (!match(n, it.next()))\n\t\t\t\t\tsame = false;\n\t\t\t}\n\t\t\tif (!same) {\n\t\t\t\tmy.modified = other.modified;\n\t\t\t}\n\t\t}\n\t}","id":22017,"modified_method":"public void visit(Way other) {\n\t\tfixWay(other);\n\t\tgenMerge(other, ds.ways, mergeds.ways, wayshash);\n\t}","commit_id":"3cfa6fcda641bd02e623bc577d8aec0c7f827b0c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * Merge the node if the id matches with any of the internal set or if\n\t * either id is zero, merge if lat/lon matches.\n\t */\n\tpublic void visit(Node other) {\n\t\tif (mergeAfterId(ds.nodes, nodeshash, other))\n\t\t\treturn;\n\n\t\tNode my = null;\n\t\tfor (Node n : ds.nodes) {\n\t\t\tif (match(n, other) && ((mergeds == null) || (!mergeds.nodes.contains(n)))) {\n\t\t\t\tmy = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (my == null)\n\t\t\tds.nodes.add(other);\n\t\telse {\n\t\t\tmerged.put(other, my);\n\t\t\tmergeCommon(my, other);\n\t\t\tif (my.modified && !other.modified)\n\t\t\t\treturn;\n\t\t\tif (!my.coor.equalsEpsilon(other.coor)) {\n\t\t\t\tmy.coor = other.coor;\n\t\t\t\tmy.eastNorth = other.eastNorth;\n\t\t\t\tmy.modified = other.modified;\n\t\t\t}\n\t\t}\n\t}","id":22018,"modified_method":"public void visit(Node other) {\n\t\tgenMerge(other, ds.nodes, mergeds.nodes, nodeshash);\n\t}","commit_id":"3cfa6fcda641bd02e623bc577d8aec0c7f827b0c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * @return Whether the ways match (in sense of \"be mergable\").\n\t */\n\tprivate boolean match(Way w1, Way w2) {\n\t\tif (w1.id == 0 || w2.id == 0) {\n\t\t\tif (w1.nodes.size() != w2.nodes.size())\n\t\t\treturn false;\n\t\t\tIterator<Node> it = w1.nodes.iterator();\n\t\t\tfor (Node n : w2.nodes)\n\t\t\t\tif (!match(n, it.next()))\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn w1.id == w2.id;\n\t}","id":22019,"modified_method":"private static boolean realMatch(Way w1, Way w2) {\n\t\tif (w1.nodes.size() != w2.nodes.size())\n\t\t\treturn false;\n\t\tIterator<Node> it = w1.nodes.iterator();\n\t\tfor (Node n : w2.nodes)\n\t\t\tif (!match(n, it.next()))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}","commit_id":"3cfa6fcda641bd02e623bc577d8aec0c7f827b0c","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * @return Whether the nodes match (in sense of \"be mergable\").\n\t */\n\tprivate boolean match(Node n1, Node n2) {\n\t\tif (n1.id == 0 || n2.id == 0)\n\t\t\treturn n1.coor.equalsEpsilon(n2.coor);\n\t\treturn n1.id == n2.id;\n\t}","id":22020,"modified_method":"private static boolean realMatch(Node n1, Node n2) {\n\t\treturn n1.coor.equalsEpsilon(n2.coor);\n\t}","commit_id":"3cfa6fcda641bd02e623bc577d8aec0c7f827b0c","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n\tpublic void bind (final ShaderProgram shader, final int[] locations) {\r\n\t\tfinal GL20 gl = Gdx.gl20;\r\n\t\tfinal int numAttributes = attributes.size();\r\n\t\tbyteBuffer.limit(buffer.limit() * 4);\r\n\t\tif (locations == null) {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tbyteBuffer.position(attribute.offset);\r\n\t\t\t\tif (attribute.usage == Usage.ColorPacked)\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,\r\n\t\t\t\t\t\tbyteBuffer);\r\n\t\t\t\telse\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,\r\n\t\t\t\t\t\tbyteBuffer);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = locations[i];\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tbyteBuffer.position(attribute.offset);\r\n\t\t\t\tif (attribute.usage == Usage.ColorPacked)\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,\r\n\t\t\t\t\t\tbyteBuffer);\r\n\t\t\t\telse\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,\r\n\t\t\t\t\t\tbyteBuffer);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisBound = true;\r\n\t}","id":22021,"modified_method":"@Override\r\n\tpublic void bind (final ShaderProgram shader, final int[] locations) {\r\n\t\tfinal GL20 gl = Gdx.gl20;\r\n\t\tfinal int numAttributes = attributes.size();\r\n\t\tbyteBuffer.limit(buffer.limit() * 4);\r\n\t\tif (locations == null) {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tbyteBuffer.position(attribute.offset);\r\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\r\n\t\t\t\t\tbyteBuffer);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = locations[i];\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tbyteBuffer.position(attribute.offset);\r\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\r\n\t\t\t\t\tbyteBuffer);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisBound = true;\r\n\t}","commit_id":"dc082be15a5b9572f4c4e1c9af6bdaf1ebefaa07","url":"https://github.com/libgdx/libgdx"},{"original_method":"public static VertexAttribute Color () {\r\n\t\treturn new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE);\r\n\t}","id":22022,"modified_method":"/** @deprecated use {@link #ColorPacked()} */\r\n\t@Deprecated\r\n\tpublic static VertexAttribute Color () {\r\n\t\treturn ColorPacked();\r\n\t}","commit_id":"dc082be15a5b9572f4c4e1c9af6bdaf1ebefaa07","url":"https://github.com/libgdx/libgdx"},{"original_method":"public static VertexAttribute ColorUnpacked () {\r\n\t\treturn new VertexAttribute(Usage.Color, 4, ShaderProgram.COLOR_ATTRIBUTE);\r\n\t}","id":22023,"modified_method":"public static VertexAttribute ColorUnpacked () {\r\n\t\treturn new VertexAttribute(Usage.Color, 4, GL20.GL_FLOAT, false, ShaderProgram.COLOR_ATTRIBUTE);\r\n\t}","commit_id":"dc082be15a5b9572f4c4e1c9af6bdaf1ebefaa07","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Constructs a new VertexAttribute.\r\n\t * \r\n\t * @param usage the usage, used for the fixed function pipeline. Generic attributes are not supported in the fixed function\r\n\t *           pipeline.\r\n\t * @param numComponents the number of components of this attribute, must be between 1 and 4.\r\n\t * @param alias the alias used in a shader for this attribute. Can be changed after construction.\r\n\t * @param index unit/index of the attribute, used for boneweights and texture coordinates. */\r\n\tpublic VertexAttribute (int usage, int numComponents, String alias, int index) {\r\n\t\tthis.usage = usage;\r\n\t\tthis.numComponents = numComponents;\r\n\t\tthis.alias = alias;\r\n\t\tthis.unit = index;\r\n\t\tthis.usageIndex = Integer.numberOfTrailingZeros(usage);\r\n\t}","id":22024,"modified_method":"/** Constructs a new VertexAttribute.\r\n\t * \r\n\t * @param usage the usage, used for the fixed function pipeline. Generic attributes are not supported in the fixed function\r\n\t *           pipeline.\r\n\t * @param numComponents the number of components of this attribute, must be between 1 and 4.\r\n\t * @param alias the alias used in a shader for this attribute. Can be changed after construction.\r\n\t * @param index unit/index of the attribute, used for boneweights and texture coordinates. */\r\n\tpublic VertexAttribute (int usage, int numComponents, String alias, int index) {\r\n\t\tthis(usage, numComponents, usage == Usage.ColorPacked ? GL20.GL_UNSIGNED_BYTE : GL20.GL_FLOAT, \r\n\t\t\t\tusage == Usage.ColorPacked, alias, index);\r\n\t}","commit_id":"dc082be15a5b9572f4c4e1c9af6bdaf1ebefaa07","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void bind (ShaderProgram shader, int[] locations) {\r\n\t\tfinal GL20 gl = Gdx.gl20;\r\n\r\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\r\n\t\tif (isDirty) {\r\n\t\t\tbyteBuffer.limit(buffer.limit() * 4);\r\n\t\t\tgl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);\r\n\t\t\tisDirty = false;\r\n\t\t}\r\n\r\n\t\tfinal int numAttributes = attributes.size();\r\n\t\tif (locations == null) {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tif (attribute.usage == Usage.ColorPacked)\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t\telse\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = locations[i];\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tif (attribute.usage == Usage.ColorPacked)\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t\telse\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisBound = true;\r\n\t}","id":22025,"modified_method":"@Override\r\n\tpublic void bind (ShaderProgram shader, int[] locations) {\r\n\t\tfinal GL20 gl = Gdx.gl20;\r\n\r\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\r\n\t\tif (isDirty) {\r\n\t\t\tbyteBuffer.limit(buffer.limit() * 4);\r\n\t\t\tgl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);\r\n\t\t\tisDirty = false;\r\n\t\t}\r\n\r\n\t\tfinal int numAttributes = attributes.size();\r\n\t\tif (locations == null) {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = locations[i];\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\r\n\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisBound = true;\r\n\t}","commit_id":"dc082be15a5b9572f4c4e1c9af6bdaf1ebefaa07","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void bind (final ShaderProgram shader, final int[] locations) {\r\n\t\tfinal GL20 gl = Gdx.gl20;\r\n\r\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\r\n\t\tif (isDirty) {\r\n\t\t\tbyteBuffer.limit(buffer.limit() * 4);\r\n\t\t\tgl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);\r\n\t\t\tisDirty = false;\r\n\t\t}\r\n\r\n\t\tfinal int numAttributes = attributes.size();\r\n\t\tif (locations == null) {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tif (attribute.usage == Usage.ColorPacked)\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t\telse\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = locations[i];\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tif (attribute.usage == Usage.ColorPacked)\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_UNSIGNED_BYTE, true, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t\telse\r\n\t\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, GL20.GL_FLOAT, false, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisBound = true;\r\n\t}","id":22026,"modified_method":"@Override\r\n\tpublic void bind (final ShaderProgram shader, final int[] locations) {\r\n\t\tfinal GL20 gl = Gdx.gl20;\r\n\r\n\t\tgl.glBindBuffer(GL20.GL_ARRAY_BUFFER, bufferHandle);\r\n\t\tif (isDirty) {\r\n\t\t\tbyteBuffer.limit(buffer.limit() * 4);\r\n\t\t\tgl.glBufferData(GL20.GL_ARRAY_BUFFER, byteBuffer.limit(), byteBuffer, usage);\r\n\t\t\tisDirty = false;\r\n\t\t}\r\n\r\n\t\tfinal int numAttributes = attributes.size();\r\n\t\tif (locations == null) {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = shader.getAttributeLocation(attribute.alias);\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0; i < numAttributes; i++) {\r\n\t\t\t\tfinal VertexAttribute attribute = attributes.get(i);\r\n\t\t\t\tfinal int location = locations[i];\r\n\t\t\t\tif (location < 0) continue;\r\n\t\t\t\tshader.enableVertexAttribute(location);\r\n\r\n\t\t\t\tshader.setVertexAttribute(location, attribute.numComponents, attribute.type, attribute.normalized, attributes.vertexSize,\r\n\t\t\t\t\t\tattribute.offset);\r\n\t\t\t}\r\n\t\t}\r\n\t\tisBound = true;\r\n\t}","commit_id":"dc082be15a5b9572f4c4e1c9af6bdaf1ebefaa07","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void setSorting(IssueQuery query, SearchRequestBuilder esSearch) {\n    String sortField = query.sort();\n    if (sortField != null) {\n      Boolean asc = query.asc();\n      List<IndexField> fields = toIndexFields(sortField);\n      for (IndexField field : fields) {\n        FieldSortBuilder sortBuilder = SortBuilders.fieldSort(field.sortField());\n        // line is optional. When missing, it means zero.\n        if (asc != null && asc) {\n          sortBuilder.missing(\"_first\");\n          sortBuilder.order(SortOrder.ASC);\n        } else {\n          sortBuilder.missing(\"_last\");\n          sortBuilder.order(SortOrder.DESC);\n        }\n        esSearch.addSort(sortBuilder);\n      }\n    } else {\n      esSearch.addSort(IssueNormalizer.IssueField.ISSUE_UPDATED_AT.sortField(), SortOrder.DESC);\n      // deterministic sort when exactly the same updated_at (same millisecond)\n      esSearch.addSort(IssueNormalizer.IssueField.KEY.sortField(), SortOrder.ASC);\n    }\n  }","id":22027,"modified_method":"private void setSorting(IssueQuery query, SearchRequestBuilder esRequest) {\n    String sortField = query.sort();\n    if (sortField != null) {\n      boolean asc = BooleanUtils.isTrue(query.asc());\n      sorting.fill(esRequest, sortField, asc);\n    } else {\n      sorting.fillDefault(esRequest);\n    }\n  }","commit_id":"c6a9ef0c9bde8583974dd2823b4f66dc8e9f7956","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public IssueIndex(SearchClient client) {\n    super(IndexDefinition.ISSUES, null, client);\n\n    sortColumns.put(IssueQuery.SORT_BY_ASSIGNEE, IssueNormalizer.IssueField.ASSIGNEE);\n    sortColumns.put(IssueQuery.SORT_BY_STATUS, IssueNormalizer.IssueField.STATUS);\n    sortColumns.put(IssueQuery.SORT_BY_SEVERITY, IssueNormalizer.IssueField.SEVERITY_VALUE);\n    sortColumns.put(IssueQuery.SORT_BY_CREATION_DATE, IssueNormalizer.IssueField.ISSUE_CREATED_AT);\n    sortColumns.put(IssueQuery.SORT_BY_UPDATE_DATE, IssueNormalizer.IssueField.ISSUE_UPDATED_AT);\n    sortColumns.put(IssueQuery.SORT_BY_CLOSE_DATE, IssueNormalizer.IssueField.ISSUE_CLOSE_DATE);\n    sortColumns.put(IssueQuery.SORT_BY_FILE_LINE, IssueNormalizer.IssueField.PROJECT);\n    sortColumns.put(IssueQuery.SORT_BY_FILE_LINE, IssueNormalizer.IssueField.FILE_PATH);\n    sortColumns.put(IssueQuery.SORT_BY_FILE_LINE, IssueNormalizer.IssueField.LINE);\n    sortColumns.put(IssueQuery.SORT_BY_FILE_LINE, IssueNormalizer.IssueField.KEY);\n  }","id":22028,"modified_method":"public IssueIndex(SearchClient client) {\n    super(IndexDefinition.ISSUES, null, client);\n\n    sorting = new Sorting();\n    sorting.add(IssueQuery.SORT_BY_ASSIGNEE, IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE);\n    sorting.add(IssueQuery.SORT_BY_STATUS, IssueIndexDefinition.FIELD_ISSUE_STATUS);\n    sorting.add(IssueQuery.SORT_BY_SEVERITY, IssueIndexDefinition.FIELD_ISSUE_SEVERITY_VALUE);\n    sorting.add(IssueQuery.SORT_BY_CREATION_DATE, IssueIndexDefinition.FIELD_ISSUE_FUNC_CREATED_AT);\n    sorting.add(IssueQuery.SORT_BY_UPDATE_DATE, IssueIndexDefinition.FIELD_ISSUE_FUNC_UPDATED_AT);\n    sorting.add(IssueQuery.SORT_BY_CLOSE_DATE, IssueIndexDefinition.FIELD_ISSUE_FUNC_CLOSED_AT);\n    sorting.add(IssueQuery.SORT_BY_FILE_LINE, IssueIndexDefinition.FIELD_ISSUE_PROJECT_UUID);\n    sorting.add(IssueQuery.SORT_BY_FILE_LINE, IssueIndexDefinition.FIELD_ISSUE_FILE_PATH);\n    sorting.add(IssueQuery.SORT_BY_FILE_LINE, IssueIndexDefinition.FIELD_ISSUE_LINE);\n    sorting.add(IssueQuery.SORT_BY_FILE_LINE, IssueIndexDefinition.FIELD_ISSUE_SEVERITY_VALUE).reverse();\n    sorting.add(IssueQuery.SORT_BY_FILE_LINE, IssueIndexDefinition.FIELD_ISSUE_KEY);\n\n    // by default order by updated date and issue key (in order to be deterministic when same ms)\n    sorting.addDefault(IssueIndexDefinition.FIELD_ISSUE_FUNC_UPDATED_AT).reverse();\n    sorting.addDefault(IssueIndexDefinition.FIELD_ISSUE_KEY);\n  }","commit_id":"c6a9ef0c9bde8583974dd2823b4f66dc8e9f7956","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void testCondition2(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicBoolean condition = new AtomicBoolean(false);\n        final AtomicBoolean fail = new AtomicBoolean(false);\n        Thread t = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                if (condition.get())\n                {\n                    System.err.println(\"\");\n                    fail.set(true);\n                }\n\n                try\n                {\n                    Thread.sleep(200);\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n                if (!condition.get())\n                {\n                    System.err.println(\"Woke up when condition not met\");\n                    fail.set(true);\n                }\n            }\n        });\n        t.start();\n        Thread.sleep(50);\n        condition.set(true);\n        queue.signal();\n        t.join(300);\n        assertFalse(queue.getClass().getName(), t.isAlive());\n        assertFalse(fail.get());\n    }","id":22029,"modified_method":"public void testCondition(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicBoolean ready = new AtomicBoolean(false);\n        final AtomicBoolean condition = new AtomicBoolean(false);\n        final AtomicBoolean fail = new AtomicBoolean(false);\n        Thread t = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                if (condition.get())\n                {\n                    System.err.println(\"\");\n                    fail.set(true);\n                    ready.set(true);\n                    return;\n                }\n\n                ready.set(true);\n                wait.awaitUninterruptibly();\n                if (!condition.get())\n                {\n                    System.err.println(\"Woke up when condition not met\");\n                    fail.set(true);\n                }\n            }\n        });\n        t.start();\n        final ThreadLocalRandom random = ThreadLocalRandom.current();\n        while (!ready.get())\n            random.nextLong();\n        condition.set(true);\n        queue.signal();\n        Util.joinThread(t);\n        assertFalse(queue.getClass().getName(), t.isAlive());\n        assertFalse(fail.get());\n    }","commit_id":"313d9c9b530d03ff750220f275e4691c2af6ce3c","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testCondition1() throws InterruptedException\n    {\n        testCondition1(new WaitQueue());\n    }","id":22030,"modified_method":"@Test\n    public void testCondition() throws InterruptedException\n    {\n        testCondition(new WaitQueue());\n    }","commit_id":"313d9c9b530d03ff750220f275e4691c2af6ce3c","url":"https://github.com/apache/cassandra"},{"original_method":"public void testSerial(final WaitQueue queue) throws InterruptedException\n    {\n        Thread[] ts = new Thread[4];\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i] = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                try\n                {\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        });\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i].start();\n        Thread.sleep(100);\n        queue.signal();\n        queue.signal();\n        queue.signal();\n        queue.signal();\n        for (int i = 0 ; i < ts.length ; i++)\n        {\n            ts[i].join(100);\n            assertFalse(queue.getClass().getName(), ts[i].isAlive());\n        }\n    }","id":22031,"modified_method":"public void testSerial(final WaitQueue queue) throws InterruptedException\n    {\n        AtomicInteger ready = new AtomicInteger();\n        Thread[] ts = new Thread[4];\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i] = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                ready.incrementAndGet();\n                try\n                {\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        });\n        for (Thread t : ts)\n            t.start();\n        final ThreadLocalRandom random = ThreadLocalRandom.current();\n        while (ready.get() < ts.length)\n            random.nextLong();\n        for (Thread t : ts)\n            queue.signal();\n        for (Thread t : ts)\n        {\n            Util.joinThread(t);\n            assertFalse(queue.getClass().getName(), t.isAlive());\n        }\n    }","commit_id":"313d9c9b530d03ff750220f275e4691c2af6ce3c","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testCondition1() throws InterruptedException\n    {\n        testCondition1(new WaitQueue());\n    }","id":22032,"modified_method":"@Test\n    public void testCondition() throws InterruptedException\n    {\n        testCondition(new WaitQueue());\n    }","commit_id":"ecb2b4b0473c019d1132c89887734792c75e0895","url":"https://github.com/apache/cassandra"},{"original_method":"public void testSerial(final WaitQueue queue) throws InterruptedException\n    {\n        Thread[] ts = new Thread[4];\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i] = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                try\n                {\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        });\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i].start();\n        Thread.sleep(100);\n        queue.signal();\n        queue.signal();\n        queue.signal();\n        queue.signal();\n        for (int i = 0 ; i < ts.length ; i++)\n        {\n            ts[i].join(100);\n            assertFalse(queue.getClass().getName(), ts[i].isAlive());\n        }\n    }","id":22033,"modified_method":"public void testSerial(final WaitQueue queue) throws InterruptedException\n    {\n        AtomicInteger ready = new AtomicInteger();\n        Thread[] ts = new Thread[4];\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i] = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                ready.incrementAndGet();\n                try\n                {\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        });\n        for (Thread t : ts)\n            t.start();\n        final ThreadLocalRandom random = ThreadLocalRandom.current();\n        while (ready.get() < ts.length)\n            random.nextLong();\n        for (Thread t : ts)\n            queue.signal();\n        for (Thread t : ts)\n        {\n            Util.joinThread(t);\n            assertFalse(queue.getClass().getName(), t.isAlive());\n        }\n    }","commit_id":"ecb2b4b0473c019d1132c89887734792c75e0895","url":"https://github.com/apache/cassandra"},{"original_method":"public void testCondition2(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicBoolean condition = new AtomicBoolean(false);\n        final AtomicBoolean fail = new AtomicBoolean(false);\n        Thread t = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                if (condition.get())\n                {\n                    System.err.println(\"\");\n                    fail.set(true);\n                }\n\n                try\n                {\n                    Thread.sleep(200);\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n                if (!condition.get())\n                {\n                    System.err.println(\"Woke up when condition not met\");\n                    fail.set(true);\n                }\n            }\n        });\n        t.start();\n        Thread.sleep(50);\n        condition.set(true);\n        queue.signal();\n        t.join(300);\n        assertFalse(queue.getClass().getName(), t.isAlive());\n        assertFalse(fail.get());\n    }","id":22034,"modified_method":"public void testCondition(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicBoolean ready = new AtomicBoolean(false);\n        final AtomicBoolean condition = new AtomicBoolean(false);\n        final AtomicBoolean fail = new AtomicBoolean(false);\n        Thread t = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                if (condition.get())\n                {\n                    System.err.println(\"\");\n                    fail.set(true);\n                    ready.set(true);\n                    return;\n                }\n\n                ready.set(true);\n                wait.awaitUninterruptibly();\n                if (!condition.get())\n                {\n                    System.err.println(\"Woke up when condition not met\");\n                    fail.set(true);\n                }\n            }\n        });\n        t.start();\n        final ThreadLocalRandom random = ThreadLocalRandom.current();\n        while (!ready.get())\n            random.nextLong();\n        condition.set(true);\n        queue.signal();\n        Util.joinThread(t);\n        assertFalse(queue.getClass().getName(), t.isAlive());\n        assertFalse(fail.get());\n    }","commit_id":"ecb2b4b0473c019d1132c89887734792c75e0895","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testCondition1() throws InterruptedException\n    {\n        testCondition1(new WaitQueue());\n    }","id":22035,"modified_method":"@Test\n    public void testCondition() throws InterruptedException\n    {\n        testCondition(new WaitQueue());\n    }","commit_id":"e1bb79260a9bdf478895724ea180cf0c2efb37ff","url":"https://github.com/apache/cassandra"},{"original_method":"public void testSerial(final WaitQueue queue) throws InterruptedException\n    {\n        Thread[] ts = new Thread[4];\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i] = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                try\n                {\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        });\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i].start();\n        Thread.sleep(100);\n        queue.signal();\n        queue.signal();\n        queue.signal();\n        queue.signal();\n        for (int i = 0 ; i < ts.length ; i++)\n        {\n            ts[i].join(100);\n            assertFalse(queue.getClass().getName(), ts[i].isAlive());\n        }\n    }","id":22036,"modified_method":"public void testSerial(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicInteger ready = new AtomicInteger();\n        Thread[] ts = new Thread[4];\n        for (int i = 0 ; i < ts.length ; i++)\n            ts[i] = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                ready.incrementAndGet();\n                try\n                {\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        });\n        for (Thread t : ts)\n            t.start();\n        final ThreadLocalRandom random = ThreadLocalRandom.current();\n        while (ready.get() < ts.length)\n            random.nextLong();\n        for (Thread t : ts)\n            queue.signal();\n        for (Thread t : ts)\n        {\n            Util.joinThread(t);\n            assertFalse(queue.getClass().getName(), t.isAlive());\n        }\n    }","commit_id":"e1bb79260a9bdf478895724ea180cf0c2efb37ff","url":"https://github.com/apache/cassandra"},{"original_method":"public void testCondition2(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicBoolean condition = new AtomicBoolean(false);\n        final AtomicBoolean fail = new AtomicBoolean(false);\n        Thread t = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                if (condition.get())\n                {\n                    System.err.println(\"\");\n                    fail.set(true);\n                }\n\n                try\n                {\n                    Thread.sleep(200);\n                    wait.await();\n                } catch (InterruptedException e)\n                {\n                    e.printStackTrace();\n                }\n                if (!condition.get())\n                {\n                    System.err.println(\"Woke up when condition not met\");\n                    fail.set(true);\n                }\n            }\n        });\n        t.start();\n        Thread.sleep(50);\n        condition.set(true);\n        queue.signal();\n        t.join(300);\n        assertFalse(queue.getClass().getName(), t.isAlive());\n        assertFalse(fail.get());\n    }","id":22037,"modified_method":"public void testCondition(final WaitQueue queue) throws InterruptedException\n    {\n        final AtomicBoolean ready = new AtomicBoolean(false);\n        final AtomicBoolean condition = new AtomicBoolean(false);\n        final AtomicBoolean fail = new AtomicBoolean(false);\n        Thread t = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                WaitQueue.Signal wait = queue.register();\n                if (condition.get())\n                {\n                    System.err.println(\"\");\n                    fail.set(true);\n                    ready.set(true);\n                    return;\n                }\n\n                ready.set(true);\n                wait.awaitUninterruptibly();\n                if (!condition.get())\n                {\n                    System.err.println(\"Woke up when condition not met\");\n                    fail.set(true);\n                }\n            }\n        });\n        t.start();\n        final ThreadLocalRandom random = ThreadLocalRandom.current();\n        while (!ready.get())\n            random.nextLong();\n        condition.set(true);\n        queue.signal();\n        Util.joinThread(t);\n        assertFalse(queue.getClass().getName(), t.isAlive());\n        assertFalse(fail.get());\n    }","commit_id":"e1bb79260a9bdf478895724ea180cf0c2efb37ff","url":"https://github.com/apache/cassandra"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    final String _pattern     = asts[2].exec(env).getStr();\n    final String _replacement = asts[3].exec(env).getStr();\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    final boolean _ignoreCase = asts[4].exec(env).getNum()==1;\n\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"replacefirst() works on a single column at a time.\" +\n          \"Got \"+ fr.numCols()+\" columns.\");\n    Frame res = null;\n    Vec vec = fr.anyVec();   assert vec != null;\n    if ( !vec.isString() ) throw new IllegalArgumentException(\"replacefirst() requires a string column.\"\n        +\" Received \"+fr.anyVec().get_type_str()+\". Please convert column to strings first.\");\n    else {\n      res = new MRTask() {\n        @Override public void map(Chunk chk, NewChunk newChk){\n          if ( chk instanceof C0DChunk ) // all NAs\n            for (int i = 0; i < chk.len(); i++)\n              newChk.addNA();\n          else {\n//        if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n//          ((CStrChunk) chk).asciiReplaceFirst(newChk);\n//        } else { //UTF requires Java string methods for accuracy\n            BufferedString tmpStr = new BufferedString();\n            for (int i = 0; i < chk._len; i++) {\n              if (chk.isNA(i))\n                newChk.addNA();\n              else {\n                if (_ignoreCase)\n                  newChk.addStr(chk.atStr(tmpStr, i).toString().toLowerCase(Locale.ENGLISH).replaceFirst(_pattern, _replacement));\n                else\n                  newChk.addStr(chk.atStr(tmpStr, i).toString().replaceFirst(_pattern, _replacement));\n              }\n            }\n          }\n        }\n      }.doAll(1, vec).outputFrame();\n    }\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22038,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    final String pattern     = asts[2].exec(env).getStr();\n    final String replacement = asts[3].exec(env).getStr();\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    final boolean ignoreCase = asts[4].exec(env).getNum()==1;\n\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"replacefirst() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = replaceFirstCategoricalCol(v, pattern, replacement, ignoreCase);\n      else\n        nvs[i] = replaceFirstStringCol(v, pattern, replacement, ignoreCase);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    Frame res = null;\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"trim() only works on a single column at a time.\" +\n                                         \"Got \"+ fr.numCols()+\" columns.\");\n    Vec vec = fr.anyVec();   assert vec != null;\n    if ( vec.isString() ) res = trimStringCol(vec);\n    else throw new IllegalArgumentException(\"trim() requires a string column. \"\n        +\"Received \"+fr.anyVec().get_type_str()+\". Please convert column to strings first.\");\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22039,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"trim() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = trimCategoricalCol(v);\n      else\n        nvs[i] = trimStringCol(v);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"tolower() only takes a single column of data. \" +\n                                         \"Got \" + fr.numCols() + \" columns.\");\n    Frame res = null;\n    Vec vec = fr.anyVec();  assert vec != null;\n    if (vec.isString()) res = toLowerStringCol(vec);\n    else throw new IllegalArgumentException(\"tolower() requires a string column. \"\n        + \"Received \" + fr.anyVec().get_type_str() + \". Please convert column to strings first.\");\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22040,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"tolower() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = toLowerCategoricalCol(v);\n      else\n        nvs[i] = toLowerStringCol(v);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private Frame lengthStringCol(Vec vec) {\n    Frame f = new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if( chk instanceof C0DChunk ) { // All NAs\n          for( int i =0; i < chk._len; i++)\n            newChk.addNA();\n        } else if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n          ((CStrChunk) chk).asciiLength(newChk);\n        } else { //UTF requires Java string methods for accuracy\n          BufferedString tmpStr = new BufferedString();\n          for(int i =0; i < chk._len; i++){\n            if (chk.isNA(i))  newChk.addNA();\n            else              newChk.addNum(chk.atStr(tmpStr, i).toString().length(), 0);\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame();\n    return f;\n  }","id":22041,"modified_method":"private Vec lengthStringCol(Vec vec) {\n    return new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if( chk instanceof C0DChunk ) { // All NAs\n          for( int i =0; i < chk._len; i++)\n            newChk.addNA();\n        } else if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n          ((CStrChunk) chk).asciiLength(newChk);\n        } else { //UTF requires Java string methods for accuracy\n          BufferedString tmpStr = new BufferedString();\n          for(int i =0; i < chk._len; i++){\n            if (chk.isNA(i))  newChk.addNA();\n            else              newChk.addNum(chk.atStr(tmpStr, i).toString().length(), 0);\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame().anyVec();\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override ValFrame apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    final String[] pattern = asts[2] instanceof ASTStrList \n      ? ((ASTStrList)asts[2])._strs \n      : new String[]{asts[2].exec(env).getStr()};\n\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"countmatches() only takes a single column of data. \" +\n                                         \"Got \" + fr.numCols() + \" columns.\");\n    Vec vec = fr.anyVec();  assert vec != null;\n    if ( !vec.isString() ) throw new IllegalArgumentException(\"countmatches() requires a string\" +\n        \"column.  Received \"+fr.anyVec().get_type_str()+\". Please convert column to strings first.\");\n    Frame res = new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk) {\n        if ( chk instanceof C0DChunk ) // all NAs\n          for( int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        else {\n          BufferedString tmpStr = new BufferedString();\n          for( int i = 0; i < chk._len; ++i ) {\n            if( chk.isNA(i) ) newChk.addNA();\n            else {\n              int cnt = 0;\n              for (String aPattern : pattern)\n                cnt += StringUtils.countMatches(chk.atStr(tmpStr, i).toString(), aPattern);\n              newChk.addNum(cnt, 0);\n            }\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame();\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22042,"modified_method":"@Override ValFrame apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    final String[] pattern = asts[2] instanceof ASTStrList \n      ? ((ASTStrList)asts[2])._strs \n      : new String[]{asts[2].exec(env).getStr()};\n\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"countmatches() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = countMatchesCategoricalCol(v, pattern);\n      else\n        nvs[i] = countMatchesStringCol(v, pattern);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"toupper() only takes a single column of data. \" +\n                                         \"Got \"+ fr.numCols()+\" columns.\");\n    Frame res = null;\n    Vec vec = fr.anyVec();   assert vec != null;\n    if (vec.isString()) res = toUpperStringCol(vec);\n    else throw new IllegalArgumentException(\"toupper() requires a string column. \"\n        + \"Received \" + fr.anyVec().get_type_str() + \". Please convert column to strings first.\");\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22043,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"toupper() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = toUpperCategoricalCol(v);\n      else\n        nvs[i] = toUpperStringCol(v);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private Frame trimStringCol(Vec vec) {\n    Frame f = new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if ( chk instanceof C0DChunk ) // all NAs\n          for (int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        // Java String.trim() only operates on ASCII whitespace\n        // so UTF-8 safe methods are not needed here.\n        else ((CStrChunk)chk).asciiTrim(newChk);\n      }\n    }.doAll(1, vec).outputFrame();\n    return f;\n  }","id":22044,"modified_method":"private Vec trimStringCol(Vec vec) {\n    return new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if ( chk instanceof C0DChunk ) // all NAs\n          for (int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        // Java String.trim() only operates on ASCII whitespace\n        // so UTF-8 safe methods are not needed here.\n        else ((CStrChunk)chk).asciiTrim(newChk);\n      }\n    }.doAll(1, vec).outputFrame().anyVec();\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    final String _pattern     = asts[2].exec(env).getStr();\n    final String _replacement = asts[3].exec(env).getStr();\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    final boolean _ignoreCase = asts[4].exec(env).getNum()==1;\n\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"replaceall() works on a single column at a time.\" +\n                                         \"Got \"+ fr.numCols()+\" columns.\");\n    Frame res = null;\n    Vec vec = fr.anyVec();   assert vec != null;\n    if ( !vec.isString() ) throw new IllegalArgumentException(\"replaceall() requires a string column.\"\n        +\" Received \"+fr.anyVec().get_type_str()+\". Please convert column to strings first.\");\n    else {\n      res = new MRTask() {\n        @Override public void map(Chunk chk, NewChunk newChk){\n          if ( chk instanceof C0DChunk ) // all NAs\n            for (int i = 0; i < chk.len(); i++)\n              newChk.addNA();\n          else {\n//        if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n//          ((CStrChunk) chk).asciiReplaceAll(newChk);\n//        } else { //UTF requires Java string methods for accuracy\n            BufferedString tmpStr = new BufferedString();\n            for (int i = 0; i < chk._len; i++) {\n              if (chk.isNA(i))\n                newChk.addNA();\n              else {\n                if (_ignoreCase)\n                  newChk.addStr(chk.atStr(tmpStr, i).toString().toLowerCase(Locale.ENGLISH).replaceAll(_pattern, _replacement));\n                else\n                  newChk.addStr(chk.atStr(tmpStr, i).toString().replaceAll(_pattern, _replacement));\n              }\n            }\n          }\n        }\n      }.doAll(1, vec).outputFrame();\n    }\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22045,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    final String pattern     = asts[2].exec(env).getStr();\n    final String replacement = asts[3].exec(env).getStr();\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    final boolean ignoreCase = asts[4].exec(env).getNum()==1;\n\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"replaceall() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = replaceAllCategoricalCol(v, pattern, replacement, ignoreCase);\n      else\n        nvs[i] = replaceAllStringCol(v, pattern, replacement, ignoreCase);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private Frame toLowerStringCol(Vec vec) {\n    Frame f = new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk) {\n        if (chk instanceof C0DChunk) // all NAs\n          for (int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        else if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n          ((CStrChunk) chk).asciiToLower(newChk);\n        } else { //UTF requires Java string methods for accuracy\n          BufferedString tmpStr = new BufferedString();\n          for(int i =0; i < chk._len; i++) {\n            if (chk.isNA(i))\n              newChk.addNA();\n            else\n              newChk.addStr(chk.atStr(tmpStr, i).toString().toLowerCase(Locale.ENGLISH));\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame();\n    return f;\n  }","id":22046,"modified_method":"private Vec toLowerStringCol(Vec vec) {\n    return new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if ( chk instanceof C0DChunk ) // all NAs\n          for (int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        else if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n          ((CStrChunk) chk).asciiToLower(newChk);\n        } else { //UTF requires Java string methods for accuracy\n          BufferedString tmpStr = new BufferedString();\n          for(int i =0; i < chk._len; i++) {\n            if (chk.isNA(i))\n              newChk.addNA();\n            else // Locale.ENGLISH to give the correct results for local insensitive strings\n              newChk.addStr(chk.atStr(tmpStr, i).toString().toLowerCase(Locale.ENGLISH));\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame().anyVec();\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private Frame toUpperStringCol(Vec vec) {\n    Frame f = new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if ( chk instanceof C0DChunk ) // all NAs\n          for (int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        else if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n          ((CStrChunk) chk).asciiToUpper(newChk);\n        } else { //UTF requires Java string methods for accuracy\n          BufferedString tmpStr = new BufferedString();\n          for(int i =0; i < chk._len; i++) {\n            if (chk.isNA(i))\n              newChk.addNA();\n            else // Locale.ENGLISH to give the correct results for local insensitive strings\n              newChk.addStr(chk.atStr(tmpStr, i).toString().toUpperCase(Locale.ENGLISH));\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame();\n    return f;\n  }","id":22047,"modified_method":"private Vec toUpperStringCol(Vec vec) {\n    return new MRTask() {\n      @Override public void map(Chunk chk, NewChunk newChk){\n        if ( chk instanceof C0DChunk ) // all NAs\n          for (int i = 0; i < chk.len(); i++)\n            newChk.addNA();\n        else if (((CStrChunk)chk)._isAllASCII) { // fast-path operations\n          ((CStrChunk) chk).asciiToUpper(newChk);\n        } else { //UTF requires Java string methods for accuracy\n          BufferedString tmpStr = new BufferedString();\n          for(int i =0; i < chk._len; i++) {\n            if (chk.isNA(i))\n              newChk.addNA();\n            else // Locale.ENGLISH to give the correct results for local insensitive strings\n              newChk.addStr(chk.atStr(tmpStr, i).toString().toUpperCase(Locale.ENGLISH));\n          }\n        }\n      }\n    }.doAll(1, vec).outputFrame().anyVec();\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n    Frame res = null;\n    if (fr.numCols() != 1)\n      throw new IllegalArgumentException(\"length() only works on a single column at a time.\" +\n                                         \"Got \"+ fr.numCols()+\" columns.\");\n    Vec vec = fr.anyVec();   assert vec != null;\n    if ( vec.isString() ) res = lengthStringCol(vec);\n    else throw new IllegalArgumentException(\"length() requires a string column. \"\n        +\"Received \"+fr.anyVec().get_type_str()+\". Please convert column to strings first.\");\n    assert res != null;\n    return new ValFrame(res);\n  }","id":22048,"modified_method":"@Override Val apply( Env env, Env.StackHelp stk, AST asts[] ) {\n    Frame fr = stk.track(asts[1].exec(env)).getFrame();\n\n    // Type check\n    for (Vec v : fr.vecs())\n      if (!(v.isCategorical() || v.isString()))\n        throw new IllegalArgumentException(\"length() requires a string or categorical column. \"\n            +\"Received \"+fr.anyVec().get_type_str()\n            +\". Please convert column to a string or categorical first.\");\n\n    // Transform each vec\n    Vec nvs[] = new Vec[fr.numCols()];\n    int i = 0;\n    for(Vec v: fr.vecs()) {\n      if (v.isCategorical())\n        nvs[i] = lengthCategoricalCol(v);\n      else\n        nvs[i] = lengthStringCol(v);\n      i++;\n    }\n\n    return new ValFrame(new Frame(nvs));\n  }","commit_id":"6c9fc7dac6c150b27989c5f4044ebd1df7c6e83e","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n    }","id":22049,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        InMemoryLogBuffer target = new InMemoryLogBuffer();\n        extractLogEntryList( txId, target );\n        return target;\n    }","commit_id":"87d090fbfcc6c84effcb9034acc66f6b8038bf41","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void getCommittedTransaction( long txId, LogBuffer buffer )\n            throws IOException\n    {\n        for ( LogEntry entry : extractLogEntryList( txId ) )\n        {\n            LogIoUtils.writeLogEntry( entry, buffer );\n        }\n    }","id":22050,"modified_method":"public synchronized void getCommittedTransaction( long txId, LogBuffer buffer )\n            throws IOException\n    {\n        extractLogEntryList( txId, buffer );\n    }","commit_id":"87d090fbfcc6c84effcb9034acc66f6b8038bf41","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, Triplet.of( logVersion, masterId, startEntry.getStartPosition() ) );\n    }","id":22051,"modified_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, new TxPosition( logVersion, masterId, startEntry.getIdentifier(),\n                startEntry.getStartPosition() ) );\n    }","commit_id":"87d090fbfcc6c84effcb9034acc66f6b8038bf41","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId,\n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        // Assertions in read?\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions =\n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null &&\n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare )\n            {\n                List<LogEntry> list = transactions.get( entry.getIdentifier() );\n\n                // Since we can start reading at any position in the log it might be the case\n                // that we come across a record which corresponding start record resides\n                // before the position we started reading from. If that should be the case\n                // then skip it since it isn't an important record for us here.\n                if ( list != null )\n                {\n                    list.add( entry );\n                }\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            msgLog.logMessage( \"txId=\" + txId + \" not found in log=\" + expectedVersion, true  );\n            throw new IOException( \"Transaction[\" + txId +\n                    \"] not found in log (\" + expectedVersion/* + \", \" + prevTxId*/ + \") \" +\n                    \"current version is (\" + this.logVersion + \")\" );\n        }\n        logEntryList.add( new LogEntry.Done( logEntryList.get( 0 ).getIdentifier() ) );\n        return logEntryList;\n    }","id":22052,"modified_method":"private LogEntry.Commit extractTransactionFromLog( long txId,\n            long expectedVersion, ReadableByteChannel log, LogBuffer targetBuffer ) throws IOException\n    {\n        // Assertions in read?\n        Map<Integer,List<LogEntry>> transactions =\n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        TxPosition txPosition = txStartPositionCache.get( txId );\n        LogEntryCollector collector = txPosition != null ?\n                new KnownIdentifierCollector( txPosition.identifier, targetBuffer ) :\n                new KnownTxIdCollector( txId, targetBuffer );\n        LogEntry.Commit commitEntry = null;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && commitEntry == null )\n        {\n            if ( collector.collect( entry ) )\n            {\n                if ( entry instanceof LogEntry.Commit )\n                {\n                    commitEntry = (LogEntry.Commit) entry;\n                }\n            }\n        }\n        \n        if ( commitEntry == null )\n        {\n            msgLog.logMessage( \"txId=\" + txId + \" not found in log=\" + expectedVersion, true  );\n            throw new IOException( \"Transaction[\" + txId +\n                    \"] not found in log (\" + expectedVersion/* + \", \" + prevTxId*/ + \") \" +\n                    \"current version is (\" + this.logVersion + \")\" );\n        }\n        \n        if ( targetBuffer != null )\n        {\n            LogIoUtils.writeLogEntry( new LogEntry.Done( collector.getIdentifier() ), targetBuffer );\n        }\n        return commitEntry;\n    }","commit_id":"87d090fbfcc6c84effcb9034acc66f6b8038bf41","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        // TODO: could we refactor this to take a LogBuffer as argument to avoid\n        //       creating the in-memory representation?\n        List<LogEntry> logEntryList = null;\n        Triplet<Long, Integer, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.third() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":22053,"modified_method":"private LogEntry.Commit extractLogEntryList( long txId, LogBuffer targetBuffer ) throws IOException\n    {\n        // TODO: could we refactor this to take a LogBuffer as argument to avoid\n        //       creating the in-memory representation?\n        long version = 0;\n        ReadableByteChannel log = null;\n        TxPosition txPosition = txStartPositionCache.get( txId );\n        try\n        {\n            if ( txPosition != null )\n            {\n                // We have log version and start position cached\n                version = txPosition.version;\n                log = getLogicalLogOrMyself( version, txPosition.position );\n            }\n            else\n            {\n                // We have to look backwards in log files\n                version = findLogContainingTxId( txId )[0];\n                if ( version == -1 )\n                {\n                    throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                                + \"(starting at \" + logVersion\n                                                + \" and searching backwards\" );\n                }\n                log = getLogicalLogOrMyself( version, 0 );\n                long[] header = readAndAssertLogHeader( buffer, log, version );\n                long prevTxId = header[1];\n                assertLogCanContainTx( txId, prevTxId );\n            }\n            return extractTransactionFromLog( txId, version, log, targetBuffer );\n        }\n        finally\n        {\n            if ( log != null )\n            {\n                log.close();\n            }\n        }\n    }","commit_id":"87d090fbfcc6c84effcb9034acc66f6b8038bf41","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n\n        Triplet<Long, Integer, Long> cache = this.txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.second();\n        }\n\n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" +\n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":22054,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n\n        TxPosition cache = txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.masterId;\n        }\n\n        LogEntry.Commit commitEntry = extractLogEntryList( txId, null );\n        if ( commitEntry != null )\n        {\n            return commitEntry.getMasterId();\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" +\n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"87d090fbfcc6c84effcb9034acc66f6b8038bf41","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n    }","id":22055,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        InMemoryLogBuffer target = new InMemoryLogBuffer();\n        extractLogEntryList( txId, target );\n        return target;\n    }","commit_id":"7960a4592e037c8ad22bd4e3cdb58e7505194915","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void getCommittedTransaction( long txId, LogBuffer buffer )\n            throws IOException\n    {\n        for ( LogEntry entry : extractLogEntryList( txId ) )\n        {\n            LogIoUtils.writeLogEntry( entry, buffer );\n        }\n    }","id":22056,"modified_method":"public synchronized void getCommittedTransaction( long txId, LogBuffer buffer )\n            throws IOException\n    {\n        extractLogEntryList( txId, buffer );\n    }","commit_id":"7960a4592e037c8ad22bd4e3cdb58e7505194915","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n\n        Triplet<Long, Integer, Long> cache = this.txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.second();\n        }\n\n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" +\n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":22057,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n\n        TxPosition cache = txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.masterId;\n        }\n\n        LogEntry.Commit commitEntry = extractLogEntryList( txId, null );\n        if ( commitEntry != null )\n        {\n            return commitEntry.getMasterId();\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" +\n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"7960a4592e037c8ad22bd4e3cdb58e7505194915","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        // TODO: could we refactor this to take a LogBuffer as argument to avoid\n        //       creating the in-memory representation?\n        List<LogEntry> logEntryList = null;\n        Triplet<Long, Integer, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.third() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":22058,"modified_method":"private LogEntry.Commit extractLogEntryList( long txId, LogBuffer targetBuffer ) throws IOException\n    {\n        // TODO: could we refactor this to take a LogBuffer as argument to avoid\n        //       creating the in-memory representation?\n        long version = 0;\n        ReadableByteChannel log = null;\n        TxPosition txPosition = txStartPositionCache.get( txId );\n        try\n        {\n            if ( txPosition != null )\n            {\n                // We have log version and start position cached\n                version = txPosition.version;\n                log = getLogicalLogOrMyself( version, txPosition.position );\n            }\n            else\n            {\n                // We have to look backwards in log files\n                version = findLogContainingTxId( txId )[0];\n                if ( version == -1 )\n                {\n                    throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                                + \"(starting at \" + logVersion\n                                                + \" and searching backwards\" );\n                }\n                log = getLogicalLogOrMyself( version, 0 );\n                long[] header = readAndAssertLogHeader( buffer, log, version );\n                long prevTxId = header[1];\n                assertLogCanContainTx( txId, prevTxId );\n            }\n            return extractTransactionFromLog( txId, version, log, targetBuffer );\n        }\n        finally\n        {\n            if ( log != null )\n            {\n                log.close();\n            }\n        }\n    }","commit_id":"7960a4592e037c8ad22bd4e3cdb58e7505194915","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, Triplet.of( logVersion, masterId, startEntry.getStartPosition() ) );\n    }","id":22059,"modified_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, new TxPosition( logVersion, masterId, startEntry.getIdentifier(),\n                startEntry.getStartPosition() ) );\n    }","commit_id":"7960a4592e037c8ad22bd4e3cdb58e7505194915","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId,\n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        // Assertions in read?\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions =\n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null &&\n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare )\n            {\n                List<LogEntry> list = transactions.get( entry.getIdentifier() );\n\n                // Since we can start reading at any position in the log it might be the case\n                // that we come across a record which corresponding start record resides\n                // before the position we started reading from. If that should be the case\n                // then skip it since it isn't an important record for us here.\n                if ( list != null )\n                {\n                    list.add( entry );\n                }\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            msgLog.logMessage( \"txId=\" + txId + \" not found in log=\" + expectedVersion, true  );\n            throw new IOException( \"Transaction[\" + txId +\n                    \"] not found in log (\" + expectedVersion/* + \", \" + prevTxId*/ + \") \" +\n                    \"current version is (\" + this.logVersion + \")\" );\n        }\n        logEntryList.add( new LogEntry.Done( logEntryList.get( 0 ).getIdentifier() ) );\n        return logEntryList;\n    }","id":22060,"modified_method":"private LogEntry.Commit extractTransactionFromLog( long txId,\n            long expectedVersion, ReadableByteChannel log, LogBuffer targetBuffer ) throws IOException\n    {\n        // Assertions in read?\n        Map<Integer,List<LogEntry>> transactions =\n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        TxPosition txPosition = txStartPositionCache.get( txId );\n        LogEntryCollector collector = txPosition != null ?\n                new KnownIdentifierCollector( txPosition.identifier, targetBuffer ) :\n                new KnownTxIdCollector( txId, targetBuffer );\n        LogEntry.Commit commitEntry = null;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && commitEntry == null )\n        {\n            if ( collector.collect( entry ) )\n            {\n                if ( entry instanceof LogEntry.Commit )\n                {\n                    commitEntry = (LogEntry.Commit) entry;\n                }\n            }\n        }\n        \n        if ( commitEntry == null )\n        {\n            msgLog.logMessage( \"txId=\" + txId + \" not found in log=\" + expectedVersion, true  );\n            throw new IOException( \"Transaction[\" + txId +\n                    \"] not found in log (\" + expectedVersion/* + \", \" + prevTxId*/ + \") \" +\n                    \"current version is (\" + this.logVersion + \")\" );\n        }\n        \n        if ( targetBuffer != null )\n        {\n            LogIoUtils.writeLogEntry( new LogEntry.Done( collector.getIdentifier() ), targetBuffer );\n        }\n        return commitEntry;\n    }","commit_id":"7960a4592e037c8ad22bd4e3cdb58e7505194915","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        return wrapInMemoryLogEntryRepresentation( logEntryList );\n    }","id":22061,"modified_method":"public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n        throws IOException\n    {\n        InMemoryLogBuffer target = new InMemoryLogBuffer();\n        extractLogEntryList( txId, target );\n        return target;\n    }","commit_id":"e73aef15de74758ad17283366678c6b6c33a9d90","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n    {\n        // TODO: could we refactor this to take a LogBuffer as argument to avoid\n        //       creating the in-memory representation?\n        List<LogEntry> logEntryList = null;\n        Triplet<Long, Integer, Long> cachedInfo = this.txStartPositionCache.get( txId );\n        if ( cachedInfo != null )\n        {\n            // We have log version and start position cached\n            long version = cachedInfo.first();\n            ReadableByteChannel log = getLogicalLogOrMyself( version, cachedInfo.third() );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        else\n        {\n            // We have to look backwards in log files\n            long version = findLogContainingTxId( txId )[0];\n            if ( version == -1 )\n            {\n                throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                            + \"(starting at \" + logVersion\n                                            + \" and searching backwards\" );\n            }\n\n            ReadableByteChannel log = getLogicalLogOrMyself( version, 0 );\n            long[] header = readAndAssertLogHeader( buffer, log, version );\n            long prevTxId = header[1];\n            assertLogCanContainTx( txId, prevTxId );\n            logEntryList = extractTransactionFromLog( txId, version, log );\n            log.close();\n        }\n        return logEntryList;\n    }","id":22062,"modified_method":"private LogEntry.Commit extractLogEntryList( long txId, LogBuffer targetBuffer ) throws IOException\n    {\n        // TODO: could we refactor this to take a LogBuffer as argument to avoid\n        //       creating the in-memory representation?\n        long version = 0;\n        ReadableByteChannel log = null;\n        TxPosition txPosition = txStartPositionCache.get( txId );\n        try\n        {\n            if ( txPosition != null )\n            {\n                // We have log version and start position cached\n                version = txPosition.version;\n                log = getLogicalLogOrMyself( version, txPosition.position );\n            }\n            else\n            {\n                // We have to look backwards in log files\n                version = findLogContainingTxId( txId )[0];\n                if ( version == -1 )\n                {\n                    throw new RuntimeException( \"txId:\" + txId + \" not found in any logical log \"\n                                                + \"(starting at \" + logVersion\n                                                + \" and searching backwards\" );\n                }\n                log = getLogicalLogOrMyself( version, 0 );\n                long[] header = readAndAssertLogHeader( buffer, log, version );\n                long prevTxId = header[1];\n                assertLogCanContainTx( txId, prevTxId );\n            }\n            return extractTransactionFromLog( txId, version, log, targetBuffer );\n        }\n        finally\n        {\n            if ( log != null )\n            {\n                log.close();\n            }\n        }\n    }","commit_id":"e73aef15de74758ad17283366678c6b6c33a9d90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void getCommittedTransaction( long txId, LogBuffer buffer )\n            throws IOException\n    {\n        for ( LogEntry entry : extractLogEntryList( txId ) )\n        {\n            LogIoUtils.writeLogEntry( entry, buffer );\n        }\n    }","id":22063,"modified_method":"public synchronized void getCommittedTransaction( long txId, LogBuffer buffer )\n            throws IOException\n    {\n        extractLogEntryList( txId, buffer );\n    }","commit_id":"e73aef15de74758ad17283366678c6b6c33a9d90","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, Triplet.of( logVersion, masterId, startEntry.getStartPosition() ) );\n    }","id":22064,"modified_method":"private synchronized void cacheTxStartPosition( long txId, int masterId,\n            LogEntry.Start startEntry )\n    {\n        if ( startEntry.getStartPosition() == -1 )\n        {\n            throw new RuntimeException( \"StartEntry.position is \" + startEntry.getStartPosition() );\n        }\n        txStartPositionCache.put( txId, new TxPosition( logVersion, masterId, startEntry.getIdentifier(),\n                startEntry.getStartPosition() ) );\n    }","commit_id":"e73aef15de74758ad17283366678c6b6c33a9d90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n\n        Triplet<Long, Integer, Long> cache = this.txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.second();\n        }\n\n        List<LogEntry> logEntryList = extractLogEntryList( txId );\n        for ( LogEntry entry : logEntryList )\n        {\n            if ( entry instanceof LogEntry.Commit )\n            {\n                return ((LogEntry.Commit) entry).getMasterId();\n            }\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" +\n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","id":22065,"modified_method":"public synchronized int getMasterIdForCommittedTransaction( long txId ) throws IOException\n    {\n        if ( txId == 1 )\n        {\n            return MASTER_ID_REPRESENTING_NO_MASTER;\n        }\n\n        TxPosition cache = txStartPositionCache.get( txId );\n        if ( cache != null )\n        {\n            return cache.masterId;\n        }\n\n        LogEntry.Commit commitEntry = extractLogEntryList( txId, null );\n        if ( commitEntry != null )\n        {\n            return commitEntry.getMasterId();\n        }\n        throw new RuntimeException( \"Unable to find commit entry in for txId[\" +\n                txId + \"]\" );// in log[\" + version + \"]\" );\n    }","commit_id":"e73aef15de74758ad17283366678c6b6c33a9d90","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId,\n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        // Assertions in read?\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions =\n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null &&\n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command || entry instanceof LogEntry.Prepare )\n            {\n                List<LogEntry> list = transactions.get( entry.getIdentifier() );\n\n                // Since we can start reading at any position in the log it might be the case\n                // that we come across a record which corresponding start record resides\n                // before the position we started reading from. If that should be the case\n                // then skip it since it isn't an important record for us here.\n                if ( list != null )\n                {\n                    list.add( entry );\n                }\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            msgLog.logMessage( \"txId=\" + txId + \" not found in log=\" + expectedVersion, true  );\n            throw new IOException( \"Transaction[\" + txId +\n                    \"] not found in log (\" + expectedVersion/* + \", \" + prevTxId*/ + \") \" +\n                    \"current version is (\" + this.logVersion + \")\" );\n        }\n        logEntryList.add( new LogEntry.Done( logEntryList.get( 0 ).getIdentifier() ) );\n        return logEntryList;\n    }","id":22066,"modified_method":"private LogEntry.Commit extractTransactionFromLog( long txId,\n            long expectedVersion, ReadableByteChannel log, LogBuffer targetBuffer ) throws IOException\n    {\n        // Assertions in read?\n        Map<Integer,List<LogEntry>> transactions =\n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        TxPosition txPosition = txStartPositionCache.get( txId );\n        LogEntryCollector collector = txPosition != null ?\n                new KnownIdentifierCollector( txPosition.identifier, targetBuffer ) :\n                new KnownTxIdCollector( txId, targetBuffer );\n        LogEntry.Commit commitEntry = null;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && commitEntry == null )\n        {\n            if ( collector.collect( entry ) )\n            {\n                if ( entry instanceof LogEntry.Commit )\n                {\n                    commitEntry = (LogEntry.Commit) entry;\n                }\n            }\n        }\n        \n        if ( commitEntry == null )\n        {\n            msgLog.logMessage( \"txId=\" + txId + \" not found in log=\" + expectedVersion, true  );\n            throw new IOException( \"Transaction[\" + txId +\n                    \"] not found in log (\" + expectedVersion/* + \", \" + prevTxId*/ + \") \" +\n                    \"current version is (\" + this.logVersion + \")\" );\n        }\n        \n        if ( targetBuffer != null )\n        {\n            LogIoUtils.writeLogEntry( new LogEntry.Done( collector.getIdentifier() ), targetBuffer );\n        }\n        return commitEntry;\n    }","commit_id":"e73aef15de74758ad17283366678c6b6c33a9d90","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new \"ls\" application.\n     */\n    public Ls()\n    {\n        super();\n        this.addValueType( \"d\", new OptionContext( OptionValueType.MUST,\n            \"Direction filter for relationships: \"\n                + this.directionAlternatives() ) );\n        this.addValueType( \"v\", new OptionContext( OptionValueType.NONE,\n            \"Verbose mode\" ) );\n        this.addValueType( \"q\", new OptionContext( OptionValueType.NONE,\n            \"Quiet mode\" ) );\n        this.addValueType( \"p\", new OptionContext( OptionValueType.NONE,\n            \"Lists properties\" ) );\n        this.addValueType( \"r\", new OptionContext( OptionValueType.NONE,\n            \"Lists relationships\" ) );\n        this.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n            \"Filters property keys/relationship types (regexp string)\" ) );\n        this.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n            \"Temporarily select a connected relationship to do the \"\n                + \"operation on\" ) );\n    }","id":22067,"modified_method":"/**\n     * Constructs a new \"ls\" application.\n     */\n    public Ls()\n    {\n        super();\n        this.addValueType( \"d\", new OptionContext( OptionValueType.MUST,\n            \"Direction filter for relationships: \"\n                + this.directionAlternatives() ) );\n        this.addValueType( \"v\", new OptionContext( OptionValueType.NONE,\n            \"Verbose mode\" ) );\n        this.addValueType( \"q\", new OptionContext( OptionValueType.NONE,\n            \"Quiet mode\" ) );\n        this.addValueType( \"p\", new OptionContext( OptionValueType.NONE,\n            \"Lists properties\" ) );\n        this.addValueType( \"r\", new OptionContext( OptionValueType.NONE,\n            \"Lists relationships\" ) );\n        this.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n            \"Filters property keys/relationship types (regexp string)\" ) );\n        this.addValueType( \"g\", new OptionContext( OptionValueType.MUST,\n            \"Filters property values (regexp string)\" ) );\n        this.addValueType( \"s\", new OptionContext( OptionValueType.NONE,\n            \"Case sensitive filters\" ) );\n        this.addValueType( \"x\", new OptionContext( OptionValueType.NONE,\n            \"Filters will only match if the entire value matches \" +\n            \"(exact match)\" ) );\n        this.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n            \"Temporarily select a connected relationship to do the \"\n                + \"operation on\" ) );\n    }","commit_id":"2509b5a598946139da60f60c54253965c68d86cc","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException, RemoteException\n    {\n        boolean verbose = parser.options().containsKey( \"v\" );\n        boolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n        boolean displayProperties = parser.options().containsKey( \"p\" );\n        boolean displayRelationships = parser.options().containsKey( \"r\" );\n        String filter = parser.options().get( \"f\" );\n        if ( !displayProperties && !displayRelationships )\n        {\n            displayProperties = true;\n            displayRelationships = true;\n        }\n\n        Node node = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            node = this.getCurrentNode( session );\n        }\n        else\n        {\n            node = this.getNodeById( Long\n                .parseLong( parser.arguments().get( 0 ) ) );\n        }\n\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        this.displayProperties( thing, out, displayProperties, displayValues,\n            verbose, filter );\n        this.displayRelationships( parser, thing, out, displayRelationships,\n            verbose, filter );\n        return null;\n    }","id":22068,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException, RemoteException\n    {\n        boolean verbose = parser.options().containsKey( \"v\" );\n        boolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n        boolean displayProperties = parser.options().containsKey( \"p\" );\n        boolean displayRelationships = parser.options().containsKey( \"r\" );\n        boolean caseSensitiveFilters = parser.options().containsKey( \"s\" );\n        boolean exactFilterMatch = parser.options().containsKey( \"x\" );\n        String keyFilter = parser.options().get( \"f\" );\n        String valueFilter = parser.options().get( \"g\" );\n        if ( !displayProperties && !displayRelationships )\n        {\n            displayProperties = true;\n            displayRelationships = true;\n        }\n\n        Node node = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            node = this.getCurrentNode( session );\n        }\n        else\n        {\n            node = this.getNodeById( Long\n                .parseLong( parser.arguments().get( 0 ) ) );\n        }\n\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        if ( displayProperties )\n        {\n            this.displayProperties( thing, out, displayValues, verbose,\n                keyFilter, valueFilter, caseSensitiveFilters,\n                exactFilterMatch );\n        }\n        if ( displayRelationships )\n        {\n            this.displayRelationships( parser, thing, out,\n                verbose, keyFilter, caseSensitiveFilters, exactFilterMatch );\n        }\n        return null;\n    }","commit_id":"2509b5a598946139da60f60c54253965c68d86cc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayRelationships( AppCommandParser parser,\n        NodeOrRelationship thing, Output out, boolean displayRelationships,\n        boolean verbose, String filter ) throws ShellException, RemoteException\n    {\n        if ( !displayRelationships )\n        {\n            return;\n        }\n        String directionFilter = parser.options().get( \"d\" );\n        Direction direction = this.getDirection( directionFilter );\n        boolean displayOutgoing = directionFilter == null\n            || direction == Direction.OUTGOING;\n        boolean displayIncoming = directionFilter == null\n            || direction == Direction.INCOMING;\n        Pattern filterPattern = filter == null ? null : Pattern\n            .compile( filter );\n        if ( displayOutgoing )\n        {\n            for ( Relationship rel : thing\n                .getRelationships( Direction.OUTGOING ) )\n            {\n                if ( filterPattern != null\n                    && !filterPattern.matcher( rel.getType().name() ).matches() )\n                {\n                    continue;\n                }\n                StringBuffer buf = new StringBuffer(\n                    getDisplayNameForCurrentNode() );\n                buf.append( \" --[\" ).append( rel.getType().name() );\n                if ( verbose )\n                {\n                    buf.append( \", \" ).append( rel.getId() );\n                }\n                buf.append( \"]--> \" );\n                buf.append( getDisplayNameForNode( rel.getEndNode() ) );\n                out.println( buf );\n            }\n        }\n        if ( displayIncoming )\n        {\n            for ( Relationship rel : thing\n                .getRelationships( Direction.INCOMING ) )\n            {\n                if ( filterPattern != null\n                    && !filterPattern.matcher( rel.getType().name() ).matches() )\n                {\n                    continue;\n                }\n                StringBuffer buf = new StringBuffer(\n                    getDisplayNameForCurrentNode() );\n                buf.append( \" <--[\" ).append( rel.getType().name() );\n                if ( verbose )\n                {\n                    buf.append( \", \" ).append( rel.getId() );\n                }\n                buf.append( \"]-- \" );\n                buf.append( getDisplayNameForNode( rel.getStartNode() ) );\n                out.println( buf );\n            }\n        }\n    }","id":22069,"modified_method":"private void displayRelationships( AppCommandParser parser,\n        NodeOrRelationship thing, Output out,\n        boolean verbose, String filter, boolean caseSensitiveFilters,\n        boolean exactFilterMatch )\n        throws ShellException, RemoteException\n    {\n        String directionFilter = parser.options().get( \"d\" );\n        Direction direction = this.getDirection( directionFilter );\n        boolean displayOutgoing = directionFilter == null\n            || direction == Direction.OUTGOING;\n        boolean displayIncoming = directionFilter == null\n            || direction == Direction.INCOMING;\n        if ( displayOutgoing )\n        {\n            displayRelationships( thing, out, verbose, Direction.OUTGOING,\n                \"--[\", \"]-->\", filter, caseSensitiveFilters, exactFilterMatch );\n        }\n        if ( displayIncoming )\n        {\n            displayRelationships( thing, out, verbose, Direction.INCOMING,\n                \"<--[\", \"]--\", filter, caseSensitiveFilters, exactFilterMatch );\n        }\n    }","commit_id":"2509b5a598946139da60f60c54253965c68d86cc","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayProperties, boolean displayValues, boolean verbose,\n        String filter ) throws RemoteException\n    {\n        if ( !displayProperties )\n        {\n            return;\n        }\n        int longestKey = this.findLongestKey( thing );\n        Pattern propertyKeyPattern = filter == null ? null : Pattern\n            .compile( filter );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            if ( propertyKeyPattern != null\n                && !propertyKeyPattern.matcher( key ).find() )\n            {\n                continue;\n            }\n\n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                Object value = thing.getProperty( key );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","id":22070,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, String keyFilter,\n        String valueFilter, boolean caseSensitiveFilters,\n        boolean exactFilterMatch ) throws RemoteException\n    {\n        int longestKey = this.findLongestKey( thing );\n        Pattern keyPattern = newPattern( keyFilter, caseSensitiveFilters );\n        Pattern valuePattern = newPattern( valueFilter, caseSensitiveFilters );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            if ( !matches( keyPattern, key, caseSensitiveFilters,\n                exactFilterMatch ) )\n            {\n                continue;\n            }\n            Object value = thing.getProperty( key );\n            if ( !matches( valuePattern, value.toString(),\n                caseSensitiveFilters, exactFilterMatch ) )\n            {\n                continue;\n            }\n\n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","commit_id":"2509b5a598946139da60f60c54253965c68d86cc","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException, RemoteException\n    {\n        boolean verbose = parser.options().containsKey( \"v\" );\n        boolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n        boolean displayProperties = parser.options().containsKey( \"p\" );\n        boolean displayRelationships = parser.options().containsKey( \"r\" );\n        String filter = parser.options().get( \"f\" );\n        if ( !displayProperties && !displayRelationships )\n        {\n            displayProperties = true;\n            displayRelationships = true;\n        }\n\n        Node node = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            node = this.getCurrentNode( session );\n        }\n        else\n        {\n            node = this.getNodeById( Long\n                .parseLong( parser.arguments().get( 0 ) ) );\n        }\n\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        this.displayProperties( thing, out, displayProperties, displayValues,\n            verbose, filter );\n        this.displayRelationships( parser, thing, out, displayRelationships,\n            verbose, filter );\n        return null;\n    }","id":22071,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException, RemoteException\n    {\n        boolean verbose = parser.options().containsKey( \"v\" );\n        boolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n        boolean displayProperties = parser.options().containsKey( \"p\" );\n        boolean displayRelationships = parser.options().containsKey( \"r\" );\n        boolean caseSensitiveFilters = parser.options().containsKey( \"s\" );\n        boolean exactFilterMatch = parser.options().containsKey( \"x\" );\n        String keyFilter = parser.options().get( \"f\" );\n        String valueFilter = parser.options().get( \"g\" );\n        if ( !displayProperties && !displayRelationships )\n        {\n            displayProperties = true;\n            displayRelationships = true;\n        }\n\n        Node node = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            node = this.getCurrentNode( session );\n        }\n        else\n        {\n            node = this.getNodeById( Long\n                .parseLong( parser.arguments().get( 0 ) ) );\n        }\n\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        if ( displayProperties )\n        {\n            this.displayProperties( thing, out, displayValues, verbose,\n                keyFilter, valueFilter, caseSensitiveFilters,\n                exactFilterMatch );\n        }\n        if ( displayRelationships )\n        {\n            this.displayRelationships( parser, thing, out,\n                verbose, keyFilter, caseSensitiveFilters, exactFilterMatch );\n        }\n        return null;\n    }","commit_id":"c6050d58c8e37f33f04098dddf41580a579517b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new \"ls\" application.\n     */\n    public Ls()\n    {\n        super();\n        this.addValueType( \"d\", new OptionContext( OptionValueType.MUST,\n            \"Direction filter for relationships: \"\n                + this.directionAlternatives() ) );\n        this.addValueType( \"v\", new OptionContext( OptionValueType.NONE,\n            \"Verbose mode\" ) );\n        this.addValueType( \"q\", new OptionContext( OptionValueType.NONE,\n            \"Quiet mode\" ) );\n        this.addValueType( \"p\", new OptionContext( OptionValueType.NONE,\n            \"Lists properties\" ) );\n        this.addValueType( \"r\", new OptionContext( OptionValueType.NONE,\n            \"Lists relationships\" ) );\n        this.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n            \"Filters property keys/relationship types (regexp string)\" ) );\n        this.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n            \"Temporarily select a connected relationship to do the \"\n                + \"operation on\" ) );\n    }","id":22072,"modified_method":"/**\n     * Constructs a new \"ls\" application.\n     */\n    public Ls()\n    {\n        super();\n        this.addValueType( \"d\", new OptionContext( OptionValueType.MUST,\n            \"Direction filter for relationships: \"\n                + this.directionAlternatives() ) );\n        this.addValueType( \"v\", new OptionContext( OptionValueType.NONE,\n            \"Verbose mode\" ) );\n        this.addValueType( \"q\", new OptionContext( OptionValueType.NONE,\n            \"Quiet mode\" ) );\n        this.addValueType( \"p\", new OptionContext( OptionValueType.NONE,\n            \"Lists properties\" ) );\n        this.addValueType( \"r\", new OptionContext( OptionValueType.NONE,\n            \"Lists relationships\" ) );\n        this.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n            \"Filters property keys/relationship types (regexp string)\" ) );\n        this.addValueType( \"g\", new OptionContext( OptionValueType.MUST,\n            \"Filters property values (regexp string)\" ) );\n        this.addValueType( \"s\", new OptionContext( OptionValueType.NONE,\n            \"Case sensitive filters\" ) );\n        this.addValueType( \"x\", new OptionContext( OptionValueType.NONE,\n            \"Filters will only match if the entire value matches \" +\n            \"(exact match)\" ) );\n        this.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n            \"Temporarily select a connected relationship to do the \"\n                + \"operation on\" ) );\n    }","commit_id":"c6050d58c8e37f33f04098dddf41580a579517b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayRelationships( AppCommandParser parser,\n        NodeOrRelationship thing, Output out, boolean displayRelationships,\n        boolean verbose, String filter ) throws ShellException, RemoteException\n    {\n        if ( !displayRelationships )\n        {\n            return;\n        }\n        String directionFilter = parser.options().get( \"d\" );\n        Direction direction = this.getDirection( directionFilter );\n        boolean displayOutgoing = directionFilter == null\n            || direction == Direction.OUTGOING;\n        boolean displayIncoming = directionFilter == null\n            || direction == Direction.INCOMING;\n        Pattern filterPattern = filter == null ? null : Pattern\n            .compile( filter );\n        if ( displayOutgoing )\n        {\n            for ( Relationship rel : thing\n                .getRelationships( Direction.OUTGOING ) )\n            {\n                if ( filterPattern != null\n                    && !filterPattern.matcher( rel.getType().name() ).matches() )\n                {\n                    continue;\n                }\n                StringBuffer buf = new StringBuffer(\n                    getDisplayNameForCurrentNode() );\n                buf.append( \" --[\" ).append( rel.getType().name() );\n                if ( verbose )\n                {\n                    buf.append( \", \" ).append( rel.getId() );\n                }\n                buf.append( \"]--> \" );\n                buf.append( getDisplayNameForNode( rel.getEndNode() ) );\n                out.println( buf );\n            }\n        }\n        if ( displayIncoming )\n        {\n            for ( Relationship rel : thing\n                .getRelationships( Direction.INCOMING ) )\n            {\n                if ( filterPattern != null\n                    && !filterPattern.matcher( rel.getType().name() ).matches() )\n                {\n                    continue;\n                }\n                StringBuffer buf = new StringBuffer(\n                    getDisplayNameForCurrentNode() );\n                buf.append( \" <--[\" ).append( rel.getType().name() );\n                if ( verbose )\n                {\n                    buf.append( \", \" ).append( rel.getId() );\n                }\n                buf.append( \"]-- \" );\n                buf.append( getDisplayNameForNode( rel.getStartNode() ) );\n                out.println( buf );\n            }\n        }\n    }","id":22073,"modified_method":"private void displayRelationships( AppCommandParser parser,\n        NodeOrRelationship thing, Output out,\n        boolean verbose, String filter, boolean caseSensitiveFilters,\n        boolean exactFilterMatch )\n        throws ShellException, RemoteException\n    {\n        String directionFilter = parser.options().get( \"d\" );\n        Direction direction = this.getDirection( directionFilter );\n        boolean displayOutgoing = directionFilter == null\n            || direction == Direction.OUTGOING;\n        boolean displayIncoming = directionFilter == null\n            || direction == Direction.INCOMING;\n        if ( displayOutgoing )\n        {\n            displayRelationships( thing, out, verbose, Direction.OUTGOING,\n                \"--[\", \"]-->\", filter, caseSensitiveFilters, exactFilterMatch );\n        }\n        if ( displayIncoming )\n        {\n            displayRelationships( thing, out, verbose, Direction.INCOMING,\n                \"<--[\", \"]--\", filter, caseSensitiveFilters, exactFilterMatch );\n        }\n    }","commit_id":"c6050d58c8e37f33f04098dddf41580a579517b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayProperties, boolean displayValues, boolean verbose,\n        String filter ) throws RemoteException\n    {\n        if ( !displayProperties )\n        {\n            return;\n        }\n        int longestKey = this.findLongestKey( thing );\n        Pattern propertyKeyPattern = filter == null ? null : Pattern\n            .compile( filter );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            if ( propertyKeyPattern != null\n                && !propertyKeyPattern.matcher( key ).find() )\n            {\n                continue;\n            }\n\n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                Object value = thing.getProperty( key );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","id":22074,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, String keyFilter,\n        String valueFilter, boolean caseSensitiveFilters,\n        boolean exactFilterMatch ) throws RemoteException\n    {\n        int longestKey = this.findLongestKey( thing );\n        Pattern keyPattern = newPattern( keyFilter, caseSensitiveFilters );\n        Pattern valuePattern = newPattern( valueFilter, caseSensitiveFilters );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            if ( !matches( keyPattern, key, caseSensitiveFilters,\n                exactFilterMatch ) )\n            {\n                continue;\n            }\n            Object value = thing.getProperty( key );\n            if ( !matches( valuePattern, value.toString(),\n                caseSensitiveFilters, exactFilterMatch ) )\n            {\n                continue;\n            }\n\n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","commit_id":"c6050d58c8e37f33f04098dddf41580a579517b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException, RemoteException\n    {\n        boolean verbose = parser.options().containsKey( \"v\" );\n        boolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n        boolean displayProperties = parser.options().containsKey( \"p\" );\n        boolean displayRelationships = parser.options().containsKey( \"r\" );\n        String filter = parser.options().get( \"f\" );\n        if ( !displayProperties && !displayRelationships )\n        {\n            displayProperties = true;\n            displayRelationships = true;\n        }\n\n        Node node = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            node = this.getCurrentNode( session );\n        }\n        else\n        {\n            node = this.getNodeById( Long\n                .parseLong( parser.arguments().get( 0 ) ) );\n        }\n\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        this.displayProperties( thing, out, displayProperties, displayValues,\n            verbose, filter );\n        this.displayRelationships( parser, thing, out, displayRelationships,\n            verbose, filter );\n        return null;\n    }","id":22075,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException, RemoteException\n    {\n        boolean verbose = parser.options().containsKey( \"v\" );\n        boolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n        boolean displayProperties = parser.options().containsKey( \"p\" );\n        boolean displayRelationships = parser.options().containsKey( \"r\" );\n        boolean caseSensitiveFilters = parser.options().containsKey( \"s\" );\n        boolean exactFilterMatch = parser.options().containsKey( \"x\" );\n        String keyFilter = parser.options().get( \"f\" );\n        String valueFilter = parser.options().get( \"g\" );\n        if ( !displayProperties && !displayRelationships )\n        {\n            displayProperties = true;\n            displayRelationships = true;\n        }\n\n        Node node = null;\n        if ( parser.arguments().isEmpty() )\n        {\n            node = this.getCurrentNode( session );\n        }\n        else\n        {\n            node = this.getNodeById( Long\n                .parseLong( parser.arguments().get( 0 ) ) );\n        }\n\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        if ( displayProperties )\n        {\n            this.displayProperties( thing, out, displayValues, verbose,\n                keyFilter, valueFilter, caseSensitiveFilters,\n                exactFilterMatch );\n        }\n        if ( displayRelationships )\n        {\n            this.displayRelationships( parser, thing, out,\n                verbose, keyFilter, caseSensitiveFilters, exactFilterMatch );\n        }\n        return null;\n    }","commit_id":"d226423bd16a670df6b44b22c4feee268e8cb622","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new \"ls\" application.\n     */\n    public Ls()\n    {\n        super();\n        this.addValueType( \"d\", new OptionContext( OptionValueType.MUST,\n            \"Direction filter for relationships: \"\n                + this.directionAlternatives() ) );\n        this.addValueType( \"v\", new OptionContext( OptionValueType.NONE,\n            \"Verbose mode\" ) );\n        this.addValueType( \"q\", new OptionContext( OptionValueType.NONE,\n            \"Quiet mode\" ) );\n        this.addValueType( \"p\", new OptionContext( OptionValueType.NONE,\n            \"Lists properties\" ) );\n        this.addValueType( \"r\", new OptionContext( OptionValueType.NONE,\n            \"Lists relationships\" ) );\n        this.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n            \"Filters property keys/relationship types (regexp string)\" ) );\n        this.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n            \"Temporarily select a connected relationship to do the \"\n                + \"operation on\" ) );\n    }","id":22076,"modified_method":"/**\n     * Constructs a new \"ls\" application.\n     */\n    public Ls()\n    {\n        super();\n        this.addValueType( \"d\", new OptionContext( OptionValueType.MUST,\n            \"Direction filter for relationships: \"\n                + this.directionAlternatives() ) );\n        this.addValueType( \"v\", new OptionContext( OptionValueType.NONE,\n            \"Verbose mode\" ) );\n        this.addValueType( \"q\", new OptionContext( OptionValueType.NONE,\n            \"Quiet mode\" ) );\n        this.addValueType( \"p\", new OptionContext( OptionValueType.NONE,\n            \"Lists properties\" ) );\n        this.addValueType( \"r\", new OptionContext( OptionValueType.NONE,\n            \"Lists relationships\" ) );\n        this.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n            \"Filters property keys/relationship types (regexp string)\" ) );\n        this.addValueType( \"g\", new OptionContext( OptionValueType.MUST,\n            \"Filters property values (regexp string)\" ) );\n        this.addValueType( \"s\", new OptionContext( OptionValueType.NONE,\n            \"Case sensitive filters\" ) );\n        this.addValueType( \"x\", new OptionContext( OptionValueType.NONE,\n            \"Filters will only match if the entire value matches \" +\n            \"(exact match)\" ) );\n        this.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n            \"Temporarily select a connected relationship to do the \"\n                + \"operation on\" ) );\n    }","commit_id":"d226423bd16a670df6b44b22c4feee268e8cb622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayRelationships( AppCommandParser parser,\n        NodeOrRelationship thing, Output out, boolean displayRelationships,\n        boolean verbose, String filter ) throws ShellException, RemoteException\n    {\n        if ( !displayRelationships )\n        {\n            return;\n        }\n        String directionFilter = parser.options().get( \"d\" );\n        Direction direction = this.getDirection( directionFilter );\n        boolean displayOutgoing = directionFilter == null\n            || direction == Direction.OUTGOING;\n        boolean displayIncoming = directionFilter == null\n            || direction == Direction.INCOMING;\n        Pattern filterPattern = filter == null ? null : Pattern\n            .compile( filter );\n        if ( displayOutgoing )\n        {\n            for ( Relationship rel : thing\n                .getRelationships( Direction.OUTGOING ) )\n            {\n                if ( filterPattern != null\n                    && !filterPattern.matcher( rel.getType().name() ).matches() )\n                {\n                    continue;\n                }\n                StringBuffer buf = new StringBuffer(\n                    getDisplayNameForCurrentNode() );\n                buf.append( \" --[\" ).append( rel.getType().name() );\n                if ( verbose )\n                {\n                    buf.append( \", \" ).append( rel.getId() );\n                }\n                buf.append( \"]--> \" );\n                buf.append( getDisplayNameForNode( rel.getEndNode() ) );\n                out.println( buf );\n            }\n        }\n        if ( displayIncoming )\n        {\n            for ( Relationship rel : thing\n                .getRelationships( Direction.INCOMING ) )\n            {\n                if ( filterPattern != null\n                    && !filterPattern.matcher( rel.getType().name() ).matches() )\n                {\n                    continue;\n                }\n                StringBuffer buf = new StringBuffer(\n                    getDisplayNameForCurrentNode() );\n                buf.append( \" <--[\" ).append( rel.getType().name() );\n                if ( verbose )\n                {\n                    buf.append( \", \" ).append( rel.getId() );\n                }\n                buf.append( \"]-- \" );\n                buf.append( getDisplayNameForNode( rel.getStartNode() ) );\n                out.println( buf );\n            }\n        }\n    }","id":22077,"modified_method":"private void displayRelationships( AppCommandParser parser,\n        NodeOrRelationship thing, Output out,\n        boolean verbose, String filter, boolean caseSensitiveFilters,\n        boolean exactFilterMatch )\n        throws ShellException, RemoteException\n    {\n        String directionFilter = parser.options().get( \"d\" );\n        Direction direction = this.getDirection( directionFilter );\n        boolean displayOutgoing = directionFilter == null\n            || direction == Direction.OUTGOING;\n        boolean displayIncoming = directionFilter == null\n            || direction == Direction.INCOMING;\n        if ( displayOutgoing )\n        {\n            displayRelationships( thing, out, verbose, Direction.OUTGOING,\n                \"--[\", \"]-->\", filter, caseSensitiveFilters, exactFilterMatch );\n        }\n        if ( displayIncoming )\n        {\n            displayRelationships( thing, out, verbose, Direction.INCOMING,\n                \"<--[\", \"]--\", filter, caseSensitiveFilters, exactFilterMatch );\n        }\n    }","commit_id":"d226423bd16a670df6b44b22c4feee268e8cb622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayProperties, boolean displayValues, boolean verbose,\n        String filter ) throws RemoteException\n    {\n        if ( !displayProperties )\n        {\n            return;\n        }\n        int longestKey = this.findLongestKey( thing );\n        Pattern propertyKeyPattern = filter == null ? null : Pattern\n            .compile( filter );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            if ( propertyKeyPattern != null\n                && !propertyKeyPattern.matcher( key ).find() )\n            {\n                continue;\n            }\n\n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                Object value = thing.getProperty( key );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","id":22078,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, String keyFilter,\n        String valueFilter, boolean caseSensitiveFilters,\n        boolean exactFilterMatch ) throws RemoteException\n    {\n        int longestKey = this.findLongestKey( thing );\n        Pattern keyPattern = newPattern( keyFilter, caseSensitiveFilters );\n        Pattern valuePattern = newPattern( valueFilter, caseSensitiveFilters );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            if ( !matches( keyPattern, key, caseSensitiveFilters,\n                exactFilterMatch ) )\n            {\n                continue;\n            }\n            Object value = thing.getProperty( key );\n            if ( !matches( valuePattern, value.toString(),\n                caseSensitiveFilters, exactFilterMatch ) )\n            {\n                continue;\n            }\n\n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","commit_id":"d226423bd16a670df6b44b22c4feee268e8cb622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      return 0;\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":22079,"modified_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      return 0;\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":22080,"modified_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getIncomingEdges(V v) {\n    if (!incomingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","id":22081,"modified_method":"public List<E> getIncomingEdges(V v) {\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.containsKey(source) && outgoingEdges.get(source).containsKey(dest) &&\n        outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.containsKey(dest) && incomingEdges.get(dest).containsKey(source) &&\n        incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.containsKey(source) && (!outgoingEdges.get(source).containsKey(dest) || outgoingEdges.get(source).get(dest).size() == 0)) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.containsKey(dest) && (!incomingEdges.get(dest).containsKey(source) || incomingEdges.get(dest).get(source).size() == 0)) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","id":22082,"modified_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.get(source).get(dest).size() == 0) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.get(dest).get(source).size() == 0) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","id":22083,"modified_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","id":22084,"modified_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      edgeIterator.remove();\n    }","id":22085,"modified_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","id":22086,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getOutgoingEdges(V v) {\n    if (!outgoingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","id":22087,"modified_method":"public List<E> getOutgoingEdges(V v) {\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","id":22088,"modified_method":"public boolean hasNext() {\n      return next != null;\n    }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","id":22089,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","commit_id":"d0bec5b4775f2b94859e4c94c1a10d3a42791337","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      edgeIterator.remove();\n    }","id":22090,"modified_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","commit_id":"7bf0aa1c8887e73936f08d6a5c18824a3df5a1f5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","id":22091,"modified_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","commit_id":"7bf0aa1c8887e73936f08d6a5c18824a3df5a1f5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","id":22092,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","commit_id":"7bf0aa1c8887e73936f08d6a5c18824a3df5a1f5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","id":22093,"modified_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","commit_id":"7bf0aa1c8887e73936f08d6a5c18824a3df5a1f5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","id":22094,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","commit_id":"7bf0aa1c8887e73936f08d6a5c18824a3df5a1f5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","id":22095,"modified_method":"public boolean hasNext() {\n      return next != null;\n    }","commit_id":"7bf0aa1c8887e73936f08d6a5c18824a3df5a1f5","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getIncomingEdges(V v) {\n    if (!incomingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","id":22096,"modified_method":"public List<E> getIncomingEdges(V v) {\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","id":22097,"modified_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","id":22098,"modified_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","id":22099,"modified_method":"public boolean hasNext() {\n      return next != null;\n    }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getOutgoingEdges(V v) {\n    if (!outgoingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","id":22100,"modified_method":"public List<E> getOutgoingEdges(V v) {\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      return 0;\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":22101,"modified_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      return 0;\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":22102,"modified_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      edgeIterator.remove();\n    }","id":22103,"modified_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","id":22104,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","id":22105,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.containsKey(source) && outgoingEdges.get(source).containsKey(dest) &&\n        outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.containsKey(dest) && incomingEdges.get(dest).containsKey(source) &&\n        incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.containsKey(source) && (!outgoingEdges.get(source).containsKey(dest) || outgoingEdges.get(source).get(dest).size() == 0)) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.containsKey(dest) && (!incomingEdges.get(dest).containsKey(source) || incomingEdges.get(dest).get(source).size() == 0)) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","id":22106,"modified_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.get(source).get(dest).size() == 0) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.get(dest).get(source).size() == 0) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","commit_id":"c9dda66f06c7565c1e231806ae566bd322a4b41b","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","id":22107,"modified_method":"public boolean hasNext() {\n      return next != null;\n    }","commit_id":"574014af8b27cf45efa938cfc1250c298eb68671","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","id":22108,"modified_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","commit_id":"574014af8b27cf45efa938cfc1250c298eb68671","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","id":22109,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","commit_id":"574014af8b27cf45efa938cfc1250c298eb68671","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","id":22110,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","commit_id":"574014af8b27cf45efa938cfc1250c298eb68671","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      edgeIterator.remove();\n    }","id":22111,"modified_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","commit_id":"574014af8b27cf45efa938cfc1250c298eb68671","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","id":22112,"modified_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","commit_id":"574014af8b27cf45efa938cfc1250c298eb68671","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory, new HostBridge() );\n    }","id":22113,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory,\n                new HostBridge(),\n                new LogServiceBridge()\n        );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","id":22114,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" +\n                \", org.osgi.service.log; version=4.2.0\"\n        );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiServiceProviderBundle\";\n        InputStream bundleStream = newBundle()\n                .add( ServiceProviderActivator.class )\n                .add( ExampleServiceImpl.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service, org.neo4j.server.osgi.services, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, ServiceProviderActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"service-impl.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n\n        container.shutdown();\n    }","id":22115,"modified_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n\n        ServiceProviderActivator serviceProvider = new ServiceProviderActivator();\n        serviceProvider.produceJar( container.getBundleDirectory(), \"service-impl.jar\");\n        String expectedBundleSymbolicName = serviceProvider.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22116,"modified_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiAwareBundle\";\n        InputStream bundleStream = newBundle()\n                .add( LifecycleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, LifecycleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"aware.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22117,"modified_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n\n        LifecycleActivator lifecycler = new LifecycleActivator();\n        lifecycler.produceJar( container.getBundleDirectory(), \"lifecycler.jar\" );\n        String expectedBundleSymbolicName = lifecycler.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n        String expectedBundleSymbolicName = \"WhovilleBundle\";\n        InputStream bundleStream = newBundle()\n                .add( WhovilleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer, org.neo4j.server.osgi.services, org.osgi.framework, org.osgi.util.tracker\" )\n                .set( Constants.BUNDLE_ACTIVATOR, WhovilleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"whoville.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n\n        container.shutdown();\n    }","id":22118,"modified_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n\n        WhovilleActivator whoville = new WhovilleActivator();\n        whoville.produceJar( container.getBundleDirectory(), \"whoville.jar\");\n        String expectedBundleSymbolicName = whoville.getBundleSymbolicName();\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n\n        container.shutdown();\n    }","id":22119,"modified_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22120,"modified_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n\n        container.shutdown();\n    }","id":22121,"modified_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n    }","commit_id":"ff10eb5d29f9aaf80c72cff859dde7bbe5d0490f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory, new HostBridge() );\n    }","id":22122,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory,\n                new HostBridge(),\n                new LogServiceBridge()\n        );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","id":22123,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" +\n                \", org.osgi.service.log; version=4.2.0\"\n        );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22124,"modified_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiServiceProviderBundle\";\n        InputStream bundleStream = newBundle()\n                .add( ServiceProviderActivator.class )\n                .add( ExampleServiceImpl.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service, org.neo4j.server.osgi.services, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, ServiceProviderActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"service-impl.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n\n        container.shutdown();\n    }","id":22125,"modified_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n\n        ServiceProviderActivator serviceProvider = new ServiceProviderActivator();\n        serviceProvider.produceJar( container.getBundleDirectory(), \"service-impl.jar\");\n        String expectedBundleSymbolicName = serviceProvider.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n\n        container.shutdown();\n    }","id":22126,"modified_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiAwareBundle\";\n        InputStream bundleStream = newBundle()\n                .add( LifecycleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, LifecycleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"aware.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22127,"modified_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n\n        LifecycleActivator lifecycler = new LifecycleActivator();\n        lifecycler.produceJar( container.getBundleDirectory(), \"lifecycler.jar\" );\n        String expectedBundleSymbolicName = lifecycler.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n        String expectedBundleSymbolicName = \"WhovilleBundle\";\n        InputStream bundleStream = newBundle()\n                .add( WhovilleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer, org.neo4j.server.osgi.services, org.osgi.framework, org.osgi.util.tracker\" )\n                .set( Constants.BUNDLE_ACTIVATOR, WhovilleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"whoville.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n\n        container.shutdown();\n    }","id":22128,"modified_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n\n        WhovilleActivator whoville = new WhovilleActivator();\n        whoville.produceJar( container.getBundleDirectory(), \"whoville.jar\");\n        String expectedBundleSymbolicName = whoville.getBundleSymbolicName();\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n\n        container.shutdown();\n    }","id":22129,"modified_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22130,"modified_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"5204be03a70952ac9c68d170414b3c7d6e80581d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory, new HostBridge() );\n    }","id":22131,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory,\n                new HostBridge(),\n                new LogServiceBridge()\n        );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","id":22132,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" +\n                \", org.osgi.service.log; version=4.2.0\"\n        );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiAwareBundle\";\n        InputStream bundleStream = newBundle()\n                .add( LifecycleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, LifecycleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"aware.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22133,"modified_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n\n        LifecycleActivator lifecycler = new LifecycleActivator();\n        lifecycler.produceJar( container.getBundleDirectory(), \"lifecycler.jar\" );\n        String expectedBundleSymbolicName = lifecycler.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n\n        container.shutdown();\n    }","id":22134,"modified_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22135,"modified_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n\n        container.shutdown();\n    }","id":22136,"modified_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n        String expectedBundleSymbolicName = \"WhovilleBundle\";\n        InputStream bundleStream = newBundle()\n                .add( WhovilleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer, org.neo4j.server.osgi.services, org.osgi.framework, org.osgi.util.tracker\" )\n                .set( Constants.BUNDLE_ACTIVATOR, WhovilleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"whoville.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n\n        container.shutdown();\n    }","id":22137,"modified_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n\n        WhovilleActivator whoville = new WhovilleActivator();\n        whoville.produceJar( container.getBundleDirectory(), \"whoville.jar\");\n        String expectedBundleSymbolicName = whoville.getBundleSymbolicName();\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22138,"modified_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiServiceProviderBundle\";\n        InputStream bundleStream = newBundle()\n                .add( ServiceProviderActivator.class )\n                .add( ExampleServiceImpl.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service, org.neo4j.server.osgi.services, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, ServiceProviderActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"service-impl.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n\n        container.shutdown();\n    }","id":22139,"modified_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n\n        ServiceProviderActivator serviceProvider = new ServiceProviderActivator();\n        serviceProvider.produceJar( container.getBundleDirectory(), \"service-impl.jar\");\n        String expectedBundleSymbolicName = serviceProvider.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n    }","commit_id":"70203fbb4839fcbcde1627f8ec25824b217784b5","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","id":22140,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory, BundleActivator... activators )\n    {\n        this.bundleDirectory = bundleDirectory;\n\n        Map<String, Object> configMap = new HashMap<String, Object>();\n\n        if ( activators != null )\n        {\n            List<BundleActivator> list = new ArrayList<BundleActivator>();\n            list.addAll( Arrays.asList( activators ) );\n            configMap.put( FelixConstants.SYSTEMBUNDLE_ACTIVATORS_PROP, list );\n        }\n        configMap.put( Constants.FRAMEWORK_STORAGE, cacheDirectory );\n        configMap.put( Constants.FRAMEWORK_SYSTEMPACKAGES_EXTRA,\n                \"org.neo4j.server.osgi.services; version=1.0.0\" +\n                \", org.osgi.service.log; version=4.2.0\"\n        );\n\n        osgiFramework = new Felix( configMap );\n\n        File bundleDirectoryAsFile = new File( bundleDirectory );\n        if ( !bundleDirectoryAsFile.exists() )\n        {\n            bundleDirectoryAsFile.mkdirs();\n        }\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory, new HostBridge() );\n    }","id":22141,"modified_method":"public OSGiContainer( String bundleDirectory, String cacheDirectory )\n    {\n        this( bundleDirectory, cacheDirectory,\n                new HostBridge(),\n                new LogServiceBridge()\n        );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22142,"modified_method":"@Test\n    public void shouldStartMinimalFramework() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22143,"modified_method":"@Test\n    public void shouldLoadLibraryBundle() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"HelloTinyBundle\";\n        InputStream bundleStream = newBundle()\n                .add( Hello.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.hello\" )\n                .build( withBnd() );\n        File helloJar = new File( container.getBundleDirectory(), \"hello.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( helloJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        // should be bundle 1\n        Bundle helloBundle = container.getBundles()[1];\n\n        assertThat( (String) helloBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( container.getFramework().getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n\n        container.shutdown();\n    }","id":22144,"modified_method":"@Test\n    public void shouldCreateBundleDirectoryDuringConstructionIfItDoesntExist() throws BundleException, InterruptedException\n    {\n        createContainer();\n        File bundleDirectory = new File( container.getBundleDirectory() );\n\n        assertTrue( bundleDirectory.exists() );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiAwareBundle\";\n        InputStream bundleStream = newBundle()\n                .add( LifecycleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.aware, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, LifecycleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"aware.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n\n        container.shutdown();\n    }","id":22145,"modified_method":"@Test\n    public void shouldActivateOSGiAwareBundles() throws Exception\n    {\n        createContainer();\n\n        LifecycleActivator lifecycler = new LifecycleActivator();\n        lifecycler.produceJar( container.getBundleDirectory(), \"lifecycler.jar\" );\n        String expectedBundleSymbolicName = lifecycler.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle awareBundle = container.getBundles()[1];\n\n        assertNotNull( awareBundle );\n\n        assertThat( awareBundle.getState(), is( Bundle.ACTIVE ) );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n        String expectedBundleSymbolicName = \"OSGiServiceProviderBundle\";\n        InputStream bundleStream = newBundle()\n                .add( ServiceProviderActivator.class )\n                .add( ExampleServiceImpl.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.service, org.neo4j.server.osgi.services, org.osgi.framework\" )\n                .set( Constants.BUNDLE_ACTIVATOR, ServiceProviderActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"service-impl.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n\n        container.shutdown();\n    }","id":22146,"modified_method":"@Test\n    public void shouldAllowAccessToOSGiServices() throws Exception\n    {\n        createContainer();\n\n        ServiceProviderActivator serviceProvider = new ServiceProviderActivator();\n        serviceProvider.produceJar( container.getBundleDirectory(), \"service-impl.jar\");\n        String expectedBundleSymbolicName = serviceProvider.getBundleSymbolicName();\n\n        container.start();\n\n        Bundle serviceProviderBundle = container.getBundles()[1];\n        assertNotNull( serviceProviderBundle );\n        assertThat( serviceProviderBundle.getState(), is( Bundle.ACTIVE ) );\n        assertThat( (String) serviceProviderBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        // should have 1 registered service\n        BundleContext bundleContext = serviceProviderBundle.getBundleContext();\n        ServiceReference[] registeredServices = bundleContext.getServiceReferences(\n                ExampleBundleService.class.getName(), null );\n        ExampleBundleService service = (ExampleBundleService) bundleContext.getService( registeredServices[0] );\n        assertThat( service, is( notNullValue() ) );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n\n        container.shutdown();\n    }","id":22147,"modified_method":"@Test\n    public void shouldCreateSystemBundle() throws Exception\n    {\n        createContainer();\n        container.start();\n\n        // The system bundle should always be bundle zero,\n        // and can otherwise be identified by the system\n        // packages it provides\n        Bundle systemBundle = container.getBundles()[0];\n\n        assertThat( (String) systemBundle.getHeaders().get( Constants.EXPORT_PACKAGE ), containsString( \"org.osgi.framework\" ) );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n        String expectedBundleSymbolicName = \"WhovilleBundle\";\n        InputStream bundleStream = newBundle()\n                .add( WhovilleActivator.class )\n                .set( Constants.BUNDLE_SYMBOLICNAME, expectedBundleSymbolicName )\n                .set( Constants.EXPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer\" )\n                .set( Constants.IMPORT_PACKAGE, \"org.neo4j.server.osgi.bundles.consumer, org.neo4j.server.osgi.services, org.osgi.framework, org.osgi.util.tracker\" )\n                .set( Constants.BUNDLE_ACTIVATOR, WhovilleActivator.class.getName() )\n                .build( withBnd() );\n        File awareJar = new File( container.getBundleDirectory(), \"whoville.jar\" );\n        OutputStream jarOutputStream = new FileOutputStream( awareJar );\n        StreamUtils.copyStream( bundleStream, jarOutputStream, true );\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n\n        container.shutdown();\n    }","id":22148,"modified_method":"@Test\n    public void shouldProvideHostServiceToOSGiBundles() throws IOException, BundleException, InvalidSyntaxException, InterruptedException\n    {\n        HortonActivator hortonActivator = new HortonActivator();\n        createContainer( hortonActivator );\n\n        WhovilleActivator whoville = new WhovilleActivator();\n        whoville.produceJar( container.getBundleDirectory(), \"whoville.jar\");\n        String expectedBundleSymbolicName = whoville.getBundleSymbolicName();\n\n        container.start();\n\n        ServiceReference[] registeredServices = container.getFramework().getRegisteredServices();\n        assertNotNull( registeredServices );\n\n        Bundle serviceConsumerBundle = container.getBundles()[1];\n        BundleContext bundleContext = serviceConsumerBundle.getBundleContext();\n        assertThat( (String) serviceConsumerBundle.getHeaders().get( Constants.BUNDLE_SYMBOLICNAME ), is( expectedBundleSymbolicName ) );\n        assertThat( serviceConsumerBundle.getState(), is( Bundle.ACTIVE ) );\n\n        ServiceReference[] hostServices = bundleContext.getServiceReferences(\n                ExampleHostService.class.getName(), null );\n        ExampleHostService service = (ExampleHostService) bundleContext.getService( hostServices[0] );\n        assertNotNull( service );\n\n        assertThat( hortonActivator.whovilleCommunicationCount, is( 1 ) );\n    }","commit_id":"3aa4d27217457cb576ab9b9fc04af1aafe416c2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected List<OrgLabor> importOrgLabors(\n\t\tPortletDataContext portletDataContext, Organization organization) {\n\n\t\tString path = getDependentModelPath(organization, OrgLabor.class);\n\n\t\tList<OrgLabor> orgLabors =\n\t\t\t(List<OrgLabor>)portletDataContext.getZipEntryAsObject(path);\n\n\t\tfor (OrgLabor orgLabor : orgLabors) {\n\t\t\torgLabor.setOrgLaborId(0);\n\t\t}\n\n\t\treturn orgLabors;\n\t}","id":22149,"modified_method":"protected void importOrgLabors(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tOrganization importedOrganization, Organization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\torganization, OrgLabor.class.getSimpleName());\n\n\t\tList<OrgLabor> orgLabors =\n\t\t\t(List<OrgLabor>)portletDataContext.getZipEntryAsObject(path);\n\n\t\tfor (OrgLabor orgLabor : orgLabors) {\n\t\t\torgLabor.setOrgLaborId(0);\n\t\t}\n\n\t\tUsersAdminUtil.updateOrgLabors(\n\t\t\timportedOrganization.getOrganizationId(), orgLabors);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<Phone> importPhones(\n\t\tPortletDataContext portletDataContext, Organization organization) {\n\n\t\tString path = getDependentModelPath(organization, Phone.class);\n\n\t\tList<Phone> phones =\n\t\t\t(List<Phone>)portletDataContext.getZipEntryAsObject(path);\n\n\t\tfor (Phone phone : phones) {\n\t\t\tphone.setPhoneId(0);\n\t\t}\n\n\t\treturn phones;\n\t}","id":22150,"modified_method":"protected void importPhones(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tOrganization importedOrganization, Organization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Element> phoneElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\torganization, Phone.class);\n\n\t\tList<Phone> phones = new ArrayList<Phone>(phoneElements.size());\n\n\t\tfor (Element phoneElement : phoneElements) {\n\n\t\t\tString path = phoneElement.attributeValue(\"path\");\n\n\t\t\tPhone phone = (Phone)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\tphone.setClassPK(importedOrganization.getOrganizationId());\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, phone);\n\n\t\t\tMap<Long, Long> newPrimaryKeysMap =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tPhone.class);\n\n\t\t\tlong phoneId = newPrimaryKeysMap.get(phone.getPrimaryKey());\n\n\t\t\tphone.setPrimaryKey(phoneId);\n\n\t\t\tphones.add(phone);\n\t\t}\n\n\t\tUsersAdminUtil.updatePhones(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), phones);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportEmailAddresses(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows SystemException {\n\n\t\tString path = getDependentModelPath(organization, EmailAddress.class);\n\n\t\tList<EmailAddress> emailAddresses =\n\t\t\tEmailAddressLocalServiceUtil.getEmailAddresses(\n\t\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\t\torganization.getOrganizationId());\n\n\t\tString xml = portletDataContext.toXML(emailAddresses);\n\n\t\tportletDataContext.addZipEntry(path, xml);\n\t}","id":22151,"modified_method":"protected void exportEmailAddresses(\n\t\t\tElement element, PortletDataContext portletDataContext,\n\t\t\tOrganization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<EmailAddress> emailAddresses =\n\t\t\tEmailAddressLocalServiceUtil.getEmailAddresses(\n\t\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\t\torganization.getOrganizationId());\n\n\t\tfor (EmailAddress emailAddress : emailAddresses) {\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\torganization, element, emailAddress,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_EMBEDDED, false);\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, emailAddress);\n\t\t}\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows Exception {\n\n\t\tQueue<Organization> organizations = new LinkedList<Organization>();\n\n\t\torganizations.add(organization);\n\n\t\twhile (!organizations.isEmpty()) {\n\t\t\tOrganization exportedOrganization = organizations.remove();\n\n\t\t\tElement organizationElement =\n\t\t\t\tportletDataContext.getExportDataElement(exportedOrganization);\n\n\t\t\texportAddresses(portletDataContext, exportedOrganization);\n\t\t\texportEmailAddresses(portletDataContext, exportedOrganization);\n\t\t\texportPhones(portletDataContext, exportedOrganization);\n\t\t\texportOrgLabors(portletDataContext, exportedOrganization);\n\t\t\texportWebsites(portletDataContext, exportedOrganization);\n\n\t\t\tportletDataContext.addClassedModel(\n\t\t\t\torganizationElement,\n\t\t\t\tExportImportPathUtil.getModelPath(exportedOrganization),\n\t\t\t\texportedOrganization, UsersAdminPortletDataHandler.NAMESPACE);\n\n\t\t\torganizations.addAll(exportedOrganization.getSuborganizations());\n\t\t}\n\t}","id":22152,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows Exception {\n\n\t\tQueue<Organization> organizations = new LinkedList<Organization>();\n\n\t\torganizations.add(organization);\n\n\t\twhile (!organizations.isEmpty()) {\n\t\t\tOrganization exportedOrganization = organizations.remove();\n\n\t\t\tElement organizationElement =\n\t\t\t\tportletDataContext.getExportDataElement(exportedOrganization);\n\n\t\t\texportAddresses(\n\t\t\t\torganizationElement, portletDataContext, exportedOrganization);\n\t\t\texportEmailAddresses(\n\t\t\t\torganizationElement, portletDataContext, exportedOrganization);\n\t\t\texportOrgLabors(portletDataContext, exportedOrganization);\n\t\t\texportPasswordPolicyRel(\n\t\t\t\torganizationElement, portletDataContext, exportedOrganization);\n\t\t\texportPhones(\n\t\t\t\torganizationElement, portletDataContext, exportedOrganization);\n\t\t\texportWebsites(\n\t\t\t\torganizationElement, portletDataContext, exportedOrganization);\n\n\t\t\tportletDataContext.addClassedModel(\n\t\t\t\torganizationElement,\n\t\t\t\tExportImportPathUtil.getModelPath(exportedOrganization),\n\t\t\t\texportedOrganization, UsersAdminPortletDataHandler.NAMESPACE);\n\n\t\t\torganizations.addAll(exportedOrganization.getSuborganizations());\n\t\t}\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<Address> importAddresses(\n\t\tPortletDataContext portletDataContext, Organization organization) {\n\n\t\tString path = getDependentModelPath(organization, Address.class);\n\n\t\tList<Address> rawEntries =\n\t\t\t(List<Address>)portletDataContext.getZipEntryAsObject(path);\n\n\t\tfor (Address address : rawEntries) {\n\t\t\taddress.setAddressId(0);\n\t\t}\n\n\t\treturn rawEntries;\n\t}","id":22153,"modified_method":"protected void importAddresses(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tOrganization importedOrganization, Organization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Element> addressElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\torganization, Address.class);\n\n\t\tList<Address> addresses = new ArrayList<Address>(\n\t\t\taddressElements.size());\n\n\t\tfor (Element addressElement : addressElements) {\n\n\t\t\tString path = addressElement.attributeValue(\"path\");\n\n\t\t\tAddress address = (Address)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\taddress.setClassPK(importedOrganization.getOrganizationId());\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, address);\n\n\t\t\tMap<Long, Long> newPrimaryKeysMap =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tAddress.class);\n\n\t\t\tlong addressId = newPrimaryKeysMap.get(address.getPrimaryKey());\n\n\t\t\taddress.setPrimaryKey(addressId);\n\n\t\t\taddresses.add(address);\n\t\t}\n\n\t\tUsersAdminUtil.updateAddresses(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), addresses);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<Website> importWebsites(\n\t\tPortletDataContext portletDataContext, Organization organization) {\n\n\t\tString path = getDependentModelPath(organization, Website.class);\n\n\t\tList<Website> websites =\n\t\t\t(List<Website>)portletDataContext.getZipEntryAsObject(path);\n\n\t\tfor (Website website : websites) {\n\t\t\twebsite.setWebsiteId(0);\n\t\t}\n\n\t\treturn websites;\n\t}","id":22154,"modified_method":"protected void importWebsites(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tOrganization importedOrganization, Organization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Element> websiteElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\torganization, Website.class);\n\n\t\tList<Website> websites = new ArrayList<Website>(websiteElements.size());\n\n\t\tfor (Element websiteElement : websiteElements) {\n\n\t\t\tString path = websiteElement.attributeValue(\"path\");\n\n\t\t\tWebsite website = (Website)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\twebsite.setClassPK(importedOrganization.getOrganizationId());\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, website);\n\n\t\t\tMap<Long, Long> newPrimaryKeysMap =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tWebsite.class);\n\n\t\t\tlong websiteId = newPrimaryKeysMap.get(website.getPrimaryKey());\n\n\t\t\twebsite.setPrimaryKey(websiteId);\n\n\t\t\twebsites.add(website);\n\t\t}\n\n\t\tUsersAdminUtil.updateWebsites(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), websites);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(organization.getUserUuid());\n\n\t\tMap<Long, Long> organizationIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tOrganization.class);\n\n\t\tlong parentOrganizationId = MapUtil.getLong(\n\t\t\torganizationIds, organization.getParentOrganizationId(),\n\t\t\torganization.getParentOrganizationId());\n\n\t\tif ((parentOrganizationId !=\n\t\t\t\tOrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID) &&\n\t\t\t(parentOrganizationId == organization.getParentOrganizationId())) {\n\n\t\t\tString parentOrganizationPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Organization.class.getName(),\n\t\t\t\tparentOrganizationId);\n\n\t\t\tOrganization parentOrganization =\n\t\t\t\t(Organization)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\tparentOrganizationPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentOrganization);\n\n\t\t\tparentOrganizationId = MapUtil.getLong(\n\t\t\t\torganizationIds, organization.getParentOrganizationId(),\n\t\t\t\torganization.getParentOrganizationId());\n\t\t}\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\torganization, UsersAdminPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tOrganization existingOrganization =\n\t\t\tOrganizationLocalServiceUtil.fetchOrganizationByUuidAndCompanyId(\n\t\t\t\torganization.getUuid(), portletDataContext.getCompanyId());\n\n\t\tif (existingOrganization == null) {\n\t\t\texistingOrganization =\n\t\t\t\tOrganizationLocalServiceUtil.fetchOrganization(\n\t\t\t\t\tportletDataContext.getCompanyId(), organization.getName());\n\t\t}\n\n\t\tOrganization importedOrganization = null;\n\n\t\tif (existingOrganization == null) {\n\t\t\tserviceContext.setUuid(organization.getUuid());\n\n\t\t\timportedOrganization =\n\t\t\t\tOrganizationLocalServiceUtil.addOrganization(\n\t\t\t\t\tuserId, parentOrganizationId, organization.getName(),\n\t\t\t\t\torganization.getType(), organization.getRegionId(),\n\t\t\t\t\torganization.getCountryId(), organization.getStatusId(),\n\t\t\t\t\torganization.getComments(), false, serviceContext);\n\t\t}\n\t\telse {\n\t\t\timportedOrganization =\n\t\t\t\tOrganizationLocalServiceUtil.updateOrganization(\n\t\t\t\t\tportletDataContext.getCompanyId(),\n\t\t\t\t\texistingOrganization.getOrganizationId(),\n\t\t\t\t\tparentOrganizationId, organization.getName(),\n\t\t\t\t\torganization.getType(), organization.getRegionId(),\n\t\t\t\t\torganization.getCountryId(), organization.getStatusId(),\n\t\t\t\t\torganization.getComments(), false, serviceContext);\n\t\t}\n\n\t\tList<Address> addresses = importAddresses(\n\t\t\tportletDataContext, organization);\n\n\t\tUsersAdminUtil.updateAddresses(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), addresses);\n\n\t\tList<EmailAddress> emailAddresses = importEmailAddresses(\n\t\t\tportletDataContext, organization);\n\n\t\tUsersAdminUtil.updateEmailAddresses(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), emailAddresses);\n\n\t\tList<OrgLabor> orgLabors = importOrgLabors(\n\t\t\tportletDataContext, organization);\n\n\t\tUsersAdminUtil.updateOrgLabors(\n\t\t\timportedOrganization.getOrganizationId(), orgLabors);\n\n\t\tList<Phone> phones = importPhones(portletDataContext, organization);\n\n\t\tUsersAdminUtil.updatePhones(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), phones);\n\n\t\tList<Website> websites = importWebsites(\n\t\t\tportletDataContext, organization);\n\n\t\tUsersAdminUtil.updateWebsites(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), websites);\n\n\t\tportletDataContext.importClassedModel(\n\t\t\torganization, importedOrganization,\n\t\t\tUsersAdminPortletDataHandler.NAMESPACE);\n\t}","id":22155,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(organization.getUserUuid());\n\n\t\tMap<Long, Long> organizationIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tOrganization.class);\n\n\t\tlong parentOrganizationId = MapUtil.getLong(\n\t\t\torganizationIds, organization.getParentOrganizationId(),\n\t\t\torganization.getParentOrganizationId());\n\n\t\tif ((parentOrganizationId !=\n\t\t\t\tOrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID) &&\n\t\t\t(parentOrganizationId == organization.getParentOrganizationId())) {\n\n\t\t\tString parentOrganizationPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Organization.class.getName(),\n\t\t\t\tparentOrganizationId);\n\n\t\t\tOrganization parentOrganization =\n\t\t\t\t(Organization)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\tparentOrganizationPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentOrganization);\n\n\t\t\tparentOrganizationId = MapUtil.getLong(\n\t\t\t\torganizationIds, organization.getParentOrganizationId(),\n\t\t\t\torganization.getParentOrganizationId());\n\t\t}\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\torganization, UsersAdminPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tOrganization existingOrganization =\n\t\t\tOrganizationLocalServiceUtil.fetchOrganizationByUuidAndCompanyId(\n\t\t\t\torganization.getUuid(), portletDataContext.getCompanyId());\n\n\t\tif (existingOrganization == null) {\n\t\t\texistingOrganization =\n\t\t\t\tOrganizationLocalServiceUtil.fetchOrganization(\n\t\t\t\t\tportletDataContext.getCompanyId(), organization.getName());\n\t\t}\n\n\t\tOrganization importedOrganization = null;\n\n\t\tif (existingOrganization == null) {\n\t\t\tserviceContext.setUuid(organization.getUuid());\n\n\t\t\timportedOrganization =\n\t\t\t\tOrganizationLocalServiceUtil.addOrganization(\n\t\t\t\t\tuserId, parentOrganizationId, organization.getName(),\n\t\t\t\t\torganization.getType(), organization.getRegionId(),\n\t\t\t\t\torganization.getCountryId(), organization.getStatusId(),\n\t\t\t\t\torganization.getComments(), false, serviceContext);\n\t\t}\n\t\telse {\n\t\t\timportedOrganization =\n\t\t\t\tOrganizationLocalServiceUtil.updateOrganization(\n\t\t\t\t\tportletDataContext.getCompanyId(),\n\t\t\t\t\texistingOrganization.getOrganizationId(),\n\t\t\t\t\tparentOrganizationId, organization.getName(),\n\t\t\t\t\torganization.getType(), organization.getRegionId(),\n\t\t\t\t\torganization.getCountryId(), organization.getStatusId(),\n\t\t\t\t\torganization.getComments(), false, serviceContext);\n\t\t}\n\n\t\timportAddresses(portletDataContext, importedOrganization, organization);\n\t\timportEmailAddresses(\n\t\t\tportletDataContext, importedOrganization, organization);\n\t\timportOrgLabors(portletDataContext, importedOrganization, organization);\n\t\timportPasswordPolicyRel(\n\t\t\tportletDataContext, importedOrganization, organization);\n\t\timportPhones(portletDataContext, importedOrganization, organization);\n\t\timportWebsites(portletDataContext, importedOrganization, organization);\n\n\t\tportletDataContext.importClassedModel(\n\t\t\torganization, importedOrganization,\n\t\t\tUsersAdminPortletDataHandler.NAMESPACE);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportAddresses(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows SystemException {\n\n\t\tString path = getDependentModelPath(organization, Address.class);\n\n\t\tList<Address> addresses = AddressLocalServiceUtil.getAddresses(\n\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\torganization.getOrganizationId());\n\n\t\tString xml = portletDataContext.toXML(addresses);\n\n\t\tportletDataContext.addZipEntry(path, xml);\n\t}","id":22156,"modified_method":"protected void exportAddresses(\n\t\t\tElement element, PortletDataContext portletDataContext,\n\t\t\tOrganization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Address> addresses = AddressLocalServiceUtil.getAddresses(\n\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\torganization.getOrganizationId());\n\n\t\tfor (Address address : addresses) {\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\torganization, element, address,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_EMBEDDED, false);\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, address);\n\t\t}\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportOrgLabors(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows SystemException {\n\n\t\tString path = getDependentModelPath(organization, OrgLabor.class);\n\n\t\tList<OrgLabor> orgLabors = OrgLaborLocalServiceUtil.getOrgLabors(\n\t\t\torganization.getOrganizationId());\n\n\t\tString xml = portletDataContext.toXML(orgLabors);\n\n\t\tportletDataContext.addZipEntry(path, xml);\n\t}","id":22157,"modified_method":"protected void exportOrgLabors(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<OrgLabor> orgLabors = OrgLaborLocalServiceUtil.getOrgLabors(\n\t\t\torganization.getOrganizationId());\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\torganization, OrgLabor.class.getSimpleName());\n\n\t\tportletDataContext.addZipEntry(path, orgLabors);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportPhones(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows SystemException {\n\n\t\tString path = getDependentModelPath(organization, Phone.class);\n\n\t\tList<Phone> phones = PhoneLocalServiceUtil.getPhones(\n\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\torganization.getOrganizationId());\n\n\t\tString xml = portletDataContext.toXML(phones);\n\n\t\tportletDataContext.addZipEntry(path, xml);\n\t}","id":22158,"modified_method":"protected void exportPhones(\n\t\t\tElement organizationElement, PortletDataContext portletDataContext,\n\t\t\tOrganization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Phone> phones = PhoneLocalServiceUtil.getPhones(\n\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\torganization.getOrganizationId());\n\n\t\tfor (Phone phone : phones) {\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\torganization, organizationElement, phone,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_EMBEDDED, false);\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, phone);\n\t\t}\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<EmailAddress> importEmailAddresses(\n\t\tPortletDataContext portletDataContext, Organization organization) {\n\n\t\tString path = getDependentModelPath(organization, EmailAddress.class);\n\n\t\tList<EmailAddress> emailAddresses =\n\t\t\t(List<EmailAddress>)portletDataContext.getZipEntryAsObject(path);\n\n\t\tfor (EmailAddress emailAddress : emailAddresses) {\n\t\t\temailAddress.setEmailAddressId(0);\n\t\t}\n\n\t\treturn emailAddresses;\n\t}","id":22159,"modified_method":"protected void importEmailAddresses(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tOrganization importedOrganization, Organization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Element> emailAddressElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\torganization, EmailAddress.class);\n\n\t\tList<EmailAddress> emailAddresses = new ArrayList<EmailAddress>(\n\t\t\temailAddressElements.size());\n\n\t\tfor (Element emailAddressElement : emailAddressElements) {\n\n\t\t\tString path = emailAddressElement.attributeValue(\"path\");\n\n\t\t\tEmailAddress emailAddress =\n\t\t\t\t(EmailAddress)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\temailAddress.setClassPK(importedOrganization.getOrganizationId());\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, emailAddress);\n\n\t\t\tMap<Long, Long> newPrimaryKeysMap =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tEmailAddress.class);\n\n\t\t\tlong emailAddressId = newPrimaryKeysMap.get(\n\t\t\t\temailAddress.getPrimaryKey());\n\n\t\t\temailAddress.setPrimaryKey(emailAddressId);\n\n\t\t\temailAddresses.add(emailAddress);\n\t\t}\n\n\t\tUsersAdminUtil.updateEmailAddresses(\n\t\t\tOrganization.class.getName(),\n\t\t\timportedOrganization.getOrganizationId(), emailAddresses);\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void exportWebsites(\n\t\t\tPortletDataContext portletDataContext, Organization organization)\n\t\tthrows SystemException {\n\n\t\tString path = getDependentModelPath(organization, Website.class);\n\n\t\tList<Website> websites = WebsiteLocalServiceUtil.getWebsites(\n\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\torganization.getOrganizationId());\n\n\t\tString xml = portletDataContext.toXML(websites);\n\n\t\tportletDataContext.addZipEntry(path, xml);\n\t}","id":22160,"modified_method":"protected void exportWebsites(\n\t\t\tElement organizationElement, PortletDataContext portletDataContext,\n\t\t\tOrganization organization)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Website> websites = WebsiteLocalServiceUtil.getWebsites(\n\t\t\torganization.getCompanyId(), organization.getModelClassName(),\n\t\t\torganization.getOrganizationId());\n\n\t\tfor (Website website : websites) {\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\torganization, organizationElement, website,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_EMBEDDED, false);\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, website);\n\t\t}\n\t}","commit_id":"9baea429175e6e08a56ab56103c55aac44a6f150","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Phases the genotypes of the given trio. If one of the parents is null, it is considered a parent/child pair.\n     * @param ref: Reference allele\n     * @param alt: Alternative allele\n     * @param mother: Mother's genotype\n     * @param father: Father's genotype\n     * @param child: Child's genotype\n     * @param finalGenotypes: An ArrayList<Genotype> that will be added the genotypes phased by transmission in the following order: Mother, Father, Child\n     * @return\n     */\n    private boolean phaseTrioGenotypes(Allele ref, Allele alt, Genotype mother, Genotype father, Genotype child,ArrayList<Genotype> finalGenotypes) {\n\n        //Get the PL\n        Map<Genotype.Type,Double> motherLikelihoods = getLikelihoodsAsMapSafeNull(mother);\n        Map<Genotype.Type,Double> fatherLikelihoods = getLikelihoodsAsMapSafeNull(father);\n        Map<Genotype.Type,Double> childLikelihoods = getLikelihoodsAsMapSafeNull(child);\n\n        //Prior vars\n        double bestConfigurationLikelihood = 0.0;\n        double norm = 0.0;\n        boolean isMV = false;\n        int bestConfigurationGenotypeDiffs=4;\n        Genotype.Type bestMotherGenotype = getTypeSafeNull(mother);\n        Genotype.Type bestFatherGenotype = getTypeSafeNull(father);\n        Genotype.Type bestChildGenotype = getTypeSafeNull(child);\n\n        //Get the most likely combination\n        //Only check for most likely combination if at least a parent and the child have genotypes\n        if(childLikelihoods.size()>2 && (motherLikelihoods.size() + fatherLikelihoods.size())>3){\n            int mvCount;\n            double configurationLikelihood;\n            int configurationGenotypeDiffs;\n            for(Map.Entry<Genotype.Type,Double> motherGenotype : motherLikelihoods.entrySet()){\n                for(Map.Entry<Genotype.Type,Double> fatherGenotype : fatherLikelihoods.entrySet()){\n                    for(Map.Entry<Genotype.Type,Double> childGenotype : childLikelihoods.entrySet()){\n                        mvCount = mvCountMatrix.get(motherGenotype.getKey()).get(fatherGenotype.getKey()).get(childGenotype.getKey());\n                        configurationLikelihood =  mvCount>0 ? Math.pow(deNovoPrior,mvCount)*motherGenotype.getValue()*fatherGenotype.getValue()*childGenotype.getValue() : (1.0-11*deNovoPrior)*motherGenotype.getValue()*fatherGenotype.getValue()*childGenotype.getValue();\n                        norm += configurationLikelihood;\n                        configurationGenotypeDiffs = countFamilyGenotypeDiff(mother.getType(),father.getType(),child.getType(),motherGenotype.getKey(),fatherGenotype.getKey(),childGenotype.getKey());\n                        //Keep this combination if\n                        //It has a better likelihood\n                        //Or it has the same likelihood but requires less changes from original genotypes\n                        if ((configurationLikelihood > bestConfigurationLikelihood) ||\n                                (configurationLikelihood == bestConfigurationLikelihood && configurationGenotypeDiffs < bestConfigurationGenotypeDiffs)) {\n                            bestConfigurationLikelihood = configurationLikelihood;\n                            bestMotherGenotype = motherGenotype.getKey();\n                            bestFatherGenotype = fatherGenotype.getKey();\n                            bestChildGenotype = childGenotype.getKey();\n                            isMV = mvCount>0;\n                            bestConfigurationGenotypeDiffs=configurationGenotypeDiffs;\n                        }\n                    }\n                }\n            }\n\n            //normalize the best configuration probability\n            bestConfigurationLikelihood = bestConfigurationLikelihood / norm;\n        }\n        else{\n            bestConfigurationLikelihood = NO_TRANSMISSION_PROB;\n        }\n\n        //Get the phased alleles for the genotype configuration\n        TrioPhase phasedTrioGenotypes = transmissionMatrix.get(bestMotherGenotype).get(bestFatherGenotype).get(bestChildGenotype);\n\n        //Return the phased genotypes\n        phasedTrioGenotypes.getPhasedGenotypes(ref,alt,mother,father,child,bestConfigurationLikelihood,finalGenotypes);\n        return isMV;\n\n    }","id":22161,"modified_method":"/**\n     * Phases the genotypes of the given trio. If one of the parents is null, it is considered a parent/child pair.\n     * @param ref: Reference allele\n     * @param alt: Alternative allele\n     * @param mother: Mother's genotype\n     * @param father: Father's genotype\n     * @param child: Child's genotype\n     * @param finalGenotypes: An ArrayList<Genotype> that will be added the genotypes phased by transmission in the following order: Mother, Father, Child\n     * @return\n     */\n    private boolean phaseTrioGenotypes(Allele ref, Allele alt, Genotype mother, Genotype father, Genotype child,ArrayList<Genotype> finalGenotypes) {\n\n        //Get the PL\n        Map<Genotype.Type,Double> motherLikelihoods = getLikelihoodsAsMapSafeNull(mother);\n        Map<Genotype.Type,Double> fatherLikelihoods = getLikelihoodsAsMapSafeNull(father);\n        Map<Genotype.Type,Double> childLikelihoods = getLikelihoodsAsMapSafeNull(child);\n\n        //Prior vars\n        double bestConfigurationLikelihood = 0.0;\n        double norm = 0.0;\n        int configuration_index =0;\n        ArrayList<Boolean> isMV = new ArrayList<Boolean>();\n        isMV.add(false);\n        ArrayList<Genotype.Type> bestMotherGenotype = new ArrayList<Genotype.Type>();\n        bestMotherGenotype.add(getTypeSafeNull(mother));\n        ArrayList<Genotype.Type> bestFatherGenotype = new ArrayList<Genotype.Type>();\n        bestFatherGenotype.add(getTypeSafeNull(father));\n        ArrayList<Genotype.Type> bestChildGenotype = new ArrayList<Genotype.Type>();\n        bestChildGenotype.add(getTypeSafeNull(child));\n\n        //Get the most likely combination\n        //Only check for most likely combination if at least a parent and the child have genotypes\n        if(childLikelihoods.size()>2 && (motherLikelihoods.size() + fatherLikelihoods.size())>3){\n            int mvCount;\n            double configurationLikelihood;\n            for(Map.Entry<Genotype.Type,Double> motherGenotype : motherLikelihoods.entrySet()){\n                for(Map.Entry<Genotype.Type,Double> fatherGenotype : fatherLikelihoods.entrySet()){\n                    for(Map.Entry<Genotype.Type,Double> childGenotype : childLikelihoods.entrySet()){\n                        mvCount = mvCountMatrix.get(motherGenotype.getKey()).get(fatherGenotype.getKey()).get(childGenotype.getKey());\n                        configurationLikelihood =  mvCount>0 ? Math.pow(deNovoPrior,mvCount)*motherGenotype.getValue()*fatherGenotype.getValue()*childGenotype.getValue() : (1.0-11*deNovoPrior)*motherGenotype.getValue()*fatherGenotype.getValue()*childGenotype.getValue();\n                        norm += configurationLikelihood;\n                        //Keep this combination if\n                        //It has a better likelihood\n                        //Or it has the same likelihood but requires less changes from original genotypes\n                        if (configurationLikelihood > bestConfigurationLikelihood){\n                            bestConfigurationLikelihood = configurationLikelihood;\n                            isMV.clear();\n                            isMV.add(mvCount>0);\n                            bestMotherGenotype.clear();\n                            bestMotherGenotype.add(motherGenotype.getKey());\n                            bestFatherGenotype.clear();\n                            bestFatherGenotype.add(fatherGenotype.getKey());\n                            bestChildGenotype.clear();\n                            bestChildGenotype.add(childGenotype.getKey());\n                        }\n                        else if(configurationLikelihood == bestConfigurationLikelihood) {\n                            bestMotherGenotype.add(motherGenotype.getKey());\n                            bestFatherGenotype.add(fatherGenotype.getKey());\n                            bestChildGenotype.add(childGenotype.getKey());\n                            isMV.add(mvCount>0);\n                        }\n                    }\n                }\n            }\n\n            //normalize the best configuration probability\n            bestConfigurationLikelihood = bestConfigurationLikelihood / norm;\n\n            //In case of multiple equally likely combinations, take a random one\n            if(bestMotherGenotype.size()>1){\n                configuration_index = rand.nextInt(bestMotherGenotype.size()-1);\n            }\n\n        }\n        else{\n            bestConfigurationLikelihood = NO_TRANSMISSION_PROB;\n        }\n\n            TrioPhase phasedTrioGenotypes = transmissionMatrix.get(bestMotherGenotype.get(configuration_index)).get(bestFatherGenotype.get(configuration_index)).get(bestChildGenotype.get(configuration_index));\n\n            //Return the phased genotypes\n            phasedTrioGenotypes.getPhasedGenotypes(ref,alt,mother,father,child,bestConfigurationLikelihood,finalGenotypes);\n            return isMV.get(configuration_index);\n\n    }","commit_id":"1f044faedd01317b71c3abf91ac935beb6581223","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Genotype getPhasedGenotype(Allele refAllele, Allele altAllele, Genotype genotype, double transmissionProb, Genotype phasedGenotype){\n\n           //Handle null, missing and unavailable genotypes\n           //Note that only cases where a null/missing/unavailable genotype was passed in the first place can lead to a null/missing/unavailable\n           //genotype so it is safe to return the original genotype in this case.\n           if(genotype == null || !phasedGenotype.isAvailable() || phasedGenotype.isNoCall())\n               return genotype;\n\n           //Add the transmission probability\n           Map<String, Object> genotypeAttributes = new HashMap<String, Object>();\n           genotypeAttributes.putAll(genotype.getAttributes());\n           if(transmissionProb>NO_TRANSMISSION_PROB)\n                genotypeAttributes.put(TRANSMISSION_PROBABILITY_TAG_NAME, MathUtils.probabilityToPhredScale(1-(transmissionProb)));\n\n           ArrayList<Allele> phasedAlleles = new ArrayList<Allele>(2);\n           for(Allele allele : phasedGenotype.getAlleles()){\n               if(allele.isReference())\n                   phasedAlleles.add(refAllele);\n               else if(allele.isNonReference())\n                   phasedAlleles.add(altAllele);\n               //At this point there should not be any other alleles left\n               else\n                   throw new UserException(String.format(\"BUG: Unexpected allele: %s. Please report.\",allele.toString()));\n\n           }\n\n           //Compute the new Log10Error if the genotype is different from the original genotype\n           double negLog10Error;\n           if(genotype.getType() == phasedGenotype.getType())\n               negLog10Error = genotype.getNegLog10PError();\n           else\n              negLog10Error =  genotype.getLikelihoods().getNegLog10GQ(phasedGenotype.getType());\n\n           return new Genotype(genotype.getSampleName(), phasedAlleles, negLog10Error, null, genotypeAttributes, phasedGenotype.isPhased());\n       }","id":22162,"modified_method":"private Genotype getPhasedGenotype(Allele refAllele, Allele altAllele, Genotype genotype, double transmissionProb, Genotype phasedGenotype){\n\n           int phredScoreTransmission = -1;\n           if(transmissionProb != NO_TRANSMISSION_PROB)\n                phredScoreTransmission = MathUtils.probabilityToPhredScale(1-(transmissionProb));\n\n           //Handle null, missing and unavailable genotypes\n           //Note that only cases where a null/missing/unavailable genotype was passed in the first place can lead to a null/missing/unavailable\n           //genotype so it is safe to return the original genotype in this case.\n           //In addition, if the phasing confidence is 0, then return the unphased, original genotypes.\n           if(phredScoreTransmission ==0 || genotype == null || !phasedGenotype.isAvailable() || phasedGenotype.isNoCall())\n               return genotype;\n\n           //Add the transmission probability\n           Map<String, Object> genotypeAttributes = new HashMap<String, Object>();\n           genotypeAttributes.putAll(genotype.getAttributes());\n           if(transmissionProb>NO_TRANSMISSION_PROB)\n                genotypeAttributes.put(TRANSMISSION_PROBABILITY_TAG_NAME, phredScoreTransmission);\n\n           ArrayList<Allele> phasedAlleles = new ArrayList<Allele>(2);\n           for(Allele allele : phasedGenotype.getAlleles()){\n               if(allele.isReference())\n                   phasedAlleles.add(refAllele);\n               else if(allele.isNonReference())\n                   phasedAlleles.add(altAllele);\n               //At this point there should not be any other alleles left\n               else\n                   throw new UserException(String.format(\"BUG: Unexpected allele: %s. Please report.\",allele.toString()));\n\n           }\n\n           //Compute the new Log10Error if the genotype is different from the original genotype\n           double negLog10Error;\n           if(genotype.getType() == phasedGenotype.getType())\n               negLog10Error = genotype.getNegLog10PError();\n           else\n              negLog10Error =  genotype.getLikelihoods().getNegLog10GQ(phasedGenotype.getType());\n\n           return new Genotype(genotype.getSampleName(), phasedAlleles, negLog10Error, null, genotypeAttributes, phasedGenotype.isPhased());\n       }","commit_id":"1f044faedd01317b71c3abf91ac935beb6581223","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Deployment(testable = false)\n    public static Archive<?> deployment() {\n        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, \"jaxws-basic-ejb.jar\")\n                .addClasses(EndpointIface.class, EJBEndpoint.class, HelloObject.class);\n        return jar;\n    }","id":22163,"modified_method":"@Deployment(testable = false)\n    public static Archive<?> deployment() {\n        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, \"jaxws-basic-ejb.jar\")\n                .addClasses(EndpointIface.class, EJBEndpoint.class, HelloObject.class);\n        // EJBEndpoint#helloError needs getClassLoader permission for SOAPFactory.newInstance() invocation which is not supposed(??? at least it seems so) to be called from deployments\n        jar.addAsManifestResource(createPermissionsXmlAsset(new RuntimePermission(\"getClassLoader\")), \"permissions.xml\");\n        return jar;\n    }","commit_id":"a5613b6ad885c4a27b99cdfa3695318c7ce84273","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment (testable=false)\n    public static Archive<?> deployment() {\n\n        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, \"ws-serviceref-example.jar\")\n            .addClasses(EJB3Bean.class, EndpointInterface.class);\n\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"ws-serviceref-example-servlet-client.war\")\n            .addClasses(EndpointInterface.class, EndpointService.class, ServletClient.class)\n            .addAsWebInfResource(ServiceRefEarTestCase.class.getPackage(), \"web.xml\", \"web.xml\")\n            .addAsWebInfResource(ServiceRefEarTestCase.class.getPackage(), \"jboss-web.xml\", \"jboss-web.xml\");\n\n        String wsdl = FileUtils.readFile(ServiceRefEarTestCase.class, \"TestService.wsdl\");\n        final Properties properties = new Properties();\n        properties.putAll(System.getProperties());\n        if(properties.containsKey(\"node0\")) {\n            properties.put(\"node0\", NetworkUtils.formatPossibleIpv6Address((String) properties.get(\"node0\")));\n        }\n        war.addAsWebInfResource(new StringAsset(PropertiesValueResolver.replaceProperties(wsdl, properties)), \"wsdl/TestService.wsdl\");\n\n        EnterpriseArchive ear = ShrinkWrap.create(EnterpriseArchive.class, \"ws-serviceref-example.ear\")\n            .addAsModule(jar)\n            .addAsModule(war);\n\n        return ear;\n    }","id":22164,"modified_method":"@Deployment (testable=false)\n    public static Archive<?> deployment() {\n\n        JavaArchive jar = ShrinkWrap.create(JavaArchive.class, \"ws-serviceref-example.jar\")\n            .addClasses(EJB3Bean.class, EndpointInterface.class);\n\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"ws-serviceref-example-servlet-client.war\")\n            .addClasses(EndpointInterface.class, EndpointService.class, ServletClient.class)\n            .addAsWebInfResource(ServiceRefEarTestCase.class.getPackage(), \"web.xml\", \"web.xml\")\n            .addAsWebInfResource(ServiceRefEarTestCase.class.getPackage(), \"jboss-web.xml\", \"jboss-web.xml\");\n\n        String wsdl = FileUtils.readFile(ServiceRefEarTestCase.class, \"TestService.wsdl\");\n        final Properties properties = new Properties();\n        properties.putAll(System.getProperties());\n        final String node0 = NetworkUtils.formatPossibleIpv6Address((String)properties.get(\"node0\"));\n        if(properties.containsKey(\"node0\")) {\n            properties.put(\"node0\", node0);\n        }\n        war.addAsWebInfResource(new StringAsset(PropertiesValueResolver.replaceProperties(wsdl, properties)), \"wsdl/TestService.wsdl\");\n\n        EnterpriseArchive ear = ShrinkWrap.create(EnterpriseArchive.class, \"ws-serviceref-example.ear\")\n            .addAsModule(jar)\n            .addAsModule(war);\n        // all the following permissions are needed because EndpointService directly extends javax.xml.ws.Service class\n        // and CXF guys are not willing to add more privileged blocks into their code, thus deployments need to have\n        // the following permissions (note that the wsdl.properties permission is needed by wsdl4j)\n        ear.addAsManifestResource(createPermissionsXmlAsset(\n                new FilePermission(System.getProperty(\"java.home\") + File.separator + \"lib\" + File.separator + \"wsdl.properties\", \"read\"),\n                new PropertyPermission(\"user.dir\", \"read\"),\n                new RuntimePermission(\"getClassLoader\"),\n                new RuntimePermission(\"org.apache.cxf.permission\", \"resolveUri\"),\n                new RuntimePermission(\"createClassLoader\"),\n                new RuntimePermission(\"accessDeclaredMembers\"),\n                new SocketPermission(node0 + \":8080\", \"connect,resolve\")), \"jboss-permissions.xml\");\n\n        return ear;\n    }","commit_id":"a5613b6ad885c4a27b99cdfa3695318c7ce84273","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment (name=\"servletClient\", testable=false)\n    public static WebArchive clientDeployment() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"ws-serviceref-example-servlet-client.war\")\n            .addClasses(EndpointInterface.class, EndpointService.class, ServletClient.class)\n                .addAsWebInfResource(ServiceRefSevletTestCase.class.getPackage(), \"web.xml\", \"web.xml\")\n                .addAsWebInfResource(ServiceRefSevletTestCase.class.getPackage(), \"jboss-web.xml\", \"jboss-web.xml\");\n\n        String wsdl = FileUtils.readFile(ServiceRefSevletTestCase.class, \"TestService.wsdl\");\n        final Properties properties = new Properties();\n        properties.putAll(System.getProperties());\n        if(properties.containsKey(\"node0\")) {\n            properties.put(\"node0\", NetworkUtils.formatPossibleIpv6Address((String) properties.get(\"node0\")));\n        }\n        war.addAsWebInfResource(new StringAsset(PropertiesValueResolver.replaceProperties(wsdl, properties)), \"wsdl/TestService.wsdl\");\n        return war;\n    }","id":22165,"modified_method":"@Deployment (name=\"servletClient\", testable=false)\n    public static WebArchive clientDeployment() {\n        WebArchive war = ShrinkWrap.create(WebArchive.class, \"ws-serviceref-example-servlet-client.war\")\n            .addClasses(EndpointInterface.class, EndpointService.class, ServletClient.class)\n                .addAsWebInfResource(ServiceRefSevletTestCase.class.getPackage(), \"web.xml\", \"web.xml\")\n                .addAsWebInfResource(ServiceRefSevletTestCase.class.getPackage(), \"jboss-web.xml\", \"jboss-web.xml\");\n\n        String wsdl = FileUtils.readFile(ServiceRefSevletTestCase.class, \"TestService.wsdl\");\n        final Properties properties = new Properties();\n        properties.putAll(System.getProperties());\n        final String node0 = NetworkUtils.formatPossibleIpv6Address((String)properties.get(\"node0\"));\n        if(properties.containsKey(\"node0\")) {\n            properties.put(\"node0\", node0);\n        }\n        war.addAsWebInfResource(new StringAsset(PropertiesValueResolver.replaceProperties(wsdl, properties)), \"wsdl/TestService.wsdl\");\n        // all the following permissions are needed because EndpointService directly extends javax.xml.ws.Service class\n        // and CXF guys are not willing to add more privileged blocks into their code, thus deployments need to have\n        // the following permissions (note that the wsdl.properties permission is needed by wsdl4j)\n        war.addAsManifestResource(createPermissionsXmlAsset(\n                new FilePermission(System.getProperty(\"java.home\") + File.separator + \"lib\" + File.separator + \"wsdl.properties\", \"read\"),\n                new PropertyPermission(\"user.dir\", \"read\"),\n                new RuntimePermission(\"getClassLoader\"),\n                new RuntimePermission(\"org.apache.cxf.permission\", \"resolveUri\"),\n                new RuntimePermission(\"createClassLoader\"),\n                new RuntimePermission(\"accessDeclaredMembers\"),\n                new SocketPermission(node0 + \":8080\", \"connect,resolve\")), \"jboss-permissions.xml\");\n        return war;\n    }","commit_id":"a5613b6ad885c4a27b99cdfa3695318c7ce84273","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Deployment\n    public static JavaArchive deployment() {\n        String wsdl = FileUtils.readFile(ServiceRefTestCase.class, \"TestService.wsdl\");\n\n        final Properties properties = new Properties();\n        properties.putAll(System.getProperties());\n        if(properties.containsKey(\"node0\")) {\n            properties.put(\"node0\", NetworkUtils.formatPossibleIpv6Address((String)properties.get(\"node0\")));\n        }\n        return ShrinkWrap.create(JavaArchive.class, \"ws-serviceref-example.jar\")\n                .addClasses(EJB3Bean.class, EndpointInterface.class, EndpointService.class, StatelessBean.class, StatelessRemote.class, CdiBean.class)\n                .addAsManifestResource(ServiceRefTestCase.class.getPackage(), \"ejb-jar.xml\", \"ejb-jar.xml\")\n                .addAsManifestResource(ServiceRefTestCase.class.getPackage(), \"jboss-ejb3.xml\", \"jboss-ejb3.xml\")\n                .addAsManifestResource(new StringAsset(PropertiesValueResolver.replaceProperties(wsdl, properties)), \"wsdl/TestService.wsdl\")\n                .addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\");\n    }","id":22166,"modified_method":"@Deployment\n    public static JavaArchive deployment() {\n        String wsdl = FileUtils.readFile(ServiceRefTestCase.class, \"TestService.wsdl\");\n\n        final Properties properties = new Properties();\n        properties.putAll(System.getProperties());\n        final String node0 = NetworkUtils.formatPossibleIpv6Address((String)properties.get(\"node0\"));\n        if(properties.containsKey(\"node0\")) {\n            properties.put(\"node0\", node0);\n        }\n        return ShrinkWrap.create(JavaArchive.class, \"ws-serviceref-example.jar\")\n                .addClasses(EJB3Bean.class, EndpointInterface.class, EndpointService.class, StatelessBean.class, StatelessRemote.class, CdiBean.class)\n                .addAsManifestResource(ServiceRefTestCase.class.getPackage(), \"ejb-jar.xml\", \"ejb-jar.xml\")\n                .addAsManifestResource(ServiceRefTestCase.class.getPackage(), \"jboss-ejb3.xml\", \"jboss-ejb3.xml\")\n                .addAsManifestResource(new StringAsset(PropertiesValueResolver.replaceProperties(wsdl, properties)), \"wsdl/TestService.wsdl\")\n                .addAsManifestResource(EmptyAsset.INSTANCE, \"beans.xml\")\n                // all the following permissions are needed because EndpointService directly extends javax.xml.ws.Service class\n                // and CXF guys are not willing to add more privileged blocks into their code, thus deployments need to have\n                // the following permissions (note that the wsdl.properties permission is needed by wsdl4j)\n                .addAsManifestResource(createPermissionsXmlAsset(\n                        new FilePermission(System.getProperty(\"java.home\") + File.separator + \"lib\" + File.separator + \"wsdl.properties\", \"read\"),\n                        new PropertyPermission(\"user.dir\", \"read\"),\n                        new RuntimePermission(\"getClassLoader\"),\n                        new RuntimePermission(\"org.apache.cxf.permission\", \"resolveUri\"),\n                        new RuntimePermission(\"createClassLoader\"),\n                        new RuntimePermission(\"accessDeclaredMembers\"),\n                        new SocketPermission(node0 + \":8080\", \"connect,resolve\")\n                ), \"jboss-permissions.xml\");\n    }","commit_id":"a5613b6ad885c4a27b99cdfa3695318c7ce84273","url":"https://github.com/wildfly/wildfly"},{"original_method":"public String getMatchedIpAddr(Event e) {\n        PassiveEvent pe = getPassiveEventByUei(e.getUei());\n        String tokenValue = null;\n        String eventToken = pe.getStatusKey().getIpaddr().getEventToken().getName();\n        if (pe.getStatusKey().getNodeLabel().getEventToken().getIsParm() == true) {\n            tokenValue = EventUtil.getNamedParmValue(\"parm[\"+ eventToken +\"]\", e);\n        } else {\n            tokenValue = getEventField(eventToken, e);\n        }\n        return tokenValue;\n    }","id":22167,"modified_method":"/**\n     * This method determines the nodelabel value by using the config to determine this value\n     * based on field and parm values of a passive event.\n     * \n     * @param e\n     * @return The correct value of the ipaddr portion of the status key\n     */\n    public String getMatchedIpAddr(Event e) {\n        String eventToken = getPassiveEventByUei(e.getUei()).getStatusKey().getIpaddr().getEventToken().getName();\n        String expr = getPassiveEventByUei(e.getUei()).getStatusKey().getIpaddr().getEventToken().getValue();\n        boolean isParm = getPassiveEventByUei(e.getUei()).getStatusKey().getIpaddr().getEventToken().getIsParm();\n        \n        String tokenValue = getValueFromFieldOrParm(e, eventToken, isParm);\n        return parseExpression(tokenValue, expr);\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getEventField(String eventToken, Event e) {\n        if (eventToken.equalsIgnoreCase(\"descr\")) {\n            return e.getDescr();\n        } else if (eventToken.equalsIgnoreCase(\"distPoller\")) {\n            return e.getDistPoller();\n        } else if (eventToken.equalsIgnoreCase(\"host\")) {\n            return e.getHost();\n        } else if (eventToken.equalsIgnoreCase(\"ifAlias\")) {\n            return e.getIfAlias();\n        } else if (eventToken.equalsIgnoreCase(\"interface\")) {\n            return e.getInterface();\n        } else if (eventToken.equalsIgnoreCase(\"service\")) {\n            return e.getService();\n        } else if (eventToken.equalsIgnoreCase(\"severity\")) {\n            return e.getSeverity();\n        } else if (eventToken.equalsIgnoreCase(\"snmpHost\")) {\n            return e.getSnmphost();\n        } else if (eventToken.equalsIgnoreCase(\"source\")) {\n            return e.getSource();\n        } else if (eventToken.equalsIgnoreCase(\"logGroup\")) {\n            return e.getLogmsg().getContent();\n        } else if (eventToken.equalsIgnoreCase(\"masterStation\")) {\n            return e.getMasterStation();\n        } else if (eventToken.equalsIgnoreCase(\"mouseOverText\")) {\n            return e.getMouseovertext();\n        } else if (eventToken.equalsIgnoreCase(\"operInstruct\")) {\n            return e.getOperinstruct();\n        }\n        return null;\n    }","id":22168,"modified_method":"/**\n     * Wish there was a better way to do this!\n     * @param eventToken\n     * @param e\n     * @return String value from the event field specified in @param eventToken\n     */\n    private String getEventField(String eventToken, Event e) {\n        if (eventToken.equalsIgnoreCase(\"descr\")) {\n            return e.getDescr();\n        } else if (eventToken.equalsIgnoreCase(\"distPoller\")) {\n            return e.getDistPoller();\n        } else if (eventToken.equalsIgnoreCase(\"host\")) {\n            return e.getHost();\n        } else if (eventToken.equalsIgnoreCase(\"ifAlias\")) {\n            return e.getIfAlias();\n        } else if (eventToken.equalsIgnoreCase(\"interface\")) {\n            return e.getInterface();\n        } else if (eventToken.equalsIgnoreCase(\"service\")) {\n            return e.getService();\n        } else if (eventToken.equalsIgnoreCase(\"severity\")) {\n            return e.getSeverity();\n        } else if (eventToken.equalsIgnoreCase(\"snmpHost\")) {\n            return e.getSnmphost();\n        } else if (eventToken.equalsIgnoreCase(\"source\")) {\n            return e.getSource();\n        } else if (eventToken.equalsIgnoreCase(\"logGroup\")) {\n            return e.getLogmsg().getContent();\n        } else if (eventToken.equalsIgnoreCase(\"masterStation\")) {\n            return e.getMasterStation();\n        } else if (eventToken.equalsIgnoreCase(\"mouseOverText\")) {\n            return e.getMouseovertext();\n        } else if (eventToken.equalsIgnoreCase(\"operInstruct\")) {\n            return e.getOperinstruct();\n        }\n        return null;\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getMatchedServiceName(Event e) {\n        PassiveEvent pe = getPassiveEventByUei(e.getUei());\n        String tokenValue = null;\n        String eventToken = pe.getStatusKey().getServiceName().getEventToken().getName();\n        if (pe.getStatusKey().getNodeLabel().getEventToken().getIsParm() == true) {\n            tokenValue = EventUtil.getNamedParmValue(\"parm[\"+ eventToken +\"]\", e);\n        } else {\n            tokenValue = getEventField(eventToken, e);\n        }\n        return tokenValue;\n    }","id":22169,"modified_method":"/**\n     * This method determines the nodelabel value by using the config to determine this value\n     * based on field and parm values of a passive event.\n     * \n     * @param e\n     * @return The correct value of the servicename portion of the status key\n     */\n    public String getMatchedServiceName(Event e) {\n        String eventToken = getPassiveEventByUei(e.getUei()).getStatusKey().getServiceName().getEventToken().getName();\n        String expr = getPassiveEventByUei(e.getUei()).getStatusKey().getServiceName().getEventToken().getValue();\n        boolean isParm = getPassiveEventByUei(e.getUei()).getStatusKey().getServiceName().getEventToken().getIsParm();\n        \n        String tokenValue = getValueFromFieldOrParm(e, eventToken, isParm);\n        return parseExpression(tokenValue, expr);\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method returns the nodelabel value by using the config to determine this value\n     * based on field and parm values of a passive event.\n     * \n     * @param e\n     * @return\n     */\n    public String getMatchedNodeLabel(Event e) {\n        \n        PassiveEvent pe = getPassiveEventByUei(e.getUei());\n        String tokenValue = null;\n        String eventToken = pe.getStatusKey().getNodeLabel().getEventToken().getName();\n        if (pe.getStatusKey().getNodeLabel().getEventToken().getIsParm() == true) {\n            tokenValue = EventUtil.getNamedParmValue(\"parm[\"+ eventToken +\"]\", e);\n        } else {\n            tokenValue = getEventField(eventToken, e);\n        }\n        return tokenValue;\n    }","id":22170,"modified_method":"/**\n     * This method determines the nodelabel value by using the config to determine this value\n     * based on field and parm values of a passive event.\n     * \n     * @param e\n     * @return The correct value of the nodelabel portion of the status key\n     */\n    public String getMatchedNodeLabel(Event e) {\n        String eventToken = getPassiveEventByUei(e.getUei()).getStatusKey().getNodeLabel().getEventToken().getName();\n        String expr = getPassiveEventByUei(e.getUei()).getStatusKey().getNodeLabel().getEventToken().getValue();\n        boolean isParm = getPassiveEventByUei(e.getUei()).getStatusKey().getNodeLabel().getEventToken().getIsParm();\n\n        String tokenValue = getValueFromFieldOrParm(e, eventToken, isParm);\n        return parseExpression(tokenValue, expr);\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PollStatus getMatchedStatus(Event e) {\n        PassiveEvent pe = getPassiveEventByUei(e.getUei());\n        String tokenValue = null;\n        String eventToken = pe.getStatusKey().getStatus().getEventToken().getName();\n        if (pe.getStatusKey().getNodeLabel().getEventToken().getIsParm() == true) {\n            tokenValue = EventUtil.getNamedParmValue(\"parm[\"+ eventToken +\"]\", e);\n        } else {\n            tokenValue = getEventField(eventToken, e);\n        }\n        return PollStatus.decodePollStatus(tokenValue, e.getLogmsg().getContent());\n    }","id":22171,"modified_method":"/**\n     * This method determines the nodelabel value by using the config to determine this value\n     * based on field and parm values of a passive event.\n     * \n     * @param e\n     * @return The PollStatus from the event\n     */\n    public PollStatus getMatchedStatus(Event e) {\n        String eventToken = getPassiveEventByUei(e.getUei()).getStatusKey().getStatus().getEventToken().getName();\n        String expr = getPassiveEventByUei(e.getUei()).getStatusKey().getStatus().getEventToken().getValue();\n        boolean isParm = getPassiveEventByUei(e.getUei()).getStatusKey().getStatus().getEventToken().getIsParm();\n        \n        String tokenValue = getValueFromFieldOrParm(e, eventToken, isParm);\n        return PollStatus.decodePollStatus(parseExpression(tokenValue, expr), e.getLogmsg().getContent());\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is a test for the passive status keeper where all the parms are derived from\n     * the config and the derived values are literal values pulled event fields.\n     * @throws ValidationException \n     * @throws MarshalException \n     */\n    public void testEventWithDerivedHardCodedParms() throws MarshalException, ValidationException {\n        \n        m_config = new PassiveStatusConfigFactory(new StringReader(getDerivedLiteralFieldConfig()));\n        PassiveStatusConfigFactory.setInstance(m_config);\n\n        Event e = createPassiveStatusEvent(null, null, null, null);\n        e.setHost(\"Router\");\n        e.setSource(\"192.168.1.1\");\n        e.setService(\"ICMP\");\n        e.setDescr(\"Down\");\n        \n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        assertEquals(\"Router\", m_config.getMatchedNodeLabel(e));\n        assertEquals(\"192.168.1.1\", m_config.getMatchedIpAddr(e));\n        assertEquals(\"ICMP\", m_config.getMatchedServiceName(e));\n        assertEquals(PollStatus.STATUS_DOWN, m_config.getMatchedStatus(e));\n        \n        \n    }","id":22172,"modified_method":"/**\n     * This is a test for the passive status keeper where all the values from the config\n     * should be taken literally.  The actual parm value is ignored, however, the parm\n     * must exist.  If the config value isn't an expression, the config value overrides the\n     * event's field value.\n     * \n     * @throws ValidationException \n     * @throws MarshalException \n     */\n    public void testEventWithHardCodedParmValues() throws MarshalException, ValidationException {\n        m_config = new PassiveStatusConfigFactory(new StringReader(getLiteralParmConfig()));\n        PassiveStatusConfigFactory.setInstance(m_config);\n        \n        //set these wrong because the literals from the config should be used instead\n        Event e = createPassiveStatusEvent(\"switch\", \"1.1.1.1\", \"pmci\", \"up\");\n        \n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        assertMatches(e);\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is a test for the passive status keeper where all the parms are derived from\n     * the config and the derived values are based on the values contained in parameters\n     * of the event.\n     */\n    public void testEventWithDerivedEventParmValues() {\n        \n    }","id":22173,"modified_method":"/**\n     * This is a test for the passive status keeper where all the parms are derived from\n     * the config and the derived values are based on regular expressions contained in the\n     * fields of the event.\n     * @throws ValidationException \n     * @throws MarshalException \n     */\n    public void testEventWithDerivedParmValues() throws MarshalException, ValidationException {\n        m_config = new PassiveStatusConfigFactory(new StringReader(getRegExParmConfig()));\n        PassiveStatusConfigFactory.setInstance(m_config);\n        \n        Event e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", \"Simulated ICMP_service tester\", \"isDown\");\n        \n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        assertMatches(e);\n\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is a test for the passive status keeper where all the required parms are included\n     * in the event.\n     */\n    public void testEventWithPassiveStatusParms() {\n        Event e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", \"ICMP\", \"Down\");\n\n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        assertEquals(\"Router\", m_config.getMatchedNodeLabel(e));\n        assertEquals(\"192.168.1.1\", m_config.getMatchedIpAddr(e));\n        assertEquals(\"ICMP\", m_config.getMatchedServiceName(e));\n        assertEquals(PollStatus.STATUS_DOWN, m_config.getMatchedStatus(e));\n    }","id":22174,"modified_method":"/**\n     * This is a test for the passive status keeper where all the required parms are included\n     * in the event.\n     */\n    public void testEventWithPassiveStatusParms() {\n        Event e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", \"ICMP\", \"Down\");\n\n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        assertMatches(e);\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is a test for the method that verifies valid passive status events\n     * for the passive status keeper.\n     * @throws ValidationException \n     * @throws MarshalException \n     *\n     */\n    public void testIsPassiveStatusEvent() throws MarshalException, ValidationException {\n        \n        Event e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", \"ICMP\", \"Down\");\n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        //test for missing required parms\n        e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", null, \"Down\");\n        assertFalse(m_config.isPassiveStatusEvent(e));\n        \n        //this will test the event simply doesn't match a registered uei.\n        e.setUei(\"bogusUei\");\n        assertFalse(m_config.isPassiveStatusEvent(e));\n        \n        /*\n         * now test to make sure not only does the event match the uei, that it understands\n         * there are no parms required for this configuration that derives the key based on\n         * literal field values.\n         */\n        m_config = new PassiveStatusConfigFactory(new StringReader(getDerivedLiteralFieldConfig()));\n        PassiveStatusConfigFactory.setInstance(m_config);\n        e = createPassiveStatusEvent(null, null, null, null);\n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n    }","id":22175,"modified_method":"/**\n     * This is a test for the method that verifies valid passive status events\n     * for the passive status keeper.\n     * @throws ValidationException \n     * @throws MarshalException \n     *\n     */\n    public void testIsPassiveStatusEvent() throws MarshalException, ValidationException {\n        \n        Event e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", \"ICMP\", \"Down\");\n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        //test for missing required parms\n        e = createPassiveStatusEvent(\"Router\", \"192.168.1.1\", null, \"Down\");\n        assertFalse(m_config.isPassiveStatusEvent(e));\n        \n        //this will test the event simply doesn't match a registered uei.\n        e.setUei(\"bogusUei\");\n        assertFalse(m_config.isPassiveStatusEvent(e));\n        \n        /*\n         * now test to make sure not only does the event match the uei, that it understands\n         * there are no parms required for this configuration that derives the key based on\n         * literal field values.\n         */\n        m_config = new PassiveStatusConfigFactory(new StringReader(getLiteralFieldConfig()));\n        PassiveStatusConfigFactory.setInstance(m_config);\n        e = createPassiveStatusEvent(null, null, null, null);\n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getDerivedLiteralParmConfig() {\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \n        \"<this:passive-status-configuration \\n\" + \n        \"xmlns:this=\\\"http://xmlns.opennms.org/xsd/passive-status-configuration\\\" \\n\" + \n        \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" >\\n\" + \n        \"  <this:passive-events>\\n\" + \n        \"    <this:passive-event uei=\\\"uei.opennms.org/services/passiveServiceStatus\\\">\\n\" + \n        \"      <this:status-key>\\n\" + \n        \"        <this:node-label>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveNodeLabel\\\" value=\\\"Router\\\"/>\\n\" + \n        \"        <\/this:node-label>\\n\" + \n        \"        <this:ipaddr>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveIpAddr\\\" value=\\\"192.168.1.1\\\"/>\\n\" + \n        \"        <\/this:ipaddr>\\n\" + \n        \"        <this:service-name>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveServiceName\\\" value=\\\"ICMP\\\"/>\\n\" + \n        \"        <\/this:service-name>\\n\" + \n        \"        <this:status>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveStatus\\\" value=\\\"Down\\\"/>\\n\" + \n        \"        <\/this:status>\\n\" + \n        \"      <\/this:status-key>\\n\" + \n        \"    <\/this:passive-event>\\n\" + \n        \"  <\/this:passive-events>\\n\" + \n        \"<\/this:passive-status-configuration>\\n\" + \n        \"\";\n    }","id":22176,"modified_method":"private String getLiteralParmConfig() {\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \n        \"<this:passive-status-configuration \\n\" + \n        \"xmlns:this=\\\"http://xmlns.opennms.org/xsd/passive-status-configuration\\\" \\n\" + \n        \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" >\\n\" + \n        \"  <this:passive-events>\\n\" + \n        \"    <this:passive-event uei=\\\"uei.opennms.org/services/passiveServiceStatus\\\">\\n\" + \n        \"      <this:status-key>\\n\" + \n        \"        <this:node-label>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveNodeLabel\\\" value=\\\"Router\\\"/>\\n\" + \n        \"        <\/this:node-label>\\n\" + \n        \"        <this:ipaddr>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveIpAddr\\\" value=\\\"192.168.1.1\\\"/>\\n\" + \n        \"        <\/this:ipaddr>\\n\" + \n        \"        <this:service-name>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveServiceName\\\" value=\\\"ICMP\\\"/>\\n\" + \n        \"        <\/this:service-name>\\n\" + \n        \"        <this:status>\\n\" + \n        \"          <this:event-token is-parm=\\\"true\\\" name=\\\"passiveStatus\\\" value=\\\"Down\\\"/>\\n\" + \n        \"        <\/this:status>\\n\" + \n        \"      <\/this:status-key>\\n\" + \n        \"    <\/this:passive-event>\\n\" + \n        \"  <\/this:passive-events>\\n\" + \n        \"<\/this:passive-status-configuration>\\n\" + \n        \"\";\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This is a test for the passive status keeper where all the parms are derived from\n     * the config and the derived values are based on the values contained in fields of the\n     * event.\n     */\n    public void testEventWithDerivedEventFieldValues() {\n        \n    }","id":22177,"modified_method":"/**\n     * This is a test for the passive status keeper where all the values from the config\n     * should be derived using the config's value as an expression against a field in\n     * the event.\n     *  \n     * @throws ValidationException \n     * @throws MarshalException \n     */\n    public void testEventWithDerivedFieldValues() throws MarshalException, ValidationException {\n        \n        m_config = new PassiveStatusConfigFactory(new StringReader(getRegExFieldConfig()));\n        PassiveStatusConfigFactory.setInstance(m_config);\n\n        Event e = createPassiveStatusEvent(null, null, null, null);\n        e.setHost(\"Router\");\n        e.setSource(\"192.168.1.1\");\n        e.setService(\"Simulated ICMP_service tester\");\n        e.setDescr(\"isDown\");\n        \n        assertTrue(m_config.isPassiveStatusEvent(e));\n        \n        assertMatches(e);\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getDerivedLiteralFieldConfig() {\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \n        \"<this:passive-status-configuration \\n\" + \n        \"xmlns:this=\\\"http://xmlns.opennms.org/xsd/passive-status-configuration\\\" \\n\" + \n        \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" >\\n\" + \n        \"  <this:passive-events>\\n\" + \n        \"    <this:passive-event uei=\\\"uei.opennms.org/services/passiveServiceStatus\\\">\\n\" + \n        \"      <this:status-key>\\n\" + \n        \"        <this:node-label>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"host\\\" value=\\\"Router\\\"/>\\n\" + \n        \"        <\/this:node-label>\\n\" + \n        \"        <this:ipaddr>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"source\\\" value=\\\"192.168.1.1\\\"/>\\n\" + \n        \"        <\/this:ipaddr>\\n\" + \n        \"        <this:service-name>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"service\\\" value=\\\"ICMP\\\"/>\\n\" + \n        \"        <\/this:service-name>\\n\" + \n        \"        <this:status>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"descr\\\" value=\\\"Down\\\"/>\\n\" + \n        \"        <\/this:status>\\n\" + \n        \"      <\/this:status-key>\\n\" + \n        \"    <\/this:passive-event>\\n\" + \n        \"  <\/this:passive-events>\\n\" + \n        \"<\/this:passive-status-configuration>\\n\" + \n        \"\";\n    }","id":22178,"modified_method":"private String getLiteralFieldConfig() {\n        return \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \n        \"<this:passive-status-configuration \\n\" + \n        \"xmlns:this=\\\"http://xmlns.opennms.org/xsd/passive-status-configuration\\\" \\n\" + \n        \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" >\\n\" + \n        \"  <this:passive-events>\\n\" + \n        \"    <this:passive-event uei=\\\"uei.opennms.org/services/passiveServiceStatus\\\">\\n\" + \n        \"      <this:status-key>\\n\" + \n        \"        <this:node-label>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"host\\\" value=\\\"Router\\\"/>\\n\" + \n        \"        <\/this:node-label>\\n\" + \n        \"        <this:ipaddr>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"source\\\" value=\\\"192.168.1.1\\\"/>\\n\" + \n        \"        <\/this:ipaddr>\\n\" + \n        \"        <this:service-name>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"service\\\" value=\\\"ICMP\\\"/>\\n\" + \n        \"        <\/this:service-name>\\n\" + \n        \"        <this:status>\\n\" + \n        \"          <this:event-token is-parm=\\\"false\\\" name=\\\"descr\\\" value=\\\"Down\\\"/>\\n\" + \n        \"        <\/this:status>\\n\" + \n        \"      <\/this:status-key>\\n\" + \n        \"    <\/this:passive-event>\\n\" + \n        \"  <\/this:passive-events>\\n\" + \n        \"<\/this:passive-status-configuration>\\n\" + \n        \"\";\n    }","commit_id":"ac22a388949a23ddddf9de4c82764a8f55767162","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","id":22179,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = 0;\n    }\n  }","commit_id":"314c2e66d3933e03132c7751e0ef97a34d652021","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":22180,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"314c2e66d3933e03132c7751e0ef97a34d652021","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","id":22181,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          item2Index.put(o, indexCounter++);\n          index2Item.add(o);\n          assert index2Item.size() == indexCounter;\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","commit_id":"314c2e66d3933e03132c7751e0ef97a34d652021","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = new ConcurrentHashMap<Integer,E>(initialCapacity);\n  }","id":22182,"modified_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = Collections.synchronizedList(new ArrayList<E>(initialCapacity));\n  }","commit_id":"314c2e66d3933e03132c7751e0ef97a34d652021","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":22183,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"e347d87a58b8768c284cbaee488e9bbf7306fa94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","id":22184,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          item2Index.put(o, indexCounter++);\n          index2Item.add(o);\n          assert index2Item.size() == indexCounter;\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","commit_id":"e347d87a58b8768c284cbaee488e9bbf7306fa94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = new ConcurrentHashMap<Integer,E>(initialCapacity);\n  }","id":22185,"modified_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = Collections.synchronizedList(new ArrayList<E>(initialCapacity));\n  }","commit_id":"e347d87a58b8768c284cbaee488e9bbf7306fa94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","id":22186,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = 0;\n    }\n  }","commit_id":"e347d87a58b8768c284cbaee488e9bbf7306fa94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":22187,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"1680f48ffb154f68368834acba0f8c3e99dc6ab8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","id":22188,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = 0;\n    }\n  }","commit_id":"1680f48ffb154f68368834acba0f8c3e99dc6ab8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","id":22189,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          item2Index.put(o, indexCounter++);\n          index2Item.add(o);\n          assert index2Item.size() == indexCounter;\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","commit_id":"1680f48ffb154f68368834acba0f8c3e99dc6ab8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = new ConcurrentHashMap<Integer,E>(initialCapacity);\n  }","id":22190,"modified_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = Collections.synchronizedList(new ArrayList<E>(initialCapacity));\n  }","commit_id":"1680f48ffb154f68368834acba0f8c3e99dc6ab8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","id":22191,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          item2Index.put(o, indexCounter++);\n          index2Item.add(o);\n          assert index2Item.size() == indexCounter;\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","commit_id":"8c816c09218cc600ce4b30200af68b7d00126f94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":22192,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"8c816c09218cc600ce4b30200af68b7d00126f94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","id":22193,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = 0;\n    }\n  }","commit_id":"8c816c09218cc600ce4b30200af68b7d00126f94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = new ConcurrentHashMap<Integer,E>(initialCapacity);\n  }","id":22194,"modified_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = Collections.synchronizedList(new ArrayList<E>(initialCapacity));\n  }","commit_id":"8c816c09218cc600ce4b30200af68b7d00126f94","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private final List<Integer> sortedKeys = Generics.newArrayList(new TreeSet<Integer>(index2Item.keySet()));\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < sortedKeys.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":22195,"modified_method":"@Override\n  public Iterator<E> iterator() {\n    return new Iterator<E>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < index2Item.size();\n      }\n      @Override\n      public E next() {\n        return index2Item.get(index++);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","commit_id":"2f6bf6be4695b2cd20b5ac0eb2bdec71d5c423aa","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","id":22196,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          item2Index.put(o, indexCounter++);\n          index2Item.add(o);\n          assert index2Item.size() == indexCounter;\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","commit_id":"2f6bf6be4695b2cd20b5ac0eb2bdec71d5c423aa","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = new AtomicInteger();\n    }\n  }","id":22197,"modified_method":"@Override\n  public void clear() {\n    synchronized(this) {\n      item2Index.clear();\n      index2Item.clear();\n      indexCounter = 0;\n    }\n  }","commit_id":"2f6bf6be4695b2cd20b5ac0eb2bdec71d5c423aa","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = new ConcurrentHashMap<Integer,E>(initialCapacity);\n  }","id":22198,"modified_method":"/**\n   * Constructor.\n   * \n   * @param initialCapacity\n   */\n  public ConcurrentHashIndex(int initialCapacity) {\n    this.item2Index = new ConcurrentHashMap<E,Integer>(initialCapacity);\n    this.index2Item = Collections.synchronizedList(new ArrayList<E>(initialCapacity));\n  }","commit_id":"2f6bf6be4695b2cd20b5ac0eb2bdec71d5c423aa","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"void close()\n    {\n        safeClose( this.writer );\n        invalidateSearcher();\n    }","id":22199,"modified_method":"void close()\n    {\n        safeClose( this.writer );\n        safeClose( this.reader );\n        safeClose( this.searcher );\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private IndexSearcher searcher()\n    {\n        try\n        {\n            if ( this.searcher == null )\n            {\n                this.writer.commit();\n                this.searcher = new IndexSearcher( directory, true );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        return this.searcher;\n    }","id":22200,"modified_method":"private IndexSearcher searcher()\n    {\n        if ( this.searcher != null && !modified )\n        {\n            return this.searcher;\n        }\n        \n        try\n        {\n            IndexReader newReader = this.reader == null ? this.writer.getReader() : this.reader.reopen();\n            if ( newReader == this.reader )\n            {\n                return this.searcher;\n            }\n            if ( this.reader != null )\n            {\n                this.reader.close();\n            }\n            this.reader = newReader;\n            if ( this.searcher != null )\n            {\n                this.searcher.close();\n            }\n            searcher = new IndexSearcher( reader );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            this.modified = false;\n        }\n        return this.searcher;\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void invalidateSearcher()\n    {\n        safeClose( this.searcher );\n        this.searcher = null;\n    }","id":22201,"modified_method":"private void invalidateSearcher()\n    {\n        this.modified = true;\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void safeClose( Object object )\n    {\n        if ( object == null )\n        {\n            return;\n        }\n        \n        try\n        {\n            if ( object instanceof IndexWriter )\n            {\n                ( ( IndexWriter ) object ).close();\n            }\n            else if ( object instanceof IndexSearcher )\n            {\n                ( ( IndexSearcher ) object ).close();\n            }\n        }\n        catch ( IOException e )\n        {\n            // Ok\n        }\n    }","id":22202,"modified_method":"private static void safeClose( Object object )\n    {\n        if ( object == null )\n        {\n            return;\n        }\n        \n        try\n        {\n            if ( object instanceof IndexWriter )\n            {\n                ( ( IndexWriter ) object ).close();\n            }\n            else if ( object instanceof IndexSearcher )\n            {\n                ( ( IndexSearcher ) object ).close();\n            }\n            else if ( object instanceof IndexReader )\n            {\n                ( ( IndexReader ) object ).close();\n            }\n        }\n        catch ( IOException e )\n        {\n            // Ok\n        }\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public int hashCode()\n    {\n        int code = 17;\n        code += 7*entityTypeByte;\n        code += 7*indexName.hashCode();\n        return code;\n    }","id":22203,"modified_method":"@Override\n    public int hashCode()\n    {\n        return this.hashCode;\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IndexIdentifier( byte entityTypeByte, EntityType entityType, String indexName,\n            Map<String, String> customConfig )\n    {\n        this.entityTypeByte = entityTypeByte;\n        this.entityType = entityType;\n        this.indexName = indexName;\n        this.config = customConfig;\n    }","id":22204,"modified_method":"public IndexIdentifier( byte entityTypeByte, EntityType entityType, String indexName,\n            Map<String, String> customConfig )\n    {\n        this.entityTypeByte = entityTypeByte;\n        this.entityType = entityType;\n        this.indexName = indexName;\n        this.config = customConfig;\n        this.hashCode = calculateHashCode();\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"abstract TxData newTxData( LuceneIndex index );","id":22205,"modified_method":"TxData newTxData( LuceneIndex index )\n    {\n        return new ExactTxData( index );\n    }","commit_id":"bee25591b6974d16f197ebacc52bc24240b75eab","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void invalidateSearcher()\n    {\n        safeClose( this.searcher );\n        this.searcher = null;\n    }","id":22206,"modified_method":"private void invalidateSearcher()\n    {\n        this.modified = true;\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"private IndexSearcher searcher()\n    {\n        try\n        {\n            if ( this.searcher == null )\n            {\n                this.writer.commit();\n                this.searcher = new IndexSearcher( directory, true );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        return this.searcher;\n    }","id":22207,"modified_method":"private IndexSearcher searcher()\n    {\n        if ( this.searcher != null && !modified )\n        {\n            return this.searcher;\n        }\n        \n        try\n        {\n            IndexReader newReader = this.reader == null ? this.writer.getReader() : this.reader.reopen();\n            if ( newReader == this.reader )\n            {\n                return this.searcher;\n            }\n            if ( this.reader != null )\n            {\n                this.reader.close();\n            }\n            this.reader = newReader;\n            if ( this.searcher != null )\n            {\n                this.searcher.close();\n            }\n            searcher = new IndexSearcher( reader );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            this.modified = false;\n        }\n        return this.searcher;\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"void close()\n    {\n        safeClose( this.writer );\n        invalidateSearcher();\n    }","id":22208,"modified_method":"void close()\n    {\n        safeClose( this.writer );\n        safeClose( this.reader );\n        safeClose( this.searcher );\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void safeClose( Object object )\n    {\n        if ( object == null )\n        {\n            return;\n        }\n        \n        try\n        {\n            if ( object instanceof IndexWriter )\n            {\n                ( ( IndexWriter ) object ).close();\n            }\n            else if ( object instanceof IndexSearcher )\n            {\n                ( ( IndexSearcher ) object ).close();\n            }\n        }\n        catch ( IOException e )\n        {\n            // Ok\n        }\n    }","id":22209,"modified_method":"private static void safeClose( Object object )\n    {\n        if ( object == null )\n        {\n            return;\n        }\n        \n        try\n        {\n            if ( object instanceof IndexWriter )\n            {\n                ( ( IndexWriter ) object ).close();\n            }\n            else if ( object instanceof IndexSearcher )\n            {\n                ( ( IndexSearcher ) object ).close();\n            }\n            else if ( object instanceof IndexReader )\n            {\n                ( ( IndexReader ) object ).close();\n            }\n        }\n        catch ( IOException e )\n        {\n            // Ok\n        }\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public int hashCode()\n    {\n        int code = 17;\n        code += 7*entityTypeByte;\n        code += 7*indexName.hashCode();\n        return code;\n    }","id":22210,"modified_method":"@Override\n    public int hashCode()\n    {\n        return this.hashCode;\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IndexIdentifier( byte entityTypeByte, EntityType entityType, String indexName,\n            Map<String, String> customConfig )\n    {\n        this.entityTypeByte = entityTypeByte;\n        this.entityType = entityType;\n        this.indexName = indexName;\n        this.config = customConfig;\n    }","id":22211,"modified_method":"public IndexIdentifier( byte entityTypeByte, EntityType entityType, String indexName,\n            Map<String, String> customConfig )\n    {\n        this.entityTypeByte = entityTypeByte;\n        this.entityType = entityType;\n        this.indexName = indexName;\n        this.config = customConfig;\n        this.hashCode = calculateHashCode();\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"abstract TxData newTxData( LuceneIndex index );","id":22212,"modified_method":"TxData newTxData( LuceneIndex index )\n    {\n        return new ExactTxData( index );\n    }","commit_id":"c5f061014f8042274f3ee0f14daee43254f279ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void safeClose( Object object )\n    {\n        if ( object == null )\n        {\n            return;\n        }\n        \n        try\n        {\n            if ( object instanceof IndexWriter )\n            {\n                ( ( IndexWriter ) object ).close();\n            }\n            else if ( object instanceof IndexSearcher )\n            {\n                ( ( IndexSearcher ) object ).close();\n            }\n        }\n        catch ( IOException e )\n        {\n            // Ok\n        }\n    }","id":22213,"modified_method":"private static void safeClose( Object object )\n    {\n        if ( object == null )\n        {\n            return;\n        }\n        \n        try\n        {\n            if ( object instanceof IndexWriter )\n            {\n                ( ( IndexWriter ) object ).close();\n            }\n            else if ( object instanceof IndexSearcher )\n            {\n                ( ( IndexSearcher ) object ).close();\n            }\n            else if ( object instanceof IndexReader )\n            {\n                ( ( IndexReader ) object ).close();\n            }\n        }\n        catch ( IOException e )\n        {\n            // Ok\n        }\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void invalidateSearcher()\n    {\n        safeClose( this.searcher );\n        this.searcher = null;\n    }","id":22214,"modified_method":"private void invalidateSearcher()\n    {\n        this.modified = true;\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"void close()\n    {\n        safeClose( this.writer );\n        invalidateSearcher();\n    }","id":22215,"modified_method":"void close()\n    {\n        safeClose( this.writer );\n        safeClose( this.reader );\n        safeClose( this.searcher );\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private IndexSearcher searcher()\n    {\n        try\n        {\n            if ( this.searcher == null )\n            {\n                this.writer.commit();\n                this.searcher = new IndexSearcher( directory, true );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        return this.searcher;\n    }","id":22216,"modified_method":"private IndexSearcher searcher()\n    {\n        if ( this.searcher != null && !modified )\n        {\n            return this.searcher;\n        }\n        \n        try\n        {\n            IndexReader newReader = this.reader == null ? this.writer.getReader() : this.reader.reopen();\n            if ( newReader == this.reader )\n            {\n                return this.searcher;\n            }\n            if ( this.reader != null )\n            {\n                this.reader.close();\n            }\n            this.reader = newReader;\n            if ( this.searcher != null )\n            {\n                this.searcher.close();\n            }\n            searcher = new IndexSearcher( reader );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            this.modified = false;\n        }\n        return this.searcher;\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IndexIdentifier( byte entityTypeByte, EntityType entityType, String indexName,\n            Map<String, String> customConfig )\n    {\n        this.entityTypeByte = entityTypeByte;\n        this.entityType = entityType;\n        this.indexName = indexName;\n        this.config = customConfig;\n    }","id":22217,"modified_method":"public IndexIdentifier( byte entityTypeByte, EntityType entityType, String indexName,\n            Map<String, String> customConfig )\n    {\n        this.entityTypeByte = entityTypeByte;\n        this.entityType = entityType;\n        this.indexName = indexName;\n        this.config = customConfig;\n        this.hashCode = calculateHashCode();\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public int hashCode()\n    {\n        int code = 17;\n        code += 7*entityTypeByte;\n        code += 7*indexName.hashCode();\n        return code;\n    }","id":22218,"modified_method":"@Override\n    public int hashCode()\n    {\n        return this.hashCode;\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"abstract TxData newTxData( LuceneIndex index );","id":22219,"modified_method":"TxData newTxData( LuceneIndex index )\n    {\n        return new ExactTxData( index );\n    }","commit_id":"4683f4eca4c23a69ed0df254dd31c75f229058bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static URL buildTarget(Node node, String resource) throws MalformedURLException {\n        final User user = User.current();\n        return buildTarget(node, resource, user.getName(), user.getPasswordHash());\n    }","id":22220,"modified_method":"public static URL buildTarget(Node node, String resource) throws MalformedURLException {\n        return buildTarget(node, resource, null);\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static <T> T put(URL url, Class<T> responseClass) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.preparePut(url.toString());\n            requestBuilder.addHeader(\"Accept\", \"application/json\");\n\n            if (url.getUserInfo() != null) {\n                final String[] userPass = url.getUserInfo().split(\":\", 2);\n                if (userPass[0] != null && userPass[1] != null) {\n                    requestBuilder.setRealm(new Realm.RealmBuilder()\n                            .setPrincipal(userPass[0])\n                            .setPassword(userPass[1])\n                            .setUsePreemptiveAuth(true)\n                            .setScheme(Realm.AuthScheme.BASIC)\n                            .build());\n                }\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != 200) {\n                throw new APIException(response.getStatusCode(), \"REST call PUT [\" + url + \"] returned \" + response.getStatusText(), response.getResponseBody());\n            }\n\n            Gson gson = new Gson();\n            return gson.fromJson(response.getResponseBody(\"UTF-8\"), responseClass);\n        } catch (InterruptedException e) {\n            // TODO\n        } catch (ExecutionException e) {\n            throw new APIException(-1, \"REST call PUT [\" + url + \"] failed: \" + e.getMessage());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"Malformed URL.\", e);\n        }\n\n        return (T) null;\n    }","id":22221,"modified_method":"public static <T> T put(URL url, Class<T> responseClass) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.preparePut(url.toString());\n            requestBuilder.addHeader(\"Accept\", \"application/json\");\n\n            applyBasicAuthentication(requestBuilder, url.getUserInfo());\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != 200) {\n                throw new APIException(response.getStatusCode(), \"REST call PUT [\" + url + \"] returned \" + response.getStatusText());\n            }\n\n            return deserializeJson(response, responseClass);\n        } catch (InterruptedException e) {\n            // TODO\n        } catch (ExecutionException e) {\n            throw new APIException(-1, \"REST call PUT [\" + url + \"] failed: \" + e.getMessage());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"Malformed URL.\", e);\n        }\n\n        return null;\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static <T> T get(URL url, Class<T> responseClass, String username, String password) throws APIException, IOException {\n\t\ttry {\n\t\t\tAsyncHttpClient.BoundRequestBuilder requestBuilder = client.prepareGet(url.toString());\n\n            // TODO: better make this better bro\n            if (!responseClass.equals(String.class)) {\n\t\t\t    requestBuilder.addHeader(\"Accept\", \"application/json\");\n            }\n            // explicit username and password have priority if they are set, to be able to perform the login\n            // otherwise we take them from the node url\n            if (username == null && url.getUserInfo() != null) {\n                final String[] userPass = url.getUserInfo().split(\":\", 2);\n                username = userPass[0];\n                password = userPass[1];\n            }\n            if (username != null && password != null) {\n                requestBuilder.setRealm(new Realm.RealmBuilder()\n                        .setPrincipal(username)\n                        .setPassword(password)\n                        .setUsePreemptiveAuth(true)\n                        .setScheme(Realm.AuthScheme.BASIC)\n                        .build());\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\t\t\tfinal Response response = requestBuilder.execute().get();\n\n\t\t\tif (response.getStatusCode() != 200) {\n\t\t\t\tthrow new APIException(response.getStatusCode(), \"REST call GET [\" + url + \"] returned \" + response.getStatusText(), response.getResponseBody());\n\t\t\t}\n\n            // TODO: better make this better bro\n            if (responseClass.equals(String.class)) {\n                return (T) response.getResponseBody(\"UTF-8\");\n            }\n\n\t\t\tGson gson = new Gson();\n\t\t\treturn gson.fromJson(response.getResponseBody(\"UTF-8\"), responseClass);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO\n\t\t} catch (ExecutionException e) {\n\t\t\tthrow new APIException(-1, \"REST call GET [\" + url + \"] failed: \" + e.getMessage());\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new RuntimeException(\"Malformed URL.\", e);\n\t\t}\n\n\t\treturn (T) null;\n\t}","id":22222,"modified_method":"public static <T> T get(URL url, Class<T> responseClass, String username, String password) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.prepareGet(url.toString());\n\n            // TODO: should we always insist on things being wrapped in json?\n            if (!responseClass.equals(String.class)) {\n\t\t\t    requestBuilder.addHeader(\"Accept\", \"application/json\");\n            }\n            // explicit username and password have priority if they are set, to be able to perform the login\n            // otherwise we take them from the node url\n            String userInfo = url.getUserInfo();\n            if (username != null && password != null) {\n                userInfo = username + \":\" + password;\n            }\n            applyBasicAuthentication(requestBuilder, userInfo);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != 200) {\n                throw new APIException(response.getStatusCode(), \"REST call GET [\" + url + \"] returned \" + response.getStatusText());\n            }\n\n            // TODO: should we always insist on things being wrapped in json?\n            if (responseClass.equals(String.class)) {\n                return responseClass.cast(response.getResponseBody(\"UTF-8\"));\n            }\n\n            return deserializeJson(response, responseClass);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO\n\t\t} catch (ExecutionException e) {\n\t\t\tthrow new APIException(-1, \"REST call GET [\" + url + \"] failed: \" + e.getMessage());\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new RuntimeException(\"Malformed URL.\", e);\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static <T> List<T> getFromAllNodes(String resource, Class<T> responseClass) throws APIException, IOException {\n        List<T> result = Lists.newArrayList();\n\n        for (Node node : Node.all()) {\n            URL url = buildTarget(node, resource);\n            try {\n                AsyncHttpClient.BoundRequestBuilder requestBuilder = client.prepareGet(url.toString());\n                requestBuilder.addHeader(\"Accept\", \"application/json\");\n\n                if (url.getUserInfo() != null) {\n                    final String[] userPass = url.getUserInfo().split(\":\", 2);\n                    if (userPass[0] != null && userPass[1] != null) {\n                        requestBuilder.setRealm(new Realm.RealmBuilder()\n                                .setPrincipal(userPass[0])\n                                .setPassword(userPass[1])\n                                .setUsePreemptiveAuth(true)\n                                .setScheme(Realm.AuthScheme.BASIC)\n                                .build());\n                    }\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"API Request: {}\", requestBuilder.build().toString());\n                }\n\n                final Response response = requestBuilder.execute().get();\n\n                if (response.getStatusCode() != 200) {\n                    throw new APIException(response.getStatusCode(), \"REST call [\" + url + \"] returned \" + response.getStatusText(), response.getResponseBody());\n                }\n\n                Gson gson = new Gson();\n                result.add(gson.fromJson(response.getResponseBody(\"UTF-8\"), responseClass));\n            } catch (InterruptedException e) {\n                // TODO\n            } catch (ExecutionException e) {\n                throw new APIException(-1, \"REST call [\" + url + \"] failed.\" + e);\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Malformed URL.\", e);\n            }\n        }\n\n        return result;\n    }","id":22223,"modified_method":"public static <T> List<T> getFromAllNodes(String resource, Class<T> responseClass) throws APIException, IOException {\n        List<T> result = Lists.newArrayList();\n\n        for (Node node : Node.all()) {\n            URL url = buildTarget(node, resource);\n            try {\n                AsyncHttpClient.BoundRequestBuilder requestBuilder = client.prepareGet(url.toString());\n                requestBuilder.addHeader(\"Accept\", \"application/json\");\n\n                applyBasicAuthentication(requestBuilder, url.getUserInfo());\n                if (log.isDebugEnabled()) {\n                    log.debug(\"API Request: {}\", requestBuilder.build().toString());\n                }\n\n                final Response response = requestBuilder.execute().get();\n\n                if (response.getStatusCode() != 200) {\n                    throw new APIException(response.getStatusCode(), \"REST call [\" + url + \"] returned \" + response.getStatusText());\n                }\n\n                result.add(deserializeJson(response, responseClass));\n            } catch (InterruptedException e) {\n                // TODO\n            } catch (ExecutionException e) {\n                throw new APIException(-1, \"REST call [\" + url + \"] failed.\" + e);\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Malformed URL.\", e);\n            }\n        }\n\n        return result;\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static <T> T delete(Node node, String part, Class<T> responseClass) throws IOException, APIException {\n        return delete(buildTarget(node, part), 204, responseClass);\n    }","id":22224,"modified_method":"public static <T> T getUnauthenticated(Node node, String part, Class<T> responseClass) throws IOException, APIException {\n        return get(buildTarget(node, part, null, null), responseClass, null, null);\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static URL buildTarget(Node node, String resource, String username, String password) throws MalformedURLException {\n        final URI targetAddress;\n        try {\n            final URI transportAddress = new URI(node.getTransportAddress());\n            final String userInfo = username + \":\" + password;\n            String path = resource;\n            if (! resource.startsWith(\"/\")) {\n                path = \"/\" + resource;\n            }\n            // TODO hack until we separate out the query parameters\n            String query = null;\n            if (path.contains(\"?\")) {\n                final int pos = path.indexOf(\"?\");\n                query = path.substring(pos + 1);\n                path = path.substring(0, pos);\n            }\n            targetAddress = new URI(transportAddress.getScheme(), userInfo, transportAddress.getHost(), transportAddress.getPort(), path, query, null);\n\n        } catch (URISyntaxException e) {\n            log.error(\"Could not create target URI\", e);\n            return null;\n        }\n        return new URL(targetAddress.toASCIIString());\n    }","id":22225,"modified_method":"public static URL buildTarget(Node node, String resource, String username, String password) throws MalformedURLException {\n        return buildTarget(node, resource, null, username, password);\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static <T> T post(URL url, String body, int expectedResponseCode, Class<T> responseClass) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.preparePost(url.toString());\n            requestBuilder.addHeader(\"Accept\", \"application/json\");\n            requestBuilder.setBody(body);\n\n            if (url.getUserInfo() != null) {\n                final String[] userPass = url.getUserInfo().split(\":\", 2);\n                if (userPass[0] != null && userPass[1] != null) {\n                    requestBuilder.setRealm(new Realm.RealmBuilder()\n                            .setPrincipal(userPass[0])\n                            .setPassword(userPass[1])\n                            .setUsePreemptiveAuth(true)\n                            .setScheme(Realm.AuthScheme.BASIC)\n                            .build());\n                }\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != expectedResponseCode) {\n                throw new APIException(response.getStatusCode(), \"REST call POST [\" + url + \"] returned \" + response.getStatusText(), response.getResponseBody());\n            }\n\n            Gson gson = new Gson();\n            return gson.fromJson(response.getResponseBody(\"UTF-8\"), responseClass);\n        } catch (InterruptedException e) {\n            // TODO\n        } catch (ExecutionException e) {\n            throw new APIException(-1, \"REST call POST [\" + url + \"] failed: \" + e.getMessage());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"Malformed URL.\", e);\n        }\n\n        return (T) null;\n    }","id":22226,"modified_method":"public static <T> T post(URL url, String body, int expectedResponseCode, Class<T> responseClass) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.preparePost(url.toString());\n            requestBuilder.addHeader(\"Accept\", \"application/json\");\n            requestBuilder.setBody(body);\n\n            applyBasicAuthentication(requestBuilder, url.getUserInfo());\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != expectedResponseCode) {\n                throw new APIException(response.getStatusCode(), \"REST call POST [\" + url + \"] returned \" + response.getStatusText());\n            }\n\n            return deserializeJson(response, responseClass);\n        } catch (InterruptedException e) {\n            // TODO\n        } catch (ExecutionException e) {\n            throw new APIException(-1, \"REST call POST [\" + url + \"] failed: \" + e.getMessage());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"Malformed URL.\", e);\n        }\n\n        return null;\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static <T> T delete(URL url, int expectedResponseCode, Class<T> responseClass) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.prepareDelete(url.toString());\n            requestBuilder.addHeader(\"Accept\", \"application/json\");\n\n            if (url.getUserInfo() != null) {\n                final String[] userPass = url.getUserInfo().split(\":\", 2);\n                if (userPass[0] != null && userPass[1] != null) {\n                    requestBuilder.setRealm(new Realm.RealmBuilder()\n                            .setPrincipal(userPass[0])\n                            .setPassword(userPass[1])\n                            .setUsePreemptiveAuth(true)\n                            .setScheme(Realm.AuthScheme.BASIC)\n                            .build());\n                }\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != expectedResponseCode) {\n                throw new APIException(response.getStatusCode(), \"REST call DELETE [\" + url + \"] returned \" + response.getStatusText(), response.getResponseBody());\n            }\n\n            Gson gson = new Gson();\n            return gson.fromJson(response.getResponseBody(\"UTF-8\"), responseClass);\n        } catch (InterruptedException e) {\n            // TODO\n        } catch (ExecutionException e) {\n            throw new APIException(-1, \"REST call DELETE [\" + url + \"] failed: \" + e.getMessage());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"Malformed URL.\", e);\n        }\n\n        return (T) null;\n    }","id":22227,"modified_method":"public static <T> T delete(URL url, int expectedResponseCode, Class<T> responseClass) throws APIException, IOException {\n        try {\n            AsyncHttpClient.BoundRequestBuilder requestBuilder = client.prepareDelete(url.toString());\n            requestBuilder.addHeader(\"Accept\", \"application/json\");\n\n            applyBasicAuthentication(requestBuilder, url.getUserInfo());\n            if (log.isDebugEnabled()) {\n                log.debug(\"API Request: {}\", requestBuilder.build().toString());\n            }\n\n            final Response response = requestBuilder.execute().get();\n\n            if (response.getStatusCode() != expectedResponseCode) {\n                throw new APIException(response.getStatusCode(), \"REST call DELETE [\" + url + \"] returned \" + response.getStatusText());\n            }\n\n            return deserializeJson(response, responseClass);\n        } catch (InterruptedException e) {\n            // TODO\n        } catch (ExecutionException e) {\n            throw new APIException(-1, \"REST call DELETE [\" + url + \"] failed: \" + e.getMessage());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(\"Malformed URL.\", e);\n        }\n\n        return null;\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static List<Node> all() throws IOException, APIException {\n        List<Node> nodes = Lists.newArrayList();\n\n        NodeResponse response = Api.get(INITIAL_NODE, \"/cluster/nodes/\", NodeResponse.class);\n        for (NodeSummaryResponse nsr : response.nodes) {\n            nodes.add(new Node(nsr));\n        }\n\n        return nodes;\n    }","id":22228,"modified_method":"public static List<Node> all() throws IOException, APIException {\n        // TODO don't just get the node list once\n        if (nodes.size() == 0) {\n            NodeResponse response = Api.getUnauthenticated(INITIAL_NODE, \"/cluster/nodes/\", NodeResponse.class);\n            for (NodeSummaryResponse nsr : response.nodes) {\n                nodes.add(new Node(nsr));\n            }\n        }\n        return nodes;\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public String getUsername(Context ctx) {\n        final User currentUser = User.current();\n        if (currentUser == null) {\n            return null;\n        }\n        return currentUser.getName();\n    }","id":22229,"modified_method":"@Override\n    public String getUsername(Context ctx) {\n        final User sessionUser = User.authenticateSessionUser();\n        if (sessionUser == null) {\n            return null;\n        }\n        return sessionUser.getName();\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static User current() {\n        // this method really covers three use cases:\n        // 1. accessing the current user from within controller or view code\n        //    the user was authenticated and is available from the request context\n        // 2. loading the user from the REST API using the credentials from the cookie,\n        //    set by a previously successful login\n        //    this is performed once each time a request is done after initial log in\n        // 3. if the authenticated user is the locally configured user, there is no REST call performed\n        //    instead a local user object is returned immediately\n\n        User currentUser = (User) Http.Context.current().args.get(\"currentUser\");\n        if (currentUser != null) {\n            // we've done this all before, just return the user.\n            return currentUser;\n        }\n\n        // is there a logged in user at all?\n        final Http.Session session = Http.Context.current().session();\n        final String sessionid = session.get(\"sessionid\");\n        if (sessionid == null) {\n            // there is no authenticated user yet.\n            log.info(\"Accessing the current user failed, there's no sessionid in the cookie.\");\n            return null;\n        }\n        final String userPassHash = Crypto.decryptAES(sessionid);\n        final StringTokenizer tokenizer = new StringTokenizer(userPassHash, \"\\t\");\n        if (tokenizer.countTokens() != 2) {\n            return null;\n        }\n        final String userName = tokenizer.nextToken();\n        final String passwordSha1 = tokenizer.nextToken();\n\n        // special case for the local admin user for the web interface\n        if (userName != null) {\n            final LocalAdminUser localAdminUser = LocalAdminUser.getInstance();\n            if (userName.equals(localAdminUser.getName())) {\n                User.setCurrent(localAdminUser);\n                return localAdminUser;\n            }\n        }\n        try {\n            final UserResponse response = Api.get(\"/users/\" + userName, UserResponse.class, userName, passwordSha1);\n            currentUser = new User(response, passwordSha1);\n            setCurrent(currentUser);\n        } catch (IOException e) {\n            log.error(\"Could not reach graylog2 server\", e);\n        } catch (APIException e) {\n            log.error(\"Unauthorized to load user \" + userName, e);\n        }\n        return currentUser;\n    }","id":22230,"modified_method":"public static User current() {\n        return (User) Http.Context.current().args.get(\"currentUser\");\n    }","commit_id":"f3a4613f1e930b98fa2ed49d743db65163de0777","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n   * Converts the given annotation to an XML document using the specified options\n   */\n  public static Document annotationToDoc(Annotation annotation, Options options) {\n    //\n    // create the XML document with the root node pointing to the namespace URL\n    //\n    Element root = new Element(\"root\", NAMESPACE_URI);\n    Document xmlDoc = new Document(root);\n    ProcessingInstruction pi = new ProcessingInstruction(\"xml-stylesheet\",\n          \"href=\\\"\" + STYLESHEET_NAME + \"\\\" type=\\\"text/xsl\\\"\");\n    xmlDoc.insertChild(pi, 0);\n    Element docElem = new Element(\"document\", NAMESPACE_URI);\n    root.appendChild(docElem);\n\n    setSingleElement(docElem, \"docId\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocIDAnnotation.class));\n    setSingleElement(docElem, \"docDate\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocDateAnnotation.class));\n    setSingleElement(docElem, \"docSourceType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocSourceTypeAnnotation.class));\n    setSingleElement(docElem, \"docType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocTypeAnnotation.class));\n    setSingleElement(docElem, \"author\", NAMESPACE_URI, annotation.get(CoreAnnotations.AuthorAnnotation.class));\n    setSingleElement(docElem, \"location\", NAMESPACE_URI, annotation.get(CoreAnnotations.LocationAnnotation.class));\n\n    if (options.includeText) {\n      setSingleElement(docElem, \"text\", NAMESPACE_URI, annotation.get(CoreAnnotations.TextAnnotation.class));\n    }\n\n    Element sentencesElem = new Element(\"sentences\", NAMESPACE_URI);\n    docElem.appendChild(sentencesElem);\n\n    //\n    // save the info for each sentence in this doc\n    //\n    if(annotation.get(CoreAnnotations.SentencesAnnotation.class) != null){\n      int sentCount = 1;\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Element sentElem = new Element(\"sentence\", NAMESPACE_URI);\n        sentElem.addAttribute(new Attribute(\"id\", Integer.toString(sentCount)));\n        Integer lineNumber = sentence.get(CoreAnnotations.LineNumberAnnotation.class);\n        if (lineNumber != null) {\n          sentElem.addAttribute(new Attribute(\"line\", Integer.toString(lineNumber)));\n        }\n        sentCount ++;\n\n        // add the word table with all token-level annotations\n        Element wordTable = new Element(\"tokens\", NAMESPACE_URI);\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        for(int j = 0; j < tokens.size(); j ++){\n          Element wordInfo = new Element(\"token\", NAMESPACE_URI);\n          addWordInfo(wordInfo, tokens.get(j), j + 1, NAMESPACE_URI);\n          wordTable.appendChild(wordInfo);\n        }\n        sentElem.appendChild(wordTable);\n\n        // add tree info\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n\n        if(tree != null){\n          // add the constituent tree for this sentence\n          Element parseInfo = new Element(\"parse\", NAMESPACE_URI);\n          addConstituentTreeInfo(parseInfo, tree, options.constituentTreePrinter);\n          sentElem.appendChild(parseInfo);\n\n          // add the dependencies for this sentence\n          Element depInfo = buildDependencyTreeInfo(\"basic-dependencies\", sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-ccprocessed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n        }\n\n        // add the MR entities and relations\n        List<EntityMention> entities = sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);\n        List<RelationMention> relations = sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);\n        if (entities != null && entities.size() > 0){\n          Element mrElem = new Element(\"MachineReading\", NAMESPACE_URI);\n          Element entElem = new Element(\"entities\", NAMESPACE_URI);\n          addEntities(entities, entElem, NAMESPACE_URI);\n          mrElem.appendChild(entElem);\n\n          if(relations != null){\n            Element relElem = new Element(\"relations\", NAMESPACE_URI);\n            addRelations(relations, relElem, NAMESPACE_URI, options.relationsBeam);\n            mrElem.appendChild(relElem);\n          }\n\n          sentElem.appendChild(mrElem);\n        }\n\n        // add the sentence to the root\n        sentencesElem.appendChild(sentElem);\n      }\n    }\n\n    //\n    // add the coref graph\n    //\n    Map<Integer, CorefChain> corefChains =\n      annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);\n    if (corefChains != null) {\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      Element corefInfo = new Element(\"coreference\", NAMESPACE_URI);\n      if (addCorefGraphInfo(corefInfo, sentences, corefChains, NAMESPACE_URI))\n        docElem.appendChild(corefInfo);\n    }\n\n    //\n    // save any document-level annotations here\n    //\n\n    return xmlDoc;\n  }","id":22231,"modified_method":"/**\n   * Converts the given annotation to an XML document using the specified options\n   */\n  public static Document annotationToDoc(Annotation annotation, Options options) {\n    //\n    // create the XML document with the root node pointing to the namespace URL\n    //\n    Element root = new Element(\"root\", NAMESPACE_URI);\n    Document xmlDoc = new Document(root);\n    ProcessingInstruction pi = new ProcessingInstruction(\"xml-stylesheet\",\n          \"href=\\\"\" + STYLESHEET_NAME + \"\\\" type=\\\"text/xsl\\\"\");\n    xmlDoc.insertChild(pi, 0);\n    Element docElem = new Element(\"document\", NAMESPACE_URI);\n    root.appendChild(docElem);\n\n    setSingleElement(docElem, \"docId\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocIDAnnotation.class));\n    setSingleElement(docElem, \"docDate\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocDateAnnotation.class));\n    setSingleElement(docElem, \"docSourceType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocSourceTypeAnnotation.class));\n    setSingleElement(docElem, \"docType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocTypeAnnotation.class));\n    setSingleElement(docElem, \"author\", NAMESPACE_URI, annotation.get(CoreAnnotations.AuthorAnnotation.class));\n    setSingleElement(docElem, \"location\", NAMESPACE_URI, annotation.get(CoreAnnotations.LocationAnnotation.class));\n\n    if (options.includeText) {\n      setSingleElement(docElem, \"text\", NAMESPACE_URI, annotation.get(CoreAnnotations.TextAnnotation.class));\n    }\n\n    Element sentencesElem = new Element(\"sentences\", NAMESPACE_URI);\n    docElem.appendChild(sentencesElem);\n\n    //\n    // save the info for each sentence in this doc\n    //\n    if(annotation.get(CoreAnnotations.SentencesAnnotation.class) != null){\n      int sentCount = 1;\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Element sentElem = new Element(\"sentence\", NAMESPACE_URI);\n        sentElem.addAttribute(new Attribute(\"id\", Integer.toString(sentCount)));\n        Integer lineNumber = sentence.get(CoreAnnotations.LineNumberAnnotation.class);\n        if (lineNumber != null) {\n          sentElem.addAttribute(new Attribute(\"line\", Integer.toString(lineNumber)));\n        }\n        sentCount ++;\n\n        // add the word table with all token-level annotations\n        Element wordTable = new Element(\"tokens\", NAMESPACE_URI);\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        for(int j = 0; j < tokens.size(); j ++){\n          Element wordInfo = new Element(\"token\", NAMESPACE_URI);\n          addWordInfo(wordInfo, tokens.get(j), j + 1, NAMESPACE_URI);\n          wordTable.appendChild(wordInfo);\n        }\n        sentElem.appendChild(wordTable);\n\n        // add tree info\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n\n        if(tree != null){\n          // add the constituent tree for this sentence\n          Element parseInfo = new Element(\"parse\", NAMESPACE_URI);\n          addConstituentTreeInfo(parseInfo, tree, options.constituentTreePrinter);\n          sentElem.appendChild(parseInfo);\n\n          // add the dependencies for this sentence\n          Element depInfo = buildDependencyTreeInfo(\"basic-dependencies\", sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-ccprocessed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n        }\n\n        // add the MR entities and relations\n        List<EntityMention> entities = sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);\n        List<RelationMention> relations = sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);\n        if (entities != null && entities.size() > 0){\n          Element mrElem = new Element(\"MachineReading\", NAMESPACE_URI);\n          Element entElem = new Element(\"entities\", NAMESPACE_URI);\n          addEntities(entities, entElem, NAMESPACE_URI);\n          mrElem.appendChild(entElem);\n\n          if(relations != null){\n            Element relElem = new Element(\"relations\", NAMESPACE_URI);\n            addRelations(relations, relElem, NAMESPACE_URI, options.relationsBeam);\n            mrElem.appendChild(relElem);\n          }\n\n          sentElem.appendChild(mrElem);\n        }\n\n        // add the sentence to the root\n        sentencesElem.appendChild(sentElem);\n      }\n    }\n\n    //\n    // add the coref graph\n    //\n    Map<Integer, CorefChain> corefChains =\n      annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);\n    if (corefChains != null) {\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      Element corefInfo = new Element(\"coreference\", NAMESPACE_URI);\n      // Do you want context with your coreference?\n      // If so provide sentences to coreference so context from sentences can be added\n      List<CoreMap> corefSents = (options.includeCoreferenceContext)? sentences:null;\n      if (addCorefGraphInfo(corefInfo, corefSents, corefChains, NAMESPACE_URI))\n        docElem.appendChild(corefInfo);\n    }\n\n    //\n    // save any document-level annotations here\n    //\n\n    return xmlDoc;\n  }","commit_id":"0fce5fba6fbe920545eab64224bfb5e2ef6f94b7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void addCorefMention(Element chainElem, String curNS,\n                                      List<CoreMap> sentences,\n                                      CorefChain.CorefMention mention,\n                                      boolean representative) {\n    Element mentionElem = new Element(\"mention\", curNS);\n    if (representative) {\n      mentionElem.addAttribute(new Attribute(\"representative\", \"true\"));\n    }\n\n    setSingleElement(mentionElem, \"sentence\", curNS,\n                     Integer.toString(mention.sentNum));\n    setSingleElement(mentionElem, \"start\", curNS,\n                     Integer.toString(mention.startIndex));\n    setSingleElement(mentionElem, \"end\", curNS,\n                     Integer.toString(mention.endIndex));\n    setSingleElement(mentionElem, \"head\", curNS,\n                     Integer.toString(mention.headIndex));\n\n    if (sentences != null) {\n      String text = StringUtils.joinWords(sentences.get(mention.sentNum - 1).get(CoreAnnotations.TokensAnnotation.class),\n              \" \", mention.startIndex - 1, mention.endIndex -1);\n      setSingleElement(mentionElem, \"text\", curNS, text);\n    }\n\n    chainElem.appendChild(mentionElem);\n  }","id":22232,"modified_method":"private static void addCorefMention(Element chainElem, String curNS,\n                                      List<CoreMap> sentences,\n                                      CorefChain.CorefMention mention,\n                                      boolean representative) {\n    Element mentionElem = new Element(\"mention\", curNS);\n    if (representative) {\n      mentionElem.addAttribute(new Attribute(\"representative\", \"true\"));\n    }\n\n    setSingleElement(mentionElem, \"sentence\", curNS,\n                     Integer.toString(mention.sentNum));\n    setSingleElement(mentionElem, \"start\", curNS,\n                     Integer.toString(mention.startIndex));\n    setSingleElement(mentionElem, \"end\", curNS,\n                     Integer.toString(mention.endIndex));\n    setSingleElement(mentionElem, \"head\", curNS,\n                     Integer.toString(mention.headIndex));\n\n    String text = mention.mentionSpan;\n    setSingleElement(mentionElem, \"text\", curNS, text);\n    if (sentences != null) {\n      List<CoreLabel> tokens = sentences.get(mention.sentNum - 1).get(CoreAnnotations.TokensAnnotation.class);\n      int contextStart = Math.max(mention.startIndex - 1 - 5, 0);\n      int contextEnd = Math.min(mention.endIndex - 1 + 5, tokens.size());\n      String context = StringUtils.joinWords(tokens, \" \", contextStart, mention.startIndex - 1)\n              + \"[[\" + mention.mentionSpan + \"]]\" + StringUtils.joinWords(tokens, \" \", mention.endIndex - 1, contextEnd);\n      setSingleElement(mentionElem, \"context\", curNS, context);\n    }\n\n    chainElem.appendChild(mentionElem);\n  }","commit_id":"0fce5fba6fbe920545eab64224bfb5e2ef6f94b7","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Converts the given annotation to an XML document using the specified options\n   */\n  public static Document annotationToDoc(Annotation annotation, Options options) {\n    //\n    // create the XML document with the root node pointing to the namespace URL\n    //\n    Element root = new Element(\"root\", NAMESPACE_URI);\n    Document xmlDoc = new Document(root);\n    ProcessingInstruction pi = new ProcessingInstruction(\"xml-stylesheet\",\n          \"href=\\\"\" + STYLESHEET_NAME + \"\\\" type=\\\"text/xsl\\\"\");\n    xmlDoc.insertChild(pi, 0);\n    Element docElem = new Element(\"document\", NAMESPACE_URI);\n    root.appendChild(docElem);\n\n    setSingleElement(docElem, \"docId\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocIDAnnotation.class));\n    setSingleElement(docElem, \"docDate\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocDateAnnotation.class));\n    setSingleElement(docElem, \"docSourceType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocSourceTypeAnnotation.class));\n    setSingleElement(docElem, \"docType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocTypeAnnotation.class));\n    setSingleElement(docElem, \"author\", NAMESPACE_URI, annotation.get(CoreAnnotations.AuthorAnnotation.class));\n    setSingleElement(docElem, \"location\", NAMESPACE_URI, annotation.get(CoreAnnotations.LocationAnnotation.class));\n\n    if (options.includeText) {\n      setSingleElement(docElem, \"text\", NAMESPACE_URI, annotation.get(CoreAnnotations.TextAnnotation.class));\n    }\n\n    Element sentencesElem = new Element(\"sentences\", NAMESPACE_URI);\n    docElem.appendChild(sentencesElem);\n\n    //\n    // save the info for each sentence in this doc\n    //\n    if(annotation.get(CoreAnnotations.SentencesAnnotation.class) != null){\n      int sentCount = 1;\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Element sentElem = new Element(\"sentence\", NAMESPACE_URI);\n        sentElem.addAttribute(new Attribute(\"id\", Integer.toString(sentCount)));\n        Integer lineNumber = sentence.get(CoreAnnotations.LineNumberAnnotation.class);\n        if (lineNumber != null) {\n          sentElem.addAttribute(new Attribute(\"line\", Integer.toString(lineNumber)));\n        }\n        sentCount ++;\n\n        // add the word table with all token-level annotations\n        Element wordTable = new Element(\"tokens\", NAMESPACE_URI);\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        for(int j = 0; j < tokens.size(); j ++){\n          Element wordInfo = new Element(\"token\", NAMESPACE_URI);\n          addWordInfo(wordInfo, tokens.get(j), j + 1, NAMESPACE_URI);\n          wordTable.appendChild(wordInfo);\n        }\n        sentElem.appendChild(wordTable);\n\n        // add tree info\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n\n        if(tree != null){\n          // add the constituent tree for this sentence\n          Element parseInfo = new Element(\"parse\", NAMESPACE_URI);\n          addConstituentTreeInfo(parseInfo, tree, options.constituentTreePrinter);\n          sentElem.appendChild(parseInfo);\n\n          // add the dependencies for this sentence\n          Element depInfo = buildDependencyTreeInfo(\"basic-dependencies\", sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-ccprocessed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n        }\n\n        // add the MR entities and relations\n        List<EntityMention> entities = sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);\n        List<RelationMention> relations = sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);\n        if (entities != null && entities.size() > 0){\n          Element mrElem = new Element(\"MachineReading\", NAMESPACE_URI);\n          Element entElem = new Element(\"entities\", NAMESPACE_URI);\n          addEntities(entities, entElem, NAMESPACE_URI);\n          mrElem.appendChild(entElem);\n\n          if(relations != null){\n            Element relElem = new Element(\"relations\", NAMESPACE_URI);\n            addRelations(relations, relElem, NAMESPACE_URI, options.relationsBeam);\n            mrElem.appendChild(relElem);\n          }\n\n          sentElem.appendChild(mrElem);\n        }\n\n        // add the sentence to the root\n        sentencesElem.appendChild(sentElem);\n      }\n    }\n\n    //\n    // add the coref graph\n    //\n    Map<Integer, CorefChain> corefChains =\n      annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);\n    if (corefChains != null) {\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      Element corefInfo = new Element(\"coreference\", NAMESPACE_URI);\n      if (addCorefGraphInfo(corefInfo, sentences, corefChains, NAMESPACE_URI))\n        docElem.appendChild(corefInfo);\n    }\n\n    //\n    // save any document-level annotations here\n    //\n\n    return xmlDoc;\n  }","id":22233,"modified_method":"/**\n   * Converts the given annotation to an XML document using the specified options\n   */\n  public static Document annotationToDoc(Annotation annotation, Options options) {\n    //\n    // create the XML document with the root node pointing to the namespace URL\n    //\n    Element root = new Element(\"root\", NAMESPACE_URI);\n    Document xmlDoc = new Document(root);\n    ProcessingInstruction pi = new ProcessingInstruction(\"xml-stylesheet\",\n          \"href=\\\"\" + STYLESHEET_NAME + \"\\\" type=\\\"text/xsl\\\"\");\n    xmlDoc.insertChild(pi, 0);\n    Element docElem = new Element(\"document\", NAMESPACE_URI);\n    root.appendChild(docElem);\n\n    setSingleElement(docElem, \"docId\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocIDAnnotation.class));\n    setSingleElement(docElem, \"docDate\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocDateAnnotation.class));\n    setSingleElement(docElem, \"docSourceType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocSourceTypeAnnotation.class));\n    setSingleElement(docElem, \"docType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocTypeAnnotation.class));\n    setSingleElement(docElem, \"author\", NAMESPACE_URI, annotation.get(CoreAnnotations.AuthorAnnotation.class));\n    setSingleElement(docElem, \"location\", NAMESPACE_URI, annotation.get(CoreAnnotations.LocationAnnotation.class));\n\n    if (options.includeText) {\n      setSingleElement(docElem, \"text\", NAMESPACE_URI, annotation.get(CoreAnnotations.TextAnnotation.class));\n    }\n\n    Element sentencesElem = new Element(\"sentences\", NAMESPACE_URI);\n    docElem.appendChild(sentencesElem);\n\n    //\n    // save the info for each sentence in this doc\n    //\n    if(annotation.get(CoreAnnotations.SentencesAnnotation.class) != null){\n      int sentCount = 1;\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Element sentElem = new Element(\"sentence\", NAMESPACE_URI);\n        sentElem.addAttribute(new Attribute(\"id\", Integer.toString(sentCount)));\n        Integer lineNumber = sentence.get(CoreAnnotations.LineNumberAnnotation.class);\n        if (lineNumber != null) {\n          sentElem.addAttribute(new Attribute(\"line\", Integer.toString(lineNumber)));\n        }\n        sentCount ++;\n\n        // add the word table with all token-level annotations\n        Element wordTable = new Element(\"tokens\", NAMESPACE_URI);\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        for(int j = 0; j < tokens.size(); j ++){\n          Element wordInfo = new Element(\"token\", NAMESPACE_URI);\n          addWordInfo(wordInfo, tokens.get(j), j + 1, NAMESPACE_URI);\n          wordTable.appendChild(wordInfo);\n        }\n        sentElem.appendChild(wordTable);\n\n        // add tree info\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n\n        if(tree != null){\n          // add the constituent tree for this sentence\n          Element parseInfo = new Element(\"parse\", NAMESPACE_URI);\n          addConstituentTreeInfo(parseInfo, tree, options.constituentTreePrinter);\n          sentElem.appendChild(parseInfo);\n\n          // add the dependencies for this sentence\n          Element depInfo = buildDependencyTreeInfo(\"basic-dependencies\", sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-ccprocessed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n        }\n\n        // add the MR entities and relations\n        List<EntityMention> entities = sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);\n        List<RelationMention> relations = sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);\n        if (entities != null && entities.size() > 0){\n          Element mrElem = new Element(\"MachineReading\", NAMESPACE_URI);\n          Element entElem = new Element(\"entities\", NAMESPACE_URI);\n          addEntities(entities, entElem, NAMESPACE_URI);\n          mrElem.appendChild(entElem);\n\n          if(relations != null){\n            Element relElem = new Element(\"relations\", NAMESPACE_URI);\n            addRelations(relations, relElem, NAMESPACE_URI, options.relationsBeam);\n            mrElem.appendChild(relElem);\n          }\n\n          sentElem.appendChild(mrElem);\n        }\n\n        // add the sentence to the root\n        sentencesElem.appendChild(sentElem);\n      }\n    }\n\n    //\n    // add the coref graph\n    //\n    Map<Integer, CorefChain> corefChains =\n      annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);\n    if (corefChains != null) {\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      Element corefInfo = new Element(\"coreference\", NAMESPACE_URI);\n      // Do you want context with your coreference?\n      // If so provide sentences to coreference so context from sentences can be added\n      List<CoreMap> corefSents = (options.includeCoreferenceContext)? sentences:null;\n      if (addCorefGraphInfo(corefInfo, corefSents, corefChains, NAMESPACE_URI))\n        docElem.appendChild(corefInfo);\n    }\n\n    //\n    // save any document-level annotations here\n    //\n\n    return xmlDoc;\n  }","commit_id":"3820582270b98693b22cb530dcb7f8c3c52711d9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void addCorefMention(Element chainElem, String curNS,\n                                      List<CoreMap> sentences,\n                                      CorefChain.CorefMention mention,\n                                      boolean representative) {\n    Element mentionElem = new Element(\"mention\", curNS);\n    if (representative) {\n      mentionElem.addAttribute(new Attribute(\"representative\", \"true\"));\n    }\n\n    setSingleElement(mentionElem, \"sentence\", curNS,\n                     Integer.toString(mention.sentNum));\n    setSingleElement(mentionElem, \"start\", curNS,\n                     Integer.toString(mention.startIndex));\n    setSingleElement(mentionElem, \"end\", curNS,\n                     Integer.toString(mention.endIndex));\n    setSingleElement(mentionElem, \"head\", curNS,\n                     Integer.toString(mention.headIndex));\n\n    if (sentences != null) {\n      String text = StringUtils.joinWords(sentences.get(mention.sentNum - 1).get(CoreAnnotations.TokensAnnotation.class),\n              \" \", mention.startIndex - 1, mention.endIndex -1);\n      setSingleElement(mentionElem, \"text\", curNS, text);\n    }\n\n    chainElem.appendChild(mentionElem);\n  }","id":22234,"modified_method":"private static void addCorefMention(Element chainElem, String curNS,\n                                      List<CoreMap> sentences,\n                                      CorefChain.CorefMention mention,\n                                      boolean representative) {\n    Element mentionElem = new Element(\"mention\", curNS);\n    if (representative) {\n      mentionElem.addAttribute(new Attribute(\"representative\", \"true\"));\n    }\n\n    setSingleElement(mentionElem, \"sentence\", curNS,\n                     Integer.toString(mention.sentNum));\n    setSingleElement(mentionElem, \"start\", curNS,\n                     Integer.toString(mention.startIndex));\n    setSingleElement(mentionElem, \"end\", curNS,\n                     Integer.toString(mention.endIndex));\n    setSingleElement(mentionElem, \"head\", curNS,\n                     Integer.toString(mention.headIndex));\n\n    String text = mention.mentionSpan;\n    setSingleElement(mentionElem, \"text\", curNS, text);\n    if (sentences != null) {\n      List<CoreLabel> tokens = sentences.get(mention.sentNum - 1).get(CoreAnnotations.TokensAnnotation.class);\n      int contextStart = Math.max(mention.startIndex - 1 - 5, 0);\n      int contextEnd = Math.min(mention.endIndex - 1 + 5, tokens.size());\n      String context = StringUtils.joinWords(tokens, \" \", contextStart, mention.startIndex - 1)\n              + \"[[\" + mention.mentionSpan + \"]]\" + StringUtils.joinWords(tokens, \" \", mention.endIndex - 1, contextEnd);\n      setSingleElement(mentionElem, \"context\", curNS, context);\n    }\n\n    chainElem.appendChild(mentionElem);\n  }","commit_id":"3820582270b98693b22cb530dcb7f8c3c52711d9","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void addCorefMention(Element chainElem, String curNS,\n                                      List<CoreMap> sentences,\n                                      CorefChain.CorefMention mention,\n                                      boolean representative) {\n    Element mentionElem = new Element(\"mention\", curNS);\n    if (representative) {\n      mentionElem.addAttribute(new Attribute(\"representative\", \"true\"));\n    }\n\n    setSingleElement(mentionElem, \"sentence\", curNS,\n                     Integer.toString(mention.sentNum));\n    setSingleElement(mentionElem, \"start\", curNS,\n                     Integer.toString(mention.startIndex));\n    setSingleElement(mentionElem, \"end\", curNS,\n                     Integer.toString(mention.endIndex));\n    setSingleElement(mentionElem, \"head\", curNS,\n                     Integer.toString(mention.headIndex));\n\n    if (sentences != null) {\n      String text = StringUtils.joinWords(sentences.get(mention.sentNum - 1).get(CoreAnnotations.TokensAnnotation.class),\n              \" \", mention.startIndex - 1, mention.endIndex -1);\n      setSingleElement(mentionElem, \"text\", curNS, text);\n    }\n\n    chainElem.appendChild(mentionElem);\n  }","id":22235,"modified_method":"private static void addCorefMention(Element chainElem, String curNS,\n                                      List<CoreMap> sentences,\n                                      CorefChain.CorefMention mention,\n                                      boolean representative) {\n    Element mentionElem = new Element(\"mention\", curNS);\n    if (representative) {\n      mentionElem.addAttribute(new Attribute(\"representative\", \"true\"));\n    }\n\n    setSingleElement(mentionElem, \"sentence\", curNS,\n                     Integer.toString(mention.sentNum));\n    setSingleElement(mentionElem, \"start\", curNS,\n                     Integer.toString(mention.startIndex));\n    setSingleElement(mentionElem, \"end\", curNS,\n                     Integer.toString(mention.endIndex));\n    setSingleElement(mentionElem, \"head\", curNS,\n                     Integer.toString(mention.headIndex));\n\n    String text = mention.mentionSpan;\n    setSingleElement(mentionElem, \"text\", curNS, text);\n    if (sentences != null) {\n      List<CoreLabel> tokens = sentences.get(mention.sentNum - 1).get(CoreAnnotations.TokensAnnotation.class);\n      int contextStart = Math.max(mention.startIndex - 1 - 5, 0);\n      int contextEnd = Math.min(mention.endIndex - 1 + 5, tokens.size());\n      String context = StringUtils.joinWords(tokens, \" \", contextStart, mention.startIndex - 1)\n              + \"[[\" + mention.mentionSpan + \"]]\" + StringUtils.joinWords(tokens, \" \", mention.endIndex - 1, contextEnd);\n      setSingleElement(mentionElem, \"context\", curNS, context);\n    }\n\n    chainElem.appendChild(mentionElem);\n  }","commit_id":"d8aff55b536e3f1ef6bff25bf7eebd0141611db3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Converts the given annotation to an XML document using the specified options\n   */\n  public static Document annotationToDoc(Annotation annotation, Options options) {\n    //\n    // create the XML document with the root node pointing to the namespace URL\n    //\n    Element root = new Element(\"root\", NAMESPACE_URI);\n    Document xmlDoc = new Document(root);\n    ProcessingInstruction pi = new ProcessingInstruction(\"xml-stylesheet\",\n          \"href=\\\"\" + STYLESHEET_NAME + \"\\\" type=\\\"text/xsl\\\"\");\n    xmlDoc.insertChild(pi, 0);\n    Element docElem = new Element(\"document\", NAMESPACE_URI);\n    root.appendChild(docElem);\n\n    setSingleElement(docElem, \"docId\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocIDAnnotation.class));\n    setSingleElement(docElem, \"docDate\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocDateAnnotation.class));\n    setSingleElement(docElem, \"docSourceType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocSourceTypeAnnotation.class));\n    setSingleElement(docElem, \"docType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocTypeAnnotation.class));\n    setSingleElement(docElem, \"author\", NAMESPACE_URI, annotation.get(CoreAnnotations.AuthorAnnotation.class));\n    setSingleElement(docElem, \"location\", NAMESPACE_URI, annotation.get(CoreAnnotations.LocationAnnotation.class));\n\n    if (options.includeText) {\n      setSingleElement(docElem, \"text\", NAMESPACE_URI, annotation.get(CoreAnnotations.TextAnnotation.class));\n    }\n\n    Element sentencesElem = new Element(\"sentences\", NAMESPACE_URI);\n    docElem.appendChild(sentencesElem);\n\n    //\n    // save the info for each sentence in this doc\n    //\n    if(annotation.get(CoreAnnotations.SentencesAnnotation.class) != null){\n      int sentCount = 1;\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Element sentElem = new Element(\"sentence\", NAMESPACE_URI);\n        sentElem.addAttribute(new Attribute(\"id\", Integer.toString(sentCount)));\n        Integer lineNumber = sentence.get(CoreAnnotations.LineNumberAnnotation.class);\n        if (lineNumber != null) {\n          sentElem.addAttribute(new Attribute(\"line\", Integer.toString(lineNumber)));\n        }\n        sentCount ++;\n\n        // add the word table with all token-level annotations\n        Element wordTable = new Element(\"tokens\", NAMESPACE_URI);\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        for(int j = 0; j < tokens.size(); j ++){\n          Element wordInfo = new Element(\"token\", NAMESPACE_URI);\n          addWordInfo(wordInfo, tokens.get(j), j + 1, NAMESPACE_URI);\n          wordTable.appendChild(wordInfo);\n        }\n        sentElem.appendChild(wordTable);\n\n        // add tree info\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n\n        if(tree != null){\n          // add the constituent tree for this sentence\n          Element parseInfo = new Element(\"parse\", NAMESPACE_URI);\n          addConstituentTreeInfo(parseInfo, tree, options.constituentTreePrinter);\n          sentElem.appendChild(parseInfo);\n\n          // add the dependencies for this sentence\n          Element depInfo = buildDependencyTreeInfo(\"basic-dependencies\", sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-ccprocessed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n        }\n\n        // add the MR entities and relations\n        List<EntityMention> entities = sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);\n        List<RelationMention> relations = sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);\n        if (entities != null && entities.size() > 0){\n          Element mrElem = new Element(\"MachineReading\", NAMESPACE_URI);\n          Element entElem = new Element(\"entities\", NAMESPACE_URI);\n          addEntities(entities, entElem, NAMESPACE_URI);\n          mrElem.appendChild(entElem);\n\n          if(relations != null){\n            Element relElem = new Element(\"relations\", NAMESPACE_URI);\n            addRelations(relations, relElem, NAMESPACE_URI, options.relationsBeam);\n            mrElem.appendChild(relElem);\n          }\n\n          sentElem.appendChild(mrElem);\n        }\n\n        // add the sentence to the root\n        sentencesElem.appendChild(sentElem);\n      }\n    }\n\n    //\n    // add the coref graph\n    //\n    Map<Integer, CorefChain> corefChains =\n      annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);\n    if (corefChains != null) {\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      Element corefInfo = new Element(\"coreference\", NAMESPACE_URI);\n      if (addCorefGraphInfo(corefInfo, sentences, corefChains, NAMESPACE_URI))\n        docElem.appendChild(corefInfo);\n    }\n\n    //\n    // save any document-level annotations here\n    //\n\n    return xmlDoc;\n  }","id":22236,"modified_method":"/**\n   * Converts the given annotation to an XML document using the specified options\n   */\n  public static Document annotationToDoc(Annotation annotation, Options options) {\n    //\n    // create the XML document with the root node pointing to the namespace URL\n    //\n    Element root = new Element(\"root\", NAMESPACE_URI);\n    Document xmlDoc = new Document(root);\n    ProcessingInstruction pi = new ProcessingInstruction(\"xml-stylesheet\",\n          \"href=\\\"\" + STYLESHEET_NAME + \"\\\" type=\\\"text/xsl\\\"\");\n    xmlDoc.insertChild(pi, 0);\n    Element docElem = new Element(\"document\", NAMESPACE_URI);\n    root.appendChild(docElem);\n\n    setSingleElement(docElem, \"docId\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocIDAnnotation.class));\n    setSingleElement(docElem, \"docDate\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocDateAnnotation.class));\n    setSingleElement(docElem, \"docSourceType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocSourceTypeAnnotation.class));\n    setSingleElement(docElem, \"docType\", NAMESPACE_URI, annotation.get(CoreAnnotations.DocTypeAnnotation.class));\n    setSingleElement(docElem, \"author\", NAMESPACE_URI, annotation.get(CoreAnnotations.AuthorAnnotation.class));\n    setSingleElement(docElem, \"location\", NAMESPACE_URI, annotation.get(CoreAnnotations.LocationAnnotation.class));\n\n    if (options.includeText) {\n      setSingleElement(docElem, \"text\", NAMESPACE_URI, annotation.get(CoreAnnotations.TextAnnotation.class));\n    }\n\n    Element sentencesElem = new Element(\"sentences\", NAMESPACE_URI);\n    docElem.appendChild(sentencesElem);\n\n    //\n    // save the info for each sentence in this doc\n    //\n    if(annotation.get(CoreAnnotations.SentencesAnnotation.class) != null){\n      int sentCount = 1;\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        Element sentElem = new Element(\"sentence\", NAMESPACE_URI);\n        sentElem.addAttribute(new Attribute(\"id\", Integer.toString(sentCount)));\n        Integer lineNumber = sentence.get(CoreAnnotations.LineNumberAnnotation.class);\n        if (lineNumber != null) {\n          sentElem.addAttribute(new Attribute(\"line\", Integer.toString(lineNumber)));\n        }\n        sentCount ++;\n\n        // add the word table with all token-level annotations\n        Element wordTable = new Element(\"tokens\", NAMESPACE_URI);\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        for(int j = 0; j < tokens.size(); j ++){\n          Element wordInfo = new Element(\"token\", NAMESPACE_URI);\n          addWordInfo(wordInfo, tokens.get(j), j + 1, NAMESPACE_URI);\n          wordTable.appendChild(wordInfo);\n        }\n        sentElem.appendChild(wordTable);\n\n        // add tree info\n        Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);\n\n        if(tree != null){\n          // add the constituent tree for this sentence\n          Element parseInfo = new Element(\"parse\", NAMESPACE_URI);\n          addConstituentTreeInfo(parseInfo, tree, options.constituentTreePrinter);\n          sentElem.appendChild(parseInfo);\n\n          // add the dependencies for this sentence\n          Element depInfo = buildDependencyTreeInfo(\"basic-dependencies\", sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n\n          depInfo = buildDependencyTreeInfo(\"collapsed-ccprocessed-dependencies\", sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), tokens, NAMESPACE_URI);\n          if (depInfo != null) {\n            sentElem.appendChild(depInfo);\n          }\n        }\n\n        // add the MR entities and relations\n        List<EntityMention> entities = sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);\n        List<RelationMention> relations = sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);\n        if (entities != null && entities.size() > 0){\n          Element mrElem = new Element(\"MachineReading\", NAMESPACE_URI);\n          Element entElem = new Element(\"entities\", NAMESPACE_URI);\n          addEntities(entities, entElem, NAMESPACE_URI);\n          mrElem.appendChild(entElem);\n\n          if(relations != null){\n            Element relElem = new Element(\"relations\", NAMESPACE_URI);\n            addRelations(relations, relElem, NAMESPACE_URI, options.relationsBeam);\n            mrElem.appendChild(relElem);\n          }\n\n          sentElem.appendChild(mrElem);\n        }\n\n        // add the sentence to the root\n        sentencesElem.appendChild(sentElem);\n      }\n    }\n\n    //\n    // add the coref graph\n    //\n    Map<Integer, CorefChain> corefChains =\n      annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);\n    if (corefChains != null) {\n      List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);\n      Element corefInfo = new Element(\"coreference\", NAMESPACE_URI);\n      // Do you want context with your coreference?\n      // If so provide sentences to coreference so context from sentences can be added\n      List<CoreMap> corefSents = (options.includeCoreferenceContext)? sentences:null;\n      if (addCorefGraphInfo(corefInfo, corefSents, corefChains, NAMESPACE_URI))\n        docElem.appendChild(corefInfo);\n    }\n\n    //\n    // save any document-level annotations here\n    //\n\n    return xmlDoc;\n  }","commit_id":"d8aff55b536e3f1ef6bff25bf7eebd0141611db3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void runTestSnapshotDeleteIndependent(boolean online) throws Exception {\n    FileSystem fs = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();\n    Path rootDir = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();\n\n    final Admin admin = UTIL.getHBaseAdmin();\n    final long startTime = System.currentTimeMillis();\n    final TableName localTableName =\n        TableName.valueOf(STRING_TABLE_NAME + startTime);\n\n    try (Table original = createTable(localTableName, TEST_FAM)) {\n      loadData(original, TEST_FAM);\n    }\n\n    // Take a snapshot\n    final String snapshotNameAsString = \"snapshot_\" + localTableName;\n    byte[] snapshotName = Bytes.toBytes(snapshotNameAsString);\n\n    SnapshotTestingUtils.createSnapshotAndValidate(admin, localTableName, TEST_FAM_STR,\n        snapshotNameAsString, rootDir, fs, online);\n\n    if (!online) {\n      tryDisable(admin, localTableName);\n    }\n\n    TableName cloneTableName = TableName.valueOf(\"test-clone-\" + localTableName);\n    admin.cloneSnapshot(snapshotName, cloneTableName);\n\n    UTIL.waitUntilAllRegionsAssigned(cloneTableName);\n\n    // Ensure the original table does not reference the HFiles anymore\n    admin.majorCompact(localTableName);\n\n    // Deleting the snapshot used to break the cloned table by deleting in-use HFiles\n    admin.deleteSnapshot(snapshotName);\n\n    // Wait for cleaner run and DFS heartbeats so that anything that is deletable is fully deleted\n    do {\n      Thread.sleep(5000);\n    } while (!admin.listSnapshots(snapshotNameAsString).isEmpty());\n\n    try (Table original = UTIL.getConnection().getTable(localTableName)) {\n      try (Table clonedTable = UTIL.getConnection().getTable(cloneTableName)) {\n        // Verify that all regions of both tables are readable\n        final int origTableRowCount = countRows(original);\n        final int clonedTableRowCount = countRows(clonedTable);\n        Assert.assertEquals(origTableRowCount, clonedTableRowCount);\n      }\n    }\n  }","id":22237,"modified_method":"/**\n   * Verify that deleting the snapshot does not affect either table.\n   */\n  private void runTestSnapshotDeleteIndependent() throws Exception {\n    // Ensure the original table does not reference the HFiles anymore\n    admin.majorCompact(originalTableName);\n\n    // Deleting the snapshot used to break the cloned table by deleting in-use HFiles\n    admin.deleteSnapshot(snapshotName);\n\n    // Wait for cleaner run and DFS heartbeats so that anything that is deletable is fully deleted\n    do {\n      Thread.sleep(5000);\n    } while (!admin.listSnapshots(snapshotNameAsString).isEmpty());\n\n    try (Table original = UTIL.getConnection().getTable(originalTableName)) {\n      try (Table clonedTable = UTIL.getConnection().getTable(cloneTableName)) {\n        // Verify that all regions of both tables are readable\n        final int origTableRowCount = countRows(original);\n        final int clonedTableRowCount = countRows(clonedTable);\n        Assert.assertEquals(origTableRowCount, clonedTableRowCount);\n      }\n    }\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"@Before\n  public void setup() throws Exception {\n    createTable(TABLE_NAME, TEST_FAM);\n  }","id":22238,"modified_method":"@Before\n  public void setup() throws Exception {\n    fs = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();\n    rootDir = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();\n\n    admin = UTIL.getHBaseAdmin();\n    originalTableName = TableName.valueOf(\"test\" + testName.getMethodName());\n    cloneTableName = TableName.valueOf(\"test-clone-\" + originalTableName);\n    snapshotNameAsString = \"snapshot_\" + originalTableName;\n    snapshotName = Bytes.toBytes(snapshotNameAsString);\n\n    originalTable = createTable(originalTableName, TEST_FAM);\n    loadData(originalTable, TEST_FAM);\n    countOriginalTable = countRows(originalTable);\n    System.out.println(\"Original table has: \" + countOriginalTable + \" rows\");\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verify that adding metadata to the cloned table will not affect the original, and vice-versa\n   * when it is taken as an online snapshot.\n   */\n  @Test (timeout=300000)\n  public void testOnlineSnapshotMetadataChangesIndependent() throws Exception {\n    runTestSnapshotMetadataChangesIndependent(true);\n  }","id":22239,"modified_method":"/**\n   * Verify that adding metadata to the cloned table will not affect the original, and vice-versa\n   * when it is taken as an online snapshot.\n   */\n  @Test\n  public void testOnlineSnapshotMetadataChangesIndependent() throws Exception {\n    createAndCloneSnapshot(true);\n    runTestSnapshotMetadataChangesIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verify that adding data to the cloned table will not affect the original, and vice-versa when\n   * it is taken as an online snapshot.\n   */\n  @Ignore (\"Flakey. Fix\") @Test (timeout=300000)\n  public void testOnlineSnapshotAppendIndependent() throws Exception {\n    runTestSnapshotAppendIndependent(true);\n  }","id":22240,"modified_method":"/**\n   * Verify that adding data to the cloned table will not affect the original, and vice-versa when\n   * it is taken as an online snapshot.\n   */\n  @Test\n  public void testOnlineSnapshotAppendIndependent() throws Exception {\n    createAndCloneSnapshot(true);\n    runTestSnapshotAppendIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout=300000)\n  @Ignore\n  public void testOfflineSnapshotDeleteIndependent() throws Exception {\n    runTestSnapshotDeleteIndependent(false);\n  }","id":22241,"modified_method":"@Test\n  public void testOfflineSnapshotDeleteIndependent() throws Exception {\n    createAndCloneSnapshot(false);\n    runTestSnapshotDeleteIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"private void runTestSnapshotAppendIndependent(boolean online) throws Exception {\n    FileSystem fs = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();\n    Path rootDir = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();\n\n    Admin admin = UTIL.getHBaseAdmin();\n    final long startTime = System.currentTimeMillis();\n    final TableName localTableName =\n        TableName.valueOf(STRING_TABLE_NAME + startTime);\n\n    try (Table original = createTable(localTableName, TEST_FAM)) {\n      loadData(original, TEST_FAM);\n      final int origTableRowCount = countRows(original);\n\n      // Take a snapshot\n      final String snapshotNameAsString = \"snapshot_\" + localTableName;\n      byte[] snapshotName = Bytes.toBytes(snapshotNameAsString);\n\n      SnapshotTestingUtils.createSnapshotAndValidate(admin, localTableName, TEST_FAM_STR,\n          snapshotNameAsString, rootDir, fs, online);\n\n      if (!online) {\n        tryDisable(admin, localTableName);\n      }\n      TableName cloneTableName = TableName.valueOf(\"test-clone-\" + localTableName);\n      admin.cloneSnapshot(snapshotName, cloneTableName);\n\n      try (Table clonedTable = UTIL.getConnection().getTable(cloneTableName)) {\n\n        // Make sure that all the regions are available before starting\n        UTIL.waitUntilAllRegionsAssigned(cloneTableName);\n\n        final int clonedTableRowCount = countRows(clonedTable);\n\n        Assert.assertEquals(\n            \"The line counts of original and cloned tables do not match after clone. \",\n            origTableRowCount, clonedTableRowCount);\n\n        // Attempt to add data to the test\n        final String rowKey = \"new-row-\" + System.currentTimeMillis();\n\n        Put p = new Put(Bytes.toBytes(rowKey));\n        p.addColumn(TEST_FAM, Bytes.toBytes(\"someQualifier\"), Bytes.toBytes(\"someString\"));\n        original.put(p);\n\n        // Verify that it is not present in the original table\n        Assert.assertEquals(\"The row count of the original table was not modified by the put\",\n            origTableRowCount + 1, countRows(original));\n        Assert.assertEquals(\n            \"The row count of the cloned table changed as a result of addition to the original\",\n            clonedTableRowCount, countRows(clonedTable));\n\n        p = new Put(Bytes.toBytes(rowKey));\n        p.addColumn(TEST_FAM, Bytes.toBytes(\"someQualifier\"), Bytes.toBytes(\"someString\"));\n        clonedTable.put(p);\n\n        // Verify that the new family is not in the restored table's description\n        Assert.assertEquals(\n            \"The row count of the original table was modified by the put to the clone\",\n            origTableRowCount + 1, countRows(original));\n        Assert.assertEquals(\"The row count of the cloned table was not modified by the put\",\n            clonedTableRowCount + 1, countRows(clonedTable));\n      }\n    }\n  }","id":22242,"modified_method":"/**\n   * Verify that adding data to original table or clone table doesn't affect other table.\n   */\n  private void runTestSnapshotAppendIndependent() throws Exception {\n    try (Table clonedTable = UTIL.getConnection().getTable(cloneTableName)) {\n      final int clonedTableRowCount = countRows(clonedTable);\n\n      Assert.assertEquals(\n        \"The line counts of original and cloned tables do not match after clone. \",\n        countOriginalTable, clonedTableRowCount);\n\n      // Attempt to add data to the test\n      Put p = new Put(Bytes.toBytes(\"new-row-\" + System.currentTimeMillis()));\n      p.addColumn(TEST_FAM, Bytes.toBytes(\"someQualifier\"), Bytes.toBytes(\"someString\"));\n      originalTable.put(p);\n\n      // Verify that the new row is not in the restored table\n      Assert.assertEquals(\"The row count of the original table was not modified by the put\",\n        countOriginalTable + 1, countRows(originalTable));\n      Assert.assertEquals(\n        \"The row count of the cloned table changed as a result of addition to the original\",\n        clonedTableRowCount, countRows(clonedTable));\n\n      Put p2 = new Put(Bytes.toBytes(\"new-row-\" + System.currentTimeMillis()));\n      p2.addColumn(TEST_FAM, Bytes.toBytes(\"someQualifier\"), Bytes.toBytes(\"someString\"));\n      clonedTable.put(p2);\n\n      // Verify that the row is not added to the original table.\n      Assert.assertEquals(\n        \"The row count of the original table was modified by the put to the clone\",\n        countOriginalTable + 1, countRows(originalTable));\n      Assert.assertEquals(\"The row count of the cloned table was not modified by the put\",\n        clonedTableRowCount + 1, countRows(clonedTable));\n    }\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verify that region operations, in this case splitting a region, are independent between the\n   * cloned table and the original.\n   */\n  @Test (timeout=300000)\n  public void testOnlineSnapshotRegionOperationsIndependent() throws Exception {\n    runTestRegionOperationsIndependent(true);\n  }","id":22243,"modified_method":"/**\n   * Verify that region operations, in this case splitting a region, are independent between the\n   * cloned table and the original.\n   */\n  @Test\n  public void testOnlineSnapshotRegionOperationsIndependent() throws Exception {\n    createAndCloneSnapshot(true);\n    runTestRegionOperationsIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"@After\n  public void tearDown() throws Exception {\n    UTIL.deleteTable(TABLE_NAME);\n    SnapshotTestingUtils.deleteAllSnapshots(UTIL.getHBaseAdmin());\n    SnapshotTestingUtils.deleteArchiveDirectory(UTIL);\n  }","id":22244,"modified_method":"@After\n  public void tearDown() throws Exception {\n    UTIL.deleteTable(originalTableName);\n    UTIL.deleteTable(cloneTableName);\n    SnapshotTestingUtils.deleteAllSnapshots(UTIL.getHBaseAdmin());\n    SnapshotTestingUtils.deleteArchiveDirectory(UTIL);\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Setup the config for the cluster and start it\n   * @throws Exception on fOailure\n   */\n  @BeforeClass\n  public static void setupCluster() throws Exception {\n    setupConf(UTIL.getConfiguration());\n    UTIL.startMiniCluster(NUM_RS);\n  }","id":22245,"modified_method":"/**\n   * Setup the config for the cluster and start it\n   */\n  @BeforeClass\n  public static void setupCluster() throws Exception {\n    setupConf(UTIL.getConfiguration());\n    UTIL.startMiniCluster(NUM_RS);\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"protected void loadData(final Table table, byte[]... families) throws Exception {\n    UTIL.loadTable(table, families);\n  }","id":22246,"modified_method":"public void loadData(final Table table, byte[]... families) throws Exception {\n    UTIL.loadTable(originalTable, TEST_FAM);\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verify that adding netadata to the cloned table will not affect the original, and vice-versa\n   * when is taken as an online snapshot.\n   */\n  @Test (timeout=300000)\n  @Ignore\n  public void testOfflineSnapshotMetadataChangesIndependent() throws Exception {\n    runTestSnapshotMetadataChangesIndependent(false);\n  }","id":22247,"modified_method":"/**\n   * Verify that adding netadata to the cloned table will not affect the original, and vice-versa\n   * when is taken as an online snapshot.\n   */\n  @Test\n  public void testOfflineSnapshotMetadataChangesIndependent() throws Exception {\n    createAndCloneSnapshot(false);\n    runTestSnapshotMetadataChangesIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"private void runTestRegionOperationsIndependent(boolean online) throws Exception {\n    FileSystem fs = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();\n    Path rootDir = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();\n\n    // Create a table\n    Admin admin = UTIL.getHBaseAdmin();\n    final long startTime = System.currentTimeMillis();\n    final TableName localTableName =\n        TableName.valueOf(STRING_TABLE_NAME + startTime);\n    Table original = createTable(localTableName, TEST_FAM);\n    loadData(original, TEST_FAM);\n    final int loadedTableCount = countRows(original);\n    System.out.println(\"Original table has: \" + loadedTableCount + \" rows\");\n\n    final String snapshotNameAsString = \"snapshot_\" + localTableName;\n\n    // Create a snapshot\n    SnapshotTestingUtils.createSnapshotAndValidate(admin, localTableName, TEST_FAM_STR,\n        snapshotNameAsString, rootDir, fs, online);\n\n    if (!online) {\n      tryDisable(admin, localTableName);\n    }\n\n    TableName cloneTableName = TableName.valueOf(\"test-clone-\" + localTableName);\n\n    // Clone the snapshot\n    byte[] snapshotName = Bytes.toBytes(snapshotNameAsString);\n    admin.cloneSnapshot(snapshotName, cloneTableName);\n\n    // Verify that region information is the same pre-split\n    ((ClusterConnection) UTIL.getConnection()).clearRegionCache();\n    List<HRegionInfo> originalTableHRegions = admin.getTableRegions(localTableName);\n\n    final int originalRegionCount = originalTableHRegions.size();\n    final int cloneTableRegionCount = admin.getTableRegions(cloneTableName).size();\n    Assert.assertEquals(\n        \"The number of regions in the cloned table is different than in the original table.\",\n        originalRegionCount, cloneTableRegionCount);\n\n    // Split a region on the parent table\n    admin.splitRegion(originalTableHRegions.get(0).getRegionName());\n    waitOnSplit(UTIL.getConnection(), original, originalRegionCount);\n\n    // Verify that the cloned table region is not split\n    final int cloneTableRegionCount2 = admin.getTableRegions(cloneTableName).size();\n    Assert.assertEquals(\n        \"The number of regions in the cloned table changed though none of its regions were split.\",\n        cloneTableRegionCount, cloneTableRegionCount2);\n  }","id":22248,"modified_method":"/**\n   * Do a split, and verify that this only affects one table\n   */\n  private void runTestRegionOperationsIndependent() throws Exception {\n    // Verify that region information is the same pre-split\n    ((ClusterConnection) UTIL.getConnection()).clearRegionCache();\n    List<HRegionInfo> originalTableHRegions = admin.getTableRegions(originalTableName);\n\n    final int originalRegionCount = originalTableHRegions.size();\n    final int cloneTableRegionCount = admin.getTableRegions(cloneTableName).size();\n    Assert.assertEquals(\n      \"The number of regions in the cloned table is different than in the original table.\",\n      originalRegionCount, cloneTableRegionCount);\n\n    // Split a region on the parent table\n    admin.splitRegion(originalTableHRegions.get(0).getRegionName());\n    waitOnSplit(UTIL.getConnection(), originalTable, originalRegionCount);\n\n    // Verify that the cloned table region is not split\n    final int cloneTableRegionCount2 = admin.getTableRegions(cloneTableName).size();\n    Assert.assertEquals(\n      \"The number of regions in the cloned table changed though none of its regions were split.\",\n      cloneTableRegionCount, cloneTableRegionCount2);\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verify that region operations, in this case splitting a region, are independent between the\n   * cloned table and the original.\n   */\n  @Test (timeout=300000)\n  @Ignore\n  public void testOfflineSnapshotRegionOperationsIndependent() throws Exception {\n    runTestRegionOperationsIndependent(false);\n  }","id":22249,"modified_method":"/**\n   * Verify that region operations, in this case splitting a region, are independent between the\n   * cloned table and the original.\n   */\n  @Test\n  public void testOfflineSnapshotRegionOperationsIndependent() throws Exception {\n    createAndCloneSnapshot(false);\n    runTestRegionOperationsIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Verify that adding data to the cloned table will not affect the original, and vice-versa when\n   * it is taken as an offline snapshot.\n   */\n  @Test (timeout=300000)\n  @Ignore\n  public void testOfflineSnapshotAppendIndependent() throws Exception {\n    runTestSnapshotAppendIndependent(false);\n  }","id":22250,"modified_method":"/**\n   * Verify that adding data to the cloned table will not affect the original, and vice-versa when\n   * it is taken as an offline snapshot.\n   */\n  @Test\n  public void testOfflineSnapshotAppendIndependent() throws Exception {\n    createAndCloneSnapshot(false);\n    runTestSnapshotAppendIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"private static void waitOnSplit(Connection c, final Table t, int originalCount) throws Exception {\n    for (int i = 0; i < 200; i++) {\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n      }\n      try (RegionLocator locator = c.getRegionLocator(t.getName())) {\n        if (locator.getAllRegionLocations().size() > originalCount) {\n          return;\n        }\n      }\n    }\n    throw new Exception(\"Split did not increase the number of regions\");\n  }","id":22251,"modified_method":"private static void waitOnSplit(Connection c, final Table t, int originalCount) throws Exception {\n    for (int i = 0; i < 200; i++) {\n      Threads.sleepWithoutInterrupt(500);\n      try (RegionLocator locator = c.getRegionLocator(t.getName())) {\n        if (locator.getAllRegionLocations().size() > originalCount) {\n          return;\n        }\n      }\n    }\n    throw new Exception(\"Split did not increase the number of regions\");\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"private void runTestSnapshotMetadataChangesIndependent(boolean online) throws Exception {\n    FileSystem fs = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getFileSystem();\n    Path rootDir = UTIL.getHBaseCluster().getMaster().getMasterFileSystem().getRootDir();\n\n    // Create a table\n    Admin admin = UTIL.getHBaseAdmin();\n    final long startTime = System.currentTimeMillis();\n    final TableName localTableName =\n        TableName.valueOf(STRING_TABLE_NAME + startTime);\n    Table original = createTable(localTableName, TEST_FAM);\n    loadData(original, TEST_FAM);\n\n    final String snapshotNameAsString = \"snapshot_\" + localTableName;\n\n    // Create a snapshot\n    SnapshotTestingUtils.createSnapshotAndValidate(admin, localTableName, TEST_FAM_STR,\n        snapshotNameAsString, rootDir, fs, online);\n\n    if (!online) {\n      tryDisable(admin, localTableName);\n    }\n\n    TableName cloneTableName = TableName.valueOf(\"test-clone-\" + localTableName);\n\n    // Clone the snapshot\n    byte[] snapshotName = Bytes.toBytes(snapshotNameAsString);\n    admin.cloneSnapshot(snapshotName, cloneTableName);\n\n    // Add a new column family to the original table\n    byte[] TEST_FAM_2 = Bytes.toBytes(\"fam2\");\n    HColumnDescriptor hcd = new HColumnDescriptor(TEST_FAM_2);\n\n    tryDisable(admin, localTableName);\n    admin.addColumnFamily(localTableName, hcd);\n\n    // Verify that it is not in the snapshot\n    admin.enableTable(localTableName);\n    UTIL.waitTableAvailable(localTableName);\n\n    // get a description of the cloned table\n    // get a list of its families\n    // assert that the family is there\n    HTableDescriptor originalTableDescriptor = original.getTableDescriptor();\n    HTableDescriptor clonedTableDescriptor = admin.getTableDescriptor(cloneTableName);\n\n    Assert.assertTrue(\"The original family was not found. There is something wrong. \",\n        originalTableDescriptor.hasFamily(TEST_FAM));\n    Assert.assertTrue(\"The original family was not found in the clone. There is something wrong. \",\n        clonedTableDescriptor.hasFamily(TEST_FAM));\n\n    Assert.assertTrue(\"The new family was not found. \",\n        originalTableDescriptor.hasFamily(TEST_FAM_2));\n    Assert.assertTrue(\"The new family was not found. \",\n        !clonedTableDescriptor.hasFamily(TEST_FAM_2));\n  }","id":22252,"modified_method":"/**\n   * Add metadata, and verify that this only affects one table\n   */\n  private void runTestSnapshotMetadataChangesIndependent() throws Exception {\n    // Add a new column family to the original table\n    byte[] TEST_FAM_2 = Bytes.toBytes(\"fam2\");\n    HColumnDescriptor hcd = new HColumnDescriptor(TEST_FAM_2);\n\n    admin.disableTable(originalTableName);\n    admin.addColumnFamily(originalTableName, hcd);\n\n    // Verify that it is not in the snapshot\n    admin.enableTable(originalTableName);\n    UTIL.waitTableAvailable(originalTableName);\n\n    // get a description of the cloned table\n    // get a list of its families\n    // assert that the family is there\n    HTableDescriptor originalTableDescriptor = originalTable.getTableDescriptor();\n    HTableDescriptor clonedTableDescriptor = admin.getTableDescriptor(cloneTableName);\n\n    Assert.assertTrue(\"The original family was not found. There is something wrong. \",\n      originalTableDescriptor.hasFamily(TEST_FAM));\n    Assert.assertTrue(\"The original family was not found in the clone. There is something wrong. \",\n      clonedTableDescriptor.hasFamily(TEST_FAM));\n\n    Assert.assertTrue(\"The new family was not found. \",\n      originalTableDescriptor.hasFamily(TEST_FAM_2));\n    Assert.assertTrue(\"The new family was not found. \",\n      !clonedTableDescriptor.hasFamily(TEST_FAM_2));\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"@Ignore (\"Flakey test\") @Test (timeout=300000)\n  public void testOnlineSnapshotDeleteIndependent() throws Exception {\n    runTestSnapshotDeleteIndependent(true);\n  }","id":22253,"modified_method":"@Test\n  public void testOnlineSnapshotDeleteIndependent() throws Exception {\n    createAndCloneSnapshot(true);\n    runTestSnapshotDeleteIndependent();\n  }","commit_id":"94696d4067165b09818615809a10e609321e7f22","url":"https://github.com/apache/hbase"},{"original_method":"long test() throws IOException {\n      long elapsedTime;\n      testSetup();\n      long startTime = System.currentTimeMillis();\n      try {\n        testTimed();\n        elapsedTime = System.currentTimeMillis() - startTime;\n      } finally {\n        testTakedown();\n      }\n      return elapsedTime;\n    }","id":22254,"modified_method":"long test() throws IOException {\n      testSetup();\n      LOG.info(\"Timed test starting in thread \" + Thread.currentThread().getName());\n      final long startTime = System.nanoTime();\n      try {\n        testTimed();\n      } finally {\n        testTakedown();\n      }\n      return (System.nanoTime() - startTime) / 1000000;\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"public PeInputSplit(int startRow, int rows, int totalRows, int clients,\n        int rowsPerPut) {\n      this.startRow = startRow;\n      this.rows = rows;\n      this.totalRows = totalRows;\n      this.clients = clients;\n      this.rowsPerPut = 1;\n    }","id":22255,"modified_method":"public PeInputSplit(TableName tableName, int startRow, int rows, int totalRows, int clients,\n        boolean flushCommits, boolean writeToWAL, boolean useTags, int noOfTags) {\n      this.tableName = tableName;\n      this.startRow = startRow;\n      this.rows = rows;\n      this.totalRows = totalRows;\n      this.clients = clients;\n      this.flushCommits = flushCommits;\n      this.writeToWAL = writeToWAL;\n      this.useTags = useTags;\n      this.noOfTags = noOfTags;\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"void testSetup() throws IOException {\n      this.table = new RemoteHTable(new Client(cluster), conf, tableName);\n    }","id":22256,"modified_method":"void testSetup() throws IOException {\n      this.table = connection.getTable(tableName);\n      this.table.setAutoFlush(false, true);\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"private void doMapReduce(final Class<? extends Test> cmd) throws IOException,\n        InterruptedException, ClassNotFoundException {\n    Path inputDir = writeInputFile(this.conf);\n    this.conf.set(EvaluationMapTask.CMD_KEY, cmd.getName());\n    this.conf.set(EvaluationMapTask.PE_KEY, getClass().getName());\n    Job job = new Job(this.conf);\n    job.setJarByClass(PerformanceEvaluation.class);\n    job.setJobName(\"HBase Performance Evaluation\");\n    \n    job.setInputFormatClass(PeInputFormat.class);\n    PeInputFormat.setInputPaths(job, inputDir);\n    \n    job.setOutputKeyClass(LongWritable.class);\n    job.setOutputValueClass(LongWritable.class);\n    \n    job.setMapperClass(EvaluationMapTask.class);\n    job.setReducerClass(LongSumReducer.class);\n        \n    job.setNumReduceTasks(1);\n    \n    job.setOutputFormatClass(TextOutputFormat.class);\n    TextOutputFormat.setOutputPath(job, new Path(inputDir,\"outputs\"));\n    \n    job.waitForCompletion(true);\n  }","id":22257,"modified_method":"private void doMapReduce(final Class<? extends Test> cmd) throws IOException,\n        InterruptedException, ClassNotFoundException {\n    Configuration conf = getConf();\n    Path inputDir = writeInputFile(conf);\n    conf.set(EvaluationMapTask.CMD_KEY, cmd.getName());\n    conf.set(EvaluationMapTask.PE_KEY, getClass().getName());\n    Job job = new Job(conf);\n    job.setJarByClass(PerformanceEvaluation.class);\n    job.setJobName(\"HBase Performance Evaluation\");\n\n    job.setInputFormatClass(PeInputFormat.class);\n    PeInputFormat.setInputPaths(job, inputDir);\n\n    job.setOutputKeyClass(LongWritable.class);\n    job.setOutputValueClass(LongWritable.class);\n\n    job.setMapperClass(EvaluationMapTask.class);\n    job.setReducerClass(LongSumReducer.class);\n    job.setNumReduceTasks(1);\n\n    job.setOutputFormatClass(TextOutputFormat.class);\n    TextOutputFormat.setOutputPath(job, new Path(inputDir.getParent(), \"outputs\"));\n    TableMapReduceUtil.addDependencyJars(job);\n    TableMapReduceUtil.initCredentials(job);\n    job.waitForCompletion(true);\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Note that all subclasses of this class must provide a public contructor\n     * that has the exact same list of arguments.\n     */\n    Test(final Configuration conf, final TestOptions options, final Status status) {\n      super();\n      this.startRow = options.getStartRow();\n      this.perClientRunRows = options.getPerClientRunRows();\n      this.totalRows = options.getTotalRows();\n      this.status = status;\n      this.tableName = options.getTableName();\n      this.table = null;\n      this.conf = conf;\n    }","id":22258,"modified_method":"/**\n     * Note that all subclasses of this class must provide a public contructor\n     * that has the exact same list of arguments.\n     */\n    Test(final Configuration conf, final TestOptions options, final Status status) {\n      super();\n      this.startRow = options.getStartRow();\n      this.perClientRunRows = options.getPerClientRunRows();\n      this.totalRows = options.getTotalRows();\n      this.status = status;\n      this.tableName = options.getTableName();\n      this.table = null;\n      this.conf = conf;\n      this.flushCommits = options.isFlushCommits();\n      this.writeToWAL = options.isWriteToWAL();\n      this.useTags = options.isUseTags();\n      this.noOfTags = options.getNumTags();\n      this.connection = options.getConnection();\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * @param args\n   */\n  public static void main(final String[] args) {\n    Configuration c = HBaseConfiguration.create();\n    System.exit(new PerformanceEvaluation(c).doCommandLine(args));\n  }","id":22259,"modified_method":"/**\n   * @param args\n   */\n  public static void main(final String[] args) throws Exception {\n    int res = ToolRunner.run(new PerformanceEvaluation(HBaseConfiguration.create()), args);\n    System.exit(res);\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"RandomWriteTest(Configuration conf, TestOptions options, Status status) {\n      super(conf, options, status);\n      rowsPerPut = options.getRowsPerPut();\n    }","id":22260,"modified_method":"RandomWriteTest(Configuration conf, TestOptions options, Status status) {\n      super(conf, options, status);\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"long runOneClient(final Class<? extends Test> cmd, final int startRow,\n                    final int perClientRunRows, final int totalRows, \n                    final int rowsPerPut, final Status status)\n  throws IOException {\n    status.setStatus(\"Start \" + cmd + \" at offset \" + startRow + \" for \" +\n      perClientRunRows + \" rows\");\n    long totalElapsedTime = 0;\n\n    Test t = null;\n    TestOptions options = new TestOptions(startRow, perClientRunRows,\n      totalRows, getTableDescriptor().getTableName().getName(), rowsPerPut);\n    try {\n      Constructor<? extends Test> constructor = cmd.getDeclaredConstructor(\n          Configuration.class, TestOptions.class, Status.class);\n      t = constructor.newInstance(this.conf, options, status);\n    } catch (NoSuchMethodException e) {\n      throw new IllegalArgumentException(\"Invalid command class: \" +\n          cmd.getName() + \".  It does not provide a constructor as described by\" +\n          \"the javadoc comment.  Available constructors are: \" +\n          Arrays.toString(cmd.getConstructors()));\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Failed to construct command class\", e);\n    }\n    totalElapsedTime = t.test();\n\n    status.setStatus(\"Finished \" + cmd + \" in \" + totalElapsedTime +\n      \"ms at offset \" + startRow + \" for \" + perClientRunRows + \" rows\");\n    return totalElapsedTime;\n  }","id":22261,"modified_method":"long runOneClient(final Class<? extends Test> cmd, final int startRow,\n      final int perClientRunRows, final int totalRows,\n      boolean flushCommits, boolean writeToWAL, boolean useTags, int noOfTags,\n      HConnection connection, final Status status)\n  throws IOException {\n    status.setStatus(\"Start \" + cmd + \" at offset \" + startRow + \" for \" +\n      perClientRunRows + \" rows\");\n    long totalElapsedTime = 0;\n\n    TestOptions options = new TestOptions(startRow, perClientRunRows,\n      totalRows, N, tableName, flushCommits, writeToWAL, useTags, noOfTags, connection);\n    final Test t;\n    try {\n      Constructor<? extends Test> constructor = cmd.getDeclaredConstructor(\n          Configuration.class, TestOptions.class, Status.class);\n      t = constructor.newInstance(this.conf, options, status);\n    } catch (NoSuchMethodException e) {\n      throw new IllegalArgumentException(\"Invalid command class: \" +\n          cmd.getName() + \".  It does not provide a constructor as described by\" +\n          \"the javadoc comment.  Available constructors are: \" +\n          Arrays.toString(cmd.getConstructors()));\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Failed to construct command class\", e);\n    }\n    totalElapsedTime = t.test();\n\n    status.setStatus(\"Finished \" + cmd + \" in \" + totalElapsedTime +\n      \"ms at offset \" + startRow + \" for \" + perClientRunRows + \" rows\");\n    return totalElapsedTime;\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"private void runNIsOne(final Class<? extends Test> cmd) {\n    Status status = new Status() {\n      public void setStatus(String msg) throws IOException {\n        LOG.info(msg);\n      }\n    };\n\n    try {\n      checkTable();\n      runOneClient(cmd, 0, R, R, B, status);\n    } catch (Exception e) {\n      LOG.error(\"Failed\", e);\n    } \n  }","id":22262,"modified_method":"private void runNIsOne(final Class<? extends Test> cmd) {\n    Status status = new Status() {\n      public void setStatus(String msg) throws IOException {\n        LOG.info(msg);\n      }\n    };\n\n    RemoteAdmin admin = null;\n    try {\n      Client client = new Client(cluster);\n      admin = new RemoteAdmin(client, getConf());\n      checkTable(admin);\n      runOneClient(cmd, 0, this.R, this.R, this.flushCommits, this.writeToWAL,\n        this.useTags, this.noOfTags, this.connection, status);\n    } catch (Exception e) {\n      LOG.error(\"Failed\", e);\n    }\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"protected HTableDescriptor getTableDescriptor() {\n    return TABLE_DESCRIPTOR;\n  }","id":22263,"modified_method":"protected HTableDescriptor getTableDescriptor() {\n    if (TABLE_DESCRIPTOR == null) {\n      TABLE_DESCRIPTOR = new HTableDescriptor(tableName);\n      HColumnDescriptor family = new HColumnDescriptor(FAMILY_NAME);\n      family.setDataBlockEncoding(blockEncoding);\n      family.setCompressionType(compression);\n      if (inMemoryCF) {\n        family.setInMemory(true);\n      }\n      TABLE_DESCRIPTOR.addFamily(family);\n    }\n    return TABLE_DESCRIPTOR;\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"private boolean checkTable() throws IOException {\n    HTableDescriptor tableDescriptor = getTableDescriptor();\n    RemoteAdmin admin = new RemoteAdmin(new Client(cluster), conf);\n    if (!admin.isTableAvailable(tableDescriptor.getTableName().getName())) {\n      admin.createTable(tableDescriptor);\n      return true;\n    }\n    return false;\n  }","id":22264,"modified_method":"private boolean checkTable(RemoteAdmin admin) throws IOException {\n    HTableDescriptor tableDescriptor = getTableDescriptor();\n    if (this.presplitRegions > 0) {\n      // presplit requested\n      if (admin.isTableAvailable(tableDescriptor.getTableName().getName())) {\n        admin.deleteTable(tableDescriptor.getTableName().getName());\n      }\n\n      byte[][] splits = getSplits();\n      for (int i=0; i < splits.length; i++) {\n        LOG.debug(\" split \" + i + \": \" + Bytes.toStringBinary(splits[i]));\n      }\n      admin.createTable(tableDescriptor);\n      LOG.info (\"Table created with \" + this.presplitRegions + \" splits\");\n    } else {\n      boolean tableExists = admin.isTableAvailable(tableDescriptor.getTableName().getName());\n      if (!tableExists) {\n        admin.createTable(tableDescriptor);\n        LOG.info(\"Table \" + tableDescriptor + \" created\");\n      }\n    }\n    boolean tableExists = admin.isTableAvailable(tableDescriptor.getTableName().getName());\n    return tableExists;\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"void testTakedown()  throws IOException {\n      this.table.close();\n    }","id":22265,"modified_method":"void testTakedown()  throws IOException {\n      if (flushCommits) {\n        this.table.flushCommits();\n      }\n      table.close();\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"public static byte [] format(final int number) {\n    byte [] b = new byte[10];\n    int d = Math.abs(number);\n    for (int i = b.length - 1; i >= 0; i--) {\n      b[i] = (byte)((d % 10) + '0');\n      d /= 10;\n    }\n    return b;\n  }","id":22266,"modified_method":"public static byte [] format(final int number) {\n    byte [] b = new byte[DEFAULT_ROW_PREFIX_LENGTH + 10];\n    int d = Math.abs(number);\n    for (int i = b.length - 1; i >= 0; i--) {\n      b[i] = (byte)((d % 10) + '0');\n      d /= 10;\n    }\n    return b;\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"protected void printUsage(final String message) {\n    if (message != null && message.length() > 0) {\n      System.err.println(message);\n    }\n    System.err.println(\"Usage: java \" + this.getClass().getName() + \" \\\\\");\n    System.err.println(\"  [--option] [--option=value] <command> <nclients>\");\n    System.err.println();\n    System.err.println(\"Options:\");\n    System.err.println(\" host          String. Specify Stargate endpoint.\");\n    System.err.println(\" rows          Integer. Rows each client runs. Default: One million\");\n    System.err.println(\" rowsPerPut    Integer. Rows each Stargate (multi)Put. Default: 100\");\n    System.err.println(\" nomapred      (Flag) Run multiple clients using threads \" +\n      \"(rather than use mapreduce)\");\n    System.err.println();\n    System.err.println(\"Command:\");\n    for (CmdDescriptor command : commands.values()) {\n      System.err.println(String.format(\" %-15s %s\", command.getName(), command.getDescription()));\n    }\n    System.err.println();\n    System.err.println(\"Args:\");\n    System.err.println(\" nclients      Integer. Required. Total number of \" +\n      \"clients (and HRegionServers)\");\n    System.err.println(\"               running: 1 <= value <= 500\");\n    System.err.println(\"Examples:\");\n    System.err.println(\" To run a single evaluation client:\");\n    System.err.println(\" $ bin/hbase \" + this.getClass().getName()\n        + \" sequentialWrite 1\");\n  }","id":22267,"modified_method":"protected void printUsage(final String message) {\n    if (message != null && message.length() > 0) {\n      System.err.println(message);\n    }\n    System.err.println(\"Usage: java \" + this.getClass().getName() + \" \\\\\");\n    System.err.println(\"  [--nomapred] [--rows=ROWS] [--table=NAME] \\\\\");\n    System.err.println(\"  [--compress=TYPE] [--blockEncoding=TYPE] [-D<property=value>]* <command> <nclients>\");\n    System.err.println();\n    System.err.println(\"Options:\");\n    System.err.println(\" nomapred        Run multiple clients using threads \" +\n      \"(rather than use mapreduce)\");\n    System.err.println(\" rows            Rows each client runs. Default: One million\");\n    System.err.println(\" table           Alternate table name. Default: 'TestTable'\");\n    System.err.println(\" compress        Compression type to use (GZ, LZO, ...). Default: 'NONE'\");\n    System.err.println(\" flushCommits    Used to determine if the test should flush the table.  Default: false\");\n    System.err.println(\" writeToWAL      Set writeToWAL on puts. Default: True\");\n    System.err.println(\" presplit        Create presplit table. Recommended for accurate perf analysis (see guide).  Default: disabled\");\n    System.err\n        .println(\" inmemory        Tries to keep the HFiles of the CF inmemory as far as possible.  Not \" +\n            \"guaranteed that reads are always served from inmemory.  Default: false\");\n    System.err.println(\" usetags         Writes tags along with KVs.  Use with HFile V3.  Default : false\");\n    System.err\n        .println(\" numoftags        Specify the no of tags that would be needed.  This works only if usetags is true.\");\n    System.err.println();\n    System.err.println(\" Note: -D properties will be applied to the conf used. \");\n    System.err.println(\"  For example: \");\n    System.err.println(\"   -Dmapred.output.compress=true\");\n    System.err.println(\"   -Dmapreduce.task.timeout=60000\");\n    System.err.println();\n    System.err.println(\"Command:\");\n    for (CmdDescriptor command : commands.values()) {\n      System.err.println(String.format(\" %-15s %s\", command.getName(), command.getDescription()));\n    }\n    System.err.println();\n    System.err.println(\"Args:\");\n    System.err.println(\" nclients      Integer. Required. Total number of \" +\n      \"clients (and HRegionServers)\");\n    System.err.println(\"               running: 1 <= value <= 500\");\n    System.err.println(\"Examples:\");\n    System.err.println(\" To run a single evaluation client:\");\n    System.err.println(\" $ bin/hbase \" + this.getClass().getName()\n        + \" sequentialWrite 1\");\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"private void doMultipleClients(final Class<? extends Test> cmd) throws IOException {\n    final List<Thread> threads = new ArrayList<Thread>(N);\n    final int perClientRows = R/N;\n    for (int i = 0; i < N; i++) {\n      Thread t = new Thread (Integer.toString(i)) {\n        @Override\n        public void run() {\n          super.run();\n          PerformanceEvaluation pe = new PerformanceEvaluation(conf);\n          int index = Integer.parseInt(getName());\n          try {\n            long elapsedTime = pe.runOneClient(cmd, index * perClientRows,\n              perClientRows, R, B, new Status() {\n                  public void setStatus(final String msg) throws IOException {\n                    LOG.info(\"client-\" + getName() + \" \" + msg);\n                  }\n                });\n            LOG.info(\"Finished \" + getName() + \" in \" + elapsedTime +\n              \"ms writing \" + perClientRows + \" rows\");\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n      threads.add(t);\n    }\n    for (Thread t: threads) {\n      t.start();\n    }\n    for (Thread t: threads) {\n      while(t.isAlive()) {\n        try {\n          t.join();\n        } catch (InterruptedException e) {\n          LOG.debug(\"Interrupted, continuing\" + e.toString());\n        }\n      }\n    }\n  }","id":22268,"modified_method":"private void doMultipleClients(final Class<? extends Test> cmd) throws IOException {\n    final List<Thread> threads = new ArrayList<Thread>(this.N);\n    final long[] timings = new long[this.N];\n    final int perClientRows = R/N;\n    final TableName tableName = this.tableName;\n    final DataBlockEncoding encoding = this.blockEncoding;\n    final boolean flushCommits = this.flushCommits;\n    final Compression.Algorithm compression = this.compression;\n    final boolean writeToWal = this.writeToWAL;\n    final int preSplitRegions = this.presplitRegions;\n    final boolean useTags = this.useTags;\n    final int numTags = this.noOfTags;\n    final HConnection connection = HConnectionManager.createConnection(getConf());\n    for (int i = 0; i < this.N; i++) {\n      final int index = i;\n      Thread t = new Thread (\"TestClient-\" + i) {\n        @Override\n        public void run() {\n          super.run();\n          PerformanceEvaluation pe = new PerformanceEvaluation(getConf());\n          pe.tableName = tableName;\n          pe.blockEncoding = encoding;\n          pe.flushCommits = flushCommits;\n          pe.compression = compression;\n          pe.writeToWAL = writeToWal;\n          pe.presplitRegions = preSplitRegions;\n          pe.N = N;\n          pe.connection = connection;\n          pe.useTags = useTags;\n          pe.noOfTags = numTags;\n          try {\n            long elapsedTime = pe.runOneClient(cmd, index * perClientRows,\n                perClientRows, R,\n                 flushCommits, writeToWAL, useTags, noOfTags, connection, new Status() {\n                   public void setStatus(final String msg) throws IOException {\n                     LOG.info(\"client-\" + getName() + \" \" + msg);\n                   }\n                 });\n            timings[index] = elapsedTime;\n            LOG.info(\"Finished \" + getName() + \" in \" + elapsedTime +\n              \"ms writing \" + perClientRows + \" rows\");\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      };\n      threads.add(t);\n    }\n    for (Thread t: threads) {\n      t.start();\n    }\n    for (Thread t: threads) {\n      while(t.isAlive()) {\n        try {\n          t.join();\n        } catch (InterruptedException e) {\n          LOG.debug(\"Interrupted, continuing\" + e.toString());\n        }\n      }\n    }\n    final String test = cmd.getSimpleName();\n    LOG.info(\"[\" + test + \"] Summary of timings (ms): \"\n             + Arrays.toString(timings));\n    Arrays.sort(timings);\n    long total = 0;\n    for (int i = 0; i < this.N; i++) {\n      total += timings[i];\n    }\n    LOG.info(\"[\" + test + \"]\"\n             + \"\\tMin: \" + timings[0] + \"ms\"\n             + \"\\tMax: \" + timings[this.N - 1] + \"ms\"\n             + \"\\tAvg: \" + (total / this.N) + \"ms\");\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void write(DataOutput out) throws IOException {\n      out.writeInt(startRow);\n      out.writeInt(rows);\n      out.writeInt(totalRows);\n      out.writeInt(clients);\n      out.writeInt(rowsPerPut);\n    }","id":22269,"modified_method":"@Override\n    public void write(DataOutput out) throws IOException {\n      byte[] name = this.tableName.toBytes();\n      out.writeInt(name.length);\n      out.write(name);\n      out.writeInt(startRow);\n      out.writeInt(rows);\n      out.writeInt(totalRows);\n      out.writeInt(clients);\n      out.writeBoolean(flushCommits);\n      out.writeBoolean(writeToWAL);\n      out.writeBoolean(useTags);\n      out.writeInt(noOfTags);\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void readFields(DataInput in) throws IOException {\n      this.startRow = in.readInt();\n      this.rows = in.readInt();\n      this.totalRows = in.readInt();\n      this.clients = in.readInt();\n      this.rowsPerPut = in.readInt();\n    }","id":22270,"modified_method":"@Override\n    public void readFields(DataInput in) throws IOException {\n      int tableNameLen = in.readInt();\n      byte[] name = new byte[tableNameLen];\n      in.readFully(name);\n      this.tableName = TableName.valueOf(name);\n      this.startRow = in.readInt();\n      this.rows = in.readInt();\n      this.totalRows = in.readInt();\n      this.clients = in.readInt();\n      this.flushCommits = in.readBoolean();\n      this.writeToWAL = in.readBoolean();\n      this.useTags = in.readBoolean();\n      this.noOfTags = in.readInt();\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"private Path writeInputFile(final Configuration c) throws IOException {\n    FileSystem fs = FileSystem.get(c);\n    if (!fs.exists(PERF_EVAL_DIR)) {\n      fs.mkdirs(PERF_EVAL_DIR);\n    }\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n    Path subdir = new Path(PERF_EVAL_DIR, formatter.format(new Date()));\n    fs.mkdirs(subdir);\n    Path inputFile = new Path(subdir, \"input.txt\");\n    PrintStream out = new PrintStream(fs.create(inputFile));\n    // Make input random.\n    Map<Integer, String> m = new TreeMap<Integer, String>();\n    Hash h = MurmurHash.getInstance();\n    int perClientRows = (R / N);\n    try {\n      for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < N; j++) {\n          String s = \"startRow=\" + ((j * perClientRows) + (i * (perClientRows/10))) +\n          \", perClientRunRows=\" + (perClientRows / 10) +\n          \", totalRows=\" + R +\n          \", clients=\" + N +\n          \", rowsPerPut=\" + B;\n          int hash = h.hash(Bytes.toBytes(s));\n          m.put(hash, s);\n        }\n      }\n      for (Map.Entry<Integer, String> e: m.entrySet()) {\n        out.println(e.getValue());\n      }\n    } finally {\n      out.close();\n    }\n    return subdir;\n  }","id":22271,"modified_method":"private Path writeInputFile(final Configuration c) throws IOException {\n    SimpleDateFormat formatter = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n    Path jobdir = new Path(PERF_EVAL_DIR, formatter.format(new Date()));\n    Path inputDir = new Path(jobdir, \"inputs\");\n\n    FileSystem fs = FileSystem.get(c);\n    fs.mkdirs(inputDir);\n    Path inputFile = new Path(inputDir, \"input.txt\");\n    PrintStream out = new PrintStream(fs.create(inputFile));\n    // Make input random.\n    Map<Integer, String> m = new TreeMap<Integer, String>();\n    Hash h = MurmurHash.getInstance();\n    int perClientRows = (this.R / this.N);\n    try {\n      for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < N; j++) {\n          String s = \"tableName=\" + this.tableName +\n          \", startRow=\" + ((j * perClientRows) + (i * (perClientRows/10))) +\n          \", perClientRunRows=\" + (perClientRows / 10) +\n          \", totalRows=\" + this.R +\n          \", clients=\" + this.N +\n          \", flushCommits=\" + this.flushCommits +\n          \", writeToWAL=\" + this.writeToWAL +\n          \", useTags=\" + this.useTags +\n          \", noOfTags=\" + this.noOfTags;\n          int hash = h.hash(Bytes.toBytes(s));\n          m.put(hash, s);\n        }\n      }\n      for (Map.Entry<Integer, String> e: m.entrySet()) {\n        out.println(e.getValue());\n      }\n    } finally {\n      out.close();\n    }\n    return inputDir;\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"public PeInputSplit() {\n      this.startRow = 0;\n      this.rows = 0;\n      this.totalRows = 0;\n      this.clients = 0;\n      this.rowsPerPut = 1;\n    }","id":22272,"modified_method":"public PeInputSplit() {\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"private void runNIsMoreThanOne(final Class<? extends Test> cmd)\n  throws IOException, InterruptedException, ClassNotFoundException {\n    checkTable();\n    if (nomapred) {\n      doMultipleClients(cmd);\n    } else {\n      doMapReduce(cmd);\n    }\n  }","id":22273,"modified_method":"private void runNIsMoreThanOne(final Class<? extends Test> cmd)\n  throws IOException, InterruptedException, ClassNotFoundException {\n    RemoteAdmin remoteAdmin = new RemoteAdmin(new Client(cluster), getConf());\n    checkTable(remoteAdmin);\n    if (nomapred) {\n      doMultipleClients(cmd);\n    } else {\n      doMapReduce(cmd);\n    }\n  }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public List<InputSplit> getSplits(JobContext job) throws IOException {\n      // generate splits\n      List<InputSplit> splitList = new ArrayList<InputSplit>();\n      \n      for (FileStatus file: listStatus(job)) {\n        Path path = file.getPath();\n        FileSystem fs = path.getFileSystem(job.getConfiguration());\n        FSDataInputStream fileIn = fs.open(path);\n        LineReader in = new LineReader(fileIn, job.getConfiguration());\n        int lineLen = 0;\n        while(true) {\n          Text lineText = new Text();\n          lineLen = in.readLine(lineText);\n          if(lineLen <= 0) {\n          break;\n          }\n          Matcher m = LINE_PATTERN.matcher(lineText.toString());\n          if((m != null) && m.matches()) {\n            int startRow = Integer.parseInt(m.group(1));\n            int rows = Integer.parseInt(m.group(2));\n            int totalRows = Integer.parseInt(m.group(3));\n            int clients = Integer.parseInt(m.group(4));\n            int rowsPerPut = Integer.parseInt(m.group(5));\n\n            LOG.debug(\"split[\"+ splitList.size() + \"] \" + \n                     \" startRow=\" + startRow +\n                     \" rows=\" + rows +\n                     \" totalRows=\" + totalRows +\n                     \" clients=\" + clients +\n                     \" rowsPerPut=\" + rowsPerPut);\n\n            PeInputSplit newSplit =\n              new PeInputSplit(startRow, rows, totalRows, clients, rowsPerPut);\n            splitList.add(newSplit);\n          }\n        }\n        in.close();\n      }\n      \n      LOG.info(\"Total # of splits: \" + splitList.size());\n      return splitList;\n    }","id":22274,"modified_method":"@Override\n    public List<InputSplit> getSplits(JobContext job) throws IOException {\n      // generate splits\n      List<InputSplit> splitList = new ArrayList<InputSplit>();\n\n      for (FileStatus file: listStatus(job)) {\n        if (file.isDir()) {\n          continue;\n        }\n        Path path = file.getPath();\n        FileSystem fs = path.getFileSystem(job.getConfiguration());\n        FSDataInputStream fileIn = fs.open(path);\n        LineReader in = new LineReader(fileIn, job.getConfiguration());\n        int lineLen = 0;\n        while(true) {\n          Text lineText = new Text();\n          lineLen = in.readLine(lineText);\n          if(lineLen <= 0) {\n          break;\n          }\n          Matcher m = LINE_PATTERN.matcher(lineText.toString());\n          if((m != null) && m.matches()) {\n            TableName tableName = TableName.valueOf(m.group(1));\n            int startRow = Integer.parseInt(m.group(2));\n            int rows = Integer.parseInt(m.group(3));\n            int totalRows = Integer.parseInt(m.group(4));\n            int clients = Integer.parseInt(m.group(5));\n            boolean flushCommits = Boolean.parseBoolean(m.group(6));\n            boolean writeToWAL = Boolean.parseBoolean(m.group(7));\n            boolean useTags = Boolean.parseBoolean(m.group(8));\n            int noOfTags = Integer.parseInt(m.group(9));\n\n            LOG.debug(\"tableName=\" + tableName +\n                      \" split[\"+ splitList.size() + \"] \" +\n                      \" startRow=\" + startRow +\n                      \" rows=\" + rows +\n                      \" totalRows=\" + totalRows +\n                      \" clients=\" + clients +\n                      \" flushCommits=\" + flushCommits +\n                      \" writeToWAL=\" + writeToWAL +\n                      \" useTags=\" + useTags +\n                      \" noOfTags=\" + noOfTags);\n\n            PeInputSplit newSplit =\n              new PeInputSplit(tableName, startRow, rows, totalRows, clients,\n                  flushCommits, writeToWAL, useTags, noOfTags);\n            splitList.add(newSplit);\n          }\n        }\n        in.close();\n      }\n\n      LOG.info(\"Total # of splits: \" + splitList.size());\n      return splitList;\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    void testRow(final int i) throws IOException {\n      Scan scan = new Scan(getRandomRow(this.rand, this.totalRows));\n      scan.addColumn(FAMILY_NAME, QUALIFIER_NAME);\n      scan.setFilter(new WhileMatchFilter(new PageFilter(120)));\n      ResultScanner s = this.table.getScanner(scan);\n      //int count = 0;\n      for (Result rr = null; (rr = s.next()) != null;) {\n        // LOG.info(\"\" + count++ + \" \" + rr.toString());\n      }\n      s.close();\n    }","id":22275,"modified_method":"@Override\n    void testRow(final int i) throws IOException {\n      Scan scan = new Scan(getRandomRow(this.rand, this.totalRows));\n      scan.addColumn(FAMILY_NAME, QUALIFIER_NAME);\n      scan.setFilter(new WhileMatchFilter(new PageFilter(120)));\n      ResultScanner s = this.table.getScanner(scan);\n      s.close();\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"SequentialWriteTest(Configuration conf, TestOptions options, Status status) {\n      super(conf, options, status);\n      rowsPerPut = options.getRowsPerPut();\n    }","id":22276,"modified_method":"SequentialWriteTest(Configuration conf, TestOptions options, Status status) {\n      super(conf, options, status);\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"protected void map(NullWritable key, PeInputSplit value, final Context context) \n           throws IOException, InterruptedException {\n      \n      Status status = new Status() {\n        public void setStatus(String msg) {\n           context.setStatus(msg); \n        }\n      };\n      \n      // Evaluation task\n      long elapsedTime = this.pe.runOneClient(this.cmd, value.getStartRow(),\n        value.getRows(), value.getTotalRows(), value.getRowsPerPut(), status);\n      // Collect how much time the thing took. Report as map output and\n      // to the ELAPSED_TIME counter.\n      context.getCounter(Counter.ELAPSED_TIME).increment(elapsedTime);\n      context.getCounter(Counter.ROWS).increment(value.rows);\n      context.write(new LongWritable(value.startRow), new LongWritable(elapsedTime));\n      context.progress();\n    }","id":22277,"modified_method":"protected void map(NullWritable key, PeInputSplit value, final Context context)\n           throws IOException, InterruptedException {\n\n      Status status = new Status() {\n        public void setStatus(String msg) {\n           context.setStatus(msg);\n        }\n      };\n\n      // Evaluation task\n      pe.tableName = value.getTableName();\n      long elapsedTime = this.pe.runOneClient(this.cmd, value.getStartRow(),\n        value.getRows(), value.getTotalRows(),\n        value.isFlushCommits(), value.isWriteToWAL(),\n        value.isUseTags(), value.getNoOfTags(),\n        HConnectionManager.createConnection(context.getConfiguration()), status);\n      // Collect how much time the thing took. Report as map output and\n      // to the ELAPSED_TIME counter.\n      context.getCounter(Counter.ELAPSED_TIME).increment(elapsedTime);\n      context.getCounter(Counter.ROWS).increment(value.rows);\n      context.write(new LongWritable(value.startRow), new LongWritable(elapsedTime));\n      context.progress();\n    }","commit_id":"cc8945a1504e04ae3a044f9ce7c518bb8e6da8c6","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public static Job createSubmittableJob(Configuration conf, String[] args)\n      throws IOException, ClassNotFoundException {\n\n    HBaseAdmin admin = new HBaseAdmin(conf);\n    // Support non-XML supported characters\n    // by re-encoding the passed separator as a Base64 string.\n    String actualSeparator = conf.get(SEPARATOR_CONF_KEY);\n    if (actualSeparator != null) {\n      conf.set(SEPARATOR_CONF_KEY,\n               Base64.encodeBytes(actualSeparator.getBytes()));\n    }\n\n    // See if a non-default Mapper was set\n    String mapperClassName = conf.get(MAPPER_CONF_KEY);\n    Class mapperClass = mapperClassName != null ?\n        Class.forName(mapperClassName) : DEFAULT_MAPPER;\n\n    TableName tableName = TableName.valueOf(args[0]);\n    Path inputDir = new Path(args[1]);\n    String jobName = conf.get(JOB_NAME_CONF_KEY,NAME + \"_\" + tableName.getNameAsString());\n    Job job = Job.getInstance(conf, jobName);\n    job.setJarByClass(mapperClass);\n    FileInputFormat.setInputPaths(job, inputDir);\n    job.setInputFormatClass(TextInputFormat.class);\n    job.setMapperClass(mapperClass);\n    String hfileOutPath = conf.get(BULK_OUTPUT_CONF_KEY);\n    String columns[] = conf.getStrings(COLUMNS_CONF_KEY);\n    if(StringUtils.isNotEmpty(conf.get(CREDENTIALS_LOCATION))) {\n      String fileLoc = conf.get(CREDENTIALS_LOCATION);\n      Credentials cred = Credentials.readTokenStorageFile(new File(fileLoc), conf);\n      job.getCredentials().addAll(cred);\n    }\n\n    if (hfileOutPath != null) {\n      if (!admin.tableExists(tableName)) {\n        LOG.warn(format(\"Table '%s' does not exist.\", tableName));\n        // TODO: this is backwards. Instead of depending on the existence of a table,\n        // create a sane splits file for HFileOutputFormat based on data sampling.\n        createTable(admin, tableName, columns);\n      }\n      HTable table = new HTable(conf, tableName);\n      job.setReducerClass(PutSortReducer.class);\n      Path outputDir = new Path(hfileOutPath);\n      FileOutputFormat.setOutputPath(job, outputDir);\n      job.setMapOutputKeyClass(ImmutableBytesWritable.class);\n      if (mapperClass.equals(TsvImporterTextMapper.class)) {\n        job.setMapOutputValueClass(Text.class);\n        job.setReducerClass(TextSortReducer.class);\n      } else {\n        job.setMapOutputValueClass(Put.class);\n        job.setCombinerClass(PutCombiner.class);\n      }\n      HFileOutputFormat.configureIncrementalLoad(job, table);\n    } else {\n      if (mapperClass.equals(TsvImporterTextMapper.class)) {\n        usage(TsvImporterTextMapper.class.toString()\n            + \" should not be used for non bulkloading case. use \"\n            + TsvImporterMapper.class.toString()\n            + \" or custom mapper whose value type is Put.\");\n        System.exit(-1);\n      }\n      // No reducers. Just write straight to table. Call initTableReducerJob\n      // to set up the TableOutputFormat.\n      TableMapReduceUtil.initTableReducerJob(tableName.getNameAsString(), null,\n          job);\n      job.setNumReduceTasks(0);\n    }\n\n    TableMapReduceUtil.addDependencyJars(job);\n    TableMapReduceUtil.addDependencyJars(job.getConfiguration(),\n        com.google.common.base.Function.class /* Guava used by TsvParser */);\n    return job;\n  }","id":22278,"modified_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public static Job createSubmittableJob(Configuration conf, String[] args)\n      throws IOException, ClassNotFoundException {\n\n    HBaseAdmin admin = new HBaseAdmin(conf);\n    // Support non-XML supported characters\n    // by re-encoding the passed separator as a Base64 string.\n    String actualSeparator = conf.get(SEPARATOR_CONF_KEY);\n    if (actualSeparator != null) {\n      conf.set(SEPARATOR_CONF_KEY,\n               Base64.encodeBytes(actualSeparator.getBytes()));\n    }\n\n    // See if a non-default Mapper was set\n    String mapperClassName = conf.get(MAPPER_CONF_KEY);\n    Class mapperClass = mapperClassName != null ?\n        Class.forName(mapperClassName) : DEFAULT_MAPPER;\n\n    TableName tableName = TableName.valueOf(args[0]);\n    Path inputDir = new Path(args[1]);\n    String jobName = conf.get(JOB_NAME_CONF_KEY,NAME + \"_\" + tableName.getNameAsString());\n    Job job = Job.getInstance(conf, jobName);\n    job.setJarByClass(mapperClass);\n    FileInputFormat.setInputPaths(job, inputDir);\n    job.setInputFormatClass(TextInputFormat.class);\n    job.setMapperClass(mapperClass);\n    String hfileOutPath = conf.get(BULK_OUTPUT_CONF_KEY);\n    String columns[] = conf.getStrings(COLUMNS_CONF_KEY);\n    if(StringUtils.isNotEmpty(conf.get(CREDENTIALS_LOCATION))) {\n      String fileLoc = conf.get(CREDENTIALS_LOCATION);\n      Credentials cred = Credentials.readTokenStorageFile(new File(fileLoc), conf);\n      job.getCredentials().addAll(cred);\n    }\n\n    if (hfileOutPath != null) {\n      if (!admin.tableExists(tableName)) {\n        String errorMsg = format(\"Table '%s' does not exist.\", tableName);\n        if (\"yes\".equalsIgnoreCase(conf.get(CREATE_TABLE_CONF_KEY, \"yes\"))) {\n          LOG.warn(errorMsg);\n          // TODO: this is backwards. Instead of depending on the existence of a table,\n          // create a sane splits file for HFileOutputFormat based on data sampling.\n          createTable(admin, tableName, columns);\n        } else {\n          LOG.error(errorMsg);\n          throw new TableNotFoundException(errorMsg);\n        }\n      }\n      HTable table = new HTable(conf, tableName);\n      job.setReducerClass(PutSortReducer.class);\n      Path outputDir = new Path(hfileOutPath);\n      FileOutputFormat.setOutputPath(job, outputDir);\n      job.setMapOutputKeyClass(ImmutableBytesWritable.class);\n      if (mapperClass.equals(TsvImporterTextMapper.class)) {\n        job.setMapOutputValueClass(Text.class);\n        job.setReducerClass(TextSortReducer.class);\n      } else {\n        job.setMapOutputValueClass(Put.class);\n        job.setCombinerClass(PutCombiner.class);\n      }\n      HFileOutputFormat.configureIncrementalLoad(job, table);\n    } else {\n      if (mapperClass.equals(TsvImporterTextMapper.class)) {\n        usage(TsvImporterTextMapper.class.toString()\n            + \" should not be used for non bulkloading case. use \"\n            + TsvImporterMapper.class.toString()\n            + \" or custom mapper whose value type is Put.\");\n        System.exit(-1);\n      }\n      // No reducers. Just write straight to table. Call initTableReducerJob\n      // to set up the TableOutputFormat.\n      TableMapReduceUtil.initTableReducerJob(tableName.getNameAsString(), null,\n          job);\n      job.setNumReduceTasks(0);\n    }\n\n    TableMapReduceUtil.addDependencyJars(job);\n    TableMapReduceUtil.addDependencyJars(job.getConfiguration(),\n        com.google.common.base.Function.class /* Guava used by TsvParser */);\n    return job;\n  }","commit_id":"8e9a8b002ff088b9ea05aa6188d3c2bedec79a5a","url":"https://github.com/apache/hbase"},{"original_method":"private static void usage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    String usage = \n      \"Usage: \" + NAME + \" -D\"+ COLUMNS_CONF_KEY + \"=a,b,c <tablename> <inputdir>\\n\" +\n      \"\\n\" +\n      \"Imports the given input directory of TSV data into the specified table.\\n\" +\n      \"\\n\" +\n      \"The column names of the TSV data must be specified using the -D\" + COLUMNS_CONF_KEY + \"\\n\" +\n      \"option. This option takes the form of comma-separated column names, where each\\n\" +\n      \"column name is either a simple column family, or a columnfamily:qualifier. The special\\n\" +\n      \"column name \" + TsvParser.ROWKEY_COLUMN_SPEC + \" is used to designate that this column should be used\\n\" +\n      \"as the row key for each imported record. You must specify exactly one column\\n\" +\n      \"to be the row key, and you must specify a column name for every column that exists in the\\n\" +\n      \"input data. Another special column\" + TsvParser.TIMESTAMPKEY_COLUMN_SPEC +\n      \" designates that this column should be\\n\" +\n      \"used as timestamp for each record. Unlike \" + TsvParser.ROWKEY_COLUMN_SPEC + \", \" +\n      TsvParser.TIMESTAMPKEY_COLUMN_SPEC + \" is optional.\\n\" +\n      \"You must specify at most one column as timestamp key for each imported record.\\n\" +\n      \"Record with invalid timestamps (blank, non-numeric) will be treated as bad record.\\n\" +\n      \"Note: if you use this option, then '\" + TIMESTAMP_CONF_KEY + \"' option will be ignored.\\n\" +\n      \"\\n\" +\n      TsvParser.ATTRIBUTES_COLUMN_SPEC+\" can be used to specify Operation Attributes per record.\\n\"+\n      \" Should be specified as key=>value where \"+TsvParser.DEFAULT_ATTRIBUTES_COLUMN_INDEX+ \" is used \\n\"+\n      \" as the seperator.  Note that more than one OperationAttributes can be specified.\\n\"+\n      \"By default importtsv will load data directly into HBase. To instead generate\\n\" +\n      \"HFiles of data to prepare for a bulk data load, pass the option:\\n\" +\n      \"  -D\" + BULK_OUTPUT_CONF_KEY + \"=/path/for/output\\n\" +\n      \"  Note: if you do not use this option, then the target table must already exist in HBase\\n\" +\n      \"\\n\" +\n      \"Other options that may be specified with -D include:\\n\" +\n      \"  -D\" + SKIP_LINES_CONF_KEY + \"=false - fail if encountering an invalid line\\n\" +\n      \"  '-D\" + SEPARATOR_CONF_KEY + \"=|' - eg separate on pipes instead of tabs\\n\" +\n      \"  -D\" + TIMESTAMP_CONF_KEY + \"=currentTimeAsLong - use the specified timestamp for the import\\n\" +\n      \"  -D\" + MAPPER_CONF_KEY + \"=my.Mapper - A user-defined Mapper to use instead of \" +\n      DEFAULT_MAPPER.getName() + \"\\n\" +\n      \"  -D\" + JOB_NAME_CONF_KEY + \"=jobName - use the specified mapreduce job name for the import\\n\" +\n      \"For performance consider the following options:\\n\" +\n      \"  -Dmapreduce.map.speculative=false\\n\" +\n      \"  -Dmapreduce.reduce.speculative=false\";\n\n    System.err.println(usage);\n  }","id":22279,"modified_method":"private static void usage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    String usage = \n      \"Usage: \" + NAME + \" -D\"+ COLUMNS_CONF_KEY + \"=a,b,c <tablename> <inputdir>\\n\" +\n      \"\\n\" +\n      \"Imports the given input directory of TSV data into the specified table.\\n\" +\n      \"\\n\" +\n      \"The column names of the TSV data must be specified using the -D\" + COLUMNS_CONF_KEY + \"\\n\" +\n      \"option. This option takes the form of comma-separated column names, where each\\n\" +\n      \"column name is either a simple column family, or a columnfamily:qualifier. The special\\n\" +\n      \"column name \" + TsvParser.ROWKEY_COLUMN_SPEC + \" is used to designate that this column should be used\\n\" +\n      \"as the row key for each imported record. You must specify exactly one column\\n\" +\n      \"to be the row key, and you must specify a column name for every column that exists in the\\n\" +\n      \"input data. Another special column\" + TsvParser.TIMESTAMPKEY_COLUMN_SPEC +\n      \" designates that this column should be\\n\" +\n      \"used as timestamp for each record. Unlike \" + TsvParser.ROWKEY_COLUMN_SPEC + \", \" +\n      TsvParser.TIMESTAMPKEY_COLUMN_SPEC + \" is optional.\\n\" +\n      \"You must specify at most one column as timestamp key for each imported record.\\n\" +\n      \"Record with invalid timestamps (blank, non-numeric) will be treated as bad record.\\n\" +\n      \"Note: if you use this option, then '\" + TIMESTAMP_CONF_KEY + \"' option will be ignored.\\n\" +\n      \"\\n\" +\n      TsvParser.ATTRIBUTES_COLUMN_SPEC+\" can be used to specify Operation Attributes per record.\\n\"+\n      \" Should be specified as key=>value where \"+TsvParser.DEFAULT_ATTRIBUTES_COLUMN_INDEX+ \" is used \\n\"+\n      \" as the seperator.  Note that more than one OperationAttributes can be specified.\\n\"+\n      \"By default importtsv will load data directly into HBase. To instead generate\\n\" +\n      \"HFiles of data to prepare for a bulk data load, pass the option:\\n\" +\n      \"  -D\" + BULK_OUTPUT_CONF_KEY + \"=/path/for/output\\n\" +\n      \"  Note: if you do not use this option, then the target table must already exist in HBase\\n\" +\n      \"\\n\" +\n      \"Other options that may be specified with -D include:\\n\" +\n      \"  -D\" + SKIP_LINES_CONF_KEY + \"=false - fail if encountering an invalid line\\n\" +\n      \"  '-D\" + SEPARATOR_CONF_KEY + \"=|' - eg separate on pipes instead of tabs\\n\" +\n      \"  -D\" + TIMESTAMP_CONF_KEY + \"=currentTimeAsLong - use the specified timestamp for the import\\n\" +\n      \"  -D\" + MAPPER_CONF_KEY + \"=my.Mapper - A user-defined Mapper to use instead of \" +\n      DEFAULT_MAPPER.getName() + \"\\n\" +\n      \"  -D\" + JOB_NAME_CONF_KEY + \"=jobName - use the specified mapreduce job name for the import\\n\" +\n      \"  -D\" + CREATE_TABLE_CONF_KEY + \"=no - can be used to avoid creation of table by this tool\\n\" +\n      \"  Note: if you set this to 'no', then the target table must already exist in HBase\\n\" +\n      \"\\n\" +\n      \"For performance consider the following options:\\n\" +\n      \"  -Dmapreduce.map.speculative=false\\n\" +\n      \"  -Dmapreduce.reduce.speculative=false\";\n\n    System.err.println(usage);\n  }","commit_id":"8e9a8b002ff088b9ea05aa6188d3c2bedec79a5a","url":"https://github.com/apache/hbase"},{"original_method":"private void usage() {\n    System.err.println(\"usage: \" + NAME +\n        \" /path/to/hfileoutputformat-output \" +\n        \"tablename\");\n  }","id":22280,"modified_method":"private void usage() {\n    System.err.println(\"usage: \" + NAME + \" /path/to/hfileoutputformat-output tablename\" + \"\\n -D\"\n        + CREATE_TABLE_CONF_KEY + \"=no - can be used to avoid creation of table by this tool\\n\"\n        + \"  Note: if you set this to 'no', then the target table must already exist in HBase\\n\"\n        + \"\\n\");\n  }","commit_id":"8e9a8b002ff088b9ea05aa6188d3c2bedec79a5a","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int run(String[] args) throws Exception {\n    if (args.length != 2) {\n      usage();\n      return -1;\n    }\n\n    initialize();\n\n    String dirPath = args[0];\n    TableName tableName = TableName.valueOf(args[1]);\n\n    boolean tableExists = this.doesTableExist(tableName);\n    if (!tableExists) this.createTable(tableName,dirPath);\n\n    Path hfofDir = new Path(dirPath);\n    HTable table = new HTable(getConf(), tableName);\n\n    doBulkLoad(hfofDir, table);\n    return 0;\n  }","id":22281,"modified_method":"@Override\n  public int run(String[] args) throws Exception {\n    if (args.length != 2) {\n      usage();\n      return -1;\n    }\n\n    initialize();\n\n    String dirPath = args[0];\n    TableName tableName = TableName.valueOf(args[1]);\n\n    boolean tableExists = this.doesTableExist(tableName);\n    if (!tableExists) {\n      if (\"yes\".equalsIgnoreCase(getConf().get(CREATE_TABLE_CONF_KEY, \"yes\"))) {\n        this.createTable(tableName, dirPath);\n      } else {\n        String errorMsg = format(\"Table '%s' does not exist.\", tableName);\n        LOG.error(errorMsg);\n        throw new TableNotFoundException(errorMsg);\n      }\n    }\n\n    Path hfofDir = new Path(dirPath);\n    HTable table = new HTable(getConf(), tableName);\n\n    doBulkLoad(hfofDir, table);\n    return 0;\n  }","commit_id":"8e9a8b002ff088b9ea05aa6188d3c2bedec79a5a","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public ColumnarTable createNewTable(byte[] tableName,\n      TimestampOracle timeOracle) {\n    HBaseOVCTable table = null;\n    try {\n      table = new HBaseOVCTable(createTable(tableName), FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return new ColumnarOnVersionedColumnarTable(table, timeOracle);\n  }","id":22282,"modified_method":"@Override\n  public ColumnarTable createNewTable(byte[] tableName,\n      TimestampOracle timeOracle) {\n    HBaseOVCTable table = null;\n    try {\n      createTable(tableName);\n      table = new HBaseOVCTable(conf, tableName, FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return new ColumnarOnVersionedColumnarTable(table, timeOracle);\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"public HBaseOVCTable(HTable table, final byte[] family,\n      IOExceptionHandler exceptionHandler) {\n    this.table = table;\n    this.family = family;\n    this.exceptionHandler = exceptionHandler;\n  }","id":22283,"modified_method":"public HBaseOVCTable(Configuration conf, final byte [] tableName,\n      final byte[] family, IOExceptionHandler exceptionHandler)\n  throws IOException {\n    this.readTable = new HTable(conf, tableName);\n    this.writeTables = new LinkedList<HTable>();\n    this.writeTables.add(new HTable(conf, tableName));\n    this.writeTables.add(new HTable(conf, tableName));\n    this.conf = conf;\n    this.tableName = tableName;\n    this.family = family;\n    this.exceptionHandler = exceptionHandler;\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public long increment(byte[] row, byte[] column, long amount,\n      ReadPointer readPointer, long writeVersion) {\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.addColumn(this.family, column, amount);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      Result result = this.table.increment(increment);\n      if (result.isEmpty()) return 0L;\n      return Bytes.toLong(result.value());\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return -1L;\n    }\n  }","id":22284,"modified_method":"@Override\n  public long increment(byte[] row, byte[] column, long amount,\n      ReadPointer readPointer, long writeVersion) {\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.addColumn(this.family, column, amount);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      increment.setWriteVersion(writeVersion);\n      Result result = this.readTable.increment(increment);\n      if (result.isEmpty()) return 0L;\n      return Bytes.toLong(result.value());\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return -1L;\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void put(byte[] row, byte[] column, long version, byte[] value) {\n    try {\n      this.table.put(new Put(row).add(this.family, column, version, value));\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22285,"modified_method":"@Override\n  public void put(byte[] row, byte[] column, long version, byte[] value) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      writeTable.put(new Put(row).add(this.family, column, version, value));\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteAll(byte[] row, byte[][] columns, long version) {\n    try {\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumns(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22286,"modified_method":"@Override\n  public void deleteAll(byte[] row, byte[][] columns, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean compareAndSwap(byte[] row, byte[] column,\n      byte[] expectedValue, byte[] newValue, ReadPointer readPointer,\n      long writeVersion) {\n    try {\n      // TODO: This currently does not support passing a read pointer!\n      Put put = new Put(row);\n      put.add(this.family, column, writeVersion, newValue);\n      return this.table.checkAndPut(row, this.family, column, expectedValue, put);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return false;\n    }\n  }","id":22287,"modified_method":"@Override\n  public boolean compareAndSwap(byte[] row, byte[] column,\n      byte[] expectedValue, byte[] newValue, ReadPointer readPointer,\n      long writeVersion) {\n    try {\n      if (newValue == null) {\n        Delete delete = new Delete(row);\n        delete.deleteColumns(family, column, writeVersion);\n        return this.readTable.checkAndDelete(row, this.family, column,\n            expectedValue, readPointer.getMaximum(), delete);\n      } else {\n        Put put = new Put(row);\n        put.add(this.family, column, writeVersion, newValue);\n        return this.readTable.checkAndPut(row, this.family, column, expectedValue,\n            readPointer.getMaximum(), put);\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return false;\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ImmutablePair<byte[], Long> getWithVersion(byte[] row, byte[] column,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        return new ImmutablePair<byte[],Long>(kv.getValue(), kv.getTimestamp());\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","id":22288,"modified_method":"@Override\n  public ImmutablePair<byte[], Long> getWithVersion(byte[] row, byte[] column,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        return new ImmutablePair<byte[],Long>(kv.getValue(), kv.getTimestamp());\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[] startColumn,\n      byte[] stopColumn, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","id":22289,"modified_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[] startColumn,\n      byte[] stopColumn, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        if (startColumn != null &&\n            Bytes.compareTo(startColumn, column) > 0) continue;\n        if (stopColumn != null &&\n            Bytes.compareTo(column, stopColumn) >= 0) break;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteAll(byte[] row, byte[] column, long version) {\n    try {\n      Delete delete = new Delete(row);\n      delete.deleteColumns(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22290,"modified_method":"@Override\n  public void deleteAll(byte[] row, byte[] column, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      delete.deleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], Long> increment(byte[] row, byte[][] columns,\n      long[] amounts, ReadPointer readPointer, long writeVersion) {\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      for (int i=0; i<columns.length; i++)\n        increment.addColumn(this.family, columns[i], amounts[i]);\n      Result result = this.table.increment(increment);\n      for (KeyValue kv : result.raw())\n        ret.put(kv.getRow(), Bytes.toLong(kv.getValue()));\n      return ret;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return ret;\n    }\n  }","id":22291,"modified_method":"@Override\n  public Map<byte[], Long> increment(byte[] row, byte[][] columns,\n      long[] amounts, ReadPointer readPointer, long writeVersion) {\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      increment.setWriteVersion(writeVersion);\n      for (int i=0; i<columns.length; i++)\n        increment.addColumn(this.family, columns[i], amounts[i]);\n      Result result = this.readTable.increment(increment);\n      for (KeyValue kv : result.raw())\n        ret.put(kv.getQualifier(), Bytes.toLong(kv.getValue()));\n      return ret;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return ret;\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void delete(byte[] row, byte[][] columns, long version) {\n    try {\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumn(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22292,"modified_method":"@Override\n  public void delete(byte[] row, byte[][] columns, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumn(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void put(byte[] row, byte[][] columns, long version, byte[][] values) {\n    assert (columns.length == values.length);\n    try {\n      Put put = new Put(row);\n      for (int i = 0; i < columns.length; i++) {\n        put.add(this.family, columns[i], version, values[i]);\n      }\n      this.table.put(put);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22293,"modified_method":"@Override\n  public void put(byte[] row, byte[][] columns, long version, byte[][] values) {\n    assert (columns.length == values.length);\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Put put = new Put(row);\n      for (int i = 0; i < columns.length; i++) {\n        put.add(this.family, columns[i], version, values[i]);\n      }\n      writeTable.put(put);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","id":22294,"modified_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[][] columns,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      for (byte [] column : columns) get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","id":22295,"modified_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[][] columns,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      for (byte [] column : columns) get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void undeleteAll(byte[] row, byte[][] columns, long version) {\n    throw new RuntimeException(\"undelete operation not supported by hbase\");\n  }","id":22296,"modified_method":"@Override\n  public void undeleteAll(byte[] row, byte[][] columns, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.undeleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<byte[]> getKeys(int limit, int offset, ReadPointer readPointer) {\n    List<byte[]> keys = new ArrayList<byte[]>(limit > 1024 ? 1024 : limit);\n    int returned = 0;\n    int skipped = 0;\n    try {\n      Scan scan = new Scan();\n      scan.setTimeRange(0, getMaxStamp(readPointer));\n      scan.setMaxVersions();\n      ResultScanner scanner = this.table.getScanner(scan);\n      Result result = null;\n      while ((result = scanner.next()) != null) {\n        for (KeyValue kv : result.raw()) {\n          if (!readPointer.isVisible(kv.getTimestamp())) continue;\n          if (skipped < offset) {\n            skipped++;\n          } else if (returned < limit) {\n            returned++;\n            keys.add(kv.getRow());\n          }\n          if (returned == limit) return keys;\n          break;\n        }\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return keys;\n  }","id":22297,"modified_method":"@Override\n  public List<byte[]> getKeys(int limit, int offset, ReadPointer readPointer) {\n    List<byte[]> keys = new ArrayList<byte[]>(limit > 1024 ? 1024 : limit);\n    int returned = 0;\n    int skipped = 0;\n    try {\n      Scan scan = new Scan();\n      scan.setTimeRange(0, getMaxStamp(readPointer));\n      scan.setMaxVersions();\n      ResultScanner scanner = this.readTable.getScanner(scan);\n      Result result = null;\n      while ((result = scanner.next()) != null) {\n        for (KeyValue kv : result.raw()) {\n          if (!readPointer.isVisible(kv.getTimestamp())) continue;\n          if (skipped < offset) {\n            skipped++;\n          } else if (returned < limit) {\n            returned++;\n            keys.add(kv.getRow());\n          }\n          if (returned == limit) return keys;\n          break;\n        }\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return keys;\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public byte[] get(byte[] row, byte[] column, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        return kv.getValue();\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","id":22298,"modified_method":"@Override\n  public byte[] get(byte[] row, byte[] column, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] value = kv.getValue();\n        return value == null || value.length == 0 ? null : value;\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void undeleteAll(byte[] row, byte[] column, long version) {\n    throw new RuntimeException(\"undelete operation not supported by hbase\");\n  }","id":22299,"modified_method":"@Override\n  public void undeleteAll(byte[] row, byte[] column, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      delete.undeleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void delete(byte[] row, byte[] column, long version) {\n    try {\n      Delete delete = new Delete(row);\n      delete.deleteColumn(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22300,"modified_method":"@Override\n  public void delete(byte[] row, byte[] column, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      delete.deleteColumn(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public OrderedVersionedColumnarTable createNewTable(byte[] tableName) {\n    HBaseOVCTable table = null;\n    try {\n      table = new HBaseOVCTable(createTable(tableName), FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return table;\n  }","id":22301,"modified_method":"@Override\n  public OrderedVersionedColumnarTable createNewTable(byte[] tableName) {\n    HBaseOVCTable table = null;\n    try {\n      createTable(tableName);\n      table = new HBaseOVCTable(conf, tableName, FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return table;\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\r\n  public static void startHBase() throws Exception {\r\n    conf = new Configuration();\r\n    \r\n    // Start ZooKeeper\r\n    \r\n    zkCluster = new MiniZooKeeperCluster(conf);\r\n    System.err.println(\"Starting ZK in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    int zkPort = zkCluster.startup(getRandomTempDir(), 1);\r\n    System.err.println(\"\\n\\nStarted ZK on port \" + zkPort + \"\\n\\n\\n\");\r\n    \r\n    // Add ZK info to conf\r\n    conf.set(HConstants.ZOOKEEPER_CLIENT_PORT, Integer.toString(zkPort));\r\n    \r\n    // Start DFS\r\n    \r\n    File dfsPath = getRandomTempDir();\r\n    System.setProperty(\"test.build.data\", dfsPath.toString());\r\n    System.err.println(\"Instantiating dfs cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    dfsCluster = new MiniDFSCluster(0, conf, 1,\r\n        true, true, true, null, null, null, null);\r\n    System.err.println(\"Waiting for dfs to start...\");\r\n    dfsCluster.waitClusterUp();\r\n    System.err.println(\"DFS started...\");\r\n    Thread.sleep(1000);\r\n    \r\n    // Add HDFS info to conf\r\n    conf.set(\"fs.defaultFS\", dfsCluster.getFileSystem().getUri().toString());\r\n    \r\n    // Start HBase\r\n    createHBaseRootDir(conf);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.mintostart\", 1);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.maxtostart\", 1);\r\n    Configuration c = new Configuration(conf);\r\n    System.err.println(\"Instantiating HBase cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    hbaseCluster = new MiniHBaseCluster(c, 1, 1);\r\n    System.err.println(\"Just waiting around for a bit now\");\r\n    Thread.sleep(10000);\r\n  }","id":22302,"modified_method":"@BeforeClass\r\n  public static void startHBase() throws Exception {\r\n    conf = new Configuration();\r\n    \r\n    // Start ZooKeeper\r\n    \r\n    zkCluster = new MiniZooKeeperCluster(conf);\r\n    System.err.println(\"Starting ZK in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    int zkPort = zkCluster.startup(getRandomTempDir(), 1);\r\n    System.err.println(\"\\n\\nStarted ZK on port \" + zkPort + \"\\n\\n\\n\");\r\n    \r\n    // Add ZK info to conf\r\n    conf.set(HConstants.ZOOKEEPER_CLIENT_PORT, Integer.toString(zkPort));\r\n    \r\n    // Start DFS\r\n    \r\n    File dfsPath = getRandomTempDir();\r\n    System.setProperty(\"test.build.data\", dfsPath.toString());\r\n    System.err.println(\"Instantiating dfs cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    dfsCluster = new MiniDFSCluster(0, conf, 1,\r\n        true, true, true, null, null, null, null);\r\n    System.err.println(\"Waiting for dfs to start...\");\r\n    dfsCluster.waitClusterUp();\r\n    System.err.println(\"DFS started...\");\r\n    Thread.sleep(1000);\r\n    \r\n    // Add HDFS info to conf\r\n    conf.set(\"fs.defaultFS\", dfsCluster.getFileSystem().getUri().toString());\r\n    \r\n    // Start HBase\r\n    createHBaseRootDir(conf);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.mintostart\", 1);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.maxtostart\", 1);\r\n    Configuration c = new Configuration(conf);\r\n    System.err.println(\"Instantiating HBase cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    hbaseCluster = new MiniHBaseCluster(c, 1, 1);\r\n    System.err.println(\"Just waiting around for a bit now\");\r\n    Thread.sleep(1000);\r\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetAllKeys() {\n\n    // list when empty\n    List<byte[]> keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertNotNull(keys);\n    assertTrue(keys.isEmpty());\n\n    // write 10 rows\n    for (int i=0; i<10; i++) {\n      this.table.put(Bytes.toBytes(\"row\" + i), COL, 10, Bytes.toBytes(i));\n    }\n\n    // get all keys and get all 10 back\n    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertEquals(10, keys.size());\n    for (int i=0; i<10; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out a smaller limit\n    keys = this.table.getKeys(5, 0, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out an offset and limit\n    keys = this.table.getKeys(5, 2, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      String row = \"row\" + (i+2);\n      assertTrue(\"On i=\" + i + \", expected row \" + row + \", got row \" +\n          new String(keys.get(i)),\n          Bytes.equals(row.getBytes(), keys.get(i)));\n    }\n\n    // too big of an offset\n    keys = this.table.getKeys(5, 10, RP_MAX);\n    assertEquals(0, keys.size());\n\n    // delete three of the rows, undelete one of them\n    this.table.delete(Bytes.toBytes(\"row\" + 4), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 8), COL, 10);\n    this.table.undeleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n\n    // get all keys and only get 8 back\n    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertEquals(8, keys.size());\n\n  }","id":22303,"modified_method":"@Test\n  public void testGetAllKeys() {\n\n    // list when empty\n    List<byte[]> keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertNotNull(keys);\n    assertTrue(keys.isEmpty());\n\n    // write 10 rows\n    for (int i=0; i<10; i++) {\n      this.table.put(Bytes.toBytes(\"row\" + i), COL, 10, Bytes.toBytes(i));\n    }\n\n    // get all keys and get all 10 back\n    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertEquals(10, keys.size());\n    for (int i=0; i<10; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out a smaller limit\n    keys = this.table.getKeys(5, 0, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out an offset and limit\n    keys = this.table.getKeys(5, 2, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      String row = \"row\" + (i+2);\n      assertTrue(\"On i=\" + i + \", expected row \" + row + \", got row \" +\n          new String(keys.get(i)),\n          Bytes.equals(row.getBytes(), keys.get(i)));\n    }\n\n    // too big of an offset\n    keys = this.table.getKeys(5, 10, RP_MAX);\n    assertEquals(0, keys.size());\n\n    // delete three of the rows, undelete one of them\n    this.table.delete(Bytes.toBytes(\"row\" + 4), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 8), COL, 10);\n//    this.table.undeleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n//\n//    // get all keys and only get 8 back\n//    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n//    assertEquals(8, keys.size());\n\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void initialize() {\n    this.tableHandle = getTableHandle();\n    this.table = this.tableHandle.getTable(\n        Bytes.toBytes(\"TestOVCTable\" + Math.abs(r.nextInt())));\n  }","id":22304,"modified_method":"@Before\n  public void initialize() {\n    System.out.println(\"\\n\\nBeginning test\\n\\n\");\n    this.tableHandle = getTableHandle();\n    this.table = this.tableHandle.getTable(\n        Bytes.toBytes(\"TestOVCTable\" + Math.abs(r.nextInt())));\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSameVersionOverwritesExisting() {\n\n    byte [] row = Bytes.toBytes(\"testSVOEKey\");\n\n    // Write value = 5 @ ts = 5\n    this.table.put(row, COL, 5L, Bytes.toBytes(5L));\n\n    // Read value = 5 @ tsMax\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 10 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(10L));\n\n    // Read value = 10 @ tsMax\n    assertEquals(10L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 11 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(11L));\n\n    // Read value = 11 @ tsMax\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 11 @ ts <= 10\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(10L))));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n\n    // Increment + 1 @ ts = 10\n    assertEquals(12L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(9L, 10L, null), 10L));\n\n    // Read value = 12 @ tsMax\n    assertEquals(12L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // CompareAndSwap 12 to 15 @ ts = 10\n    assertTrue(this.table.compareAndSwap(row, COL, Bytes.toBytes(12L),\n        Bytes.toBytes(15L), new MemoryReadPointer(9L, 10L, null), 10L));\n\n    // Increment + 1 @ ts = 10\n    assertEquals(16L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(9L, 10L, null), 10L));\n\n    // Read value = 16 @ tsMax\n    assertEquals(16L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n  }","id":22305,"modified_method":"@Test\n  public void testSameVersionOverwritesExisting() {\n\n    byte [] row = Bytes.toBytes(\"testSVOEKey\");\n\n    // Write value = 5 @ ts = 5\n    this.table.put(row, COL, 5L, Bytes.toBytes(5L));\n\n    // Read value = 5 @ tsMax\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 10 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(10L));\n\n    // Read value = 10 @ tsMax\n    assertEquals(10L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 11 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(11L));\n\n    // Read value = 11 @ tsMax\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 11 @ ts <= 10\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(10L))));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n\n    // Increment + 1 @ ts = 9 to ts=11\n    assertEquals(6L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(9L), 11L));\n\n    // Read value = 6 @ tsMax\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // CompareAndSwap 6 to 15 @ ts = 11\n    assertTrue(this.table.compareAndSwap(row, COL, Bytes.toBytes(6L),\n        Bytes.toBytes(15L), new MemoryReadPointer(11L), 12L));\n\n    // Increment + 1 @ ts = 12\n    assertEquals(16L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(12L), 13L));\n\n    // Read value = 16 @ tsMax\n    assertEquals(16L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testIncrementsSupportReadAndWritePointers() {\n\n    byte [] row = Bytes.toBytes(\"testIncrementsSupportReadAndWritePointers\");\n\n    assertEquals(1L, this.table.increment(row, COL, 1L, RP_MAX, 1L));\n\n    assertEquals(3L, this.table.increment(row, COL, 2L, RP_MAX, 2L));\n\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n  }","id":22306,"modified_method":"@Test\n  public void testIncrementsSupportReadAndWritePointers() {\n\n    byte [] row = Bytes.toBytes(\"testIncrementsSupportReadAndWritePointers\");\n\n    // increment with write pointers\n    \n    assertEquals(1L, this.table.increment(row, COL, 1L, RP_MAX, 1L));\n\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(1L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(2L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(3L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(4L))));\n    \n    assertEquals(3L, this.table.increment(row, COL, 2L, RP_MAX, 3L));\n\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(1L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(2L))));\n    assertEquals(3L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(3L))));\n    assertEquals(3L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(4L))));\n\n    // test an increment with a read pointer\n    \n    assertEquals(2L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(1L), 2L));\n    \n    // read it back with read pointer reads\n    \n    assertEquals(3L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(3L))));\n    assertEquals(2L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(2L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(1L))));\n    \n    // read it back with increment=0\n\n    assertEquals(1L, this.table.increment(row, COL, 0L,\n        new MemoryReadPointer(1L), 1L));\n    assertEquals(2L, this.table.increment(row, COL, 0L,\n        new MemoryReadPointer(2L), 2L));\n    assertEquals(3L, this.table.increment(row, COL, 0L,\n        new MemoryReadPointer(3L), 3L));\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDeleteBehavior() {\n\n    byte [] row = Bytes.toBytes(\"testDeleteBehavior\");\n\n    // Verify row dne\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write values 1, 2, 3 @ ts 1, 2, 3\n    this.table.put(row, COL, 1L, Bytes.toBytes(1L));\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n    this.table.put(row, COL, 2L, Bytes.toBytes(2L));\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 2\n    this.table.delete(row, COL, 2L);\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 3\n    this.table.delete(row, COL, 3L);\n\n    // Read value, should be 1 (2 and 3 point deleted)\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 3\n    this.table.deleteAll(row, COL, 3L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 3 (trying to overwrite existing deletes @ 3)\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n\n    // Read value\n    // If writes can overwrite deletes at the same timestamp:\n    // assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n    // Currently, a delete cannot be overwritten on the same version:\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Undelete the delete all at 3\n    this.table.undeleteAll(row, COL, 3L);\n\n    // There is still a point delete at 3, should uncover 1\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 5\n    this.table.deleteAll(row, COL, 5L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 4\n    this.table.put(row, COL, 4L, Bytes.toBytes(4L));\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 6\n    this.table.put(row, COL, 6L, Bytes.toBytes(6L));\n\n    // Read value, should be 6\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Undelete the delete all at 5\n    this.table.undeleteAll(row, COL, 5L);\n\n    // 6 still visible\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete 6\n    this.table.delete(row, COL, 6L);\n\n    // Read value, should now be 4\n    assertEquals(4L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n  }","id":22307,"modified_method":"@Test\n  public void testDeleteBehavior() {\n\n    byte [] row = Bytes.toBytes(\"testDeleteBehavior\");\n\n    // Verify row dne\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write values 1, 2, 3 @ ts 1, 2, 3\n    this.table.put(row, COL, 1L, Bytes.toBytes(1L));\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n    this.table.put(row, COL, 2L, Bytes.toBytes(2L));\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 2\n    this.table.delete(row, COL, 2L);\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 3\n    this.table.delete(row, COL, 3L);\n\n    // Read value, should be 1 (2 and 3 point deleted)\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 3\n    this.table.deleteAll(row, COL, 3L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 3 (trying to overwrite existing deletes @ 3)\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n\n    // Read value\n    // If writes can overwrite deletes at the same timestamp:\n    // assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n    // Currently, a delete cannot be overwritten on the same version:\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Undelete the delete all at 3\n    this.table.undeleteAll(row, COL, 3L);\n\n    // There is still a point delete at 3, should uncover 1\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 5\n    this.table.deleteAll(row, COL, 5L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 4\n    this.table.put(row, COL, 4L, Bytes.toBytes(4L));\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 6\n    this.table.put(row, COL, 6L, Bytes.toBytes(6L));\n\n    // Read value, should be 6\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Undelete the delete all at 5\n    this.table.undeleteAll(row, COL, 5L);\n\n    // 6 still visible\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // 4 is still visible at ts=4\n    assertEquals(4L, Bytes.toLong(this.table.get(row, COL, new MemoryReadPointer(4))));\n\n    // Point delete 6\n    this.table.delete(row, COL, 6L);\n\n    // Read value, should now be 4\n    assertEquals(4L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n  }","commit_id":"836153b2c47d6e1d32175f7b8e19ef5dfeef1d3c","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * We were only clearing rows that had a hregioninfo column in hbase:meta.  Mangled rows that\n   * were missing the hregioninfo because of error were being left behind messing up any\n   * subsequent table made with the same name. HBASE-12980\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  @Test(timeout=60000)\n  public void testDeleteForSureClearsAllTableRowsFromMeta()\n  throws IOException, InterruptedException {\n    final TableName tableName = TableName.valueOf(\"testDeleteForSureClearsAllTableRowsFromMeta\");\n    final HBaseAdmin admin = TEST_UTIL.getHBaseAdmin();\n    final HTableDescriptor desc = new HTableDescriptor(tableName);\n    desc.addFamily(new HColumnDescriptor(FAMILYNAME));\n    admin.createTable(desc, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n    // Now I have a nice table, mangle it by removing the HConstants.REGIONINFO_QUALIFIER_STR\n    // content from a few of the rows.\n    try (Table metaTable = TEST_UTIL.getConnection().getTable(TableName.META_TABLE_NAME)) {\n      try (ResultScanner scanner =\n          metaTable.getScanner(MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(), tableName))) {\n        for (Result result : scanner) {\n          // Just delete one row.\n          Delete d = new Delete(result.getRow());\n          d.addColumn(HConstants.CATALOG_FAMILY, HConstants.REGIONINFO_QUALIFIER);\n          LOG.info(\"Mangled: \" + d);\n          metaTable.delete(d);\n          break;\n        }\n      }\n      admin.disableTable(tableName);\n      TEST_UTIL.waitTableDisabled(tableName.getName());\n      // Presume this synchronous all is.\n      admin.deleteTable(tableName);\n      int rowCount = 0;\n      try (ResultScanner scanner =\n          metaTable.getScanner(MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(), tableName))) {\n        for (Result result : scanner) {\n          LOG.info(\"Found when none expected: \" + result);\n          rowCount++;\n        }\n      }\n      assertEquals(0, rowCount);\n    }\n  }","id":22308,"modified_method":"/**\n   * We were only clearing rows that had a hregioninfo column in hbase:meta.  Mangled rows that\n   * were missing the hregioninfo because of error were being left behind messing up any\n   * subsequent table made with the same name. HBASE-12980\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  @Test(timeout=60000)\n  public void testDeleteForSureClearsAllTableRowsFromMeta()\n  throws IOException, InterruptedException {\n    final TableName tableName = TableName.valueOf(\"testDeleteForSureClearsAllTableRowsFromMeta\");\n    final HBaseAdmin admin = TEST_UTIL.getHBaseAdmin();\n    final HTableDescriptor desc = new HTableDescriptor(tableName);\n    desc.addFamily(new HColumnDescriptor(FAMILYNAME));\n    try {\n      createTable(TEST_UTIL, desc, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n    } catch (Exception e) {\n      e.printStackTrace();\n      fail(\"Got an exception while creating \" + tableName);\n    }\n    // Now I have a nice table, mangle it by removing the HConstants.REGIONINFO_QUALIFIER_STR\n    // content from a few of the rows.\n    try (Table metaTable = TEST_UTIL.getConnection().getTable(TableName.META_TABLE_NAME)) {\n      try (ResultScanner scanner =\n          metaTable.getScanner(MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(), tableName))) {\n        for (Result result : scanner) {\n          // Just delete one row.\n          Delete d = new Delete(result.getRow());\n          d.addColumn(HConstants.CATALOG_FAMILY, HConstants.REGIONINFO_QUALIFIER);\n          LOG.info(\"Mangled: \" + d);\n          metaTable.delete(d);\n          break;\n        }\n      }\n      admin.disableTable(tableName);\n      TEST_UTIL.waitTableDisabled(tableName.getName());\n      // Rely on the coprocessor based latch to make the operation synchronous.\n      try {\n        deleteTable(TEST_UTIL, tableName);\n      } catch (Exception e) {\n        e.printStackTrace();\n        fail(\"Got an exception while deleting \" + tableName);\n      }\n      int rowCount = 0;\n      try (ResultScanner scanner =\n          metaTable.getScanner(MetaTableAccessor.getScanForTableName(TEST_UTIL.getConnection(), tableName))) {\n        for (Result result : scanner) {\n          LOG.info(\"Found when none expected: \" + result);\n          rowCount++;\n        }\n      }\n      assertEquals(0, rowCount);\n    }\n  }","commit_id":"b728e66708cba45e1a030a8e06971a3c9d431dc7","url":"https://github.com/apache/hbase"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    TEST_UTIL.startMiniCluster(1);\n  }","id":22309,"modified_method":"@Before\n  public void setUp() throws Exception {\n    TEST_UTIL.getConfiguration().set(CoprocessorHost.MASTER_COPROCESSOR_CONF_KEY,\n      MasterSyncObserver.class.getName());\n    TEST_UTIL.startMiniCluster(1);\n  }","commit_id":"b728e66708cba45e1a030a8e06971a3c9d431dc7","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public ColumnarTable createNewTable(byte[] tableName,\n      TimestampOracle timeOracle) {\n    HBaseOVCTable table = null;\n    try {\n      table = new HBaseOVCTable(createTable(tableName), FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return new ColumnarOnVersionedColumnarTable(table, timeOracle);\n  }","id":22310,"modified_method":"@Override\n  public ColumnarTable createNewTable(byte[] tableName,\n      TimestampOracle timeOracle) {\n    HBaseOVCTable table = null;\n    try {\n      createTable(tableName);\n      table = new HBaseOVCTable(conf, tableName, FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return new ColumnarOnVersionedColumnarTable(table, timeOracle);\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void undeleteAll(byte[] row, byte[] column, long version) {\n    throw new RuntimeException(\"undelete operation not supported by hbase\");\n  }","id":22311,"modified_method":"@Override\n  public void undeleteAll(byte[] row, byte[] column, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      delete.undeleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","id":22312,"modified_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<byte[]> getKeys(int limit, int offset, ReadPointer readPointer) {\n    List<byte[]> keys = new ArrayList<byte[]>(limit > 1024 ? 1024 : limit);\n    int returned = 0;\n    int skipped = 0;\n    try {\n      Scan scan = new Scan();\n      scan.setTimeRange(0, getMaxStamp(readPointer));\n      scan.setMaxVersions();\n      ResultScanner scanner = this.table.getScanner(scan);\n      Result result = null;\n      while ((result = scanner.next()) != null) {\n        for (KeyValue kv : result.raw()) {\n          if (!readPointer.isVisible(kv.getTimestamp())) continue;\n          if (skipped < offset) {\n            skipped++;\n          } else if (returned < limit) {\n            returned++;\n            keys.add(kv.getRow());\n          }\n          if (returned == limit) return keys;\n          break;\n        }\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return keys;\n  }","id":22313,"modified_method":"@Override\n  public List<byte[]> getKeys(int limit, int offset, ReadPointer readPointer) {\n    List<byte[]> keys = new ArrayList<byte[]>(limit > 1024 ? 1024 : limit);\n    int returned = 0;\n    int skipped = 0;\n    try {\n      Scan scan = new Scan();\n      scan.setTimeRange(0, getMaxStamp(readPointer));\n      scan.setMaxVersions();\n      ResultScanner scanner = this.readTable.getScanner(scan);\n      Result result = null;\n      while ((result = scanner.next()) != null) {\n        for (KeyValue kv : result.raw()) {\n          if (!readPointer.isVisible(kv.getTimestamp())) continue;\n          if (skipped < offset) {\n            skipped++;\n          } else if (returned < limit) {\n            returned++;\n            keys.add(kv.getRow());\n          }\n          if (returned == limit) return keys;\n          break;\n        }\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return keys;\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void delete(byte[] row, byte[][] columns, long version) {\n    try {\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumn(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22314,"modified_method":"@Override\n  public void delete(byte[] row, byte[][] columns, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumn(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public long increment(byte[] row, byte[] column, long amount,\n      ReadPointer readPointer, long writeVersion) {\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.addColumn(this.family, column, amount);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      Result result = this.table.increment(increment);\n      if (result.isEmpty()) return 0L;\n      return Bytes.toLong(result.value());\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return -1L;\n    }\n  }","id":22315,"modified_method":"@Override\n  public long increment(byte[] row, byte[] column, long amount,\n      ReadPointer readPointer, long writeVersion) {\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.addColumn(this.family, column, amount);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      increment.setWriteVersion(writeVersion);\n      Result result = this.readTable.increment(increment);\n      if (result.isEmpty()) return 0L;\n      return Bytes.toLong(result.value());\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return -1L;\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void delete(byte[] row, byte[] column, long version) {\n    try {\n      Delete delete = new Delete(row);\n      delete.deleteColumn(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22316,"modified_method":"@Override\n  public void delete(byte[] row, byte[] column, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      delete.deleteColumn(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteAll(byte[] row, byte[][] columns, long version) {\n    try {\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumns(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22317,"modified_method":"@Override\n  public void deleteAll(byte[] row, byte[][] columns, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.deleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"public HBaseOVCTable(HTable table, final byte[] family,\n      IOExceptionHandler exceptionHandler) {\n    this.table = table;\n    this.family = family;\n    this.exceptionHandler = exceptionHandler;\n  }","id":22318,"modified_method":"public HBaseOVCTable(Configuration conf, final byte [] tableName,\n      final byte[] family, IOExceptionHandler exceptionHandler)\n  throws IOException {\n    this.readTable = new HTable(conf, tableName);\n    this.writeTables = new LinkedList<HTable>();\n    this.writeTables.add(new HTable(conf, tableName));\n    this.writeTables.add(new HTable(conf, tableName));\n    this.conf = conf;\n    this.tableName = tableName;\n    this.family = family;\n    this.exceptionHandler = exceptionHandler;\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[] startColumn,\n      byte[] stopColumn, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","id":22319,"modified_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[] startColumn,\n      byte[] stopColumn, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addFamily(this.family);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        if (startColumn != null &&\n            Bytes.compareTo(startColumn, column) > 0) continue;\n        if (stopColumn != null &&\n            Bytes.compareTo(column, stopColumn) >= 0) break;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], Long> increment(byte[] row, byte[][] columns,\n      long[] amounts, ReadPointer readPointer, long writeVersion) {\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      for (int i=0; i<columns.length; i++)\n        increment.addColumn(this.family, columns[i], amounts[i]);\n      Result result = this.table.increment(increment);\n      for (KeyValue kv : result.raw())\n        ret.put(kv.getRow(), Bytes.toLong(kv.getValue()));\n      return ret;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return ret;\n    }\n  }","id":22320,"modified_method":"@Override\n  public Map<byte[], Long> increment(byte[] row, byte[][] columns,\n      long[] amounts, ReadPointer readPointer, long writeVersion) {\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    try {\n      // TODO: This currently does not support passing a read pointer or a write\n      //       pointer!\n      Increment increment = new Increment(row);\n      increment.setTimeRange(0, getMaxStamp(readPointer));\n      increment.setWriteVersion(writeVersion);\n      for (int i=0; i<columns.length; i++)\n        increment.addColumn(this.family, columns[i], amounts[i]);\n      Result result = this.readTable.increment(increment);\n      for (KeyValue kv : result.raw())\n        ret.put(kv.getQualifier(), Bytes.toLong(kv.getValue()));\n      return ret;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return ret;\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ImmutablePair<byte[], Long> getWithVersion(byte[] row, byte[] column,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        return new ImmutablePair<byte[],Long>(kv.getValue(), kv.getTimestamp());\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","id":22321,"modified_method":"@Override\n  public ImmutablePair<byte[], Long> getWithVersion(byte[] row, byte[] column,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        return new ImmutablePair<byte[],Long>(kv.getValue(), kv.getTimestamp());\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[][] columns,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      for (byte [] column : columns) get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","id":22322,"modified_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[][] columns,\n      ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      for (byte [] column : columns) get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      Map<byte[], byte[]> map = new TreeMap<byte[], byte[]>(\n          Bytes.BYTES_COMPARATOR);\n      byte[] last = null;\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] column = kv.getQualifier();\n        if (Bytes.equals(last, column)) continue;\n        map.put(column, kv.getValue());\n        last = column;\n      }\n      return map;\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return null;\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean compareAndSwap(byte[] row, byte[] column,\n      byte[] expectedValue, byte[] newValue, ReadPointer readPointer,\n      long writeVersion) {\n    try {\n      // TODO: This currently does not support passing a read pointer!\n      Put put = new Put(row);\n      put.add(this.family, column, writeVersion, newValue);\n      return this.table.checkAndPut(row, this.family, column, expectedValue, put);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return false;\n    }\n  }","id":22323,"modified_method":"@Override\n  public boolean compareAndSwap(byte[] row, byte[] column,\n      byte[] expectedValue, byte[] newValue, ReadPointer readPointer,\n      long writeVersion) {\n    try {\n      if (newValue == null) {\n        Delete delete = new Delete(row);\n        delete.deleteColumns(family, column, writeVersion);\n        return this.readTable.checkAndDelete(row, this.family, column,\n            expectedValue, readPointer.getMaximum(), delete);\n      } else {\n        Put put = new Put(row);\n        put.add(this.family, column, writeVersion, newValue);\n        return this.readTable.checkAndPut(row, this.family, column, expectedValue,\n            readPointer.getMaximum(), put);\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n      return false;\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void put(byte[] row, byte[] column, long version, byte[] value) {\n    try {\n      this.table.put(new Put(row).add(this.family, column, version, value));\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22324,"modified_method":"@Override\n  public void put(byte[] row, byte[] column, long version, byte[] value) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      writeTable.put(new Put(row).add(this.family, column, version, value));\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void undeleteAll(byte[] row, byte[][] columns, long version) {\n    throw new RuntimeException(\"undelete operation not supported by hbase\");\n  }","id":22325,"modified_method":"@Override\n  public void undeleteAll(byte[] row, byte[][] columns, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      for (byte [] column : columns)\n        delete.undeleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteAll(byte[] row, byte[] column, long version) {\n    try {\n      Delete delete = new Delete(row);\n      delete.deleteColumns(this.family, column, version);\n      this.table.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22326,"modified_method":"@Override\n  public void deleteAll(byte[] row, byte[] column, long version) {\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Delete delete = new Delete(row);\n      delete.deleteColumns(this.family, column, version);\n      writeTable.delete(delete);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public byte[] get(byte[] row, byte[] column, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.table.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        return kv.getValue();\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","id":22327,"modified_method":"@Override\n  public byte[] get(byte[] row, byte[] column, ReadPointer readPointer) {\n    try {\n      Get get = new Get(row);\n      get.addColumn(this.family, column);\n      get.setTimeRange(0, getMaxStamp(readPointer));\n      get.setMaxVersions();\n      Result result = this.readTable.get(get);\n      for (KeyValue kv : result.raw()) {\n        long version = kv.getTimestamp();\n        if (!readPointer.isVisible(version)) continue;\n        byte [] value = kv.getValue();\n        return value == null || value.length == 0 ? null : value;\n      }\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n    return null;\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void put(byte[] row, byte[][] columns, long version, byte[][] values) {\n    assert (columns.length == values.length);\n    try {\n      Put put = new Put(row);\n      for (int i = 0; i < columns.length; i++) {\n        put.add(this.family, columns[i], version, values[i]);\n      }\n      this.table.put(put);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    }\n  }","id":22328,"modified_method":"@Override\n  public void put(byte[] row, byte[][] columns, long version, byte[][] values) {\n    assert (columns.length == values.length);\n    HTable writeTable = null;\n    try {\n      writeTable = getWriteTable();\n      Put put = new Put(row);\n      for (int i = 0; i < columns.length; i++) {\n        put.add(this.family, columns[i], version, values[i]);\n      }\n      writeTable.put(put);\n    } catch (IOException e) {\n      this.exceptionHandler.handle(e);\n    } finally {\n      if (writeTable != null) returnWriteTable(writeTable);\n    }\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public OrderedVersionedColumnarTable createNewTable(byte[] tableName) {\n    HBaseOVCTable table = null;\n    try {\n      table = new HBaseOVCTable(createTable(tableName), FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return table;\n  }","id":22329,"modified_method":"@Override\n  public OrderedVersionedColumnarTable createNewTable(byte[] tableName) {\n    HBaseOVCTable table = null;\n    try {\n      createTable(tableName);\n      table = new HBaseOVCTable(conf, tableName, FAMILY,\n          new HBaseIOExceptionHandler());\n    } catch (IOException e) {\n      exceptionHandler.handle(e);\n    }\n    return table;\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\r\n  public static void startHBase() throws Exception {\r\n    conf = new Configuration();\r\n    \r\n    // Start ZooKeeper\r\n    \r\n    zkCluster = new MiniZooKeeperCluster(conf);\r\n    System.err.println(\"Starting ZK in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    int zkPort = zkCluster.startup(getRandomTempDir(), 1);\r\n    System.err.println(\"\\n\\nStarted ZK on port \" + zkPort + \"\\n\\n\\n\");\r\n    \r\n    // Add ZK info to conf\r\n    conf.set(HConstants.ZOOKEEPER_CLIENT_PORT, Integer.toString(zkPort));\r\n    \r\n    // Start DFS\r\n    \r\n    File dfsPath = getRandomTempDir();\r\n    System.setProperty(\"test.build.data\", dfsPath.toString());\r\n    System.err.println(\"Instantiating dfs cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    dfsCluster = new MiniDFSCluster(0, conf, 1,\r\n        true, true, true, null, null, null, null);\r\n    System.err.println(\"Waiting for dfs to start...\");\r\n    dfsCluster.waitClusterUp();\r\n    System.err.println(\"DFS started...\");\r\n    Thread.sleep(1000);\r\n    \r\n    // Add HDFS info to conf\r\n    conf.set(\"fs.defaultFS\", dfsCluster.getFileSystem().getUri().toString());\r\n    \r\n    // Start HBase\r\n    createHBaseRootDir(conf);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.mintostart\", 1);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.maxtostart\", 1);\r\n    Configuration c = new Configuration(conf);\r\n    System.err.println(\"Instantiating HBase cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    hbaseCluster = new MiniHBaseCluster(c, 1, 1);\r\n    System.err.println(\"Just waiting around for a bit now\");\r\n    Thread.sleep(10000);\r\n  }","id":22330,"modified_method":"@BeforeClass\r\n  public static void startHBase() throws Exception {\r\n    conf = new Configuration();\r\n    \r\n    // Start ZooKeeper\r\n    \r\n    zkCluster = new MiniZooKeeperCluster(conf);\r\n    System.err.println(\"Starting ZK in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    int zkPort = zkCluster.startup(getRandomTempDir(), 1);\r\n    System.err.println(\"\\n\\nStarted ZK on port \" + zkPort + \"\\n\\n\\n\");\r\n    \r\n    // Add ZK info to conf\r\n    conf.set(HConstants.ZOOKEEPER_CLIENT_PORT, Integer.toString(zkPort));\r\n    \r\n    // Start DFS\r\n    \r\n    File dfsPath = getRandomTempDir();\r\n    System.setProperty(\"test.build.data\", dfsPath.toString());\r\n    System.err.println(\"Instantiating dfs cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    dfsCluster = new MiniDFSCluster(0, conf, 1,\r\n        true, true, true, null, null, null, null);\r\n    System.err.println(\"Waiting for dfs to start...\");\r\n    dfsCluster.waitClusterUp();\r\n    System.err.println(\"DFS started...\");\r\n    Thread.sleep(1000);\r\n    \r\n    // Add HDFS info to conf\r\n    conf.set(\"fs.defaultFS\", dfsCluster.getFileSystem().getUri().toString());\r\n    \r\n    // Start HBase\r\n    createHBaseRootDir(conf);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.mintostart\", 1);\r\n    conf.setInt(\"hbase.master.wait.on.regionservers.maxtostart\", 1);\r\n    Configuration c = new Configuration(conf);\r\n    System.err.println(\"Instantiating HBase cluster in 1 sec...\");\r\n    Thread.sleep(1000);\r\n    hbaseCluster = new MiniHBaseCluster(c, 1, 1);\r\n    System.err.println(\"Just waiting around for a bit now\");\r\n    Thread.sleep(1000);\r\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSameVersionOverwritesExisting() {\n\n    byte [] row = Bytes.toBytes(\"testSVOEKey\");\n\n    // Write value = 5 @ ts = 5\n    this.table.put(row, COL, 5L, Bytes.toBytes(5L));\n\n    // Read value = 5 @ tsMax\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 10 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(10L));\n\n    // Read value = 10 @ tsMax\n    assertEquals(10L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 11 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(11L));\n\n    // Read value = 11 @ tsMax\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 11 @ ts <= 10\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(10L))));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n\n    // Increment + 1 @ ts = 10\n    assertEquals(12L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(9L, 10L, null), 10L));\n\n    // Read value = 12 @ tsMax\n    assertEquals(12L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // CompareAndSwap 12 to 15 @ ts = 10\n    assertTrue(this.table.compareAndSwap(row, COL, Bytes.toBytes(12L),\n        Bytes.toBytes(15L), new MemoryReadPointer(9L, 10L, null), 10L));\n\n    // Increment + 1 @ ts = 10\n    assertEquals(16L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(9L, 10L, null), 10L));\n\n    // Read value = 16 @ tsMax\n    assertEquals(16L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n  }","id":22331,"modified_method":"@Test\n  public void testSameVersionOverwritesExisting() {\n\n    byte [] row = Bytes.toBytes(\"testSVOEKey\");\n\n    // Write value = 5 @ ts = 5\n    this.table.put(row, COL, 5L, Bytes.toBytes(5L));\n\n    // Read value = 5 @ tsMax\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 10 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(10L));\n\n    // Read value = 10 @ tsMax\n    assertEquals(10L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Write value = 11 @ ts = 10\n    this.table.put(row, COL, 10L, Bytes.toBytes(11L));\n\n    // Read value = 11 @ tsMax\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 11 @ ts <= 10\n    assertEquals(11L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(10L))));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n\n    // Increment + 1 @ ts = 9 to ts=11\n    assertEquals(6L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(9L), 11L));\n\n    // Read value = 6 @ tsMax\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // CompareAndSwap 6 to 15 @ ts = 11\n    assertTrue(this.table.compareAndSwap(row, COL, Bytes.toBytes(6L),\n        Bytes.toBytes(15L), new MemoryReadPointer(11L), 12L));\n\n    // Increment + 1 @ ts = 12\n    assertEquals(16L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(12L), 13L));\n\n    // Read value = 16 @ tsMax\n    assertEquals(16L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Read value = 5 @ ts <= 9\n    assertEquals(5L, Bytes.toLong(this.table.get(row, COL,\n        new MemoryReadPointer(9L))));\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetAllKeys() {\n\n    // list when empty\n    List<byte[]> keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertNotNull(keys);\n    assertTrue(keys.isEmpty());\n\n    // write 10 rows\n    for (int i=0; i<10; i++) {\n      this.table.put(Bytes.toBytes(\"row\" + i), COL, 10, Bytes.toBytes(i));\n    }\n\n    // get all keys and get all 10 back\n    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertEquals(10, keys.size());\n    for (int i=0; i<10; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out a smaller limit\n    keys = this.table.getKeys(5, 0, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out an offset and limit\n    keys = this.table.getKeys(5, 2, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      String row = \"row\" + (i+2);\n      assertTrue(\"On i=\" + i + \", expected row \" + row + \", got row \" +\n          new String(keys.get(i)),\n          Bytes.equals(row.getBytes(), keys.get(i)));\n    }\n\n    // too big of an offset\n    keys = this.table.getKeys(5, 10, RP_MAX);\n    assertEquals(0, keys.size());\n\n    // delete three of the rows, undelete one of them\n    this.table.delete(Bytes.toBytes(\"row\" + 4), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 8), COL, 10);\n    this.table.undeleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n\n    // get all keys and only get 8 back\n    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertEquals(8, keys.size());\n\n  }","id":22332,"modified_method":"@Test\n  public void testGetAllKeys() {\n\n    // list when empty\n    List<byte[]> keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertNotNull(keys);\n    assertTrue(keys.isEmpty());\n\n    // write 10 rows\n    for (int i=0; i<10; i++) {\n      this.table.put(Bytes.toBytes(\"row\" + i), COL, 10, Bytes.toBytes(i));\n    }\n\n    // get all keys and get all 10 back\n    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n    assertEquals(10, keys.size());\n    for (int i=0; i<10; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out a smaller limit\n    keys = this.table.getKeys(5, 0, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      assertTrue(\"On i=\" + i + \", got row \" + new String(keys.get(i)),\n          Bytes.equals(Bytes.toBytes(\"row\" + i), keys.get(i)));\n    }\n\n    // try out an offset and limit\n    keys = this.table.getKeys(5, 2, RP_MAX);\n    assertEquals(5, keys.size());\n    for (int i=0; i<5; i++) {\n      String row = \"row\" + (i+2);\n      assertTrue(\"On i=\" + i + \", expected row \" + row + \", got row \" +\n          new String(keys.get(i)),\n          Bytes.equals(row.getBytes(), keys.get(i)));\n    }\n\n    // too big of an offset\n    keys = this.table.getKeys(5, 10, RP_MAX);\n    assertEquals(0, keys.size());\n\n    // delete three of the rows, undelete one of them\n    this.table.delete(Bytes.toBytes(\"row\" + 4), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n    this.table.deleteAll(Bytes.toBytes(\"row\" + 8), COL, 10);\n//    this.table.undeleteAll(Bytes.toBytes(\"row\" + 6), COL, 10);\n//\n//    // get all keys and only get 8 back\n//    keys = this.table.getKeys(Integer.MAX_VALUE, 0, RP_MAX);\n//    assertEquals(8, keys.size());\n\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDeleteBehavior() {\n\n    byte [] row = Bytes.toBytes(\"testDeleteBehavior\");\n\n    // Verify row dne\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write values 1, 2, 3 @ ts 1, 2, 3\n    this.table.put(row, COL, 1L, Bytes.toBytes(1L));\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n    this.table.put(row, COL, 2L, Bytes.toBytes(2L));\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 2\n    this.table.delete(row, COL, 2L);\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 3\n    this.table.delete(row, COL, 3L);\n\n    // Read value, should be 1 (2 and 3 point deleted)\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 3\n    this.table.deleteAll(row, COL, 3L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 3 (trying to overwrite existing deletes @ 3)\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n\n    // Read value\n    // If writes can overwrite deletes at the same timestamp:\n    // assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n    // Currently, a delete cannot be overwritten on the same version:\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Undelete the delete all at 3\n    this.table.undeleteAll(row, COL, 3L);\n\n    // There is still a point delete at 3, should uncover 1\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 5\n    this.table.deleteAll(row, COL, 5L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 4\n    this.table.put(row, COL, 4L, Bytes.toBytes(4L));\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 6\n    this.table.put(row, COL, 6L, Bytes.toBytes(6L));\n\n    // Read value, should be 6\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Undelete the delete all at 5\n    this.table.undeleteAll(row, COL, 5L);\n\n    // 6 still visible\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete 6\n    this.table.delete(row, COL, 6L);\n\n    // Read value, should now be 4\n    assertEquals(4L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n  }","id":22333,"modified_method":"@Test\n  public void testDeleteBehavior() {\n\n    byte [] row = Bytes.toBytes(\"testDeleteBehavior\");\n\n    // Verify row dne\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write values 1, 2, 3 @ ts 1, 2, 3\n    this.table.put(row, COL, 1L, Bytes.toBytes(1L));\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n    this.table.put(row, COL, 2L, Bytes.toBytes(2L));\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 2\n    this.table.delete(row, COL, 2L);\n\n    // Read value, should be 3\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Point delete at 3\n    this.table.delete(row, COL, 3L);\n\n    // Read value, should be 1 (2 and 3 point deleted)\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 3\n    this.table.deleteAll(row, COL, 3L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 3 (trying to overwrite existing deletes @ 3)\n    this.table.put(row, COL, 3L, Bytes.toBytes(3L));\n\n    // Read value\n    // If writes can overwrite deletes at the same timestamp:\n    // assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n    // Currently, a delete cannot be overwritten on the same version:\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Undelete the delete all at 3\n    this.table.undeleteAll(row, COL, 3L);\n\n    // There is still a point delete at 3, should uncover 1\n    assertEquals(1L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // DeleteAll at 5\n    this.table.deleteAll(row, COL, 5L);\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 4\n    this.table.put(row, COL, 4L, Bytes.toBytes(4L));\n\n    // Read value, should not exist\n    assertNull(this.table.get(row, COL, RP_MAX));\n\n    // Write at 6\n    this.table.put(row, COL, 6L, Bytes.toBytes(6L));\n\n    // Read value, should be 6\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // Undelete the delete all at 5\n    this.table.undeleteAll(row, COL, 5L);\n\n    // 6 still visible\n    assertEquals(6L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n    // 4 is still visible at ts=4\n    assertEquals(4L, Bytes.toLong(this.table.get(row, COL, new MemoryReadPointer(4))));\n\n    // Point delete 6\n    this.table.delete(row, COL, 6L);\n\n    // Read value, should now be 4\n    assertEquals(4L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testIncrementsSupportReadAndWritePointers() {\n\n    byte [] row = Bytes.toBytes(\"testIncrementsSupportReadAndWritePointers\");\n\n    assertEquals(1L, this.table.increment(row, COL, 1L, RP_MAX, 1L));\n\n    assertEquals(3L, this.table.increment(row, COL, 2L, RP_MAX, 2L));\n\n    assertEquals(3L, Bytes.toLong(this.table.get(row, COL, RP_MAX)));\n\n  }","id":22334,"modified_method":"@Test\n  public void testIncrementsSupportReadAndWritePointers() {\n\n    byte [] row = Bytes.toBytes(\"testIncrementsSupportReadAndWritePointers\");\n\n    // increment with write pointers\n    \n    assertEquals(1L, this.table.increment(row, COL, 1L, RP_MAX, 1L));\n\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(1L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(2L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(3L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(4L))));\n    \n    assertEquals(3L, this.table.increment(row, COL, 2L, RP_MAX, 3L));\n\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(1L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(2L))));\n    assertEquals(3L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(3L))));\n    assertEquals(3L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(4L))));\n\n    // test an increment with a read pointer\n    \n    assertEquals(2L, this.table.increment(row, COL, 1L,\n        new MemoryReadPointer(1L), 2L));\n    \n    // read it back with read pointer reads\n    \n    assertEquals(3L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(3L))));\n    assertEquals(2L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(2L))));\n    assertEquals(1L, Bytes.toLong(\n        this.table.get(row, COL, new MemoryReadPointer(1L))));\n    \n    // read it back with increment=0\n\n    assertEquals(1L, this.table.increment(row, COL, 0L,\n        new MemoryReadPointer(1L), 1L));\n    assertEquals(2L, this.table.increment(row, COL, 0L,\n        new MemoryReadPointer(2L), 2L));\n    assertEquals(3L, this.table.increment(row, COL, 0L,\n        new MemoryReadPointer(3L), 3L));\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void initialize() {\n    this.tableHandle = getTableHandle();\n    this.table = this.tableHandle.getTable(\n        Bytes.toBytes(\"TestOVCTable\" + Math.abs(r.nextInt())));\n  }","id":22335,"modified_method":"@Before\n  public void initialize() {\n    System.out.println(\"\\n\\nBeginning test\\n\\n\");\n    this.tableHandle = getTableHandle();\n    this.table = this.tableHandle.getTable(\n        Bytes.toBytes(\"TestOVCTable\" + Math.abs(r.nextInt())));\n  }","commit_id":"db042c5219cb694d800fce44e7403c339d2d312f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected void createSchema() throws IOException {\n      HBaseAdmin admin = new HBaseAdmin(getConf());\n      TableName tableName = getTableName(getConf());\n      if (!admin.tableExists(tableName)) {\n        HTableDescriptor htd = new HTableDescriptor(getTableName(getConf()));\n        htd.addFamily(new HColumnDescriptor(FAMILY_NAME));\n        admin.createTable(htd);\n      }\n      admin.close();\n    }","id":22336,"modified_method":"protected void createSchema() throws IOException {\n      Configuration conf = getConf();\n      HBaseAdmin admin = new HBaseAdmin(conf);\n      TableName tableName = getTableName(conf);\n      try {\n        if (!admin.tableExists(tableName)) {\n          HTableDescriptor htd = new HTableDescriptor(getTableName(getConf()));\n          htd.addFamily(new HColumnDescriptor(FAMILY_NAME));\n          int numberOfServers = admin.getClusterStatus().getServers().size();\n          if (numberOfServers == 0) {\n            throw new IllegalStateException(\"No live regionservers\");\n          }\n          int regionsPerServer = conf.getInt(HBaseTestingUtility.REGIONS_PER_SERVER_KEY,\n                                HBaseTestingUtility.DEFAULT_REGIONS_PER_SERVER);\n          int totalNumberOfRegions = numberOfServers * regionsPerServer;\n          LOG.info(\"Number of live regionservers: \" + numberOfServers + \", \" +\n              \"pre-splitting table into \" + totalNumberOfRegions + \" regions \" +\n              \"(default regions per server: \" + regionsPerServer + \")\");\n\n          byte[][] splits = new RegionSplitter.UniformSplit().split(\n              totalNumberOfRegions);\n\n          admin.createTable(htd, splits);\n        }\n      } catch (MasterNotRunningException e) {\n        LOG.error(\"Master not running\", e);\n        throw new IOException(e);\n      } finally {\n        admin.close();\n      }\n    }","commit_id":"235aaee4fe6931796ff17777d882906af5fa9270","url":"https://github.com/apache/hbase"},{"original_method":"public ItemAttachmentIfc createItemAttachment(ItemDataIfc item,\n         String resourceId, String filename, String protocol){\n    ItemAttachment attach = null;\n    Boolean isLink = Boolean.FALSE;\n    try{\n      ContentResource cr = ContentHostingService.getResource(resourceId);\n      if (cr !=null){\n        ResourceProperties p = cr.getProperties();\n        attach = new ItemAttachment();\n        attach.setItem(item);\n        attach.setResourceId(resourceId);\n        attach.setFilename(filename);\n\tattach.setMimeType(cr.getContentType());\n        // we want to display kb, so divide by 1000 and round the result\n\tattach.setFileSize(new Long(\"\"+fileSizeInKB(cr.getContentLength())));\n        if (cr.getContentType().lastIndexOf(\"url\") > -1)\n          isLink = Boolean.TRUE;\n        attach.setIsLink(isLink);\n        attach.setStatus(ItemAttachmentIfc.ACTIVE_STATUS);\n\tattach.setCreatedBy(p.getProperty(p.getNamePropCreator()));\n        attach.setCreatedDate(new Date());\n\tattach.setLastModifiedBy(p.getProperty(p.getNamePropModifiedBy()));\n        attach.setLastModifiedDate(new Date());\n        attach.setLocation(getRelativePath(cr.getUrl(), protocol));\n        //getHibernateTemplate().save(attach);\n      }\n    }\n    catch(PermissionException pe){\n        pe.printStackTrace();\n    }\n    catch(IdUnusedException ie){\n        ie.printStackTrace();\n    }\n    catch(TypeException te){\n        te.printStackTrace();\n    }\n    return attach;\n  }","id":22337,"modified_method":"public ItemAttachmentIfc createItemAttachment(ItemDataIfc item,\n         String resourceId, String filename, String protocol){\n    ItemAttachment attach = null;\n    Boolean isLink = Boolean.FALSE;\n    try{\n      ContentResource cr = ContentHostingService.getResource(resourceId);\n      if (cr !=null){\n        ResourceProperties p = cr.getProperties();\n        attach = new ItemAttachment();\n        attach.setItem(item);\n        attach.setResourceId(resourceId);\n        attach.setMimeType(cr.getContentType());\n        // we want to display kb, so divide by 1000 and round the result\n        attach.setFileSize(new Long(\"\"+fileSizeInKB(cr.getContentLength())));\n\t\tif (cr.getContentType().lastIndexOf(\"url\") > -1) {\n\t\t\tisLink = Boolean.TRUE;\n\t\t\tif (!filename.toLowerCase().startsWith(\"http\")) {\n\t\t\t\tString adjustedFilename = \"http://\" + filename;\n\t\t\t\tattach.setFilename(adjustedFilename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattach.setFilename(filename);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tattach.setFilename(filename);\n\t\t}\n\t\tattach.setIsLink(isLink);\n        attach.setStatus(ItemAttachmentIfc.ACTIVE_STATUS);\n        attach.setCreatedBy(p.getProperty(p.getNamePropCreator()));\n        attach.setCreatedDate(new Date());\n        attach.setLastModifiedBy(p.getProperty(p.getNamePropModifiedBy()));\n        attach.setLastModifiedDate(new Date());\n        attach.setLocation(getRelativePath(cr.getUrl(), protocol));\n        //getHibernateTemplate().save(attach);\n      }\n    }\n    catch(PermissionException pe){\n        pe.printStackTrace();\n    }\n    catch(IdUnusedException ie){\n        ie.printStackTrace();\n    }\n    catch(TypeException te){\n        te.printStackTrace();\n    }\n    return attach;\n  }","commit_id":"efbd57ce0606e34b5ba9a44dad7ec4bfbed41d5d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public AssessmentAttachmentIfc createAssessmentAttachment(AssessmentIfc assessment,\n         String resourceId, String filename, String protocol){\n    AssessmentAttachment attach = null;\n    Boolean isLink = Boolean.FALSE;\n    try{\n      ContentResource cr = ContentHostingService.getResource(resourceId);\n      if (cr !=null){\n        ResourceProperties p = cr.getProperties();\n        attach = new AssessmentAttachment();\n        attach.setAssessment(assessment);\n        attach.setResourceId(resourceId);\n        attach.setFilename(filename);\n\tattach.setMimeType(cr.getContentType());\n        // we want to display kb, so divide by 1000 and round the result\n\tattach.setFileSize(new Long(fileSizeInKB(cr.getContentLength())));\n        if (cr.getContentType().lastIndexOf(\"url\") > -1)\n          isLink = Boolean.TRUE;\n        attach.setIsLink(isLink);\n        attach.setStatus(AssessmentAttachmentIfc.ACTIVE_STATUS);\n\tattach.setCreatedBy(p.getProperty(p.getNamePropCreator()));\n        attach.setCreatedDate(new Date());\n\tattach.setLastModifiedBy(p.getProperty(p.getNamePropModifiedBy()));\n        attach.setLastModifiedDate(new Date());\n        attach.setLocation(getRelativePath(cr.getUrl(), protocol));\n        //getHibernateTemplate().save(attach);\n      }\n    }\n    catch(PermissionException pe){\n      pe.printStackTrace();\n    }\n    catch(IdUnusedException ie){\n        ie.printStackTrace();\n    }\n    catch(TypeException te){\n        te.printStackTrace();\n    }\n    return attach;\n  }","id":22338,"modified_method":"public AssessmentAttachmentIfc createAssessmentAttachment(AssessmentIfc assessment,\n         String resourceId, String filename, String protocol){\n    AssessmentAttachment attach = null;\n    Boolean isLink = Boolean.FALSE;\n    try{\n      ContentResource cr = ContentHostingService.getResource(resourceId);\n      if (cr !=null){\n        ResourceProperties p = cr.getProperties();\n        attach = new AssessmentAttachment();\n        attach.setAssessment(assessment);\n        attach.setResourceId(resourceId);\n        attach.setFilename(filename);\n        attach.setMimeType(cr.getContentType());\n        // we want to display kb, so divide by 1000 and round the result\n\t\tattach.setFileSize(new Long(fileSizeInKB(cr.getContentLength())));\n\t\tif (cr.getContentType().lastIndexOf(\"url\") > -1) {\n\t\t\tisLink = Boolean.TRUE;\n\t\t\tif (!filename.toLowerCase().startsWith(\"http\")) {\n\t\t\t\tString adjustedFilename = \"http://\" + filename;\n\t\t\t\tattach.setFilename(adjustedFilename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattach.setFilename(filename);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tattach.setFilename(filename);\n\t\t}\n\t\tattach.setIsLink(isLink);\n        attach.setStatus(AssessmentAttachmentIfc.ACTIVE_STATUS);\n        attach.setCreatedBy(p.getProperty(p.getNamePropCreator()));\n        attach.setCreatedDate(new Date());\n        attach.setLastModifiedBy(p.getProperty(p.getNamePropModifiedBy()));\n        attach.setLastModifiedDate(new Date());\n        attach.setLocation(getRelativePath(cr.getUrl(), protocol));\n        //getHibernateTemplate().save(attach);\n      }\n    }\n    catch(PermissionException pe){\n      pe.printStackTrace();\n    }\n    catch(IdUnusedException ie){\n        ie.printStackTrace();\n    }\n    catch(TypeException te){\n        te.printStackTrace();\n    }\n    return attach;\n  }","commit_id":"efbd57ce0606e34b5ba9a44dad7ec4bfbed41d5d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public SectionAttachmentIfc createSectionAttachment(SectionDataIfc section,\n         String resourceId, String filename, String protocol){\n    SectionAttachment attach = null;\n    Boolean isLink = Boolean.FALSE;\n    try{\n      ContentResource cr = ContentHostingService.getResource(resourceId);\n      if (cr !=null){\n        ResourceProperties p = cr.getProperties();\n        attach = new SectionAttachment();\n        attach.setSection(section);\n        attach.setResourceId(resourceId);\n        attach.setFilename(filename);\n\tattach.setMimeType(cr.getContentType());\n        // we want to display kb, so divide by 1000 and round the result\n\tattach.setFileSize(new Long(fileSizeInKB(cr.getContentLength())));\n        if (cr.getContentType().lastIndexOf(\"url\") > -1)\n          isLink = Boolean.TRUE;\n        attach.setIsLink(isLink);\n        attach.setStatus(SectionAttachmentIfc.ACTIVE_STATUS);\n\tattach.setCreatedBy(p.getProperty(p.getNamePropCreator()));\n        attach.setCreatedDate(new Date());\n\tattach.setLastModifiedBy(p.getProperty(p.getNamePropModifiedBy()));\n        attach.setLastModifiedDate(new Date());\n        attach.setLocation(getRelativePath(cr.getUrl(), protocol));\n        //getHibernateTemplate().save(attach);\n      }\n    }\n    catch(PermissionException pe){\n        pe.printStackTrace();\n    }\n    catch(IdUnusedException ie){\n        ie.printStackTrace();\n    }\n    catch(TypeException te){\n        te.printStackTrace();\n    }\n\n    return attach;\n  }","id":22339,"modified_method":"public SectionAttachmentIfc createSectionAttachment(SectionDataIfc section,\n         String resourceId, String filename, String protocol){\n    SectionAttachment attach = null;\n    Boolean isLink = Boolean.FALSE;\n    try{\n      ContentResource cr = ContentHostingService.getResource(resourceId);\n      if (cr !=null){\n        ResourceProperties p = cr.getProperties();\n        attach = new SectionAttachment();\n        attach.setSection(section);\n        attach.setResourceId(resourceId);\n        attach.setMimeType(cr.getContentType());\n        // we want to display kb, so divide by 1000 and round the result\n\t\tattach.setFileSize(new Long(fileSizeInKB(cr.getContentLength())));\n\t\tif (cr.getContentType().lastIndexOf(\"url\") > -1) {\n\t\t\tisLink = Boolean.TRUE;\n\t\t\tif (!filename.toLowerCase().startsWith(\"http\")) {\n\t\t\t\tString adjustedFilename = \"http://\" + filename;\n\t\t\t\tattach.setFilename(adjustedFilename);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattach.setFilename(filename);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tattach.setFilename(filename);\n\t\t}\n\t\tattach.setIsLink(isLink);\n        attach.setStatus(SectionAttachmentIfc.ACTIVE_STATUS);\n\tattach.setCreatedBy(p.getProperty(p.getNamePropCreator()));\n        attach.setCreatedDate(new Date());\n\tattach.setLastModifiedBy(p.getProperty(p.getNamePropModifiedBy()));\n        attach.setLastModifiedDate(new Date());\n        attach.setLocation(getRelativePath(cr.getUrl(), protocol));\n        //getHibernateTemplate().save(attach);\n      }\n    }\n    catch(PermissionException pe){\n        pe.printStackTrace();\n    }\n    catch(IdUnusedException ie){\n        ie.printStackTrace();\n    }\n    catch(TypeException te){\n        te.printStackTrace();\n    }\n\n    return attach;\n  }","commit_id":"efbd57ce0606e34b5ba9a44dad7ec4bfbed41d5d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public AssessmentFacade save(AssessmentSettingsBean assessmentSettings)\n  {\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - set Assessment\n    Long assessmentId = assessmentSettings.getAssessmentId();\n    //log.info(\"**** save assessment assessmentId =\"+assessmentId.toString());\n    ItemAuthorBean iAuthor=new ItemAuthorBean();\n    //System.out.println(\"assessmentSettings.getFeedbackAuthoring: \"+assessmentSettings.getFeedbackAuthoring());\n    iAuthor.setShowFeedbackAuthoring(assessmentSettings.getFeedbackAuthoring());\n    //System.out.println(\"iAuthor.getShowFeedbackAuthoring :\"+iAuthor.getShowFeedbackAuthoring());\n    AssessmentService assessmentService = new AssessmentService();\n    AssessmentFacade assessment = assessmentService.getAssessment(\n        assessmentId.toString());\n    //log.info(\"** assessment = \"+assessment);\n    assessment.setTitle(assessmentSettings.getTitle());\n    assessment.setDescription(assessmentSettings.getDescription());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.AUTHORS, assessmentSettings.getAuthors());\n\n    // #2 - set AssessmentAccessControl\n    AssessmentAccessControl control = (AssessmentAccessControl)assessment.getAssessmentAccessControl();\n    if (control == null){\n      control = new AssessmentAccessControl();\n      // need to fix accessControl so it can take AssessmentFacade later\n      control.setAssessmentBase(assessment.getData());\n    }\n    // a. LATER set dueDate, retractDate, startDate, releaseTo\n    control.setStartDate(assessmentSettings.getStartDate());\n    control.setDueDate(assessmentSettings.getDueDate());\n    control.setRetractDate(assessmentSettings.getRetractDate());\n    control.setFeedbackDate(assessmentSettings.getFeedbackDate());\n    control.setReleaseTo(assessmentSettings.getReleaseTo());\n    //log.info(\"control RELEASETO =\"+control.getReleaseTo());\n    //log.info(\"settings RELEASETO =\"+assessmentSettings.getReleaseTo());\n\n    // b. set Timed Assessment\n    //log.info(\"** Time limit update to = \"+assessmentSettings.getTimeLimit().intValue());\n    control.setTimeLimit(assessmentSettings.getTimeLimit());\n    if (assessmentSettings.getTimedAssessment())\n      control.setTimedAssessment(AssessmentAccessControl.TIMED_ASSESSMENT);\n    else\n      control.setTimedAssessment(AssessmentAccessControl.DO_NOT_TIMED_ASSESSMENT);\n\n    if (assessmentSettings.getAutoSubmit())\n      control.setAutoSubmit(AssessmentAccessControl.AUTO_SUBMIT);\n    else\n      control.setAutoSubmit(AssessmentAccessControl.DO_NOT_AUTO_SUBMIT);\n\n    // c. set Assessment Orgainzation\n    if (assessmentSettings.getItemNavigation()!=null ) {\n    \tString nav = assessmentSettings.getItemNavigation();\n    \tif (nav.equals(\"1\")) {\n    \t\tassessmentSettings.setAssessmentFormat(\"1\");\n    \t}\n    \tcontrol.setItemNavigation(new Integer(nav));\n    }\n    if (assessmentSettings.getItemNumbering()!=null)\n      control.setItemNumbering(new Integer(assessmentSettings.getItemNumbering()));\n    if (assessmentSettings.getAssessmentFormat()!=null )\n     control.setAssessmentFormat(new Integer(assessmentSettings.getAssessmentFormat()));\n\n    // d. set Submissions\n    if (assessmentSettings.getUnlimitedSubmissions()!=null){\n      if (!assessmentSettings.getUnlimitedSubmissions().\n          equals(AssessmentAccessControlIfc.UNLIMITED_SUBMISSIONS.toString())) {\n        control.setUnlimitedSubmissions(Boolean.FALSE);\n        if (assessmentSettings.getSubmissionsAllowed() != null)\n          control.setSubmissionsAllowed(new Integer(assessmentSettings.\n              getSubmissionsAllowed()));\n        else\n          control.setSubmissionsAllowed(new Integer(\"1\"));\n      }\n      else {\n        control.setUnlimitedSubmissions(Boolean.TRUE);\n        control.setSubmissionsAllowed(null);\n      }\n    }\n    //log.info(\"**unlimited submission=\"+assessmentSettings.getUnlimitedSubmissions());\n    //log.info(\"**allowed=\"+control.getSubmissionsAllowed());\n\n    if (assessmentSettings.getLateHandling()!=null){\n      control.setLateHandling(new Integer(assessmentSettings.\n                                                getLateHandling()));\n    }\n    if (assessmentSettings.getSubmissionsSaved()!=null){\n      control.setSubmissionsSaved(new Integer(assessmentSettings.getSubmissionsSaved()));\n    }\n    assessment.setAssessmentAccessControl(control);\n\n    // e. set Submission Messages\n    control.setSubmissionMessage(assessmentSettings.getSubmissionMessage());\n    // f. set username\n    control.setUsername(assessmentSettings.getUsername());\n    // g. set password\n    control.setPassword(assessmentSettings.getPassword());\n    // h. set finalPageUrl\n    control.setFinalPageUrl(assessmentSettings.getFinalPageUrl());\n\n    //#3 Feedback\n    AssessmentFeedback feedback = (AssessmentFeedback)assessment.getAssessmentFeedback();\n    if (feedback == null){\n      feedback = new AssessmentFeedback();\n      // need to fix feeback so it can take AssessmentFacade later\n      feedback.setAssessmentBase(assessment.getData());\n    }\n    if (assessmentSettings.getFeedbackDelivery()!=null)\n     feedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n    if (assessmentSettings.getFeedbackAuthoring()!=null)\n     feedback.setFeedbackAuthoring(new Integer(assessmentSettings.getFeedbackAuthoring()));\n    feedback.setShowQuestionText(Boolean.valueOf(assessmentSettings.getShowQuestionText()));\n    feedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n    feedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n    feedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n    feedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n    feedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n    feedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n    feedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n    feedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n    assessment.setAssessmentFeedback(feedback);\n\n    // g. set Grading\n    EvaluationModel evaluation = (EvaluationModel) assessment.getEvaluationModel();\n    if (evaluation == null){\n      evaluation = new EvaluationModel();\n      // need to fix evaluation so it can take AssessmentFacade later\n      evaluation.setAssessmentBase(assessment.getData());\n    }\n    if (assessmentSettings.getAnonymousGrading()!=null)\n      evaluation.setAnonymousGrading(new Integer(assessmentSettings.getAnonymousGrading()));\n    evaluation.setToGradeBook(assessmentSettings.getToDefaultGradebook());\n    if (assessmentSettings.getScoringType()!=null)\n      evaluation.setScoringType(new Integer(assessmentSettings.getScoringType()));\n    assessment.setEvaluationModel(evaluation);\n\n\n    // h. update ValueMap: it contains value for teh checkboxes in\n    // authorSettings.jsp for: hasAvailableDate, hasDueDate,\n    // hasRetractDate, hasAnonymous, hasAuthenticatedUser, hasIpAddress,\n    // hasUsernamePassword,\n    // hasTimeAssessment,hasAutoSubmit, hasPartMetaData, hasQuestionMetaData\n    HashMap h = assessmentSettings.getValueMap();\n    updateMetaWithValueMap(assessment, h);\n\n    // i. set Graphics\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGCOLOR, assessmentSettings.getBgColor());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGIMAGE, assessmentSettings.getBgImage());\n\n    // j. set objectives,rubrics,keywords\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.KEYWORDS, assessmentSettings.getKeywords());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.OBJECTIVES,assessmentSettings.getObjectives());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.RUBRICS, assessmentSettings.getRubrics());\n\n    // jj. save assessment first, then deal with ip\n    assessmentService.saveAssessment(assessment);\n    assessmentService.deleteAllSecuredIP(assessment);\n\n    // k. set ipAddresses\n   \n    HashSet ipSet = new HashSet();\n    String ipAddresses = assessmentSettings.getIpAddresses();\n    if (ipAddresses == null)\n      ipAddresses = \"\";\n    \n    String[] ip = ipAddresses.split(\"\\\\n\");\n    for (int j=0; j<ip.length;j++){\n      if (ip[j]!=null && !ip[j].equals(\"\\r\")) {\n    \t  \n        ipSet.add(new SecuredIPAddress(assessment.getData(),null,ip[j]));\n      }\n    }\n    assessment.setSecuredIPAddressSet(ipSet);\n\n    // l. FINALLY: save the assessment\n    assessmentService.saveAssessment(assessment);\n\n    // added by daisyf, 10/10/06\n    updateAttachment(assessment.getAssessmentAttachmentList(), assessmentSettings.getAttachmentList(),(AssessmentIfc)assessment.getData());\n    assessment = assessmentService.getAssessment(assessmentId.toString());\n    return assessment;\n  }","id":22340,"modified_method":"public AssessmentFacade save(AssessmentSettingsBean assessmentSettings)\n  {\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - set Assessment\n    Long assessmentId = assessmentSettings.getAssessmentId();\n    //log.info(\"**** save assessment assessmentId =\"+assessmentId.toString());\n    ItemAuthorBean iAuthor=new ItemAuthorBean();\n    //System.out.println(\"assessmentSettings.getFeedbackAuthoring: \"+assessmentSettings.getFeedbackAuthoring());\n    iAuthor.setShowFeedbackAuthoring(assessmentSettings.getFeedbackAuthoring());\n    //System.out.println(\"iAuthor.getShowFeedbackAuthoring :\"+iAuthor.getShowFeedbackAuthoring());\n    AssessmentService assessmentService = new AssessmentService();\n    AssessmentFacade assessment = assessmentService.getAssessment(\n        assessmentId.toString());\n    //log.info(\"** assessment = \"+assessment);\n    assessment.setTitle(assessmentSettings.getTitle());\n    assessment.setDescription(assessmentSettings.getDescription());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.AUTHORS, assessmentSettings.getAuthors());\n\n    // #2 - set AssessmentAccessControl\n    AssessmentAccessControl control = (AssessmentAccessControl)assessment.getAssessmentAccessControl();\n    if (control == null){\n      control = new AssessmentAccessControl();\n      // need to fix accessControl so it can take AssessmentFacade later\n      control.setAssessmentBase(assessment.getData());\n    }\n    // a. LATER set dueDate, retractDate, startDate, releaseTo\n    control.setStartDate(assessmentSettings.getStartDate());\n    control.setDueDate(assessmentSettings.getDueDate());\n    control.setRetractDate(assessmentSettings.getRetractDate());\n    control.setFeedbackDate(assessmentSettings.getFeedbackDate());\n    control.setReleaseTo(assessmentSettings.getReleaseTo());\n    //log.info(\"control RELEASETO =\"+control.getReleaseTo());\n    //log.info(\"settings RELEASETO =\"+assessmentSettings.getReleaseTo());\n\n    // b. set Timed Assessment\n    //log.info(\"** Time limit update to = \"+assessmentSettings.getTimeLimit().intValue());\n    control.setTimeLimit(assessmentSettings.getTimeLimit());\n    if (assessmentSettings.getTimedAssessment())\n      control.setTimedAssessment(AssessmentAccessControl.TIMED_ASSESSMENT);\n    else\n      control.setTimedAssessment(AssessmentAccessControl.DO_NOT_TIMED_ASSESSMENT);\n\n    if (assessmentSettings.getAutoSubmit())\n      control.setAutoSubmit(AssessmentAccessControl.AUTO_SUBMIT);\n    else\n      control.setAutoSubmit(AssessmentAccessControl.DO_NOT_AUTO_SUBMIT);\n\n    // c. set Assessment Orgainzation\n    if (assessmentSettings.getItemNavigation()!=null ) {\n    \tString nav = assessmentSettings.getItemNavigation();\n    \tif (nav.equals(\"1\")) {\n    \t\tassessmentSettings.setAssessmentFormat(\"1\");\n    \t}\n    \tcontrol.setItemNavigation(new Integer(nav));\n    }\n    if (assessmentSettings.getItemNumbering()!=null)\n      control.setItemNumbering(new Integer(assessmentSettings.getItemNumbering()));\n    if (assessmentSettings.getAssessmentFormat()!=null )\n     control.setAssessmentFormat(new Integer(assessmentSettings.getAssessmentFormat()));\n\n    // d. set Submissions\n    if (assessmentSettings.getUnlimitedSubmissions()!=null){\n      if (!assessmentSettings.getUnlimitedSubmissions().\n          equals(AssessmentAccessControlIfc.UNLIMITED_SUBMISSIONS.toString())) {\n        control.setUnlimitedSubmissions(Boolean.FALSE);\n        if (assessmentSettings.getSubmissionsAllowed() != null)\n          control.setSubmissionsAllowed(new Integer(assessmentSettings.\n              getSubmissionsAllowed()));\n        else\n          control.setSubmissionsAllowed(new Integer(\"1\"));\n      }\n      else {\n        control.setUnlimitedSubmissions(Boolean.TRUE);\n        control.setSubmissionsAllowed(null);\n      }\n    }\n    //log.info(\"**unlimited submission=\"+assessmentSettings.getUnlimitedSubmissions());\n    //log.info(\"**allowed=\"+control.getSubmissionsAllowed());\n\n    if (assessmentSettings.getLateHandling()!=null){\n      control.setLateHandling(new Integer(assessmentSettings.\n                                                getLateHandling()));\n    }\n    if (assessmentSettings.getSubmissionsSaved()!=null){\n      control.setSubmissionsSaved(new Integer(assessmentSettings.getSubmissionsSaved()));\n    }\n    assessment.setAssessmentAccessControl(control);\n\n    // e. set Submission Messages\n    control.setSubmissionMessage(assessmentSettings.getSubmissionMessage());\n    // f. set username\n    control.setUsername(assessmentSettings.getUsername());\n    // g. set password\n    control.setPassword(assessmentSettings.getPassword());\n    // h. set finalPageUrl\n    String finalPageUrl = assessmentSettings.getFinalPageUrl();\n    if (!finalPageUrl.toLowerCase().startsWith(\"http\")) {\n    \tfinalPageUrl = \"http://\" + finalPageUrl;\n    }\n    control.setFinalPageUrl(finalPageUrl);\n\n    //#3 Feedback\n    AssessmentFeedback feedback = (AssessmentFeedback)assessment.getAssessmentFeedback();\n    if (feedback == null){\n      feedback = new AssessmentFeedback();\n      // need to fix feeback so it can take AssessmentFacade later\n      feedback.setAssessmentBase(assessment.getData());\n    }\n    if (assessmentSettings.getFeedbackDelivery()!=null)\n     feedback.setFeedbackDelivery(new Integer(assessmentSettings.getFeedbackDelivery()));\n    if (assessmentSettings.getFeedbackAuthoring()!=null)\n     feedback.setFeedbackAuthoring(new Integer(assessmentSettings.getFeedbackAuthoring()));\n    feedback.setShowQuestionText(Boolean.valueOf(assessmentSettings.getShowQuestionText()));\n    feedback.setShowStudentResponse(Boolean.valueOf(assessmentSettings.getShowStudentResponse()));\n    feedback.setShowCorrectResponse(Boolean.valueOf(assessmentSettings.getShowCorrectResponse()));\n    feedback.setShowStudentScore(Boolean.valueOf(assessmentSettings.getShowStudentScore()));\n    feedback.setShowStudentQuestionScore(Boolean.valueOf(assessmentSettings.getShowStudentQuestionScore()));\n    feedback.setShowQuestionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowQuestionLevelFeedback()));\n    feedback.setShowSelectionLevelFeedback(Boolean.valueOf(assessmentSettings.getShowSelectionLevelFeedback()));\n    feedback.setShowGraderComments(Boolean.valueOf(assessmentSettings.getShowGraderComments()));\n    feedback.setShowStatistics(Boolean.valueOf(assessmentSettings.getShowStatistics()));\n    assessment.setAssessmentFeedback(feedback);\n\n    // g. set Grading\n    EvaluationModel evaluation = (EvaluationModel) assessment.getEvaluationModel();\n    if (evaluation == null){\n      evaluation = new EvaluationModel();\n      // need to fix evaluation so it can take AssessmentFacade later\n      evaluation.setAssessmentBase(assessment.getData());\n    }\n    if (assessmentSettings.getAnonymousGrading()!=null)\n      evaluation.setAnonymousGrading(new Integer(assessmentSettings.getAnonymousGrading()));\n    evaluation.setToGradeBook(assessmentSettings.getToDefaultGradebook());\n    if (assessmentSettings.getScoringType()!=null)\n      evaluation.setScoringType(new Integer(assessmentSettings.getScoringType()));\n    assessment.setEvaluationModel(evaluation);\n\n\n    // h. update ValueMap: it contains value for teh checkboxes in\n    // authorSettings.jsp for: hasAvailableDate, hasDueDate,\n    // hasRetractDate, hasAnonymous, hasAuthenticatedUser, hasIpAddress,\n    // hasUsernamePassword,\n    // hasTimeAssessment,hasAutoSubmit, hasPartMetaData, hasQuestionMetaData\n    HashMap h = assessmentSettings.getValueMap();\n    updateMetaWithValueMap(assessment, h);\n\n    // i. set Graphics\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGCOLOR, assessmentSettings.getBgColor());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.BGIMAGE, assessmentSettings.getBgImage());\n\n    // j. set objectives,rubrics,keywords\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.KEYWORDS, assessmentSettings.getKeywords());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.OBJECTIVES,assessmentSettings.getObjectives());\n    assessment.updateAssessmentMetaData(AssessmentMetaDataIfc.RUBRICS, assessmentSettings.getRubrics());\n\n    // jj. save assessment first, then deal with ip\n    assessmentService.saveAssessment(assessment);\n    assessmentService.deleteAllSecuredIP(assessment);\n\n    // k. set ipAddresses\n   \n    HashSet ipSet = new HashSet();\n    String ipAddresses = assessmentSettings.getIpAddresses();\n    if (ipAddresses == null)\n      ipAddresses = \"\";\n    \n    String[] ip = ipAddresses.split(\"\\\\n\");\n    for (int j=0; j<ip.length;j++){\n      if (ip[j]!=null && !ip[j].equals(\"\\r\")) {\n    \t  \n        ipSet.add(new SecuredIPAddress(assessment.getData(),null,ip[j]));\n      }\n    }\n    assessment.setSecuredIPAddressSet(ipSet);\n\n    // l. FINALLY: save the assessment\n    assessmentService.saveAssessment(assessment);\n\n    // added by daisyf, 10/10/06\n    updateAttachment(assessment.getAssessmentAttachmentList(), assessmentSettings.getAttachmentList(),(AssessmentIfc)assessment.getData());\n    assessment = assessmentService.getAssessment(assessmentId.toString());\n    return assessment;\n  }","commit_id":"efbd57ce0606e34b5ba9a44dad7ec4bfbed41d5d","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(CsvInputMeta)smi;\n\t\tdata=(CsvInputData)sdi;\n\n\t\tif (first) {\n\t\t\tfirst=false;\n\t\t\t\n\t\t\tdata.outputRowMeta = new RowMeta();\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\n\t\t\t// The conversion logic for when the lazy conversion is turned of is simple:\n\t\t\t// Pretend it's a lazy conversion object anyway and get the native type during conversion.\n\t\t\t//\n\t\t\tdata.convertRowMeta = data.outputRowMeta.clone();\n\t\t\tfor (ValueMetaInterface valueMeta : data.convertRowMeta.getValueMetaList())\n\t\t\t{\n\t\t\t\tvalueMeta.setStorageType(ValueMetaInterface.STORAGE_TYPE_BINARY_STRING);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tif (meta.isHeaderPresent()) {\n\t\t\t\treadOneRow(false); // skip this row.\n\t\t\t}\n\t\t}\n\t\t\n\t\tObject[] outputRowData=readOneRow(true);    // get row, set busy!\n\t\tif (outputRowData==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tputRow(data.outputRowMeta, outputRowData);     // copy row to possible alternate rowset(s).\n\n        if (checkFeedback(linesInput)) logBasic(Messages.getString(\"CsvInput.Log.LineNumber\", Long.toString(linesInput))); //$NON-NLS-1$\n\t\t\t\n\t\treturn true;\n\t}","id":22341,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(CsvInputMeta)smi;\n\t\tdata=(CsvInputData)sdi;\n\n\t\tif (first) {\n\t\t\tfirst=false;\n\t\t\t\n\t\t\tdata.outputRowMeta = new RowMeta();\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\r\n\t\t\tif (data.filenames==null) {\r\n\t\t\t\t// We're expecting the list of filenames from the previous step(s)...\r\n\t\t\t\t//\r\n\t\t\t\tgetFilenamesFromPreviousSteps();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Open the next file...\r\n\t\t\t//\r\n\t\t\tif (!openNextFile()) {\r\n\t\t\t\tsetOutputDone();\r\n\t\t\t\treturn false; // nothing to see here, move along...\r\n\t\t\t}\r\n\t\t\t\n\t\t\t// The conversion logic for when the lazy conversion is turned of is simple:\n\t\t\t// Pretend it's a lazy conversion object anyway and get the native type during conversion.\n\t\t\t//\n\t\t\tdata.convertRowMeta = data.outputRowMeta.clone();\n\t\t\tfor (ValueMetaInterface valueMeta : data.convertRowMeta.getValueMetaList())\n\t\t\t{\n\t\t\t\tvalueMeta.setStorageType(ValueMetaInterface.STORAGE_TYPE_BINARY_STRING);\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tif (meta.isHeaderPresent()) {\n\t\t\t\treadOneRow(false); // skip this row.\n\t\t\t}\n\t\t}\n\t\t\n\t\tObject[] outputRowData=readOneRow(true);    // get row, set busy!\n\t\tif (outputRowData==null)  // no more input to be expected...\n\t\t{\r\n\t\t\tif (openNextFile()) {\r\n\t\t\t\treturn true; // try again on the next loop...\r\n\t\t\t}\r\n\t\t\telse {\n\t\t\t\tsetOutputDone(); // last file, end here\r\n\t\t\t\treturn false;\r\n\t\t\t}\n\t\t}\n\t\telse \r\n\t\t{\n\t\t\tputRow(data.outputRowMeta, outputRowData);     // copy row to possible alternate rowset(s).\n\t        if (checkFeedback(linesInput)) logBasic(Messages.getString(\"CsvInput.Log.LineNumber\", Long.toString(linesInput))); //$NON-NLS-1$\r\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(CsvInputMeta)smi;\n\t\tdata=(CsvInputData)sdi;\n\t\t\n\t\tif (super.init(smi, sdi)) {\n\t\t\ttry {\n\t\t\t\tdata.preferredBufferSize = Integer.parseInt(environmentSubstitute(meta.getBufferSize()));\n\t\t\t\tdata.filename = environmentSubstitute(meta.getFilename());\n\t\t\t\t\r\n\t\t\t\tif (Const.isEmpty(data.filename)) {\r\n\t\t\t\t\tlogError(Messages.getString(\"CsvInput.MissingFilename.Message\"));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\n\t\t\t\tFileObject fileObject = KettleVFS.getFileObject(data.filename);\n\t\t\t\tif (!(fileObject instanceof LocalFile)) {\n\t\t\t\t\t// We can only use NIO on local files at the moment, so that's what we limit ourselves to.\n\t\t\t\t\t//\n\t\t\t\t\tlogError(Messages.getString(\"CsvInput.Log.OnlyLocalFilesAreSupported\"));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tFileInputStream fis = (FileInputStream)((LocalFile)fileObject).getInputStream();\n\t\t\t\tdata.fc = fis.getChannel();\n\t\t\t\tdata.bb = ByteBuffer.allocateDirect( data.preferredBufferSize );\n\t\t\t\t\n\t\t\t\tdata.delimiter = environmentSubstitute(meta.getDelimiter()).getBytes();\n\n\t\t\t\tif( Const.isEmpty(meta.getEnclosure()) ) {\n\t\t\t\t\tdata.enclosure = null;\r\n\t\t\t\t} else {\n\t\t\t\t\tdata.enclosure = environmentSubstitute(meta.getEnclosure()).getBytes();\r\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogError(\"Error opening file '\"+meta.getFilename()+\"' : \"+e.toString());\n\t\t\t\tlogError(Const.getStackTracker(e));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":22342,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(CsvInputMeta)smi;\n\t\tdata=(CsvInputData)sdi;\n\t\t\n\t\tif (super.init(smi, sdi)) {\n\t\t\tdata.preferredBufferSize = Integer.parseInt(environmentSubstitute(meta.getBufferSize()));\r\n\t\t\t\r\n\t\t\t// If the step doesn't have any previous steps, we just get the filename.\r\n\t\t\t// Otherwise, we'll grab the list of filenames later...\r\n\t\t\t//\r\n\t\t\tif (getTransMeta().findNrPrevSteps(getStepMeta())==0) {\r\n\t\t\t\tString filename = environmentSubstitute(meta.getFilename());\n\r\n\t\t\t\tif (Const.isEmpty(filename)) {\r\n\t\t\t\t\tlogError(Messages.getString(\"CsvInput.MissingFilename.Message\"));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.filenames = new String[] { filename, };\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdata.filenames = null;\r\n\t\t\t\tdata.filenr = 0;\n\t\t\t}\r\n\t\t\t\t\t\t\t\n\t\t\tdata.delimiter = environmentSubstitute(meta.getDelimiter()).getBytes();\n\n\t\t\tif( Const.isEmpty(meta.getEnclosure()) ) {\n\t\t\t\tdata.enclosure = null;\r\n\t\t\t} else {\n\t\t\t\tdata.enclosure = environmentSubstitute(meta.getEnclosure()).getBytes();\r\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\n\t\t}\n\t\treturn false;\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(CsvInputMeta inputMeta) {\n\t\t\n\t\tinputMeta.setFilename(wFilename.getText());\n\t\tinputMeta.setDelimiter(wDelimiter.getText());\n\t\tinputMeta.setEnclosure(wEnclosure.getText());\n\t\tinputMeta.setBufferSize(wBufferSize.getText());\n\t\tinputMeta.setLazyConversionActive(wLazyConversion.getSelection());\n\t\tinputMeta.setHeaderPresent(wHeaderPresent.getSelection());\n\n    \tint nrNonEmptyFields = wFields.nrNonEmpty(); \n    \tinputMeta.allocate(nrNonEmptyFields);\n\n\t\tfor (int i=0;i<nrNonEmptyFields;i++) {\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tinputMeta.getInputFields()[i] = new TextFileInputField();\n\t\t\t\n\t\t\tint colnr=1;\n\t\t\tinputMeta.getInputFields()[i].setName( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setType( ValueMeta.getType( item.getText(colnr++) ) );\n\t\t\tinputMeta.getInputFields()[i].setFormat( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setLength( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setPrecision( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setCurrencySymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setDecimalSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setGroupSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setTrimType(ValueMeta.getTrimTypeByDesc( item.getText(colnr++) ));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\tinputMeta.setChanged();\n\t}","id":22343,"modified_method":"private void getInfo(CsvInputMeta inputMeta) {\n\t\t\r\n\t\tif (isReceivingInput) {\r\n\t\t\tinputMeta.setFilenameField(wFilename.getText());\r\n\t\t} else {\r\n\t\t\tinputMeta.setFilename(wFilename.getText());\r\n\t\t}\r\n\t\t\n\t\tinputMeta.setDelimiter(wDelimiter.getText());\n\t\tinputMeta.setEnclosure(wEnclosure.getText());\n\t\tinputMeta.setBufferSize(wBufferSize.getText());\n\t\tinputMeta.setLazyConversionActive(wLazyConversion.getSelection());\n\t\tinputMeta.setHeaderPresent(wHeaderPresent.getSelection());\n\n    \tint nrNonEmptyFields = wFields.nrNonEmpty(); \n    \tinputMeta.allocate(nrNonEmptyFields);\n\n\t\tfor (int i=0;i<nrNonEmptyFields;i++) {\n\t\t\tTableItem item = wFields.getNonEmpty(i);\n\t\t\tinputMeta.getInputFields()[i] = new TextFileInputField();\n\t\t\t\n\t\t\tint colnr=1;\n\t\t\tinputMeta.getInputFields()[i].setName( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setType( ValueMeta.getType( item.getText(colnr++) ) );\n\t\t\tinputMeta.getInputFields()[i].setFormat( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setLength( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setPrecision( Const.toInt(item.getText(colnr++), -1) );\n\t\t\tinputMeta.getInputFields()[i].setCurrencySymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setDecimalSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setGroupSymbol( item.getText(colnr++) );\n\t\t\tinputMeta.getInputFields()[i].setTrimType(ValueMeta.getTrimTypeByDesc( item.getText(colnr++) ));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\tinputMeta.setChanged();\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, inputMeta);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinputMeta.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = inputMeta.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"CsvInputDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Step name line\n\t\t//\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"CsvInputDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\t\tControl lastControl = wStepname;\n\t\t\n\t\t// Filename...\n\t\t//\n\t\t// The filename browse button\n\t\t//\n        wbbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n        props.setLook(wbbFilename);\n        wbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n        wbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n        FormData fdbFilename = new FormData();\n        fdbFilename.top  = new FormAttachment(lastControl, margin);\n        fdbFilename.right= new FormAttachment(100, 0);\n        wbbFilename.setLayoutData(fdbFilename);\n\n        // The field itself...\n        //\n\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.Filename.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlFilename);\n\t\tFormData fdlFilename = new FormData();\n\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\t\twFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tFormData fdFilename = new FormData();\n\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\t\tlastControl = wFilename;\n\t\t\n\t\t// delimiter\n\t\tLabel wlDelimiter = new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tFormData fdlDelimiter = new FormData();\n\t\tfdlDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\r\n\t\twbDelimiter=new Button(shell, SWT.PUSH| SWT.CENTER);\r\n        props.setLook(wbDelimiter);\r\n        wbDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Button\"));\r\n        FormData fdbDelimiter=new FormData();\r\n        fdbDelimiter.top  = new FormAttachment(lastControl, margin);\r\n        fdbDelimiter.left = new FormAttachment(wbbFilename, 0, SWT.LEFT);\r\n        fdbDelimiter.right= new FormAttachment(100, 0);        \r\n        wbDelimiter.setLayoutData(fdbDelimiter);\n\t\twDelimiter=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tFormData fdDelimiter = new FormData();\n\t\tfdDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.right= new FormAttachment(wbDelimiter, -margin);\n\t\twDelimiter.setLayoutData(fdDelimiter);\t\t\r\n        lastControl = wDelimiter;\r\n\t\t\n\t\t// enclosure\n\t\tLabel wlEnclosure = new Label(shell, SWT.RIGHT);\n\t\twlEnclosure.setText(Messages.getString(\"CsvInputDialog.Enclosure.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlEnclosure);\n\t\tFormData fdlEnclosure = new FormData();\n\t\tfdlEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdlEnclosure.left = new FormAttachment(0, 0);\n\t\tfdlEnclosure.right= new FormAttachment(middle, -margin);\n\t\twlEnclosure.setLayoutData(fdlEnclosure);\n\t\twEnclosure=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wEnclosure);\n\t\twEnclosure.addModifyListener(lsMod);\n\t\tFormData fdEnclosure = new FormData();\n\t\tfdEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdEnclosure.left = new FormAttachment(middle, 0);\n\t\tfdEnclosure.right= new FormAttachment(100, 0);\n\t\twEnclosure.setLayoutData(fdEnclosure);\n\t\tlastControl = wEnclosure;\n\n\t\t// bufferSize\n\t\t//\n\t\tLabel wlBufferSize = new Label(shell, SWT.RIGHT);\n\t\twlBufferSize.setText(Messages.getString(\"CsvInputDialog.BufferSize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlBufferSize);\n\t\tFormData fdlBufferSize = new FormData();\n\t\tfdlBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdlBufferSize.left = new FormAttachment(0, 0);\n\t\tfdlBufferSize.right= new FormAttachment(middle, -margin);\n\t\twlBufferSize.setLayoutData(fdlBufferSize);\n\t\twBufferSize = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wBufferSize);\n\t\twBufferSize.addModifyListener(lsMod);\n\t\tFormData fdBufferSize = new FormData();\n\t\tfdBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdBufferSize.left = new FormAttachment(middle, 0);\n\t\tfdBufferSize.right= new FormAttachment(100, 0);\n\t\twBufferSize.setLayoutData(fdBufferSize);\n\t\tlastControl = wBufferSize;\n\t\t\n\t\t// performingLazyConversion?\n\t\t//\n\t\tLabel wlLazyConversion = new Label(shell, SWT.RIGHT);\n\t\twlLazyConversion.setText(Messages.getString(\"CsvInputDialog.LazyConversion.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlLazyConversion);\n\t\tFormData fdlLazyConversion = new FormData();\n\t\tfdlLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdlLazyConversion.left = new FormAttachment(0, 0);\n\t\tfdlLazyConversion.right= new FormAttachment(middle, -margin);\n\t\twlLazyConversion.setLayoutData(fdlLazyConversion);\n\t\twLazyConversion = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wLazyConversion);\n\t\tFormData fdLazyConversion = new FormData();\n\t\tfdLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdLazyConversion.left = new FormAttachment(middle, 0);\n\t\tfdLazyConversion.right= new FormAttachment(100, 0);\n\t\twLazyConversion.setLayoutData(fdLazyConversion);\n\t\tlastControl = wLazyConversion;\n\n\t\t// header row?\n\t\t//\n\t\tLabel wlHeaderPresent = new Label(shell, SWT.RIGHT);\n\t\twlHeaderPresent.setText(Messages.getString(\"CsvInputDialog.HeaderPresent.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHeaderPresent);\n\t\tFormData fdlHeaderPresent = new FormData();\n\t\tfdlHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdlHeaderPresent.left = new FormAttachment(0, 0);\n\t\tfdlHeaderPresent.right= new FormAttachment(middle, -margin);\n\t\twlHeaderPresent.setLayoutData(fdlHeaderPresent);\n\t\twHeaderPresent = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wHeaderPresent);\n\t\tFormData fdHeaderPresent = new FormData();\n\t\tfdHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdHeaderPresent.left = new FormAttachment(middle, 0);\n\t\tfdHeaderPresent.right= new FormAttachment(100, 0);\n\t\twHeaderPresent.setLayoutData(fdHeaderPresent);\n\t\tlastControl = wHeaderPresent;\n\n\t\t// Some buttons first, so that the dialog scales nicely...\n\t\t//\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"System.Button.Preview\")); //$NON-NLS-1$\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"System.Button.GetFields\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel, wPreview, wGet, }, margin, null);\n\n\n\t\t// Fields\n        ColumnInfo[] colinf=new ColumnInfo[]\n            {\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.NameColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.getTypes(), true ),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO,  Const.getConversionFormats()),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.LengthColumn.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.PrecisionColumn.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.CurrencyColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.DecimalColumn.Column\"),    ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.GroupColumn.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TrimTypeColumn.Column\"),   ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.trimTypeDesc),\n            };\n        \n        colinf[2].setComboValuesSelectionListener(new ComboValuesSelectionListener() {\n    \t\t\n\t\t\tpublic String[] getComboValues(TableItem tableItem, int rowNr, int colNr) {\n\t\t\t\tString[] comboValues = new String[] { };\n\t\t\t\tint type = ValueMeta.getType( tableItem.getText(colNr-1) );\n\t\t\t\tswitch(type) {\n\t\t\t\tcase ValueMetaInterface.TYPE_DATE: comboValues = Const.getDateFormats(); break;\n\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER: \n\t\t\t\tcase ValueMetaInterface.TYPE_BIGNUMBER:\n\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER: comboValues = Const.getNumberFormats(); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\treturn comboValues;\n\t\t\t}\n\t\t\n\t\t});\n\n        \n        wFields=new TableView(transMeta, shell, \n                              SWT.FULL_SELECTION | SWT.MULTI, \n                              colinf, \n                              1,  \n                              lsMod,\n                              props\n                              );\n\n        FormData fdFields = new FormData();\n        fdFields.top   = new FormAttachment(lastControl, margin*2);\n        fdFields.bottom= new FormAttachment(wOK, -margin*2);\n        fdFields.left  = new FormAttachment(0, 0);\n        fdFields.right = new FormAttachment(100, 0);\n        wFields.setLayoutData(fdFields);\n        \n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview(); } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { getCSV(); } };\n\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twGet.addListener    (SWT.Selection, lsGet    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twFilename.addSelectionListener( lsDef );\n\t\twDelimiter.addSelectionListener( lsDef );\n\t\twEnclosure.addSelectionListener( lsDef );\n\t\twBufferSize.addSelectionListener( lsDef );\n\t\t\r\n\t\t// Allow the insertion of tabs as separator...\r\n\t\twbDelimiter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t\t{\r\n\t\t\t\t\tText t = wDelimiter.getTextWidget();\r\n\t\t\t\t\tif ( t != null )\r\n\t\t\t\t\t    t.insert(\"\\t\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\n\t\t// Listen to the browse button next to the file name\n\t\twbbFilename.addSelectionListener(\n\t\t\t\tnew SelectionAdapter()\n\t\t\t\t{\n\t\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t\t{\n\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.txt;*.csv\", \"*.csv\", \"*.txt\", \"*\"});\n\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString fname = transMeta.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"System.FileType.CSVFiles\")+\", \"+Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.CSVFiles\"), Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinputMeta.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":22344,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, inputMeta);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinputMeta.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = inputMeta.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"CsvInputDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Step name line\n\t\t//\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"CsvInputDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\t\tControl lastControl = wStepname;\n\t\t\r\n\t\t\r\n\t\t// See if the step receives input.  If so, we don't ask for the filename, but for the filename field.\r\n\t\t//\r\n\t\tisReceivingInput = transMeta.findNrPrevSteps(stepMeta)>0;\r\n\t\tif (isReceivingInput) {\r\n\t\t\t\r\n\t\t\t// The filename field ...\r\n\t\t\t//\r\n\t\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\r\n\t\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.FilenameField.Label\")); //$NON-NLS-1$\r\n\t \t\tprops.setLook(wlFilename);\r\n\t\t\tFormData fdlFilename = new FormData();\r\n\t\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\t\twlFilename.setLayoutData(fdlFilename);\r\n\t\t\twFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t \t\tprops.setLook(wFilename);\r\n\t\t\twFilename.addModifyListener(lsMod);\r\n\t\t\tFormData fdFilename = new FormData();\r\n\t\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\r\n\t\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\t\tfdFilename.right= new FormAttachment(100, 0);\r\n\t\t\twFilename.setLayoutData(fdFilename);\r\n\t\t\tlastControl = wFilename;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t\r\n\t\t\t// Filename...\n\t\t\t//\n\t\t\t// The filename browse button\n\t\t\t//\n\t        wbbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n\t        props.setLook(wbbFilename);\n\t        wbbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t        wbbFilename.setToolTipText(Messages.getString(\"System.Tooltip.BrowseForFileOrDirAndAdd\"));\n\t        FormData fdbFilename = new FormData();\n\t        fdbFilename.top  = new FormAttachment(lastControl, margin);\n\t        fdbFilename.right= new FormAttachment(100, 0);\n\t        wbbFilename.setLayoutData(fdbFilename);\n\t\n\t        // The field itself...\n\t        //\n\t\t\tLabel wlFilename = new Label(shell, SWT.RIGHT);\n\t\t\twlFilename.setText(Messages.getString(\"CsvInputDialog.Filename.Label\")); //$NON-NLS-1$\n\t \t\tprops.setLook(wlFilename);\n\t\t\tFormData fdlFilename = new FormData();\n\t\t\tfdlFilename.top  = new FormAttachment(lastControl, margin);\n\t\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\t\twlFilename.setLayoutData(fdlFilename);\n\t\t\twFilename=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t \t\tprops.setLook(wFilename);\n\t\t\twFilename.addModifyListener(lsMod);\n\t\t\tFormData fdFilename = new FormData();\n\t\t\tfdFilename.top  = new FormAttachment(lastControl, margin);\n\t\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\t\tfdFilename.right= new FormAttachment(wbbFilename, -margin);\n\t\t\twFilename.setLayoutData(fdFilename);\n\t\t\tlastControl = wFilename;\r\n\t\t}\n\t\t\n\t\t// delimiter\n\t\tLabel wlDelimiter = new Label(shell, SWT.RIGHT);\n\t\twlDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlDelimiter);\n\t\tFormData fdlDelimiter = new FormData();\n\t\tfdlDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdlDelimiter.left = new FormAttachment(0, 0);\n\t\tfdlDelimiter.right= new FormAttachment(middle, -margin);\n\t\twlDelimiter.setLayoutData(fdlDelimiter);\r\n\t\twbDelimiter=new Button(shell, SWT.PUSH| SWT.CENTER);\r\n        props.setLook(wbDelimiter);\r\n        wbDelimiter.setText(Messages.getString(\"CsvInputDialog.Delimiter.Button\"));\r\n        FormData fdbDelimiter=new FormData();\r\n        fdbDelimiter.top  = new FormAttachment(lastControl, margin);\r\n        fdbDelimiter.right= new FormAttachment(100, 0);        \r\n        wbDelimiter.setLayoutData(fdbDelimiter);\n\t\twDelimiter=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wDelimiter);\n\t\twDelimiter.addModifyListener(lsMod);\n\t\tFormData fdDelimiter = new FormData();\n\t\tfdDelimiter.top  = new FormAttachment(lastControl, margin);\n\t\tfdDelimiter.left = new FormAttachment(middle, 0);\n\t\tfdDelimiter.right= new FormAttachment(wbDelimiter, -margin);\n\t\twDelimiter.setLayoutData(fdDelimiter);\t\t\r\n        lastControl = wDelimiter;\r\n\t\t\n\t\t// enclosure\n\t\tLabel wlEnclosure = new Label(shell, SWT.RIGHT);\n\t\twlEnclosure.setText(Messages.getString(\"CsvInputDialog.Enclosure.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlEnclosure);\n\t\tFormData fdlEnclosure = new FormData();\n\t\tfdlEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdlEnclosure.left = new FormAttachment(0, 0);\n\t\tfdlEnclosure.right= new FormAttachment(middle, -margin);\n\t\twlEnclosure.setLayoutData(fdlEnclosure);\n\t\twEnclosure=new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wEnclosure);\n\t\twEnclosure.addModifyListener(lsMod);\n\t\tFormData fdEnclosure = new FormData();\n\t\tfdEnclosure.top  = new FormAttachment(lastControl, margin);\n\t\tfdEnclosure.left = new FormAttachment(middle, 0);\n\t\tfdEnclosure.right= new FormAttachment(100, 0);\n\t\twEnclosure.setLayoutData(fdEnclosure);\n\t\tlastControl = wEnclosure;\n\n\t\t// bufferSize\n\t\t//\n\t\tLabel wlBufferSize = new Label(shell, SWT.RIGHT);\n\t\twlBufferSize.setText(Messages.getString(\"CsvInputDialog.BufferSize.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlBufferSize);\n\t\tFormData fdlBufferSize = new FormData();\n\t\tfdlBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdlBufferSize.left = new FormAttachment(0, 0);\n\t\tfdlBufferSize.right= new FormAttachment(middle, -margin);\n\t\twlBufferSize.setLayoutData(fdlBufferSize);\n\t\twBufferSize = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wBufferSize);\n\t\twBufferSize.addModifyListener(lsMod);\n\t\tFormData fdBufferSize = new FormData();\n\t\tfdBufferSize.top  = new FormAttachment(lastControl, margin);\n\t\tfdBufferSize.left = new FormAttachment(middle, 0);\n\t\tfdBufferSize.right= new FormAttachment(100, 0);\n\t\twBufferSize.setLayoutData(fdBufferSize);\n\t\tlastControl = wBufferSize;\n\t\t\n\t\t// performingLazyConversion?\n\t\t//\n\t\tLabel wlLazyConversion = new Label(shell, SWT.RIGHT);\n\t\twlLazyConversion.setText(Messages.getString(\"CsvInputDialog.LazyConversion.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlLazyConversion);\n\t\tFormData fdlLazyConversion = new FormData();\n\t\tfdlLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdlLazyConversion.left = new FormAttachment(0, 0);\n\t\tfdlLazyConversion.right= new FormAttachment(middle, -margin);\n\t\twlLazyConversion.setLayoutData(fdlLazyConversion);\n\t\twLazyConversion = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wLazyConversion);\n\t\tFormData fdLazyConversion = new FormData();\n\t\tfdLazyConversion.top  = new FormAttachment(lastControl, margin);\n\t\tfdLazyConversion.left = new FormAttachment(middle, 0);\n\t\tfdLazyConversion.right= new FormAttachment(100, 0);\n\t\twLazyConversion.setLayoutData(fdLazyConversion);\n\t\tlastControl = wLazyConversion;\n\n\t\t// header row?\n\t\t//\n\t\tLabel wlHeaderPresent = new Label(shell, SWT.RIGHT);\n\t\twlHeaderPresent.setText(Messages.getString(\"CsvInputDialog.HeaderPresent.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlHeaderPresent);\n\t\tFormData fdlHeaderPresent = new FormData();\n\t\tfdlHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdlHeaderPresent.left = new FormAttachment(0, 0);\n\t\tfdlHeaderPresent.right= new FormAttachment(middle, -margin);\n\t\twlHeaderPresent.setLayoutData(fdlHeaderPresent);\n\t\twHeaderPresent = new Button(shell, SWT.CHECK);\n \t\tprops.setLook(wHeaderPresent);\n\t\tFormData fdHeaderPresent = new FormData();\n\t\tfdHeaderPresent.top  = new FormAttachment(lastControl, margin);\n\t\tfdHeaderPresent.left = new FormAttachment(middle, 0);\n\t\tfdHeaderPresent.right= new FormAttachment(100, 0);\n\t\twHeaderPresent.setLayoutData(fdHeaderPresent);\n\t\tlastControl = wHeaderPresent;\n\n\t\t// Some buttons first, so that the dialog scales nicely...\n\t\t//\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\t\twPreview=new Button(shell, SWT.PUSH);\n\t\twPreview.setText(Messages.getString(\"System.Button.Preview\")); //$NON-NLS-1$\n\t\twPreview.setEnabled(!isReceivingInput);\r\n\t\twGet=new Button(shell, SWT.PUSH);\n\t\twGet.setText(Messages.getString(\"System.Button.GetFields\")); //$NON-NLS-1$\r\n\t\twGet.setEnabled(!isReceivingInput);\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel, wPreview, wGet, }, margin, null);\n\n\n\t\t// Fields\n        ColumnInfo[] colinf=new ColumnInfo[]\n            {\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.NameColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.getTypes(), true ),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO,  Const.getConversionFormats()),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.LengthColumn.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.PrecisionColumn.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.CurrencyColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.DecimalColumn.Column\"),    ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.GroupColumn.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,    false),\n             new ColumnInfo(Messages.getString(\"CsvInputDialog.TrimTypeColumn.Column\"),   ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.trimTypeDesc),\n            };\n        \n        colinf[2].setComboValuesSelectionListener(new ComboValuesSelectionListener() {\n    \t\t\n\t\t\tpublic String[] getComboValues(TableItem tableItem, int rowNr, int colNr) {\n\t\t\t\tString[] comboValues = new String[] { };\n\t\t\t\tint type = ValueMeta.getType( tableItem.getText(colNr-1) );\n\t\t\t\tswitch(type) {\n\t\t\t\tcase ValueMetaInterface.TYPE_DATE: comboValues = Const.getDateFormats(); break;\n\t\t\t\tcase ValueMetaInterface.TYPE_INTEGER: \n\t\t\t\tcase ValueMetaInterface.TYPE_BIGNUMBER:\n\t\t\t\tcase ValueMetaInterface.TYPE_NUMBER: comboValues = Const.getNumberFormats(); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\treturn comboValues;\n\t\t\t}\n\t\t\n\t\t});\n\n        \n        wFields=new TableView(transMeta, shell, \n                              SWT.FULL_SELECTION | SWT.MULTI, \n                              colinf, \n                              1,  \n                              lsMod,\n                              props\n                              );\n\n        FormData fdFields = new FormData();\n        fdFields.top   = new FormAttachment(lastControl, margin*2);\n        fdFields.bottom= new FormAttachment(wOK, -margin*2);\n        fdFields.left  = new FormAttachment(0, 0);\n        fdFields.right = new FormAttachment(100, 0);\n        wFields.setLayoutData(fdFields);\n        \n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\tlsPreview  = new Listener() { public void handleEvent(Event e) { preview(); } };\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { getCSV(); } };\n\n\t\twCancel.addListener (SWT.Selection, lsCancel );\n\t\twOK.addListener     (SWT.Selection, lsOK     );\n\t\twPreview.addListener(SWT.Selection, lsPreview);\n\t\twGet.addListener    (SWT.Selection, lsGet    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\twFilename.addSelectionListener( lsDef );\n\t\twDelimiter.addSelectionListener( lsDef );\n\t\twEnclosure.addSelectionListener( lsDef );\n\t\twBufferSize.addSelectionListener( lsDef );\n\t\t\r\n\t\t// Allow the insertion of tabs as separator...\r\n\t\twbDelimiter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t\t{\r\n\t\t\t\t\tText t = wDelimiter.getTextWidget();\r\n\t\t\t\t\tif ( t != null )\r\n\t\t\t\t\t    t.insert(\"\\t\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif (wbbFilename!=null) {\n\t\t\t// Listen to the browse button next to the file name\n\t\t\twbbFilename.addSelectionListener(\n\t\t\t\t\tnew SelectionAdapter()\n\t\t\t\t\t{\n\t\t\t\t\t\tpublic void widgetSelected(SelectionEvent e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.txt;*.csv\", \"*.csv\", \"*.txt\", \"*\"});\n\t\t\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString fname = transMeta.environmentSubstitute(wFilename.getText());\n\t\t\t\t\t\t\t\tdialog.setFileName( fname );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"System.FileType.CSVFiles\")+\", \"+Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.CSVFiles\"), Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString str = dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName();\n\t\t\t\t\t\t\t\twFilename.setText(str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\r\n\t\t}\n\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinputMeta.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData(CsvInputMeta inputMeta)\n\t{\n\t\twStepname.setText(stepname);\n\t\twFilename.setText(Const.NVL(inputMeta.getFilename(), \"\"));\n\t\twDelimiter.setText(Const.NVL(inputMeta.getDelimiter(), \"\"));\n\t\twEnclosure.setText(Const.NVL(inputMeta.getEnclosure(), \"\"));\n\t\twBufferSize.setText(Const.NVL(inputMeta.getBufferSize(), \"\"));\n\t\twLazyConversion.setSelection(inputMeta.isLazyConversionActive());\n\t\twHeaderPresent.setSelection(inputMeta.isHeaderPresent());\n\n\t\tfor (int i=0;i<inputMeta.getInputFields().length;i++) {\n\t\t\tTextFileInputField field = inputMeta.getInputFields()[i];\n\t\t\t\n\t\t\tTableItem item = new TableItem(wFields.table, SWT.NONE);\n\t\t\tint colnr=1;\n\t\t\titem.setText(colnr++, Const.NVL(field.getName(), \"\"));\n\t\t\titem.setText(colnr++, ValueMeta.getTypeDesc(field.getType()));\n\t\t\titem.setText(colnr++, Const.NVL(field.getFormat(), \"\"));\n\t\t\titem.setText(colnr++, field.getLength()>=0?Integer.toString(field.getLength()):\"\") ;\n\t\t\titem.setText(colnr++, field.getPrecision()>=0?Integer.toString(field.getPrecision()):\"\") ;\n\t\t\titem.setText(colnr++, Const.NVL(field.getCurrencySymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getDecimalSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getGroupSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getTrimTypeDesc(), \"\"));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\twStepname.selectAll();\n\t}","id":22345,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData(CsvInputMeta inputMeta)\n\t{\n\t\twStepname.setText(stepname);\r\n\t\tif (isReceivingInput) {\n\t\t\twFilename.setText(Const.NVL(inputMeta.getFilenameField(), \"\"));\r\n\t\t} else {\r\n\t\t\twFilename.setText(Const.NVL(inputMeta.getFilename(), \"\"));\r\n\t\t}\n\t\twDelimiter.setText(Const.NVL(inputMeta.getDelimiter(), \"\"));\n\t\twEnclosure.setText(Const.NVL(inputMeta.getEnclosure(), \"\"));\n\t\twBufferSize.setText(Const.NVL(inputMeta.getBufferSize(), \"\"));\n\t\twLazyConversion.setSelection(inputMeta.isLazyConversionActive());\n\t\twHeaderPresent.setSelection(inputMeta.isHeaderPresent());\n\n\t\tfor (int i=0;i<inputMeta.getInputFields().length;i++) {\n\t\t\tTextFileInputField field = inputMeta.getInputFields()[i];\n\t\t\t\n\t\t\tTableItem item = new TableItem(wFields.table, SWT.NONE);\n\t\t\tint colnr=1;\n\t\t\titem.setText(colnr++, Const.NVL(field.getName(), \"\"));\n\t\t\titem.setText(colnr++, ValueMeta.getTypeDesc(field.getType()));\n\t\t\titem.setText(colnr++, Const.NVL(field.getFormat(), \"\"));\n\t\t\titem.setText(colnr++, field.getLength()>=0?Integer.toString(field.getLength()):\"\") ;\n\t\t\titem.setText(colnr++, field.getPrecision()>=0?Integer.toString(field.getPrecision()):\"\") ;\n\t\t\titem.setText(colnr++, Const.NVL(field.getCurrencySymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getDecimalSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getGroupSymbol(), \"\"));\n\t\t\titem.setText(colnr++, Const.NVL(field.getTrimTypeDesc(), \"\"));\n\t\t}\n\t\twFields.removeEmptyRows();\n\t\twFields.setRowNums();\n\t\twFields.optWidth(true);\n\t\t\n\t\twStepname.selectAll();\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename\", filename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\", delimiter);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\", enclosure);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"buffer_size\", bufferSize);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\", headerPresent);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"lazy_conversion\", lazyConversionActive);\n\n\t\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t\t{\n\t\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\t\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\", field.getName());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\", ValueMeta.getTypeDesc(field.getType()));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\", field.getFormat());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\", field.getCurrencySymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\", field.getDecimalSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\", field.getGroupSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\", field.getLength());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", ValueMeta.getTrimTypeCode( field.getTrimType()));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\" + id_step, e);\n\t\t}\n\t}","id":22346,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename\", filename);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"filename_field\", filenameField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\", delimiter);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\", enclosure);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"buffer_size\", bufferSize);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\", headerPresent);\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"lazy_conversion\", lazyConversionActive);\n\n\t\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t\t{\n\t\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\t\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\", field.getName());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\", ValueMeta.getTypeDesc(field.getType()));\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\", field.getFormat());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\", field.getCurrencySymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\", field.getDecimalSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\", field.getGroupSymbol());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\", field.getLength());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", ValueMeta.getTrimTypeCode( field.getTrimType()));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\" + id_step, e);\n\t\t}\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = XMLHandler.getTagValue(stepnode, \"filename\");\n\t\t\tdelimiter = XMLHandler.getTagValue(stepnode, \"separator\");\n\t\t\tenclosure = XMLHandler.getTagValue(stepnode, \"enclosure\");\n\t\t\tbufferSize  = XMLHandler.getTagValue(stepnode, \"buffer_size\");\n\t\t\theaderPresent = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\n\t\t\tlazyConversionActive= \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"lazy_conversion\"));\n\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\n\t\t\t\tinputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\n\t\t\t\tinputFields[i].setType(  ValueMeta.getType(XMLHandler.getTagValue(fnode, \"type\")) );\n\t\t\t\tinputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( XMLHandler.getTagValue(fnode, \"group\") );\n\t\t\t\tinputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\n\t\t\t\tinputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( XMLHandler.getTagValue(fnode, \"trim_type\") ) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","id":22347,"modified_method":"private void readData(Node stepnode) throws KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = XMLHandler.getTagValue(stepnode, \"filename\");\n\t\t\tfilenameField = XMLHandler.getTagValue(stepnode, \"filename_field\");\r\n\t\t\tdelimiter = XMLHandler.getTagValue(stepnode, \"separator\");\n\t\t\tenclosure = XMLHandler.getTagValue(stepnode, \"enclosure\");\n\t\t\tbufferSize  = XMLHandler.getTagValue(stepnode, \"buffer_size\");\n\t\t\theaderPresent = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\n\t\t\tlazyConversionActive= \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"lazy_conversion\"));\n\n\t\t\tNode fields = XMLHandler.getSubNode(stepnode, \"fields\");\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\n\t\t\t\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\n\n\t\t\t\tinputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\n\t\t\t\tinputFields[i].setType(  ValueMeta.getType(XMLHandler.getTagValue(fnode, \"type\")) );\n\t\t\t\tinputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( XMLHandler.getTagValue(fnode, \"group\") );\n\t\t\t\tinputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\n\t\t\t\tinputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( XMLHandler.getTagValue(fnode, \"trim_type\") ) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\n\t\t}\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = rep.getStepAttributeString(id_step, \"filename\");\n\t\t\tdelimiter = rep.getStepAttributeString(id_step, \"separator\");\n\t\t\tenclosure = rep.getStepAttributeString(id_step, \"enclosure\");\n\t\t\theaderPresent = rep.getStepAttributeBoolean(id_step, \"header\");\n\t\t\tbufferSize = rep.getStepAttributeString(id_step, \"buffer_size\");\n\t\t\tlazyConversionActive = rep.getStepAttributeBoolean(id_step, \"lazy_conversion\");\n\t\t\t\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tinputFields[i].setName( rep.getStepAttributeString(id_step, i, \"field_name\") );\n\t\t\t\tinputFields[i].setType( ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"field_type\")) );\n\t\t\t\tinputFields[i].setFormat( rep.getStepAttributeString(id_step, i, \"field_format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( rep.getStepAttributeString(id_step, i, \"field_currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( rep.getStepAttributeString(id_step, i, \"field_decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( rep.getStepAttributeString(id_step, i, \"field_group\") );\n\t\t\t\tinputFields[i].setLength( (int) rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tinputFields[i].setPrecision( (int) rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","id":22348,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tfilename = rep.getStepAttributeString(id_step, \"filename\");\n\t\t\tfilenameField = rep.getStepAttributeString(id_step, \"filename_field\");\r\n\t\t\tdelimiter = rep.getStepAttributeString(id_step, \"separator\");\n\t\t\tenclosure = rep.getStepAttributeString(id_step, \"enclosure\");\n\t\t\theaderPresent = rep.getStepAttributeBoolean(id_step, \"header\");\n\t\t\tbufferSize = rep.getStepAttributeString(id_step, \"buffer_size\");\n\t\t\tlazyConversionActive = rep.getStepAttributeBoolean(id_step, \"lazy_conversion\");\n\t\t\t\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\n\n\t\t\tallocate(nrfields);\n\n\t\t\tfor (int i = 0; i < nrfields; i++)\n\t\t\t{\n\t\t\t\tinputFields[i] = new TextFileInputField();\n\t\t\t\t\n\t\t\t\tinputFields[i].setName( rep.getStepAttributeString(id_step, i, \"field_name\") );\n\t\t\t\tinputFields[i].setType( ValueMeta.getType(rep.getStepAttributeString(id_step, i, \"field_type\")) );\n\t\t\t\tinputFields[i].setFormat( rep.getStepAttributeString(id_step, i, \"field_format\") );\n\t\t\t\tinputFields[i].setCurrencySymbol( rep.getStepAttributeString(id_step, i, \"field_currency\") );\n\t\t\t\tinputFields[i].setDecimalSymbol( rep.getStepAttributeString(id_step, i, \"field_decimal\") );\n\t\t\t\tinputFields[i].setGroupSymbol( rep.getStepAttributeString(id_step, i, \"field_group\") );\n\t\t\t\tinputFields[i].setLength( (int) rep.getStepAttributeInteger(id_step, i, \"field_length\") );\n\t\t\t\tinputFields[i].setPrecision( (int) rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\n\t\t\t\tinputFields[i].setTrimType( ValueMeta.getTrimTypeByCode( rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\n\t\t}\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n\t\tStringBuffer retval = new StringBuffer(500);\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename\", filename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", delimiter));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\", headerPresent));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"buffer_size\", bufferSize));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"lazy_conversion\", lazyConversionActive));\n\n\t\tretval.append(\"    <fields>\").append(Const.CR);\n\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t{\n\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\n\t\t\tretval.append(\"      <field>\").append(Const.CR);\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\", field.getName()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(field.getType())));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\", field.getFormat()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\", field.getCurrencySymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\", field.getDecimalSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\", field.getGroupSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\", field.getLength()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", ValueMeta.getTrimTypeCode(field.getTrimType())));\n\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\n\t\t}\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\n\n\t\treturn retval.toString();\n\t}","id":22349,"modified_method":"public String getXML()\n\t{\n\t\tStringBuffer retval = new StringBuffer(500);\n\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename\", filename));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"filename_field\", filenameField));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", delimiter));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\", headerPresent));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"buffer_size\", bufferSize));\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"lazy_conversion\", lazyConversionActive));\n\n\t\tretval.append(\"    <fields>\").append(Const.CR);\n\t\tfor (int i = 0; i < inputFields.length; i++)\n\t\t{\n\t\t\tTextFileInputField field = inputFields[i];\n\t\t\t\n\t\t\tretval.append(\"      <field>\").append(Const.CR);\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\", field.getName()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\", ValueMeta.getTypeDesc(field.getType())));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\", field.getFormat()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\", field.getCurrencySymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\", field.getDecimalSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\", field.getGroupSymbol()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\", field.getLength()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\n\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", ValueMeta.getTrimTypeCode(field.getTrimType())));\n\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\n\t\t}\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\n\n\t\treturn retval.toString();\n\t}","commit_id":"20bf084662c19873bbaaa5e84d5b57eef73ffa2a","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static boolean isJavaFile(java.io.File file) {\n    String suffix = \".\" + StringUtils.substringAfterLast(file.getName(), \".\");\n    return ArrayUtils.contains(SUFFIXES, suffix);\n  }","id":22350,"modified_method":"public static boolean isJavaFile(java.io.File file) {\n    String suffix = \".\" + StringUtils.lowerCase(StringUtils.substringAfterLast(file.getName(), \".\"));\n    return ArrayUtils.contains(SUFFIXES, suffix);\n  }","commit_id":"5b4b4172c45aa794d7b40c8e5b9fde6d3a001492","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test() {\n    Java language = new Java();\n    assertThat(language.getFileSuffixes()).isEqualTo(new String[] {\".java\", \".jav\"});\n\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.java\"))).isTrue();\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.jav\"))).isTrue();\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.notjava\"))).isFalse();\n  }","id":22351,"modified_method":"@Test\n  public void test() {\n    Java language = new Java();\n    assertThat(language.getFileSuffixes()).isEqualTo(new String[] {\".java\", \".jav\"});\n\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.java\"))).isTrue();\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.JAVA\"))).isTrue();\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.jav\"))).isTrue();\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.Jav\"))).isTrue();\n    assertThat(Java.isJavaFile(new java.io.File(\"Example.notjava\"))).isFalse();\n  }","commit_id":"5b4b4172c45aa794d7b40c8e5b9fde6d3a001492","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static String convertToSquidKeyFormat(JavaFile file) {\n    String key = file.getKey();\n    if (file.getParent() == null || file.getParent().isDefault()) {\n      key = StringUtils.substringAfterLast(file.getKey(), \".\");\n    } else {\n      key = StringUtils.replace(key, \".\", \"/\");\n    }\n    return key + JAVA_FILE_SUFFIX;\n  }","id":22352,"modified_method":"public static String convertToSquidKeyFormat(JavaFile file) {\n    throw new UnsupportedOperationException(\"Not supported since v4.0. Was badly implemented\");\n  }","commit_id":"5b4b4172c45aa794d7b40c8e5b9fde6d3a001492","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static JavaFile convertJavaFileKeyFromSquidFormat(String key) {\n    boolean isJavaFile = key.endsWith(JAVA_FILE_SUFFIX);\n    if (isJavaFile) {\n      key = key.substring(0, key.length() - JAVA_FILE_SUFFIX.length());\n    }\n\n    String convertedKey = key.replace('/', '.');\n    if (convertedKey.indexOf('.') == -1 && !\"\".equals(convertedKey)) {\n      convertedKey = \"[default].\" + convertedKey;\n\n    } else if (convertedKey.indexOf('.') == -1) {\n      convertedKey = \"[default]\";\n    }\n\n    return new JavaFile(convertedKey);\n  }","id":22353,"modified_method":"public static JavaFile convertJavaFileKeyFromSquidFormat(String key) {\n    String extension = StringUtils.lowerCase(FilenameUtils.getExtension(key));\n    boolean isJavaFile = \"jav\".equals(extension) || \"java\".equals(extension);\n    if (isJavaFile) {\n      key = key.substring(0, key.length() - extension.length() -1);\n    }\n\n    String convertedKey = key.replace('/', '.');\n    if (convertedKey.indexOf('.') == -1 && !\"\".equals(convertedKey)) {\n      convertedKey = \"[default].\" + convertedKey;\n\n    } else if (convertedKey.indexOf('.') == -1) {\n      convertedKey = \"[default]\";\n    }\n\n    return new JavaFile(convertedKey);\n  }","commit_id":"5b4b4172c45aa794d7b40c8e5b9fde6d3a001492","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void convertJavaFileKeyFromSquidFormat() {\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String\"));\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String.java\"));\n    assertThat(new JavaFile(\"String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"String.java\"));\n    assertThat(new JavaFile(\"String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"String\"));\n  }","id":22354,"modified_method":"@Test\n  public void convertJavaFileKeyFromSquidFormat() {\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String\"));\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String.java\"));\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String.jav\"));\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String.JAVA\"));\n    assertThat(new JavaFile(\"java.lang.String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"java/lang/String.JAV\"));\n    assertThat(new JavaFile(\"String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"String.java\"));\n    assertThat(new JavaFile(\"String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"String.JAVA\"));\n    assertThat(new JavaFile(\"String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"String.JAV\"));\n    assertThat(new JavaFile(\"String\")).isEqualTo(SquidUtils.convertJavaFileKeyFromSquidFormat(\"String\"));\n  }","commit_id":"5b4b4172c45aa794d7b40c8e5b9fde6d3a001492","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldConvertToSquidKeyFormat() {\n    assertThat(SquidUtils.convertToSquidKeyFormat(new JavaFile(\"com.foo.Bar\"))).isEqualTo((\"com/foo/Bar.java\"));\n    assertThat(SquidUtils.convertToSquidKeyFormat(new JavaFile(\"Bar\"))).isEqualTo((\"Bar.java\"));\n  }","id":22355,"modified_method":"@Test(expected = UnsupportedOperationException.class)\n  public void shouldConvertToSquidKeyFormat() {\n    SquidUtils.convertToSquidKeyFormat(new JavaFile(\"com.foo.Bar\"));\n  }","commit_id":"5b4b4172c45aa794d7b40c8e5b9fde6d3a001492","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static String createHash(String scriptText) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw UncheckedException.asUncheckedException(e);\n        }\n        messageDigest.update(scriptText.getBytes());\n        return new BigInteger(1, messageDigest.digest()).toString(16);\n    }","id":22356,"modified_method":"public static String createHash(String scriptText) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw UncheckedException.asUncheckedException(e);\n        }\n        messageDigest.update(scriptText.getBytes());\n        return new BigInteger(1, messageDigest.digest()).toString(32);\n    }","commit_id":"8df2a66f0b39cb954f808e0d7f3211b5570b3778","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Returns the class name for use for this script source.  The name is intended to be unique to support mapping\n     * class names to source files even if many sources have the same file name (e.g. build.gradle).\n     */\n    public String getClassName() {\n        if (className == null) {\n            URI sourceUri = resource.getURI();\n            String name = StringUtils.substringAfterLast(sourceUri.getPath(), \"/\");\n            StringBuilder className = new StringBuilder(name.length());\n            for (int i = 0; i < name.length(); i++) {\n                char ch = name.charAt(i);\n                if (Character.isJavaIdentifierPart(ch)) {\n                    className.append(ch);\n                } else {\n                    className.append('_');\n                }\n            }\n            if (!Character.isJavaIdentifierStart(className.charAt(0))) {\n                className.insert(0, '_');\n            }\n            className.append('_');\n            String path = sourceUri.toString();\n            className.append(HashUtil.createHash(path));\n\n            this.className = className.toString();\n        }\n\n        return className;\n    }","id":22357,"modified_method":"/**\n     * Returns the class name for use for this script source.  The name is intended to be unique to support mapping\n     * class names to source files even if many sources have the same file name (e.g. build.gradle).\n     */\n    public String getClassName() {\n        if (className == null) {\n            URI sourceUri = resource.getURI();\n            String name = StringUtils.substringBeforeLast(StringUtils.substringAfterLast(sourceUri.getPath(), \"/\"), \".\");\n            StringBuilder className = new StringBuilder(name.length());\n            for (int i = 0; i < name.length(); i++) {\n                char ch = name.charAt(i);\n                if (Character.isJavaIdentifierPart(ch)) {\n                    className.append(ch);\n                } else {\n                    className.append('_');\n                }\n            }\n            if (!Character.isJavaIdentifierStart(className.charAt(0))) {\n                className.insert(0, '_');\n            }\n            className.setLength(Math.min(className.length(), 30));\n            className.append('_');\n            String path = sourceUri.toString();\n            className.append(HashUtil.createHash(path));\n\n            this.className = className.toString();\n        }\n\n        return className;\n    }","commit_id":"8df2a66f0b39cb954f808e0d7f3211b5570b3778","url":"https://github.com/gradle/gradle"},{"original_method":"public static JavaClass create(String packageName, String className) {\n    if (StringUtils.isBlank(packageName)) {\n      return new JavaClass(className);\n    }\n    String name = new StringBuilder().append(packageName).append(JavaUtils.PACKAGE_SEPARATOR).append(className).toString();\n    return new JavaClass(name);\n  }","id":22358,"modified_method":"public static JavaClass createRef(String packageName, String className) {\n    if (StringUtils.isBlank(packageName)) {\n      return new JavaClass(className);\n    }\n    return new JavaClass(toName(packageName, className));\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static JavaClass create(String name) {\n    return new JavaClass(name);\n  }","id":22359,"modified_method":"public static JavaClass createRef(String name) {\n    return new JavaClass(name);\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String getPackageName() {\n    return StringUtils.substringBeforeLast(name, JavaUtils.PACKAGE_SEPARATOR);\n  }","id":22360,"modified_method":"public String getPackageName() {\n    if (StringUtils.contains(getKey(), JavaUtils.PACKAGE_SEPARATOR)) {\n      return StringUtils.substringBeforeLast(getKey(), JavaUtils.PACKAGE_SEPARATOR);\n    }\n    return \"\";\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public String getScope() {\n    return Scopes.TYPE;\n  }","id":22361,"modified_method":"@Override\n  public String getScope() {\n    return null;\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String getClassName() {\n    return StringUtils.substringAfterLast(name, JavaUtils.PACKAGE_SEPARATOR);\n  }","id":22362,"modified_method":"public String getClassName() {\n    String className = StringUtils.substringAfterLast(getKey(), JavaUtils.PACKAGE_SEPARATOR);\n    return StringUtils.defaultIfEmpty(className, getKey());\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public String getName() {\n    return getClassName();\n  }","id":22363,"modified_method":"@Override\n  public String getName() {\n    return getKey();\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public String getLongName() {\n    return name;\n  }","id":22364,"modified_method":"@Override\n  public String getLongName() {\n    return getKey();\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private JavaClass(String name) {\n    this.name = name;\n    setKey(name);\n  }","id":22365,"modified_method":"private JavaClass(String name) {\n    setKey(name);\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCreateJavaClassFromName() {\n    JavaClass javaClass = JavaClass.create(\"org.foo.Bar\");\n    assertThat(javaClass.getClassName(), is(\"Bar\"));\n    assertThat(javaClass.getKey(), is(\"org.foo.Bar\"));\n    assertThat(javaClass.getLanguage(), is((Language)Java.INSTANCE));\n    assertThat(javaClass.getName(), is(\"Bar\"));\n    assertThat(javaClass.getLongName(), is(\"org.foo.Bar\"));\n  }","id":22366,"modified_method":"@Test\n  public void shouldCreateReferenceFromName() {\n    JavaClass javaClass = JavaClass.createRef(\"org.foo.Bar\");\n    assertThat(javaClass.getClassName(), is(\"Bar\"));\n    assertThat(javaClass.getKey(), is(\"org.foo.Bar\"));\n    assertThat(javaClass.getLanguage(), is((Language)Java.INSTANCE));\n    assertThat(javaClass.getName(), is(\"org.foo.Bar\"));\n    assertThat(javaClass.getLongName(), is(\"org.foo.Bar\"));\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCreateJavaClassFromPackageAndClassname() {\n    JavaClass javaClass = JavaClass.create(\"org.foo\", \"Bar\");\n    assertThat(javaClass.getClassName(), is(\"Bar\"));\n    assertThat(javaClass.getKey(), is(\"org.foo.Bar\"));\n    assertThat(javaClass.getLanguage(), is((Language)Java.INSTANCE));\n    assertThat(javaClass.getName(), is(\"Bar\"));\n    assertThat(javaClass.getLongName(), is(\"org.foo.Bar\"));\n  }","id":22367,"modified_method":"@Test\n  public void shouldCreateReferenceFromPackageAndClassname() {\n    JavaClass javaClass = JavaClass.createRef(\"org.foo\", \"Bar\");\n    assertThat(javaClass.getClassName(), is(\"Bar\"));\n    assertThat(javaClass.getKey(), is(\"org.foo.Bar\"));\n    assertThat(javaClass.getLanguage(), is((Language)Java.INSTANCE));\n    assertThat(javaClass.getName(), is(\"org.foo.Bar\"));\n    assertThat(javaClass.getLongName(), is(\"org.foo.Bar\"));\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ResourceIndex    loadSquidResources(Squid squid, SensorContext context, Project project) {\n    loadSquidProject(squid, project);\n    loadSquidPackages(squid, context);\n    loadSquidFiles(squid, context);\n    return this;\n  }","id":22368,"modified_method":"public ResourceIndex    loadSquidResources(Squid squid, SensorContext context, Project project) {\n    loadSquidProject(squid, project);\n    loadSquidPackages(squid, context);\n    loadSquidFiles(squid, context);\n    loadSquidClasses(squid, context);\n//    loadSquidMethods(squid, context);\n    return this;\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void loadSquidPackages(Squid squid, SensorContext context) {\n    Collection<SourceCode> packages = squid.search(new QueryByType(SourcePackage.class));\n    for (SourceCode squidPackage : packages) {\n      JavaPackage sonarPackage = SquidUtils.convertJavaPackageKeyFromSquidFormat(squidPackage.getKey());\n      context.saveResource(sonarPackage);\n      put(squidPackage, context.getResource(sonarPackage)); // resource is reloaded to get the id\n    }\n  }","id":22369,"modified_method":"private void loadSquidPackages(Squid squid, SensorContext context) {\n    Collection<SourceCode> packages = squid.search(new QueryByType(SourcePackage.class));\n    for (SourceCode squidPackage : packages) {\n      JavaPackage sonarPackage = SquidUtils.convertJavaPackageKeyFromSquidFormat(squidPackage.getKey());\n      context.index(sonarPackage);\n      put(squidPackage, context.getResource(sonarPackage)); // resource is reloaded to get the id\n    }\n  }","commit_id":"8015cc71f97f5e049a8120ed54d1fb763f8343f2","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static void clearRunHistory(Integer orgId, Date limitTime) {\n        try {\n            String[] triggerNames = SchedulerKernel.getScheduler().\n                getTriggerNames(orgId.toString());\n            // triggerName == jobLabel\n            for (String jobLabel : triggerNames) {\n                // delete history of runs\n                List<TaskoRun> runList =\n                    TaskoFactory.listRunsOlderThan(orgId, limitTime);\n                for (TaskoRun run : runList) {\n                    TaskoFactory.deleteLogFiles(run);\n                    TaskoFactory.delete(run);\n                }\n\n                // unschedule outdated jobs\n                Trigger trigger = SchedulerKernel.getScheduler().getTrigger(\n                        jobLabel, orgId.toString());\n                Date endTime = trigger.getEndTime();\n                if ((endTime != null) && (endTime.before(limitTime))) {\n                    SchedulerKernel.getScheduler().unscheduleJob(trigger.getName(),\n                            orgId.toString());\n                }\n            }\n            TaskoFactory.commitTransaction();\n        }\n        catch (SchedulerException e) {\n            TaskoFactory.rollbackTransaction();\n        }\n    }","id":22370,"modified_method":"public static void clearRunHistory(Integer orgId, Date limitTime) throws InvalidParamException {\n        if (limitTime == null) {\n            throw new InvalidParamException(\"Invalid limit date\");\n        }\n        List<TaskoRun> runList = listRunsOlderThan(orgId, limitTime);\n        Transaction trns = TaskoFactory.getSession().beginTransaction();\n        for (TaskoRun run : runList) {\n            // delete history of runs\n            TaskoFactory.deleteLogFiles(run);\n            TaskoFactory.delete(run);\n        }\n        trns.commit();\n\n        // delete outdated schedules\n        List<TaskoSchedule> scheduleList = listSchedulesByOrg(orgId);\n        trns = TaskoFactory.getSession().beginTransaction();\n        for (TaskoSchedule schedule : scheduleList) {\n            Date endTime = schedule.getActiveTill();\n            if ((endTime != null) && (endTime.before(limitTime))) {\n                TaskoFactory.delete(schedule);\n            }\n        }\n        trns.commit();\n    }","commit_id":"2094048e5c0fc929b9254f34e5c1e9957c5be37f","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public static TaskoSchedule listSchedulesByOrgAndBunch(Integer orgId,\n            TaskoBunch bunch) {\n        Map params = new HashMap();\n        params.put(\"org_id\", orgId);\n        params.put(\"bunch_id\", bunch.getId());\n        return (TaskoSchedule) singleton.listObjectsByNamedQuery(\n                                       \"TaskoSchedule.listByOrgAndBunch\", params);\n    }","id":22371,"modified_method":"public static List<TaskoSchedule> listSchedulesByOrgAndBunch(Integer orgId,\n            TaskoBunch bunch) {\n        Map params = new HashMap();\n        params.put(\"org_id\", orgId);\n        params.put(\"bunch_id\", bunch.getId());\n        return singleton.listObjectsByNamedQuery(\n                                       \"TaskoSchedule.listByOrgAndBunch\", params);\n    }","commit_id":"2094048e5c0fc929b9254f34e5c1e9957c5be37f","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public static TaskoSchedule lookupActiveScheduleByOrgAndLabel(Integer orgId,\n            String jobLabel) {\n        Map params = new HashMap();\n        params.put(\"org_id\", orgId);\n        params.put(\"job_label\", jobLabel);\n        return (TaskoSchedule) singleton.lookupObjectByNamedQuery(\n                   \"TaskoSchedule.findActiveScheduleByOrgAndLabel\", params);\n    }","id":22372,"modified_method":"public static TaskoSchedule lookupActiveScheduleByOrgAndLabel(Integer orgId,\n            String jobLabel) {\n        Map params = new HashMap();\n        params.put(\"org_id\", orgId);\n        params.put(\"job_label\", jobLabel);\n        return (TaskoSchedule) singleton.lookupObjectByNamedQuery(\n                   \"TaskoSchedule.findActiveByOrgAndLabel\", params);\n    }","commit_id":"2094048e5c0fc929b9254f34e5c1e9957c5be37f","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public static TaskoSchedule listSchedulesByOrgAndLabel(Integer orgId, String jobLabel) {\n        Map params = new HashMap();\n        params.put(\"org_id\", orgId);\n        params.put(\"job_label\", jobLabel);\n        return (TaskoSchedule) singleton.listObjectsByNamedQuery(\n                                       \"TaskoSchedule.listByOrgAndLabel\", params);\n    }","id":22373,"modified_method":"public static List<TaskoSchedule> listSchedulesByOrgAndLabel(Integer orgId, String jobLabel) {\n        Map params = new HashMap();\n        params.put(\"org_id\", orgId);\n        params.put(\"job_label\", jobLabel);\n        return singleton.listObjectsByNamedQuery(\n                                       \"TaskoSchedule.listByOrgAndLabel\", params);\n    }","commit_id":"2094048e5c0fc929b9254f34e5c1e9957c5be37f","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private ActionForward handleDispatchAction(ActionMapping mapping,\n            RequestContext context,\n            Long sid,\n            Set sessionSet) {\n        Set<String> soids = (Set<String>) sessionSet;\n        Set<Org> allowedOrgs = new HashSet<Org>();\n        IssSlave s = IssFactory.lookupSlaveById(sid);\n        for (String soid : soids) {\n            Long oid = Long.parseLong(soid);\n            Org anOrg = OrgFactory.lookupById(oid);\n            allowedOrgs.add(anOrg);\n        }\n        s.setAllowedOrgs(allowedOrgs);\n\n        ActionMessages msg = new ActionMessages();\n        msg.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\n                \"message.iss_slave_allowed_orgs_updated\", s.getSlave()));\n        getStrutsDelegate().saveMessages(context.getRequest(), msg);\n\n        Map params = makeParamMap(context.getRequest());\n        if (sid != null) {\n            params.put(\"sid\", sid);\n        }\n        return StrutsDelegate.getInstance().forwardParams(\n                mapping.findForward(\"success\"), params);\n    }","id":22374,"modified_method":"private ActionForward handleDispatchAction(ActionMapping mapping,\n            RequestContext context,\n            Long sid,\n            Set sessionSet) {\n        Set<String> soids = sessionSet;\n        Set<Org> allowedOrgs = new HashSet<Org>();\n        IssSlave s = IssFactory.lookupSlaveById(sid);\n        for (String soid : soids) {\n            Long oid = Long.parseLong(soid);\n            Org anOrg = OrgFactory.lookupById(oid);\n            allowedOrgs.add(anOrg);\n        }\n        s.setAllowedOrgs(allowedOrgs);\n\n        ActionMessages msg = new ActionMessages();\n        msg.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\n                \"message.iss_slave_allowed_orgs_updated\", s.getSlave()));\n        getStrutsDelegate().saveMessages(context.getRequest(), msg);\n\n        Map params = makeParamMap(context.getRequest());\n        if (sid != null) {\n            params.put(\"sid\", sid);\n        }\n        return StrutsDelegate.getInstance().forwardParams(\n                mapping.findForward(\"success\"), params);\n    }","commit_id":"5d416cfa91fa6543b7a9271384761bf2f19e7f33","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * List all IssMaster entries for this Slave\n     * @return list of all masters known to this slave\n     */\n    public static List<IssMaster> listAllMasters() {\n        Map params = new HashMap();\n        return (List<IssMaster>)singleton.listObjectsByNamedQuery(\n                \"IssMaster.lookupAll\", params);\n    }","id":22375,"modified_method":"/**\n     * List all IssMaster entries for this Slave\n     * @return list of all masters known to this slave\n     */\n    public static List<IssMaster> listAllMasters() {\n        Map params = new HashMap();\n        return singleton.listObjectsByNamedQuery(\n                \"IssMaster.lookupAll\", params);\n    }","commit_id":"5d416cfa91fa6543b7a9271384761bf2f19e7f33","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * List all IssSlaves for this Master\n     * @return list of all the slaves\n     */\n    public static List<IssSlave> listAllIssSlaves() {\n        Map params = new HashMap();\n        return (List<IssSlave>)singleton.listObjectsByNamedQuery(\n                \"IssSlave.lookupAll\", params);\n    }","id":22376,"modified_method":"/**\n     * List all IssSlaves for this Master\n     * @return list of all the slaves\n     */\n    public static List<IssSlave> listAllIssSlaves() {\n        Map params = new HashMap();\n        return singleton.listObjectsByNamedQuery(\n                \"IssSlave.lookupAll\", params);\n    }","commit_id":"5d416cfa91fa6543b7a9271384761bf2f19e7f33","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private List<IssMaster> findSelectedMasters(Set sessionSet, Long midIn) {\n        List<IssMaster> masters = new ArrayList<IssMaster>();\n\n        if (sessionSet != null) {\n            Set<String> mids = (Set<String>) sessionSet;\n            for (String mid : mids) {\n                IssMaster aMaster = IssFactory.lookupMasterById(Long.parseLong(mid));\n                masters.add(aMaster);\n            }\n        }\n        else if (midIn != null) {\n            masters.add(IssFactory.lookupMasterById(Long.parseLong(midIn.toString())));\n        }\n\n        return masters;\n    }","id":22377,"modified_method":"private List<IssMaster> findSelectedMasters(Set sessionSet, Long midIn) {\n        List<IssMaster> masters = new ArrayList<IssMaster>();\n\n        if (sessionSet != null) {\n            Set<String> mids = sessionSet;\n            for (String mid : mids) {\n                IssMaster aMaster = IssFactory.lookupMasterById(Long.parseLong(mid));\n                masters.add(aMaster);\n            }\n        }\n        else if (midIn != null) {\n            masters.add(IssFactory.lookupMasterById(Long.parseLong(midIn.toString())));\n        }\n\n        return masters;\n    }","commit_id":"5d416cfa91fa6543b7a9271384761bf2f19e7f33","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private List<IssSlave> findSelectedSlaves(Set sessionSet, Object sidIn) {\n        List<IssSlave> slaves = new ArrayList<IssSlave>();\n\n        if (sessionSet != null) {\n            Set<String> sids = (Set<String>) sessionSet;\n            for (String sid : sids) {\n                IssSlave aSlave = IssFactory.lookupSlaveById(Long.parseLong(sid));\n                slaves.add(aSlave);\n            }\n        }\n        else if (sidIn != null) {\n            slaves.add(IssFactory.lookupSlaveById(Long.parseLong(sidIn.toString())));\n        }\n\n        return slaves;\n    }","id":22378,"modified_method":"private List<IssSlave> findSelectedSlaves(Set sessionSet, Object sidIn) {\n        List<IssSlave> slaves = new ArrayList<IssSlave>();\n\n        if (sessionSet != null) {\n            Set<String> sids = sessionSet;\n            for (String sid : sids) {\n                IssSlave aSlave = IssFactory.lookupSlaveById(Long.parseLong(sid));\n                slaves.add(aSlave);\n            }\n        }\n        else if (sidIn != null) {\n            slaves.add(IssFactory.lookupSlaveById(Long.parseLong(sidIn.toString())));\n        }\n\n        return slaves;\n    }","commit_id":"5d416cfa91fa6543b7a9271384761bf2f19e7f33","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * This is the heart of the installer - it processes new resources and merges them\n     * with existing resources.\n     * The second part consists of detecting the resources to be processsed.\n     */\n    private void mergeNewResources() {\n        synchronized (newResources) {\n            final boolean changed = !this.newResources.isEmpty() || !this.newResourcesSchemes.isEmpty() || !this.urlsToRemove.isEmpty();\n            // check for new resource providers (schemes)\n            // if we have new providers we have to sync them with existing resources\n            for(final Map.Entry<String, List<RegisteredResource>> entry : this.newResourcesSchemes.entrySet()) {\n                logger.debug(\"Processing set of new resources with scheme {}\", entry.getKey());\n\n                // set all previously found resources that are not available anymore to uninstall\n                // if they have been installed - remove resources with a different state\n                for(final String entityId : this.persistentList.getEntityIds()) {\n                    final EntityResourceList group = this.persistentList.getEntityResourceList(entityId);\n\n                    final List<RegisteredResource> toRemove = new ArrayList<RegisteredResource>();\n                    boolean first = true;\n                    for(final RegisteredResource r : group.getResources()) {\n                        if ( r.getScheme().equals(entry.getKey()) ) {\n                            logger.debug(\"Checking {}\", r);\n                            // search if we have a new entry with the same url\n                            boolean found = false;\n                            final Iterator<RegisteredResource> m = entry.getValue().iterator();\n                            while ( !found && m.hasNext() ) {\n                                final RegisteredResource testResource = m.next();\n                                found = testResource.getURL().equals(r.getURL());\n                            }\n                            if ( !found) {\n                                logger.debug(\"Resource {} seems to be removed.\", r);\n                                if ( first && (r.getState() == RegisteredResource.State.INSTALLED\n                                           ||  r.getState() == RegisteredResource.State.INSTALL)\n                                           ||  r.getState() == RegisteredResource.State.IGNORED) {\n                                     r.setState(RegisteredResource.State.UNINSTALL);\n                                } else {\n                                    toRemove.add(r);\n                                }\n                            }\n                        }\n                        first = false;\n                    }\n                    for(final RegisteredResource rr : toRemove) {\n                        this.persistentList.remove(rr);\n                    }\n                }\n                logger.debug(\"Added set of {} new resources with scheme {} : {}\",\n                        new Object[] {entry.getValue().size(), entry.getKey(), entry.getValue()});\n                newResources.addAll(entry.getValue());\n            }\n\n            newResourcesSchemes.clear();\n\n            for(RegisteredResource r : newResources) {\n                this.persistentList.addOrUpdate(r);\n            }\n            newResources.clear();\n\n            // Mark resources for removal according to urlsToRemove\n            if (!urlsToRemove.isEmpty()) {\n                for(final String url : urlsToRemove ) {\n                    this.persistentList.remove(url);\n                }\n            }\n            urlsToRemove.clear();\n\n            if ( changed ) {\n                printResources(\"Merged\");\n                // persist list\n                this.persistentList.save();\n            }\n        }\n    }","id":22379,"modified_method":"/**\n     * This is the heart of the installer - it processes new resources and merges them\n     * with existing resources.\n     * The second part consists of detecting the resources to be processsed.\n     */\n    private void mergeNewResources() {\n        synchronized (newResources) {\n            final boolean changed = this.hasNewResources();\n\n            if ( changed ) {\n                // check for new resource providers (schemes)\n                // if we have new providers we have to sync them with existing resources\n                for(final Map.Entry<String, List<RegisteredResource>> entry : this.newResourcesSchemes.entrySet()) {\n                    logger.debug(\"Processing set of new resources with scheme {}\", entry.getKey());\n\n                    // set all previously found resources that are not available anymore to uninstall\n                    // if they have been installed - remove resources with a different state\n                    for(final String entityId : this.persistentList.getEntityIds()) {\n                        final EntityResourceList group = this.persistentList.getEntityResourceList(entityId);\n\n                        final List<RegisteredResource> toRemove = new ArrayList<RegisteredResource>();\n                        boolean first = true;\n                        for(final RegisteredResource r : group.getResources()) {\n                            if ( r.getScheme().equals(entry.getKey()) ) {\n                                logger.debug(\"Checking {}\", r);\n                                // search if we have a new entry with the same url\n                                boolean found = false;\n                                final Iterator<RegisteredResource> m = entry.getValue().iterator();\n                                while ( !found && m.hasNext() ) {\n                                    final RegisteredResource testResource = m.next();\n                                    found = testResource.getURL().equals(r.getURL());\n                                }\n                                if ( !found) {\n                                    logger.debug(\"Resource {} seems to be removed.\", r);\n                                    if ( first && (r.getState() == RegisteredResource.State.INSTALLED\n                                               ||  r.getState() == RegisteredResource.State.INSTALL)\n                                               ||  r.getState() == RegisteredResource.State.IGNORED) {\n                                         r.setState(RegisteredResource.State.UNINSTALL);\n                                    } else {\n                                        toRemove.add(r);\n                                    }\n                                }\n                            }\n                            first = false;\n                        }\n                        for(final RegisteredResource rr : toRemove) {\n                            this.persistentList.remove(rr);\n                        }\n                    }\n                    logger.debug(\"Added set of {} new resources with scheme {} : {}\",\n                            new Object[] {entry.getValue().size(), entry.getKey(), entry.getValue()});\n                    newResources.addAll(entry.getValue());\n                }\n\n                newResourcesSchemes.clear();\n\n                for(RegisteredResource r : newResources) {\n                    this.persistentList.addOrUpdate(r);\n                }\n                newResources.clear();\n\n                // Mark resources for removal according to urlsToRemove\n                if (!urlsToRemove.isEmpty()) {\n                    for(final String url : urlsToRemove ) {\n                        this.persistentList.remove(url);\n                    }\n                }\n                urlsToRemove.clear();\n\n                printResources(\"Merged\");\n                // persist list\n                this.persistentList.save();\n            }\n        }\n    }","commit_id":"28a12122fe8b04501b0646885c481de936260b57","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void run() {\n        this.init();\n        while (active) {\n            this.mergeNewResources();\n            final boolean tasksToDo = this.hasOpenTasks();\n            final SortedSet<OsgiInstallerTask> tasks = this.computeTasks();\n\n            if (tasks.isEmpty() && !tasksToDo && !retriesScheduled) {\n                // No tasks to execute - wait until new resources are\n                // registered\n                this.cleanupInstallableResources();\n                logger.debug(\"No tasks to process, going idle\");\n\n                synchronized (newResources) {\n                    try {\n                        newResources.wait();\n                    } catch (InterruptedException ignore) {}\n                }\n                logger.debug(\"Notified of new resources, back to work\");\n                continue;\n            }\n\n            retriesScheduled = false;\n            // execute tasks\n            this.executeTasks(tasks);\n            // clean up and save\n            this.cleanupInstallableResources();\n\n            // Some integration tests depend on this delay, make sure to\n            // rerun/adapt them if changing this value\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException ignore) {}\n        }\n    }","id":22380,"modified_method":"@Override\n    public void run() {\n        this.init();\n        while (active) {\n            this.mergeNewResources();\n            final boolean tasksToDo = this.hasOpenTasks();\n            final SortedSet<OsgiInstallerTask> tasks = this.computeTasks();\n\n            if (tasks.isEmpty() && !tasksToDo && !retriesScheduled) {\n                this.cleanupInstallableResources();\n\n                synchronized (newResources) {\n                    // before we go to sleep, check if new resources arrived in the meantime\n                    if ( !this.hasNewResources()) {\n                        // No tasks to execute - wait until new resources are\n                        // registered\n                        logger.debug(\"No tasks to process, going idle\");\n                        try {\n                            newResources.wait();\n                        } catch (InterruptedException ignore) {}\n                        logger.debug(\"Notified of new resources, back to work\");\n                    }\n                }\n            } else {\n\n                retriesScheduled = false;\n                // execute tasks\n                this.executeTasks(tasks);\n                // clean up and save\n                this.cleanupInstallableResources();\n\n                // Some integration tests depend on this delay, make sure to\n                // rerun/adapt them if changing this value\n                try {\n                    Thread.sleep(250);\n                } catch (final InterruptedException ignore) {}\n            }\n        }\n    }","commit_id":"28a12122fe8b04501b0646885c481de936260b57","url":"https://github.com/apache/sling"},{"original_method":"/** Digest is needed to detect changes in data, and must not depend on dictionary ordering */\n    public static String computeDigest(Dictionary<String, Object> data) {\n        try {\n            final MessageDigest d = MessageDigest.getInstance(\"MD5\");\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            final ObjectOutputStream oos = new ObjectOutputStream(bos);\n\n            final SortedSet<String> sortedKeys = new TreeSet<String>();\n            if (data != null) {\n                for(Enumeration<String> e = data.keys(); e.hasMoreElements(); ) {\n                    final String key = e.nextElement();\n                    sortedKeys.add(key);\n                }\n            }\n            for(final String key : sortedKeys) {\n                oos.writeObject(key);\n                final Object val = data.get(key);\n                if ( val instanceof Number ) {\n                    oos.writeObject(String.valueOf(val));\n                } else {\n                    oos.writeObject(val);\n                }\n            }\n\n            bos.flush();\n            d.update(bos.toByteArray());\n            return digestToString(d);\n        } catch (Exception ignore) {\n            return data.toString();\n        }\n    }","id":22381,"modified_method":"/** Digest is needed to detect changes in data, and must not depend on dictionary ordering */\n    public static String computeDigest(Dictionary<String, Object> data) {\n        try {\n            final MessageDigest d = MessageDigest.getInstance(\"MD5\");\n            final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            final ObjectOutputStream oos = new ObjectOutputStream(bos);\n\n            final SortedSet<String> sortedKeys = new TreeSet<String>();\n            if (data != null) {\n                for(Enumeration<String> e = data.keys(); e.hasMoreElements(); ) {\n                    final String key = e.nextElement();\n                    sortedKeys.add(key);\n                }\n            }\n            for(final String key : sortedKeys) {\n                oos.writeObject(key);\n                final Object val = data.get(key);\n                if ( val instanceof Number ) {\n                    oos.writeObject(String.valueOf(val));\n                } else {\n                    oos.writeObject(val);\n                }\n            }\n\n            oos.flush();\n            d.update(bos.toByteArray());\n            return digestToString(d);\n        } catch (Exception ignore) {\n            return data.toString();\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"FolderNameFilter(final String [] rootsConfig, final String regexp, final Set<String> runModes) {\n        this.regexp = regexp;\n        this.pattern = Pattern.compile(regexp);\n        this.runModes = runModes;\n\n        // Each entry in rootsConfig is like /libs:100, where 100\n        // is the priority.\n        // Break that up into paths and priorities\n        rootPaths = new String[rootsConfig.length];\n        for(int i = 0; i < rootsConfig.length; i++) {\n        \tfinal String [] parts = rootsConfig[i].split(\":\");\n        \trootPaths[i] = cleanupRootPath(parts[0]);\n        \tInteger priority = new Integer(DEFAULT_ROOT_PRIORITY);\n        \tif(parts.length > 1) {\n        \t\ttry {\n        \t\t\tpriority = Integer.parseInt(parts[1].trim());\n        \t\t} catch(NumberFormatException nfe) {\n        \t\t\tlog.warn(\"Invalid priority in path definition '{}'\", rootsConfig[i]);\n        \t\t}\n        \t}\n        \trootPriorities.put(rootPaths[i], priority);\n        \tlog.debug(\"Root path {} has priority {}\", rootPaths[i], priority);\n        }\n    }","id":22382,"modified_method":"FolderNameFilter(final String [] rootsConfig, final String regexp, final Set<String> runModes) {\n        final List<RootPathInfo> rootPathInfos = new ArrayList<RootPathInfo>();\n        this.regexp = regexp;\n        this.pattern = Pattern.compile(regexp);\n        this.runModes = runModes;\n\n        // Each entry in rootsConfig is like /libs:100, where 100\n        // is the priority.\n        // Break that up into paths and priorities\n        this.rootPaths = new String[rootsConfig.length];\n        for(int i = 0; i < rootsConfig.length; i++) {\n        \tfinal String [] parts = rootsConfig[i].split(\":\");\n        \tthis.rootPaths[i] = cleanupRootPath(parts[0]);\n        \tInteger priority = new Integer(DEFAULT_ROOT_PRIORITY);\n        \tif(parts.length > 1) {\n        \t\ttry {\n        \t\t\tpriority = Integer.parseInt(parts[1].trim());\n        \t\t} catch(NumberFormatException nfe) {\n        \t\t\tlog.warn(\"Invalid priority in path definition '{}'\", rootsConfig[i]);\n        \t\t}\n        \t}\n        \trootPriorities.put(this.rootPaths[i], priority);\n        \trootPathInfos.add(new RootPathInfo(this.rootPaths[i], priority));\n        \tlog.debug(\"Root path {} has priority {}\", this.rootPaths[i], priority);\n        }\n        // sort root paths by priority\n        Collections.sort(rootPathInfos);\n        int index = 0;\n        for(final RootPathInfo rpi : rootPathInfos) {\n            this.rootPaths[index++] = rpi.path;\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testParseRootPaths() {\n    \t{\n    \t\tfinal String [] paths = { \"a\", \"b/\" };\n            final FolderNameFilter f = new FolderNameFilter(paths, DEFAULT_REGEXP, new HashSet<String>());\n            assertEquals(\"/a\", f.getRootPaths()[0]);\n            assertEquals(\"/b\", f.getRootPaths()[1]);\n            assertEquals(FolderNameFilter.DEFAULT_ROOT_PRIORITY, f.getRootPriority(\"/a/foo\"));\n            assertEquals(FolderNameFilter.DEFAULT_ROOT_PRIORITY, f.getRootPriority(\"/b/foo\"));\n            assertEquals(0, f.getRootPriority(\"/notInThoseRoots\"));\n    \t}\n    \t{\n    \t\tfinal String [] paths = { \"a:100\", \"/b/: 200 \" };\n            final FolderNameFilter f = new FolderNameFilter(paths, DEFAULT_REGEXP, new HashSet<String>());\n            assertEquals(\"/a\", f.getRootPaths()[0]);\n            assertEquals(\"/b\", f.getRootPaths()[1]);\n            assertEquals(100, f.getRootPriority(\"/a/foo\"));\n            assertEquals(200, f.getRootPriority(\"/b/foo\"));\n    \t}\n    \t{\n    \t\tfinal String [] paths = { \"a/:NOT_AN_INTEGER\", \"/b/: 200 \" };\n            final FolderNameFilter f = new FolderNameFilter(paths, DEFAULT_REGEXP, new HashSet<String>());\n            assertEquals(\"/a\", f.getRootPaths()[0]);\n            assertEquals(\"/b\", f.getRootPaths()[1]);\n            assertEquals(FolderNameFilter.DEFAULT_ROOT_PRIORITY, f.getRootPriority(\"/a/foo\"));\n            assertEquals(200, f.getRootPriority(\"/b/foo\"));\n    \t}\n    }","id":22383,"modified_method":"@Test\n    public void testParseRootPaths() {\n    \t{\n    \t\tfinal String [] paths = { \"a\", \"b/\" };\n            final FolderNameFilter f = new FolderNameFilter(paths, DEFAULT_REGEXP, new HashSet<String>());\n            assertEquals(\"/a\", f.getRootPaths()[0]);\n            assertEquals(\"/b\", f.getRootPaths()[1]);\n            assertEquals(FolderNameFilter.DEFAULT_ROOT_PRIORITY, f.getRootPriority(\"/a/foo\"));\n            assertEquals(FolderNameFilter.DEFAULT_ROOT_PRIORITY, f.getRootPriority(\"/b/foo\"));\n            assertEquals(0, f.getRootPriority(\"/notInThoseRoots\"));\n    \t}\n    \t{\n    \t\tfinal String [] paths = { \"a:100\", \"/b/: 200 \" };\n            final FolderNameFilter f = new FolderNameFilter(paths, DEFAULT_REGEXP, new HashSet<String>());\n            assertEquals(\"/b\", f.getRootPaths()[0]);\n            assertEquals(\"/a\", f.getRootPaths()[1]);\n            assertEquals(100, f.getRootPriority(\"/a/foo\"));\n            assertEquals(200, f.getRootPriority(\"/b/foo\"));\n    \t}\n    \t{\n    \t\tfinal String [] paths = { \"a/:NOT_AN_INTEGER\", \"/b/: 200 \" };\n            final FolderNameFilter f = new FolderNameFilter(paths, DEFAULT_REGEXP, new HashSet<String>());\n            assertEquals(\"/b\", f.getRootPaths()[0]);\n            assertEquals(\"/a\", f.getRootPaths()[1]);\n            assertEquals(FolderNameFilter.DEFAULT_ROOT_PRIORITY, f.getRootPriority(\"/a/foo\"));\n            assertEquals(200, f.getRootPriority(\"/b/foo\"));\n    \t}\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"@Override\n        public final void run() {\n            log.info(\"Background thread {} starting\", Thread.currentThread().getName());\n            try {\n                // open session\n                session = repository.loginAdministrative(repository.getDefaultWorkspace());\n\n                for (String path : roots) {\n                    listeners.add(new RootFolderListener(session, folderNameFilter, path, updateFoldersListTimer));\n                    log.debug(\"Configured root folder: {}\", path);\n                }\n\n                // Watch for events on the root - that might be one of our root folders\n                session.getWorkspace().getObservationManager().addEventListener(JcrInstaller.this,\n                        Event.NODE_ADDED | Event.NODE_REMOVED,\n                        \"/\",\n                        false, // isDeep\n                        null,\n                        null,\n                        true); // noLocal\n                log.debug(\"Watching for node events on / to detect removal/add of our root folders\");\n\n\n                // Find paths to watch and create WatchedFolders to manage them\n                watchedFolders = new LinkedList<WatchedFolder>();\n                for(String root : roots) {\n                    findPathsToWatch(root, watchedFolders);\n                }\n\n                // Scan watchedFolders and register resources with installer\n                final List<InstallableResource> resources = new LinkedList<InstallableResource>();\n                for(WatchedFolder f : watchedFolders) {\n                    final WatchedFolder.ScanResult r = f.scan();\n                    log.debug(\"Startup: {} provides resources {}\", f, r.toAdd);\n                    resources.addAll(r.toAdd);\n                }\n\n                log.debug(\"Registering {} resources with OSGi installer: {}\", resources.size(), resources);\n                installer.registerResources(URL_SCHEME, resources.toArray(new InstallableResource[resources.size()]));\n            } catch (final RepositoryException re) {\n                log.error(\"Repository exception during startup - deactivating installer!\", re);\n                active = false;\n                final ComponentContext ctx = componentContext;\n                if ( ctx  != null ) {\n                    final String name = (String) componentContext.getProperties().get(\n                            ComponentConstants.COMPONENT_NAME);\n                    ctx.disableComponent(name);\n                }\n            }\n            while (active) {\n                runOneCycle();\n            }\n            log.info(\"Background thread {} done\", Thread.currentThread().getName());\n            counters[RUN_LOOP_COUNTER] = -1;\n        }","id":22384,"modified_method":"@Override\n        public final void run() {\n            logger.info(\"Background thread {} starting\", Thread.currentThread().getName());\n            try {\n                // open session\n                session = repository.loginAdministrative(repository.getDefaultWorkspace());\n\n                for (String path : roots) {\n                    listeners.add(new RootFolderListener(session, folderNameFilter, path, updateFoldersListTimer));\n                    logger.debug(\"Configured root folder: {}\", path);\n                }\n\n                // Watch for events on the root - that might be one of our root folders\n                session.getWorkspace().getObservationManager().addEventListener(JcrInstaller.this,\n                        Event.NODE_ADDED | Event.NODE_REMOVED,\n                        \"/\",\n                        false, // isDeep\n                        null,\n                        null,\n                        true); // noLocal\n                logger.debug(\"Watching for node events on / to detect removal/add of our root folders\");\n\n\n                // Find paths to watch and create WatchedFolders to manage them\n                watchedFolders = new LinkedList<WatchedFolder>();\n                for(String root : roots) {\n                    findPathsToWatch(root, watchedFolders);\n                }\n\n                // Scan watchedFolders and register resources with installer\n                final List<InstallableResource> resources = new LinkedList<InstallableResource>();\n                for(WatchedFolder f : watchedFolders) {\n                    final WatchedFolder.ScanResult r = f.scan();\n                    logger.debug(\"Startup: {} provides resources {}\", f, r.toAdd);\n                    resources.addAll(r.toAdd);\n                }\n\n                logger.debug(\"Registering {} resources with OSGi installer: {}\", resources.size(), resources);\n                installer.registerResources(URL_SCHEME, resources.toArray(new InstallableResource[resources.size()]));\n            } catch (final RepositoryException re) {\n                logger.error(\"Repository exception during startup - deactivating installer!\", re);\n                active = false;\n                final ComponentContext ctx = componentContext;\n                if ( ctx  != null ) {\n                    final String name = (String) componentContext.getProperties().get(\n                            ComponentConstants.COMPONENT_NAME);\n                    ctx.disableComponent(name);\n                }\n            }\n            while (active) {\n                runOneCycle();\n            }\n            logger.info(\"Background thread {} done\", Thread.currentThread().getName());\n            counters[RUN_LOOP_COUNTER] = -1;\n        }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Add n to result if it is a folder that we must watch, and recurse into its children\n     * to do the same.\n     */\n    void findPathsUnderNode(final Node n, final List<WatchedFolder> result) throws RepositoryException {\n        final String path = n.getPath();\n        final int priority = folderNameFilter.getPriority(path);\n        if (priority > 0) {\n            result.add(new WatchedFolder(session, path, priority, converters));\n        }\n        final int depth = path.split(\"/\").length;\n        if(depth > maxWatchedFolderDepth) {\n            log.debug(\"Not recursing into {} due to maxWatchedFolderDepth={}\", path, maxWatchedFolderDepth);\n            return;\n        }\n        final NodeIterator it = n.getNodes();\n        while (it.hasNext()) {\n            findPathsUnderNode(it.nextNode(), result);\n        }\n    }","id":22385,"modified_method":"/**\n     * Add n to result if it is a folder that we must watch, and recurse into its children\n     * to do the same.\n     */\n    void findPathsUnderNode(final Node n, final List<WatchedFolder> result) throws RepositoryException {\n        final String path = n.getPath();\n        final int priority = folderNameFilter.getPriority(path);\n        if (priority > 0) {\n            result.add(new WatchedFolder(session, path, priority, converters));\n        }\n        final int depth = path.split(\"/\").length;\n        if(depth > maxWatchedFolderDepth) {\n            logger.debug(\"Not recursing into {} due to maxWatchedFolderDepth={}\", path, maxWatchedFolderDepth);\n            return;\n        }\n        final NodeIterator it = n.getNodes();\n        while (it.hasNext()) {\n            findPathsUnderNode(it.nextNode(), result);\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"public void onEvent(EventIterator it) {\n        // Got a DELETE or ADD on root - schedule folders rescan if one\n        // of our root folders is impacted\n        try {\n            while(it.hasNext()) {\n                final Event e = it.nextEvent();\n                log.debug(\"Got event {}\", e);\n\n                for(String root : roots) {\n                    if (e.getPath().startsWith(root)) {\n                        log.info(\"Got event for root {}, scheduling scanning of new folders\", root);\n                        updateFoldersListTimer.scheduleScan();\n                    }\n                }\n            }\n        } catch(RepositoryException re) {\n            log.warn(\"RepositoryException in onEvent\", re);\n        }\n    }","id":22386,"modified_method":"public void onEvent(EventIterator it) {\n        // Got a DELETE or ADD on root - schedule folders rescan if one\n        // of our root folders is impacted\n        try {\n            while(it.hasNext()) {\n                final Event e = it.nextEvent();\n                logger.debug(\"Got event {}\", e);\n\n                for(String root : roots) {\n                    if (e.getPath().startsWith(root)) {\n                        logger.info(\"Got event for root {}, scheduling scanning of new folders\", root);\n                        updateFoldersListTimer.scheduleScan();\n                    }\n                }\n            }\n        } catch(RepositoryException re) {\n            logger.warn(\"RepositoryException in onEvent\", re);\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/** Add new folders to watch if any have been detected\n     *  @return a list of InstallableResource that must be unregistered,\n     *  \tfor folders that have been removed\n     */\n    private List<String> updateFoldersList() throws Exception {\n        log.debug(\"Updating folder list.\");\n\n        final List<String> result = new LinkedList<String>();\n\n        final List<WatchedFolder> newFolders = new ArrayList<WatchedFolder>();\n\t    for(String root : roots) {\n\t        findPathsToWatch(root, newFolders);\n\t    }\n\t    for(WatchedFolder wf : newFolders) {\n\t        addWatchedFolder(wf);\n\t    }\n\n        // Check all WatchedFolder, in case some were deleted\n        final List<WatchedFolder> toRemove = new ArrayList<WatchedFolder>();\n        for(WatchedFolder wf : watchedFolders) {\n            log.debug(\"Item {} exists? {}\", wf.getPath(), session.itemExists(wf.getPath()));\n\n            if(!session.itemExists(wf.getPath())) {\n                result.addAll(wf.scan().toRemove);\n                wf.cleanup();\n                toRemove.add(wf);\n            }\n        }\n        for(WatchedFolder wf : toRemove) {\n            log.info(\"Deleting {}, path does not exist anymore\", wf);\n            watchedFolders.remove(wf);\n        }\n\n        return result;\n    }","id":22387,"modified_method":"/** Add new folders to watch if any have been detected\n     *  @return a list of InstallableResource that must be unregistered,\n     *  \tfor folders that have been removed\n     */\n    private List<String> updateFoldersList() throws Exception {\n        logger.debug(\"Updating folder list.\");\n\n        final List<String> result = new LinkedList<String>();\n\n        final List<WatchedFolder> newFolders = new ArrayList<WatchedFolder>();\n\t    for(String root : roots) {\n\t        findPathsToWatch(root, newFolders);\n\t    }\n\t    for(WatchedFolder wf : newFolders) {\n\t        addWatchedFolder(wf);\n\t    }\n\n        // Check all WatchedFolder, in case some were deleted\n        final List<WatchedFolder> toRemove = new ArrayList<WatchedFolder>();\n        for(WatchedFolder wf : watchedFolders) {\n            logger.debug(\"Item {} exists? {}\", wf.getPath(), session.itemExists(wf.getPath()));\n\n            if(!session.itemExists(wf.getPath())) {\n                result.addAll(wf.scan().toRemove);\n                wf.cleanup();\n                toRemove.add(wf);\n            }\n        }\n        for(WatchedFolder wf : toRemove) {\n            logger.info(\"Deleting {}, path does not exist anymore\", wf);\n            watchedFolders.remove(wf);\n        }\n\n        return result;\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deactivate this component\n     */\n    protected void deactivate(final ComponentContext context) {\n    \tlog.info(\"Deactivating Apache Sling JCR Installer\");\n\n    \tfinal long timeout = 30000L;\n        backgroundThread.active = false;\n        log.debug(\"Waiting for \" + backgroundThread.getName() + \" Thread to end...\");\n        backgroundThread.interrupt();\n    \ttry {\n            backgroundThread.join(timeout);\n    \t} catch(InterruptedException iex) {\n    \t    // ignore this as we want to shutdown\n    \t}\n        backgroundThread = null;\n\n        folderNameFilter = null;\n        watchedFolders = null;\n        converters.clear();\n        try {\n            if (session != null) {\n                for(RootFolderListener wfc : listeners) {\n                    wfc.cleanup(session);\n                }\n                session.getWorkspace().getObservationManager().removeEventListener(this);\n            }\n        } catch (final RepositoryException e) {\n            log.warn(\"Exception in deactivate()\", e);\n        }\n        if ( session != null ) {\n            session.logout();\n            session = null;\n        }\n        listeners.clear();\n        this.componentContext = null;\n    }","id":22388,"modified_method":"/**\n     * Deactivate this component\n     */\n    protected void deactivate(final ComponentContext context) {\n    \tlogger.info(\"Deactivating Apache Sling JCR Installer\");\n\n    \tfinal long timeout = 30000L;\n        backgroundThread.active = false;\n        logger.debug(\"Waiting for \" + backgroundThread.getName() + \" Thread to end...\");\n        backgroundThread.interrupt();\n    \ttry {\n            backgroundThread.join(timeout);\n    \t} catch(InterruptedException iex) {\n    \t    // ignore this as we want to shutdown\n    \t}\n        backgroundThread = null;\n\n        folderNameFilter = null;\n        watchedFolders = null;\n        converters.clear();\n        try {\n            if (session != null) {\n                for(RootFolderListener wfc : listeners) {\n                    wfc.cleanup(session);\n                }\n                session.getWorkspace().getObservationManager().removeEventListener(this);\n            }\n        } catch (final RepositoryException e) {\n            logger.warn(\"Exception in deactivate()\", e);\n        }\n        if ( session != null ) {\n            session.logout();\n            session = null;\n        }\n        listeners.clear();\n        this.componentContext = null;\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/** Run periodic scans of our watched folders, and watch for folders creations/deletions */\n    public void runOneCycle() {\n        log.debug(\"Running watch cycle.\");\n\n        try {\n            boolean didRefresh = true;\n\n            // Rescan WatchedFolders if needed\n            final boolean scanWf = WatchedFolder.getRescanTimer().expired();\n            if(scanWf) {\n                session.refresh(false);\n                didRefresh = true;\n                for(WatchedFolder wf : watchedFolders) {\n                    if(!wf.needsScan()) {\n                        continue;\n                    }\n                    WatchedFolder.getRescanTimer().reset();\n                    counters[SCAN_FOLDERS_COUNTER]++;\n                    final WatchedFolder.ScanResult sr = wf.scan();\n                    log.info(\"Registering resource with OSGi installer: {}\",sr.toAdd);\n                    log.info(\"Removing resource from OSGi installer: {}\", sr.toRemove);\n                    installer.updateResources(URL_SCHEME, sr.toAdd.toArray(new InstallableResource[sr.toAdd.size()]),\n                            sr.toRemove.toArray(new String[sr.toRemove.size()]));\n                }\n            }\n\n            // Update list of WatchedFolder if we got any relevant events,\n            // or if there were any WatchedFolder events\n            if(scanWf || updateFoldersListTimer.expired()) {\n                if (!didRefresh) {\n                    session.refresh(false);\n                    didRefresh = true;\n                }\n                updateFoldersListTimer.reset();\n                counters[UPDATE_FOLDERS_LIST_COUNTER]++;\n                final List<String> toRemove = updateFoldersList();\n                log.info(\"Removing resource from OSGi installer (folder deleted): {}\", toRemove);\n                installer.updateResources(URL_SCHEME, null,\n                        toRemove.toArray(new String[toRemove.size()]));\n            }\n\n            try {\n                Thread.sleep(RUN_LOOP_DELAY_MSEC);\n            } catch(InterruptedException ignore) {\n            }\n\n        } catch(Exception e) {\n            log.warn(\"Exception in run()\", e);\n            try {\n                Thread.sleep(RUN_LOOP_DELAY_MSEC);\n            } catch(InterruptedException ignore) {\n            }\n        }\n        counters[RUN_LOOP_COUNTER]++;\n    }","id":22389,"modified_method":"/** Run periodic scans of our watched folders, and watch for folders creations/deletions */\n    public void runOneCycle() {\n        logger.debug(\"Running watch cycle.\");\n\n        try {\n            boolean didRefresh = true;\n\n            // Rescan WatchedFolders if needed\n            final boolean scanWf = WatchedFolder.getRescanTimer().expired();\n            if(scanWf) {\n                session.refresh(false);\n                didRefresh = true;\n                for(WatchedFolder wf : watchedFolders) {\n                    if(!wf.needsScan()) {\n                        continue;\n                    }\n                    WatchedFolder.getRescanTimer().reset();\n                    counters[SCAN_FOLDERS_COUNTER]++;\n                    final WatchedFolder.ScanResult sr = wf.scan();\n                    logger.info(\"Registering resource with OSGi installer: {}\",sr.toAdd);\n                    logger.info(\"Removing resource from OSGi installer: {}\", sr.toRemove);\n                    installer.updateResources(URL_SCHEME, sr.toAdd.toArray(new InstallableResource[sr.toAdd.size()]),\n                            sr.toRemove.toArray(new String[sr.toRemove.size()]));\n                }\n            }\n\n            // Update list of WatchedFolder if we got any relevant events,\n            // or if there were any WatchedFolder events\n            if(scanWf || updateFoldersListTimer.expired()) {\n                if (!didRefresh) {\n                    session.refresh(false);\n                    didRefresh = true;\n                }\n                updateFoldersListTimer.reset();\n                counters[UPDATE_FOLDERS_LIST_COUNTER]++;\n                final List<String> toRemove = updateFoldersList();\n                logger.info(\"Removing resource from OSGi installer (folder deleted): {}\", toRemove);\n                installer.updateResources(URL_SCHEME, null,\n                        toRemove.toArray(new String[toRemove.size()]));\n            }\n\n            try {\n                Thread.sleep(RUN_LOOP_DELAY_MSEC);\n            } catch(InterruptedException ignore) {\n            }\n\n        } catch(Exception e) {\n            logger.warn(\"Exception in run()\", e);\n            try {\n                Thread.sleep(RUN_LOOP_DELAY_MSEC);\n            } catch(InterruptedException ignore) {\n            }\n        }\n        counters[RUN_LOOP_COUNTER]++;\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Activate this component.\n     */\n    protected void activate(final ComponentContext context) {\n        if (backgroundThread != null) {\n            throw new IllegalStateException(\"Expected backgroundThread to be null in activate()\");\n        }\n        this.componentContext = context;\n        log.info(\"Activating Apache Sling JCR Installer\");\n\n    \t// Setup converters\n    \tconverters.add(new FileNodeConverter());\n    \tconverters.add(new ConfigNodeConverter());\n\n    \t// Configurable max depth, system property (via bundle context) overrides default value\n    \tfinal Object obj = getPropertyValue(context, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \tif (obj != null) {\n    \t\t// depending on where it's coming from, obj might be a string or integer\n    \t\tmaxWatchedFolderDepth = Integer.valueOf(String.valueOf(obj)).intValue();\n            log.debug(\"Using configured ({}) folder name max depth '{}'\", PROP_INSTALL_FOLDER_MAX_DEPTH, maxWatchedFolderDepth);\n    \t} else {\n            maxWatchedFolderDepth = DEFAULT_FOLDER_MAX_DEPTH;\n            log.debug(\"Using default folder max depth {}, not provided by {}\", maxWatchedFolderDepth, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \t}\n\n    \t// Configurable folder regexp, system property overrides default value\n    \tString folderNameRegexp = (String)getPropertyValue(context, FOLDER_NAME_REGEXP_PROPERTY);\n    \tif(folderNameRegexp != null) {\n    \t\tfolderNameRegexp = folderNameRegexp.trim();\n            log.debug(\"Using configured ({}) folder name regexp '{}'\", FOLDER_NAME_REGEXP_PROPERTY, folderNameRegexp);\n    \t} else {\n    \t    folderNameRegexp = DEFAULT_FOLDER_NAME_REGEXP;\n            log.debug(\"Using default folder name regexp '{}', not provided by {}\", folderNameRegexp, FOLDER_NAME_REGEXP_PROPERTY);\n    \t}\n\n    \t// Setup folder filtering and watching\n        folderNameFilter = new FolderNameFilter(OsgiUtil.toStringArray(context.getProperties().get(PROP_SEARCH_PATH), DEFAULT_SEARCH_PATH),\n                folderNameRegexp, settings.getRunModes());\n        roots = folderNameFilter.getRootPaths();\n        backgroundThread = new StoppableThread();\n        backgroundThread.start();\n    }","id":22390,"modified_method":"/**\n     * Activate this component.\n     */\n    protected void activate(final ComponentContext context) {\n        if (backgroundThread != null) {\n            throw new IllegalStateException(\"Expected backgroundThread to be null in activate()\");\n        }\n        this.componentContext = context;\n        logger.info(\"Activating Apache Sling JCR Installer\");\n\n        this.newConfigPath = OsgiUtil.toString(context.getProperties().get(PROP_NEW_CONFIG_PATH), DEFAULT_NEW_CONFIG_PATH);\n        if ( !newConfigPath.endsWith(\"/\") ) {\n            this.newConfigPath = this.newConfigPath.concat(\"/\");\n        }\n        this.writeBack = OsgiUtil.toBoolean(context.getProperties().get(PROP_ENABLE_WRITEBACK), DEFAULT_ENABLE_WRITEBACK);\n\n    \t// Setup converters\n    \tconverters.add(new FileNodeConverter());\n    \tconverters.add(new ConfigNodeConverter());\n\n    \t// Configurable max depth, system property (via bundle context) overrides default value\n    \tfinal Object obj = getPropertyValue(context, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \tif (obj != null) {\n    \t\t// depending on where it's coming from, obj might be a string or integer\n    \t\tmaxWatchedFolderDepth = Integer.valueOf(String.valueOf(obj)).intValue();\n            logger.debug(\"Using configured ({}) folder name max depth '{}'\", PROP_INSTALL_FOLDER_MAX_DEPTH, maxWatchedFolderDepth);\n    \t} else {\n            maxWatchedFolderDepth = DEFAULT_FOLDER_MAX_DEPTH;\n            logger.debug(\"Using default folder max depth {}, not provided by {}\", maxWatchedFolderDepth, PROP_INSTALL_FOLDER_MAX_DEPTH);\n    \t}\n\n    \t// Configurable folder regexp, system property overrides default value\n    \tString folderNameRegexp = (String)getPropertyValue(context, FOLDER_NAME_REGEXP_PROPERTY);\n    \tif(folderNameRegexp != null) {\n    \t\tfolderNameRegexp = folderNameRegexp.trim();\n            logger.debug(\"Using configured ({}) folder name regexp '{}'\", FOLDER_NAME_REGEXP_PROPERTY, folderNameRegexp);\n    \t} else {\n    \t    folderNameRegexp = DEFAULT_FOLDER_NAME_REGEXP;\n            logger.debug(\"Using default folder name regexp '{}', not provided by {}\", folderNameRegexp, FOLDER_NAME_REGEXP_PROPERTY);\n    \t}\n\n    \t// Setup folder filtering and watching\n        folderNameFilter = new FolderNameFilter(OsgiUtil.toStringArray(context.getProperties().get(PROP_SEARCH_PATH), DEFAULT_SEARCH_PATH),\n                folderNameRegexp, settings.getRunModes());\n        roots = folderNameFilter.getRootPaths();\n        backgroundThread = new StoppableThread();\n        backgroundThread.start();\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/** Find the paths to watch under rootPath, according to our folderNameFilter,\n     * \tand add them to result */\n    void findPathsToWatch(final String rootPath, final List<WatchedFolder> result) throws RepositoryException {\n        Session s = null;\n\n        try {\n            s = repository.loginAdministrative(repository.getDefaultWorkspace());\n            if (!s.itemExists(rootPath) || !s.getItem(rootPath).isNode() ) {\n                log.info(\"Bundles root node {} not found, ignored\", rootPath);\n            } else {\n                log.debug(\"Bundles root node {} found, looking for bundle folders inside it\", rootPath);\n                final Node n = (Node)s.getItem(rootPath);\n                findPathsUnderNode(n, result);\n            }\n        } finally {\n            if (s != null) {\n                s.logout();\n            }\n        }\n    }","id":22391,"modified_method":"/** Find the paths to watch under rootPath, according to our folderNameFilter,\n     * \tand add them to result */\n    void findPathsToWatch(final String rootPath, final List<WatchedFolder> result) throws RepositoryException {\n        Session s = null;\n\n        try {\n            s = repository.loginAdministrative(repository.getDefaultWorkspace());\n            if (!s.itemExists(rootPath) || !s.getItem(rootPath).isNode() ) {\n                logger.info(\"Bundles root node {} not found, ignored\", rootPath);\n            } else {\n                logger.debug(\"Bundles root node {} found, looking for bundle folders inside it\", rootPath);\n                final Node n = (Node)s.getItem(rootPath);\n                findPathsUnderNode(n, result);\n            }\n        } finally {\n            if (s != null) {\n                s.logout();\n            }\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.installer.api.ResourceChangeListener#resourceRemoved(java.lang.String, java.lang.String)\n     */\n    public void resourceRemoved(final String resourceType, String resourceId) {\n        String key = resourceType + ':' + resourceId;\n        synchronized ( this.resourcesLock ) {\n            final EntityResourceList erl = this.persistentList.getEntityResourceList(key);\n            logger.info(\"Removed {}:{}: {}\", new Object[] {resourceType, resourceId, erl});\n            // if this is not registered at all, we can simply ignore this\n            if ( erl != null ) {\n                resourceId = erl.getResourceId();\n                key = resourceType + ':' + resourceId;\n                final TaskResource tr = erl.getFirstResource();\n                if ( tr != null ) {\n                    if ( tr.getState() != ResourceState.IGNORED ) {\n                        final UpdateHandler handler = this.findHandler(tr.getScheme());\n                        if ( handler == null ) {\n                            logger.info(\"No handler found to handle remove of resource with scheme {}\", tr.getScheme());\n                        } else {\n                            // we don't need to check the result, we just check if a result is returned\n                            if ( handler.handleUpdate(resourceType, resourceId, tr.getURL(), null, null) != null ) {\n                                // We first set the state of the resource to uninstall to make setFinishState work in all cases\n                                ((RegisteredResourceImpl)tr).setState(ResourceState.UNINSTALL);\n                                erl.setFinishState(ResourceState.UNINSTALLED);\n                                erl.compact();\n                                this.persistentList.save();\n                                this.wakeUp();\n                            } else {\n                                logger.info(\"No handler found to handle remove of resource with scheme {}\", tr.getScheme());\n                            }\n                        }\n                    } else {\n                        // if it has been ignored before, we activate it now again!\n                        ((RegisteredResourceImpl)tr).setState(ResourceState.INSTALL);\n                        this.persistentList.save();\n                        this.wakeUp();\n                    }\n                }\n            }\n        }\n    }","id":22392,"modified_method":"/**\n     * @see org.apache.sling.installer.api.ResourceChangeListener#resourceRemoved(java.lang.String, java.lang.String)\n     */\n    public void resourceRemoved(final String resourceType, String resourceId) {\n        String key = resourceType + ':' + resourceId;\n        synchronized ( this.resourcesLock ) {\n            final EntityResourceList erl = this.persistentList.getEntityResourceList(key);\n            logger.debug(\"Removed {} : {}\", key, erl);\n            // if this is not registered at all, we can simply ignore this\n            if ( erl != null ) {\n                resourceId = erl.getResourceId();\n                key = resourceType + ':' + resourceId;\n                final TaskResource tr = erl.getFirstResource();\n                if ( tr != null ) {\n                    if ( tr.getState() != ResourceState.IGNORED ) {\n                        final UpdateHandler handler = this.findHandler(tr.getScheme());\n                        if ( handler == null ) {\n                            logger.debug(\"No handler found to handle remove of resource with scheme {}\", tr.getScheme());\n                        } else {\n                            // we don't need to check the result, we just check if a result is returned\n                            if ( handler.handleUpdate(resourceType, resourceId, tr.getURL(), null, null) != null ) {\n                                // We first set the state of the resource to uninstall to make setFinishState work in all cases\n                                ((RegisteredResourceImpl)tr).setState(ResourceState.UNINSTALL);\n                                erl.setFinishState(ResourceState.UNINSTALLED);\n                                erl.compact();\n                                this.persistentList.save();\n                                this.wakeUp();\n                            } else {\n                                logger.debug(\"No handler found to handle remove of resource with scheme {}\", tr.getScheme());\n                            }\n                        }\n                    } else {\n                        // if it has been ignored before, we activate it now again!\n                        ((RegisteredResourceImpl)tr).setState(ResourceState.INSTALL);\n                        this.persistentList.save();\n                        this.wakeUp();\n                    }\n                }\n            }\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void run() {\n        this.init();\n        while (active) {\n            logger.debug(\"Starting new cycle\");\n\n            this.mergeNewlyRegisteredResources();\n\n            // invoke transformers\n            this.transformResources();\n\n            // execute tasks\n            final SortedSet<InstallTask> tasks = this.computeTasks();\n            final boolean tasksCreated = !tasks.isEmpty();\n            this.executeTasks(tasks);\n\n            // clean up and save\n            this.cleanupInstallableResources();\n\n            // if we don't have any tasks, we go to sleep\n            if (!tasksCreated) {\n                synchronized ( this.resourcesLock ) {\n  \t\t            // before we go to sleep, check if new resources arrived in the meantime\n                    if ( !this.hasNewResources()) {\n                        // No tasks to execute - wait until new resources are\n                        // registered\n                        logger.debug(\"No tasks to process, going idle\");\n                        try {\n                            this.resourcesLock.wait();\n                        } catch (InterruptedException ignore) {}\n                        logger.debug(\"Notified of new resources, back to work\");\n                    }\n                }\n            }\n            // Some integration tests depend on this delay, make sure to\n            // rerun/adapt them if changing this value\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException ignore) {}\n        }\n    }","id":22393,"modified_method":"@Override\n    public void run() {\n        this.init();\n        while (active) {\n            logger.debug(\"Starting new cycle\");\n\n            this.mergeNewlyRegisteredResources();\n\n            // invoke transformers - sync as we change state\n            synchronized ( this.resourcesLock ) {\n                this.transformResources();\n            }\n\n            // execute tasks\n            final SortedSet<InstallTask> tasks = this.computeTasks();\n            final boolean tasksCreated = !tasks.isEmpty();\n\n            // sync as we might change state\n            synchronized ( this.resourcesLock ) {\n                this.executeTasks(tasks);\n\n                // clean up and save\n                this.cleanupInstallableResources();\n            }\n\n            // if we don't have any tasks, we go to sleep\n            if (!tasksCreated) {\n                synchronized ( this.resourcesLock ) {\n  \t\t            // before we go to sleep, check if new resources arrived in the meantime\n                    if ( !this.hasNewResources()) {\n                        // No tasks to execute - wait until new resources are\n                        // registered\n                        logger.debug(\"No tasks to process, going idle\");\n                        try {\n                            this.resourcesLock.wait();\n                        } catch (InterruptedException ignore) {}\n                        logger.debug(\"Notified of new resources, back to work\");\n                    }\n                }\n            }\n            // Some integration tests depend on this delay, make sure to\n            // rerun/adapt them if changing this value\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException ignore) {}\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.installer.api.ResourceChangeListener#resourceAddedOrUpdated(java.lang.String, java.lang.String, java.io.InputStream, java.util.Dictionary)\n     */\n    public void resourceAddedOrUpdated(final String resourceType,\n            String resourceId,\n            final InputStream is,\n            final Dictionary<String, Object> dict) {\n        String key = resourceType + ':' + resourceId;\n        try {\n            final ResourceData data = ResourceData.create(is, dict);\n            synchronized ( this.resourcesLock ) {\n                final EntityResourceList erl = this.persistentList.getEntityResourceList(key);\n                if ( erl != null ) {\n                    resourceId = erl.getResourceId();\n                    key = resourceType + ':' + resourceId;\n                }\n                logger.info(\"Added or updated {}:{}: {}\", new Object[] {resourceType, resourceId, erl});\n\n                // we first check for update\n                boolean updated = false;\n                if ( erl != null && erl.getFirstResource() != null ) {\n                    // check digest for dictionaries\n                    final TaskResource tr = erl.getFirstResource();\n                    if ( dict != null ) {\n                        final String digest = FileDataStore.computeDigest(dict);\n                        if ( tr.getState() == ResourceState.INSTALLED && tr.getDigest().equals(digest) ) {\n                            logger.debug(\"Resource did not change {}:{}\", resourceType, resourceId);\n                            return;\n                        }\n                    }\n                    final UpdateHandler handler = this.findHandler(tr.getScheme());\n                    if ( handler == null ) {\n                        logger.info(\"No handler found to handle update of resource with scheme {}\", tr.getScheme());\n                    } else {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = handler.handleUpdate(resourceType, resourceId, tr.getURL(), localIS, data.getDictionary());\n                            if ( result != null ) {\n                                ((RegisteredResourceImpl)tr).update(\n                                        data.getDataFile(), data.getDictionary(),\n                                        data.getDigest(result.getURL(), result.getDigest()),\n                                        result.getPriority());\n                                // TODO : Handle move and add\n                                updated = true;\n                                // We first set the state of the resource to install to make setFinishState work in all cases\n                                ((RegisteredResourceImpl)tr).setState(ResourceState.INSTALL);\n                                erl.setFinishState(ResourceState.INSTALLED);\n                                erl.compact();\n                                this.persistentList.save();\n                                this.wakeUp();\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n                boolean created = false;\n                if ( !updated ) {\n                    // create\n                    final List<UpdateHandler> handlerList = this.updateHandlerTracker.getSortedServices();\n                    for(final UpdateHandler handler : handlerList) {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = handler.handleUpdate(resourceType, resourceId, null, localIS, data.getDictionary());\n                            if ( result != null ) {\n                                final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                        result.getResourceId(),\n                                        null,\n                                        data.getDictionary(),\n                                        (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                        data.getDigest(result.getURL(), result.getDigest()),\n                                        result.getPriority(),\n                                        data.getDataFile());\n                                final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                final TransformationResult transRes = new TransformationResult();\n                                transRes.setId(resourceId);\n                                transRes.setResourceType(resourceType);\n                                this.persistentList.transform(rr, new TransformationResult[] {\n                                        transRes\n                                });\n                                this.persistentList.save();\n                                created = true;\n                                this.wakeUp();\n                                break;\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n                    if ( !created ) {\n                        logger.info(\"No handler found to handle creation of resource {}:{}\", resourceType, resourceId);\n                    }\n                }\n\n            }\n        } catch (final IOException ioe) {\n            logger.error(\"Unable to handle resource add or update of \" + key, ioe);\n        } finally {\n            // always close the input stream!\n            if ( is != null ) {\n                try {\n                    is.close();\n                } catch (final IOException ignore) {\n                    // ignore\n                }\n            }\n        }\n    }","id":22394,"modified_method":"/**\n     * @see org.apache.sling.installer.api.ResourceChangeListener#resourceAddedOrUpdated(java.lang.String, java.lang.String, java.io.InputStream, java.util.Dictionary)\n     */\n    public void resourceAddedOrUpdated(final String resourceType,\n            String entityId,\n            final InputStream is,\n            final Dictionary<String, Object> dict) {\n        String key = resourceType + ':' + entityId;\n        try {\n            final ResourceData data = ResourceData.create(is, dict);\n            synchronized ( this.resourcesLock ) {\n                final EntityResourceList erl = this.persistentList.getEntityResourceList(key);\n                if ( erl != null ) {\n                    entityId = erl.getResourceId();\n                    key = resourceType + ':' + entityId;\n                }\n                logger.debug(\"Added or updated {} : {}\", key, erl);\n\n                // we first check for update\n                boolean updated = false;\n                if ( erl != null && erl.getFirstResource() != null ) {\n                    // check digest for dictionaries\n                    final TaskResource tr = erl.getFirstResource();\n                    if ( dict != null ) {\n                        final String digest = FileDataStore.computeDigest(dict);\n                        if ( tr.getState() == ResourceState.INSTALLED && tr.getDigest().equals(digest) ) {\n                            logger.debug(\"Resource did not change {}\", key);\n                            return;\n                        }\n                    }\n                    final UpdateHandler handler = this.findHandler(tr.getScheme());\n                    if ( handler == null ) {\n                        logger.debug(\"No handler found to handle update of resource with scheme {}\", tr.getScheme());\n                    } else {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = handler.handleUpdate(resourceType, entityId, tr.getURL(), localIS, data.getDictionary());\n                            if ( result != null ) {\n                                if ( !result.getURL().equals(tr.getURL()) && !result.getResourceIsMoved() ) {\n                                    // resource has been added!\n                                    final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                            result.getResourceId(),\n                                            null,\n                                            data.getDictionary(),\n                                            (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                            data.getDigest(result.getURL(), result.getDigest()),\n                                            result.getPriority(),\n                                            data.getDataFile());\n                                    final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                    final TransformationResult transRes = new TransformationResult();\n                                    transRes.setId(entityId);\n                                    transRes.setResourceType(resourceType);\n                                    this.persistentList.transform(rr, new TransformationResult[] {\n                                            transRes\n                                    });\n                                    final EntityResourceList newGroup = this.persistentList.getEntityResourceList(key);\n                                    newGroup.setFinishState(ResourceState.INSTALLED);\n                                    newGroup.compact();\n                                } else {\n                                    // resource has been updated or moved\n                                    ((RegisteredResourceImpl)tr).update(\n                                            data.getDataFile(), data.getDictionary(),\n                                            data.getDigest(result.getURL(), result.getDigest()),\n                                            result.getPriority(),\n                                            result.getURL());\n                                    // We first set the state of the resource to install to make setFinishState work in all cases\n                                    ((RegisteredResourceImpl)tr).setState(ResourceState.INSTALL);\n                                    erl.setFinishState(ResourceState.INSTALLED);\n                                    erl.compact();\n                                }\n                                updated = true;\n                                this.persistentList.save();\n                                this.wakeUp();\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n                boolean created = false;\n                if ( !updated ) {\n                    // create\n                    final List<UpdateHandler> handlerList = this.updateHandlerTracker.getSortedServices();\n                    for(final UpdateHandler handler : handlerList) {\n                        final InputStream localIS = data.getInputStream();\n                        try {\n                            final UpdateResult result = handler.handleUpdate(resourceType, entityId, null, localIS, data.getDictionary());\n                            if ( result != null ) {\n                                final InternalResource internalResource = new InternalResource(result.getScheme(),\n                                        result.getResourceId(),\n                                        null,\n                                        data.getDictionary(),\n                                        (data.getDictionary() != null ? InstallableResource.TYPE_PROPERTIES : InstallableResource.TYPE_FILE),\n                                        data.getDigest(result.getURL(), result.getDigest()),\n                                        result.getPriority(),\n                                        data.getDataFile());\n                                final RegisteredResource rr = this.persistentList.addOrUpdate(internalResource);\n                                final TransformationResult transRes = new TransformationResult();\n                                transRes.setId(entityId);\n                                transRes.setResourceType(resourceType);\n                                this.persistentList.transform(rr, new TransformationResult[] {\n                                        transRes\n                                });\n                                final EntityResourceList newGroup = this.persistentList.getEntityResourceList(key);\n                                newGroup.setFinishState(ResourceState.INSTALLED);\n                                newGroup.compact();\n                                this.persistentList.save();\n                                created = true;\n                                this.wakeUp();\n                                break;\n                            }\n                        } finally {\n                            if ( localIS != null ) {\n                                // always close the input stream!\n                                try {\n                                    localIS.close();\n                                } catch (final IOException ignore) {\n                                    // ignore\n                                }\n                            }\n                        }\n                    }\n                    if ( !created ) {\n                        logger.debug(\"No handler found to handle creation of resource {}\", key);\n                    }\n                }\n\n            }\n        } catch (final IOException ioe) {\n            logger.error(\"Unable to handle resource add or update of \" + key, ioe);\n        } finally {\n            // always close the input stream!\n            if ( is != null ) {\n                try {\n                    is.close();\n                } catch (final IOException ignore) {\n                    // ignore\n                }\n            }\n        }\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"public void update(final File file,\n            final Dictionary<String, Object> dict,\n            final String digest,\n            final int priority) {\n        this.removeDataFile();\n        if ( file != null ) {\n            this.dataFile = file;\n        } else {\n            while ( !this.dictionary.isEmpty() ) {\n                this.dictionary.remove(this.dictionary.keys().nextElement());\n            }\n            final Enumeration<String> keys = dict.keys();\n            while ( keys.hasMoreElements() ) {\n                final String key = keys.nextElement();\n                this.dictionary.put(key, dict.get(key));\n            }\n        }\n        this.digest = digest;\n        this.priority = priority;\n    }","id":22395,"modified_method":"public void update(final File file,\n            final Dictionary<String, Object> dict,\n            final String digest,\n            final int priority,\n            final String url) {\n        this.removeDataFile();\n        if ( file != null ) {\n            this.dataFile = file;\n        } else {\n            while ( !this.dictionary.isEmpty() ) {\n                this.dictionary.remove(this.dictionary.keys().nextElement());\n            }\n            final Enumeration<String> keys = dict.keys();\n            while ( keys.hasMoreElements() ) {\n                final String key = keys.nextElement();\n                this.dictionary.put(key, dict.get(key));\n            }\n        }\n        this.digest = digest;\n        this.priority = priority;\n        this.url = url;\n        final int pos = url.indexOf(':');\n        this.urlScheme = url.substring(0, pos);\n    }","commit_id":"89648bbbefc66ddbe6ee12dcde806c9463782eff","url":"https://github.com/apache/sling"},{"original_method":"private void checkModifiers(@Nullable JetModifierList modifierList) {\n        checkModalityModifiers(modifierList);\n        checkVisibilityModifiers(modifierList);\n    }","id":22396,"modified_method":"private void checkModifiers(@Nullable JetModifierList modifierList, @NotNull DeclarationDescriptor descriptor) {\n        checkModalityModifiers(modifierList);\n        checkVisibilityModifiers(modifierList, descriptor);\n    }","commit_id":"aefabd132e255201739d97bc0998d136b782350d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkDeclaredTypeInPublicMember(JetNamedDeclaration member, CallableMemberDescriptor memberDescriptor) {\n        boolean hasDeferredType;\n        if (member instanceof JetProperty) {\n            hasDeferredType = ((JetProperty) member).getPropertyTypeRef() == null && DescriptorResolver.hasBody((JetProperty) member);\n        }\n        else {\n            assert member instanceof JetFunction;\n            JetFunction function = (JetFunction) member;\n            hasDeferredType = function.getReturnTypeRef() == null && function.getBodyExpression() != null && !function.hasBlockBody();\n        }\n        if ((memberDescriptor.getVisibility() == Visibility.PUBLIC || memberDescriptor.getVisibility() == Visibility.PROTECTED) && hasDeferredType) {\n            trace.report(PUBLIC_MEMBER_SHOULD_SPECIFY_TYPE.on(member));\n        }\n    }","id":22397,"modified_method":"private void checkDeclaredTypeInPublicMember(JetNamedDeclaration member, CallableMemberDescriptor memberDescriptor) {\n        boolean hasDeferredType;\n        if (member instanceof JetProperty) {\n            hasDeferredType = ((JetProperty) member).getPropertyTypeRef() == null && DescriptorResolver.hasBody((JetProperty) member);\n        }\n        else {\n            assert member instanceof JetFunction;\n            JetFunction function = (JetFunction) member;\n            hasDeferredType = function.getReturnTypeRef() == null && function.getBodyExpression() != null && !function.hasBlockBody();\n        }\n        if ((memberDescriptor.getVisibility().isPublicAPI()) && hasDeferredType) {\n            trace.report(PUBLIC_MEMBER_SHOULD_SPECIFY_TYPE.on(member));\n        }\n    }","commit_id":"aefabd132e255201739d97bc0998d136b782350d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkVisibilityModifiers(@Nullable JetModifierList modifierList) {\n        if (modifierList == null) return;\n\n        checkCompatibility(modifierList, Lists.newArrayList(JetTokens.PRIVATE_KEYWORD, JetTokens.PROTECTED_KEYWORD, JetTokens.PUBLIC_KEYWORD, JetTokens.INTERNAL_KEYWORD),\n                           Lists.<JetToken>newArrayList(JetTokens.PROTECTED_KEYWORD, JetTokens.INTERNAL_KEYWORD));\n    }","id":22398,"modified_method":"private void checkVisibilityModifiers(@Nullable JetModifierList modifierList, @NotNull DeclarationDescriptor descriptor) {\n        if (modifierList == null) return;\n\n        DeclarationDescriptor containingDeclaration = descriptor.getContainingDeclaration();\n        if (containingDeclaration instanceof NamespaceDescriptor) {\n            if (modifierList.hasModifier(JetTokens.PROTECTED_KEYWORD)) {\n                trace.report(Errors.PACKAGE_MEMBER_CANNOT_BE_PROTECTED.on(modifierList.getModifierNode(JetTokens.PROTECTED_KEYWORD).getPsi()));\n            }\n        }\n\n        checkCompatibility(modifierList, Lists.newArrayList(JetTokens.PRIVATE_KEYWORD, JetTokens.PROTECTED_KEYWORD, JetTokens.PUBLIC_KEYWORD, JetTokens.INTERNAL_KEYWORD),\n                           Lists.<JetToken>newArrayList(JetTokens.PROTECTED_KEYWORD, JetTokens.INTERNAL_KEYWORD));\n    }","commit_id":"aefabd132e255201739d97bc0998d136b782350d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void process() {\n        Map<JetClass, MutableClassDescriptor> classes = context.getClasses();\n        for (Map.Entry<JetClass, MutableClassDescriptor> entry : classes.entrySet()) {\n            JetClass aClass = entry.getKey();\n            MutableClassDescriptor classDescriptor = entry.getValue();\n            if (!context.completeAnalysisNeeded(aClass)) continue;\n\n            checkClass(aClass, classDescriptor);\n            checkModifiers(aClass.getModifierList());\n        }\n\n        Map<JetObjectDeclaration, MutableClassDescriptor> objects = context.getObjects();\n        for (Map.Entry<JetObjectDeclaration, MutableClassDescriptor> entry : objects.entrySet()) {\n            JetObjectDeclaration objectDeclaration = entry.getKey();\n            MutableClassDescriptor objectDescriptor = entry.getValue();\n\n            if (!context.completeAnalysisNeeded(objectDeclaration)) continue;\n            checkObject(objectDeclaration, objectDescriptor);\n        }\n\n        Map<JetNamedFunction, SimpleFunctionDescriptor> functions = context.getFunctions();\n        for (Map.Entry<JetNamedFunction, SimpleFunctionDescriptor> entry : functions.entrySet()) {\n            JetNamedFunction function = entry.getKey();\n            SimpleFunctionDescriptor functionDescriptor = entry.getValue();\n\n            if (!context.completeAnalysisNeeded(function)) continue;\n            checkFunction(function, functionDescriptor);\n            checkModifiers(function.getModifierList());\n        }\n\n        Map<JetProperty, PropertyDescriptor> properties = context.getProperties();\n        for (Map.Entry<JetProperty, PropertyDescriptor> entry : properties.entrySet()) {\n            JetProperty property = entry.getKey();\n            PropertyDescriptor propertyDescriptor = entry.getValue();\n\n            if (!context.completeAnalysisNeeded(property)) continue;\n            checkProperty(property, propertyDescriptor);\n            checkModifiers(property.getModifierList());\n        }\n\n    }","id":22399,"modified_method":"public void process() {\n        Map<JetClass, MutableClassDescriptor> classes = context.getClasses();\n        for (Map.Entry<JetClass, MutableClassDescriptor> entry : classes.entrySet()) {\n            JetClass aClass = entry.getKey();\n            MutableClassDescriptor classDescriptor = entry.getValue();\n            if (!context.completeAnalysisNeeded(aClass)) continue;\n\n            checkClass(aClass, classDescriptor);\n            checkModifiers(aClass.getModifierList(), classDescriptor);\n        }\n\n        Map<JetObjectDeclaration, MutableClassDescriptor> objects = context.getObjects();\n        for (Map.Entry<JetObjectDeclaration, MutableClassDescriptor> entry : objects.entrySet()) {\n            JetObjectDeclaration objectDeclaration = entry.getKey();\n            MutableClassDescriptor objectDescriptor = entry.getValue();\n\n            if (!context.completeAnalysisNeeded(objectDeclaration)) continue;\n            checkObject(objectDeclaration, objectDescriptor);\n        }\n\n        Map<JetNamedFunction, SimpleFunctionDescriptor> functions = context.getFunctions();\n        for (Map.Entry<JetNamedFunction, SimpleFunctionDescriptor> entry : functions.entrySet()) {\n            JetNamedFunction function = entry.getKey();\n            SimpleFunctionDescriptor functionDescriptor = entry.getValue();\n\n            if (!context.completeAnalysisNeeded(function)) continue;\n            checkFunction(function, functionDescriptor);\n            checkModifiers(function.getModifierList(), functionDescriptor);\n        }\n\n        Map<JetProperty, PropertyDescriptor> properties = context.getProperties();\n        for (Map.Entry<JetProperty, PropertyDescriptor> entry : properties.entrySet()) {\n            JetProperty property = entry.getKey();\n            PropertyDescriptor propertyDescriptor = entry.getValue();\n\n            if (!context.completeAnalysisNeeded(property)) continue;\n            checkProperty(property, propertyDescriptor);\n            checkModifiers(property.getModifierList(), propertyDescriptor);\n        }\n\n    }","commit_id":"aefabd132e255201739d97bc0998d136b782350d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generatedMethod(JetExpression bodyExpressions,\n            JvmMethodSignature jvmSignature,\n            boolean needJetAnnotations, @Nullable String propertyTypeSignature,\n            CodegenContexts.MethodContext context,\n            FunctionDescriptor functionDescriptor,\n            JetDeclarationWithBody fun\n    )\n    {\n        if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {\n            throw new IllegalStateException(\"must not generate code for fake overrides\");\n        }\n\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        List<TypeParameterDescriptor> typeParameters = (functionDescriptor instanceof PropertyAccessorDescriptor ? ((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(): functionDescriptor).getTypeParameters();\n\n        int flags = ACC_PUBLIC; // TODO.\n        \n        if (!functionDescriptor.getValueParameters().isEmpty()\n                && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)\n                        .getVarargElementType() != null)\n        {\n            flags |= ACC_VARARGS;\n        }\n\n        Modality modality = functionDescriptor.getModality();\n        if (modality == Modality.FINAL) {\n            flags |= ACC_FINAL;\n        }\n\n        OwnerKind kind = context.getContextKind();\n        \n        if (kind == OwnerKind.TRAIT_IMPL) {\n            needJetAnnotations = false;\n        }\n\n        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n\n        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {\n            boolean isStatic = kind == OwnerKind.NAMESPACE || kind instanceof OwnerKind.StaticDelegateKind;\n            if (isStatic || kind == OwnerKind.TRAIT_IMPL)\n                flags |= ACC_STATIC;\n\n            boolean isAbstract = (\n                        modality == Modality.ABSTRACT\n                        || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())\n                    ) && !isStatic && kind != OwnerKind.TRAIT_IMPL;\n            if (isAbstract) flags |= ACC_ABSTRACT;\n            \n            final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);\n            AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);\n            if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES) {\n                int start = 0;\n                if (needJetAnnotations) {\n                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {\n                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter(),\n                                                                      ((PropertyAccessorDescriptor) functionDescriptor)\n                                                                              .getCorrespondingProperty(),\n                                                                      functionDescriptor.getVisibility());\n                    }\n                    else if (functionDescriptor instanceof SimpleFunctionDescriptor) {\n                        if (propertyTypeSignature != null) {\n                            throw new IllegalStateException();\n                        }\n                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                        BitSet kotlinFlags = new BitSet();\n                        if (CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {\n                            kotlinFlags.set(modality == Modality.FINAL\n                                            ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT\n                                            : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);\n                        }\n                        if (functionDescriptor.getVisibility() == Visibilities.INTERNAL) {\n                            kotlinFlags.set(JvmStdlibNames.FLAG_INTERNAL_BIT);\n                        }\n                        else if (functionDescriptor.getVisibility() == Visibilities.PRIVATE) {\n                            kotlinFlags.set(JvmStdlibNames.FLAG_PRIVATE_BIT);\n                        }\n                        aw.writeFlags(kotlinFlags);\n                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                        aw.visitEnd();\n                    }\n                    else {\n                        throw new IllegalStateException();\n                    }\n\n                    if (receiverParameter.exists()) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, start++);\n                        av.writeName(\"this$receiver\");\n                        av.writeNullable(receiverParameter.getType().isNullable());\n                        av.writeReceiver();\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                    for(int i = 0; i != paramDescrs.size(); ++i) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i + start);\n                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);\n                        av.writeName(parameterDescriptor.getName().getName());\n                        av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());\n                        av.writeNullable(parameterDescriptor.getType().isNullable());\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                }\n            }\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                StubCodegen.generateStubCode(mv);\n            }\n\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                mv.visitCode();\n                \n                Label methodBegin = new Label();\n                mv.visitLabel(methodBegin);\n                \n                FrameMap frameMap = context.prepareFrame(state.getInjector().getJetTypeMapper());\n\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);\n\n                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n                int add = 0;\n\n                if (kind == OwnerKind.TRAIT_IMPL)\n                    add++;\n\n                if (receiverParameter.exists())\n                    add++;\n\n                for (int i = 0; i < paramDescrs.size(); i++) {\n                    ValueParameterDescriptor parameter = paramDescrs.get(i);\n                    frameMap.enter(parameter, argTypes[i+add].getSize());\n                }\n\n                if (!isStatic && (kind instanceof OwnerKind.DelegateKind) != (functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                    throw new IllegalStateException(\"mismatching kind in \" + functionDescriptor);\n                }\n\n                Map<Name, Label> mapLabelsToDivideLocalVarVisibilityForSharedVar = new HashMap<Name, Label>();\n\n                if (kind instanceof OwnerKind.StaticDelegateKind) {\n                    OwnerKind.StaticDelegateKind dk = (OwnerKind.StaticDelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    for (int i = 0, k = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(k, argType);\n                        k += argType.getSize();\n                    }\n                    iv.invokestatic(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else if (kind instanceof OwnerKind.DelegateKind) {\n                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                    for (int i = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(i + 1, argType);\n                    }\n                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else {\n                    for (ValueParameterDescriptor parameter : paramDescrs) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        if (sharedVarType != null) {\n                            Type localVarType = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                            int index = frameMap.getIndex(parameter);\n                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());\n                            mv.visitInsn(DUP);\n                            mv.visitInsn(DUP);\n                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), \"<init>\", \"()V\");\n                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);\n                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), \"ref\", StackValue.refType(localVarType).getDescriptor());\n\n                            Label labelToDivideLocalVarForSharedVarVisibility = new Label();\n                            mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);\n                            mapLabelsToDivideLocalVarVisibilityForSharedVar.put(parameter.getName(), labelToDivideLocalVarForSharedVarVisibility);\n\n                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);\n                        }\n                    }\n\n                    codegen.returnExpression(bodyExpressions);\n                }\n                \n                Label methodEnd = new Label();\n                mv.visitLabel(methodEnd);\n\n                Collection<String> localVariableNames = new HashSet<String>();\n                localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());\n                for (ValueParameterDescriptor parameterDescriptor : paramDescrs) {\n                    localVariableNames.add(parameterDescriptor.getName().getName());\n                }\n\n                int k = 0;\n\n                if (expectedThisObject.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n                else if (fun instanceof JetFunctionLiteralExpression || CodegenUtil.isLocalFun(functionDescriptor, state.getBindingContext())) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(\n                            context.getThisDescriptor().getDefaultType(), MapTypeMode.VALUE);\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                if (receiverParameter.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this$receiver\", type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                for (ValueParameterDescriptor parameter : paramDescrs) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n\n                    Label divideLabel = mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());\n                    String parameterName = parameter.getName().getName();\n                    if (divideLabel != null) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        mv.visitLocalVariable(parameterName, type.getDescriptor(), null, methodBegin, divideLabel, k);\n\n                        String nameForSharedVar = CodegenUtil.generateTmpVariableName(localVariableNames);\n                        localVariableNames.add(nameForSharedVar);\n\n                        mv.visitLocalVariable(nameForSharedVar, sharedVarType.getDescriptor(), null, divideLabel, methodEnd, k);\n                        k += Math.max(type.getSize(), sharedVarType.getSize());\n                    }   else {\n                        mv.visitLocalVariable(parameter.getName().getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);\n                        k += type.getSize();\n                    }\n                }\n\n                endVisit(mv, null, fun);\n                mv.visitEnd();\n\n                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n            }\n        }\n\n        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n    }","id":22400,"modified_method":"private void generatedMethod(JetExpression bodyExpressions,\n            JvmMethodSignature jvmSignature,\n            boolean needJetAnnotations, @Nullable String propertyTypeSignature,\n            CodegenContexts.MethodContext context,\n            FunctionDescriptor functionDescriptor,\n            JetDeclarationWithBody fun\n    )\n    {\n        if (functionDescriptor.getKind() == CallableMemberDescriptor.Kind.FAKE_OVERRIDE) {\n            throw new IllegalStateException(\"must not generate code for fake overrides\");\n        }\n\n        List<ValueParameterDescriptor> paramDescrs = functionDescriptor.getValueParameters();\n        List<TypeParameterDescriptor> typeParameters = (functionDescriptor instanceof PropertyAccessorDescriptor ? ((PropertyAccessorDescriptor)functionDescriptor).getCorrespondingProperty(): functionDescriptor).getTypeParameters();\n\n        int flags = ACC_PUBLIC; // TODO.\n        \n        if (!functionDescriptor.getValueParameters().isEmpty()\n                && functionDescriptor.getValueParameters().get(functionDescriptor.getValueParameters().size() - 1)\n                        .getVarargElementType() != null)\n        {\n            flags |= ACC_VARARGS;\n        }\n\n        Modality modality = functionDescriptor.getModality();\n        if (modality == Modality.FINAL) {\n            flags |= ACC_FINAL;\n        }\n\n        OwnerKind kind = context.getContextKind();\n        \n        if (kind == OwnerKind.TRAIT_IMPL) {\n            needJetAnnotations = false;\n        }\n\n        ReceiverDescriptor expectedThisObject = functionDescriptor.getExpectedThisObject();\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n\n        if (kind != OwnerKind.TRAIT_IMPL || bodyExpressions != null) {\n            boolean isStatic = kind == OwnerKind.NAMESPACE || kind instanceof OwnerKind.StaticDelegateKind;\n            if (isStatic || kind == OwnerKind.TRAIT_IMPL)\n                flags |= ACC_STATIC;\n\n            boolean isAbstract = (\n                        modality == Modality.ABSTRACT\n                        || CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration())\n                    ) && !isStatic && kind != OwnerKind.TRAIT_IMPL;\n            if (isAbstract) flags |= ACC_ABSTRACT;\n            \n            final MethodVisitor mv = v.newMethod(fun, flags, jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor(), jvmSignature.getGenericsSignature(), null);\n            AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(functionDescriptor);\n            if (state.getClassBuilderMode() != ClassBuilderMode.SIGNATURES) {\n                int start = 0;\n                if (needJetAnnotations) {\n                    if (functionDescriptor instanceof PropertyAccessorDescriptor) {\n                        PropertyCodegen.generateJetPropertyAnnotation(mv, propertyTypeSignature, jvmSignature.getKotlinTypeParameter(),\n                                                                      ((PropertyAccessorDescriptor) functionDescriptor)\n                                                                              .getCorrespondingProperty(),\n                                                                      functionDescriptor.getVisibility());\n                    }\n                    else if (functionDescriptor instanceof SimpleFunctionDescriptor) {\n                        if (propertyTypeSignature != null) {\n                            throw new IllegalStateException();\n                        }\n                        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                        BitSet kotlinFlags = CodegenUtil.getFlagsForVisibility(functionDescriptor.getVisibility());\n                        if (CodegenUtil.isInterface(functionDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {\n                            kotlinFlags.set(modality == Modality.FINAL\n                                            ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT\n                                            : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);\n                        }\n                        aw.writeFlags(kotlinFlags);\n                        aw.writeNullableReturnType(functionDescriptor.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                        aw.visitEnd();\n                    }\n                    else {\n                        throw new IllegalStateException();\n                    }\n\n                    if (receiverParameter.exists()) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, start++);\n                        av.writeName(\"this$receiver\");\n                        av.writeNullable(receiverParameter.getType().isNullable());\n                        av.writeReceiver();\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(0) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(0).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                    for(int i = 0; i != paramDescrs.size(); ++i) {\n                        JetValueParameterAnnotationWriter av = JetValueParameterAnnotationWriter.visitParameterAnnotation(mv, i + start);\n                        ValueParameterDescriptor parameterDescriptor = paramDescrs.get(i);\n                        av.writeName(parameterDescriptor.getName().getName());\n                        av.writeHasDefaultValue(parameterDescriptor.declaresDefaultValue());\n                        av.writeNullable(parameterDescriptor.getType().isNullable());\n                        if (jvmSignature.getKotlinParameterTypes() != null && jvmSignature.getKotlinParameterTypes().get(i) != null) {\n                            av.writeType(jvmSignature.getKotlinParameterTypes().get(i + start).getKotlinSignature());\n                        }\n                        av.visitEnd();\n                    }\n                }\n            }\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                StubCodegen.generateStubCode(mv);\n            }\n\n\n            if (!isAbstract && state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                mv.visitCode();\n                \n                Label methodBegin = new Label();\n                mv.visitLabel(methodBegin);\n                \n                FrameMap frameMap = context.prepareFrame(state.getInjector().getJetTypeMapper());\n\n                ExpressionCodegen codegen = new ExpressionCodegen(mv, frameMap, jvmSignature.getAsmMethod().getReturnType(), context, state);\n\n                Type[] argTypes = jvmSignature.getAsmMethod().getArgumentTypes();\n                int add = 0;\n\n                if (kind == OwnerKind.TRAIT_IMPL)\n                    add++;\n\n                if (receiverParameter.exists())\n                    add++;\n\n                for (int i = 0; i < paramDescrs.size(); i++) {\n                    ValueParameterDescriptor parameter = paramDescrs.get(i);\n                    frameMap.enter(parameter, argTypes[i+add].getSize());\n                }\n\n                if (!isStatic && (kind instanceof OwnerKind.DelegateKind) != (functionDescriptor.getKind() == FunctionDescriptor.Kind.DELEGATION)) {\n                    throw new IllegalStateException(\"mismatching kind in \" + functionDescriptor);\n                }\n\n                Map<Name, Label> mapLabelsToDivideLocalVarVisibilityForSharedVar = new HashMap<Name, Label>();\n\n                if (kind instanceof OwnerKind.StaticDelegateKind) {\n                    OwnerKind.StaticDelegateKind dk = (OwnerKind.StaticDelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    for (int i = 0, k = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(k, argType);\n                        k += argType.getSize();\n                    }\n                    iv.invokestatic(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else if (kind instanceof OwnerKind.DelegateKind) {\n                    OwnerKind.DelegateKind dk = (OwnerKind.DelegateKind) kind;\n                    InstructionAdapter iv = new InstructionAdapter(mv);\n                    iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                    dk.getDelegate().put(JetTypeMapper.TYPE_OBJECT, iv);\n                    for (int i = 0; i < argTypes.length; i++) {\n                        Type argType = argTypes[i];\n                        iv.load(i + 1, argType);\n                    }\n                    iv.invokeinterface(dk.getOwnerClass(), jvmSignature.getAsmMethod().getName(), jvmSignature.getAsmMethod().getDescriptor());\n                    iv.areturn(jvmSignature.getAsmMethod().getReturnType());\n                }\n                else {\n                    for (ValueParameterDescriptor parameter : paramDescrs) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        if (sharedVarType != null) {\n                            Type localVarType = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                            int index = frameMap.getIndex(parameter);\n                            mv.visitTypeInsn(NEW, sharedVarType.getInternalName());\n                            mv.visitInsn(DUP);\n                            mv.visitInsn(DUP);\n                            mv.visitMethodInsn(INVOKESPECIAL, sharedVarType.getInternalName(), \"<init>\", \"()V\");\n                            mv.visitVarInsn(localVarType.getOpcode(ILOAD), index);\n                            mv.visitFieldInsn(PUTFIELD, sharedVarType.getInternalName(), \"ref\", StackValue.refType(localVarType).getDescriptor());\n\n                            Label labelToDivideLocalVarForSharedVarVisibility = new Label();\n                            mv.visitLabel(labelToDivideLocalVarForSharedVarVisibility);\n                            mapLabelsToDivideLocalVarVisibilityForSharedVar.put(parameter.getName(), labelToDivideLocalVarForSharedVarVisibility);\n\n                            mv.visitVarInsn(sharedVarType.getOpcode(ISTORE), index);\n                        }\n                    }\n\n                    codegen.returnExpression(bodyExpressions);\n                }\n                \n                Label methodEnd = new Label();\n                mv.visitLabel(methodEnd);\n\n                Collection<String> localVariableNames = new HashSet<String>();\n                localVariableNames.addAll(codegen.getLocalVariableNamesForExpression());\n                for (ValueParameterDescriptor parameterDescriptor : paramDescrs) {\n                    localVariableNames.add(parameterDescriptor.getName().getName());\n                }\n\n                int k = 0;\n\n                if (expectedThisObject.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(expectedThisObject.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n                else if (fun instanceof JetFunctionLiteralExpression || CodegenUtil.isLocalFun(functionDescriptor, state.getBindingContext())) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(\n                            context.getThisDescriptor().getDefaultType(), MapTypeMode.VALUE);\n                    mv.visitLocalVariable(\"this\", type.getDescriptor(), null, methodBegin, methodEnd, k++);\n                }\n\n                if (receiverParameter.exists()) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(receiverParameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n                    mv.visitLocalVariable(\"this$receiver\", type.getDescriptor(), null, methodBegin, methodEnd, k);\n                    k += type.getSize();\n                }\n\n                for (ValueParameterDescriptor parameter : paramDescrs) {\n                    Type type = state.getInjector().getJetTypeMapper().mapType(parameter.getType(), MapTypeMode.VALUE);\n                    // TODO: specify signature\n\n                    Label divideLabel = mapLabelsToDivideLocalVarVisibilityForSharedVar.get(parameter.getName());\n                    String parameterName = parameter.getName().getName();\n                    if (divideLabel != null) {\n                        Type sharedVarType = state.getInjector().getJetTypeMapper().getSharedVarType(parameter);\n                        mv.visitLocalVariable(parameterName, type.getDescriptor(), null, methodBegin, divideLabel, k);\n\n                        String nameForSharedVar = CodegenUtil.generateTmpVariableName(localVariableNames);\n                        localVariableNames.add(nameForSharedVar);\n\n                        mv.visitLocalVariable(nameForSharedVar, sharedVarType.getDescriptor(), null, divideLabel, methodEnd, k);\n                        k += Math.max(type.getSize(), sharedVarType.getSize());\n                    }   else {\n                        mv.visitLocalVariable(parameter.getName().getName(), type.getDescriptor(), null, methodBegin, methodEnd, k);\n                        k += type.getSize();\n                    }\n                }\n\n                endVisit(mv, null, fun);\n                mv.visitEnd();\n\n                generateBridgeIfNeeded(owner, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n            }\n        }\n\n        generateDefaultIfNeeded(context, state, v, jvmSignature.getAsmMethod(), functionDescriptor, kind);\n    }","commit_id":"993aecbc94a5b66de676e20181548243ad23f8cc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void generateDeclaration() {\n        getSuperClass();\n\n        JvmClassSignature signature = signature();\n\n        boolean isAbstract = false;\n        boolean isInterface = false;\n        boolean isFinal = false;\n        boolean isStatic = false;\n        boolean isAnnotation = false;\n\n        if (myClass instanceof JetClass) {\n            JetClass jetClass = (JetClass) myClass;\n            if (jetClass.hasModifier(JetTokens.ABSTRACT_KEYWORD))\n               isAbstract = true;\n            if (jetClass.isTrait()) {\n                isAbstract = true;\n                isInterface = true;\n            }\n            if (jetClass.isAnnotation()) {\n                isAbstract = true;\n                isInterface = true;\n                isAnnotation = true;\n                signature.getInterfaces().add(JdkNames.JLA_ANNOTATION.getInternalName());\n            }\n            if (!jetClass.hasModifier(JetTokens.OPEN_KEYWORD) && !isAbstract) {\n                isFinal = true;\n            }\n        }\n        else if (myClass.getParent() instanceof JetClassObject) {\n            isStatic = true;\n        }\n\n        int access = 0;\n        access |= ACC_PUBLIC;\n        if (isAbstract) {\n            access |= ACC_ABSTRACT;\n        }\n        if (isInterface) {\n            access |= ACC_INTERFACE; // ACC_SUPER\n        }\n        else {\n            access |= ACC_SUPER;\n        }\n        if (isFinal) {\n            access |= ACC_FINAL;\n        }\n        if (isStatic) {\n            access |= ACC_STATIC;\n        }\n        if (isAnnotation) {\n            access |= ACC_ANNOTATION;\n        }\n        v.defineClass(myClass, V1_6,\n                access,\n                      signature.getName(),\n                      signature.getJavaGenericSignature(),\n                      signature.getSuperclassName(),\n                      signature.getInterfaces().toArray(new String[0])\n        );\n        v.visitSource(myClass.getContainingFile().getName(), null);\n\n        ClassDescriptor container = getContainingClassDescriptor(descriptor);\n        if (container != null) {\n            v.visitOuterClass(typeMapper.mapType(container.getDefaultType(), MapTypeMode.IMPL).getInternalName(), null, null);\n        }\n\n        for (DeclarationDescriptor declarationDescriptor : descriptor.getUnsubstitutedInnerClassesScope().getAllDescriptors()) {\n            assert declarationDescriptor instanceof ClassDescriptor;\n            ClassDescriptor innerClass = (ClassDescriptor) declarationDescriptor;\n            // TODO: proper access\n            int innerClassAccess = ACC_PUBLIC;\n            if (innerClass.getModality() == Modality.FINAL) {\n                innerClassAccess |= ACC_FINAL;\n            }\n            else if (innerClass.getModality() == Modality.ABSTRACT) {\n                innerClassAccess |= ACC_ABSTRACT;\n            }\n\n            if (innerClass.getKind() == ClassKind.TRAIT) {\n                innerClassAccess |= ACC_INTERFACE;\n            }\n\n            // TODO: cache internal names\n            String outerClassInernalName = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n            String innerClassInternalName = typeMapper.mapType(innerClass.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n            v.visitInnerClass(innerClassInternalName, outerClassInernalName, innerClass.getName().getName(), innerClassAccess);\n        }\n\n        if (descriptor.getClassObjectDescriptor() != null) {\n            int innerClassAccess = ACC_PUBLIC | ACC_FINAL | ACC_STATIC;\n            String outerClassInernalName = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n            v.visitInnerClass(outerClassInernalName + JvmAbi.CLASS_OBJECT_SUFFIX, outerClassInernalName, JvmAbi.CLASS_OBJECT_CLASS_NAME, innerClassAccess);\n        }\n\n        AnnotationCodegen.forClass(v.getVisitor(), typeMapper).genAnnotations(descriptor);\n\n        if (signature.getKotlinGenericSignature() != null || descriptor.getVisibility() != Visibilities.PUBLIC) {\n            AnnotationVisitor annotationVisitor = v.newAnnotation(myClass, JvmStdlibNames.JET_CLASS.getDescriptor(), true);\n            annotationVisitor.visit(JvmStdlibNames.JET_CLASS_SIGNATURE, signature.getKotlinGenericSignature());\n            BitSet flags = new BitSet();\n            if (descriptor.getVisibility() == Visibilities.INTERNAL) {\n                flags.set(JvmStdlibNames.FLAG_INTERNAL_BIT);\n            }\n            else if (descriptor.getVisibility() == Visibilities.PRIVATE) {\n                flags.set(JvmStdlibNames.FLAG_PRIVATE_BIT);\n            }\n            int flagsValue = BitSetUtils.toInt(flags);\n            if (JvmStdlibNames.FLAGS_DEFAULT_VALUE != flagsValue) {\n                annotationVisitor.visit(JvmStdlibNames.JET_CLASS_FLAGS_FIELD, flagsValue);\n            }\n            annotationVisitor.visitEnd();\n        }\n    }","id":22401,"modified_method":"@Override\n    protected void generateDeclaration() {\n        getSuperClass();\n\n        JvmClassSignature signature = signature();\n\n        boolean isAbstract = false;\n        boolean isInterface = false;\n        boolean isFinal = false;\n        boolean isStatic = false;\n        boolean isAnnotation = false;\n\n        if (myClass instanceof JetClass) {\n            JetClass jetClass = (JetClass) myClass;\n            if (jetClass.hasModifier(JetTokens.ABSTRACT_KEYWORD))\n               isAbstract = true;\n            if (jetClass.isTrait()) {\n                isAbstract = true;\n                isInterface = true;\n            }\n            if (jetClass.isAnnotation()) {\n                isAbstract = true;\n                isInterface = true;\n                isAnnotation = true;\n                signature.getInterfaces().add(JdkNames.JLA_ANNOTATION.getInternalName());\n            }\n            if (!jetClass.hasModifier(JetTokens.OPEN_KEYWORD) && !isAbstract) {\n                isFinal = true;\n            }\n        }\n        else if (myClass.getParent() instanceof JetClassObject) {\n            isStatic = true;\n        }\n\n        int access = 0;\n        access |= ACC_PUBLIC;\n        if (isAbstract) {\n            access |= ACC_ABSTRACT;\n        }\n        if (isInterface) {\n            access |= ACC_INTERFACE; // ACC_SUPER\n        }\n        else {\n            access |= ACC_SUPER;\n        }\n        if (isFinal) {\n            access |= ACC_FINAL;\n        }\n        if (isStatic) {\n            access |= ACC_STATIC;\n        }\n        if (isAnnotation) {\n            access |= ACC_ANNOTATION;\n        }\n        v.defineClass(myClass, V1_6,\n                access,\n                      signature.getName(),\n                      signature.getJavaGenericSignature(),\n                      signature.getSuperclassName(),\n                      signature.getInterfaces().toArray(new String[0])\n        );\n        v.visitSource(myClass.getContainingFile().getName(), null);\n\n        ClassDescriptor container = getContainingClassDescriptor(descriptor);\n        if (container != null) {\n            v.visitOuterClass(typeMapper.mapType(container.getDefaultType(), MapTypeMode.IMPL).getInternalName(), null, null);\n        }\n\n        for (DeclarationDescriptor declarationDescriptor : descriptor.getUnsubstitutedInnerClassesScope().getAllDescriptors()) {\n            assert declarationDescriptor instanceof ClassDescriptor;\n            ClassDescriptor innerClass = (ClassDescriptor) declarationDescriptor;\n            // TODO: proper access\n            int innerClassAccess = ACC_PUBLIC;\n            if (innerClass.getModality() == Modality.FINAL) {\n                innerClassAccess |= ACC_FINAL;\n            }\n            else if (innerClass.getModality() == Modality.ABSTRACT) {\n                innerClassAccess |= ACC_ABSTRACT;\n            }\n\n            if (innerClass.getKind() == ClassKind.TRAIT) {\n                innerClassAccess |= ACC_INTERFACE;\n            }\n\n            // TODO: cache internal names\n            String outerClassInernalName = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n            String innerClassInternalName = typeMapper.mapType(innerClass.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n            v.visitInnerClass(innerClassInternalName, outerClassInernalName, innerClass.getName().getName(), innerClassAccess);\n        }\n\n        if (descriptor.getClassObjectDescriptor() != null) {\n            int innerClassAccess = ACC_PUBLIC | ACC_FINAL | ACC_STATIC;\n            String outerClassInernalName = typeMapper.mapType(descriptor.getDefaultType(), MapTypeMode.IMPL).getInternalName();\n            v.visitInnerClass(outerClassInernalName + JvmAbi.CLASS_OBJECT_SUFFIX, outerClassInernalName, JvmAbi.CLASS_OBJECT_CLASS_NAME, innerClassAccess);\n        }\n\n        AnnotationCodegen.forClass(v.getVisitor(), typeMapper).genAnnotations(descriptor);\n\n        if (signature.getKotlinGenericSignature() != null || descriptor.getVisibility() != Visibilities.PUBLIC) {\n            AnnotationVisitor annotationVisitor = v.newAnnotation(myClass, JvmStdlibNames.JET_CLASS.getDescriptor(), true);\n            annotationVisitor.visit(JvmStdlibNames.JET_CLASS_SIGNATURE, signature.getKotlinGenericSignature());\n            BitSet flags = CodegenUtil.getFlagsForVisibility(descriptor.getVisibility());\n            int flagsValue = BitSetUtils.toInt(flags);\n            if (JvmStdlibNames.FLAGS_DEFAULT_VALUE != flagsValue) {\n                annotationVisitor.visit(JvmStdlibNames.JET_CLASS_FLAGS_FIELD, flagsValue);\n            }\n            annotationVisitor.visitEnd();\n        }\n    }","commit_id":"993aecbc94a5b66de676e20181548243ad23f8cc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void generateDelegationToTraitImpl(ExpressionCodegen codegen, FunctionDescriptor fun, @NotNull FunctionDescriptor inheritedFun) {\n        DeclarationDescriptor containingDeclaration = fun.getContainingDeclaration();\n        if (containingDeclaration instanceof ClassDescriptor) {\n            ClassDescriptor declaration = (ClassDescriptor) containingDeclaration;\n            PsiElement psiElement = BindingContextUtils.classDescriptorToDeclaration(bindingContext, declaration);\n            if (psiElement instanceof JetClass) {\n                JetClass jetClass = (JetClass) psiElement;\n                if (jetClass.isTrait()) {\n                    int flags = ACC_PUBLIC; // TODO.\n\n                    Method function;\n                    Method functionOriginal;\n                    if (fun instanceof PropertyAccessorDescriptor) {\n                        PropertyDescriptor property = ((PropertyAccessorDescriptor) fun).getCorrespondingProperty();\n                        if (fun instanceof PropertyGetterDescriptor) {\n                            function = typeMapper.mapGetterSignature(property, OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                            functionOriginal = typeMapper.mapGetterSignature(property.getOriginal(), OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                        }\n                        else if (fun instanceof PropertySetterDescriptor) {\n                            function = typeMapper.mapSetterSignature(property, OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                            functionOriginal = typeMapper.mapSetterSignature(property.getOriginal(), OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                        }\n                        else {\n                            throw new IllegalStateException(\"Accessor is neither getter, nor setter, what is it?\");\n                        }\n                    }\n                    else {\n                        function = typeMapper.mapSignature(fun.getName(), fun).getAsmMethod();\n                        functionOriginal = typeMapper.mapSignature(fun.getName(), fun.getOriginal()).getAsmMethod();\n                    }\n\n                    final MethodVisitor mv = v.newMethod(myClass, flags, function.getName(), function.getDescriptor(), null, null);\n                    AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(fun);\n\n                    JvmMethodSignature jvmSignature = typeMapper.mapToCallableMethod(inheritedFun, false, OwnerKind.IMPLEMENTATION).getSignature();\n                    JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                    BitSet kotlinFlags = new BitSet();\n                    if (fun.getVisibility() == Visibilities.INTERNAL) {\n                        kotlinFlags.set(JvmStdlibNames.FLAG_INTERNAL_BIT);\n                    }\n                    else if (fun.getVisibility() == Visibilities.PRIVATE) {\n                        kotlinFlags.set(JvmStdlibNames.FLAG_PRIVATE_BIT);\n                    }\n                    if (fun instanceof PropertyAccessorDescriptor) {\n                        kotlinFlags.set(JvmStdlibNames.FLAG_PROPERTY_BIT);\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writePropertyType(jvmSignature.getKotlinReturnType());\n                    } else {\n                        aw.writeNullableReturnType(fun.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                    }\n                    aw.writeFlags(kotlinFlags);\n                    aw.visitEnd();\n\n                    if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                        StubCodegen.generateStubCode(mv);\n                    }\n                    else if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                        mv.visitCode();\n\n                        codegen.generateThisOrOuter(descriptor);\n\n                        Type[] argTypes = function.getArgumentTypes();\n                        InstructionAdapter iv = new InstructionAdapter(mv);\n                        iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                        for (int i = 0, reg = 1; i < argTypes.length; i++) {\n                            Type argType = argTypes[i];\n                            iv.load(reg, argType);\n                            //noinspection AssignmentToForLoopParameter\n                            reg += argType.getSize();\n                        }\n\n                        JetType jetType = TraitImplBodyCodegen.getSuperClass(declaration, bindingContext);\n                        Type type = typeMapper.mapType(jetType, MapTypeMode.IMPL);\n                        if (type.getInternalName().equals(\"java/lang/Object\")) {\n                            jetType = declaration.getDefaultType();\n                            type = typeMapper.mapType(jetType, MapTypeMode.IMPL);\n                        }\n\n                        String fdescriptor = functionOriginal.getDescriptor().replace(\"(\",\"(\" +  type.getDescriptor());\n                        Type type1 = typeMapper.mapType(((ClassDescriptor) fun.getContainingDeclaration()).getDefaultType(), MapTypeMode.TRAIT_IMPL);\n                        iv.invokestatic(type1.getInternalName(), function.getName(), fdescriptor);\n                        if (function.getReturnType().getSort() == Type.OBJECT) {\n                            iv.checkcast(function.getReturnType());\n                        }\n                        iv.areturn(function.getReturnType());\n                        FunctionCodegen.endVisit(iv, \"trait method\", BindingContextUtils.callableDescriptorToDeclaration(bindingContext, fun));\n                    }\n\n                    FunctionCodegen.generateBridgeIfNeeded(context, state, v, function, fun, kind);\n                }\n            }\n        }\n    }","id":22402,"modified_method":"private void generateDelegationToTraitImpl(ExpressionCodegen codegen, FunctionDescriptor fun, @NotNull FunctionDescriptor inheritedFun) {\n        DeclarationDescriptor containingDeclaration = fun.getContainingDeclaration();\n        if (containingDeclaration instanceof ClassDescriptor) {\n            ClassDescriptor declaration = (ClassDescriptor) containingDeclaration;\n            PsiElement psiElement = BindingContextUtils.classDescriptorToDeclaration(bindingContext, declaration);\n            if (psiElement instanceof JetClass) {\n                JetClass jetClass = (JetClass) psiElement;\n                if (jetClass.isTrait()) {\n                    int flags = ACC_PUBLIC; // TODO.\n\n                    Method function;\n                    Method functionOriginal;\n                    if (fun instanceof PropertyAccessorDescriptor) {\n                        PropertyDescriptor property = ((PropertyAccessorDescriptor) fun).getCorrespondingProperty();\n                        if (fun instanceof PropertyGetterDescriptor) {\n                            function = typeMapper.mapGetterSignature(property, OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                            functionOriginal = typeMapper.mapGetterSignature(property.getOriginal(), OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                        }\n                        else if (fun instanceof PropertySetterDescriptor) {\n                            function = typeMapper.mapSetterSignature(property, OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                            functionOriginal = typeMapper.mapSetterSignature(property.getOriginal(), OwnerKind.IMPLEMENTATION).getJvmMethodSignature().getAsmMethod();\n                        }\n                        else {\n                            throw new IllegalStateException(\"Accessor is neither getter, nor setter, what is it?\");\n                        }\n                    }\n                    else {\n                        function = typeMapper.mapSignature(fun.getName(), fun).getAsmMethod();\n                        functionOriginal = typeMapper.mapSignature(fun.getName(), fun.getOriginal()).getAsmMethod();\n                    }\n\n                    final MethodVisitor mv = v.newMethod(myClass, flags, function.getName(), function.getDescriptor(), null, null);\n                    AnnotationCodegen.forMethod(mv, state.getInjector().getJetTypeMapper()).genAnnotations(fun);\n\n                    JvmMethodSignature jvmSignature = typeMapper.mapToCallableMethod(inheritedFun, false, OwnerKind.IMPLEMENTATION).getSignature();\n                    JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n                    BitSet kotlinFlags = CodegenUtil.getFlagsForVisibility(fun.getVisibility());\n                    if (fun instanceof PropertyAccessorDescriptor) {\n                        kotlinFlags.set(JvmStdlibNames.FLAG_PROPERTY_BIT);\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writePropertyType(jvmSignature.getKotlinReturnType());\n                    } else {\n                        aw.writeNullableReturnType(fun.getReturnType().isNullable());\n                        aw.writeTypeParameters(jvmSignature.getKotlinTypeParameter());\n                        aw.writeReturnType(jvmSignature.getKotlinReturnType());\n                    }\n                    aw.writeFlags(kotlinFlags);\n                    aw.visitEnd();\n\n                    if (state.getClassBuilderMode() == ClassBuilderMode.STUBS) {\n                        StubCodegen.generateStubCode(mv);\n                    }\n                    else if (state.getClassBuilderMode() == ClassBuilderMode.FULL) {\n                        mv.visitCode();\n\n                        codegen.generateThisOrOuter(descriptor);\n\n                        Type[] argTypes = function.getArgumentTypes();\n                        InstructionAdapter iv = new InstructionAdapter(mv);\n                        iv.load(0, JetTypeMapper.TYPE_OBJECT);\n                        for (int i = 0, reg = 1; i < argTypes.length; i++) {\n                            Type argType = argTypes[i];\n                            iv.load(reg, argType);\n                            //noinspection AssignmentToForLoopParameter\n                            reg += argType.getSize();\n                        }\n\n                        JetType jetType = TraitImplBodyCodegen.getSuperClass(declaration, bindingContext);\n                        Type type = typeMapper.mapType(jetType, MapTypeMode.IMPL);\n                        if (type.getInternalName().equals(\"java/lang/Object\")) {\n                            jetType = declaration.getDefaultType();\n                            type = typeMapper.mapType(jetType, MapTypeMode.IMPL);\n                        }\n\n                        String fdescriptor = functionOriginal.getDescriptor().replace(\"(\",\"(\" +  type.getDescriptor());\n                        Type type1 = typeMapper.mapType(((ClassDescriptor) fun.getContainingDeclaration()).getDefaultType(), MapTypeMode.TRAIT_IMPL);\n                        iv.invokestatic(type1.getInternalName(), function.getName(), fdescriptor);\n                        if (function.getReturnType().getSort() == Type.OBJECT) {\n                            iv.checkcast(function.getReturnType());\n                        }\n                        iv.areturn(function.getReturnType());\n                        FunctionCodegen.endVisit(iv, \"trait method\", BindingContextUtils.callableDescriptorToDeclaration(bindingContext, fun));\n                    }\n\n                    FunctionCodegen.generateBridgeIfNeeded(context, state, v, function, fun, kind);\n                }\n            }\n        }\n    }","commit_id":"993aecbc94a5b66de676e20181548243ad23f8cc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void generateJetPropertyAnnotation(MethodVisitor mv, @NotNull String kotlinType, @NotNull String typeParameters,\n            @NotNull PropertyDescriptor propertyDescriptor, @NotNull Visibility visibility) {\n        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n        Modality modality = propertyDescriptor.getModality();\n        BitSet flags = new BitSet();\n        flags.set(JvmStdlibNames.FLAG_PROPERTY_BIT);\n        if (CodegenUtil.isInterface(propertyDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {\n            flags.set(modality == Modality.FINAL\n                      ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT\n                      : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);\n        }\n        if (visibility == Visibilities.INTERNAL) {\n            flags.set(JvmStdlibNames.FLAG_INTERNAL_BIT);\n        }\n        else if (visibility == Visibilities.PRIVATE) {\n            flags.set(JvmStdlibNames.FLAG_PRIVATE_BIT);\n        }\n        aw.writeFlags(flags);\n        aw.writeTypeParameters(typeParameters);\n        aw.writePropertyType(kotlinType);\n        aw.visitEnd();\n    }","id":22403,"modified_method":"public static void generateJetPropertyAnnotation(MethodVisitor mv, @NotNull String kotlinType, @NotNull String typeParameters,\n            @NotNull PropertyDescriptor propertyDescriptor, @NotNull Visibility visibility) {\n        JetMethodAnnotationWriter aw = JetMethodAnnotationWriter.visitAnnotation(mv);\n        Modality modality = propertyDescriptor.getModality();\n        BitSet flags = CodegenUtil.getFlagsForVisibility(visibility);\n        flags.set(JvmStdlibNames.FLAG_PROPERTY_BIT);\n        if (CodegenUtil.isInterface(propertyDescriptor.getContainingDeclaration()) && modality != Modality.ABSTRACT) {\n            flags.set(modality == Modality.FINAL\n                      ? JvmStdlibNames.FLAG_FORCE_FINAL_BIT\n                      : JvmStdlibNames.FLAG_FORCE_OPEN_BIT);\n        }\n        aw.writeFlags(flags);\n        aw.writeTypeParameters(typeParameters);\n        aw.writePropertyType(kotlinType);\n        aw.visitEnd();\n    }","commit_id":"993aecbc94a5b66de676e20181548243ad23f8cc","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void addPlugin( String pluginKey, Artifact pluginArtifact, MavenSession session )\n        throws ArtifactResolutionException, ComponentLookupException, PlexusContainerException\n    {\n        ArtifactResolver artifactResolver = null;\n        MavenProjectBuilder mavenProjectBuilder = null;\n\n        try\n        {\n            artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n\n            mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n            MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections.singleton( pluginArtifact ), session.getRemoteRepositories(), session.getLocalRepository(), metadataSource, artifactFilter );\n            \n            Map resolved = result.getArtifacts();\n            \n            List files = new ArrayList();\n            \n            for ( Iterator it = resolved.values().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n                File artifactFile = artifact.getFile();\n                \n                files.add( artifact.getFile() );\n            }\n            \n            container.createChildContainer( pluginKey, files, Collections.EMPTY_MAP, Collections.singletonList( this ) );\n        }\n        finally\n        {\n            if ( artifactResolver != null )\n            {\n                releaseComponent( artifactResolver );\n            }\n            if ( mavenProjectBuilder != null )\n            {\n                releaseComponent( mavenProjectBuilder );\n            }\n        }\n    }","id":22404,"modified_method":"protected void addPlugin( String pluginKey, Artifact pluginArtifact, MavenSession session )\n        throws ArtifactResolutionException, ComponentLookupException, PlexusContainerException\n    {\n        ArtifactResolver artifactResolver = null;\n        MavenProjectBuilder mavenProjectBuilder = null;\n\n        try\n        {\n            artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n\n            mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n            MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively(\n                Collections.singleton( pluginArtifact ), session.getRemoteRepositories(), session.getLocalRepository(),\n                metadataSource, artifactFilter );\n\n            Map resolved = result.getArtifacts();\n\n            List files = new ArrayList();\n\n            for ( Iterator it = resolved.values().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                files.add( artifact.getFile() );\n            }\n\n            container.createChildContainer( pluginKey, files, Collections.EMPTY_MAP, Collections.singletonList( this ) );\n        }\n        finally\n        {\n            if ( artifactResolver != null )\n            {\n                releaseComponent( artifactResolver );\n            }\n            if ( mavenProjectBuilder != null )\n            {\n                releaseComponent( mavenProjectBuilder );\n            }\n        }\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"private void validatePomConfiguration( MojoDescriptor goal, PlexusConfiguration pomConfiguration )\n        throws PluginConfigurationException\n    {\n        List parameters = goal.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            boolean editable = parameter.isEditable();\n\n            // the key for the configuration map we're building.\n            String key = parameter.getName();\n\n            // the key used to lookup the parameter in the config from the POM, etc.\n            String lookupKey = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( lookupKey ) )\n            {\n                lookupKey = key;\n            }\n\n            // Make sure the parameter is either editable/configurable, or else is NOT specified in the POM \n            if ( !editable && ( pomConfiguration.getChild( lookupKey, false ) != null ||\n                pomConfiguration.getChild( key, false ) != null ) )\n            {\n                StringBuffer errorMessage = new StringBuffer().append( \"ERROR: Cannot override read-only parameter: \" ).append(\n                    key );\n\n                if ( !lookupKey.equals( key ) )\n                {\n                    errorMessage.append( \" (with alias: \" ).append( lookupKey ).append( \")\" );\n                }\n\n                errorMessage.append( \" in goal: \" ).append( goal.getFullGoalName() );\n\n                throw new PluginConfigurationException( errorMessage.toString() );\n            }\n        }\n    }","id":22405,"modified_method":"private void validatePomConfiguration( MojoDescriptor goal, PlexusConfiguration pomConfiguration )\n        throws PluginConfigurationException\n    {\n        List parameters = goal.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            // the key for the configuration map we're building.\n            String key = parameter.getName();\n\n            PlexusConfiguration value = pomConfiguration.getChild( key, false );\n\n            if ( value == null && StringUtils.isNotEmpty( parameter.getAlias() ) )\n            {\n                key = parameter.getAlias();\n                value = pomConfiguration.getChild( key, false );\n            }\n\n            // Make sure the parameter is either editable/configurable, or else is NOT specified in the POM\n            if ( !parameter.isEditable() && value != null )\n            {\n                StringBuffer errorMessage = new StringBuffer().append( \"ERROR: Cannot override read-only parameter: \" );\n                errorMessage.append( key );\n                errorMessage.append( \" in goal: \" ).append( goal.getFullGoalName() );\n\n                throw new PluginConfigurationException( errorMessage.toString() );\n            }\n        }\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"public void componentDiscovered( ComponentDiscoveryEvent event )\n    {\n        ComponentSetDescriptor componentSetDescriptor = event.getComponentSetDescriptor();\n\n        if ( componentSetDescriptor instanceof PluginDescriptor )\n        {\n            PluginDescriptor pluginDescriptor = (PluginDescriptor) componentSetDescriptor;\n\n            if ( pluginDescriptor.getVersion() == null )\n            {\n                // TODO: temporary - until we're done testing that version is always written\n                throw new NullPointerException( \"Version was null - check your plugin '\" + pluginDescriptor.getId() +\n                                                \"' was built with Maven 2.0 Alpha 2\" );\n            }\n\n//            String key = pluginDescriptor.getId();\n            // TODO: see comment in getPluginDescriptor\n            String key = pluginDescriptor.getGroupId() + \":\" + pluginDescriptor.getArtifactId();\n\n            if ( !pluginsInProcess.contains( key ) )\n            {\n                pluginsInProcess.add( key );\n\n                pluginDescriptors.put( key, pluginDescriptor );\n\n                // TODO: throw an (not runtime) exception if there is a prefix overlap - means doing so elsewhere\n                if ( !pluginDescriptorsByPrefix.containsKey( pluginDescriptor.getGoalPrefix() ) )\n                {\n                    pluginDescriptorsByPrefix.put( pluginDescriptor.getGoalPrefix(), pluginDescriptor );\n                }\n            }\n        }\n    }","id":22406,"modified_method":"public void componentDiscovered( ComponentDiscoveryEvent event )\n    {\n        ComponentSetDescriptor componentSetDescriptor = event.getComponentSetDescriptor();\n\n        if ( componentSetDescriptor instanceof PluginDescriptor )\n        {\n            PluginDescriptor pluginDescriptor = (PluginDescriptor) componentSetDescriptor;\n\n//            String key = pluginDescriptor.getId();\n            // TODO: see comment in getPluginDescriptor\n            String key = pluginDescriptor.getGroupId() + \":\" + pluginDescriptor.getArtifactId();\n\n            if ( !pluginsInProcess.contains( key ) )\n            {\n                pluginsInProcess.add( key );\n\n                pluginDescriptors.put( key, pluginDescriptor );\n\n                // TODO: throw an (not runtime) exception if there is a prefix overlap - means doing so elsewhere\n                if ( !pluginDescriptorsByPrefix.containsKey( pluginDescriptor.getGoalPrefix() ) )\n                {\n                    pluginDescriptorsByPrefix.put( pluginDescriptor.getGoalPrefix(), pluginDescriptor );\n                }\n            }\n        }\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"public void initialize()\n    {\n        // TODO: configure this from bootstrap or scan lib\n        // TODO: Note: maven-plugin just re-added until all plugins are switched over...\n        artifactFilter = new ExclusionSetFilter( new String[]\n        {\n            \"bsh\",\n            \"classworlds\",\n            \"doxia-core\",\n            \"maven-artifact\",\n            \"maven-core\",\n            \"maven-model\",\n            \"maven-monitor\",\n            \"maven-plugin\",\n            \"maven-plugin-api\",\n            \"maven-plugin-descriptor\",\n            \"maven-project\",\n            \"maven-reporting-api\",\n            \"maven-script-beanshell\",\n            \"maven-settings\",\n            \"plexus-bsh-factory\",\n            \"plexus-container-default\",\n            \"plexus-utils\",\n            \"wagon-provider-api\"\n        } );\n    }","id":22407,"modified_method":"public void initialize()\n    {\n        // TODO: configure this from bootstrap or scan lib\n        artifactFilter = new ExclusionSetFilter( new String[]{\"bsh\", \"classworlds\", \"doxia-core\", \"maven-artifact\",\n                                                              \"maven-core\", \"maven-model\", \"maven-monitor\",\n                                                              \"maven-plugin-api\", \"maven-plugin-descriptor\",\n                                                              \"maven-project\", \"maven-reporting-api\",\n                                                              \"maven-script-beanshell\", \"maven-settings\",\n                                                              \"plexus-bsh-factory\", \"plexus-container-default\",\n                                                              \"plexus-utils\", \"wagon-provider-api\"} );\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @deprecated [JC] in favor of what?\n     */\n    private void getPluginConfigurationFromExpressions( Mojo plugin, MojoDescriptor goal,\n                                                        PlexusConfiguration mergedConfiguration,\n                                                        PlexusContainer pluginContainer, ExpressionEvaluator expressionEvaluator )\n        throws ExpressionEvaluationException, PluginConfigurationException\n    {\n        List parameters = goal.getParameters();\n\n        List invalidParameters = new ArrayList();\n\n        if ( parameters == null || parameters.isEmpty() )\n        {\n            return;\n        }\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            boolean editable = parameter.isEditable();\n\n            // the key for the configuration map we're building.\n            String key = parameter.getName();\n\n            // the key used to lookup the parameter in the config from the POM, etc.\n            String lookupKey = parameter.getAlias();\n\n            if ( StringUtils.isEmpty( lookupKey ) )\n            {\n                lookupKey = key;\n            }\n\n            String expression;\n\n            boolean foundInConfiguration = false;\n\n            if ( mergedConfiguration.getChild( lookupKey, false ) != null )\n            {\n                expression = mergedConfiguration.getChild( lookupKey, false ).getValue( null );\n                foundInConfiguration = true;\n            }\n            else if ( mergedConfiguration.getChild( key, false ) != null )\n            {\n                expression = mergedConfiguration.getChild( key, false ).getValue( null );\n                foundInConfiguration = true;\n            }\n            else\n            {\n                expression = parameter.getExpression();\n            }\n\n            if ( foundInConfiguration && expression != null && parameter.getDeprecated() != null )\n            {\n                PlexusConfiguration goalConfiguration = goal.getMojoConfiguration();\n                \n                // TODO: Go back to this when we get the container ready to configure mojos...\n//                PlexusConfiguration goalConfiguration = goal.getConfiguration();\n\n                if ( !expression.equals( goalConfiguration.getChild( lookupKey, false ).getValue( null ) ) &&\n                    !expression.equals( goalConfiguration.getChild( key, false ).getValue( null ) ) )\n                {\n                    StringBuffer message = new StringBuffer().append( \"DEPRECATED: \" ).append( key );\n\n                    if ( !lookupKey.equals( key ) )\n                    {\n                        message.append( \" (aliased to \" ).append( lookupKey ).append( \")\" );\n                    }\n\n                    message.append( \" is deprecated.\\n\\t\" ).append( parameter.getDeprecated() );\n\n                    getLogger().warn( message.toString() );\n                }\n            }\n\n            Object value = expressionEvaluator.evaluate( expression );\n\n            getLogger().debug( \"Evaluated mojo parameter expression: \\'\" + expression + \"\\' to: \" + value +\n                               \" for parameter: \\'\" + key + \"\\'\" );\n\n            // TODO: remove. If there is a default value, required should have been removed by the descriptor generator\n            if ( value == null && goal.getComponentConfigurator() == null )\n            {\n                Object defaultValue;\n                try\n                {\n                    Field pluginField = findPluginField( plugin.getClass(), parameter.getName() );\n                    boolean accessible = pluginField.isAccessible();\n                    if ( !accessible )\n                    {\n                        pluginField.setAccessible( true );\n                    }\n                    defaultValue = pluginField.get( plugin );\n                    if ( !accessible )\n                    {\n                        pluginField.setAccessible( false );\n                    }\n                }\n                catch ( IllegalAccessException e )\n                {\n                    String message = \"Error finding field for parameter '\" + parameter.getName() + \"'\";\n                    throw new PluginConfigurationException( message, e );\n                }\n                catch ( NoSuchFieldException e )\n                {\n                    String message = \"Error finding field for parameter '\" + parameter.getName() + \"'\";\n                    throw new PluginConfigurationException( message, e );\n                }\n                if ( defaultValue != null )\n                {\n                    // TODO: allow expressions?\n                    value = defaultValue;\n                }\n            }\n\n            // ----------------------------------------------------------------------\n            // We will perform a basic check here for parameters values that are\n            // required. Required parameters can't be null so we throw an\n            // Exception in the case where they are. We probably want some\n            // pluggable\n            // mechanism here but this will catch the most obvious of\n            // misconfigurations.\n            // ----------------------------------------------------------------------\n\n            if ( value == null && parameter.isRequired() )\n            {\n                invalidParameters.add( parameter );\n            }\n\n        }\n\n        if ( !invalidParameters.isEmpty() )\n        {\n            throw new PluginParameterException( goal, invalidParameters );\n        }\n    }","id":22408,"modified_method":"private void checkRequiredParameters( MojoDescriptor goal, PlexusConfiguration configuration,\n                                          ExpressionEvaluator expressionEvaluator, Mojo plugin )\n        throws PluginConfigurationException\n    {\n        // TODO: this should be built in to the configurator, as we presently double process the expressions\n\n        List parameters = goal.getParameters();\n\n        List invalidParameters = new ArrayList();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            // the key for the configuration map we're building.\n            String key = parameter.getName();\n\n            Object fieldValue = null;\n            String expression = null;\n            PlexusConfiguration value = configuration.getChild( key, false );\n            try\n            {\n                if ( value != null )\n                {\n                    expression = value.getValue( null );\n                    fieldValue = expressionEvaluator.evaluate( expression );\n                    if ( fieldValue == null )\n                    {\n                        fieldValue = value.getAttribute( \"default-value\", null );\n                    }\n                }\n\n                if ( fieldValue == null && StringUtils.isNotEmpty( parameter.getAlias() ) )\n                {\n                    value = configuration.getChild( parameter.getAlias(), false );\n                    if ( value != null )\n                    {\n                        expression = value.getValue( null );\n                        fieldValue = expressionEvaluator.evaluate( expression );\n                        if ( fieldValue == null )\n                        {\n                            fieldValue = value.getAttribute( \"default-value\", null );\n                        }\n                    }\n                }\n            }\n            catch ( ExpressionEvaluationException e )\n            {\n                throw new PluginConfigurationException( \"Bad expression\", e );\n            }\n\n            if ( fieldValue == null && goal.getComponentConfigurator() == null )\n            {\n                try\n                {\n                    // TODO: remove in beta-1\n                    Field field = findPluginField( plugin.getClass(), parameter.getName() );\n                    boolean accessible = field.isAccessible();\n                    if ( !accessible )\n                    {\n                        field.setAccessible( true );\n                    }\n                    fieldValue = field.get( plugin );\n                    if ( !accessible )\n                    {\n                        field.setAccessible( false );\n                    }\n                    if ( fieldValue != null )\n                    {\n                        getLogger().warn( \"DEPRECATED: using default-value to set the default value of field '\" +\n                                          parameter.getName() + \"'\" );\n                    }\n                }\n                catch ( NoSuchFieldException e )\n                {\n                    throw new PluginConfigurationException( \"Unable to find field to check default value\", e );\n                }\n                catch ( IllegalAccessException e )\n                {\n                    throw new PluginConfigurationException( \"Unable to read field to check default value\", e );\n                }\n            }\n\n            if ( parameter.isRequired() && fieldValue == null )\n            {\n                parameter.setExpression( expression );\n                invalidParameters.add( parameter );\n            }\n        }\n\n        if ( !invalidParameters.isEmpty() )\n        {\n            throw new PluginParameterException( goal, invalidParameters );\n        }\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"public void executeMojo( MavenSession session, MojoDescriptor mojoDescriptor )\n        throws ArtifactResolutionException, PluginManagerException, MojoExecutionException\n    {\n        PlexusContainer pluginContainer = null;\n        \n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n\n            ArtifactResolver artifactResolver = null;\n            MavenProjectBuilder mavenProjectBuilder = null;\n\n            try\n            {\n                artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder,\n                                               mojoDescriptor.isDependencyResolutionRequired() );\n                downloadDependencies( session, artifactResolver );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new PluginManagerException( \"Internal configuration error in plugin manager\", e );\n            }\n            finally\n            {\n                if ( artifactResolver != null )\n                {\n                    releaseComponent( artifactResolver );\n                }\n                if ( mavenProjectBuilder != null )\n                {\n                    releaseComponent( mavenProjectBuilder );\n                }\n            }\n        }\n\n        Mojo plugin = null;\n\n        String goalName = mojoDescriptor.getFullGoalName();\n\n        try\n        {\n            String pluginKey = mojoDescriptor.getPluginDescriptor().getPluginLookupKey();\n            \n            pluginContainer = container.getChildContainer( pluginKey );\n            \n            if( pluginContainer == null )\n            {\n                throw new PluginConfigurationException( \"Cannot find PlexusContainer for plugin: \" + pluginKey );\n            }\n            \n            plugin = (Mojo) pluginContainer.lookup( Mojo.ROLE, mojoDescriptor.getRoleHint() );\n            plugin.setLog( mojoLogger );\n\n            String goalId = mojoDescriptor.getGoal();\n\n            // TODO: can probable refactor these a little when only the new plugin technique is in place\n            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n            Xpp3Dom dom = session.getProject().getGoalConfiguration( pluginDescriptor.getGroupId(),\n                                                                     pluginDescriptor.getArtifactId(), goalId );\n\n            PlexusConfiguration pomConfiguration;\n            if ( dom == null )\n            {\n                pomConfiguration = new XmlPlexusConfiguration( \"configuration\" );\n            }\n            else\n            {\n                pomConfiguration = new XmlPlexusConfiguration( dom );\n\n                // Validate against non-editable (@readonly) parameters, to make sure users aren't trying to \n                // override in the POM.\n                // TODO: currently breaks it0014, as an expression is in pomConfiguration\n//                validatePomConfiguration( mojoDescriptor, pomConfiguration );\n            }\n\n            ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session, pathTranslator,\n                                                                                              getLogger() );\n\n            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration,\n                                                                          mojoDescriptor.getMojoConfiguration() );\n\n            // TODO: Go back to this when we get the container ready to configure mojos...\n//            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration,\n//                                                                          mojoDescriptor.getConfiguration() );\n\n            try\n            {\n                getPluginConfigurationFromExpressions( plugin, mojoDescriptor, mergedConfiguration,\n                                                       pluginContainer, expressionEvaluator );\n\n                populatePluginFields( plugin, mojoDescriptor, mergedConfiguration, pluginContainer, expressionEvaluator );\n            }\n            catch ( ExpressionEvaluationException e )\n            {\n                throw new MojoExecutionException( \"Unable to configure plugin\", e );\n            }\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                plugin.execute();\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( MojoExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( PluginConfigurationException e )\n        {\n            String msg = \"Error configuring plugin for execution of '\" + goalName + \"'.\";\n            throw new MojoExecutionException( msg, e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MojoExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                pluginContainer.release( plugin );\n            }\n            catch ( ComponentLifecycleException e )\n            {\n                if( getLogger().isErrorEnabled() )\n                {\n                    getLogger().error( \"Error releasing plugin - ignoring.\", e );\n                }\n            }\n        }\n    }","id":22409,"modified_method":"public void executeMojo( MavenSession session, MojoDescriptor mojoDescriptor )\n        throws ArtifactResolutionException, PluginManagerException, MojoExecutionException\n    {\n        PlexusContainer pluginContainer = null;\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n\n            ArtifactResolver artifactResolver = null;\n            MavenProjectBuilder mavenProjectBuilder = null;\n\n            try\n            {\n                artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder,\n                                               mojoDescriptor.isDependencyResolutionRequired() );\n                downloadDependencies( session, artifactResolver );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new PluginManagerException( \"Internal configuration error in plugin manager\", e );\n            }\n            finally\n            {\n                if ( artifactResolver != null )\n                {\n                    releaseComponent( artifactResolver );\n                }\n                if ( mavenProjectBuilder != null )\n                {\n                    releaseComponent( mavenProjectBuilder );\n                }\n            }\n        }\n\n        Mojo plugin = null;\n\n        String goalName = mojoDescriptor.getFullGoalName();\n\n        try\n        {\n            String pluginKey = mojoDescriptor.getPluginDescriptor().getPluginLookupKey();\n\n            pluginContainer = container.getChildContainer( pluginKey );\n\n            if ( pluginContainer == null )\n            {\n                throw new PluginConfigurationException( \"Cannot find PlexusContainer for plugin: \" + pluginKey );\n            }\n\n            plugin = (Mojo) pluginContainer.lookup( Mojo.ROLE, mojoDescriptor.getRoleHint() );\n            plugin.setLog( mojoLogger );\n\n            String goalId = mojoDescriptor.getGoal();\n\n            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n            Xpp3Dom dom = session.getProject().getGoalConfiguration( pluginDescriptor.getGroupId(),\n                                                                     pluginDescriptor.getArtifactId(), goalId );\n\n            PlexusConfiguration pomConfiguration;\n            if ( dom == null )\n            {\n                pomConfiguration = new XmlPlexusConfiguration( \"configuration\" );\n            }\n            else\n            {\n                pomConfiguration = new XmlPlexusConfiguration( dom );\n            }\n\n            // Validate against non-editable (@readonly) parameters, to make sure users aren't trying to\n            // override in the POM.\n            validatePomConfiguration( mojoDescriptor, pomConfiguration );\n\n            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration,\n                                                                          mojoDescriptor.getMojoConfiguration() );\n\n            // TODO: plexus\n//            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration,\n//                                                                          mojoDescriptor.getConfiguration() );\n\n            ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session, pathTranslator,\n                                                                                              getLogger() );\n            checkRequiredParameters( mojoDescriptor, mergedConfiguration, expressionEvaluator, plugin );\n\n            populatePluginFields( plugin, mojoDescriptor, mergedConfiguration, pluginContainer, expressionEvaluator );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n\n            dispatcher.dispatchStart( event, goalName );\n            try\n            {\n                plugin.execute();\n\n                dispatcher.dispatchEnd( event, goalName );\n            }\n            catch ( MojoExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalName, e );\n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( PluginConfigurationException e )\n        {\n            String msg = \"Error configuring plugin for execution of '\" + goalName + \"'.\";\n            throw new MojoExecutionException( msg, e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MojoExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                pluginContainer.release( plugin );\n            }\n            catch ( ComponentLifecycleException e )\n            {\n                if ( getLogger().isErrorEnabled() )\n                {\n                    getLogger().error( \"Error releasing plugin - ignoring.\", e );\n                }\n            }\n        }\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass ) throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = new TreeMap();\n\n        extractFieldParameterTags( javaClass, rawParams );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Entry) it.next();\n            String paramName = (String) entry.getKey();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            DocletTag parameter = field.getTagByName( PARAMETER );\n\n            Parameter pd = new Parameter();\n\n            pd.setName( paramName );\n\n            pd.setType( field.getType().getValue() );\n\n            pd.setDescription( field.getComment() );\n\n            pd.setRequired( field.getTagByName( REQUIRED ) != null );\n\n            pd.setEditable( field.getTagByName( READONLY ) == null );\n\n            DocletTag deprecationTag = field.getTagByName( DEPRECATED );\n            if ( deprecationTag != null )\n            {\n                pd.setDeprecated( deprecationTag.getValue() );\n            }\n\n            String alias = parameter.getNamedParameter( \"alias\" );\n\n            if ( !StringUtils.isEmpty( alias ) )\n            {\n                pd.setAlias( alias );\n            }\n\n            pd.setExpression( parameter.getNamedParameter( PARAMETER_EXPRESSION ) );\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }","id":22410,"modified_method":"private void extractParameters( MojoDescriptor mojoDescriptor, JavaClass javaClass ) throws InvalidPluginDescriptorException\n    {\n        // ---------------------------------------------------------------------------------\n        // We're resolving class-level, ancestor-class-field, local-class-field order here.\n        // ---------------------------------------------------------------------------------\n\n        Map rawParams = new TreeMap();\n\n        extractFieldParameterTags( javaClass, rawParams );\n\n        for ( Iterator it = rawParams.entrySet().iterator(); it.hasNext(); )\n        {\n            Map.Entry entry = (Entry) it.next();\n            String paramName = (String) entry.getKey();\n\n            JavaField field = (JavaField) entry.getValue();\n\n            DocletTag parameter = field.getTagByName( PARAMETER );\n\n            Parameter pd = new Parameter();\n\n            pd.setName( paramName );\n\n            pd.setType( field.getType().getValue() );\n\n            pd.setDescription( field.getComment() );\n\n            pd.setRequired( field.getTagByName( REQUIRED ) != null );\n\n            pd.setEditable( field.getTagByName( READONLY ) == null );\n\n            DocletTag deprecationTag = field.getTagByName( DEPRECATED );\n            if ( deprecationTag != null )\n            {\n                pd.setDeprecated( deprecationTag.getValue() );\n            }\n\n            String alias = parameter.getNamedParameter( \"alias\" );\n\n            if ( !StringUtils.isEmpty( alias ) )\n            {\n                pd.setAlias( alias );\n            }\n\n            pd.setExpression( parameter.getNamedParameter( PARAMETER_EXPRESSION ) );\n\n            pd.setDefaultValue( parameter.getNamedParameter( PARAMETER_DEFAULT_VALUE ) );\n\n            mojoDescriptor.addParameter( pd );\n        }\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n        mojo.setPluginDescriptor( pluginDescriptor );\n\n        mojo.setGoal( c.getChild( \"goal\" ).getValue() );\n\n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        PlexusConfiguration configuratorConfig = c.getChild( \"configurator\" );\n\n        if ( configuratorConfig != null )\n        {\n            mojo.setComponentConfigurator( configuratorConfig.getValue() );\n        }\n\n        PlexusConfiguration composerConfig = c.getChild( \"composer\" );\n\n        if ( composerConfig != null )\n        {\n            mojo.setComponentComposer( composerConfig.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        String executePhase = c.getChild( \"executePhase\" ).getValue();\n\n        if ( executePhase != null )\n        {\n            mojo.setExecutePhase( executePhase );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String dependencyResolution = c.getChild( \"requiresDependencyResolution\" ).getValue();\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setDependencyResolutionRequired( dependencyResolution );\n        }\n\n        String requiresProject = c.getChild( \"requiresProject\" ).getValue();\n\n        if ( requiresProject != null )\n        {\n            mojo.setProjectRequired( Boolean.valueOf( requiresProject ).booleanValue() );\n        }\n\n        String requiresOnline = c.getChild( \"requiresOnline\" ).getValue();\n\n        if ( requiresOnline != null )\n        {\n            mojo.setOnlineRequired( Boolean.valueOf( requiresOnline ).booleanValue() );\n        }\n\n        String inheritedByDefault = c.getChild( \"inheritedByDefault\" ).getValue();\n\n        if ( inheritedByDefault != null )\n        {\n            mojo.setInheritedByDefault( Boolean.valueOf( inheritedByDefault ).booleanValue() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List parameters = new ArrayList();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setAlias( d.getChild( \"alias\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String required = d.getChild( \"required\" ).getValue();\n\n            parameter.setRequired( Boolean.valueOf( required ).booleanValue() );\n\n            PlexusConfiguration editableConfig = d.getChild( \"editable\" );\n\n            // we need the null check for pre-build legacy plugins...\n            if ( editableConfig != null )\n            {\n                String editable = d.getChild( \"editable\" ).getValue();\n\n                parameter.setEditable( editable == null || Boolean.valueOf( editable ).booleanValue() );\n            }\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setExpression( d.getChild( \"expression\" ).getValue() );\n\n            parameter.setDeprecated( d.getChild( \"deprecated\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n\n        // TODO: Go back to this when we get the container ready to configure mojos...\n        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","id":22411,"modified_method":"public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDescriptor pluginDescriptor )\n        throws PlexusConfigurationException\n    {\n        MojoDescriptor mojo = new MojoDescriptor();\n        mojo.setPluginDescriptor( pluginDescriptor );\n\n        mojo.setGoal( c.getChild( \"goal\" ).getValue() );\n\n        mojo.setImplementation( c.getChild( \"implementation\" ).getValue() );\n\n        PlexusConfiguration langConfig = c.getChild( \"language\" );\n\n        if ( langConfig != null )\n        {\n            mojo.setLanguage( langConfig.getValue() );\n        }\n\n        PlexusConfiguration configuratorConfig = c.getChild( \"configurator\" );\n\n        if ( configuratorConfig != null )\n        {\n            mojo.setComponentConfigurator( configuratorConfig.getValue() );\n        }\n\n        PlexusConfiguration composerConfig = c.getChild( \"composer\" );\n\n        if ( composerConfig != null )\n        {\n            mojo.setComponentComposer( composerConfig.getValue() );\n        }\n\n        String phase = c.getChild( \"phase\" ).getValue();\n\n        if ( phase != null )\n        {\n            mojo.setPhase( phase );\n        }\n\n        String executePhase = c.getChild( \"executePhase\" ).getValue();\n\n        if ( executePhase != null )\n        {\n            mojo.setExecutePhase( executePhase );\n        }\n\n        mojo.setInstantiationStrategy( c.getChild( \"instantiationStrategy\" ).getValue() );\n\n        mojo.setDescription( c.getChild( \"description\" ).getValue() );\n\n        String dependencyResolution = c.getChild( \"requiresDependencyResolution\" ).getValue();\n\n        if ( dependencyResolution != null )\n        {\n            mojo.setDependencyResolutionRequired( dependencyResolution );\n        }\n\n        String requiresProject = c.getChild( \"requiresProject\" ).getValue();\n\n        if ( requiresProject != null )\n        {\n            mojo.setProjectRequired( Boolean.valueOf( requiresProject ).booleanValue() );\n        }\n\n        String requiresOnline = c.getChild( \"requiresOnline\" ).getValue();\n\n        if ( requiresOnline != null )\n        {\n            mojo.setOnlineRequired( Boolean.valueOf( requiresOnline ).booleanValue() );\n        }\n\n        String inheritedByDefault = c.getChild( \"inheritedByDefault\" ).getValue();\n\n        if ( inheritedByDefault != null )\n        {\n            mojo.setInheritedByDefault( Boolean.valueOf( inheritedByDefault ).booleanValue() );\n        }\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] parameterConfigurations = c.getChild( \"parameters\" ).getChildren( \"parameter\" );\n\n        List parameters = new ArrayList();\n\n        for ( int i = 0; i < parameterConfigurations.length; i++ )\n        {\n            PlexusConfiguration d = parameterConfigurations[i];\n\n            Parameter parameter = new Parameter();\n\n            parameter.setName( d.getChild( \"name\" ).getValue() );\n\n            parameter.setAlias( d.getChild( \"alias\" ).getValue() );\n\n            parameter.setType( d.getChild( \"type\" ).getValue() );\n\n            String required = d.getChild( \"required\" ).getValue();\n\n            parameter.setRequired( Boolean.valueOf( required ).booleanValue() );\n\n            PlexusConfiguration editableConfig = d.getChild( \"editable\" );\n\n            // we need the null check for pre-build legacy plugins...\n            if ( editableConfig != null )\n            {\n                String editable = d.getChild( \"editable\" ).getValue();\n\n                parameter.setEditable( editable == null || Boolean.valueOf( editable ).booleanValue() );\n            }\n\n            parameter.setDescription( d.getChild( \"description\" ).getValue() );\n\n            parameter.setDeprecated( d.getChild( \"deprecated\" ).getValue() );\n\n            parameters.add( parameter );\n        }\n\n        mojo.setParameters( parameters );\n\n        // TODO: this should not need to be handed off...\n\n        // ----------------------------------------------------------------------\n        // Configuration\n        // ----------------------------------------------------------------------\n\n        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n\n        // TODO: Go back to this when we get the container ready to configure mojos...\n        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        PlexusConfiguration[] requirements = c.getChild( \"requirements\" ).getChildren( \"requirement\" );\n\n        for ( int i = 0; i < requirements.length; i++ )\n        {\n            PlexusConfiguration requirement = requirements[i];\n\n            ComponentRequirement cr = new ComponentRequirement();\n\n            cr.setRole( requirement.getChild( \"role\" ).getValue() );\n\n            cr.setRoleHint( requirement.getChild( \"role-hint\" ).getValue() );\n\n            cr.setFieldName( requirement.getChild( \"field-name\" ).getValue() );\n\n            mojo.addRequirement( cr );\n        }\n\n        return mojo;\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n\n        w.writeText( mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"inheritedByDefault\", \"\" + mojoDescriptor.isInheritedByDefault() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n\n            w.writeText( mojoDescriptor.getComponentComposer() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n        \n        Map configuration = new HashMap();\n        \n        if( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                Parameter parameter = (Parameter) parameters.get( j );\n\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    requirements.add( parameter );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        element( w, \"deprecated\", parameter.getDeprecated() );\n                    }\n\n                    element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    element( w, \"description\", parameter.getDescription() );\n\n                    if ( expression != null && expression.length() > 0 )\n                    {\n                        configuration.put( parameter, expression );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.keySet().iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                w.writeText( (String) configuration.get( parameter ) );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                // remove \"component.\" plus expression delimiters\n                String expression = requirement.getExpression();\n                String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                element( w, \"role\", role );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","id":22412,"modified_method":"protected void processMojoDescriptor( MojoDescriptor mojoDescriptor, XMLWriter w )\n    {\n        w.startElement( \"mojo\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"goal\" );\n\n        w.writeText( mojoDescriptor.getGoal() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n            element( w, \"requiresDependencyResolution\", mojoDescriptor.isDependencyResolutionRequired() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresProject\", \"\" + mojoDescriptor.isProjectRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"requiresOnline\", \"\" + mojoDescriptor.isOnlineRequired() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        element( w, \"inheritedByDefault\", \"\" + mojoDescriptor.isInheritedByDefault() );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getPhase() != null )\n        {\n            element( w, \"phase\", mojoDescriptor.getPhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getExecutePhase() != null )\n        {\n            element( w, \"executePhase\", mojoDescriptor.getExecutePhase() );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"implementation\" );\n\n        w.writeText( mojoDescriptor.getImplementation() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"language\" );\n\n        w.writeText( mojoDescriptor.getLanguage() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentConfigurator() != null )\n        {\n            w.startElement( \"configurator\" );\n\n            w.writeText( mojoDescriptor.getComponentConfigurator() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( mojoDescriptor.getComponentComposer() != null )\n        {\n            w.startElement( \"composer\" );\n\n            w.writeText( mojoDescriptor.getComponentComposer() );\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.startElement( \"instantiationStrategy\" );\n\n        w.writeText( mojoDescriptor.getInstantiationStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Strategy for handling repeated reference to mojo in\n        // the calculated (decorated, resolved) execution stack\n        // ----------------------------------------------------------------------\n        w.startElement( \"executionStrategy\" );\n\n        w.writeText( mojoDescriptor.getExecutionStrategy() );\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Parameters\n        // ----------------------------------------------------------------------\n\n        List parameters = mojoDescriptor.getParameters();\n\n        w.startElement( \"parameters\" );\n\n        Collection requirements = new ArrayList();\n\n        Set configuration = new HashSet();\n\n        if ( parameters != null )\n        {\n            for ( int j = 0; j < parameters.size(); j++ )\n            {\n                Parameter parameter = (Parameter) parameters.get( j );\n\n                String expression = parameter.getExpression();\n\n                if ( StringUtils.isNotEmpty( expression ) && expression.startsWith( \"${component.\" ) )\n                {\n                    // treat it as a component...a requirement, in other words.\n\n                    requirements.add( parameter );\n                }\n                else\n                {\n                    // treat it as a normal parameter.\n\n                    w.startElement( \"parameter\" );\n\n                    element( w, \"name\", parameter.getName() );\n\n                    if ( parameter.getAlias() != null )\n                    {\n                        element( w, \"alias\", parameter.getAlias() );\n                    }\n\n                    element( w, \"type\", parameter.getType() );\n\n                    if ( parameter.getDeprecated() != null )\n                    {\n                        element( w, \"deprecated\", parameter.getDeprecated() );\n                    }\n\n                    element( w, \"required\", Boolean.toString( parameter.isRequired() ) );\n\n                    element( w, \"editable\", Boolean.toString( parameter.isEditable() ) );\n\n                    element( w, \"description\", parameter.getDescription() );\n\n                    if ( StringUtils.isNotEmpty( parameter.getDefaultValue() ) ||\n                        StringUtils.isNotEmpty( parameter.getExpression() ) )\n                    {\n                        configuration.add( parameter );\n                    }\n\n                    w.endElement();\n                }\n\n            }\n        }\n\n        w.endElement();\n\n        // ----------------------------------------------------------------------\n        // Coinfiguration\n        // ----------------------------------------------------------------------\n\n        if ( !configuration.isEmpty() )\n        {\n            w.startElement( \"configuration\" );\n\n            for ( Iterator i = configuration.iterator(); i.hasNext(); )\n            {\n                Parameter parameter = (Parameter) i.next();\n\n                w.startElement( parameter.getName() );\n\n                String type = parameter.getType();\n                if ( type != null )\n                {\n                    w.addAttribute( \"implementation\", type );\n                }\n\n                if ( parameter.getDefaultValue() != null )\n                {\n                    w.addAttribute( \"default-value\", parameter.getDefaultValue() );\n                }\n\n                if ( parameter.getExpression() != null )\n                {\n                    w.writeText( parameter.getExpression() );\n                }\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        // Requirements\n        // ----------------------------------------------------------------------\n\n        if ( !requirements.isEmpty() )\n        {\n            w.startElement( \"requirements\" );\n\n            for ( Iterator i = requirements.iterator(); i.hasNext(); )\n            {\n                Parameter requirement = (Parameter) i.next();\n\n                w.startElement( \"requirement\" );\n\n                // remove \"component.\" plus expression delimiters\n                String expression = requirement.getExpression();\n                String role = expression.substring( \"${component.\".length(), expression.length() - 1 );\n\n                element( w, \"role\", role );\n\n                element( w, \"field-name\", requirement.getName() );\n\n                w.endElement();\n            }\n\n            w.endElement();\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        w.endElement();\n    }","commit_id":"a48cfef4eb8184fc26f3dc4ed68e98b455a3aa16","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Returns true if the detail pages can be edited.\n     *  \n     * @return true if the detail pages can be edited \n     */\n    public boolean canEditDetailPages() {\n\n        return m_canEditDetailPages;\n    }","id":22413,"modified_method":"/**\n     * Returns true if the detail pages can be edited.\n     *  \n     * @return true if the detail pages can be edited \n     */\n    public boolean canEditDetailPages() {\n\n        return m_canEditDetailPages && (m_resourceTypeInfos != null) && !m_resourceTypeInfos.isEmpty();\n    }","commit_id":"8847230071c7e00655eff6dda49151605e59fc9c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param controller the sitemap controller \n     */\n    public CmsSitemapToolbar(CmsSitemapController controller) {\n\n        addLeft(new CmsToolbarPublishButton(this, controller));\n        m_newMenuButton = new CmsToolbarNewButton(this, controller);\n        if (controller.isEditable()) {\n            addLeft(m_newMenuButton);\n            addLeft(new CmsToolbarClipboardButton(this, controller));\n        }\n        addLeft(new CmsToolbarShowNonNavigationButton());\n    }","id":22414,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param controller the sitemap controller \n     */\n    public CmsSitemapToolbar(CmsSitemapController controller) {\n\n        addLeft(new CmsToolbarPublishButton(this, controller));\n        m_newMenuButton = new CmsToolbarNewButton(this, controller);\n        if (controller.isEditable() && (controller.getData().getDefaultNewElementInfo() != null)) {\n            addLeft(m_newMenuButton);\n            addLeft(new CmsToolbarClipboardButton(this, controller));\n        }\n        addLeft(new CmsToolbarShowNonNavigationButton());\n    }","commit_id":"8847230071c7e00655eff6dda49151605e59fc9c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.sitemap.client.toolbar.A_CmsToolbarListMenuButton#initContent()\n     */\n    @Override\n    protected void initContent() {\n\n        boolean hasTabs = false;\n        m_newElementsList = new CmsList<I_CmsListItem>();\n        for (CmsNewResourceInfo info : getController().getData().getNewElementInfos()) {\n            m_newElementsList.add(makeNewElementItem(info));\n        }\n        if (m_newElementsList.getWidgetCount() > 0) {\n            hasTabs = true;\n            addTab(\n                createTab(Messages.get().key(Messages.GUI_NEW_PAGES_TAB_DESCRIPTION_0), m_newElementsList),\n                Messages.get().key(Messages.GUI_NEW_PAGES_TAB_TITLE_0));\n        }\n        m_specialList = new CmsList<I_CmsListItem>();\n        m_specialList.add(makeRedirectItem());\n        if (CmsSitemapView.getInstance().getController().getData().canEditDetailPages()) {\n            for (CmsNewResourceInfo typeInfo : CmsSitemapView.getInstance().getController().getData().getResourceTypeInfos()) {\n                CmsCreatableListItem item = makeDetailPageItem(typeInfo);\n                m_specialList.add(item);\n            }\n        }\n        if (m_specialList.getWidgetCount() > 0) {\n            hasTabs = true;\n            addTab(\n                createTab(Messages.get().key(Messages.GUI_SPECIAL_TAB_DESCRIPTION_0), m_specialList),\n                Messages.get().key(Messages.GUI_SPECIAL_TAB_TITLE_0));\n        }\n        if (!hasTabs) {\n            // no new elements available, show appropriate message\n\n            //TODO: improve styling, add localization\n            Label messageLabel = new Label(Messages.get().key(Messages.GUI_NO_CREATABLE_ELEMENTS_0));\n            messageLabel.addStyleName(I_CmsLayoutBundle.INSTANCE.clipboardCss().menuTabContainer());\n            SimplePanel content = new SimplePanel();\n            content.setWidget(messageLabel);\n            setMenuWidget(messageLabel);\n        }\n    }","id":22415,"modified_method":"/**\n     * @see org.opencms.ade.sitemap.client.toolbar.A_CmsToolbarListMenuButton#initContent()\n     */\n    @Override\n    protected void initContent() {\n\n        boolean hasTabs = false;\n        m_newElementsList = new CmsList<I_CmsListItem>();\n        for (CmsNewResourceInfo info : getController().getData().getNewElementInfos()) {\n            m_newElementsList.add(makeNewElementItem(info));\n        }\n        if (m_newElementsList.getWidgetCount() > 0) {\n            hasTabs = true;\n            addTab(\n                createTab(Messages.get().key(Messages.GUI_NEW_PAGES_TAB_DESCRIPTION_0), m_newElementsList),\n                Messages.get().key(Messages.GUI_NEW_PAGES_TAB_TITLE_0));\n        }\n        m_specialList = new CmsList<I_CmsListItem>();\n        m_specialList.add(makeRedirectItem());\n        CmsSitemapController controller = CmsSitemapView.getInstance().getController();\n        if (controller.getData().canEditDetailPages()) {\n            for (CmsNewResourceInfo typeInfo : controller.getData().getResourceTypeInfos()) {\n                CmsCreatableListItem item = makeDetailPageItem(typeInfo);\n                m_specialList.add(item);\n            }\n        }\n        if (m_specialList.getWidgetCount() > 0) {\n            hasTabs = true;\n            addTab(\n                createTab(Messages.get().key(Messages.GUI_SPECIAL_TAB_DESCRIPTION_0), m_specialList),\n                Messages.get().key(Messages.GUI_SPECIAL_TAB_TITLE_0));\n        }\n        if (!hasTabs) {\n            // no new elements available, show appropriate message\n\n            //TODO: improve styling, add localization\n            Label messageLabel = new Label(Messages.get().key(Messages.GUI_NO_CREATABLE_ELEMENTS_0));\n            messageLabel.addStyleName(I_CmsLayoutBundle.INSTANCE.clipboardCss().menuTabContainer());\n            SimplePanel content = new SimplePanel();\n            content.setWidget(messageLabel);\n            setMenuWidget(messageLabel);\n        }\n    }","commit_id":"8847230071c7e00655eff6dda49151605e59fc9c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n  public boolean equals(Object obj) {\n    if (obj == null) {\n      return false;\n    }\n    if (!((obj instanceof ChildrenCountDifference))) {\n      return false;\n    }\n    ChildrenCountDifference diff = (ChildrenCountDifference) obj;\n    return myRole.equals(diff.myRole) && myCount1 == diff.myCount1 && myCount2 == diff.myCount2;\n  }","id":22416,"modified_method":"@Override\n  public boolean equals(Object obj) {\n    if (obj == null) {\n      return false;\n    }\n    if (!((obj instanceof ChildrenCountDifference))) {\n      return false;\n    }\n    ChildrenCountDifference diff = (ChildrenCountDifference) obj;\n    return myRole.equals(diff.myRole) && myActualCount == diff.myActualCount && myExpectedCount == diff.myExpectedCount;\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ChildrenCountDifference(String role, int c1, int c2) {\n    myRole = role;\n    myCount1 = c1;\n    myCount2 = c2;\n  }","id":22417,"modified_method":"public ChildrenCountDifference(String role, int actualCount, int expectedCount) {\n    myRole = role;\n    myActualCount = actualCount;\n    myExpectedCount = expectedCount;\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String toString() {\n    return \"Different children count in role: \" + myRole + \" [\" + myCount1 + \", \" + myCount2 + \"]\";\n  }","id":22418,"modified_method":"@Override\n  public String toString() {\n    return \"Different children count in role: \" + myRole + \" [was: \" + myActualCount + \", expected: \" + myExpectedCount + \"]\";\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean equals(Object obj) {\n    if (obj == null) {\n      return false;\n    }\n    if (!((obj instanceof ConceptDifference))) {\n      return false;\n    }\n    ConceptDifference diff = (ConceptDifference) obj;\n    return myConcept1.equals(diff.myConcept1) && myConcept2.equals(diff.myConcept2);\n  }","id":22419,"modified_method":"@Override\n  public boolean equals(Object obj) {\n    if (obj == null) {\n      return false;\n    }\n    if (!((obj instanceof ConceptDifference))) {\n      return false;\n    }\n    ConceptDifference diff = (ConceptDifference) obj;\n    return myActualConcept.equals(diff.myActualConcept) && myExpectedConcept.equals(diff.myExpectedConcept);\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDifference(String concept1, String concept2) {\n    myConcept1 = concept1;\n    myConcept2 = concept2;\n  }","id":22420,"modified_method":"public ConceptDifference(String actualConcept, String expectedConcept) {\n    myActualConcept = actualConcept;\n    myExpectedConcept = expectedConcept;\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String toString() {\n    return \"Different concepts: \" + myConcept1 + \", \" + myConcept2;\n  }","id":22421,"modified_method":"@Override\n  public String toString() {\n    return \"Different concepts: [was: \" + myActualConcept + \", expected: \" + myExpectedConcept + \"]\";\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean putTextInErrorChild(CellInfo cellInfo, String textToSet, EditorContext editorContext) {\n    editorContext.flushEvents();\n    EditorComponent component = (EditorComponent) editorContext.getEditorComponent();\n    EditorCell cellToSelect = cellInfo.findCell(component);\n    if (cellToSelect != null) {\n      EditorCell_Label label = CellFinderUtil.findFirstError(cellToSelect, true);\n      if (label != null) {\n        if (label.isEditable() && !(label instanceof EditorCell_Constant)) {\n          label.changeText(textToSet);\n          return true;\n        }\n        label.end();\n      }\n    }\n    return false;\n  }","id":22422,"modified_method":"private static boolean putTextInErrorChild(CellInfo cellInfo, String textToSet, EditorContext editorContext) {\n    editorContext.flushEvents();\n    EditorComponent component = (EditorComponent) editorContext.getEditorComponent();\n    EditorCell cellToSelect = cellInfo.findCell(component);\n    if (cellToSelect != null) {\n      EditorCell_Label label = CellFinderUtil.findFirstError(cellToSelect, true);\n      if (label != null && label != cellToSelect && label.isEditable() && !(label instanceof EditorCell_Constant)) {\n        label.changeText(textToSet);\n        label.end();\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"a5965171b8dd02c4f71a66f7c0c66b543cee0107","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <AdapterType> AdapterType adaptTo(final Class<AdapterType> type) {\n        if (type == ModifiableValueMap.class) {\n            final Iterator<Resource> iter = this.picker.pickResources(this.getResourceResolver(), this.relativePath);\n            Resource highestRsrc = null;\n            while ( iter.hasNext() ) {\n                highestRsrc = iter.next();\n            }\n            if ( ResourceUtil.isNonExistingResource(highestRsrc) ) {\n                final String paths[] = (String[])this.getResourceMetadata().get(MergedResourceConstants.METADATA_RESOURCES);\n\n                final Resource copyResource = this.getResourceResolver().getResource(paths[paths.length - 1]);\n                try {\n                    final Resource newResource = ResourceUtil.getOrCreateResource(this.getResourceResolver(), highestRsrc.getPath(), copyResource.getResourceType(), null, false);\n                    final ModifiableValueMap target = newResource.adaptTo(ModifiableValueMap.class);\n                    if ( target != null ) {\n                        return (AdapterType)new ModifiableProperties(this, target);\n                    }\n                } catch ( final PersistenceException pe) {\n                    // we ignore this for now\n                }\n                return super.adaptTo(type);\n            }\n            final ModifiableValueMap target = highestRsrc.adaptTo(ModifiableValueMap.class);\n            if ( target != null ) {\n                return (AdapterType)new ModifiableProperties(this, target);\n            }\n        }\n        return super.adaptTo(type);\n    }","id":22423,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <AdapterType> AdapterType adaptTo(final Class<AdapterType> type) {\n        if (type == ModifiableValueMap.class) {\n            final Iterator<Resource> iter = this.picker.pickResources(this.getResourceResolver(), this.relativePath).iterator();\n            Resource highestRsrc = null;\n            while ( iter.hasNext() ) {\n                highestRsrc = iter.next();\n            }\n            if ( ResourceUtil.isNonExistingResource(highestRsrc) ) {\n                final String paths[] = (String[])this.getResourceMetadata().get(MergedResourceConstants.METADATA_RESOURCES);\n\n                final Resource copyResource = this.getResourceResolver().getResource(paths[paths.length - 1]);\n                try {\n                    final Resource newResource = ResourceUtil.getOrCreateResource(this.getResourceResolver(), highestRsrc.getPath(), copyResource.getResourceType(), null, false);\n                    final ModifiableValueMap target = newResource.adaptTo(ModifiableValueMap.class);\n                    if ( target != null ) {\n                        return (AdapterType)new ModifiableProperties(this, target);\n                    }\n                } catch ( final PersistenceException pe) {\n                    // we ignore this for now\n                }\n                return super.adaptTo(type);\n            }\n            final ModifiableValueMap target = highestRsrc.adaptTo(ModifiableValueMap.class);\n            if ( target != null ) {\n                return (AdapterType)new ModifiableProperties(this, target);\n            }\n        }\n        return super.adaptTo(type);\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"private ExtendedResourceHolder getAllResources(final ResourceResolver resolver,\n            final String path,\n            final String relativePath) {\n        final ExtendedResourceHolder holder = new ExtendedResourceHolder();\n        holder.holder = new ResourceHolder(ResourceUtil.getName(path));\n\n        holder.count = 0;\n\n        // Loop over resources\n        final Iterator<Resource> iter = this.picker.pickResources(resolver, relativePath);\n        while ( iter.hasNext() ) {\n            final Resource rsrc = iter.next();\n            holder.count++;\n            if ( holder.count == 1 ) {\n                holder.lowestResourcePath = rsrc.getPath();\n            }\n            holder.highestResourcePath = rsrc.getPath();\n            if ( !ResourceUtil.isNonExistingResource(rsrc) ) {\n                // check parent for hiding\n                final Resource parent = rsrc.getParent();\n                if ( parent != null ) {\n                    final boolean hidden = new ParentHidingHandler(parent).isHidden(holder.holder.name);\n                    if ( hidden ) {\n                        holder.holder.resources.clear();\n                    } else {\n                        holder.holder.resources.add(rsrc);\n                    }\n                }\n            }\n        }\n\n        return holder;\n    }","id":22424,"modified_method":"private ExtendedResourceHolder getAllResources(final ResourceResolver resolver,\n            final String path,\n            final String relativePath) {\n        final ExtendedResourceHolder holder = new ExtendedResourceHolder();\n        holder.holder = new ResourceHolder(ResourceUtil.getName(path));\n\n        holder.count = 0;\n\n        // Loop over resources\n        final Iterator<Resource> iter = this.picker.pickResources(resolver, relativePath).iterator();\n        while ( iter.hasNext() ) {\n            final Resource rsrc = iter.next();\n            holder.count++;\n            if ( holder.count == 1 ) {\n                holder.lowestResourcePath = rsrc.getPath();\n            }\n            holder.highestResourcePath = rsrc.getPath();\n            if ( !ResourceUtil.isNonExistingResource(rsrc) ) {\n                // check parent for hiding\n                final Resource parent = rsrc.getParent();\n                if ( parent != null ) {\n                    final boolean hidden = new ParentHidingHandler(parent).isHidden(holder.holder.name);\n                    if ( hidden ) {\n                        holder.holder.resources.clear();\n                    } else {\n                        holder.holder.resources.add(rsrc);\n                    }\n                }\n            }\n        }\n\n        return holder;\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"@Before public void setup() throws Exception {\n        final MockResourceResolverFactoryOptions options = new MockResourceResolverFactoryOptions();\n        options.setSearchPaths(new String[] {\"/apps/\", \"/libs/\"});\n        final ResourceResolverFactory factory = new MockResourceResolverFactory(options);\n        this.resolver = factory.getAdministrativeResourceResolver(null);\n        MockHelper.create(this.resolver).resource(\"/apps\")\n                                          .resource(\"a\").p(MergedResourceConstants.PN_HIDE_CHILDREN, new String[] {\"Z\", \"x\", \"y\"})\n                                            .resource(\"1\").p(\"a\", \"1\").p(\"b\", \"2\")\n                                            .resource(\".2\").p(ResourceResolver.PROPERTY_RESOURCE_TYPE, \"apps\")\n                                            .resource(\".3\").p(\"e\", \"2\")\n                                                           .p(MergedResourceConstants.PN_HIDE_PROPERTIES, \"*\")\n                                                           .p(\"b\", \"x\")\n                                                           .p(\"d\", \"1\")\n                                            .resource(\".4\").p(\"e\", \"2\")\n                                                           .p(MergedResourceConstants.PN_HIDE_PROPERTIES, new String[] {\"a\", \"c\"})\n                                                           .p(\"b\", \"x\")\n                                                           .p(\"d\", \"1\")\n                                            .resource(\".X\")\n                                        .resource(\"/libs\")\n                                          .resource(\"deleteTest\")\n                                          .resource(\".mvmTest\").p(\"a\", \"1\").p(\"b\", \"2\")\n                                          .resource(\".a\")\n                                            .resource(\"1\").p(\"a\", \"5\").p(\"c\", \"2\")\n                                            .resource(\".2\").p(ResourceResolver.PROPERTY_RESOURCE_TYPE, \"libs\")\n                                            .resource(\".3\").p(\"a\", \"1\").p(\"b\", \"2\").p(\"c\", \"3\")\n                                            .resource(\".4\").p(\"a\", \"1\").p(\"b\", \"2\").p(\"c\", \"3\")\n                                            .resource(\".Y\")\n                                            .resource(\".Z\")\n                                        .commit();\n\n        this.provider = new CRUDMergingResourceProvider(\"/merged\", new MergingResourcePicker());\n    }","id":22425,"modified_method":"@Before public void setup() throws Exception {\n        final MockResourceResolverFactoryOptions options = new MockResourceResolverFactoryOptions();\n        options.setSearchPaths(new String[] {\"/apps/\", \"/libs/\"});\n        final ResourceResolverFactory factory = new MockResourceResolverFactory(options);\n        this.resolver = factory.getResourceResolver(null);\n        MockHelper.create(this.resolver).resource(\"/apps\")\n                                          .resource(\"a\").p(MergedResourceConstants.PN_HIDE_CHILDREN, new String[] {\"Z\", \"x\", \"y\"})\n                                            .resource(\"1\").p(\"a\", \"1\").p(\"b\", \"2\")\n                                            .resource(\".2\").p(ResourceResolver.PROPERTY_RESOURCE_TYPE, \"apps\")\n                                            .resource(\".3\").p(\"e\", \"2\")\n                                                           .p(MergedResourceConstants.PN_HIDE_PROPERTIES, \"*\")\n                                                           .p(\"b\", \"x\")\n                                                           .p(\"d\", \"1\")\n                                            .resource(\".4\").p(\"e\", \"2\")\n                                                           .p(MergedResourceConstants.PN_HIDE_PROPERTIES, new String[] {\"a\", \"c\"})\n                                                           .p(\"b\", \"x\")\n                                                           .p(\"d\", \"1\")\n                                            .resource(\".X\")\n                                        .resource(\"/libs\")\n                                          .resource(\"deleteTest\")\n                                          .resource(\".mvmTest\").p(\"a\", \"1\").p(\"b\", \"2\")\n                                          .resource(\".a\")\n                                            .resource(\"1\").p(\"a\", \"5\").p(\"c\", \"2\")\n                                            .resource(\".2\").p(ResourceResolver.PROPERTY_RESOURCE_TYPE, \"libs\")\n                                            .resource(\".3\").p(\"a\", \"1\").p(\"b\", \"2\").p(\"c\", \"3\")\n                                            .resource(\".4\").p(\"a\", \"1\").p(\"b\", \"2\").p(\"c\", \"3\")\n                                            .resource(\".Y\")\n                                            .resource(\".Z\")\n                                        .commit();\n\n        this.provider = new CRUDMergingResourceProvider(\"/merged\", new MergingResourcePicker());\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"public Iterator<Resource> pickResources(final ResourceResolver resolver, final String relativePath) {\n        final List<Resource> resources = new ArrayList<Resource>();\n        final String[] searchPaths = resolver.getSearchPath();\n        for (int i = searchPaths.length - 1; i >= 0; i--) {\n            final String basePath = searchPaths[i];\n            final String fullPath = basePath + relativePath;\n            final Resource resource = resolver.getResource(fullPath);\n            if (resource != null) {\n                resources.add(resource);\n            } else {\n                resources.add(new NonExistingResource(resolver, fullPath));\n            }\n        }\n        return resources.iterator();\n    }","id":22426,"modified_method":"public List<Resource> pickResources(final ResourceResolver resolver, final String relativePath) {\n        final List<Resource> resources = new ArrayList<Resource>();\n        final String[] searchPaths = resolver.getSearchPath();\n        for (int i = searchPaths.length - 1; i >= 0; i--) {\n            final String basePath = searchPaths[i];\n            final String fullPath = basePath + relativePath;\n            final Resource resource = resolver.getResource(fullPath);\n            if (resource != null) {\n                resources.add(resource);\n            } else {\n                resources.add(new NonExistingResource(resolver, fullPath));\n            }\n        }\n        return resources;\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public Iterator<Resource> listChildren(Resource resource) {\n        final ResourceResolver resolver = resource.getResourceResolver();\n\n        final String relativePath = getRelativePath(resource.getPath());\n\n        if (relativePath != null) {\n            final List<ResourceHolder> candidates = new ArrayList<ResourceHolder>();\n\n            final Iterator<Resource> resources = picker.pickResources(resolver, relativePath);\n\n            while (resources.hasNext()) {\n                Resource parentResource = resources.next();\n                final ParentHidingHandler handler = new ParentHidingHandler(parentResource);\n                for (final Resource child : parentResource.getChildren()) {\n                    final String rsrcName = child.getName();\n                    ResourceHolder holder = null;\n                    for (final ResourceHolder current : candidates) {\n                        if (current.name.equals(rsrcName)) {\n                            holder = current;\n                            break;\n                        }\n                    }\n                    if (holder == null) {\n                        holder = new ResourceHolder(rsrcName);\n                        candidates.add(holder);\n                    }\n                    holder.resources.add(child);\n\n                    // Check if children need reordering\n                    int orderBeforeIndex = -1;\n                    final ValueMap vm = child.getValueMap();\n                    final String orderBefore = vm.get(MergedResourceConstants.PN_ORDER_BEFORE, String.class);\n                    if (orderBefore != null && !orderBefore.equals(rsrcName)) {\n                        // search entry\n                        int index = 0;\n                        while (index < candidates.size()) {\n                            final ResourceHolder current = candidates.get(index);\n                            if (current.name.equals(orderBefore)) {\n                                orderBeforeIndex = index;\n                                break;\n                            }\n                            index++;\n                        }\n                    }\n\n                    if (orderBeforeIndex > -1) {\n                        candidates.add(orderBeforeIndex, holder);\n                        candidates.remove(candidates.size() - 1);\n                    }\n                }\n                final Iterator<ResourceHolder> iter = candidates.iterator();\n                while (iter.hasNext()) {\n                    final ResourceHolder holder = iter.next();\n                    if (handler.isHidden(holder.name)) {\n                        iter.remove();\n                    }\n                }\n            }\n            final List<Resource> children = new ArrayList<Resource>();\n            for (final ResourceHolder holder : candidates) {\n                final Resource mergedResource = this.createMergedResource(resolver,\n                        (relativePath.length() == 0 ? holder.name : relativePath + '/' + holder.name), holder);\n                if (mergedResource != null) {\n                    children.add(mergedResource);\n                }\n            }\n            return children.iterator();\n        }\n\n        return null;\n    }","id":22427,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public Iterator<Resource> listChildren(Resource resource) {\n        final ResourceResolver resolver = resource.getResourceResolver();\n\n        final String relativePath = getRelativePath(resource.getPath());\n\n        if (relativePath != null) {\n            final List<ResourceHolder> candidates = new ArrayList<ResourceHolder>();\n\n            final Iterator<Resource> resources = picker.pickResources(resolver, relativePath).iterator();\n\n            while (resources.hasNext()) {\n                Resource parentResource = resources.next();\n                final ParentHidingHandler handler = new ParentHidingHandler(parentResource);\n                for (final Resource child : parentResource.getChildren()) {\n                    final String rsrcName = child.getName();\n                    ResourceHolder holder = null;\n                    for (final ResourceHolder current : candidates) {\n                        if (current.name.equals(rsrcName)) {\n                            holder = current;\n                            break;\n                        }\n                    }\n                    if (holder == null) {\n                        holder = new ResourceHolder(rsrcName);\n                        candidates.add(holder);\n                    }\n                    holder.resources.add(child);\n\n                    // Check if children need reordering\n                    int orderBeforeIndex = -1;\n                    final ValueMap vm = child.getValueMap();\n                    final String orderBefore = vm.get(MergedResourceConstants.PN_ORDER_BEFORE, String.class);\n                    if (orderBefore != null && !orderBefore.equals(rsrcName)) {\n                        // search entry\n                        int index = 0;\n                        while (index < candidates.size()) {\n                            final ResourceHolder current = candidates.get(index);\n                            if (current.name.equals(orderBefore)) {\n                                orderBeforeIndex = index;\n                                break;\n                            }\n                            index++;\n                        }\n                    }\n\n                    if (orderBeforeIndex > -1) {\n                        candidates.add(orderBeforeIndex, holder);\n                        candidates.remove(candidates.size() - 1);\n                    }\n                }\n                final Iterator<ResourceHolder> iter = candidates.iterator();\n                while (iter.hasNext()) {\n                    final ResourceHolder holder = iter.next();\n                    if (handler.isHidden(holder.name)) {\n                        iter.remove();\n                    }\n                }\n            }\n            final List<Resource> children = new ArrayList<Resource>();\n            for (final ResourceHolder holder : candidates) {\n                final Resource mergedResource = this.createMergedResource(resolver,\n                        (relativePath.length() == 0 ? holder.name : relativePath + '/' + holder.name), holder);\n                if (mergedResource != null) {\n                    children.add(mergedResource);\n                }\n            }\n            return children.iterator();\n        }\n\n        return null;\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public Resource getResource(final ResourceResolver resolver, final String path) {\n        final String relativePath = getRelativePath(path);\n\n        if (relativePath != null) {\n            final ResourceHolder holder = new ResourceHolder(ResourceUtil.getName(path));\n\n            final Iterator<Resource> resources = picker.pickResources(resolver, relativePath);\n\n            if (!resources.hasNext()) {\n                return null;\n            }\n\n            while (resources.hasNext()) {\n                final Resource resource = resources.next();\n                // check parent for hiding\n                // SLING 3521 : if parent is not readable, nothing is hidden\n                final Resource parent = resource.getParent();\n                final boolean hidden = new ParentHidingHandler(parent).isHidden(holder.name);\n                if (hidden) {\n                    holder.resources.clear();\n                } else if (!ResourceUtil.isNonExistingResource(resource)) {\n                    holder.resources.add(resource);\n                }\n            }\n            return createMergedResource(resolver, relativePath, holder);\n        }\n\n        return null;\n    }","id":22428,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public Resource getResource(final ResourceResolver resolver, final String path) {\n        final String relativePath = getRelativePath(path);\n\n        if (relativePath != null) {\n            final ResourceHolder holder = new ResourceHolder(ResourceUtil.getName(path));\n\n            final Iterator<Resource> resources = picker.pickResources(resolver, relativePath).iterator();\n\n            if (!resources.hasNext()) {\n                return null;\n            }\n\n            while (resources.hasNext()) {\n                final Resource resource = resources.next();\n                // check parent for hiding\n                // SLING 3521 : if parent is not readable, nothing is hidden\n                final Resource parent = resource.getParent();\n                final boolean hidden = new ParentHidingHandler(parent).isHidden(holder.name);\n                if (hidden) {\n                    holder.resources.clear();\n                } else if (!ResourceUtil.isNonExistingResource(resource)) {\n                    holder.resources.add(resource);\n                }\n            }\n            return createMergedResource(resolver, relativePath, holder);\n        }\n\n        return null;\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"public Iterator<Resource> pickResources(ResourceResolver resolver, String relativePath) {\n        String absPath = \"/\" + relativePath;\n        final List<Resource> resources = new ArrayList<Resource>();\n\n        Resource currentTarget = resolver.getResource(absPath);\n\n        if (currentTarget != null) {\n            resources.add(currentTarget);\n\n            while (currentTarget != null) {\n                final Resource inheritanceRootResource = findInheritanceRoot(currentTarget);\n                if (inheritanceRootResource == null) {\n                    currentTarget = null;\n                } else {\n                    final String relPath = currentTarget.getPath()\n                            .substring(inheritanceRootResource.getPath().length());\n                    final String superType = inheritanceRootResource.getResourceSuperType();\n                    if (superType == null) {\n                        currentTarget = null;\n                    } else {\n                        final String superTypeChildPath = superType + relPath;\n                        final Resource superTypeResource = resolver.getResource(superTypeChildPath);\n                        if (superTypeResource != null) {\n                            resources.add(superTypeResource);\n                            currentTarget = superTypeResource;\n                        } else {\n                            resources.add(new NonExistingResource(resolver, superTypeChildPath));\n                            currentTarget = null;\n                        }\n                    }\n                }\n            }\n\n            Collections.reverse(resources);\n        }\n        return resources.iterator();\n    }","id":22429,"modified_method":"public List<Resource> pickResources(ResourceResolver resolver, String relativePath) {\n        String absPath = \"/\" + relativePath;\n        final List<Resource> resources = new ArrayList<Resource>();\n\n        Resource currentTarget = resolver.getResource(absPath);\n\n        if (currentTarget != null) {\n            resources.add(currentTarget);\n\n            while (currentTarget != null) {\n                final Resource inheritanceRootResource = findInheritanceRoot(currentTarget);\n                if (inheritanceRootResource == null) {\n                    currentTarget = null;\n                } else {\n                    final String relPath = currentTarget.getPath()\n                            .substring(inheritanceRootResource.getPath().length());\n                    final String superType = inheritanceRootResource.getResourceSuperType();\n                    if (superType == null) {\n                        currentTarget = null;\n                    } else {\n                        final String superTypeChildPath = superType + relPath;\n                        final Resource superTypeResource = resolver.getResource(superTypeChildPath);\n                        if (superTypeResource != null) {\n                            resources.add(superTypeResource);\n                            currentTarget = superTypeResource;\n                        } else {\n                            resources.add(new NonExistingResource(resolver, superTypeChildPath));\n                            currentTarget = null;\n                        }\n                    }\n                }\n            }\n\n            Collections.reverse(resources);\n        }\n        return resources;\n    }","commit_id":"30d31f823994754862d34d4d9e27fa6f057bbfa8","url":"https://github.com/apache/sling"},{"original_method":"private ServerBootstrap createBootstrap() {\n    final ServerBootstrap boot = createBootstrapOfType(\n        mTachyonConf.getEnum(Constants.WORKER_NETWORK_NETTY_CHANNEL, ChannelType.defaultType()));\n\n    // use pooled buffers\n    boot.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n    boot.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n\n    // set write buffer\n    // this is the default, but its recommended to set it in case of change in future netty.\n    boot.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK,\n        mTachyonConf.getInt(Constants.WORKER_NETTY_WATERMARK_HIGH, 32 * 1024));\n    boot.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,\n        mTachyonConf.getInt(Constants.WORKER_NETTY_WATERMARK_LOW, 8 * 1024));\n\n    // more buffer settings\n    final int optBacklog = mTachyonConf.getInt(Constants.WORKER_NETTY_BACKLOG, -1);\n    if (optBacklog > 0) {\n      boot.option(ChannelOption.SO_BACKLOG, optBacklog);\n    }\n    final int optSendBuffer = mTachyonConf.getInt(Constants.WORKER_NETTY_SEND_BUFFER, -1);\n    if (optSendBuffer > 0) {\n      boot.option(ChannelOption.SO_SNDBUF, optSendBuffer);\n    }\n    final int optReceiveBuffer = mTachyonConf.getInt(Constants.WORKER_NETTY_RECEIVE_BUFFER, -1);\n    if (optReceiveBuffer > 0) {\n      boot.option(ChannelOption.SO_RCVBUF, optReceiveBuffer);\n    }\n    return boot;\n  }","id":22430,"modified_method":"private ServerBootstrap createBootstrap() {\n    final ServerBootstrap boot = createBootstrapOfType(\n        mTachyonConf.getEnum(Constants.WORKER_NETWORK_NETTY_CHANNEL, ChannelType.defaultType()));\n\n    // use pooled buffers\n    boot.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n    boot.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n\n    // set write buffer\n    // this is the default, but its recommended to set it in case of change in future netty.\n    boot.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK,\n        (int)mTachyonConf.getBytes(Constants.WORKER_NETTY_WATERMARK_HIGH, 32 * 1024));\n    boot.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK,\n        (int)mTachyonConf.getBytes(Constants.WORKER_NETTY_WATERMARK_LOW, 8 * 1024));\n\n    // more buffer settings\n    final int optBacklog = mTachyonConf.getInt(Constants.WORKER_NETTY_BACKLOG, -1);\n    if (optBacklog > 0) {\n      boot.option(ChannelOption.SO_BACKLOG, optBacklog);\n    }\n    final int optSendBuffer = mTachyonConf.getInt(Constants.WORKER_NETTY_SEND_BUFFER, -1);\n    if (optSendBuffer > 0) {\n      boot.option(ChannelOption.SO_SNDBUF, optSendBuffer);\n    }\n    final int optReceiveBuffer = mTachyonConf.getInt(Constants.WORKER_NETTY_RECEIVE_BUFFER, -1);\n    if (optReceiveBuffer > 0) {\n      boot.option(ChannelOption.SO_RCVBUF, optReceiveBuffer);\n    }\n    return boot;\n  }","commit_id":"e4b8dce357c5dae7550928ffba3f1444ecd6a25f","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @param file the file the block belongs to\n   * @param opType the OutStream's write type\n   * @param blockIndex the index of the block in the file\n   * @param tachyonConf the TachyonConf instance for this file output stream.\n   * @throws IOException\n   */\n  BlockOutStream(TachyonFile file, WriteType opType, int blockIndex, TachyonConf tachyonConf)\n      throws IOException {\n    this(file, opType, blockIndex,\n        tachyonConf.getLong(Constants.USER_QUOTA_UNIT_BYTES, 8 * Constants.MB), tachyonConf);\n  }","id":22431,"modified_method":"/**\n   * @param file the file the block belongs to\n   * @param opType the OutStream's write type\n   * @param blockIndex the index of the block in the file\n   * @param tachyonConf the TachyonConf instance for this file output stream.\n   * @throws IOException\n   */\n  BlockOutStream(TachyonFile file, WriteType opType, int blockIndex, TachyonConf tachyonConf)\n      throws IOException {\n    this(file, opType, blockIndex,\n        tachyonConf.getBytes(Constants.USER_QUOTA_UNIT_BYTES, 8 * Constants.MB), tachyonConf);\n  }","commit_id":"c3d226d697d5709df53a5000ee0553dbd9fb7050","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Makes sure mCurrentBuffer is set to read at mBlockPos. If it is already, we do\n   * nothing. Otherwise, we set mBufferStartPos accordingly and try to read the correct range of\n   * bytes remotely. If we fail to read remotely, mCurrentBuffer will be null at the end of the\n   * function\n   *\n   * @return true if mCurrentBuffer was successfully set to read at mBlockPos, or false if the\n   *         remote read failed.\n   * @throws IOException\n   */\n  private boolean updateCurrentBuffer() throws IOException {\n    long bufferSize =\n        mTachyonConf.getInt(Constants.USER_REMOTE_READ_BUFFER_SIZE_BYTE, Constants.MB);\n    if (mCurrentBuffer != null && mBufferStartPos <= mBlockPos\n        && mBlockPos < Math.min(mBufferStartPos + bufferSize, mBlockInfo.length)) {\n      // We move the buffer to read at mBlockPos\n      mCurrentBuffer.position((int) (mBlockPos - mBufferStartPos));\n      return true;\n    }\n\n    // We must read in a new block. By starting at mBlockPos, we ensure that the next byte read will\n    // be the one at mBlockPos\n    mBufferStartPos = mBlockPos;\n    long length = Math.min(bufferSize, mBlockInfo.length - mBufferStartPos);\n    LOG.info(String.format(\"Try to find remote worker and read block %d from %d, with len %d\",\n        mBlockInfo.blockId, mBufferStartPos, length));\n\n    for (int i = 0; i < MAX_REMOTE_READ_ATTEMPTS; i ++) {\n      mCurrentBuffer =\n          readRemoteByteBuffer(mTachyonFS, mBlockInfo, mBufferStartPos, length, mTachyonConf);\n      if (mCurrentBuffer != null) {\n        return true;\n      }\n      // The read failed, refresh the block info and try again\n      mBlockInfo = mFile.getClientBlockInfo(mBlockIndex);\n    }\n    return false;\n  }","id":22432,"modified_method":"/**\n   * Makes sure mCurrentBuffer is set to read at mBlockPos. If it is already, we do\n   * nothing. Otherwise, we set mBufferStartPos accordingly and try to read the correct range of\n   * bytes remotely. If we fail to read remotely, mCurrentBuffer will be null at the end of the\n   * function\n   *\n   * @return true if mCurrentBuffer was successfully set to read at mBlockPos, or false if the\n   *         remote read failed.\n   * @throws IOException\n   */\n  private boolean updateCurrentBuffer() throws IOException {\n    long bufferSize =\n        mTachyonConf.getBytes(Constants.USER_REMOTE_READ_BUFFER_SIZE_BYTE, Constants.MB);\n    if (mCurrentBuffer != null && mBufferStartPos <= mBlockPos\n        && mBlockPos < Math.min(mBufferStartPos + bufferSize, mBlockInfo.length)) {\n      // We move the buffer to read at mBlockPos\n      mCurrentBuffer.position((int) (mBlockPos - mBufferStartPos));\n      return true;\n    }\n\n    // We must read in a new block. By starting at mBlockPos, we ensure that the next byte read will\n    // be the one at mBlockPos\n    mBufferStartPos = mBlockPos;\n    long length = Math.min(bufferSize, mBlockInfo.length - mBufferStartPos);\n    LOG.info(String.format(\"Try to find remote worker and read block %d from %d, with len %d\",\n        mBlockInfo.blockId, mBufferStartPos, length));\n\n    for (int i = 0; i < MAX_REMOTE_READ_ATTEMPTS; i ++) {\n      mCurrentBuffer =\n          readRemoteByteBuffer(mTachyonFS, mBlockInfo, mBufferStartPos, length, mTachyonConf);\n      if (mCurrentBuffer != null) {\n        return true;\n      }\n      // The read failed, refresh the block info and try again\n      mBlockInfo = mFile.getClientBlockInfo(mBlockIndex);\n    }\n    return false;\n  }","commit_id":"c3d226d697d5709df53a5000ee0553dbd9fb7050","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Re-cache the block into memory\n   *\n   * @param blockIndex The block index of the current file.\n   * @return true if succeed, false otherwise\n   * @throws IOException\n   */\n  boolean recache(int blockIndex) throws IOException {\n    String path = getUfsPath();\n    UnderFileSystem underFsClient = UnderFileSystem.get(path, mTachyonConf);\n\n    InputStream inputStream = null;\n    BlockOutStream bos = null;\n    try {\n      inputStream = underFsClient.open(path);\n\n      long length = getBlockSizeByte();\n      long offset = blockIndex * length;\n      inputStream.skip(offset);\n\n      int bufferBytes = mTachyonConf.getInt(Constants.USER_FILE_BUFFER_BYTES, Constants.MB) * 4;\n      byte[] buffer = new byte[bufferBytes];\n      bos = new BlockOutStream(this, WriteType.TRY_CACHE, blockIndex, mTachyonConf);\n      int limit;\n      while (length > 0 && ((limit = inputStream.read(buffer)) >= 0)) {\n        if (limit != 0) {\n          if (length >= limit) {\n            bos.write(buffer, 0, limit);\n            length -= limit;\n          } else {\n            bos.write(buffer, 0, (int) length);\n            length = 0;\n          }\n        }\n      }\n      bos.close();\n    } catch (IOException e) {\n      LOG.warn(e.getMessage(), e);\n      if (bos != null) {\n        bos.cancel();\n      }\n      return false;\n    } finally {\n      if (inputStream != null) {\n        inputStream.close();\n      }\n    }\n\n    return true;\n  }","id":22433,"modified_method":"/**\n   * Re-cache the block into memory\n   *\n   * @param blockIndex The block index of the current file.\n   * @return true if succeed, false otherwise\n   * @throws IOException\n   */\n  boolean recache(int blockIndex) throws IOException {\n    String path = getUfsPath();\n    UnderFileSystem underFsClient = UnderFileSystem.get(path, mTachyonConf);\n\n    InputStream inputStream = null;\n    BlockOutStream bos = null;\n    try {\n      inputStream = underFsClient.open(path);\n\n      long length = getBlockSizeByte();\n      long offset = blockIndex * length;\n      inputStream.skip(offset);\n\n      int bufferBytes =\n          (int) mTachyonConf.getBytes(Constants.USER_FILE_BUFFER_BYTES, Constants.MB) * 4;\n      byte[] buffer = new byte[bufferBytes];\n      bos = new BlockOutStream(this, WriteType.TRY_CACHE, blockIndex, mTachyonConf);\n      int limit;\n      while (length > 0 && ((limit = inputStream.read(buffer)) >= 0)) {\n        if (limit != 0) {\n          if (length >= limit) {\n            bos.write(buffer, 0, limit);\n            length -= limit;\n          } else {\n            bos.write(buffer, 0, (int) length);\n            length = 0;\n          }\n        }\n      }\n      bos.close();\n    } catch (IOException e) {\n      LOG.warn(e.getMessage(), e);\n      if (bos != null) {\n        bos.cancel();\n      }\n      return false;\n    } finally {\n      if (inputStream != null) {\n        inputStream.close();\n      }\n    }\n\n    return true;\n  }","commit_id":"c3d226d697d5709df53a5000ee0553dbd9fb7050","url":"https://github.com/amplab/tachyon"},{"original_method":"public Module getModule() {\n    if (!isValid()) return null;\n    PsiElement element = myUsageInfo.getElement();\n    VirtualFile virtualFile = getFile();\n    ProjectRootManager projectRootManager = ProjectRootManager.getInstance(element.getProject());\n    ProjectFileIndex fileIndex = projectRootManager.getFileIndex();\n    Module module = fileIndex.getModuleForFile(virtualFile);\n    return module;\n  }","id":22434,"modified_method":"public Module getModule() {\n    if (!isValid()) return null;\n    PsiElement element = myUsageInfo.getElement();\n    VirtualFile virtualFile = getFile();\n    if (virtualFile == null) return null;\n\n    ProjectRootManager projectRootManager = ProjectRootManager.getInstance(element.getProject());\n    ProjectFileIndex fileIndex = projectRootManager.getFileIndex();\n    return fileIndex.getModuleForFile(virtualFile);\n  }","commit_id":"db83273c186e1ff9a5325c7f1f0ac9e360ccabbf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable public ProblemDescriptor[] checkFile(final PsiFile file, final InspectionManager manager, boolean isOnTheFly) {\n    if (file.getFileType().equals(StdFileTypes.GUI_DESIGNER_FORM)) {\n      final Module module = VfsUtil.getModuleForFile(file.getProject(), file.getVirtualFile());\n      if (module == null) {\n        return null;\n      }\n\n      final LwRootContainer rootContainer;\n      try {\n        rootContainer = Utils.getRootContainer(file.getText(), new PsiPropertiesProvider(module));\n      }\n      catch (Exception e) {\n        return null;\n      }\n\n      if (rootContainer.isInspectionSuppressed(getShortName(), null)) {\n        return null;\n      }\n      final FormFileErrorCollector collector = new FormFileErrorCollector(file, manager);\n      startCheckForm(rootContainer);\n      FormEditingUtil.iterate(rootContainer, new FormEditingUtil.ComponentVisitor() {\n        public boolean visit(final IComponent component) {\n          if (!rootContainer.isInspectionSuppressed(getShortName(), component.getId())) {\n            checkComponentProperties(module, component, collector);\n          }\n          return true;\n        }\n      });\n      doneCheckForm(rootContainer);\n      return collector.result();\n    }\n    return null;\n  }","id":22435,"modified_method":"@Nullable public ProblemDescriptor[] checkFile(@NotNull PsiFile file, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    if (file.getFileType().equals(StdFileTypes.GUI_DESIGNER_FORM)) {\n      final VirtualFile virtualFile = file.getVirtualFile();\n      if (virtualFile == null) {\n        return null;\n      }\n      final Module module = VfsUtil.getModuleForFile(file.getProject(), virtualFile);\n      if (module == null) {\n        return null;\n      }\n\n      final LwRootContainer rootContainer;\n      try {\n        rootContainer = Utils.getRootContainer(file.getText(), new PsiPropertiesProvider(module));\n      }\n      catch (Exception e) {\n        return null;\n      }\n\n      if (rootContainer.isInspectionSuppressed(getShortName(), null)) {\n        return null;\n      }\n      final FormFileErrorCollector collector = new FormFileErrorCollector(file, manager);\n      startCheckForm(rootContainer);\n      FormEditingUtil.iterate(rootContainer, new FormEditingUtil.ComponentVisitor() {\n        public boolean visit(final IComponent component) {\n          if (!rootContainer.isInspectionSuppressed(getShortName(), component.getId())) {\n            checkComponentProperties(module, component, collector);\n          }\n          return true;\n        }\n      });\n      doneCheckForm(rootContainer);\n      return collector.result();\n    }\n    return null;\n  }","commit_id":"d6c6e1c97c34d1e2f302c8627fbda42151b96fe0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getDisplayName() {\n    return null;\n  }","id":22436,"modified_method":"@Nls @NotNull\n  public String getDisplayName() {\n    return \"\";\n  }","commit_id":"d6c6e1c97c34d1e2f302c8627fbda42151b96fe0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isActive(PsiElement psiRoot) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(psiRoot.getProject()).getInspectionProfile(psiRoot);\n    HighlightDisplayKey key = HighlightDisplayKey.find(myInspectionKey);\n    if (key == null) {\n      return false;\n    }\n    return profile.isToolEnabled(key);\n  }","id":22437,"modified_method":"public boolean isActive(PsiElement psiRoot) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(psiRoot.getProject()).getInspectionProfile(psiRoot);\n    HighlightDisplayKey key = HighlightDisplayKey.find(myInspectionKey);\n    return key != null && profile.isToolEnabled(key);\n  }","commit_id":"d6c6e1c97c34d1e2f302c8627fbda42151b96fe0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void checkStringDescriptor(final StringDescriptorType descriptorType,\n                                       final Module module,\n                                       final IComponent component,\n                                       final IProperty prop,\n                                       final StringDescriptor descriptor,\n                                       final FormErrorCollector collector) {\n    if (isHardCodedStringDescriptor(descriptor)) {\n      if (descriptorType == StringDescriptorType.PROPERTY) {\n        if (isSetterNonNls(module.getProject(),\n                           GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module),\n                           component.getComponentClassName(), prop.getName())) {\n          return;\n        }\n      }\n\n      EditorQuickFixProvider provider = null;\n      switch (descriptorType) {\n        case PROPERTY:\n          provider = new EditorQuickFixProvider() {\n            public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n              return new I18nizeFormPropertyQuickFix(editor, UIDesignerBundle.message(\"i18n.quickfix.property\", prop.getName()),\n                                                     component,\n                                                     (IntrospectedProperty)prop);\n            }\n          };\n          break;\n\n        case BORDER:\n          provider = new EditorQuickFixProvider() {\n            public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n              return new I18nizeFormBorderQuickFix(editor, UIDesignerBundle.message(\"i18n.quickfix.border.title\"),\n                                                   (RadContainer)component);\n            }\n          };\n          break;\n\n        case TAB:\n          provider = new EditorQuickFixProvider() {\n            public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n              return new I18nizeTabTitleQuickFix(editor, UIDesignerBundle.message(\"i18n.quickfix.tab.title\"), component);\n            }\n          };\n      }\n\n      collector.addError(getID(), prop,\n                         CodeInsightBundle.message(\"inspection.i18n.message.in.form\", descriptor.getValue()),\n                         provider);\n    }\n  }","id":22438,"modified_method":"protected void checkStringDescriptor(final StringDescriptorType descriptorType,\n                                       final Module module,\n                                       final IComponent component,\n                                       final IProperty prop,\n                                       final StringDescriptor descriptor,\n                                       final FormErrorCollector collector) {\n    if (isHardCodedStringDescriptor(descriptor)) {\n      if (descriptorType == StringDescriptorType.PROPERTY) {\n        if (isSetterNonNls(module.getProject(),\n                           GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module),\n                           component.getComponentClassName(), prop.getName())) {\n          return;\n        }\n      }\n\n      EditorQuickFixProvider provider = null;\n      switch (descriptorType) {\n        case PROPERTY:\n          provider = new EditorQuickFixProvider() {\n            public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n              return new I18nizeFormPropertyQuickFix(editor, UIDesignerBundle.message(\"i18n.quickfix.property\", prop.getName()),\n                                                     component,\n                                                     (IntrospectedProperty)prop);\n            }\n          };\n          break;\n\n        case BORDER:\n          provider = new EditorQuickFixProvider() {\n            public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n              return new I18nizeFormBorderQuickFix(editor, UIDesignerBundle.message(\"i18n.quickfix.border.title\"),\n                                                   (RadContainer)component);\n            }\n          };\n          break;\n\n        case TAB:\n          provider = new EditorQuickFixProvider() {\n            public QuickFix createQuickFix(GuiEditor editor, RadComponent component) {\n              return new I18nizeTabTitleQuickFix(editor, UIDesignerBundle.message(\"i18n.quickfix.tab.title\"), component);\n            }\n          };\n      }\n\n      collector.addError(getID(), prop,\n                         UIDesignerBundle.message(\"inspection.i18n.message.in.form\", descriptor.getValue()),\n                         provider);\n    }\n  }","commit_id":"d6c6e1c97c34d1e2f302c8627fbda42151b96fe0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String checkDescriptor(final StringDescriptor descriptor, final Module module) {\n    final String bundleName = descriptor.getDottedBundleName();\n    final String key = descriptor.getKey();\n    if (bundleName == null && key == null) return null;\n    if (bundleName == null) {\n      return  CodeInsightBundle.message(\"inspection.invalid.property.in.form.quickfix.error.bundle.not.specified\");\n    }\n\n    if (key == null) {\n      return CodeInsightBundle.message(\"inspection.invalid.property.in.form.quickfix.error.property.key.not.specified\");\n    }\n\n    PropertiesReferenceManager manager = PropertiesReferenceManager.getInstance(module.getProject());\n    List<PropertiesFile> propFiles = manager.findPropertiesFiles(module, bundleName);\n\n    if (propFiles.size() == 0) {\n      return CodeInsightBundle.message(\"inspection.invalid.property.in.form.quickfix.error.bundle.not.found\", bundleName);\n    }\n\n    for(PropertiesFile propFile: propFiles) {\n      final Property property = propFile.findPropertyByKey(key);\n      if (property == null) {\n        return CodeInsightBundle.message(\"inspection.invalid.property.in.form.quickfix.error.key.not.found\",\n                                         key, bundleName, propFile.getLocale().getDisplayName());\n      }\n    }\n    return null;\n  }","id":22439,"modified_method":"@Nullable\n  private static String checkDescriptor(final StringDescriptor descriptor, final Module module) {\n    final String bundleName = descriptor.getDottedBundleName();\n    final String key = descriptor.getKey();\n    if (bundleName == null && key == null) return null;\n    if (bundleName == null) {\n      return UIDesignerBundle.message(\"inspection.invalid.property.in.form.quickfix.error.bundle.not.specified\");\n    }\n\n    if (key == null) {\n      return UIDesignerBundle.message(\"inspection.invalid.property.in.form.quickfix.error.property.key.not.specified\");\n    }\n\n    PropertiesReferenceManager manager = PropertiesReferenceManager.getInstance(module.getProject());\n    List<PropertiesFile> propFiles = manager.findPropertiesFiles(module, bundleName);\n\n    if (propFiles.size() == 0) {\n      return UIDesignerBundle.message(\"inspection.invalid.property.in.form.quickfix.error.bundle.not.found\", bundleName);\n    }\n\n    for(PropertiesFile propFile: propFiles) {\n      final Property property = propFile.findPropertyByKey(key);\n      if (property == null) {\n        return UIDesignerBundle.message(\"inspection.invalid.property.in.form.quickfix.error.key.not.found\",\n                                         key, bundleName, propFile.getLocale().getDisplayName());\n      }\n    }\n    return null;\n  }","commit_id":"d6c6e1c97c34d1e2f302c8627fbda42151b96fe0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void selectIn(final SelectInContext context, final boolean requestFocus) {\n    final Project project = context.getProject();\n    final VirtualFile file = context.getVirtualFile();\n\n    final Module module;\n    final Facet facet;\n    if (file instanceof WrappingVirtualFile) {\n      final Object o = ((WrappingVirtualFile)file).getWrappedObject(project);\n      facet = o instanceof Facet? (Facet)o : null;\n      module = facet == null? null : facet.getModule();\n    }\n    else {\n      final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n      module = fileIndex.getModuleForFile(file);\n      facet = fileIndex.isInSourceContent(file) ? null : findFacet(project, file);\n    }\n    if (module != null || facet != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          if (facet != null) {\n            ModulesConfigurator.showFacetSettingsDialog(facet, null);\n          }\n          else {\n            ProjectSettingsService.getInstance(project).openModuleSettings(module);\n          }\n        }\n      });\n      return;\n    }\n\n    final OrderEntry orderEntry = LibraryUtil.findLibraryEntry(file, project);\n    if (orderEntry != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          ProjectSettingsService.getInstance(project).openLibraryOrSdkSettings(orderEntry);\n        }\n      });\n    }\n  }","id":22440,"modified_method":"@Override\n  public void selectIn(final SelectInContext context, final boolean requestFocus) {\n    final Project project = context.getProject();\n    final VirtualFile file = context.getVirtualFile();\n\n    final Module module;\n    final Facet facet;\n    if (file instanceof WrappingVirtualFile) {\n      final Object o = ((WrappingVirtualFile)file).getWrappedObject(project);\n      facet = o instanceof Facet? (Facet)o : null;\n      module = facet == null? null : facet.getModule();\n    }\n    else {\n      Module moduleByIml = file.getFileType().equals(StdFileTypes.IDEA_MODULE) ? findModuleByModuleFile(project, file) : null;\n      final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n      module = moduleByIml != null ? moduleByIml : fileIndex.getModuleForFile(file);\n      facet = fileIndex.isInSourceContent(file) ? null : findFacet(project, file);\n    }\n    if (module != null || facet != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          if (facet != null) {\n            ModulesConfigurator.showFacetSettingsDialog(facet, null);\n          }\n          else {\n            ProjectSettingsService.getInstance(project).openModuleSettings(module);\n          }\n        }\n      });\n      return;\n    }\n\n    final OrderEntry orderEntry = LibraryUtil.findLibraryEntry(file, project);\n    if (orderEntry != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          ProjectSettingsService.getInstance(project).openLibraryOrSdkSettings(orderEntry);\n        }\n      });\n    }\n  }","commit_id":"c367db22bfc85a07d1cc7f8ff09b3d18bd72e45a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean canSelect(final SelectInContext context) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(context.getProject()).getFileIndex();\n    final VirtualFile file = context.getVirtualFile();\n    if (file instanceof WrappingVirtualFile) {\n      final Object o = ((WrappingVirtualFile)file).getWrappedObject(context.getProject());\n      return o instanceof Facet;\n    }\n    return fileIndex.isInContent(file) || fileIndex.isInLibraryClasses(file) || fileIndex.isInLibrarySource(file);\n  }","id":22441,"modified_method":"@Override\n  public boolean canSelect(final SelectInContext context) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(context.getProject()).getFileIndex();\n    final VirtualFile file = context.getVirtualFile();\n    if (file instanceof WrappingVirtualFile) {\n      final Object o = ((WrappingVirtualFile)file).getWrappedObject(context.getProject());\n      return o instanceof Facet;\n    }\n    return fileIndex.isInContent(file) || fileIndex.isInLibraryClasses(file) || fileIndex.isInLibrarySource(file)\n           || StdFileTypes.IDEA_MODULE.equals(file.getFileType()) && findModuleByModuleFile(context.getProject(), file) != null;\n  }","commit_id":"c367db22bfc85a07d1cc7f8ff09b3d18bd72e45a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void selectIn(final SelectInContext context, final boolean requestFocus) {\n    final Project project = context.getProject();\n    VirtualFile file = context.getVirtualFile();\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final Module module = fileIndex.getModuleForFile(file);\n    if (module != null) {\n      final Facet facet = findFacet(project, file, fileIndex);\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          if (facet != null) {\n            ModulesConfigurator.showFacetSettingsDialog(facet, null);\n          }\n          else {\n            ModulesConfigurator.showDialog(project, module.getName(), null, false);\n          }\n        }\n      });\n      return;\n    }\n\n    final LibraryOrderEntry libraryOrderEntry = findLibrary(file, fileIndex);\n    if (libraryOrderEntry != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          ModulesConfigurator.showLibrarySettings(project, libraryOrderEntry);\n        }\n      });\n      return;\n    }\n\n    final Sdk jdk = findJdk(file, fileIndex);\n    if (jdk != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          ModulesConfigurator.showSdkSettings(project, jdk);\n        }\n      });\n    }\n  }","id":22442,"modified_method":"public void selectIn(final SelectInContext context, final boolean requestFocus) {\n    final Project project = context.getProject();\n    final VirtualFile file = context.getVirtualFile();\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n\n    final Module module;\n    final Facet facet;\n    if (file instanceof WrappingVirtualFile) {\n      final Object o = ((WrappingVirtualFile)file).getWrappedObject(project);\n      facet = o instanceof Facet? (Facet)o : null;\n      module = facet == null? null : facet.getModule();\n    }\n    else {\n      module = fileIndex.getModuleForFile(file);\n      facet = findFacet(project, file, fileIndex);\n    }\n    if (module != null || facet != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          if (facet != null) {\n            ModulesConfigurator.showFacetSettingsDialog(facet, null);\n          }\n          else {\n            ModulesConfigurator.showDialog(project, module.getName(), null, false);\n          }\n        }\n      });\n      return;\n    }\n\n    final LibraryOrderEntry libraryOrderEntry = findLibrary(file, fileIndex);\n    if (libraryOrderEntry != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          ModulesConfigurator.showLibrarySettings(project, libraryOrderEntry);\n        }\n      });\n      return;\n    }\n\n    final Sdk jdk = findJdk(file, fileIndex);\n    if (jdk != null) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          ModulesConfigurator.showSdkSettings(project, jdk);\n        }\n      });\n    }\n  }","commit_id":"e4f11a9d8cabf08aa06d8f7c250c2a08c73b8739","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canSelect(final SelectInContext context) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(context.getProject()).getFileIndex();\n    VirtualFile file = context.getVirtualFile();\n    return fileIndex.isInContent(file) || fileIndex.isInLibraryClasses(file) || fileIndex.isInLibrarySource(file);\n  }","id":22443,"modified_method":"public boolean canSelect(final SelectInContext context) {\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(context.getProject()).getFileIndex();\n    final VirtualFile file = context.getVirtualFile();\n    if (file instanceof WrappingVirtualFile) {\n      final Object o = ((WrappingVirtualFile)file).getWrappedObject(context.getProject());\n      return o instanceof Facet;\n    }\n    return fileIndex.isInContent(file) || fileIndex.isInLibraryClasses(file) || fileIndex.isInLibrarySource(file);\n  }","commit_id":"e4f11a9d8cabf08aa06d8f7c250c2a08c73b8739","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public final char readChar() throws IOException {\n        if(pos + 1 >= count) {\n            fillNew();\n            if(pos + 1 >= count) throw new EOFException();\n        }\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        return (char)((ch1 << 8) + ch2);\n    }","id":22444,"modified_method":"@Override\n    public final char readChar() throws IOException {\n        if(pos + 1 >= count) {\n            fillNew(2);\n        }\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        return (char)((ch1 << 8) + ch2);\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean readBoolean() throws IOException {\n        if (pos >= count) {\n            fillNew();\n            if (pos >= count)\n                throw new EOFException();\n        }\n        int ch = this.buf[pos++] & 0xff;\n        return (ch != 0);\n    }","id":22445,"modified_method":"@Override\n    public boolean readBoolean() throws IOException {\n        if (pos >= count) {\n            fillNew(1);\n        }\n        int ch = this.buf[pos++] & 0xff;\n        return (ch != 0);\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public final float readFloat() throws IOException {\n        return Float.intBitsToFloat(readInt());\n    }","id":22446,"modified_method":"private void fillNew(int minimumCount) throws IOException {\n        if (pos < count) {\n            int remain = count - pos;\n            System.arraycopy(buf, pos, buf, 0, remain);\n            count = remain;\n        } else {\n            count = 0;\n        }\n        pos = 0;\n        do {\n            int n = in.read(buf, count, buf.length - count);\n            if (n < 0) {\n                throw new EOFException();\n            }\n            count += n;\n        } while (count < minimumCount);\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public int readUnsignedShort() throws IOException{\n        if(pos + 1 >= count) {\n            fillNew();\n            if(pos + 1 >= count) throw new EOFException();\n        }\n\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        return (ch1 << 8) + ch2;\n    }","id":22447,"modified_method":"@Override\n    public int readUnsignedShort() throws IOException{\n        if(pos + 1 >= count) {\n            fillNew(2);\n        }\n\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        return (ch1 << 8) + ch2;\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public final short readShort() throws IOException {\n        if(pos + 1 >= count){\n            fillNew();\n            if(pos + 1 >= count) throw new EOFException();\n        }\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        return (short)((ch1 << 8) + ch2);\n    }","id":22448,"modified_method":"@Override\n    public final short readShort() throws IOException {\n        if(pos + 1 >= count){\n            fillNew(2);\n        }\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        return (short)((ch1 << 8) + ch2);\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public int readUnsignedByte() throws IOException {\n        if (pos >= count) {\n            fillNew();\n            if (pos >= count)\n                throw new EOFException();\n        }\n        int ch = this.buf[pos++] & 0xff;\n        return ch;\n    }","id":22449,"modified_method":"@Override\n    public int readUnsignedByte() throws IOException {\n        if (pos >= count) {\n            fillNew(1);\n        }\n        int ch = this.buf[pos++] & 0xff;\n        return ch;\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public final byte readByte() throws IOException {\n        if (pos >= count) {\n            fillNew();\n            if (pos >= count)\n                throw new EOFException();\n        }\n        return this.buf[pos++];\n    }","id":22450,"modified_method":"@Override\n    public final byte readByte() throws IOException {\n        if (pos >= count) {\n            fillNew(1);\n        }\n        return this.buf[pos++];\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public final int readInt() throws IOException {\n        if(pos + 3 >= count){\n            fillNew();\n            if(pos + 3 >= count) throw new EOFException();\n        }\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        int ch3 = this.buf[pos++] & 0xff;\n        int ch4 = this.buf[pos++] & 0xff;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + ch4);\n    }","id":22451,"modified_method":"@Override\n    public final int readInt() throws IOException {\n        if(pos + 3 >= count){\n            fillNew(4);\n        }\n        int ch1 = this.buf[pos++] & 0xff;\n        int ch2 = this.buf[pos++] & 0xff;\n        int ch3 = this.buf[pos++] & 0xff;\n        int ch4 = this.buf[pos++] & 0xff;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + ch4);\n    }","commit_id":"8416a978ddceb9dd25990c74d97bce911ba822a6","url":"https://github.com/apache/tomcat"},{"original_method":"protected boolean login(Subject clientSubject, String username, \n                            Credential credential, String authMethod, \n                            MessageInfo messageInfo) \n    throws IOException, UnsupportedCallbackException\n    {\n        CredentialValidationCallback credValidationCallback = new CredentialValidationCallback(clientSubject, username, credential);\n        callbackHandler.handle(new Callback[] { credValidationCallback });\n        if (credValidationCallback.getResult())\n        {\n            Set<LoginCallbackImpl> loginCallbacks = clientSubject.getPrivateCredentials(LoginCallbackImpl.class);\n            if (!loginCallbacks.isEmpty())\n            {\n                LoginCallbackImpl loginCallback = loginCallbacks.iterator().next();\n                CallerPrincipalCallback callerPrincipalCallback = new CallerPrincipalCallback(clientSubject, loginCallback.getUserPrincipal());\n                GroupPrincipalCallback groupPrincipalCallback = new GroupPrincipalCallback(clientSubject, loginCallback.getRoles());\n                callbackHandler.handle(new Callback[] { callerPrincipalCallback, groupPrincipalCallback });\n            }\n            messageInfo.getMap().put(JaspiMessageInfo.AUTH_METHOD_KEY, authMethod);\n        }\n        return credValidationCallback.getResult();\n\n    }","id":22452,"modified_method":"protected boolean login(Subject clientSubject, String username, \n                            Credential credential, String authMethod, \n                            MessageInfo messageInfo) \n    throws IOException, UnsupportedCallbackException\n    {\n        CredentialValidationCallback credValidationCallback = new CredentialValidationCallback(clientSubject, username, credential);\n        callbackHandler.handle(new Callback[] { credValidationCallback });\n        if (credValidationCallback.getResult())\n        {\n            Set<LoginCallbackImpl> loginCallbacks = clientSubject.getPrivateCredentials(LoginCallbackImpl.class);\n            System.err.println(\"LoginCallbackImpls.isEmpty=\"+loginCallbacks.isEmpty());\n            if (!loginCallbacks.isEmpty())\n            {\n                LoginCallbackImpl loginCallback = loginCallbacks.iterator().next();\n                CallerPrincipalCallback callerPrincipalCallback = new CallerPrincipalCallback(clientSubject, loginCallback.getUserPrincipal());\n                GroupPrincipalCallback groupPrincipalCallback = new GroupPrincipalCallback(clientSubject, loginCallback.getRoles());\n                callbackHandler.handle(new Callback[] { callerPrincipalCallback, groupPrincipalCallback });\n            }\n            messageInfo.getMap().put(JaspiMessageInfo.AUTH_METHOD_KEY, authMethod);\n        }\n        return credValidationCallback.getResult();\n\n    }","commit_id":"53fa6a04810f2cd4366d3821efd8497e2479d0f8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private boolean tryLogin(MessageInfo messageInfo, Subject clientSubject, \n                             HttpServletResponse response, HttpSession session, \n                             String username, Password password) \n    throws AuthException, IOException, UnsupportedCallbackException\n    {\n        if (login(clientSubject, username, password, Constraint.__FORM_AUTH, messageInfo))\n        {\n            char[] pwdChars = password.toString().toCharArray();\n            Set<LoginCallbackImpl> loginCallbacks = clientSubject.getPrivateCredentials(LoginCallbackImpl.class);\n            if (!loginCallbacks.isEmpty())\n            {\n                LoginCallbackImpl loginCallback = loginCallbacks.iterator().next();\n                FormCredential form_cred = new FormCredential(username, pwdChars, loginCallback.getUserPrincipal());\n\n                session.setAttribute(__J_AUTHENTICATED, form_cred);\n            }\n\n            // Sign-on to SSO mechanism\n            if (ssoSource != null)\n            {\n                UserInfo userInfo = new UserInfo(username, pwdChars);\n                ssoSource.store(userInfo, response);\n            }\n            return true;\n        }\n        return false;\n        // LoginCallback loginCallback = new LoginCallback(clientSubject,\n        // username, password);\n        // loginService.login(loginCallback);\n        // if (loginCallback.isSuccess())\n        // {\n        // CallerPrincipalCallback callerPrincipalCallback = new\n        // CallerPrincipalCallback(clientSubject,\n        // loginCallback.getUserPrincipal());\n        // GroupPrincipalCallback groupPrincipalCallback = new\n        // GroupPrincipalCallback(clientSubject,\n        // loginCallback.getGroups().toArray(new\n        // String[loginCallback.getGroups().size()]));\n        // callbackHandler.handle(new Callback[] {callerPrincipalCallback,\n        // groupPrincipalCallback});\n        // messageInfo.getMap().put(JettyMessageInfo.AUTH_METHOD_KEY,\n        // Constraint.__FORM_AUTH);\n        // FormCredential form_cred = new FormCredential(username, password,\n        // loginCallback.getUserPrincipal());\n        //\n        // session.setAttribute(__J_AUTHENTICATED, form_cred);\n        // // Sign-on to SSO mechanism\n        // if (ssoSource != null)\n        // {\n        // UserInfo userInfo = new UserInfo(username, password);\n        // ssoSource.store(userInfo, response);\n        // }\n        // }\n        // return loginCallback.isSuccess();\n    }","id":22453,"modified_method":"private boolean tryLogin(MessageInfo messageInfo, Subject clientSubject, \n                             HttpServletResponse response, HttpSession session, \n                             String username, Password password) \n    throws AuthException, IOException, UnsupportedCallbackException\n    {\n        if (login(clientSubject, username, password, Constraint.__FORM_AUTH, messageInfo))\n        {\n            char[] pwdChars = password.toString().toCharArray();\n            Set<LoginCallbackImpl> loginCallbacks = clientSubject.getPrivateCredentials(LoginCallbackImpl.class);\n            System.err.println(\"FormAuthModule, LoginCallbackImpl.isEmpty=\"+loginCallbacks.isEmpty());\n            if (!loginCallbacks.isEmpty())\n            {\n                LoginCallbackImpl loginCallback = loginCallbacks.iterator().next();\n                FormCredential form_cred = new FormCredential(username, pwdChars, loginCallback.getUserPrincipal());\n\n                session.setAttribute(__J_AUTHENTICATED, form_cred);\n            }\n\n            // Sign-on to SSO mechanism\n            if (ssoSource != null)\n            {\n                UserInfo userInfo = new UserInfo(username, pwdChars);\n                ssoSource.store(userInfo, response);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"53fa6a04810f2cd4366d3821efd8497e2479d0f8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject, Subject serviceSubject) throws AuthException\n    {\n        System.err.println(\"FormAuthModule.validateRequest(info,subject,serviceSubject)\");\n        HttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();\n        HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();\n        HttpSession session = request.getSession(isMandatory(messageInfo));\n        String uri = request.getRequestURI();\n        // not mandatory and not authenticated\n        if (session == null || isLoginOrErrorPage(uri)) return AuthStatus.SUCCESS;\n\n        System.err.println(\"FormAuthModule.validateRequest(info,subect,serviceSubject), uri=\"+uri);\n        try\n        {\n            // Handle a request for authentication.\n            // TODO perhaps j_securitycheck can be uri suffix?\n            if (uri != null && isJSecurityCheck(uri))\n            {\n\n                final String username = request.getParameter(__J_USERNAME);\n                final String password = request.getParameter(__J_PASSWORD);\n                System.err.println(\"Try login username=\"+username+\" password=\"+password);\n                boolean success = tryLogin(messageInfo, clientSubject, response, session, username, new Password(password));\n                if (success)\n                {\n                    // Redirect to original request\n                    String nuri = (String) session.getAttribute(__J_URI);\n                    if (nuri == null || nuri.length() == 0)\n                    {\n                        nuri = request.getContextPath();\n                        if (nuri.length() == 0) nuri = URIUtil.SLASH;\n                    }\n                    session.removeAttribute(__J_URI); // Remove popped return\n                                                        // URI.\n                    response.setContentLength(0);\n                    response.sendRedirect(response.encodeRedirectURL(nuri));\n\n                    return AuthStatus.SEND_CONTINUE;\n                }\n                // not authenticated\n                if (LOG.isDebugEnabled()) LOG.debug(\"Form authentication FAILED for \" + StringUtil.printable(username));\n                if (_formErrorPage == null)\n                {\n                    if (response != null) response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                }\n                else\n                {\n                    response.setContentLength(0);\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getContextPath(), _formErrorPage)));\n                }\n                // TODO is this correct response if isMandatory false??? Can\n                // that occur?\n                return AuthStatus.SEND_FAILURE;\n            }\n            // Check if the session is already authenticated.\n            FormCredential form_cred = (FormCredential) session.getAttribute(__J_AUTHENTICATED);\n\n            if (form_cred != null)\n            {\n                System.err.println(\"Form cred: form.username=\"+form_cred._jUserName+\" form.pwd=\"+new String(form_cred._jPassword));\n                boolean success = tryLogin(messageInfo, clientSubject, response, session, form_cred._jUserName, new Password(new String(form_cred._jPassword)));\n                if (success) { return AuthStatus.SUCCESS; }\n                // CallbackHandler loginCallbackHandler = new\n                // UserPasswordCallbackHandler(form_cred._jUserName,\n                // form_cred._jPassword);\n                // LoginResult loginResult = loginService.login(clientSubject,\n                // loginCallbackHandler);\n                // //TODO what should happen if !isMandatory but credentials\n                // exist and are wrong?\n                // if (loginResult.isSuccess())\n                // {\n                // callbackHandler.handle(new\n                // Callback[]{loginResult.getCallerPrincipalCallback(),\n                // loginResult.getGroupPrincipalCallback()});\n                // messageInfo.getMap().put(JettyMessageInfo.AUTH_METHOD_KEY,\n                // Constraint.__FORM_AUTH);\n                //\n                // form_cred = new FormCredential(form_cred._jUserName,\n                // form_cred._jPassword,\n                // loginResult.getCallerPrincipalCallback().getPrincipal());\n                //\n                // session.setAttribute(__J_AUTHENTICATED, form_cred);\n                // if (ssoSource != null && ssoSource.fetch(request) == null)\n                // {\n                // UserInfo userInfo = new UserInfo(form_cred._jUserName,\n                // form_cred._jPassword);\n                // ssoSource.store(userInfo, response);\n                // }\n                // messageInfo.getMap().put(JettyMessageInfo.AUTH_METHOD_KEY,\n                // Constraint.__FORM_AUTH);\n                // return AuthStatus.SUCCESS;\n                // }\n\n                // // We have a form credential. Has it been distributed?\n                // if (form_cred._userPrincipal==null)\n                // {\n                // // This form_cred appears to have been distributed. Need to\n                // reauth\n                // form_cred.authenticate(realm, request);\n                //\n                // // Sign-on to SSO mechanism\n                // if (form_cred._userPrincipal!=null && realm instanceof\n                // SSORealm)\n                // ((SSORealm)realm).setSingleSignOn(request,response,form_cred._userPrincipal,new\n                // Password(form_cred._jPassword));\n                //\n                // }\n                // else if (!realm.reauthenticate(form_cred._userPrincipal))\n                // // Else check that it is still authenticated.\n                // form_cred._userPrincipal=null;\n                //\n                // // If this credential is still authenticated\n                // if (form_cred._userPrincipal!=null)\n                // {\n                // if(LOG.isDebugEnabled())LOG.debug(\"FORM Authenticated for\n                // \"+form_cred._userPrincipal.getName());\n                // request.setAuthType(Constraint.__FORM_AUTH);\n                // //jaspi\n                // // request.setUserPrincipal(form_cred._userPrincipal);\n                // return form_cred._userPrincipal;\n                // }\n                // else\n                // session.setAttribute(__J_AUTHENTICATED,null);\n                // }\n                // else if (realm instanceof SSORealm)\n                // {\n                // // Try a single sign on.\n                // Credential cred =\n                // ((SSORealm)realm).getSingleSignOn(request,response);\n                //\n                // if (request.getUserPrincipal()!=null)\n                // {\n                // form_cred=new FormCredential();\n                // form_cred._userPrincipal=request.getUserPrincipal();\n                // form_cred._jUserName=form_cred._userPrincipal.getName();\n                // if (cred!=null)\n                // form_cred._jPassword=cred.toString();\n                // if(LOG.isDebugEnabled())LOG.debug(\"SSO for\n                // \"+form_cred._userPrincipal);\n                //\n                // request.setAuthType(Constraint.__FORM_AUTH);\n                // session.setAttribute(__J_AUTHENTICATED,form_cred);\n                // return form_cred._userPrincipal;\n                // }\n            }\n            else if (ssoSource != null)\n            {\n                UserInfo userInfo = ssoSource.fetch(request);\n                if (userInfo != null)\n                {\n                    boolean success = tryLogin(messageInfo, clientSubject, response, session, userInfo.getUserName(), new Password(new String(userInfo.getPassword())));\n                    if (success) { return AuthStatus.SUCCESS; }\n                }\n            }\n\n            // Don't authenticate authform or errorpage\n            if (!isMandatory(messageInfo) || isLoginOrErrorPage(uri))\n            // TODO verify this is correct action\n                return AuthStatus.SUCCESS;\n\n            // redirect to login page\n            System.err.println(\"Redirecting to login page\");\n            if (request.getQueryString() != null) uri += \"?\" + request.getQueryString();\n            session.setAttribute(__J_URI, request.getScheme() + \"://\"\n                                          + request.getServerName()\n                                          + \":\"\n                                          + request.getServerPort()\n                                          + URIUtil.addPaths(request.getContextPath(), uri));\n            response.setContentLength(0);\n            response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getContextPath(), _formLoginPage)));\n            return AuthStatus.SEND_CONTINUE;\n        }\n        catch (IOException e)\n        {\n            throw new AuthException(e.getMessage());\n        }\n        catch (UnsupportedCallbackException e)\n        {\n            throw new AuthException(e.getMessage());\n        }\n\n    }","id":22454,"modified_method":"@Override\n    public AuthStatus validateRequest(MessageInfo messageInfo, Subject clientSubject, Subject serviceSubject) throws AuthException\n    {\n       \n        HttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();\n        HttpServletResponse response = (HttpServletResponse) messageInfo.getResponseMessage();\n        String uri = request.getRequestURI();\n        if (uri==null)\n            uri=URIUtil.SLASH;\n        \n        boolean mandatory = isMandatory(messageInfo);  \n        mandatory |= isJSecurityCheck(uri);\n        HttpSession session = request.getSession(mandatory);\n       \n        System.err.println(\"FormAuthModule.validateRequest(info,subject,serviceSubject) for uri=\"+uri+\" mandatory=\"+mandatory+\" isLoginOrError=\"+isLoginOrErrorPage(uri));\n        \n        // not mandatory or its the login or login error page don't authenticate\n        if (!mandatory || isLoginOrErrorPage(uri)) return AuthStatus.SUCCESS;\n\n        try\n        {\n            // Handle a request for authentication.\n            if (isJSecurityCheck(uri))\n            {\n                final String username = request.getParameter(__J_USERNAME);\n                final String password = request.getParameter(__J_PASSWORD);\n                System.err.println(\"Try login username=\"+username+\" password=\"+password);\n                boolean success = tryLogin(messageInfo, clientSubject, response, session, username, new Password(password));\n                if (success)\n                {\n                    // Redirect to original request                    \n                    String nuri=null;\n                    synchronized(session)\n                    {\n                        nuri = (String) session.getAttribute(__J_URI);\n                    }\n                    \n                    if (nuri == null || nuri.length() == 0)\n                    {\n                        nuri = request.getContextPath();\n                        if (nuri.length() == 0) \n                            nuri = URIUtil.SLASH;\n                    }\n                   \n                    System.err.println(\"FormAuthModule succesful login, sending redirect to \"+nuri);\n                    response.setContentLength(0);   \n                    response.sendRedirect(response.encodeRedirectURL(nuri));\n                    return AuthStatus.SEND_CONTINUE;\n                }\n                // not authenticated\n                if (LOG.isDebugEnabled()) LOG.debug(\"Form authentication FAILED for \" + StringUtil.printable(username));\n                if (_formErrorPage == null)\n                {\n                    if (response != null) response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                }\n                else\n                {\n                    response.setContentLength(0);\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getContextPath(), _formErrorPage)));\n                }\n                // TODO is this correct response if isMandatory false??? Can\n                // that occur?\n                return AuthStatus.SEND_FAILURE;\n            }\n            // Check if the session is already authenticated.\n            FormCredential form_cred = (FormCredential) session.getAttribute(__J_AUTHENTICATED);\n\n            if (form_cred != null)\n            {\n                System.err.println(\"Form cred: form.username=\"+form_cred._jUserName+\" form.pwd=\"+new String(form_cred._jPassword));\n                boolean success = tryLogin(messageInfo, clientSubject, response, session, form_cred._jUserName, new Password(new String(form_cred._jPassword)));\n                if (success) { return AuthStatus.SUCCESS; }\n            }\n            else if (ssoSource != null)\n            {\n                UserInfo userInfo = ssoSource.fetch(request);\n                if (userInfo != null)\n                {\n                    boolean success = tryLogin(messageInfo, clientSubject, response, session, userInfo.getUserName(), new Password(new String(userInfo.getPassword())));\n                    if (success) { return AuthStatus.SUCCESS; }\n                }\n            }\n\n            // redirect to login page  \n            StringBuffer buf = request.getRequestURL();\n            if (request.getQueryString() != null)\n                buf.append(\"?\").append(request.getQueryString());\n\n            synchronized (session)\n            {\n                session.setAttribute(__J_URI, buf.toString());\n            }\n            \n            System.err.println(\"Redirecting to login page \"+_formLoginPage+\" and remembering juri=\"+buf.toString());\n            response.setContentLength(0);\n            response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getContextPath(), _formLoginPage)));\n            return AuthStatus.SEND_CONTINUE;\n        }\n        catch (IOException e)\n        {\n            throw new AuthException(e.getMessage());\n        }\n        catch (UnsupportedCallbackException e)\n        {\n            throw new AuthException(e.getMessage());\n        }\n\n    }","commit_id":"53fa6a04810f2cd4366d3821efd8497e2479d0f8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Authentication validateRequest(ServletRequest request, ServletResponse response, boolean mandatory) throws ServerAuthException\n    {\n        System.err.println(\"JaspiAuthenticator.validateRequest, uri=\" + ((javax.servlet.http.HttpServletRequest) request).getRequestURI()\n                           + \"lazy=\"\n                           + _allowLazyAuthentication\n                           + \" mandatory=\"\n                           + mandatory);\n        new Throwable().printStackTrace();\n        \n\n        JaspiMessageInfo info = new JaspiMessageInfo(request, response, mandatory);\n        request.setAttribute(\"org.eclipse.jetty.security.jaspi.info\", info);\n        \n       /* if (_allowLazyAuthentication && !mandatory)\n            return _deferred;*/\n\n        return validateRequest(info);\n    }","id":22455,"modified_method":"public Authentication validateRequest(ServletRequest request, ServletResponse response, boolean mandatory) throws ServerAuthException\n    {\n        System.err.println(\"\\nJaspiAuthenticator.validateRequest, uri=\" + ((javax.servlet.http.HttpServletRequest) request).getRequestURI()\n                           + \" lazy=\"\n                           + _allowLazyAuthentication\n                           + \" mandatory=\"\n                           + mandatory);\n  \n        JaspiMessageInfo info = new JaspiMessageInfo(request, response, mandatory);\n        request.setAttribute(\"org.eclipse.jetty.security.jaspi.info\", info);\n        \n        //TODO janb - removed deferred authentication temporarily\n       /* if (_allowLazyAuthentication && !mandatory)\n            return _deferred;*/\n\n        Authentication a = validateRequest(info);\n        \n        //if its not mandatory to authenticate, and the authenticator returned UNAUTHENTICATED, we treat it as authentication deferred\n        if (_allowLazyAuthentication && !info.isAuthMandatory() && a == Authentication.UNAUTHENTICATED)\n            a =_deferred;\n        \n        System.err.println(\"JaspiAuthenticator.validateRequest returning \"+a);\n        return a;\n    }","commit_id":"53fa6a04810f2cd4366d3821efd8497e2479d0f8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException\n    {\n        for (Callback callback : callbacks)\n        {\n            // jaspi to server communication\n            if (callback instanceof CallerPrincipalCallback)\n            {\n                _callerPrincipals.set((CallerPrincipalCallback) callback);\n            }\n            else if (callback instanceof GroupPrincipalCallback)\n            {\n                _groupPrincipals.set((GroupPrincipalCallback) callback);\n            }\n            else if (callback instanceof PasswordValidationCallback)\n            {\n                PasswordValidationCallback passwordValidationCallback = (PasswordValidationCallback) callback;\n                Subject subject = passwordValidationCallback.getSubject();\n\n                UserIdentity user = _loginService.login(passwordValidationCallback.getUsername(),passwordValidationCallback.getPassword());\n                \n                if (user!=null)\n                {\n                    passwordValidationCallback.setResult(true);\n                    passwordValidationCallback.getSubject().getPrincipals().addAll(user.getSubject().getPrincipals());\n                    passwordValidationCallback.getSubject().getPrivateCredentials().add(user);\n                }\n            }\n            else if (callback instanceof CredentialValidationCallback)\n            {\n                CredentialValidationCallback credentialValidationCallback = (CredentialValidationCallback) callback;\n                Subject subject = credentialValidationCallback.getSubject();\n                LoginCallback loginCallback = new LoginCallbackImpl(subject,\n                        credentialValidationCallback.getUsername(),\n                        credentialValidationCallback.getCredential());\n\n                UserIdentity user = _loginService.login(credentialValidationCallback.getUsername(),credentialValidationCallback.getCredential());\n\n                if (user!=null)\n                {\n                    credentialValidationCallback.setResult(true);\n\n                    credentialValidationCallback.getSubject().getPrincipals().addAll(user.getSubject().getPrincipals());\n                    credentialValidationCallback.getSubject().getPrivateCredentials().add(user);\n                }\n            }\n            // server to jaspi communication\n            // TODO implement these\n            else if (callback instanceof CertStoreCallback)\n            {\n            }\n            else if (callback instanceof PrivateKeyCallback)\n            {\n            }\n            else if (callback instanceof SecretKeyCallback)\n            {\n            }\n            else if (callback instanceof TrustStoreCallback)\n            {\n            }\n            else\n            {\n                throw new UnsupportedCallbackException(callback);\n            }\n        }\n    }","id":22456,"modified_method":"public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException\n    {\n        for (Callback callback : callbacks)\n        {\n            // jaspi to server communication\n            if (callback instanceof CallerPrincipalCallback)\n            {\n                _callerPrincipals.set((CallerPrincipalCallback) callback);\n            }\n            else if (callback instanceof GroupPrincipalCallback)\n            {\n                _groupPrincipals.set((GroupPrincipalCallback) callback);\n            }\n            else if (callback instanceof PasswordValidationCallback)\n            {\n                PasswordValidationCallback passwordValidationCallback = (PasswordValidationCallback) callback;\n                Subject subject = passwordValidationCallback.getSubject();\n\n                UserIdentity user = _loginService.login(passwordValidationCallback.getUsername(),passwordValidationCallback.getPassword());\n                \n                if (user!=null)\n                {\n                    passwordValidationCallback.setResult(true);\n                    passwordValidationCallback.getSubject().getPrincipals().addAll(user.getSubject().getPrincipals());\n                    passwordValidationCallback.getSubject().getPrivateCredentials().add(user);\n                }\n            }\n            else if (callback instanceof CredentialValidationCallback)\n            {\n                CredentialValidationCallback credentialValidationCallback = (CredentialValidationCallback) callback;\n                Subject subject = credentialValidationCallback.getSubject();\n                LoginCallback loginCallback = new LoginCallbackImpl(subject,\n                        credentialValidationCallback.getUsername(),\n                        credentialValidationCallback.getCredential());\n\n                UserIdentity user = _loginService.login(credentialValidationCallback.getUsername(),credentialValidationCallback.getCredential());\n\n                if (user!=null)\n                {\n                    loginCallback.setUserPrincipal(user.getUserPrincipal());\n                    credentialValidationCallback.getSubject().getPrivateCredentials().add(loginCallback);\n                    credentialValidationCallback.setResult(true);\n                    credentialValidationCallback.getSubject().getPrincipals().addAll(user.getSubject().getPrincipals());\n                    credentialValidationCallback.getSubject().getPrivateCredentials().add(user);\n                }\n            }\n            // server to jaspi communication\n            // TODO implement these\n            else if (callback instanceof CertStoreCallback)\n            {\n            }\n            else if (callback instanceof PrivateKeyCallback)\n            {\n            }\n            else if (callback instanceof SecretKeyCallback)\n            {\n            }\n            else if (callback instanceof TrustStoreCallback)\n            {\n            }\n            else\n            {\n                throw new UnsupportedCallbackException(callback);\n            }\n        }\n    }","commit_id":"53fa6a04810f2cd4366d3821efd8497e2479d0f8","url":"https://github.com/eclipse/jetty.project"},{"original_method":"static CliConfig parse(final CommandContext ctx, File f) throws CliInitializationException {\n        if(f == null) {\n            throw new CliInitializationException(\"The file argument is null.\");\n        }\n        if(!f.exists()) {\n            //throw new CliInitializationException(f.getAbsolutePath() + \" doesn't exist.\");\n            return new CliConfigImpl();\n        }\n\n        CliConfigImpl config = new CliConfigImpl();\n\n        BufferedInputStream input = null;\n        try {\n            final XMLMapper mapper = XMLMapper.Factory.create();\n            mapper.registerRootElement(new QName(NS, JBOSS_CLI), new XMLElementReader<CliConfigImpl>(){\n                @Override\n                public void readElement(XMLExtendedStreamReader reader, CliConfigImpl config) throws XMLStreamException {\n                    boolean jbossCliEnded = false;\n                    while (reader.hasNext() && jbossCliEnded == false) {\n                        int tag = reader.nextTag();\n                        if(tag == XMLStreamConstants.START_ELEMENT) {\n                            final String localName = reader.getLocalName();\n                            if(localName.equals(DEFAULT_CONTROLLER)) {\n                                readDefaultController(reader, config);\n                            } else if(localName.equals(HISTORY)) {\n                                readHistory(reader, config);\n                            } else if (localName.equals(\"ssl\")) {\n                                SslConfig sslConfig = new SslConfig();\n                                readSSLElement(reader, sslConfig);\n                                config.sslConfig = sslConfig;\n                            } else {\n                                throw new XMLStreamException(\"Unexpected element: \" + localName);\n                            }\n                        } else if(tag == XMLStreamConstants.END_ELEMENT) {\n                            final String localName = reader.getLocalName();\n                            if (localName.equals(JBOSS_CLI)) {\n                                jbossCliEnded = true;\n                            }\n                        }\n                    }\n                }\n\n                private void readDefaultController(XMLExtendedStreamReader reader, CliConfigImpl config) throws XMLStreamException {\n                    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final String localName = reader.getLocalName();\n                        final String resolved = resolveString(reader.getElementText());\n                        if (HOST.equals(localName)) {\n                            config.defaultControllerHost = resolved;\n                        } else if (PORT.equals(localName)) {\n                            try {\n                                config.defaultControllerPort = Integer.parseInt(resolved);\n                            } catch(NumberFormatException e) {\n                                throw new XMLStreamException(\"Failed to parse \" + DEFAULT_CONTROLLER + \" \" + PORT + \" value '\" + resolved + \"'\", e);\n                            }\n                        } else {\n                            throw new XMLStreamException(\"Unexpected child of \" + DEFAULT_CONTROLLER + \": \" + localName);\n                        }\n                    }\n                }\n\n                private void readHistory(XMLExtendedStreamReader reader, CliConfigImpl config) throws XMLStreamException {\n                    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final String localName = reader.getLocalName();\n                        final String resolved = resolveString(reader.getElementText());\n                        if (ENABLED.equals(localName)) {\n                            config.historyEnabled = Boolean.parseBoolean(resolved);\n                        } else if (FILE_NAME.equals(localName)) {\n                            config.historyFileName = resolved;\n                        } else if (FILE_DIR.equals(localName)) {\n                            config.historyFileDir = resolved;\n                        } else if (MAX_SIZE.equals(localName)) {\n                            try {\n                                config.historyMaxSize = Integer.parseInt(resolved);\n                            } catch(NumberFormatException e) {\n                                throw new XMLStreamException(\"Failed to parse \" + HISTORY + \" \" + MAX_SIZE + \" value '\" + resolved + \"'\", e);\n                            }\n                        } else {\n                            throw new XMLStreamException(\"Unexpected child of \" + DEFAULT_CONTROLLER + \": \" + localName);\n                        }\n                    }\n                }\n\n                public void readSSLElement(XMLExtendedStreamReader reader, SslConfig config) throws XMLStreamException {\n                    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final String localName = reader.getLocalName();\n                        if (\"keyStore\".equals(localName)) {\n                            config.setKeyStore(reader.getElementText());\n                        } else if (\"keyStorePassword\".equals(localName)) {\n                            config.setKeyStorePassword(reader.getElementText());\n                        } else if (\"trustStore\".equals(localName)) {\n                            config.setTrustStore(reader.getElementText());\n                        } else if (\"trustStorePassword\".equals(localName)) {\n                            config.setTrustStorePassword(reader.getElementText());\n                        } else if (\"modifyTrustStore\".equals(localName)) {\n                            config.setModifyTrustStore(Boolean.getBoolean(reader.getElementText()));\n                        }\n                    }\n                }\n            });\n\n            FileInputStream is = new FileInputStream(f);\n            input = new BufferedInputStream(is);\n            XMLStreamReader streamReader = XMLInputFactory.newInstance().createXMLStreamReader(input);\n            mapper.parseDocument(config, streamReader);\n            streamReader.close();\n        } catch(Throwable t) {\n            throw new CliInitializationException(\"Failed to parse \" + f.getAbsolutePath(), t);\n        } finally {\n            StreamUtils.safeClose(input);\n        }\n        return config;\n    }","id":22457,"modified_method":"static CliConfig parse(final CommandContext ctx, File f) throws CliInitializationException {\n        if(f == null) {\n            throw new CliInitializationException(\"The file argument is null.\");\n        }\n        if(!f.exists()) {\n            //throw new CliInitializationException(f.getAbsolutePath() + \" doesn't exist.\");\n            return new CliConfigImpl();\n        }\n\n        CliConfigImpl config = new CliConfigImpl();\n\n        BufferedInputStream input = null;\n        try {\n            final XMLMapper mapper = XMLMapper.Factory.create();\n            mapper.registerRootElement(new QName(NS, JBOSS_CLI), new XMLElementReader<CliConfigImpl>(){\n                @Override\n                public void readElement(XMLExtendedStreamReader reader, CliConfigImpl config) throws XMLStreamException {\n                    boolean jbossCliEnded = false;\n                    while (reader.hasNext() && jbossCliEnded == false) {\n                        int tag = reader.nextTag();\n                        if(tag == XMLStreamConstants.START_ELEMENT) {\n                            final String localName = reader.getLocalName();\n                            if(localName.equals(DEFAULT_CONTROLLER)) {\n                                readDefaultController(reader, config);\n                            } else if(localName.equals(HISTORY)) {\n                                readHistory(reader, config);\n                            } else if (localName.equals(\"ssl\")) {\n                                SslConfig sslConfig = new SslConfig();\n                                readSSLElement(reader, sslConfig);\n                                config.sslConfig = sslConfig;\n                            } else if(localName.equals(VALIDATE_OPERATION_REQUESTS)) {\n                                final String resolved = resolveString(reader.getElementText());\n                                config.validateOperationRequests = Boolean.parseBoolean(resolved);\n                            } else {\n                                throw new XMLStreamException(\"Unexpected element: \" + localName);\n                            }\n                        } else if(tag == XMLStreamConstants.END_ELEMENT) {\n                            final String localName = reader.getLocalName();\n                            if (localName.equals(JBOSS_CLI)) {\n                                jbossCliEnded = true;\n                            }\n                        }\n                    }\n                }\n\n                private void readDefaultController(XMLExtendedStreamReader reader, CliConfigImpl config) throws XMLStreamException {\n                    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final String localName = reader.getLocalName();\n                        final String resolved = resolveString(reader.getElementText());\n                        if (HOST.equals(localName)) {\n                            config.defaultControllerHost = resolved;\n                        } else if (PORT.equals(localName)) {\n                            try {\n                                config.defaultControllerPort = Integer.parseInt(resolved);\n                            } catch(NumberFormatException e) {\n                                throw new XMLStreamException(\"Failed to parse \" + DEFAULT_CONTROLLER + \" \" + PORT + \" value '\" + resolved + \"'\", e);\n                            }\n                        } else {\n                            throw new XMLStreamException(\"Unexpected child of \" + DEFAULT_CONTROLLER + \": \" + localName);\n                        }\n                    }\n                }\n\n                private void readHistory(XMLExtendedStreamReader reader, CliConfigImpl config) throws XMLStreamException {\n                    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final String localName = reader.getLocalName();\n                        final String resolved = resolveString(reader.getElementText());\n                        if (ENABLED.equals(localName)) {\n                            config.historyEnabled = Boolean.parseBoolean(resolved);\n                        } else if (FILE_NAME.equals(localName)) {\n                            config.historyFileName = resolved;\n                        } else if (FILE_DIR.equals(localName)) {\n                            config.historyFileDir = resolved;\n                        } else if (MAX_SIZE.equals(localName)) {\n                            try {\n                                config.historyMaxSize = Integer.parseInt(resolved);\n                            } catch(NumberFormatException e) {\n                                throw new XMLStreamException(\"Failed to parse \" + HISTORY + \" \" + MAX_SIZE + \" value '\" + resolved + \"'\", e);\n                            }\n                        } else {\n                            throw new XMLStreamException(\"Unexpected child of \" + DEFAULT_CONTROLLER + \": \" + localName);\n                        }\n                    }\n                }\n\n                public void readSSLElement(XMLExtendedStreamReader reader, SslConfig config) throws XMLStreamException {\n                    while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final String localName = reader.getLocalName();\n                        if (\"keyStore\".equals(localName)) {\n                            config.setKeyStore(reader.getElementText());\n                        } else if (\"keyStorePassword\".equals(localName)) {\n                            config.setKeyStorePassword(reader.getElementText());\n                        } else if (\"trustStore\".equals(localName)) {\n                            config.setTrustStore(reader.getElementText());\n                        } else if (\"trustStorePassword\".equals(localName)) {\n                            config.setTrustStorePassword(reader.getElementText());\n                        } else if (\"modifyTrustStore\".equals(localName)) {\n                            config.setModifyTrustStore(Boolean.getBoolean(reader.getElementText()));\n                        }\n                    }\n                }\n            });\n\n            FileInputStream is = new FileInputStream(f);\n            input = new BufferedInputStream(is);\n            XMLStreamReader streamReader = XMLInputFactory.newInstance().createXMLStreamReader(input);\n            mapper.parseDocument(config, streamReader);\n            streamReader.close();\n        } catch(Throwable t) {\n            throw new CliInitializationException(\"Failed to parse \" + f.getAbsolutePath(), t);\n        } finally {\n            StreamUtils.safeClose(input);\n        }\n        return config;\n    }","commit_id":"6c3fdd28d3ba9932c3dc11cb4831498f26cfc342","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void handle(CommandContext ctx) throws CommandLineException {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            throw new CommandFormatException(\"You are disconnected at the moment.\" +\n                    \" Type 'connect' to connect to the server\" +\n                    \" or 'help' for the list of supported commands.\");\n        }\n\n        ModelNode request = (ModelNode) ctx.get(\"OP_REQ\");\n        if(request == null) {\n            throw new CommandFormatException(\"Parsed request isn't available.\");\n        }\n\n        validateRequest(ctx, request);\n\n        try {\n            final ModelNode result = client.execute(request);\n            if(Util.isSuccess(result)) {\n                ctx.printLine(result.toString());\n            } else {\n                throw new CommandFormatException(result.toString());\n            }\n        } catch(NoSuchElementException e) {\n            throw new CommandFormatException(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            throw new CommandFormatException(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.disconnectController();\n            throw new CommandFormatException(\"Communication error: \" + e.getLocalizedMessage());\n        } catch (RuntimeException e) {\n            throw new CommandFormatException(\"Failed to execute operation.\", e);\n        }\n    }","id":22458,"modified_method":"@Override\n    public void handle(CommandContext ctx) throws CommandLineException {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            throw new CommandFormatException(\"You are disconnected at the moment.\" +\n                    \" Type 'connect' to connect to the server\" +\n                    \" or 'help' for the list of supported commands.\");\n        }\n\n        ModelNode request = (ModelNode) ctx.get(\"OP_REQ\");\n        if(request == null) {\n            throw new CommandFormatException(\"Parsed request isn't available.\");\n        }\n\n        if(ctx.getConfig().isValidateOperationRequests()) {\n            validateRequest(ctx, request);\n        }\n\n        try {\n            final ModelNode result = client.execute(request);\n            if(Util.isSuccess(result)) {\n                ctx.printLine(result.toString());\n            } else {\n                throw new CommandFormatException(result.toString());\n            }\n        } catch(NoSuchElementException e) {\n            throw new CommandFormatException(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            throw new CommandFormatException(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.disconnectController();\n            throw new CommandFormatException(\"Communication error: \" + e.getLocalizedMessage());\n        } catch (RuntimeException e) {\n            throw new CommandFormatException(\"Failed to execute operation.\", e);\n        }\n    }","commit_id":"6c3fdd28d3ba9932c3dc11cb4831498f26cfc342","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public boolean canProcess(RequestAbstractType request) {\n        List<String> respondWithList = request.getRespondWith();\n        if ((respondWithList != null) && !(respondWithList.isEmpty())) {\n            return respondWithList.contains(RespondWithEnum.HTTP_WWW_W_3_ORG_2002_03_XKMS_X_509_CERT);\n        } else {\n            // Default handler\n            return true;\n        }\n    }","id":22459,"modified_method":"@Override\n    public boolean canProcess(RequestAbstractType request) {\n        if (request instanceof RecoverRequestType) {\n            return false;\n        }\n        List<String> respondWithList = request.getRespondWith();\n        if ((respondWithList != null) && !(respondWithList.isEmpty())) {\n            return respondWithList.contains(RespondWithEnum.HTTP_WWW_W_3_ORG_2002_03_XKMS_X_509_CERT);\n        } else {\n            // Default handler\n            return true;\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Performs basic validations on request message to ensure XKMS standard is applied correctly.\n     *\n     * The following validations are performed: 1) Check if a request ID is set 2) Check if service name equals this\n     * XKMS service instance\n     *\n     * @param request XKMS request\n     */\n    private void validateRequest(MessageAbstractType request) {\n        // Check if ID is set\n        if (request.getId() == null || request.getId().isEmpty()) {\n            throw new IllegalArgumentException(\"Message Id is not set\");\n        }\n        // Check if Service matches this instance\n        if (!getServiceName().equals(request.getService())) {\n            throw new IllegalArgumentException(\"Service \" + request.getService()\n                                               + \" is not responsible to process request\");\n        }\n    }","id":22460,"modified_method":"/**\n     * Performs basic validations on request message to ensure XKMS standard is applied correctly.\n     *\n     * The following validations are performed: 1) Check if a request ID is set 2) Check if service name equals this\n     * XKMS service instance\n     *\n     * @param request XKMS request\n     */\n    private void validateRequest(MessageAbstractType request) {\n        // Check if ID is set\n        if (request.getId() == null || request.getId().isEmpty()) {\n            throw new IllegalArgumentException(\"Message Id is not set\");\n        }\n        // Check if Service matches this instance\n        if (!serviceName.equals(request.getService())) {\n            throw new IllegalArgumentException(\"Service \" + request.getService()\n                                               + \" is not responsible to process request\");\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public RegisterResultType register(RegisterRequestType request) {\n        try {\n            validateRequest(request);\n            RegisterResultType response = XKMSResponseFactory.createResponse(request, new RegisterResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.register(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error due X509 Validation: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new RegisterResultType()));\n        }\n    }","id":22461,"modified_method":"@Override\n    public RegisterResultType register(RegisterRequestType request) {\n        try {\n            assertXKRSSAllowed();\n            validateRequest(request);\n            RegisterResultType response = XKMSResponseFactory.createResponse(request, new RegisterResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.register(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error due X509 Validation: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new RegisterResultType()));\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public LocateResultType locate(LocateRequestType request) {\n        try {\n            validateRequest(request);\n            // Create basic response\n            LocateResultType result = XKMSResponseFactory.createResponse(request, new LocateResultType());\n            // Search\n            for (Locator locator : getLocators()) {\n                UnverifiedKeyBindingType keyBinding = locator.locate(request);\n                if (keyBinding != null) {\n                    result.getUnverifiedKeyBinding().add(keyBinding);\n                    return result;\n                }\n            }\n            // No matches found\n            result.setResultMinor(ResultMinorEnum.HTTP_WWW_W_3_ORG_2002_03_XKMS_NO_MATCH.value());\n            return result;\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new LocateResultType()));\n        }\n    }","id":22462,"modified_method":"@Override\n    public LocateResultType locate(LocateRequestType request) {\n        try {\n            validateRequest(request);\n            // Create basic response\n            LocateResultType result = XKMSResponseFactory.createResponse(request, new LocateResultType());\n            // Search\n            for (Locator locator : locators) {\n                UnverifiedKeyBindingType keyBinding = locator.locate(request);\n                if (keyBinding != null) {\n                    result.getUnverifiedKeyBinding().add(keyBinding);\n                    return result;\n                }\n            }\n            // No matches found\n            result.setResultMinor(ResultMinorEnum.HTTP_WWW_W_3_ORG_2002_03_XKMS_NO_MATCH.value());\n            return result;\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new LocateResultType()));\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public RevokeResultType revoke(RevokeRequestType request) {\n        try {\n            validateRequest(request);\n            RevokeResultType response = XKMSResponseFactory.createResponse(request, new RevokeResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.revoke(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error due X509 Validation: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new RevokeResultType()));\n        }\n    }","id":22463,"modified_method":"@Override\n    public RevokeResultType revoke(RevokeRequestType request) {\n        try {\n            assertXKRSSAllowed();\n            validateRequest(request);\n            RevokeResultType response = XKMSResponseFactory.createResponse(request, new RevokeResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.revoke(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error due X509 Validation: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new RevokeResultType()));\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public CompoundResultType compound(CompoundRequestType request) {\n        validateRequest(request);\n\n        return ExceptionMapper.toResponse(new UnsupportedOperationException(\"XKMS request is currently not supported\"),\n                XKMSResponseFactory.createResponse(request, new CompoundResultType()));\n    }","id":22464,"modified_method":"@Override\n    public CompoundResultType compound(CompoundRequestType request) {\n        validateRequest(request);\n\n        RuntimeException ex = new UnsupportedOperationException(\"XKMS compound request is currently not supported\");\n        CompoundResultType response = XKMSResponseFactory.createResponse(request, new CompoundResultType());\n        return ExceptionMapper.toResponse(ex, response);\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public ReissueResultType reissue(ReissueRequestType request) {\n        try {\n            validateRequest(request);\n            ReissueResultType response = XKMSResponseFactory.createResponse(request, new ReissueResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.reissue(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error due X509 Validation: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new ReissueResultType()));\n        }\n    }","id":22465,"modified_method":"@Override\n    public ReissueResultType reissue(ReissueRequestType request) {\n        assertXKRSSAllowed();\n        try {\n            validateRequest(request);\n            ReissueResultType response = XKMSResponseFactory.createResponse(request, new ReissueResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.reissue(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error due X509 Validation: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new ReissueResultType()));\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public RecoverResultType recover(RecoverRequestType request) {\n        validateRequest(request);\n\n        return ExceptionMapper.toResponse(new UnsupportedOperationException(\"XKMS request is currently not supported\"),\n                XKMSResponseFactory.createResponse(request, new RecoverResultType()));\n    }","id":22466,"modified_method":"@Override\n    public RecoverResultType recover(RecoverRequestType request) {\n        try {\n            assertXKRSSAllowed();\n            validateRequest(request);\n            RecoverResultType response = XKMSResponseFactory.createResponse(request, new RecoverResultType());\n            try {\n                for (Register handler : keyRegisterHandlers) {\n                    if (handler.canProcess(request)) {\n                        return handler.recover(request, response);\n                    }\n                }\n                throw new UnsupportedOperationException(\"Service was unable to handle your request\");\n            } catch (Exception e) {\n                LOG.log(Level.SEVERE, \"Error during recover: \" + e.getMessage(), e);\n                return ExceptionMapper.toResponse(e, response);\n            }\n        } catch (Exception e) {\n            return ExceptionMapper.toResponse(e, XKMSResponseFactory.createResponse(request, new RecoverResultType()));\n        }\n    }","commit_id":"e521bb9e84b5701e50b4d9aa3d25c8206ca59b72","url":"https://github.com/apache/cxf"},{"original_method":"public void dump(Appendable out,String indent) throws IOException\n    {\n        dumpThis(out);\n        dump(out,indent,TypeUtil.asList(getHandlers()),getBeans());\n    }","id":22467,"modified_method":"public void dump(Appendable out,String indent) throws IOException\n    {\n        dumpThis(out);\n        dump(out,indent,getBeans(),TypeUtil.asList(getHandlers()));\n    }","commit_id":"c1b2eedadce864ba85e88bd37970a45b50f0aa3b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected boolean checkUserDataPermissions(String pathInContext, Request request, Response response, Object constraintInfo) throws IOException\n    {\n        if (constraintInfo == null)\n            return true;\n\n        RoleInfo roleInfo = (RoleInfo)constraintInfo;\n        if (roleInfo.isForbidden())\n            return false;\n\n\n        UserDataConstraint dataConstraint = roleInfo.getUserDataConstraint();\n        if (dataConstraint == null || dataConstraint == UserDataConstraint.None)\n        {\n            return true;\n        }\n        AbstractHttpConnection connection = AbstractHttpConnection.getCurrentConnection();\n        Connector connector = connection.getConnector();\n\n        if (dataConstraint == UserDataConstraint.Integral)\n        {\n            if (connector.isIntegral(request))\n                return true;\n            if (connector.getConfidentialPort() > 0)\n            {\n                String url = connector.getIntegralScheme() + \"://\" + request.getServerName() + \":\" + connector.getIntegralPort() + request.getRequestURI();\n                if (request.getQueryString() != null)\n                    url += \"?\" + request.getQueryString();\n                response.setContentLength(0);\n                response.sendRedirect(url);\n            }\n            else\n                response.sendError(Response.SC_FORBIDDEN,\"!Integral\");\n\n            request.setHandled(true);\n            return false;\n        }\n        else if (dataConstraint == UserDataConstraint.Confidential)\n        {\n            if (connector.isConfidential(request))\n                return true;\n\n            if (connector.getConfidentialPort() > 0)\n            {\n                String url = connector.getConfidentialScheme() + \"://\" + request.getServerName() + \":\" + connector.getConfidentialPort()\n                        + request.getRequestURI();\n                if (request.getQueryString() != null)\n                    url += \"?\" + request.getQueryString();\n\n                response.setContentLength(0);\n                response.sendRedirect(url);\n            }\n            else\n                response.sendError(Response.SC_FORBIDDEN,\"!Confidential\");\n\n            request.setHandled(true);\n            return false;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"Invalid dataConstraint value: \" + dataConstraint);\n        }\n\n    }","id":22468,"modified_method":"protected boolean checkUserDataPermissions(String pathInContext, Request request, Response response, Object constraintInfo) throws IOException\n    {\n        if (constraintInfo == null)\n            return true;\n\n        RoleInfo roleInfo = (RoleInfo)constraintInfo;\n        if (roleInfo.isForbidden())\n            return false;\n\n\n        UserDataConstraint dataConstraint = roleInfo.getUserDataConstraint();\n        if (dataConstraint == null || dataConstraint == UserDataConstraint.None)\n        {\n            return true;\n        }\n        AbstractHttpConnection connection = AbstractHttpConnection.getCurrentConnection();\n        Connector connector = connection.getConnector();\n\n        if (dataConstraint == UserDataConstraint.Integral)\n        {\n            if (connector.isIntegral(request))\n                return true;\n            if (connector.getIntegralPort() > 0)\n            {\n                String url = connector.getIntegralScheme() + \"://\" + request.getServerName() + \":\" + connector.getIntegralPort() + request.getRequestURI();\n                if (request.getQueryString() != null)\n                    url += \"?\" + request.getQueryString();\n                response.setContentLength(0);\n                response.sendRedirect(url);\n            }\n            else\n                response.sendError(Response.SC_FORBIDDEN,\"!Integral\");\n\n            request.setHandled(true);\n            return false;\n        }\n        else if (dataConstraint == UserDataConstraint.Confidential)\n        {\n            if (connector.isConfidential(request))\n                return true;\n\n            if (connector.getConfidentialPort() > 0)\n            {\n                String url = connector.getConfidentialScheme() + \"://\" + request.getServerName() + \":\" + connector.getConfidentialPort()\n                        + request.getRequestURI();\n                if (request.getQueryString() != null)\n                    url += \"?\" + request.getQueryString();\n\n                response.setContentLength(0);\n                response.sendRedirect(url);\n            }\n            else\n                response.sendError(Response.SC_FORBIDDEN,\"!Confidential\");\n\n            request.setHandled(true);\n            return false;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"Invalid dataConstraint value: \" + dataConstraint);\n        }\n\n    }","commit_id":"c1b2eedadce864ba85e88bd37970a45b50f0aa3b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void dump(Appendable out,String indent) throws IOException\n    {\n        dumpThis(out);\n        dump(out,indent,TypeUtil.asList(getHandlers()),getBeans(),Collections.singleton(_roles),_constraintMap.entrySet());\n    }","id":22469,"modified_method":"@Override\n    public void dump(Appendable out,String indent) throws IOException\n    {\n        dumpThis(out);\n        dump(out,indent,\n                Collections.singleton(getLoginService()),\n                Collections.singleton(getIdentityService()),\n                Collections.singleton(getAuthenticator()),\n                Collections.singleton(_roles),\n                _constraintMap.entrySet(),\n                getBeans(),\n                TypeUtil.asList(getHandlers()));\n    }","commit_id":"c1b2eedadce864ba85e88bd37970a45b50f0aa3b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void handle(String pathInContext, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        final Response base_response = baseRequest.getResponse();\n        final Handler handler=getHandler();\n        \n        if (handler==null)\n            return;\n\n        final Authenticator authenticator = _authenticator;\n        \n        if (authenticator!=null && checkSecurity(baseRequest))\n        {\n            Object constraintInfo = prepareConstraintInfo(pathInContext, baseRequest);\n            \n            // Check data constraints\n            if (!checkUserDataPermissions(pathInContext, baseRequest, base_response, constraintInfo))\n            {\n                if (!baseRequest.isHandled())\n                {\n                    response.sendError(Response.SC_FORBIDDEN);\n                    baseRequest.setHandled(true);\n                }\n                return;\n            }\n\n            // is Auth mandatory?\n            boolean isAuthMandatory = \n                isAuthMandatory(baseRequest, base_response, constraintInfo);\n\n            // check authentication\n            Object previousIdentity = null;\n            try\n            {\n                Authentication authentication = baseRequest.getAuthentication();\n                if (authentication==null || authentication==Authentication.NOT_CHECKED)\n                    authentication=authenticator.validateRequest(request, response, isAuthMandatory);\n\n                if (authentication instanceof Authentication.Wrapped)\n                {\n                    request=((Authentication.Wrapped)authentication).getHttpServletRequest();\n                    response=((Authentication.Wrapped)authentication).getHttpServletResponse();\n                }\n\n                if (authentication instanceof Authentication.ResponseSent)\n                {\n                    baseRequest.setHandled(true);\n                }\n                else if (authentication instanceof Authentication.User)\n                {\n                    Authentication.User userAuth = (Authentication.User)authentication;\n                    baseRequest.setAuthentication(authentication);\n                    previousIdentity = _identityService.associate(userAuth.getUserIdentity());\n\n                    if (isAuthMandatory)\n                    {\n                        boolean authorized=checkWebResourcePermissions(pathInContext, baseRequest, base_response, constraintInfo, userAuth.getUserIdentity());\n                        if (!authorized)\n                        {\n                            response.sendError(Response.SC_FORBIDDEN, \"!role\");\n                            baseRequest.setHandled(true);\n                            return;\n                        }\n                    }\n                         \n                    handler.handle(pathInContext, baseRequest, request, response);\n                    authenticator.secureResponse(request, response, isAuthMandatory, userAuth);\n                }\n                else if (authentication instanceof Authentication.Deferred)\n                {\n                    DeferredAuthentication deferred= (DeferredAuthentication)authentication;\n                    deferred.setIdentityService(_identityService);\n                    deferred.setLoginService(_loginService);\n                    baseRequest.setAuthentication(authentication);\n\n                    try\n                    {\n                        handler.handle(pathInContext, baseRequest, request, response);\n                    }\n                    finally\n                    {\n                        previousIdentity = deferred.getPreviousAssociation();\n                        deferred.setIdentityService(null);\n                    }\n                   \n                    Authentication auth=baseRequest.getAuthentication();\n                    if (auth instanceof Authentication.User)\n                    {\n                        Authentication.User userAuth = (Authentication.User)auth;\n                        authenticator.secureResponse(request, response, isAuthMandatory, userAuth);\n                    }\n                    else\n                        authenticator.secureResponse(request, response, isAuthMandatory, null);\n                }\n                else\n                {\n                    baseRequest.setAuthentication(authentication);\n                    previousIdentity = _identityService.associate(null);\n                    handler.handle(pathInContext, baseRequest, request, response);\n                    authenticator.secureResponse(request, response, isAuthMandatory, null);\n                }\n            }\n            catch (ServerAuthException e)\n            {\n                // jaspi 3.8.3 send HTTP 500 internal server error, with message\n                // from AuthException\n                response.sendError(Response.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n            finally\n            {\n                _identityService.disassociate(previousIdentity);\n            }\n        }\n        else\n            handler.handle(pathInContext, baseRequest, request, response);\n    }","id":22470,"modified_method":"@Override\n    public void handle(String pathInContext, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        final Response base_response = baseRequest.getResponse();\n        final Handler handler=getHandler();\n        \n        if (handler==null)\n            return;\n\n        final Authenticator authenticator = _authenticator;\n        \n        if (checkSecurity(baseRequest))\n        {\n            Object constraintInfo = prepareConstraintInfo(pathInContext, baseRequest);\n            \n            // Check data constraints\n            if (!checkUserDataPermissions(pathInContext, baseRequest, base_response, constraintInfo))\n            {\n                if (!baseRequest.isHandled())\n                {\n                    response.sendError(Response.SC_FORBIDDEN);\n                    baseRequest.setHandled(true);\n                }\n                return;\n            }\n\n            // is Auth mandatory?\n            boolean isAuthMandatory = \n                isAuthMandatory(baseRequest, base_response, constraintInfo);\n\n            if (isAuthMandatory && authenticator==null)\n            {\n                LOG.warn(\"No authenticator for: \"+constraintInfo);\n                if (!baseRequest.isHandled())\n                {\n                    response.sendError(Response.SC_FORBIDDEN);\n                    baseRequest.setHandled(true);\n                }\n                return;\n            }\n            \n            // check authentication\n            Object previousIdentity = null;\n            try\n            {\n                Authentication authentication = baseRequest.getAuthentication();\n                if (authentication==null || authentication==Authentication.NOT_CHECKED)\n                    authentication=authenticator==null?Authentication.UNAUTHENTICATED:authenticator.validateRequest(request, response, isAuthMandatory);\n\n                if (authentication instanceof Authentication.Wrapped)\n                {\n                    request=((Authentication.Wrapped)authentication).getHttpServletRequest();\n                    response=((Authentication.Wrapped)authentication).getHttpServletResponse();\n                }\n\n                if (authentication instanceof Authentication.ResponseSent)\n                {\n                    baseRequest.setHandled(true);\n                }\n                else if (authentication instanceof Authentication.User)\n                {\n                    Authentication.User userAuth = (Authentication.User)authentication;\n                    baseRequest.setAuthentication(authentication);\n                    previousIdentity = _identityService.associate(userAuth.getUserIdentity());\n\n                    if (isAuthMandatory)\n                    {\n                        boolean authorized=checkWebResourcePermissions(pathInContext, baseRequest, base_response, constraintInfo, userAuth.getUserIdentity());\n                        if (!authorized)\n                        {\n                            response.sendError(Response.SC_FORBIDDEN, \"!role\");\n                            baseRequest.setHandled(true);\n                            return;\n                        }\n                    }\n                         \n                    handler.handle(pathInContext, baseRequest, request, response);\n                    authenticator.secureResponse(request, response, isAuthMandatory, userAuth);\n                }\n                else if (authentication instanceof Authentication.Deferred)\n                {\n                    DeferredAuthentication deferred= (DeferredAuthentication)authentication;\n                    deferred.setIdentityService(_identityService);\n                    deferred.setLoginService(_loginService);\n                    baseRequest.setAuthentication(authentication);\n\n                    try\n                    {\n                        handler.handle(pathInContext, baseRequest, request, response);\n                    }\n                    finally\n                    {\n                        previousIdentity = deferred.getPreviousAssociation();\n                        deferred.setIdentityService(null);\n                    }\n                   \n                    Authentication auth=baseRequest.getAuthentication();\n                    if (auth instanceof Authentication.User)\n                    {\n                        Authentication.User userAuth = (Authentication.User)auth;\n                        authenticator.secureResponse(request, response, isAuthMandatory, userAuth);\n                    }\n                    else\n                        authenticator.secureResponse(request, response, isAuthMandatory, null);\n                }\n                else\n                {\n                    baseRequest.setAuthentication(authentication);\n                    if (_identityService!=null)\n                        previousIdentity = _identityService.associate(null);\n                    handler.handle(pathInContext, baseRequest, request, response);\n                    if (authenticator!=null)\n                        authenticator.secureResponse(request, response, isAuthMandatory, null);\n                }\n            }\n            catch (ServerAuthException e)\n            {\n                // jaspi 3.8.3 send HTTP 500 internal server error, with message\n                // from AuthException\n                response.sendError(Response.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n            finally\n            {\n                if (_identityService!=null)\n                    _identityService.disassociate(previousIdentity);\n            }\n        }\n        else\n            handler.handle(pathInContext, baseRequest, request, response);\n    }","commit_id":"c1b2eedadce864ba85e88bd37970a45b50f0aa3b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected LoginService findLoginService()\n    {\n        List<LoginService> list = getServer().getBeans(LoginService.class);\n        \n        for (LoginService service : list)\n            if (service.getName()!=null && service.getName().equals(getRealmName()))\n                return service;\n        if (list.size()>0)\n            return list.get(0);\n        return null;\n    }","id":22471,"modified_method":"protected LoginService findLoginService()\n    {\n        List<LoginService> list = getServer().getBeans(LoginService.class);\n        \n        String realm=getRealmName();\n        if (realm!=null)\n        {\n            for (LoginService service : list)\n                if (service.getName()!=null && service.getName().equals(realm))\n                    return service;\n        }\n        else if (list.size()==1)\n            return list.get(0);\n        return null;\n    }","commit_id":"c1b2eedadce864ba85e88bd37970a45b50f0aa3b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void validateRequest(CommandContext ctx, ModelNode request) throws CommandFormatException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            throw new CommandFormatException(\"No connection to the controller.\");\n        }\n\n        final Set<String> keys = request.keys();\n\n        if(!keys.contains(Util.OPERATION)) {\n            throw new CommandFormatException(\"Request is missing the operation name.\");\n        }\n        final String operationName = request.get(Util.OPERATION).asString();\n\n        if(!keys.contains(Util.ADDRESS)) {\n            throw new CommandFormatException(\"Request is missing the address part.\");\n        }\n        final ModelNode address = request.get(Util.ADDRESS);\n\n        if(keys.size() == 2) { // no props\n            return;\n        }\n\n        final ModelNode opDescrReq = new ModelNode();\n        opDescrReq.get(Util.ADDRESS).set(address);\n        opDescrReq.get(Util.OPERATION).set(Util.READ_OPERATION_DESCRIPTION);\n        opDescrReq.get(Util.NAME).set(operationName);\n\n        final ModelNode outcome;\n        try {\n            outcome = client.execute(opDescrReq);\n        } catch(Exception e) {\n            throw new CommandFormatException(\"Failed to perform \" + Util.READ_OPERATION_DESCRIPTION + \" to validate the request: \" + e.getLocalizedMessage());\n        }\n        if (!Util.isSuccess(outcome)) {\n            throw new CommandFormatException(\"Failed to get the list of the operation properties: \\\"\" + Util.getFailureDescription(outcome) + '\\\"');\n        }\n\n        if(!outcome.has(Util.RESULT)) {\n            throw new CommandFormatException(\"Failed to perform \" + Util.READ_OPERATION_DESCRIPTION + \" to validate the request: result is not available.\");\n        }\n        final ModelNode result = outcome.get(Util.RESULT);\n        if(!result.hasDefined(Util.REQUEST_PROPERTIES)) {\n            throw new CommandFormatException(\"Operation '\" + operationName + \"' does not expect any property.\");\n        }\n        final Set<String> definedProps = result.get(\"request-properties\").keys();\n        if(definedProps.isEmpty()) {\n            throw new CommandFormatException(\"Operation '\" + operationName + \"' does not expect any property.\");\n        }\n\n        int skipped = 0;\n        for(String prop : keys) {\n            if(skipped < 2 && (prop.equals(Util.ADDRESS) || prop.equals(Util.OPERATION))) {\n                ++skipped;\n                continue;\n            }\n            if(!definedProps.contains(prop)) {\n                if(!Util.OPERATION_HEADERS.equals(prop)) {\n                    throw new CommandFormatException(\"'\" + prop + \"' is not found among the supported properties: \" + definedProps);\n                }\n            }\n        }\n    }","id":22472,"modified_method":"private void validateRequest(CommandContext ctx, ModelNode request) throws CommandFormatException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            throw new CommandFormatException(\"No connection to the controller.\");\n        }\n\n        final Set<String> keys = request.keys();\n\n        if(!keys.contains(Util.OPERATION)) {\n            throw new CommandFormatException(\"Request is missing the operation name.\");\n        }\n        final String operationName = request.get(Util.OPERATION).asString();\n\n        if(!keys.contains(Util.ADDRESS)) {\n            throw new CommandFormatException(\"Request is missing the address part.\");\n        }\n        final ModelNode address = request.get(Util.ADDRESS);\n\n        if(keys.size() == 2) { // no props\n            return;\n        }\n\n        final ModelNode opDescrReq = new ModelNode();\n        opDescrReq.get(Util.ADDRESS).set(address);\n        opDescrReq.get(Util.OPERATION).set(Util.READ_OPERATION_DESCRIPTION);\n        opDescrReq.get(Util.NAME).set(operationName);\n\n        final ModelNode outcome;\n        try {\n            outcome = client.execute(opDescrReq);\n        } catch(Exception e) {\n            throw new CommandFormatException(\"Failed to perform \" + Util.READ_OPERATION_DESCRIPTION + \" to validate the request: \" + e.getLocalizedMessage());\n        }\n        if (!Util.isSuccess(outcome)) {\n            throw new CommandFormatException(\"Failed to get the list of the operation properties: \\\"\" + Util.getFailureDescription(outcome) + '\\\"');\n        }\n\n        if(!outcome.has(Util.RESULT)) {\n            throw new CommandFormatException(\"Failed to perform \" + Util.READ_OPERATION_DESCRIPTION + \" to validate the request: result is not available.\");\n        }\n        final ModelNode result = outcome.get(Util.RESULT);\n        if(!result.hasDefined(Util.REQUEST_PROPERTIES)) {\n            if(!(keys.size() == 3 && keys.contains(Util.OPERATION_HEADERS))) {\n                throw new CommandFormatException(\"Operation '\" + operationName + \"' does not expect any property.\");\n            }\n        } else {\n            final Set<String> definedProps = result.get(Util.REQUEST_PROPERTIES).keys();\n            if(definedProps.isEmpty()) {\n                if(!(keys.size() == 3 && keys.contains(Util.OPERATION_HEADERS))) {\n                    throw new CommandFormatException(\"Operation '\" + operationName + \"' does not expect any property.\");\n                }\n            }\n\n            int skipped = 0;\n            for(String prop : keys) {\n                if(skipped < 2 && (prop.equals(Util.ADDRESS) || prop.equals(Util.OPERATION))) {\n                    ++skipped;\n                    continue;\n                }\n                if(!definedProps.contains(prop)) {\n                    if(!Util.OPERATION_HEADERS.equals(prop)) {\n                        throw new CommandFormatException(\"'\" + prop + \"' is not found among the supported properties: \" + definedProps);\n                    }\n                }\n            }\n        }\n    }","commit_id":"2ac536f7224a8d0443b0467322486f29b634eaaa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void handle(CommandContext ctx) throws CommandLineException {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            throw new CommandFormatException(\"You are disconnected at the moment.\" +\n                    \" Type 'connect' to connect to the server\" +\n                    \" or 'help' for the list of supported commands.\");\n        }\n\n        ModelNode request = (ModelNode) ctx.get(\"OP_REQ\");\n        if(request == null) {\n            throw new CommandFormatException(\"Parsed request isn't available.\");\n        }\n\n        try {\n            validateRequest(ctx, request);\n        } catch(CommandFormatException e) {\n            throw new CommandFormatException(e.getLocalizedMessage());\n        }\n\n        try {\n            final ModelNode result = client.execute(request);\n            if(Util.isSuccess(result)) {\n                ctx.printLine(result.toString());\n            } else {\n                throw new CommandFormatException(result.toString());\n            }\n        } catch(NoSuchElementException e) {\n            throw new CommandFormatException(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            throw new CommandFormatException(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.disconnectController();\n            throw new CommandFormatException(\"Communication error: \" + e.getLocalizedMessage());\n        } catch (RuntimeException e) {\n            throw new CommandFormatException(\"Failed to execute operation.\", e);\n        }\n    }","id":22473,"modified_method":"@Override\n    public void handle(CommandContext ctx) throws CommandLineException {\n\n        ModelControllerClient client = ctx.getModelControllerClient();\n        if(client == null) {\n            throw new CommandFormatException(\"You are disconnected at the moment.\" +\n                    \" Type 'connect' to connect to the server\" +\n                    \" or 'help' for the list of supported commands.\");\n        }\n\n        ModelNode request = (ModelNode) ctx.get(\"OP_REQ\");\n        if(request == null) {\n            throw new CommandFormatException(\"Parsed request isn't available.\");\n        }\n\n        validateRequest(ctx, request);\nSystem.out.println(\"request:\\n\" + request);\n        try {\n            final ModelNode result = client.execute(request);\n            if(Util.isSuccess(result)) {\n                ctx.printLine(result.toString());\n            } else {\n                throw new CommandFormatException(result.toString());\n            }\n        } catch(NoSuchElementException e) {\n            throw new CommandFormatException(\"ModelNode request is incomplete: \" + e.getMessage());\n        } catch (CancellationException e) {\n            throw new CommandFormatException(\"The result couldn't be retrieved (perhaps the task was cancelled: \" + e.getLocalizedMessage());\n        } catch (IOException e) {\n            ctx.disconnectController();\n            throw new CommandFormatException(\"Communication error: \" + e.getLocalizedMessage());\n        } catch (RuntimeException e) {\n            throw new CommandFormatException(\"Failed to execute operation.\", e);\n        }\n    }","commit_id":"2ac536f7224a8d0443b0467322486f29b634eaaa","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public boolean visit(ConstructorDeclaration ctorDecl, ClassScope scope) {\n      try {\n        MethodBinding b = ctorDecl.binding;\n        SModel model = myReferentsCreator.myCurrentModel;\n        Classifier enclosingType = (Classifier) myReferentsCreator.myBindingMap.get(scope.enclosingSourceType());\n        assert (enclosingType instanceof ClassConcept);\n        ClassConcept classConcept = (ClassConcept) enclosingType;\n        jetbrains.mps.baseLanguage.structure.ConstructorDeclaration constructorDeclaration =\n          jetbrains.mps.baseLanguage.structure.ConstructorDeclaration.newInstance(model);\n        Visibility visibility = getMethodVisibility(b);\n        constructorDeclaration.setVisibility(visibility);\n        mapParameters(constructorDeclaration, ctorDecl);\n        classConcept.addConstructor(constructorDeclaration);\n        myReferentsCreator.myBindingMap.put(b, constructorDeclaration);\n        return true;\n      } catch (Throwable e) {\n        throw new JavaConverterException(e);\n      }\n    }","id":22474,"modified_method":"@Override\n    public boolean visit(ConstructorDeclaration ctorDecl, ClassScope scope) {\n      try {\n        MethodBinding b = ctorDecl.binding;\n        SModel model = myReferentsCreator.myCurrentModel;\n        Classifier enclosingType = (Classifier) myReferentsCreator.myBindingMap.get(scope.enclosingSourceType());\n        assert (enclosingType instanceof ClassConcept);\n        ClassConcept classConcept = (ClassConcept) enclosingType;\n        jetbrains.mps.baseLanguage.structure.ConstructorDeclaration constructorDeclaration =\n          jetbrains.mps.baseLanguage.structure.ConstructorDeclaration.newInstance(model);\n        Visibility visibility = getMethodVisibility(b);\n        constructorDeclaration.setVisibility(visibility);\n        mapParameters(constructorDeclaration, ctorDecl);\n        if (!(classConcept instanceof AnonymousClass)) {\n          classConcept.addConstructor(constructorDeclaration);\n        }\n        myReferentsCreator.myBindingMap.put(b, constructorDeclaration);\n        return true;\n      } catch (Throwable e) {\n        throw new JavaConverterException(e);\n      }\n    }","commit_id":"da3f2f2f9b766ee247f2804d8dfe0f645c58f9e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean validateConstructors(ClassNode cNode) {\n        if (cNode.getDeclaredConstructors().size() != 0) {\n            // TODO: allow constructors which only call provided constructor?\n            addError(\"Explicit constructors not allowed for \" + MY_TYPE_NAME + \" class: \" + cNode.getNameWithoutPackage(), cNode.getDeclaredConstructors().get(0));\n        }\n        return true;\n    }","id":22475,"modified_method":"private boolean validateConstructors(ClassNode cNode) {\n        List<ConstructorNode> declaredConstructors = cNode.getDeclaredConstructors();\n        for (ConstructorNode constructorNode : declaredConstructors) {\n            // allow Synthetic constructors added by other transforms\n            if ((constructorNode.getModifiers() & ACC_SYNTHETIC) != 0) {\n                continue;\n            }\n            // TODO: allow constructors which only call provided constructor?\n            addError(\"Explicit constructors not allowed for \" + MY_TYPE_NAME + \" class: \" + cNode.getNameWithoutPackage(), constructorNode);\n            return false;\n        }\n        return true;\n    }","commit_id":"e9ed3ff64ef733a5df5c7a966719f66d8f1998e9","url":"https://github.com/apache/groovy"},{"original_method":"private static void createBuildeeConstructors(ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(\"initializer\"), fieldNode.getName()));\n        }\n        Expression args = new ArgumentListExpression(argsList);\n        buildee.addConstructor(ACC_PUBLIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args)));\n        final BlockStatement body = new BlockStatement();\n        body.addStatement(ctorSuperS());\n        initializeFields(fields, body);\n        buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields), NO_EXCEPTIONS, body);\n    }","id":22476,"modified_method":"private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields) {\n        ClassNode paramType = makeClassSafeWithGenerics(builder, setGenTypes(fields.size()));\n        List<Expression> argsList = new ArrayList<Expression>();\n        for (FieldNode fieldNode : fields) {\n            argsList.add(propX(varX(\"initializer\"), fieldNode.getName()));\n        }\n        Expression args = new ArgumentListExpression(argsList);\n        buildee.addConstructor(ACC_PUBLIC | ACC_SYNTHETIC, params(param(paramType, \"initializer\")), NO_EXCEPTIONS, block(ctorThisS(args)));\n        if (!transform.hasAnnotation(buildee, ImmutableASTTransformation.MY_TYPE)) {\n            final BlockStatement body = new BlockStatement();\n            body.addStatement(ctorSuperS());\n            initializeFields(fields, body);\n            buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields), NO_EXCEPTIONS, body);\n        }\n    }","commit_id":"e9ed3ff64ef733a5df5c7a966719f66d8f1998e9","url":"https://github.com/apache/groovy"},{"original_method":"public void build(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Initializer\");\n        String buildMethodName = transform.getMemberStringValue(anno, \"buildMethodName\", \"create\");\n        List<FieldNode> fields = getInstancePropertyFields(buildee);\n        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);\n        int numFields = filteredFields.size();\n        ClassNode builder = createInnerHelperClass(buildee, builderClassName, filteredFields);\n        createBuilderConstructors(builder, fields);\n        createBuildeeConstructors(buildee, builder, fields);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, buildMethodName, builder, numFields));\n        for (int i = 0; i < numFields; i++) {\n            builder.addField(createFieldCopy(buildee, filteredFields.get(i)));\n            builder.addMethod(createBuilderMethodForField(builder, filteredFields, prefix, i));\n        }\n        builder.addMethod(createBuildMethod(builder, buildMethodName, filteredFields));\n    }","id":22477,"modified_method":"public void build(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {\n        List<String> excludes = new ArrayList<String>();\n        List<String> includes = new ArrayList<String>();\n        if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;\n        String prefix = transform.getMemberStringValue(anno, \"prefix\", \"\");\n        if (unsupportedAttribute(transform, anno, \"forClass\")) return;\n        String builderClassName = transform.getMemberStringValue(anno, \"builderClassName\", buildee.getName() + \"Initializer\");\n        String buildMethodName = transform.getMemberStringValue(anno, \"buildMethodName\", \"create\");\n        List<FieldNode> fields = getInstancePropertyFields(buildee);\n        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);\n        int numFields = filteredFields.size();\n        ClassNode builder = createInnerHelperClass(buildee, builderClassName, filteredFields);\n        createBuilderConstructors(builder, filteredFields);\n        createBuildeeConstructors(transform, buildee, builder, filteredFields);\n        buildee.getModule().addClass(builder);\n        buildee.addMethod(createBuilderMethod(transform, anno, buildMethodName, builder, numFields));\n        for (int i = 0; i < numFields; i++) {\n            builder.addField(createFieldCopy(buildee, filteredFields.get(i)));\n            builder.addMethod(createBuilderMethodForField(builder, filteredFields, prefix, i));\n        }\n        builder.addMethod(createBuildMethod(builder, buildMethodName, filteredFields));\n    }","commit_id":"e9ed3ff64ef733a5df5c7a966719f66d8f1998e9","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public final void performInjection(SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        Class instanceImplementation = getInstanceImplementation();\n\n        if(instanceImplementation != null) {\n            ClassNode implementationNode = new ClassNode(instanceImplementation);\n\n\n\n            String apiInstanceProperty = INSTANCE_PREFIX + instanceImplementation.getSimpleName();\n            VariableExpression apiInstance = new VariableExpression(apiInstanceProperty);\n\n\n            PropertyNode propertyNode = new PropertyNode(apiInstanceProperty, Modifier.PUBLIC, implementationNode, classNode, new ConstructorCallExpression(implementationNode, ZERO_ARGS), null, null);\n            propertyNode.addAnnotation(AUTO_WIRED_ANNOTATION);\n            classNode.addProperty(propertyNode);\n\n            while(!implementationNode.equals(OBJECT_CLASS)) {\n                List<MethodNode> declaredMethods = implementationNode.getMethods();\n                for (MethodNode declaredMethod : declaredMethods) {\n\n                    if(isConstructor(declaredMethod)) {\n                        BlockStatement constructorBody = new BlockStatement();\n                        ArgumentListExpression arguments = new ArgumentListExpression();\n                        arguments.addExpression(THIS_EXPRESSION);\n                        constructorBody.addStatement(new ExpressionStatement( new MethodCallExpression(new ClassExpression(implementationNode), \"initialize\",arguments)));\n                        classNode.addConstructor(new ConstructorNode(Modifier.PUBLIC, constructorBody));\n                    }\n                    else if(isCandidateInstanceMethod(declaredMethod)) {\n\n                        Parameter[] parameterTypes = getParameterTypes(declaredMethod.getParameters());\n                        if(!classNode.hasMethod(declaredMethod.getName(), parameterTypes)) {\n                            BlockStatement methodBody = new BlockStatement();\n                            ArgumentListExpression arguments = new ArgumentListExpression();\n                            arguments.addExpression(THIS_EXPRESSION);\n                            for (Parameter parameterType : parameterTypes) {\n                                arguments.addExpression(new VariableExpression(parameterType.getName()));\n                            }\n                            methodBody.addStatement(new ExpressionStatement( new MethodCallExpression(apiInstance, declaredMethod.getName(), arguments)));\n                            MethodNode methodNode = new MethodNode(declaredMethod.getName(),\n                                                                   Modifier.PUBLIC,\n                                                                   declaredMethod.getReturnType(),\n                                                                   parameterTypes,\n                                                                   EMPTY_CLASS_ARRAY,\n                                                                   methodBody\n                                                                    );\n                            classNode.addMethod(methodNode);\n                        }\n\n                    }\n\n                }\n                implementationNode = implementationNode.getSuperClass();\n            }\n            performInjectionInternal(apiInstanceProperty, source, classNode);\n        }\n\n\n        if(classNode.getAnnotations(ENHANCED_CLASS_NODE) == null)\n            classNode.addAnnotation(new AnnotationNode(ENHANCED_CLASS_NODE));\n\n    }","id":22478,"modified_method":"@Override\n    public final void performInjection(SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        Class instanceImplementation = getInstanceImplementation();\n\n        if(instanceImplementation != null) {\n            ClassNode implementationNode = new ClassNode(instanceImplementation);\n\n\n\n            String apiInstanceProperty = INSTANCE_PREFIX + instanceImplementation.getSimpleName();\n            VariableExpression apiInstance = new VariableExpression(apiInstanceProperty);\n\n\n            PropertyNode propertyNode = new PropertyNode(apiInstanceProperty, Modifier.PUBLIC, implementationNode, classNode, new ConstructorCallExpression(implementationNode, ZERO_ARGS), null, null);\n            propertyNode.addAnnotation(AUTO_WIRED_ANNOTATION);\n            classNode.addProperty(propertyNode);\n\n            while(!implementationNode.equals(OBJECT_CLASS)) {\n                List<MethodNode> declaredMethods = implementationNode.getMethods();\n                for (MethodNode declaredMethod : declaredMethods) {\n\n                    if(isConstructor(declaredMethod)) {\n                        BlockStatement constructorBody = new BlockStatement();\n                        ArgumentListExpression arguments = new ArgumentListExpression();\n                        arguments.addExpression(THIS_EXPRESSION);\n                        constructorBody.addStatement(new ExpressionStatement( new MethodCallExpression(new ClassExpression(implementationNode), \"initialize\",arguments)));\n                        ConstructorNode constructorNode = getDefaultConstructor(classNode);\n                        if(constructorNode != null){\n                            constructorBody.addStatement(constructorNode.getCode());\n                            constructorNode.setCode(constructorBody);\n                        }else{\n                            classNode.addConstructor(new ConstructorNode(Modifier.PUBLIC, constructorBody));\n                        }\n                    }\n                    else if(isCandidateInstanceMethod(declaredMethod)) {\n\n                        Parameter[] parameterTypes = getParameterTypes(declaredMethod.getParameters());\n                        if(!classNode.hasMethod(declaredMethod.getName(), parameterTypes)) {\n                            BlockStatement methodBody = new BlockStatement();\n                            ArgumentListExpression arguments = new ArgumentListExpression();\n                            arguments.addExpression(THIS_EXPRESSION);\n                            for (Parameter parameterType : parameterTypes) {\n                                arguments.addExpression(new VariableExpression(parameterType.getName()));\n                            }\n                            methodBody.addStatement(new ExpressionStatement( new MethodCallExpression(apiInstance, declaredMethod.getName(), arguments)));\n                            MethodNode methodNode = new MethodNode(declaredMethod.getName(),\n                                                                   Modifier.PUBLIC,\n                                                                   declaredMethod.getReturnType(),\n                                                                   parameterTypes,\n                                                                   EMPTY_CLASS_ARRAY,\n                                                                   methodBody\n                                                                    );\n                            classNode.addMethod(methodNode);\n                        }\n\n                    }\n\n                }\n                implementationNode = implementationNode.getSuperClass();\n            }\n            performInjectionInternal(apiInstanceProperty, source, classNode);\n        }\n\n\n        if(classNode.getAnnotations(ENHANCED_CLASS_NODE) == null)\n            classNode.addAnnotation(new AnnotationNode(ENHANCED_CLASS_NODE));\n\n    }","commit_id":"66f1ee82edffe7d07a704a8c854e31c6a697cb58","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public void performInjection(SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        File sourcePath = new File(source.getName());\n        try {\n            String absolutePath = sourcePath.getCanonicalPath();\n            if (pluginBuildSettings == null) {\n                return;\n            }\n\n            GrailsPluginInfo info = pluginBuildSettings.getPluginInfoForSource(absolutePath);\n            if (info == null) {\n                return;\n            }\n\n            final ClassNode annotation = new ClassNode(GrailsPlugin.class);\n            final List<?> list = classNode.getAnnotations(annotation);\n            if (!list.isEmpty()) {\n                return;\n            }\n\n            final AnnotationNode annotationNode = new AnnotationNode(annotation);\n            annotationNode.addMember(org.codehaus.groovy.grails.plugins.GrailsPlugin.NAME,\n                    new ConstantExpression(info.getName()));\n            annotationNode.addMember(org.codehaus.groovy.grails.plugins.GrailsPlugin.VERSION,\n                    new ConstantExpression(info.getVersion()));\n            annotationNode.setRuntimeRetention(true);\n            annotationNode.setClassRetention(true);\n\n            classNode.addAnnotation(annotationNode);\n        }\n        catch (IOException e) {\n            // ignore\n        }\n    }","id":22479,"modified_method":"@Override\n    public void performInjection(SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        File sourcePath = new File(source.getName());\n        try {\n            String absolutePath = sourcePath.getCanonicalPath();\n            if (pluginBuildSettings == null) {\n                return;\n            }\n\n            GrailsPluginInfo info = pluginBuildSettings.getPluginInfoForSource(absolutePath);\n            if (info == null) {\n                return;\n            }\n\n            final ClassNode annotation = new ClassNode(GrailsPlugin.class);\n            final List<?> list = classNode.getAnnotations(annotation);\n            if (!list.isEmpty()) {\n                return;\n            }\n\n            if(classNode.isAnnotationDefinition()){\n                return;\n            }\n\n            final AnnotationNode annotationNode = new AnnotationNode(annotation);\n            annotationNode.addMember(org.codehaus.groovy.grails.plugins.GrailsPlugin.NAME,\n                    new ConstantExpression(info.getName()));\n            annotationNode.addMember(org.codehaus.groovy.grails.plugins.GrailsPlugin.VERSION,\n                    new ConstantExpression(info.getVersion()));\n            annotationNode.setRuntimeRetention(true);\n            annotationNode.setClassRetention(true);\n\n            classNode.addAnnotation(annotationNode);\n        }\n        catch (IOException e) {\n            // ignore\n        }\n    }","commit_id":"66f1ee82edffe7d07a704a8c854e31c6a697cb58","url":"https://github.com/grails/grails-core"},{"original_method":"public boolean canAddSetter(final MutableFieldDeclaration field) {\n      boolean _isFinal = field.isFinal();\n      if (_isFinal) {\n        this.context.addError(field, \"Cannot set a final field\");\n        return false;\n      }\n      TypeReference _type = field.getType();\n      boolean _isInferred = _type.isInferred();\n      if (_isInferred) {\n        this.context.addError(field, \"Type cannot be inferred.\");\n        return false;\n      }\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      TypeReference _newSelfTypeReference = this.context.newSelfTypeReference(_declaringType);\n      Iterable<? extends ResolvedMethod> _allResolvedMethods = _newSelfTypeReference.getAllResolvedMethods();\n      final Function1<ResolvedMethod, Boolean> _function = new Function1<ResolvedMethod, Boolean>() {\n        public Boolean apply(final ResolvedMethod it) {\n          boolean _and = false;\n          boolean _and_1 = false;\n          MethodDeclaration _declaration = it.getDeclaration();\n          String _simpleName = _declaration.getSimpleName();\n          String _setterName = Util.this.getSetterName(field);\n          boolean _equals = Objects.equal(_simpleName, _setterName);\n          if (!_equals) {\n            _and_1 = false;\n          } else {\n            Iterable<? extends ResolvedParameter> _resolvedParameters = it.getResolvedParameters();\n            int _size = IterableExtensions.size(_resolvedParameters);\n            boolean _equals_1 = (_size == 1);\n            _and_1 = _equals_1;\n          }\n          if (!_and_1) {\n            _and = false;\n          } else {\n            TypeReference _type = field.getType();\n            Iterable<? extends ResolvedParameter> _resolvedParameters_1 = it.getResolvedParameters();\n            ResolvedParameter _head = IterableExtensions.head(_resolvedParameters_1);\n            TypeReference _resolvedType = _head.getResolvedType();\n            boolean _isAssignableFrom = _type.isAssignableFrom(_resolvedType);\n            _and = _isAssignableFrom;\n          }\n          return Boolean.valueOf(_and);\n        }\n      };\n      final ResolvedMethod overriddenSetter = IterableExtensions.findFirst(_allResolvedMethods, _function);\n      boolean _equals = Objects.equal(overriddenSetter, null);\n      if (_equals) {\n        return true;\n      }\n      final MethodDeclaration overriddenDeclaration = overriddenSetter.getDeclaration();\n      boolean _isFinal_1 = overriddenDeclaration.isFinal();\n      if (_isFinal_1) {\n        StringConcatenation _builder = new StringConcatenation();\n        _builder.append(\"Cannot override the final method \");\n        String _simpleSignature = overriddenSetter.getSimpleSignature();\n        _builder.append(_simpleSignature, \"\");\n        _builder.append(\" in \");\n        TypeDeclaration _declaringType_1 = overriddenDeclaration.getDeclaringType();\n        String _simpleName = _declaringType_1.getSimpleName();\n        _builder.append(_simpleName, \"\");\n        this.context.addError(field, _builder.toString());\n        return false;\n      }\n      TypeReference _resolvedReturnType = overriddenSetter.getResolvedReturnType();\n      boolean _isVoid = _resolvedReturnType.isVoid();\n      boolean _not = (!_isVoid);\n      if (_not) {\n        StringConcatenation _builder_1 = new StringConcatenation();\n        _builder_1.append(\"Cannot override the method \");\n        String _simpleSignature_1 = overriddenSetter.getSimpleSignature();\n        _builder_1.append(_simpleSignature_1, \"\");\n        _builder_1.append(\" in \");\n        TypeDeclaration _declaringType_2 = overriddenDeclaration.getDeclaringType();\n        String _simpleName_1 = _declaringType_2.getSimpleName();\n        _builder_1.append(_simpleName_1, \"\");\n        _builder_1.append(\", because its return type is not void�\");\n        _builder_1.newLineIfNotEmpty();\n        this.context.addError(field, _builder_1.toString());\n        return false;\n      }\n      return true;\n    }","id":22480,"modified_method":"public void validateSetter(final MutableFieldDeclaration field) {\n      boolean _isFinal = field.isFinal();\n      if (_isFinal) {\n        this.context.addError(field, \"Cannot set a final field\");\n      }\n      TypeReference _type = field.getType();\n      boolean _isInferred = _type.isInferred();\n      if (_isInferred) {\n        this.context.addError(field, \"Type cannot be inferred.\");\n        return;\n      }\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      TypeReference _newSelfTypeReference = this.context.newSelfTypeReference(_declaringType);\n      Iterable<? extends ResolvedMethod> _allResolvedMethods = _newSelfTypeReference.getAllResolvedMethods();\n      final Function1<ResolvedMethod, Boolean> _function = new Function1<ResolvedMethod, Boolean>() {\n        public Boolean apply(final ResolvedMethod it) {\n          boolean _and = false;\n          boolean _and_1 = false;\n          MethodDeclaration _declaration = it.getDeclaration();\n          String _simpleName = _declaration.getSimpleName();\n          String _setterName = Util.this.getSetterName(field);\n          boolean _equals = Objects.equal(_simpleName, _setterName);\n          if (!_equals) {\n            _and_1 = false;\n          } else {\n            Iterable<? extends ResolvedParameter> _resolvedParameters = it.getResolvedParameters();\n            int _size = IterableExtensions.size(_resolvedParameters);\n            boolean _equals_1 = (_size == 1);\n            _and_1 = _equals_1;\n          }\n          if (!_and_1) {\n            _and = false;\n          } else {\n            TypeReference _type = field.getType();\n            Iterable<? extends ResolvedParameter> _resolvedParameters_1 = it.getResolvedParameters();\n            ResolvedParameter _head = IterableExtensions.head(_resolvedParameters_1);\n            TypeReference _resolvedType = _head.getResolvedType();\n            boolean _isAssignableFrom = _type.isAssignableFrom(_resolvedType);\n            _and = _isAssignableFrom;\n          }\n          return Boolean.valueOf(_and);\n        }\n      };\n      final ResolvedMethod overriddenSetter = IterableExtensions.findFirst(_allResolvedMethods, _function);\n      boolean _tripleNotEquals = (overriddenSetter != null);\n      if (_tripleNotEquals) {\n        final MethodDeclaration overriddenDeclaration = overriddenSetter.getDeclaration();\n        boolean _isFinal_1 = overriddenDeclaration.isFinal();\n        if (_isFinal_1) {\n          StringConcatenation _builder = new StringConcatenation();\n          _builder.append(\"Cannot override the final method \");\n          String _simpleSignature = overriddenSetter.getSimpleSignature();\n          _builder.append(_simpleSignature, \"\");\n          _builder.append(\" in \");\n          TypeDeclaration _declaringType_1 = overriddenDeclaration.getDeclaringType();\n          String _simpleName = _declaringType_1.getSimpleName();\n          _builder.append(_simpleName, \"\");\n          this.context.addError(field, _builder.toString());\n        }\n        TypeReference _resolvedReturnType = overriddenSetter.getResolvedReturnType();\n        boolean _isVoid = _resolvedReturnType.isVoid();\n        boolean _not = (!_isVoid);\n        if (_not) {\n          StringConcatenation _builder_1 = new StringConcatenation();\n          _builder_1.append(\"Cannot override the method \");\n          String _simpleSignature_1 = overriddenSetter.getSimpleSignature();\n          _builder_1.append(_simpleSignature_1, \"\");\n          _builder_1.append(\" in \");\n          TypeDeclaration _declaringType_2 = overriddenDeclaration.getDeclaringType();\n          String _simpleName_1 = _declaringType_2.getSimpleName();\n          _builder_1.append(_simpleName_1, \"\");\n          _builder_1.append(\", because its return type is not void�\");\n          _builder_1.newLineIfNotEmpty();\n          this.context.addError(field, _builder_1.toString());\n        }\n      }\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void addGetter(final MutableFieldDeclaration field, final Visibility visibility) {\n      field.markAsRead();\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _getterName = this.getGetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          NamedElement _primarySourceElement = Util.this.context.getPrimarySourceElement(field);\n          Util.this.context.setPrimarySourceElement(it, _primarySourceElement);\n          AnnotationReference _newAnnotationReference = Util.this.context.newAnnotationReference(Pure.class);\n          it.addAnnotation(_newAnnotationReference);\n          TypeReference _type = field.getType();\n          it.setReturnType(_type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              _builder.append(\"return \");\n              Object _fieldOwner = Util.this.fieldOwner(field);\n              _builder.append(_fieldOwner, \"\");\n              _builder.append(\".\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n          boolean _isStatic = field.isStatic();\n          it.setStatic(_isStatic);\n          it.setVisibility(visibility);\n        }\n      };\n      _declaringType.addMethod(_getterName, _function);\n    }","id":22481,"modified_method":"public void addGetter(final MutableFieldDeclaration field, final Visibility visibility) {\n      this.validateGetter(field);\n      field.markAsRead();\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _getterName = this.getGetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          NamedElement _primarySourceElement = Util.this.context.getPrimarySourceElement(field);\n          Util.this.context.setPrimarySourceElement(it, _primarySourceElement);\n          AnnotationReference _newAnnotationReference = Util.this.context.newAnnotationReference(Pure.class);\n          it.addAnnotation(_newAnnotationReference);\n          TypeReference _type = field.getType();\n          it.setReturnType(_type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              _builder.append(\"return \");\n              Object _fieldOwner = Util.this.fieldOwner(field);\n              _builder.append(_fieldOwner, \"\");\n              _builder.append(\".\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n          boolean _isStatic = field.isStatic();\n          it.setStatic(_isStatic);\n          it.setVisibility(visibility);\n        }\n      };\n      _declaringType.addMethod(_getterName, _function);\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean canAddGetter(final MutableFieldDeclaration field) {\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      TypeReference _newSelfTypeReference = this.context.newSelfTypeReference(_declaringType);\n      Iterable<? extends ResolvedMethod> _allResolvedMethods = _newSelfTypeReference.getAllResolvedMethods();\n      final Function1<ResolvedMethod, Boolean> _function = new Function1<ResolvedMethod, Boolean>() {\n        public Boolean apply(final ResolvedMethod it) {\n          boolean _and = false;\n          MethodDeclaration _declaration = it.getDeclaration();\n          String _simpleName = _declaration.getSimpleName();\n          String _getterName = Util.this.getGetterName(field);\n          boolean _equals = Objects.equal(_simpleName, _getterName);\n          if (!_equals) {\n            _and = false;\n          } else {\n            Iterable<? extends ResolvedParameter> _resolvedParameters = it.getResolvedParameters();\n            boolean _isEmpty = IterableExtensions.isEmpty(_resolvedParameters);\n            _and = _isEmpty;\n          }\n          return Boolean.valueOf(_and);\n        }\n      };\n      final ResolvedMethod overriddenGetter = IterableExtensions.findFirst(_allResolvedMethods, _function);\n      boolean _equals = Objects.equal(overriddenGetter, null);\n      if (_equals) {\n        return true;\n      }\n      final MethodDeclaration overriddenDeclaration = overriddenGetter.getDeclaration();\n      boolean _isFinal = overriddenDeclaration.isFinal();\n      if (_isFinal) {\n        StringConcatenation _builder = new StringConcatenation();\n        _builder.append(\"Cannot override the final method \");\n        String _simpleSignature = overriddenGetter.getSimpleSignature();\n        _builder.append(_simpleSignature, \"\");\n        _builder.append(\" in \");\n        TypeDeclaration _declaringType_1 = overriddenDeclaration.getDeclaringType();\n        String _simpleName = _declaringType_1.getSimpleName();\n        _builder.append(_simpleName, \"\");\n        this.context.addError(field, _builder.toString());\n        return false;\n      }\n      TypeReference _resolvedReturnType = overriddenGetter.getResolvedReturnType();\n      TypeReference _type = field.getType();\n      boolean _isAssignableFrom = _resolvedReturnType.isAssignableFrom(_type);\n      boolean _not = (!_isAssignableFrom);\n      if (_not) {\n        StringConcatenation _builder_1 = new StringConcatenation();\n        _builder_1.append(\"Cannot override the method \");\n        String _simpleSignature_1 = overriddenGetter.getSimpleSignature();\n        _builder_1.append(_simpleSignature_1, \"\");\n        _builder_1.append(\" in \");\n        TypeDeclaration _declaringType_2 = overriddenDeclaration.getDeclaringType();\n        String _simpleName_1 = _declaringType_2.getSimpleName();\n        _builder_1.append(_simpleName_1, \"\");\n        _builder_1.append(\", \");\n        _builder_1.newLineIfNotEmpty();\n        _builder_1.append(\"because its return type is incompatible with \");\n        TypeReference _type_1 = field.getType();\n        String _simpleName_2 = _type_1.getSimpleName();\n        _builder_1.append(_simpleName_2, \"\");\n        _builder_1.newLineIfNotEmpty();\n        this.context.addError(field, _builder_1.toString());\n        return false;\n      }\n      return true;\n    }","id":22482,"modified_method":"public void validateGetter(final MutableFieldDeclaration field) {\n      TypeReference _type = field.getType();\n      boolean _isInferred = _type.isInferred();\n      if (_isInferred) {\n        return;\n      }\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      TypeReference _newSelfTypeReference = this.context.newSelfTypeReference(_declaringType);\n      Iterable<? extends ResolvedMethod> _allResolvedMethods = _newSelfTypeReference.getAllResolvedMethods();\n      final Function1<ResolvedMethod, Boolean> _function = new Function1<ResolvedMethod, Boolean>() {\n        public Boolean apply(final ResolvedMethod it) {\n          boolean _and = false;\n          MethodDeclaration _declaration = it.getDeclaration();\n          String _simpleName = _declaration.getSimpleName();\n          String _getterName = Util.this.getGetterName(field);\n          boolean _equals = Objects.equal(_simpleName, _getterName);\n          if (!_equals) {\n            _and = false;\n          } else {\n            Iterable<? extends ResolvedParameter> _resolvedParameters = it.getResolvedParameters();\n            boolean _isEmpty = IterableExtensions.isEmpty(_resolvedParameters);\n            _and = _isEmpty;\n          }\n          return Boolean.valueOf(_and);\n        }\n      };\n      final ResolvedMethod overriddenGetter = IterableExtensions.findFirst(_allResolvedMethods, _function);\n      boolean _tripleNotEquals = (overriddenGetter != null);\n      if (_tripleNotEquals) {\n        final MethodDeclaration overriddenDeclaration = overriddenGetter.getDeclaration();\n        boolean _isFinal = overriddenDeclaration.isFinal();\n        if (_isFinal) {\n          StringConcatenation _builder = new StringConcatenation();\n          _builder.append(\"Cannot override the final method \");\n          String _simpleSignature = overriddenGetter.getSimpleSignature();\n          _builder.append(_simpleSignature, \"\");\n          _builder.append(\" in \");\n          TypeDeclaration _declaringType_1 = overriddenDeclaration.getDeclaringType();\n          String _simpleName = _declaringType_1.getSimpleName();\n          _builder.append(_simpleName, \"\");\n          this.context.addError(field, _builder.toString());\n        }\n        TypeReference _resolvedReturnType = overriddenGetter.getResolvedReturnType();\n        TypeReference _type_1 = field.getType();\n        boolean _isAssignableFrom = _resolvedReturnType.isAssignableFrom(_type_1);\n        boolean _not = (!_isAssignableFrom);\n        if (_not) {\n          StringConcatenation _builder_1 = new StringConcatenation();\n          _builder_1.append(\"Cannot override the method \");\n          String _simpleSignature_1 = overriddenGetter.getSimpleSignature();\n          _builder_1.append(_simpleSignature_1, \"\");\n          _builder_1.append(\" in \");\n          TypeDeclaration _declaringType_2 = overriddenDeclaration.getDeclaringType();\n          String _simpleName_1 = _declaringType_2.getSimpleName();\n          _builder_1.append(_simpleName_1, \"\");\n          _builder_1.append(\", \");\n          _builder_1.newLineIfNotEmpty();\n          _builder_1.append(\"because its return type is incompatible with \");\n          TypeReference _type_2 = field.getType();\n          String _simpleName_2 = _type_2.getSimpleName();\n          _builder_1.append(_simpleName_2, \"\");\n          _builder_1.newLineIfNotEmpty();\n          this.context.addError(field, _builder_1.toString());\n        }\n      }\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void addSetter(final MutableFieldDeclaration field, final Visibility visibility) {\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _setterName = this.getSetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          NamedElement _primarySourceElement = Util.this.context.getPrimarySourceElement(field);\n          Util.this.context.setPrimarySourceElement(it, _primarySourceElement);\n          TypeReference _primitiveVoid = Util.this.context.getPrimitiveVoid();\n          it.setReturnType(_primitiveVoid);\n          String _simpleName = field.getSimpleName();\n          TypeReference _type = field.getType();\n          final MutableParameterDeclaration param = it.addParameter(_simpleName, _type);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              Object _fieldOwner = Util.this.fieldOwner(field);\n              _builder.append(_fieldOwner, \"\");\n              _builder.append(\".\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\" = \");\n              String _simpleName_1 = param.getSimpleName();\n              _builder.append(_simpleName_1, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n          boolean _isStatic = field.isStatic();\n          it.setStatic(_isStatic);\n          it.setVisibility(visibility);\n        }\n      };\n      _declaringType.addMethod(_setterName, _function);\n    }","id":22483,"modified_method":"public void addSetter(final MutableFieldDeclaration field, final Visibility visibility) {\n      this.validateSetter(field);\n      MutableTypeDeclaration _declaringType = field.getDeclaringType();\n      String _setterName = this.getSetterName(field);\n      final Procedure1<MutableMethodDeclaration> _function = new Procedure1<MutableMethodDeclaration>() {\n        public void apply(final MutableMethodDeclaration it) {\n          NamedElement _primarySourceElement = Util.this.context.getPrimarySourceElement(field);\n          Util.this.context.setPrimarySourceElement(it, _primarySourceElement);\n          TypeReference _primitiveVoid = Util.this.context.getPrimitiveVoid();\n          it.setReturnType(_primitiveVoid);\n          String _simpleName = field.getSimpleName();\n          TypeReference _xifexpression = null;\n          TypeReference _type = field.getType();\n          boolean _isInferred = _type.isInferred();\n          if (_isInferred) {\n            _xifexpression = Util.this.context.getObject();\n          } else {\n            _xifexpression = field.getType();\n          }\n          final MutableParameterDeclaration param = it.addParameter(_simpleName, _xifexpression);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              Object _fieldOwner = Util.this.fieldOwner(field);\n              _builder.append(_fieldOwner, \"\");\n              _builder.append(\".\");\n              String _simpleName = field.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\" = \");\n              String _simpleName_1 = param.getSimpleName();\n              _builder.append(_simpleName_1, \"\");\n              _builder.append(\";\");\n            }\n          };\n          it.setBody(_client);\n          boolean _isStatic = field.isStatic();\n          it.setStatic(_isStatic);\n          it.setVisibility(visibility);\n        }\n      };\n      _declaringType.addMethod(_setterName, _function);\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _transform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final AccessorsProcessor.Util util = new AccessorsProcessor.Util(context);\n    boolean _and = false;\n    boolean _shouldAddGetter = util.shouldAddGetter(it);\n    if (!_shouldAddGetter) {\n      _and = false;\n    } else {\n      boolean _canAddGetter = util.canAddGetter(it);\n      _and = _canAddGetter;\n    }\n    if (_and) {\n      AccessorType _getterType = util.getGetterType(it);\n      Visibility _visibility = util.toVisibility(_getterType);\n      util.addGetter(it, _visibility);\n    }\n    boolean _and_1 = false;\n    boolean _shouldAddSetter = util.shouldAddSetter(it);\n    if (!_shouldAddSetter) {\n      _and_1 = false;\n    } else {\n      boolean _canAddSetter = util.canAddSetter(it);\n      _and_1 = _canAddSetter;\n    }\n    if (_and_1) {\n      AccessorType _setterType = util.getSetterType(it);\n      Visibility _visibility_1 = util.toVisibility(_setterType);\n      util.addSetter(it, _visibility_1);\n    }\n  }","id":22484,"modified_method":"protected void _transform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final AccessorsProcessor.Util util = new AccessorsProcessor.Util(context);\n    boolean _shouldAddGetter = util.shouldAddGetter(it);\n    if (_shouldAddGetter) {\n      AccessorType _getterType = util.getGetterType(it);\n      Visibility _visibility = util.toVisibility(_getterType);\n      util.addGetter(it, _visibility);\n    }\n    boolean _shouldAddSetter = util.shouldAddSetter(it);\n    if (_shouldAddSetter) {\n      AccessorType _setterType = util.getSetterType(it);\n      Visibility _visibility_1 = util.toVisibility(_setterType);\n      util.addSetter(it, _visibility_1);\n    }\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _transform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    Type _findTypeGlobally = context.findTypeGlobally(Data.class);\n    AnnotationReference _findAnnotation = it.findAnnotation(_findTypeGlobally);\n    boolean _tripleNotEquals = (_findAnnotation != null);\n    if (_tripleNotEquals) {\n      return;\n    }\n    @Extension\n    final FinalFieldsConstructorProcessor.Util requiredArgsUtil = new FinalFieldsConstructorProcessor.Util(context);\n    boolean _and = false;\n    boolean _hasUserDefinedConstructor = requiredArgsUtil.hasUserDefinedConstructor(it);\n    boolean _not = (!_hasUserDefinedConstructor);\n    if (!_not) {\n      _and = false;\n    } else {\n      boolean _hasFinalFieldsConstructor = requiredArgsUtil.hasFinalFieldsConstructor(it);\n      boolean _not_1 = (!_hasFinalFieldsConstructor);\n      _and = _not_1;\n    }\n    if (_and) {\n      requiredArgsUtil.addFinalFieldsConstructor(it);\n    }\n    Iterable<? extends MutableFieldDeclaration> _declaredFields = it.getDeclaredFields();\n    final Function1<MutableFieldDeclaration, Boolean> _function = new Function1<MutableFieldDeclaration, Boolean>() {\n      public Boolean apply(final MutableFieldDeclaration it) {\n        boolean _and = false;\n        boolean _isStatic = it.isStatic();\n        boolean _not = (!_isStatic);\n        if (!_not) {\n          _and = false;\n        } else {\n          boolean _isThePrimaryGeneratedJavaElement = context.isThePrimaryGeneratedJavaElement(it);\n          _and = _isThePrimaryGeneratedJavaElement;\n        }\n        return Boolean.valueOf(_and);\n      }\n    };\n    Iterable<? extends MutableFieldDeclaration> _filter = IterableExtensions.filter(_declaredFields, _function);\n    final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        AccessorsProcessor.this._transform(it, context);\n      }\n    };\n    IterableExtensions.forEach(_filter, _function_1);\n  }","id":22485,"modified_method":"protected void _transform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    Type _findTypeGlobally = context.findTypeGlobally(Data.class);\n    AnnotationReference _findAnnotation = it.findAnnotation(_findTypeGlobally);\n    boolean _tripleNotEquals = (_findAnnotation != null);\n    if (_tripleNotEquals) {\n      return;\n    }\n    @Extension\n    final FinalFieldsConstructorProcessor.Util requiredArgsUtil = new FinalFieldsConstructorProcessor.Util(context);\n    boolean _needsFinalFieldConstructor = requiredArgsUtil.needsFinalFieldConstructor(it);\n    if (_needsFinalFieldConstructor) {\n      requiredArgsUtil.addFinalFieldsConstructor(it);\n    }\n    Iterable<? extends MutableFieldDeclaration> _declaredFields = it.getDeclaredFields();\n    final Function1<MutableFieldDeclaration, Boolean> _function = new Function1<MutableFieldDeclaration, Boolean>() {\n      public Boolean apply(final MutableFieldDeclaration it) {\n        boolean _and = false;\n        boolean _isStatic = it.isStatic();\n        boolean _not = (!_isStatic);\n        if (!_not) {\n          _and = false;\n        } else {\n          boolean _isThePrimaryGeneratedJavaElement = context.isThePrimaryGeneratedJavaElement(it);\n          _and = _isThePrimaryGeneratedJavaElement;\n        }\n        return Boolean.valueOf(_and);\n      }\n    };\n    Iterable<? extends MutableFieldDeclaration> _filter = IterableExtensions.filter(_declaredFields, _function);\n    final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        AccessorsProcessor.this._transform(it, context);\n      }\n    };\n    IterableExtensions.forEach(_filter, _function_1);\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void doTransform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final DataProcessor.Util util = new DataProcessor.Util(context);\n    @Extension\n    final AccessorsProcessor.Util getterUtil = new AccessorsProcessor.Util(context);\n    @Extension\n    final EqualsHashCodeProcessor.Util ehUtil = new EqualsHashCodeProcessor.Util(context);\n    @Extension\n    final ToStringProcessor.Util toStringUtil = new ToStringProcessor.Util(context);\n    @Extension\n    final FinalFieldsConstructorProcessor.Util requiredArgsUtil = new FinalFieldsConstructorProcessor.Util(context);\n    Iterable<? extends MutableFieldDeclaration> _dataFields = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        it.setFinal(true);\n      }\n    };\n    IterableExtensions.forEach(_dataFields, _function);\n    boolean _and = false;\n    boolean _hasUserDefinedConstructor = requiredArgsUtil.hasUserDefinedConstructor(it);\n    boolean _not = (!_hasUserDefinedConstructor);\n    if (!_not) {\n      _and = false;\n    } else {\n      boolean _hasFinalFieldsConstructor = requiredArgsUtil.hasFinalFieldsConstructor(it);\n      boolean _not_1 = (!_hasFinalFieldsConstructor);\n      _and = _not_1;\n    }\n    if (_and) {\n      requiredArgsUtil.addFinalFieldsConstructor(it);\n    }\n    boolean _hasHashCode = ehUtil.hasHashCode(it);\n    boolean _not_2 = (!_hasHashCode);\n    if (_not_2) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_1 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals = (_superConstructor != null);\n      ehUtil.addHashCode(it, _dataFields_1, _tripleNotEquals);\n    }\n    boolean _hasEquals = ehUtil.hasEquals(it);\n    boolean _not_3 = (!_hasEquals);\n    if (_not_3) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_2 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor_1 = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals_1 = (_superConstructor_1 != null);\n      ehUtil.addEquals(it, _dataFields_2, _tripleNotEquals_1);\n    }\n    boolean _hasToString = toStringUtil.hasToString(it);\n    boolean _not_4 = (!_hasToString);\n    if (_not_4) {\n      util.addDataToString(it);\n    }\n    Iterable<? extends MutableFieldDeclaration> _dataFields_3 = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        boolean _and = false;\n        boolean _shouldAddGetter = getterUtil.shouldAddGetter(it);\n        if (!_shouldAddGetter) {\n          _and = false;\n        } else {\n          boolean _canAddGetter = getterUtil.canAddGetter(it);\n          _and = _canAddGetter;\n        }\n        if (_and) {\n          getterUtil.addGetter(it, Visibility.PUBLIC);\n        }\n        String _simpleName = it.getSimpleName();\n        String _firstLower = StringExtensions.toFirstLower(_simpleName);\n        String _plus = (\"_\" + _firstLower);\n        it.setSimpleName(_plus);\n      }\n    };\n    IterableExtensions.forEach(_dataFields_3, _function_1);\n  }","id":22486,"modified_method":"public void doTransform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final DataProcessor.Util util = new DataProcessor.Util(context);\n    @Extension\n    final AccessorsProcessor.Util getterUtil = new AccessorsProcessor.Util(context);\n    @Extension\n    final EqualsHashCodeProcessor.Util ehUtil = new EqualsHashCodeProcessor.Util(context);\n    @Extension\n    final ToStringProcessor.Util toStringUtil = new ToStringProcessor.Util(context);\n    @Extension\n    final FinalFieldsConstructorProcessor.Util requiredArgsUtil = new FinalFieldsConstructorProcessor.Util(context);\n    Iterable<? extends MutableFieldDeclaration> _dataFields = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        it.setFinal(true);\n      }\n    };\n    IterableExtensions.forEach(_dataFields, _function);\n    boolean _needsFinalFieldConstructor = requiredArgsUtil.needsFinalFieldConstructor(it);\n    if (_needsFinalFieldConstructor) {\n      requiredArgsUtil.addFinalFieldsConstructor(it);\n    }\n    boolean _hasHashCode = ehUtil.hasHashCode(it);\n    boolean _not = (!_hasHashCode);\n    if (_not) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_1 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals = (_superConstructor != null);\n      ehUtil.addHashCode(it, _dataFields_1, _tripleNotEquals);\n    }\n    boolean _hasEquals = ehUtil.hasEquals(it);\n    boolean _not_1 = (!_hasEquals);\n    if (_not_1) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_2 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor_1 = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals_1 = (_superConstructor_1 != null);\n      ehUtil.addEquals(it, _dataFields_2, _tripleNotEquals_1);\n    }\n    boolean _hasToString = toStringUtil.hasToString(it);\n    boolean _not_2 = (!_hasToString);\n    if (_not_2) {\n      util.addDataToString(it);\n    }\n    Iterable<? extends MutableFieldDeclaration> _dataFields_3 = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        boolean _shouldAddGetter = getterUtil.shouldAddGetter(it);\n        if (_shouldAddGetter) {\n          getterUtil.addGetter(it, Visibility.PUBLIC);\n        }\n        String _simpleName = it.getSimpleName();\n        String _firstLower = StringExtensions.toFirstLower(_simpleName);\n        String _plus = (\"_\" + _firstLower);\n        it.setSimpleName(_plus);\n      }\n    };\n    IterableExtensions.forEach(_dataFields_3, _function_1);\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void doTransform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final DataProcessor.Util util = new DataProcessor.Util(context);\n    @Extension\n    final AccessorsProcessor.Util getterUtil = new AccessorsProcessor.Util(context);\n    @Extension\n    final EqualsHashCodeProcessor.Util ehUtil = new EqualsHashCodeProcessor.Util(context);\n    @Extension\n    final ToStringProcessor.Util toStringUtil = new ToStringProcessor.Util(context);\n    @Extension\n    final FinalFieldsConstructorProcessor.Util requiredArgsUtil = new FinalFieldsConstructorProcessor.Util(context);\n    Iterable<? extends MutableFieldDeclaration> _dataFields = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        it.setFinal(true);\n      }\n    };\n    IterableExtensions.forEach(_dataFields, _function);\n    boolean _and = false;\n    boolean _hasUserDefinedConstructor = requiredArgsUtil.hasUserDefinedConstructor(it);\n    boolean _not = (!_hasUserDefinedConstructor);\n    if (!_not) {\n      _and = false;\n    } else {\n      boolean _hasFinalFieldsConstructor = requiredArgsUtil.hasFinalFieldsConstructor(it);\n      boolean _not_1 = (!_hasFinalFieldsConstructor);\n      _and = _not_1;\n    }\n    if (_and) {\n      requiredArgsUtil.addFinalFieldsConstructor(it);\n    }\n    boolean _hasHashCode = ehUtil.hasHashCode(it);\n    boolean _not_2 = (!_hasHashCode);\n    if (_not_2) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_1 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals = (_superConstructor != null);\n      ehUtil.addHashCode(it, _dataFields_1, _tripleNotEquals);\n    }\n    boolean _hasEquals = ehUtil.hasEquals(it);\n    boolean _not_3 = (!_hasEquals);\n    if (_not_3) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_2 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor_1 = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals_1 = (_superConstructor_1 != null);\n      ehUtil.addEquals(it, _dataFields_2, _tripleNotEquals_1);\n    }\n    boolean _hasToString = toStringUtil.hasToString(it);\n    boolean _not_4 = (!_hasToString);\n    if (_not_4) {\n      ResolvedConstructor _superConstructor_2 = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleEquals = (_superConstructor_2 == null);\n      if (_tripleEquals) {\n        Iterable<? extends MutableFieldDeclaration> _dataFields_3 = util.getDataFields(it);\n        ToStringConfiguration _elvis = null;\n        ToStringConfiguration _toStringConfig = toStringUtil.getToStringConfig(it);\n        if (_toStringConfig != null) {\n          _elvis = _toStringConfig;\n        } else {\n          ToStringConfiguration _toStringConfiguration = new ToStringConfiguration();\n          _elvis = _toStringConfiguration;\n        }\n        toStringUtil.addToString(it, _dataFields_3, _elvis);\n      } else {\n        ToStringConfiguration _elvis_1 = null;\n        ToStringConfiguration _toStringConfig_1 = toStringUtil.getToStringConfig(it);\n        if (_toStringConfig_1 != null) {\n          _elvis_1 = _toStringConfig_1;\n        } else {\n          ToStringConfiguration _toStringConfiguration_1 = new ToStringConfiguration();\n          _elvis_1 = _toStringConfiguration_1;\n        }\n        toStringUtil.addReflectiveToString(it, _elvis_1);\n      }\n    }\n    Iterable<? extends MutableFieldDeclaration> _dataFields_4 = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        boolean _and = false;\n        boolean _shouldAddGetter = getterUtil.shouldAddGetter(it);\n        if (!_shouldAddGetter) {\n          _and = false;\n        } else {\n          boolean _canAddGetter = getterUtil.canAddGetter(it);\n          _and = _canAddGetter;\n        }\n        if (_and) {\n          Visibility _elvis = null;\n          AccessorType _getterType = getterUtil.getGetterType(it);\n          Visibility _visibility = null;\n          if (_getterType!=null) {\n            _visibility=getterUtil.toVisibility(_getterType);\n          }\n          if (_visibility != null) {\n            _elvis = _visibility;\n          } else {\n            _elvis = Visibility.PUBLIC;\n          }\n          getterUtil.addGetter(it, _elvis);\n        }\n      }\n    };\n    IterableExtensions.forEach(_dataFields_4, _function_1);\n  }","id":22487,"modified_method":"public void doTransform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final DataProcessor.Util util = new DataProcessor.Util(context);\n    @Extension\n    final AccessorsProcessor.Util getterUtil = new AccessorsProcessor.Util(context);\n    @Extension\n    final EqualsHashCodeProcessor.Util ehUtil = new EqualsHashCodeProcessor.Util(context);\n    @Extension\n    final ToStringProcessor.Util toStringUtil = new ToStringProcessor.Util(context);\n    @Extension\n    final FinalFieldsConstructorProcessor.Util requiredArgsUtil = new FinalFieldsConstructorProcessor.Util(context);\n    Iterable<? extends MutableFieldDeclaration> _dataFields = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        it.setFinal(true);\n      }\n    };\n    IterableExtensions.forEach(_dataFields, _function);\n    boolean _needsFinalFieldConstructor = requiredArgsUtil.needsFinalFieldConstructor(it);\n    if (_needsFinalFieldConstructor) {\n      requiredArgsUtil.addFinalFieldsConstructor(it);\n    }\n    boolean _hasHashCode = ehUtil.hasHashCode(it);\n    boolean _not = (!_hasHashCode);\n    if (_not) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_1 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals = (_superConstructor != null);\n      ehUtil.addHashCode(it, _dataFields_1, _tripleNotEquals);\n    }\n    boolean _hasEquals = ehUtil.hasEquals(it);\n    boolean _not_1 = (!_hasEquals);\n    if (_not_1) {\n      Iterable<? extends MutableFieldDeclaration> _dataFields_2 = util.getDataFields(it);\n      ResolvedConstructor _superConstructor_1 = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleNotEquals_1 = (_superConstructor_1 != null);\n      ehUtil.addEquals(it, _dataFields_2, _tripleNotEquals_1);\n    }\n    boolean _hasToString = toStringUtil.hasToString(it);\n    boolean _not_2 = (!_hasToString);\n    if (_not_2) {\n      ResolvedConstructor _superConstructor_2 = requiredArgsUtil.getSuperConstructor(it);\n      boolean _tripleEquals = (_superConstructor_2 == null);\n      if (_tripleEquals) {\n        Iterable<? extends MutableFieldDeclaration> _dataFields_3 = util.getDataFields(it);\n        ToStringConfiguration _elvis = null;\n        ToStringConfiguration _toStringConfig = toStringUtil.getToStringConfig(it);\n        if (_toStringConfig != null) {\n          _elvis = _toStringConfig;\n        } else {\n          ToStringConfiguration _toStringConfiguration = new ToStringConfiguration();\n          _elvis = _toStringConfiguration;\n        }\n        toStringUtil.addToString(it, _dataFields_3, _elvis);\n      } else {\n        ToStringConfiguration _elvis_1 = null;\n        ToStringConfiguration _toStringConfig_1 = toStringUtil.getToStringConfig(it);\n        if (_toStringConfig_1 != null) {\n          _elvis_1 = _toStringConfig_1;\n        } else {\n          ToStringConfiguration _toStringConfiguration_1 = new ToStringConfiguration();\n          _elvis_1 = _toStringConfiguration_1;\n        }\n        toStringUtil.addReflectiveToString(it, _elvis_1);\n      }\n    }\n    Iterable<? extends MutableFieldDeclaration> _dataFields_4 = util.getDataFields(it);\n    final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n      public void apply(final MutableFieldDeclaration it) {\n        boolean _shouldAddGetter = getterUtil.shouldAddGetter(it);\n        if (_shouldAddGetter) {\n          Visibility _elvis = null;\n          AccessorType _getterType = getterUtil.getGetterType(it);\n          Visibility _visibility = null;\n          if (_getterType!=null) {\n            _visibility=getterUtil.toVisibility(_getterType);\n          }\n          if (_visibility != null) {\n            _elvis = _visibility;\n          } else {\n            _elvis = Visibility.PUBLIC;\n          }\n          getterUtil.addGetter(it, _elvis);\n        }\n      }\n    };\n    IterableExtensions.forEach(_dataFields_4, _function_1);\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testDuplicate2() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor\");\n      _builder.newLine();\n      _builder.append(\"class C {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"val int a\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@FinalFieldsConstructor new() {}\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@FinalFieldsConstructor new() {}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String source = _builder.toString();\n      XtendClass _clazz = this.clazz(source);\n      this._validationTestHelper.assertError(_clazz, XtendPackage.Literals.XTEND_CONSTRUCTOR, \"user.issue\", \"FinalFieldsConstructor\", \"already defined\");\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":22488,"modified_method":"@Test\n  public void testDuplicate2() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor\");\n      _builder.newLine();\n      _builder.append(\"class C {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"val int a\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@FinalFieldsConstructor new() {}\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@FinalFieldsConstructor new() {}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String source = _builder.toString();\n      XtendClass _clazz = this.clazz(source);\n      this._validationTestHelper.assertError(_clazz, XtendPackage.Literals.XTEND_CONSTRUCTOR, \"user.issue\", \"FinalFieldsConstructor\", \"new(int)\", \"already exists\");\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testDuplicate() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor\");\n      _builder.newLine();\n      _builder.append(\"@FinalFieldsConstructor\");\n      _builder.newLine();\n      _builder.append(\"class C {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"val int a\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@FinalFieldsConstructor new() {}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String source = _builder.toString();\n      XtendClass _clazz = this.clazz(source);\n      this._validationTestHelper.assertError(_clazz, XtendPackage.Literals.XTEND_CONSTRUCTOR, \"user.issue\", \"FinalFieldsConstructor\", \"already defined\");\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":22489,"modified_method":"@Test\n  public void testDuplicate() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor\");\n      _builder.newLine();\n      _builder.append(\"@FinalFieldsConstructor\");\n      _builder.newLine();\n      _builder.append(\"class C {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"val int a\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"@FinalFieldsConstructor new() {}\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      final String source = _builder.toString();\n      XtendClass _clazz = this.clazz(source);\n      this._validationTestHelper.assertError(_clazz, XtendPackage.Literals.XTEND_CONSTRUCTOR, \"user.issue\", \"FinalFieldsConstructor\", \"new(int)\", \"already exists\");\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public MutableConstructorDeclaration makeFinalFieldsConstructor(final MutableConstructorDeclaration ctor) {\n      final Procedure1<MutableConstructorDeclaration> _function = new Procedure1<MutableConstructorDeclaration>() {\n        public void apply(final MutableConstructorDeclaration it) {\n          Iterable<? extends ResolvedParameter> _elvis = null;\n          MutableTypeDeclaration _declaringType = ctor.getDeclaringType();\n          ResolvedConstructor _superConstructor = Util.this.getSuperConstructor(_declaringType);\n          Iterable<? extends ResolvedParameter> _resolvedParameters = null;\n          if (_superConstructor!=null) {\n            _resolvedParameters=_superConstructor.getResolvedParameters();\n          }\n          if (_resolvedParameters != null) {\n            _elvis = _resolvedParameters;\n          } else {\n            _elvis = Collections.<ResolvedParameter>unmodifiableList(CollectionLiterals.<ResolvedParameter>newArrayList());\n          }\n          final Iterable<? extends ResolvedParameter> superParameters = _elvis;\n          final Procedure1<ResolvedParameter> _function = new Procedure1<ResolvedParameter>() {\n            public void apply(final ResolvedParameter p) {\n              ParameterDeclaration _declaration = p.getDeclaration();\n              String _simpleName = _declaration.getSimpleName();\n              TypeReference _resolvedType = p.getResolvedType();\n              it.addParameter(_simpleName, _resolvedType);\n            }\n          };\n          IterableExtensions.forEach(superParameters, _function);\n          final HashMap<MutableFieldDeclaration, MutableParameterDeclaration> fieldToParameter = CollectionLiterals.<MutableFieldDeclaration, MutableParameterDeclaration>newHashMap();\n          MutableTypeDeclaration _declaringType_1 = it.getDeclaringType();\n          Iterable<? extends MutableFieldDeclaration> _finalFields = Util.this.getFinalFields(_declaringType_1);\n          final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n            public void apply(final MutableFieldDeclaration p) {\n              p.markAsInitializedBy(ctor);\n              String _simpleName = p.getSimpleName();\n              TypeReference _type = p.getType();\n              final MutableParameterDeclaration param = it.addParameter(_simpleName, _type);\n              fieldToParameter.put(p, param);\n            }\n          };\n          IterableExtensions.forEach(_finalFields, _function_1);\n          StringConcatenationClient _client = new StringConcatenationClient() {\n            @Override\n            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n              _builder.append(\"super(\");\n              final Function1<ResolvedParameter, String> _function = new Function1<ResolvedParameter, String>() {\n                public String apply(final ResolvedParameter it) {\n                  ParameterDeclaration _declaration = it.getDeclaration();\n                  return _declaration.getSimpleName();\n                }\n              };\n              String _join = IterableExtensions.join(superParameters, \", \", _function);\n              _builder.append(_join, \"\");\n              _builder.append(\");\");\n              _builder.newLineIfNotEmpty();\n              {\n                MutableTypeDeclaration _declaringType = it.getDeclaringType();\n                Iterable<? extends MutableFieldDeclaration> _finalFields = Util.this.getFinalFields(_declaringType);\n                for(final MutableFieldDeclaration arg : _finalFields) {\n                  _builder.append(\"this.\");\n                  String _simpleName = arg.getSimpleName();\n                  _builder.append(_simpleName, \"\");\n                  _builder.append(\" = \");\n                  MutableParameterDeclaration _get = fieldToParameter.get(arg);\n                  String _simpleName_1 = _get.getSimpleName();\n                  _builder.append(_simpleName_1, \"\");\n                  _builder.append(\";\");\n                  _builder.newLineIfNotEmpty();\n                }\n              }\n            }\n          };\n          it.setBody(_client);\n        }\n      };\n      return ObjectExtensions.<MutableConstructorDeclaration>operator_doubleArrow(ctor, _function);\n    }","id":22490,"modified_method":"public void makeFinalFieldsConstructor(final MutableConstructorDeclaration it) {\n      MutableTypeDeclaration _declaringType = it.getDeclaringType();\n      boolean _hasFinalFieldsConstructor = this.hasFinalFieldsConstructor(_declaringType);\n      if (_hasFinalFieldsConstructor) {\n        MutableTypeDeclaration _declaringType_1 = it.getDeclaringType();\n        String _constructorAlreadyExistsMessage = this.getConstructorAlreadyExistsMessage(_declaringType_1);\n        this.context.addError(it, _constructorAlreadyExistsMessage);\n        return;\n      }\n      Iterable<? extends MutableParameterDeclaration> _parameters = it.getParameters();\n      boolean _isEmpty = IterableExtensions.isEmpty(_parameters);\n      boolean _not = (!_isEmpty);\n      if (_not) {\n        this.context.addError(it, \"Parameter list must be empty\");\n      }\n      boolean _and = false;\n      Expression _body = it.getBody();\n      boolean _tripleNotEquals = (_body != null);\n      if (!_tripleNotEquals) {\n        _and = false;\n      } else {\n        Expression _body_1 = it.getBody();\n        String _string = _body_1.toString();\n        Matcher _matcher = FinalFieldsConstructorProcessor.Util.EMPTY_BODY.matcher(_string);\n        boolean _matches = _matcher.matches();\n        boolean _not_1 = (!_matches);\n        _and = _not_1;\n      }\n      if (_and) {\n        this.context.addError(it, \"Body must be empty\");\n      }\n      Iterable<? extends ResolvedParameter> _elvis = null;\n      MutableTypeDeclaration _declaringType_2 = it.getDeclaringType();\n      ResolvedConstructor _superConstructor = this.getSuperConstructor(_declaringType_2);\n      Iterable<? extends ResolvedParameter> _resolvedParameters = null;\n      if (_superConstructor!=null) {\n        _resolvedParameters=_superConstructor.getResolvedParameters();\n      }\n      if (_resolvedParameters != null) {\n        _elvis = _resolvedParameters;\n      } else {\n        _elvis = Collections.<ResolvedParameter>unmodifiableList(CollectionLiterals.<ResolvedParameter>newArrayList());\n      }\n      final Iterable<? extends ResolvedParameter> superParameters = _elvis;\n      final Procedure1<ResolvedParameter> _function = new Procedure1<ResolvedParameter>() {\n        public void apply(final ResolvedParameter p) {\n          ParameterDeclaration _declaration = p.getDeclaration();\n          String _simpleName = _declaration.getSimpleName();\n          TypeReference _resolvedType = p.getResolvedType();\n          it.addParameter(_simpleName, _resolvedType);\n        }\n      };\n      IterableExtensions.forEach(superParameters, _function);\n      final HashMap<MutableFieldDeclaration, MutableParameterDeclaration> fieldToParameter = CollectionLiterals.<MutableFieldDeclaration, MutableParameterDeclaration>newHashMap();\n      MutableTypeDeclaration _declaringType_3 = it.getDeclaringType();\n      Iterable<? extends MutableFieldDeclaration> _finalFields = this.getFinalFields(_declaringType_3);\n      final Procedure1<MutableFieldDeclaration> _function_1 = new Procedure1<MutableFieldDeclaration>() {\n        public void apply(final MutableFieldDeclaration p) {\n          p.markAsInitializedBy(it);\n          String _simpleName = p.getSimpleName();\n          TypeReference _type = p.getType();\n          final MutableParameterDeclaration param = it.addParameter(_simpleName, _type);\n          fieldToParameter.put(p, param);\n        }\n      };\n      IterableExtensions.forEach(_finalFields, _function_1);\n      StringConcatenationClient _client = new StringConcatenationClient() {\n        @Override\n        protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {\n          _builder.append(\"super(\");\n          final Function1<ResolvedParameter, String> _function = new Function1<ResolvedParameter, String>() {\n            public String apply(final ResolvedParameter it) {\n              ParameterDeclaration _declaration = it.getDeclaration();\n              return _declaration.getSimpleName();\n            }\n          };\n          String _join = IterableExtensions.join(superParameters, \", \", _function);\n          _builder.append(_join, \"\");\n          _builder.append(\");\");\n          _builder.newLineIfNotEmpty();\n          {\n            MutableTypeDeclaration _declaringType = it.getDeclaringType();\n            Iterable<? extends MutableFieldDeclaration> _finalFields = Util.this.getFinalFields(_declaringType);\n            for(final MutableFieldDeclaration arg : _finalFields) {\n              _builder.append(\"this.\");\n              String _simpleName = arg.getSimpleName();\n              _builder.append(_simpleName, \"\");\n              _builder.append(\" = \");\n              MutableParameterDeclaration _get = fieldToParameter.get(arg);\n              String _simpleName_1 = _get.getSimpleName();\n              _builder.append(_simpleName_1, \"\");\n              _builder.append(\";\");\n              _builder.newLineIfNotEmpty();\n            }\n          }\n        }\n      };\n      it.setBody(_client);\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean hasFinalFieldsConstructor(final MutableTypeDeclaration cls) {\n      Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = cls.getDeclaredConstructors();\n      final Function1<MutableConstructorDeclaration, Boolean> _function = new Function1<MutableConstructorDeclaration, Boolean>() {\n        public Boolean apply(final MutableConstructorDeclaration it) {\n          boolean _xblockexpression = false;\n          {\n            final ArrayList<TypeReference> expectedTypes = CollectionLiterals.<TypeReference>newArrayList();\n            ResolvedConstructor _superConstructor = Util.this.getSuperConstructor(cls);\n            boolean _tripleNotEquals = (_superConstructor != null);\n            if (_tripleNotEquals) {\n              ResolvedConstructor _superConstructor_1 = Util.this.getSuperConstructor(cls);\n              Iterable<? extends ResolvedParameter> _resolvedParameters = _superConstructor_1.getResolvedParameters();\n              final Function1<ResolvedParameter, TypeReference> _function = new Function1<ResolvedParameter, TypeReference>() {\n                public TypeReference apply(final ResolvedParameter it) {\n                  return it.getResolvedType();\n                }\n              };\n              Iterable<TypeReference> _map = IterableExtensions.map(_resolvedParameters, _function);\n              Iterables.<TypeReference>addAll(expectedTypes, _map);\n            }\n            Iterable<? extends MutableFieldDeclaration> _finalFields = Util.this.getFinalFields(cls);\n            final Function1<MutableFieldDeclaration, TypeReference> _function_1 = new Function1<MutableFieldDeclaration, TypeReference>() {\n              public TypeReference apply(final MutableFieldDeclaration it) {\n                return it.getType();\n              }\n            };\n            Iterable<TypeReference> _map_1 = IterableExtensions.map(_finalFields, _function_1);\n            Iterables.<TypeReference>addAll(expectedTypes, _map_1);\n            Iterable<? extends MutableParameterDeclaration> _parameters = it.getParameters();\n            final Function1<MutableParameterDeclaration, TypeReference> _function_2 = new Function1<MutableParameterDeclaration, TypeReference>() {\n              public TypeReference apply(final MutableParameterDeclaration it) {\n                return it.getType();\n              }\n            };\n            Iterable<TypeReference> _map_2 = IterableExtensions.map(_parameters, _function_2);\n            List<TypeReference> _list = IterableExtensions.<TypeReference>toList(_map_2);\n            _xblockexpression = Objects.equal(_list, expectedTypes);\n          }\n          return Boolean.valueOf(_xblockexpression);\n        }\n      };\n      return IterableExtensions.exists(_declaredConstructors, _function);\n    }","id":22491,"modified_method":"public boolean hasFinalFieldsConstructor(final MutableTypeDeclaration cls) {\n      boolean _xblockexpression = false;\n      {\n        final ArrayList<TypeReference> expectedTypes = this.getFinalFieldsConstructorArgumentTypes(cls);\n        Iterable<? extends MutableConstructorDeclaration> _declaredConstructors = cls.getDeclaredConstructors();\n        final Function1<MutableConstructorDeclaration, Boolean> _function = new Function1<MutableConstructorDeclaration, Boolean>() {\n          public Boolean apply(final MutableConstructorDeclaration it) {\n            Iterable<? extends MutableParameterDeclaration> _parameters = it.getParameters();\n            final Function1<MutableParameterDeclaration, TypeReference> _function = new Function1<MutableParameterDeclaration, TypeReference>() {\n              public TypeReference apply(final MutableParameterDeclaration it) {\n                return it.getType();\n              }\n            };\n            Iterable<TypeReference> _map = IterableExtensions.map(_parameters, _function);\n            List<TypeReference> _list = IterableExtensions.<TypeReference>toList(_map);\n            return Boolean.valueOf(Objects.equal(_list, expectedTypes));\n          }\n        };\n        _xblockexpression = IterableExtensions.exists(_declaredConstructors, _function);\n      }\n      return _xblockexpression;\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean hasUserDefinedConstructor(final MutableClassDeclaration it) {\n      NamedElement _primarySourceElement = this.context.getPrimarySourceElement(it);\n      Iterable<? extends ConstructorDeclaration> _declaredConstructors = ((ClassDeclaration) _primarySourceElement).getDeclaredConstructors();\n      boolean _isEmpty = IterableExtensions.isEmpty(_declaredConstructors);\n      return (!_isEmpty);\n    }","id":22492,"modified_method":"public boolean needsFinalFieldConstructor(final MutableClassDeclaration it) {\n      boolean _and = false;\n      boolean _hasFinalFieldsConstructor = this.hasFinalFieldsConstructor(it);\n      boolean _not = (!_hasFinalFieldsConstructor);\n      if (!_not) {\n        _and = false;\n      } else {\n        NamedElement _primarySourceElement = this.context.getPrimarySourceElement(it);\n        Iterable<? extends ConstructorDeclaration> _declaredConstructors = ((ClassDeclaration) _primarySourceElement).getDeclaredConstructors();\n        boolean _isEmpty = IterableExtensions.isEmpty(_declaredConstructors);\n        _and = _isEmpty;\n      }\n      return _and;\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public MutableConstructorDeclaration addFinalFieldsConstructor(final MutableClassDeclaration cls) {\n      final Procedure1<MutableConstructorDeclaration> _function = new Procedure1<MutableConstructorDeclaration>() {\n        public void apply(final MutableConstructorDeclaration it) {\n          NamedElement _primarySourceElement = Util.this.context.getPrimarySourceElement(cls);\n          Util.this.context.setPrimarySourceElement(it, _primarySourceElement);\n          Util.this.makeFinalFieldsConstructor(it);\n        }\n      };\n      return cls.addConstructor(_function);\n    }","id":22493,"modified_method":"public void addFinalFieldsConstructor(final MutableClassDeclaration it) {\n      boolean _hasFinalFieldsConstructor = this.hasFinalFieldsConstructor(it);\n      if (_hasFinalFieldsConstructor) {\n        String _constructorAlreadyExistsMessage = this.getConstructorAlreadyExistsMessage(it);\n        this.context.addError(it, _constructorAlreadyExistsMessage);\n        return;\n      }\n      final Procedure1<MutableConstructorDeclaration> _function = new Procedure1<MutableConstructorDeclaration>() {\n        public void apply(final MutableConstructorDeclaration it) {\n          MutableTypeDeclaration _declaringType = it.getDeclaringType();\n          NamedElement _primarySourceElement = Util.this.context.getPrimarySourceElement(_declaringType);\n          Util.this.context.setPrimarySourceElement(it, _primarySourceElement);\n          Util.this.makeFinalFieldsConstructor(it);\n        }\n      };\n      it.addConstructor(_function);\n    }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _transform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    Type _findTypeGlobally = context.findTypeGlobally(Data.class);\n    AnnotationReference _findAnnotation = it.findAnnotation(_findTypeGlobally);\n    boolean _tripleNotEquals = (_findAnnotation != null);\n    if (_tripleNotEquals) {\n      return;\n    }\n    Type _findTypeGlobally_1 = context.findTypeGlobally(Accessors.class);\n    AnnotationReference _findAnnotation_1 = it.findAnnotation(_findTypeGlobally_1);\n    boolean _tripleNotEquals_1 = (_findAnnotation_1 != null);\n    if (_tripleNotEquals_1) {\n      return;\n    }\n    @Extension\n    final FinalFieldsConstructorProcessor.Util util = new FinalFieldsConstructorProcessor.Util(context);\n    boolean _hasFinalFieldsConstructor = util.hasFinalFieldsConstructor(it);\n    if (_hasFinalFieldsConstructor) {\n      context.addError(it, \"A RequiredArgsConstructor is already defined\");\n    }\n    util.addFinalFieldsConstructor(it);\n  }","id":22494,"modified_method":"protected void _transform(final MutableClassDeclaration it, @Extension final TransformationContext context) {\n    Type _findTypeGlobally = context.findTypeGlobally(Data.class);\n    AnnotationReference _findAnnotation = it.findAnnotation(_findTypeGlobally);\n    boolean _tripleNotEquals = (_findAnnotation != null);\n    if (_tripleNotEquals) {\n      return;\n    }\n    Type _findTypeGlobally_1 = context.findTypeGlobally(Accessors.class);\n    AnnotationReference _findAnnotation_1 = it.findAnnotation(_findTypeGlobally_1);\n    boolean _tripleNotEquals_1 = (_findAnnotation_1 != null);\n    if (_tripleNotEquals_1) {\n      return;\n    }\n    @Extension\n    final FinalFieldsConstructorProcessor.Util util = new FinalFieldsConstructorProcessor.Util(context);\n    util.addFinalFieldsConstructor(it);\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _transform(final MutableConstructorDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final FinalFieldsConstructorProcessor.Util util = new FinalFieldsConstructorProcessor.Util(context);\n    Iterable<? extends MutableParameterDeclaration> _parameters = it.getParameters();\n    boolean _isEmpty = IterableExtensions.isEmpty(_parameters);\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      context.addError(it, \"Parameter list must be empty\");\n    }\n    Expression _body = it.getBody();\n    String _string = _body.toString();\n    Matcher _matcher = FinalFieldsConstructorProcessor.EMPTY_BODY.matcher(_string);\n    boolean _matches = _matcher.matches();\n    boolean _not_1 = (!_matches);\n    if (_not_1) {\n      context.addError(it, \"Body must be empty\");\n    }\n    MutableTypeDeclaration _declaringType = it.getDeclaringType();\n    boolean _hasFinalFieldsConstructor = util.hasFinalFieldsConstructor(_declaringType);\n    if (_hasFinalFieldsConstructor) {\n      context.addError(it, \"A FinalFieldsConstructor is already defined\");\n    }\n    util.makeFinalFieldsConstructor(it);\n  }","id":22495,"modified_method":"protected void _transform(final MutableConstructorDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final FinalFieldsConstructorProcessor.Util util = new FinalFieldsConstructorProcessor.Util(context);\n    util.makeFinalFieldsConstructor(it);\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void doTransform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final AccessorsProcessor.Util util = new AccessorsProcessor.Util(context);\n    boolean _and = false;\n    boolean _hasGetter = util.hasGetter(it);\n    boolean _not = (!_hasGetter);\n    if (!_not) {\n      _and = false;\n    } else {\n      boolean _canAddGetter = util.canAddGetter(it);\n      _and = _canAddGetter;\n    }\n    if (_and) {\n      util.addGetter(it, Visibility.PUBLIC);\n    }\n    boolean _and_1 = false;\n    boolean _and_2 = false;\n    boolean _isFinal = it.isFinal();\n    boolean _not_1 = (!_isFinal);\n    if (!_not_1) {\n      _and_2 = false;\n    } else {\n      boolean _hasSetter = util.hasSetter(it);\n      boolean _not_2 = (!_hasSetter);\n      _and_2 = _not_2;\n    }\n    if (!_and_2) {\n      _and_1 = false;\n    } else {\n      boolean _canAddSetter = util.canAddSetter(it);\n      _and_1 = _canAddSetter;\n    }\n    if (_and_1) {\n      util.addSetter(it, Visibility.PUBLIC);\n    }\n    String _simpleName = it.getSimpleName();\n    String _firstLower = StringExtensions.toFirstLower(_simpleName);\n    String _plus = (\"_\" + _firstLower);\n    it.setSimpleName(_plus);\n  }","id":22496,"modified_method":"public void doTransform(final MutableFieldDeclaration it, @Extension final TransformationContext context) {\n    @Extension\n    final AccessorsProcessor.Util util = new AccessorsProcessor.Util(context);\n    boolean _hasGetter = util.hasGetter(it);\n    boolean _not = (!_hasGetter);\n    if (_not) {\n      util.addGetter(it, Visibility.PUBLIC);\n    }\n    boolean _and = false;\n    boolean _isFinal = it.isFinal();\n    boolean _not_1 = (!_isFinal);\n    if (!_not_1) {\n      _and = false;\n    } else {\n      boolean _hasSetter = util.hasSetter(it);\n      boolean _not_2 = (!_hasSetter);\n      _and = _not_2;\n    }\n    if (_and) {\n      util.addSetter(it, Visibility.PUBLIC);\n    }\n    String _simpleName = it.getSimpleName();\n    String _firstLower = StringExtensions.toFirstLower(_simpleName);\n    String _plus = (\"_\" + _firstLower);\n    it.setSimpleName(_plus);\n  }","commit_id":"15ba980d242fbe24ec800f01291a4a7d1f4853f6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void validateConversion()\n\t\tthrows InvalidFileSystemStoreRootDirException {\n\n\t\tString sourceStoreClassName = getSourceStoreClassName();\n\n\t\tif (!sourceStoreClassName.endsWith(_FILE_SYSTEM_STORE_SUFFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString targetStoreClassName = getTargetStoreClassName();\n\n\t\tif (!targetStoreClassName.endsWith(_FILE_SYSTEM_STORE_SUFFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString advancedFileSystemStoreRootDir =\n\t\t\tPropsValues.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR;\n\n\t\tString fileSystemStoreRootDir =\n\t\t\tPropsValues.DL_STORE_FILE_SYSTEM_ROOT_DIR;\n\n\t\tif (Validator.isBlank(advancedFileSystemStoreRootDir) ||\n\t\t\tValidator.isBlank(fileSystemStoreRootDir)) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(\"Either \");\n\t\t\t\tsb.append(PropsKeys.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR);\n\t\t\t\tsb.append(\" or \");\n\t\t\t\tsb.append(PropsKeys.DL_STORE_FILE_SYSTEM_ROOT_DIR);\n\t\t\t\tsb.append(\n\t\t\t\t\t\" is null; set both of them to a valid path and retry.\");\n\n\t\t\t\t_log.warn(sb.toString());\n\t\t\t}\n\n\t\t\tthrow new InvalidFileSystemStoreRootDirException();\n\t\t}\n\n\t\tboolean identicalRootDirs = true;\n\n\t\tif (OSDetector.isWindows()) {\n\t\t\tidenticalRootDirs = StringUtil.equalsIgnoreCase(\n\t\t\t\tadvancedFileSystemStoreRootDir, fileSystemStoreRootDir);\n\t\t}\n\t\telse {\n\t\t\tidenticalRootDirs = advancedFileSystemStoreRootDir.equals(\n\t\t\t\tfileSystemStoreRootDir);\n\t\t}\n\n\t\tif (identicalRootDirs) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(\"Both \");\n\t\t\t\tsb.append(PropsKeys.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR);\n\t\t\t\tsb.append(\" and \");\n\t\t\t\tsb.append(PropsKeys.DL_STORE_FILE_SYSTEM_ROOT_DIR);\n\t\t\t\tsb.append(\" refer to the same path.\");\n\n\t\t\t\t_log.warn(sb.toString());\n\t\t\t}\n\n\t\t\tthrow new InvalidFileSystemStoreRootDirException();\n\t\t}\n\t}","id":22497,"modified_method":"@Override\n\tpublic void validateConversion()\n\t\tthrows InvalidFileSystemStoreRootDirException {\n\n\t\tString sourceStoreClassName = getSourceStoreClassName();\n\n\t\tif (!sourceStoreClassName.endsWith(_FILE_SYSTEM_STORE_SUFFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString targetStoreClassName = getTargetStoreClassName();\n\n\t\tif (!targetStoreClassName.endsWith(_FILE_SYSTEM_STORE_SUFFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Validator.isBlank(\n\t\t\t\tPropsValues.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR)) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Property \\\"\" +\n\t\t\t\t\t\tPropsKeys.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR +\n\t\t\t\t\t\t\t\" is not set\");\n\t\t\t}\n\n\t\t\tthrow new InvalidFileSystemStoreRootDirException();\n\t\t}\n\n\t\tif (Validator.isBlank(PropsValues.DL_STORE_FILE_SYSTEM_ROOT_DIR)) {\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Property \\\"\" +\n\t\t\t\t\t\tPropsKeys.DL_STORE_FILE_SYSTEM_ROOT_DIR +\n\t\t\t\t\t\t\t\" is not set\");\n\t\t\t}\n\n\t\t\tthrow new InvalidFileSystemStoreRootDirException();\n\t\t}\n\n\t\tboolean identicalRootDirNames = true;\n\n\t\tif (OSDetector.isWindows()) {\n\t\t\tidenticalRootDirNames = StringUtil.equalsIgnoreCase(\n\t\t\t\tPropsValues.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR,\n\t\t\t\tPropsValues.DL_STORE_FILE_SYSTEM_ROOT_DIR);\n\t\t}\n\t\telse {\n\t\t\tidenticalRootDirNames =\n\t\t\t\tPropsValues.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR.equals(\n\t\t\t\t\tPropsValues.DL_STORE_FILE_SYSTEM_ROOT_DIR);\n\t\t}\n\n\t\tif (identicalRootDirNames) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(\"Both properties \\\"\");\n\t\t\t\tsb.append(PropsKeys.DL_STORE_ADVANCED_FILE_SYSTEM_ROOT_DIR);\n\t\t\t\tsb.append(\"\\\" and \\\"\");\n\t\t\t\tsb.append(PropsKeys.DL_STORE_FILE_SYSTEM_ROOT_DIR);\n\t\t\t\tsb.append(\"\\\" have the same value\");\n\n\t\t\t\t_log.warn(sb.toString());\n\t\t\t}\n\n\t\t\tthrow new InvalidFileSystemStoreRootDirException();\n\t\t}\n\t}","commit_id":"2293ded53769ffad4757d07b814595e69b4b2378","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t* Process a merge for the file, or if it's a directory, for all contained files (one level deep).\n\t* @param fileName The site name (for the archive file) to read from.\n\t* @param mergeId The id string to use to make ids in the merge consistent and unique.\n\t* @param creatorId The creator id\n\t* If null or blank, the date/time string of the merge is used.\n\t*/\n\t//TODO Javadoc this\n\tpublic String merge(String fileName, String siteId, String creatorId, String m_storagePath,\n\t\t\t\t\t\tboolean filterSakaiServices, String[] filteredSakaiServices, boolean filterSakaiRoles, String[] filteredSakaiRoles)\n\t{\n\t\tStringBuilder results = new StringBuilder();\n\n\t\tFile[] files = null;\n\n\t\t// see if the name is a directory\n\t\tFile file = new File(m_storagePath + fileName);\n\t\tif ((file == null) || (!file.exists()))\n\t\t{\n\t\t\tresults.append(\"file: \" + file.getPath() + \" not found.\\n\");\n\t\t\tM_log.warn(\"merge(): file not found: \" + file.getPath());\n\t\t\treturn results.toString();\n\t\t}\n\n\t\tif (file.isDirectory())\n\t\t{\n\t\t\tfiles = file.listFiles();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfiles = new File[1];\n\t\t\tfiles[0] = file;\n\t\t}\n\n\t\t// track old to new attachment names\n\t\tMap attachmentNames = new HashMap();\t\t\n\t\t\n\t\t// firstly, merge the users\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif ((files[i] != null) && (files[i].getPath().indexOf(\"user.xml\") != -1))\n\t\t\t{\n\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, null, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t\t\tfiles[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// see if there's a site definition\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif ((files[i] != null) && (files[i].getPath().indexOf(\"site.xml\") != -1))\n\t\t\t{\n\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, creatorId, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t\t\tfiles[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// see if there's an attachments definition\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif ((files[i] != null) && (files[i].getPath().indexOf(\"attachment.xml\") != -1))\n\t\t\t{\n\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, null, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t\t\tfiles[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// process each remaining file that is an .xml file\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif (files[i] != null)\n\t\t\t\tif (files[i].getPath().endsWith(\".xml\"))\n\t\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, null, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t}\n\n\t\treturn results.toString();\n\n\t}","id":22498,"modified_method":"/**\n\t* Process a merge for the file, or if it's a directory, for all contained files (one level deep).\n\t* @param fileName The site name (for the archive file) to read from.\n\t* @param mergeId The id string to use to make ids in the merge consistent and unique.\n\t* @param creatorId The creator id\n\t* If null or blank, the date/time string of the merge is used.\n\t*/\n\t//TODO Javadoc this\n\tpublic String merge(String fileName, String siteId, String creatorId, String m_storagePath,\n\t\t\t\t\t\tboolean filterSakaiServices, String[] filteredSakaiServices, boolean filterSakaiRoles, String[] filteredSakaiRoles)\n\t{\n\t\tStringBuilder results = new StringBuilder();\n\n\t\tFile[] files = null;\n\n\t\t// see if the name is a directory\n\t\tFile file = new File(m_storagePath + fileName);\n\t\tif ((file == null) || (!file.exists()))\n\t\t{\n\t\t\tresults.append(\"file: \" + fileName + \" not found.\\n\");\n\t\t\tM_log.warn(\"merge(): file not found: \" + file.getPath());\n\t\t\treturn results.toString();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t// Path outside archive location, discard !\n\t\t\t\tFile baseLocation = new File(m_storagePath);\n\t\t\t\tif (!file.getCanonicalPath().startsWith(baseLocation.getCanonicalPath())) {\n\t\t\t\t\tthrow new Exception();\n\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tresults.append(\"file: \" + fileName + \" not permitted.\\n\");\n\t\t\t\tM_log.warn(\"merge(): file not permitted: \" + file.getPath());\n\t\t\t\treturn results.toString();\n\t\t\t}\n\t\t}\n\n\t\tif (file.isDirectory())\n\t\t{\n\t\t\tfiles = file.listFiles();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfiles = new File[1];\n\t\t\tfiles[0] = file;\n\t\t}\n\n\t\t// track old to new attachment names\n\t\tMap attachmentNames = new HashMap();\t\t\n\t\t\n\t\t// firstly, merge the users\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif ((files[i] != null) && (files[i].getPath().indexOf(\"user.xml\") != -1))\n\t\t\t{\n\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, null, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t\t\tfiles[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// see if there's a site definition\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif ((files[i] != null) && (files[i].getPath().indexOf(\"site.xml\") != -1))\n\t\t\t{\n\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, creatorId, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t\t\tfiles[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// see if there's an attachments definition\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif ((files[i] != null) && (files[i].getPath().indexOf(\"attachment.xml\") != -1))\n\t\t\t{\n\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, null, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t\t\tfiles[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// process each remaining file that is an .xml file\n\t\tfor (int i = 0; i < files.length; i++)\n\t\t{\n\t\t\tif (files[i] != null)\n\t\t\t\tif (files[i].getPath().endsWith(\".xml\"))\n\t\t\t\t\tprocessMerge(files[i].getPath(), siteId, results, attachmentNames, null, filterSakaiServices, filteredSakaiServices, filterSakaiRoles, filteredSakaiRoles);\n\t\t}\n\n\t\treturn results.toString();\n\n\t}","commit_id":"ca683ef2a533703645f0c5290ec99ced8005c08e","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String toString()\n    {\n        try\n        {\n            return String.format(\"KeyCacheKey(descriptor:%s, key:%s)\", desc, ByteBufferUtil.string(ByteBuffer.wrap(key)));\n        }\n        catch (CharacterCodingException e)\n        {\n            throw new AssertionError(e);\n        }\n    }","id":22499,"modified_method":"public String toString()\n    {\n        return String.format(\"KeyCacheKey(%s, %s)\", desc, ByteBufferUtil.bytesToHex(ByteBuffer.wrap(key)));\n    }","commit_id":"c710edf07b8bda7c2456fa615ce61a7d490f89a4","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to\n     * allow key selection by token bounds but only if op != * EQ\n     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.\n     * @param updateCacheAndStats true if updating stats and cache\n     * @return The position in the data file to find the key, or -1 if the key is not present\n     */\n    public long getPosition(RowPosition key, Operator op, boolean updateCacheAndStats)\n    {\n        // first, check bloom filter\n        if (op == Operator.EQ)\n        {\n            assert key instanceof DecoratedKey; // EQ only make sense if the key is a valid row key\n            if (!bf.isPresent(((DecoratedKey)key).key))\n                return -1;\n        }\n\n        // next, the key cache (only make sense for valid row key)\n        if ((op == Operator.EQ || op == Operator.GE) && (key instanceof DecoratedKey))\n        {\n            DecoratedKey decoratedKey = (DecoratedKey)key;\n            Long cachedPosition = getCachedPosition(new KeyCacheKey(descriptor, decoratedKey.key), updateCacheAndStats);\n            if (cachedPosition != null)\n                return cachedPosition;\n        }\n\n        // next, see if the sampled index says it's impossible for the key to be present\n        long sampledPosition = getIndexScanPosition(key);\n        if (sampledPosition == -1)\n        {\n            if (op == Operator.EQ && updateCacheAndStats)\n                bloomFilterTracker.addFalsePositive();\n            // we matched the -1th position: if the operator might match forward, return the 0th position\n            return op.apply(1) >= 0 ? 0 : -1;\n        }\n\n        // scan the on-disk index, starting at the nearest sampled position\n        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition, INDEX_FILE_BUFFER_BYTES);\n        while (segments.hasNext())\n        {\n            FileDataInput input = segments.next();\n            try\n            {\n                while (!input.isEOF())\n                {\n                    // read key & data position from index entry\n                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));\n                    long dataPosition = input.readLong();\n\n                    int comparison = indexDecoratedKey.compareTo(key);\n                    int v = op.apply(comparison);\n                    if (v == 0)\n                    {\n                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0 && updateCacheAndStats)\n                        {\n                            assert key instanceof DecoratedKey; // key can be == to the index key only if it's a true row key\n                            DecoratedKey decoratedKey = (DecoratedKey)key;\n                            // store exact match for the key\n                            cacheKey(decoratedKey, dataPosition);\n                        }\n                        if (op == Operator.EQ && updateCacheAndStats)\n                            bloomFilterTracker.addTruePositive();\n                        return dataPosition;\n                    }\n                    if (v < 0)\n                    {\n                        if (op == Operator.EQ && updateCacheAndStats)\n                            bloomFilterTracker.addFalsePositive();\n                        return -1;\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                markSuspect();\n                throw new IOError(e);\n            }\n            finally\n            {\n                FileUtils.closeQuietly(input);\n            }\n        }\n\n        if (op == Operator.EQ && updateCacheAndStats)\n            bloomFilterTracker.addFalsePositive();\n        return -1;\n    }","id":22500,"modified_method":"/**\n     * @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to\n     * allow key selection by token bounds but only if op != * EQ\n     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.\n     * @param updateCacheAndStats true if updating stats and cache\n     * @return The position in the data file to find the key, or -1 if the key is not present\n     */\n    public long getPosition(RowPosition key, Operator op, boolean updateCacheAndStats)\n    {\n        // first, check bloom filter\n        if (op == Operator.EQ)\n        {\n            assert key instanceof DecoratedKey; // EQ only make sense if the key is a valid row key\n            if (!bf.isPresent(((DecoratedKey)key).key))\n                return -1;\n        }\n\n        // next, the key cache (only make sense for valid row key)\n        if ((op == Operator.EQ || op == Operator.GE) && (key instanceof DecoratedKey))\n        {\n            DecoratedKey decoratedKey = (DecoratedKey)key;\n            KeyCacheKey cacheKey = new KeyCacheKey(descriptor, decoratedKey.key);\n            Long cachedPosition = getCachedPosition(cacheKey, updateCacheAndStats);\n            if (cachedPosition != null)\n            {\n                logger.trace(\"Cache hit for {} -> {}\", cacheKey, cachedPosition);\n                return cachedPosition;\n            }\n        }\n\n        // next, see if the sampled index says it's impossible for the key to be present\n        long sampledPosition = getIndexScanPosition(key);\n        if (sampledPosition == -1)\n        {\n            if (op == Operator.EQ && updateCacheAndStats)\n                bloomFilterTracker.addFalsePositive();\n            // we matched the -1th position: if the operator might match forward, return the 0th position\n            return op.apply(1) >= 0 ? 0 : -1;\n        }\n\n        // scan the on-disk index, starting at the nearest sampled position\n        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition, INDEX_FILE_BUFFER_BYTES);\n        while (segments.hasNext())\n        {\n            FileDataInput input = segments.next();\n            try\n            {\n                while (!input.isEOF())\n                {\n                    // read key & data position from index entry\n                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));\n                    long dataPosition = input.readLong();\n\n                    int comparison = indexDecoratedKey.compareTo(key);\n                    int v = op.apply(comparison);\n                    if (v == 0)\n                    {\n                        if (comparison == 0)\n                        {\n                            assert key instanceof DecoratedKey; // key can be == to the index key only if it's a true row key\n                            DecoratedKey decoratedKey = (DecoratedKey)key;\n\n                            if (logger.isTraceEnabled())\n                            {\n                                // expensive sanity check!  see CASSANDRA-4687\n                                FileDataInput fdi = dfile.getSegment(dataPosition);\n                                DecoratedKey keyInDisk = SSTableReader.decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(fdi));\n                                if (!keyInDisk.equals(key))\n                                    throw new AssertionError(String.format(\"%s != %s in %s\", keyInDisk, key, fdi.getPath()));\n                                fdi.close();\n                            }\n\n                            if (keyCache != null && keyCache.getCapacity() > 0 && updateCacheAndStats)\n                            {\n                                // store exact match for the key\n                                cacheKey(decoratedKey, dataPosition);\n                            }\n                        }\n                        if (op == Operator.EQ && updateCacheAndStats)\n                            bloomFilterTracker.addTruePositive();\n                        return dataPosition;\n                    }\n                    if (v < 0)\n                    {\n                        if (op == Operator.EQ && updateCacheAndStats)\n                            bloomFilterTracker.addFalsePositive();\n                        return -1;\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                markSuspect();\n                throw new IOError(e);\n            }\n            finally\n            {\n                FileUtils.closeQuietly(input);\n            }\n        }\n\n        if (op == Operator.EQ && updateCacheAndStats)\n            bloomFilterTracker.addFalsePositive();\n        return -1;\n    }","commit_id":"c710edf07b8bda7c2456fa615ce61a7d490f89a4","url":"https://github.com/apache/cassandra"},{"original_method":"public void cacheKey(DecoratedKey key, Long info)\n    {\n        CFMetaData.Caching caching = metadata.getCaching();\n\n        if (keyCache == null\n                || caching == CFMetaData.Caching.NONE\n                || caching == CFMetaData.Caching.ROWS_ONLY\n                || keyCache.getCapacity() == 0)\n            return;\n\n        // avoid keeping a permanent reference to the original key buffer\n        keyCache.put(new KeyCacheKey(descriptor, ByteBufferUtil.clone(key.key)), info);\n    }","id":22501,"modified_method":"public void cacheKey(DecoratedKey key, Long info)\n    {\n        CFMetaData.Caching caching = metadata.getCaching();\n\n        if (keyCache == null\n                || caching == CFMetaData.Caching.NONE\n                || caching == CFMetaData.Caching.ROWS_ONLY\n                || keyCache.getCapacity() == 0)\n            return;\n\n        // avoid keeping a permanent reference to the original key buffer\n        KeyCacheKey cacheKey = new KeyCacheKey(descriptor, ByteBufferUtil.clone(key.key));\n        logger.trace(\"Adding cache entry for {} -> {}\", cacheKey, info);\n        keyCache.put(cacheKey, info);\n    }","commit_id":"c710edf07b8bda7c2456fa615ce61a7d490f89a4","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Perform sanity checks on @param decoratedKey and @return the position in the data file before any data is written\n     */\n    private long beforeAppend(DecoratedKey<?> decoratedKey) throws IOException\n    {\n        assert decoratedKey != null : \"Keys must not be null\";\n        if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) >= 0)\n            throw new RuntimeException(\"Last written key \" + lastWrittenKey + \" >= current key \" + decoratedKey + \" writing into \" + getFilename());\n        return (lastWrittenKey == null) ? 0 : dataFile.getFilePointer();\n    }","id":22502,"modified_method":"/**\n     * Perform sanity checks on @param decoratedKey and @return the position in the data file before any data is written\n     */\n    private long beforeAppend(DecoratedKey<?> decoratedKey) throws IOException\n    {\n        assert decoratedKey != null : \"Keys must not be null\";\n        assert decoratedKey.key.remaining() > 0 : \"Keys must not be empty\";\n        if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) >= 0)\n            throw new RuntimeException(\"Last written key \" + lastWrittenKey + \" >= current key \" + decoratedKey + \" writing into \" + getFilename());\n        return (lastWrittenKey == null) ? 0 : dataFile.getFilePointer();\n    }","commit_id":"c710edf07b8bda7c2456fa615ce61a7d490f89a4","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * @param decoratedKey The key to apply as the rhs to the given Operator.\n     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.\n     * @return The position in the data file to find the key, or -1 if the key is not present\n     */\n    public long getPosition(DecoratedKey decoratedKey, Operator op)\n    {\n        // first, check bloom filter\n        if (op == Operator.EQ)\n        {\n            assert decoratedKey.key != null; // null is ok for GE scans\n            if (!bf.isPresent(decoratedKey.key))\n                return -1;\n        }\n\n        // next, the key cache\n        Pair<Descriptor, DecoratedKey> unifiedKey = new Pair<Descriptor, DecoratedKey>(descriptor, decoratedKey);\n        Long cachedPosition = getCachedPosition(unifiedKey);\n        if (cachedPosition != null)\n            return cachedPosition;\n\n        // next, see if the sampled index says it's impossible for the key to be present\n        IndexSummary.KeyPosition sampledPosition = getIndexScanPosition(decoratedKey);\n        if (sampledPosition == null)\n        {\n            if (op == Operator.EQ)\n                bloomFilterTracker.addFalsePositive();\n            // we matched the -1th position: if the operator might match forward, return the 0th position\n            return op.apply(1) >= 0 ? 0 : -1;\n        }\n\n        // scan the on-disk index, starting at the nearest sampled position\n        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition.indexPosition, INDEX_FILE_BUFFER_BYTES);\n        while (segments.hasNext())\n        {\n            FileDataInput input = segments.next();\n            try\n            {\n                while (!input.isEOF())\n                {\n                    // read key & data position from index entry\n                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));\n                    long dataPosition = input.readLong();\n\n                    int comparison = indexDecoratedKey.compareTo(decoratedKey);\n                    int v = op.apply(comparison);\n                    if (v == 0)\n                    {\n                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)\n                        {\n                            if (op == Operator.EQ)\n                                bloomFilterTracker.addTruePositive();\n                            // store exact match for the key\n                            cacheKey(decoratedKey, dataPosition);\n                        }\n                        return dataPosition;\n                    }\n                    if (v < 0)\n                    {\n                        if (op == Operator.EQ)\n                            bloomFilterTracker.addFalsePositive();\n                        return -1;\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                throw new IOError(e);\n            }\n            finally\n            {\n                FileUtils.closeQuietly(input);\n            }\n        }\n\n        if (op == Operator.EQ)\n            bloomFilterTracker.addFalsePositive();\n        return -1;\n    }","id":22503,"modified_method":"/**\n     * @param decoratedKey The key to apply as the rhs to the given Operator.\n     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.\n     * @return The position in the data file to find the key, or -1 if the key is not present\n     */\n    public long getPosition(DecoratedKey decoratedKey, Operator op)\n    {\n        // first, check bloom filter\n        if (op == Operator.EQ)\n        {\n            assert decoratedKey.key != null; // null is ok for GE scans\n            if (!bf.isPresent(decoratedKey.key))\n                return -1;\n        }\n\n        // next, the key cache\n        Pair<Descriptor, DecoratedKey> unifiedKey = new Pair<Descriptor, DecoratedKey>(descriptor, decoratedKey);\n        Long cachedPosition = getCachedPosition(unifiedKey);\n        if (cachedPosition != null)\n            return cachedPosition;\n\n        // next, see if the sampled index says it's impossible for the key to be present\n        IndexSummary.KeyPosition sampledPosition = getIndexScanPosition(decoratedKey);\n        if (sampledPosition == null)\n        {\n            if (op == Operator.EQ)\n                bloomFilterTracker.addFalsePositive();\n            // we matched the -1th position: if the operator might match forward, return the 0th position\n            return op.apply(1) >= 0 ? 0 : -1;\n        }\n\n        // scan the on-disk index, starting at the nearest sampled position\n        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition.indexPosition, INDEX_FILE_BUFFER_BYTES);\n        while (segments.hasNext())\n        {\n            FileDataInput input = segments.next();\n            try\n            {\n                while (!input.isEOF())\n                {\n                    // read key & data position from index entry\n                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));\n                    long dataPosition = input.readLong();\n\n                    int comparison = indexDecoratedKey.compareTo(decoratedKey);\n                    int v = op.apply(comparison);\n                    if (v == 0)\n                    {\n                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)\n                        {\n                            if (op == Operator.EQ)\n                                bloomFilterTracker.addTruePositive();\n                            // store exact match for the key\n                            if (decoratedKey.key != null)\n                                cacheKey(decoratedKey, dataPosition);\n                        }\n                        return dataPosition;\n                    }\n                    if (v < 0)\n                    {\n                        if (op == Operator.EQ)\n                            bloomFilterTracker.addFalsePositive();\n                        return -1;\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                throw new IOError(e);\n            }\n            finally\n            {\n                FileUtils.closeQuietly(input);\n            }\n        }\n\n        if (op == Operator.EQ)\n            bloomFilterTracker.addFalsePositive();\n        return -1;\n    }","commit_id":"86f6184d0d09f3f3a2c6d080c88e31810f373020","url":"https://github.com/apache/cassandra"},{"original_method":"public void cacheKey(DecoratedKey key, Long info)\n    {\n        // avoid keeping a permanent reference to the original key buffer\n        DecoratedKey copiedKey = new DecoratedKey(key.token, key.key == null ? null : ByteBufferUtil.clone(key.key));\n        keyCache.put(new Pair<Descriptor, DecoratedKey>(descriptor, copiedKey), info);\n    }","id":22504,"modified_method":"public void cacheKey(DecoratedKey key, Long info)\n    {\n        assert key.key != null;\n        // avoid keeping a permanent reference to the original key buffer\n        DecoratedKey copiedKey = new DecoratedKey(key.token, ByteBufferUtil.clone(key.key));\n        keyCache.put(new Pair<Descriptor, DecoratedKey>(descriptor, copiedKey), info);\n    }","commit_id":"86f6184d0d09f3f3a2c6d080c88e31810f373020","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * @param decoratedKey The key to apply as the rhs to the given Operator.\n     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.\n     * @return The position in the data file to find the key, or -1 if the key is not present\n     */\n    public long getPosition(DecoratedKey decoratedKey, Operator op)\n    {\n        // first, check bloom filter\n        if (op == Operator.EQ)\n        {\n            assert decoratedKey.key != null; // null is ok for GE scans\n            if (!bf.isPresent(decoratedKey.key))\n                return -1;\n        }\n\n        // next, the key cache\n        Pair<Descriptor, DecoratedKey> unifiedKey = new Pair<Descriptor, DecoratedKey>(descriptor, decoratedKey);\n        Long cachedPosition = getCachedPosition(unifiedKey);\n        if (cachedPosition != null)\n            return cachedPosition;\n\n        // next, see if the sampled index says it's impossible for the key to be present\n        IndexSummary.KeyPosition sampledPosition = getIndexScanPosition(decoratedKey);\n        if (sampledPosition == null)\n        {\n            if (op == Operator.EQ)\n                bloomFilterTracker.addFalsePositive();\n            // we matched the -1th position: if the operator might match forward, return the 0th position\n            return op.apply(1) >= 0 ? 0 : -1;\n        }\n\n        // scan the on-disk index, starting at the nearest sampled position\n        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition.indexPosition, INDEX_FILE_BUFFER_BYTES);\n        while (segments.hasNext())\n        {\n            FileDataInput input = segments.next();\n            try\n            {\n                while (!input.isEOF())\n                {\n                    // read key & data position from index entry\n                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));\n                    long dataPosition = input.readLong();\n\n                    int comparison = indexDecoratedKey.compareTo(decoratedKey);\n                    int v = op.apply(comparison);\n                    if (v == 0)\n                    {\n                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)\n                        {\n                            if (op == Operator.EQ)\n                                bloomFilterTracker.addTruePositive();\n                            // store exact match for the key\n                            cacheKey(decoratedKey, dataPosition);\n                        }\n                        return dataPosition;\n                    }\n                    if (v < 0)\n                    {\n                        if (op == Operator.EQ)\n                            bloomFilterTracker.addFalsePositive();\n                        return -1;\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                throw new IOError(e);\n            }\n            finally\n            {\n                FileUtils.closeQuietly(input);\n            }\n        }\n\n        if (op == Operator.EQ)\n            bloomFilterTracker.addFalsePositive();\n        return -1;\n    }","id":22505,"modified_method":"/**\n     * @param decoratedKey The key to apply as the rhs to the given Operator.\n     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.\n     * @return The position in the data file to find the key, or -1 if the key is not present\n     */\n    public long getPosition(DecoratedKey decoratedKey, Operator op)\n    {\n        // first, check bloom filter\n        if (op == Operator.EQ)\n        {\n            assert decoratedKey.key != null; // null is ok for GE scans\n            if (!bf.isPresent(decoratedKey.key))\n                return -1;\n        }\n\n        // next, the key cache\n        Pair<Descriptor, DecoratedKey> unifiedKey = new Pair<Descriptor, DecoratedKey>(descriptor, decoratedKey);\n        Long cachedPosition = getCachedPosition(unifiedKey);\n        if (cachedPosition != null)\n            return cachedPosition;\n\n        // next, see if the sampled index says it's impossible for the key to be present\n        IndexSummary.KeyPosition sampledPosition = getIndexScanPosition(decoratedKey);\n        if (sampledPosition == null)\n        {\n            if (op == Operator.EQ)\n                bloomFilterTracker.addFalsePositive();\n            // we matched the -1th position: if the operator might match forward, return the 0th position\n            return op.apply(1) >= 0 ? 0 : -1;\n        }\n\n        // scan the on-disk index, starting at the nearest sampled position\n        Iterator<FileDataInput> segments = ifile.iterator(sampledPosition.indexPosition, INDEX_FILE_BUFFER_BYTES);\n        while (segments.hasNext())\n        {\n            FileDataInput input = segments.next();\n            try\n            {\n                while (!input.isEOF())\n                {\n                    // read key & data position from index entry\n                    DecoratedKey indexDecoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.readWithShortLength(input));\n                    long dataPosition = input.readLong();\n\n                    int comparison = indexDecoratedKey.compareTo(decoratedKey);\n                    int v = op.apply(comparison);\n                    if (v == 0)\n                    {\n                        if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)\n                        {\n                            if (op == Operator.EQ)\n                                bloomFilterTracker.addTruePositive();\n                            // store exact match for the key\n                            if (decoratedKey.key != null)\n                                cacheKey(decoratedKey, dataPosition);\n                        }\n                        return dataPosition;\n                    }\n                    if (v < 0)\n                    {\n                        if (op == Operator.EQ)\n                            bloomFilterTracker.addFalsePositive();\n                        return -1;\n                    }\n                }\n            }\n            catch (IOException e)\n            {\n                throw new IOError(e);\n            }\n            finally\n            {\n                FileUtils.closeQuietly(input);\n            }\n        }\n\n        if (op == Operator.EQ)\n            bloomFilterTracker.addFalsePositive();\n        return -1;\n    }","commit_id":"0654df403f65a6c93794c3132c89f34bcb1d25cc","url":"https://github.com/apache/cassandra"},{"original_method":"public void cacheKey(DecoratedKey key, Long info)\n    {\n        // avoid keeping a permanent reference to the original key buffer\n        DecoratedKey copiedKey = new DecoratedKey(key.token, key.key == null ? null : ByteBufferUtil.clone(key.key));\n        keyCache.put(new Pair<Descriptor, DecoratedKey>(descriptor, copiedKey), info);\n    }","id":22506,"modified_method":"public void cacheKey(DecoratedKey key, Long info)\n    {\n        assert key.key != null;\n        // avoid keeping a permanent reference to the original key buffer\n        DecoratedKey copiedKey = new DecoratedKey(key.token, ByteBufferUtil.clone(key.key));\n        keyCache.put(new Pair<Descriptor, DecoratedKey>(descriptor, copiedKey), info);\n    }","commit_id":"0654df403f65a6c93794c3132c89f34bcb1d25cc","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Loads ifile, dfile and indexSummary, and optionally recreates the bloom filter.\n     */\n    private void load(boolean recreatebloom, Set<DecoratedKey> keysToLoadInCache) throws IOException\n    {\n        boolean cacheLoading = keyCache != null && !keysToLoadInCache.isEmpty();\n\n        SegmentedFile.Builder ibuilder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());\n        SegmentedFile.Builder dbuilder = compression\n                                          ? SegmentedFile.getCompressedBuilder()\n                                          : SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());\n\n        // we read the positions in a BRAF so we don't have to worry about an entry spanning a mmap boundary.\n        RandomAccessReader input = RandomAccessReader.open(new File(descriptor.filenameFor(Component.PRIMARY_INDEX)), true);\n        DecoratedKey left = null, right = null;\n        try\n        {\n            long indexSize = input.length();\n            long histogramCount = sstableMetadata.estimatedRowSize.count();\n            long estimatedKeys = histogramCount > 0 && !sstableMetadata.estimatedRowSize.isOverflowed()\n                               ? histogramCount\n                               : estimateRowsFromIndex(input); // statistics is supposed to be optional\n            indexSummary = new IndexSummary(estimatedKeys);\n            if (recreatebloom)\n                bf = LegacyBloomFilter.getFilter(estimatedKeys, 15);\n\n            while (true)\n            {\n                long indexPosition = input.getFilePointer();\n                if (indexPosition == indexSize)\n                    break;\n\n                DecoratedKey decoratedKey = null;\n                int len = ByteBufferUtil.readShortLength(input);\n\n                boolean firstKey = left == null;\n                boolean lastKey = indexPosition + DBConstants.SHORT_SIZE + len + DBConstants.LONG_SIZE == indexSize;\n                boolean shouldAddEntry = indexSummary.shouldAddEntry();\n                if (shouldAddEntry || cacheLoading || recreatebloom || firstKey || lastKey)\n                {\n                    decoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.read(input, len));\n                    if (firstKey)\n                        left = decoratedKey;\n                    if (lastKey)\n                        right = decoratedKey;\n                }\n                else\n                {\n                    FileUtils.skipBytesFully(input, len);\n                }\n\n                RowIndexEntry indexEntry = RowIndexEntry.serializer.deserialize(input, descriptor);\n                if (decoratedKey != null)\n                {\n                    if (recreatebloom)\n                        bf.add(decoratedKey.key);\n                    if (shouldAddEntry)\n                        indexSummary.addEntry(decoratedKey, indexPosition);\n                    // if key cache could be used and we have key already pre-loaded\n                    if (cacheLoading && keysToLoadInCache.contains(decoratedKey))\n                        cacheKey(decoratedKey, indexEntry);\n                }\n\n                indexSummary.incrementRowid();\n                ibuilder.addPotentialBoundary(indexPosition);\n                dbuilder.addPotentialBoundary(indexEntry.position);\n            }\n            indexSummary.complete();\n        }\n        finally\n        {\n            FileUtils.closeQuietly(input);\n        }\n        this.first = getMinimalKey(left);\n        this.last = getMinimalKey(right);\n\n        // finalize the state of the reader\n        ifile = ibuilder.complete(descriptor.filenameFor(Component.PRIMARY_INDEX));\n        dfile = dbuilder.complete(descriptor.filenameFor(Component.DATA));\n    }","id":22507,"modified_method":"/**\n     * Loads ifile, dfile and indexSummary, and optionally recreates the bloom filter.\n     */\n    private void load(boolean recreatebloom, Set<DecoratedKey> keysToLoadInCache) throws IOException\n    {\n        boolean cacheLoading = keyCache != null && !keysToLoadInCache.isEmpty();\n\n        SegmentedFile.Builder ibuilder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());\n        SegmentedFile.Builder dbuilder = compression\n                                          ? SegmentedFile.getCompressedBuilder()\n                                          : SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());\n\n        // we read the positions in a BRAF so we don't have to worry about an entry spanning a mmap boundary.\n        RandomAccessReader input = RandomAccessReader.open(new File(descriptor.filenameFor(Component.PRIMARY_INDEX)), true);\n        DecoratedKey left = null, right = null;\n        try\n        {\n            long indexSize = input.length();\n            long histogramCount = sstableMetadata.estimatedRowSize.count();\n            long estimatedKeys = histogramCount > 0 && !sstableMetadata.estimatedRowSize.isOverflowed()\n                               ? histogramCount\n                               : estimateRowsFromIndex(input); // statistics is supposed to be optional\n            indexSummary = new IndexSummary(estimatedKeys);\n            if (recreatebloom)\n                bf = LegacyBloomFilter.getFilter(estimatedKeys, 15);\n\n            while (true)\n            {\n                long indexPosition = input.getFilePointer();\n                if (indexPosition == indexSize)\n                    break;\n\n                DecoratedKey decoratedKey = null;\n                int len = ByteBufferUtil.readShortLength(input);\n\n                // when primary index file contains info other than data position, there is noway to determine\n                // the last key without deserializing index entry\n                boolean firstKey = left == null;\n                boolean lastKeyForUnpromoted = indexPosition + DBConstants.SHORT_SIZE + len + DBConstants.LONG_SIZE == indexSize;\n                boolean shouldAddEntry = indexSummary.shouldAddEntry();\n                if (shouldAddEntry || cacheLoading || recreatebloom || firstKey || lastKeyForUnpromoted || descriptor.hasPromotedIndexes)\n                {\n                    decoratedKey = decodeKey(partitioner, descriptor, ByteBufferUtil.read(input, len));\n                    if (firstKey)\n                        left = decoratedKey;\n                    right = decoratedKey;\n                }\n                else\n                {\n                    FileUtils.skipBytesFully(input, len);\n                }\n\n                RowIndexEntry indexEntry = null;\n                if (decoratedKey != null)\n                {\n                    if (recreatebloom)\n                        bf.add(decoratedKey.key);\n                    if (shouldAddEntry)\n                        indexSummary.addEntry(decoratedKey, indexPosition);\n                    // if key cache could be used and we have key already pre-loaded\n                    if (cacheLoading && keysToLoadInCache.contains(decoratedKey))\n                    {\n                        indexEntry = RowIndexEntry.serializer.deserialize(input, descriptor);\n                        cacheKey(decoratedKey, indexEntry);\n                    }\n                }\n                if (indexEntry == null)\n                    indexEntry = RowIndexEntry.serializer.deserializePositionOnly(input, descriptor);\n\n                indexSummary.incrementRowid();\n                ibuilder.addPotentialBoundary(indexPosition);\n                dbuilder.addPotentialBoundary(indexEntry.position);\n            }\n            indexSummary.complete();\n        }\n        finally\n        {\n            FileUtils.closeQuietly(input);\n        }\n        this.first = getMinimalKey(left);\n        this.last = getMinimalKey(right);\n\n        // finalize the state of the reader\n        ifile = ibuilder.complete(descriptor.filenameFor(Component.PRIMARY_INDEX));\n        dfile = dbuilder.complete(descriptor.filenameFor(Component.DATA));\n    }","commit_id":"417b175fa4bfc80994b3d4e85c9f8d93f3d9ab60","url":"https://github.com/apache/cassandra"},{"original_method":"private File getContextTempFile(int hashcode, DocumentReference targetContext)\n    {\n        return new File(getTempDir(targetContext), Math.abs(hashcode) + RASTER_FILE_EXTENSION);\n    }","id":22508,"modified_method":"private File getContextTempFile(int hashcode, DocumentReference targetContext)\n    {\n        File parent = getTempDir(targetContext);\n        if (parent == null) {\n            return null;\n        }\n        return new File(parent, Math.abs(hashcode) + RASTER_FILE_EXTENSION);\n    }","commit_id":"3a9e8606927ca86c07c77d0b4cc9640ce0b2c42b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public File rasterizeToTemporaryFile(String content, int width, int height) throws IOException\n    {\n        File out = getTempFile(content.hashCode());\n        if (rasterizeToFile(content, out, width, height)) {\n            return out;\n        }\n        return null;\n    }","id":22509,"modified_method":"@Override\n    public File rasterizeToTemporaryFile(String content, int width, int height) throws IOException\n    {\n        File out = getTempFile(content.hashCode());\n        if (out != null && rasterizeToFile(content, out, width, height)) {\n            return out;\n        }\n        return null;\n    }","commit_id":"3a9e8606927ca86c07c77d0b4cc9640ce0b2c42b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private File getTempDir(DocumentReference targetContext)\n    {\n        File tempDir = getBaseTempDir();\n        for (EntityReference ref : targetContext.getReversedReferenceChain()) {\n            tempDir = new File(tempDir, ref.getName());\n        }\n\n        try {\n            tempDir.mkdirs();\n        } catch (Exception ex) {\n            this.logger.warn(\"Cannot create temporary files: {}\", ExceptionUtils.getRootCauseMessage(ex));\n        }\n\n        return tempDir;\n    }","id":22510,"modified_method":"private File getTempDir(DocumentReference targetContext)\n    {\n        File tempDir = getBaseTempDir();\n        if (tempDir == null) {\n            return null;\n        }\n        for (EntityReference ref : targetContext.getReversedReferenceChain()) {\n            tempDir = new File(tempDir, ref.getName());\n        }\n\n        if (!tempDir.exists() && !tempDir.mkdirs()) {\n            this.logger.error(\"Cannot create temporary directory [{}] for context document [{}]\", tempDir,\n                targetContext);\n            return null;\n        }\n\n        return tempDir;\n    }","commit_id":"3a9e8606927ca86c07c77d0b4cc9640ce0b2c42b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private File getTempFile(int hashcode)\n    {\n        return new File(getBaseTempDir(), Math.abs(hashcode) + RASTER_FILE_EXTENSION);\n    }","id":22511,"modified_method":"private File getTempFile(int hashcode)\n    {\n        File parent = getBaseTempDir();\n        if (parent == null) {\n            return null;\n        }\n        return new File(parent, Math.abs(hashcode) + RASTER_FILE_EXTENSION);\n    }","commit_id":"3a9e8606927ca86c07c77d0b4cc9640ce0b2c42b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public TemporaryResourceReference rasterizeToTemporaryResource(String content, int width, int height,\n        DocumentReference targetContext) throws IOException\n    {\n        File out = getContextTempFile(content.hashCode(), targetContext);\n        if (rasterizeToFile(content, out, width, height)) {\n            return new TemporaryResourceReference(TEMP_DIR_NAME, out.getName(), targetContext);\n        }\n        return null;\n    }","id":22512,"modified_method":"@Override\n    public TemporaryResourceReference rasterizeToTemporaryResource(String content, int width, int height,\n        DocumentReference targetContext) throws IOException\n    {\n        File out = getContextTempFile(content.hashCode(), targetContext);\n        if (out != null && rasterizeToFile(content, out, width, height)) {\n            return new TemporaryResourceReference(TEMP_DIR_NAME, out.getName(), targetContext);\n        }\n        return null;\n    }","commit_id":"3a9e8606927ca86c07c77d0b4cc9640ce0b2c42b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private File getBaseTempDir()\n    {\n        File tempDir = new File(new File(this.environment.getTemporaryDirectory(), \"temp\"), TEMP_DIR_NAME);\n\n        try {\n            tempDir.mkdirs();\n        } catch (Exception ex) {\n            this.logger.warn(\"Cannot create temporary directory: {}\", ExceptionUtils.getRootCauseMessage(ex));\n        }\n\n        return tempDir;\n    }","id":22513,"modified_method":"private File getBaseTempDir()\n    {\n        File tempDir = new File(new File(this.environment.getTemporaryDirectory(), \"temp\"), TEMP_DIR_NAME);\n\n        if (!tempDir.exists() && !tempDir.mkdirs()) {\n            this.logger.error(\"Cannot create temporary directory [{}]\", tempDir);\n            return null;\n        }\n\n        return tempDir;\n    }","commit_id":"3a9e8606927ca86c07c77d0b4cc9640ce0b2c42b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public File rasterizeToTemporaryFile(String content, int width, int height) throws IOException\n    {\n        File out = getTempFile(content.hashCode());\n        if (out != null && rasterizeToFile(content, out, width, height)) {\n            return out;\n        }\n        return null;\n    }","id":22514,"modified_method":"@Override\n    public File rasterizeToTemporaryFile(String content, int width, int height) throws IOException\n    {\n        String fileName = getTemporaryFileName(content, width, height);\n        TemporaryResourceReference reference = new TemporaryResourceReference(TEMP_DIR_NAME, fileName, null);\n        File out = this.temporaryResourceStore.getTemporaryFile(reference);\n        if (rasterizeToFile(content, out, width, height)) {\n            return out;\n        }\n        return null;\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public TemporaryResourceReference rasterizeToTemporaryResource(String content, int width, int height,\n        DocumentReference targetContext) throws IOException\n    {\n        File out = getContextTempFile(content.hashCode(), targetContext);\n        if (out != null && rasterizeToFile(content, out, width, height)) {\n            return new TemporaryResourceReference(TEMP_DIR_NAME, out.getName(), targetContext);\n        }\n        return null;\n    }","id":22515,"modified_method":"@Override\n    public TemporaryResourceReference rasterizeToTemporaryResource(String content, int width, int height,\n        DocumentReference targetContext) throws IOException\n    {\n        String fileName = getTemporaryFileName(content, width, height);\n        TemporaryResourceReference reference = new TemporaryResourceReference(TEMP_DIR_NAME, fileName, targetContext);\n        File out = this.temporaryResourceStore.getTemporaryFile(reference);\n        if (rasterizeToFile(content, out, width, height)) {\n            return reference;\n        }\n        return null;\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean rasterizeToFile(String content, File out, int width, int height) throws IOException\n    {\n        boolean result = true;\n        if (out.exists()) {\n            this.logger.debug(\"Reusing existing temporary raster image: {}\", out.getAbsolutePath());\n            return result;\n        }\n        try (OutputStream fout = new FileOutputStream(out)) {\n            this.logger.debug(\"Rasterizing to temp file: {}\", out.getAbsolutePath());\n            TranscoderInput input = new TranscoderInput(new StringReader(content));\n            TranscoderOutput output = new TranscoderOutput(fout);\n            result = rasterize(input, output, width, height);\n        }\n        if (!result) {\n            out.delete();\n        }\n        return result;\n    }","id":22516,"modified_method":"private boolean rasterizeToFile(String content, File out, int width, int height) throws IOException\n    {\n        if (!out.getParentFile().exists() && !out.getParentFile().mkdirs()) {\n            this.logger.debug(\"Failed to create temporary folder [{}].\", out.getParentFile().getAbsolutePath());\n            return false;\n        } else if (out.exists() && out.isFile()) {\n            this.logger.debug(\"Reusing existing temporary raster image: {}\", out.getAbsolutePath());\n            return true;\n        } else {\n            try (OutputStream fout = new FileOutputStream(out)) {\n                this.logger.debug(\"Rasterizing to temp file: {}\", out.getAbsolutePath());\n                TranscoderInput input = new TranscoderInput(new StringReader(content));\n                TranscoderOutput output = new TranscoderOutput(fout);\n                boolean success = rasterize(input, output, width, height);\n                if (!success) {\n                    out.delete();\n                }\n                return success;\n            }\n        }\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private boolean writeTestFile(File file) throws IOException\n    {\n        FileUtils.forceMkdir(file.getParentFile());\n        try (OutputStream out = new FileOutputStream(file)) {\n            IOUtils.write(\"test\", out);\n            return true;\n        } catch (Exception ex) {\n            return false;\n        }\n    }","id":22517,"modified_method":"private boolean writeTestFile(File file) throws IOException\n    {\n        FileUtils.forceMkdir(file.getParentFile());\n        try (OutputStream out = new FileOutputStream(file)) {\n            IOUtils.write(\"test\".getBytes(), out);\n            return true;\n        } catch (Exception ex) {\n            return false;\n        }\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void setup() throws Exception\n    {\n        MockitoAnnotations.initMocks(this);\n        this.rasterFile = new File(this.baseDirectory.getRoot() + \"/temp/svg/wiki/Space/Document/\" + RASTER_FILE_NAME);\n        this.temporaryFile = new File(this.baseDirectory.getRoot() + \"/temp/svg/\" + RASTER_FILE_NAME);\n        this.temporaryFilePath = this.temporaryFile.getAbsolutePath();\n\n        this.environment = this.mocker.getInstance(Environment.class);\n        when(this.environment.getTemporaryDirectory()).thenReturn(this.baseDirectory.getRoot());\n\n        this.resolver = this.mocker.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        when(this.resolver.resolve(\"\")).thenReturn(this.dref);\n\n        this.container = this.mocker.getInstance(Container.class);\n        when(this.container.getResponse()).thenReturn(this.sresponse);\n        when(this.sresponse.getHttpServletResponse()).thenReturn(this.hsresponse);\n    }","id":22518,"modified_method":"@Before\n    public void setup() throws Exception\n    {\n        MockitoAnnotations.initMocks(this);\n        this.rasterFile = new File(this.baseDirectory.getRoot() + \"/temp/svg/wiki/Space/Document/\" + RASTER_FILE_NAME);\n        this.temporaryFile = new File(this.baseDirectory.getRoot() + \"/temp/svg/\" + RASTER_FILE_NAME);\n        this.temporaryFilePath = this.temporaryFile.getAbsolutePath();\n\n        this.temporaryResourceStore = this.mocker.getInstance(TemporaryResourceStore.class);\n\n        TemporaryResourceReference rasterFileReferece = new TemporaryResourceReference(\"svg\", RASTER_FILE_NAME, dref);\n        when(this.temporaryResourceStore.getTemporaryFile(rasterFileReferece)).thenReturn(rasterFile);\n\n        TemporaryResourceReference temporaryFileReferece =\n            new TemporaryResourceReference(\"svg\", RASTER_FILE_NAME, null);\n        when(this.temporaryResourceStore.getTemporaryFile(temporaryFileReferece)).thenReturn(temporaryFile);\n\n        String invalidRasterFileName = Math.abs(INVALID_SVG.hashCode()) + \".png\";\n        File invalidRasterFile =\n            new File(this.baseDirectory.getRoot() + \"/temp/svg/wiki/Space/Document/\" + invalidRasterFileName);\n        File invalidTemporaryFile = new File(this.baseDirectory.getRoot() + \"/temp/svg/\" + invalidRasterFileName);\n\n        TemporaryResourceReference invalidRasterFileReferece =\n            new TemporaryResourceReference(\"svg\", invalidRasterFileName, dref);\n        when(this.temporaryResourceStore.getTemporaryFile(invalidRasterFileReferece)).thenReturn(invalidRasterFile);\n\n        TemporaryResourceReference invalidTemporaryFileReferece =\n            new TemporaryResourceReference(\"svg\", invalidRasterFileName, null);\n        when(this.temporaryResourceStore.getTemporaryFile(invalidTemporaryFileReferece))\n            .thenReturn(invalidTemporaryFile);\n\n        this.resolver = this.mocker.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        when(this.resolver.resolve(\"\")).thenReturn(this.dref);\n\n        this.container = this.mocker.getInstance(Container.class);\n        when(this.container.getResponse()).thenReturn(this.sresponse);\n        when(this.sresponse.getHttpServletResponse()).thenReturn(this.hsresponse);\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void rasterizeToTemporaryFileReturnsNullWhenFileCannotBeCreated() throws Exception\n    {\n        this.baseDirectory.getRoot().mkdirs();\n        writeTestFile(new File(this.baseDirectory.getRoot(), \"temp\"));\n        File tfile =\n            this.mocker.getComponentUnderTest().rasterizeToTemporaryFile(VALID_SVG, 100, 200);\n        Assert.assertNull(tfile);\n    }","id":22519,"modified_method":"@Test\n    public void rasterizeToTemporaryFileReturnsNullWhenParentFolderCannotBeCreated() throws Exception\n    {\n        this.baseDirectory.getRoot().mkdirs();\n        writeTestFile(new File(this.baseDirectory.getRoot(), \"temp\"));\n        File tfile = this.mocker.getComponentUnderTest().rasterizeToTemporaryFile(VALID_SVG, 100, 200);\n        Assert.assertNull(tfile);\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param resourceReference the reference to the WebJar resource to get\n     * @return the name of the specified resource, e.g. \"requirejs/2.1.15/require.min.js\"\n     */\n    private String getResourceName(WebJarsResourceReference resourceReference)\n    {\n        return resourceReference.getResourceName();\n    }","id":22520,"modified_method":"@Override\n    protected String getResourceName(WebJarsResourceReference resourceReference)\n    {\n        return resourceReference.getResourceName();\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param resourceReference a reference to a WebJar resource\n     * @return {@code true} if the referenced resource is static and is cached by the browser, {@code false} if the\n     *         browser should discard the cached version and use the new version from this response\n     */\n    private boolean shouldBrowserUseCachedContent(WebJarsResourceReference resourceReference)\n    {\n        // If the request contains an \"If-Modified-Since\" header and the referenced resource is not supposed to be\n        // evaluated (i.e. no Velocity code) then return a 304 so to tell the browser to use its cached version.\n        Request request = this.container.getRequest();\n        if (request instanceof ServletRequest && !shouldEvaluateResource(resourceReference)) {\n            // This is a request for a static resource from a WebJar.\n            if (((ServletRequest) request).getHttpServletRequest().getHeader(\"If-Modified-Since\") != null) {\n                // The user probably used F5 to reload the page and the browser checks if there are changes.\n                Response response = this.container.getResponse();\n                if (response instanceof ServletResponse) {\n                    // Return the 304 Not Modified. Static WebJar resources don't change if their path doesn't change\n                    // (and the WebJar version is included in the path).\n                    ((ServletResponse) response).getHttpServletResponse().setStatus(\n                        HttpServletResponse.SC_NOT_MODIFIED);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":22521,"modified_method":"@Override\n    protected boolean isResourceCacheable(WebJarsResourceReference resourceReference)\n    {\n        return !Boolean.valueOf(resourceReference.getParameterValue(\"evaluate\"));\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param resourceReference the reference to the WebJar resource to get\n     * @return the stream that can be used to read the resource from the WebJar\n     */\n    private InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        String resourcePath = String.format(\"%s%s\", WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n        return getClassLoader(resourceReference.getNamespace()).getResourceAsStream(resourcePath);\n    }","id":22522,"modified_method":"@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        String resourcePath = String.format(\"%s%s\", WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n        return getClassLoader(resourceReference.getNamespace()).getResourceAsStream(resourcePath);\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Sends back the specified resource.\n     *\n     * @param resourceReference the reference to the WebJar resource to get\n     * @param rawResourceStream the resource stream used to read the resource from the WebJar\n     * @throws ResourceReferenceHandlerException if it fails to read the resource\n     */\n    private void serveResource(WebJarsResourceReference resourceReference, InputStream rawResourceStream)\n        throws ResourceReferenceHandlerException\n    {\n        InputStream resourceStream = rawResourceStream;\n        String resourceName = getResourceName(resourceReference);\n\n        if (shouldEvaluateResource(resourceReference)) {\n            resourceStream = evaluate(resourceName, resourceStream);\n        }\n\n        // Make sure the resource stream supports mark & reset which is needed in order be able to detect the\n        // content type without affecting the stream (Tika may need to read a few bytes from the start of the\n        // stream, in which case it will mark & reset the stream).\n        if (!resourceStream.markSupported()) {\n            resourceStream = new BufferedInputStream(resourceStream);\n        }\n\n        try {\n            Response response = this.container.getResponse();\n            setResponseHeaders(response, resourceReference);\n            response.setContentType(this.tika.detect(resourceStream, resourceName));\n            IOUtils.copy(resourceStream, response.getOutputStream());\n        } catch (Exception e) {\n            throw new ResourceReferenceHandlerException(String.format(\"Failed to read resource [%s]\", resourceName), e);\n        } finally {\n            IOUtils.closeQuietly(resourceStream);\n        }\n    }","id":22523,"modified_method":"@Override\n    protected InputStream filterResource(WebJarsResourceReference resourceReference, InputStream resourceStream)\n        throws ResourceReferenceHandlerException\n    {\n        if (!isResourceCacheable(resourceReference)) {\n            String resourceName = getResourceName(resourceReference);\n            try {\n                // Evaluates the given resource using Velocity.\n                StringWriter writer = new StringWriter();\n                this.velocityManager.getVelocityEngine().evaluate(this.velocityManager.getVelocityContext(), writer,\n                    resourceName, new InputStreamReader(resourceStream, UTF8));\n                return new ByteArrayInputStream(writer.toString().getBytes(UTF8));\n            } catch (Exception e) {\n                throw new ResourceReferenceHandlerException(\n                    String.format(\"Failed to evaluate the Velocity code from WebJar resource [%s]\", resourceName), e);\n            }\n        }\n        return super.filterResource(resourceReference, resourceStream);\n    }","commit_id":"a211c90d70b5df2d37ab03bf4ad83205c96d07bd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private List<EditableSModelDescriptor> getModelsToSave() {\n    List<EditableSModelDescriptor> modelsToSave = new ArrayList<EditableSModelDescriptor>();\n    for (SModelDescriptor md : myModelsWithOwners.keySet()) {\n      if (md instanceof EditableSModelDescriptor) {\n        EditableSModelDescriptor emd = ((EditableSModelDescriptor) md);\n        if (emd.isChanged()) {\n          modelsToSave.add(emd);\n        }\n      }\n    }\n    return modelsToSave;\n  }","id":22524,"modified_method":"private List<EditableSModelDescriptor> getModelsToSave() {\n    List<EditableSModelDescriptor> modelsToSave = new ArrayList<EditableSModelDescriptor>();\n    for (SModelDescriptor md : myModelsWithOwners.keySet()) {\n      if (md instanceof EditableSModelDescriptor) {\n        EditableSModelDescriptor emd = ((EditableSModelDescriptor) md);\n        // HOTFIX MPS-13326\n        if (emd.isChanged() && !emd.isPackaged()) {\n          modelsToSave.add(emd);\n        }\n      }\n    }\n    return modelsToSave;\n  }","commit_id":"0cd678f74bf6b298b5adde0a08ec6abb2fe2a257","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#updateResources(org.apache.lucene.index.IndexWriter, org.opencms.search.CmsIndexingThreadManager, java.util.List, java.util.List)\n     */\n    public void updateResources(IndexWriter writer, CmsIndexingThreadManager threadManager, List resourcesToUpdate, List sources) {\n\n        // NYI\n    }","id":22525,"modified_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#updateResources(org.apache.lucene.index.IndexWriter, org.opencms.search.CmsIndexingThreadManager, java.util.List)\n     */\n    public void updateResources(IndexWriter writer, CmsIndexingThreadManager threadManager, List resourcesToUpdate) {\n\n        // NYI\n    }","commit_id":"ed977f6fe7e99e954f4f2af95e7473a1357160eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Incrementally updates all indexes that have their rebuild mode set to <code>\"auto\"<\/code>\n     * after resources have been published.<p> \n     * \n     * @param adminCms an OpenCms user context with Admin permissions\n     * @param publishHistoryId the history ID of the published project \n     * @param report the report to write the output to\n     */\n    protected synchronized void updateAllIndexes(CmsObject adminCms, CmsUUID publishHistoryId, I_CmsReport report) {\n\n        List publishedResources;\n        try {\n            // read the list of all published resources\n            publishedResources = adminCms.readPublishedResources(publishHistoryId);\n        } catch (CmsException e) {\n            LOG.error(Messages.get().key(Messages.LOG_READING_CHANGED_RESOURCES_FAILED_1, publishHistoryId), e);\n            return;\n        }\n\n        List updateResources = new ArrayList();\n        Iterator itPubRes = publishedResources.iterator();\n        while (itPubRes.hasNext()) {\n            CmsPublishedResource res = (CmsPublishedResource)itPubRes.next();\n            if (res.isFolder() || res.isUnChanged() || !res.isVfsResource()) {\n                // folders, unchanged resources and non vfs resources don't need to be indexed after publish\n                continue;\n            }\n            if (res.isDeleted() || res.isNew() || res.isChanged()) {\n                updateResources.add(res);\n            }\n        }\n\n        // cache for the generated documents (to avoid multiple text extraction in case of overlapping indexes)\n        Map documentCache = Collections.synchronizedMap(new LRUMap(256));\n\n        if (!updateResources.isEmpty()) {\n            // sort the resource to update\n            Collections.sort(updateResources);\n            // only update the indexes if the list of remaining published resources is not empty\n            Iterator i = m_indexes.iterator();\n            while (i.hasNext()) {\n                CmsSearchIndex index = (CmsSearchIndex)i.next();\n                if (CmsSearchIndex.REBUILD_MODE_AUTO.equals(index.getRebuildMode())) {\n                    // only update indexes which have the rebuild mode set to \"auto\"\n                    try {\n                        updateIndex(index, report, false, updateResources, documentCache);\n                    } catch (CmsException e) {\n                        LOG.error(Messages.get().key(Messages.LOG_UPDATE_INDEX_FAILED_1, index.getName()), e);\n                    }\n                }\n            }\n        }\n    }","id":22526,"modified_method":"/**\n     * Incrementally updates all indexes that have their rebuild mode set to <code>\"auto\"<\/code>\n     * after resources have been published.<p> \n     * \n     * @param adminCms an OpenCms user context with Admin permissions\n     * @param publishHistoryId the history ID of the published project \n     * @param report the report to write the output to\n     */\n    protected synchronized void updateAllIndexes(CmsObject adminCms, CmsUUID publishHistoryId, I_CmsReport report) {\n\n        List publishedResources;\n        try {\n            // read the list of all published resources\n            publishedResources = adminCms.readPublishedResources(publishHistoryId);\n        } catch (CmsException e) {\n            LOG.error(Messages.get().key(Messages.LOG_READING_CHANGED_RESOURCES_FAILED_1, publishHistoryId), e);\n            return;\n        }\n\n        List updateResources = new ArrayList();\n        Iterator itPubRes = publishedResources.iterator();\n        while (itPubRes.hasNext()) {\n            CmsPublishedResource res = (CmsPublishedResource)itPubRes.next();\n            if (res.isFolder() || res.isUnChanged() || !res.isVfsResource()) {\n                // folders, unchanged resources and non vfs resources don't need to be indexed after publish\n                continue;\n            }\n            if (res.isDeleted() || res.isNew() || res.isChanged()) {\n                if (updateResources.contains(res)) {\n                    // resource may have been added as a sibling of another resource\n                    // in this case we make sure to use the value from the publih list because of the \"deleted\" flag\n                    updateResources.remove(res);\n                    // \"equals()\" implementation of published resource only checks for path, \n                    // so the removed value may have a different \"deleted\" or \"modified\" status value\n                    updateResources.add(res);\n                } else {\n                    // resource not yet contained in the list\n                    updateResources.add(res);\n                    // check for the siblings\n                    if (res.getSiblingCount() > 1) {\n                        // this resource has siblings                    \n                        try {\n                            // read siblings from the online project\n                            List siblings = adminCms.readSiblings(res.getRootPath(), CmsResourceFilter.ALL);\n                            Iterator itSib = siblings.iterator();\n                            while (itSib.hasNext()) {\n                                // check all siblings\n                                CmsResource sibling = (CmsResource)itSib.next();\n                                CmsPublishedResource sib = new CmsPublishedResource(sibling);\n                                if (!updateResources.contains(sib)) {\n                                    // ensure sibling is added only once\n                                    updateResources.add(sib);\n                                }\n                            }\n                        } catch (CmsException e) {\n                            // ignore, just use the original resource\n                            if (LOG.isWarnEnabled()) {\n                                LOG.warn(\n                                    Messages.get().key(Messages.LOG_UNABLE_TO_READ_SIBLINGS_1, res.getRootPath()),\n                                    e);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // cache for the generated documents (to avoid multiple text extraction in case of overlapping indexes)\n        Map documentCache = Collections.synchronizedMap(new LRUMap(256));\n\n        if (!updateResources.isEmpty()) {\n            // sort the resource to update\n            Collections.sort(updateResources);\n            // only update the indexes if the list of remaining published resources is not empty\n            Iterator i = m_indexes.iterator();\n            while (i.hasNext()) {\n                CmsSearchIndex index = (CmsSearchIndex)i.next();\n                if (CmsSearchIndex.REBUILD_MODE_AUTO.equals(index.getRebuildMode())) {\n                    // only update indexes which have the rebuild mode set to \"auto\"\n                    try {\n                        updateIndex(index, report, false, updateResources, documentCache);\n                    } catch (CmsException e) {\n                        LOG.error(Messages.get().key(Messages.LOG_UPDATE_INDEX_FAILED_1, index.getName()), e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ed977f6fe7e99e954f4f2af95e7473a1357160eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Updates (if required creates) the index with the given name.<p>\n     * \n     * If the optional List of <code>{@link CmsPublishedResource}<\/code> instances is provided, the index will be \n     * incrementally updated for these resources only. If this List is <code>null<\/code> or empty, \n     * the index will be fully rebuild.<p>\n     * \n     * @param index the index to update or rebuild\n     * @param report the report to write output messages to \n     * @param wait signals to wait until all the indexing threads are finished\n     * @param resourcesToIndex an (optional) list of <code>{@link CmsPublishedResource}<\/code> objects to update in the index\n     * @param documentCache a cache for the created search documents, to avoid multiple text extraction\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected synchronized void updateIndex(\n        CmsSearchIndex index,\n        I_CmsReport report,\n        boolean wait,\n        List resourcesToIndex,\n        Map documentCache) throws CmsException {\n\n        // copy the stored admin context for the indexing\n        CmsObject cms = OpenCms.initCmsObject(m_adminCms);\n        // make sure a report is available\n        if (report == null) {\n            report = new CmsLogReport(cms.getRequestContext().getLocale(), CmsSearchManager.class);\n        }\n        // set site root and project for this index\n        cms.getRequestContext().setSiteRoot(\"/\");\n        // switch to the index project\n        cms.getRequestContext().setCurrentProject(cms.readProject(index.getProject()));\n\n        if ((resourcesToIndex == null) || resourcesToIndex.isEmpty()) {\n            // rebuild the complete index\n\n            // create a new index writer\n            IndexWriter writer = index.getIndexWriter(true);\n\n            // create a new thread manager for the indexing threads\n            // please note: document cache _must_ be null for full rebuild \n            //              since there may be diffeences between online and offline projects,\n            //              which can only be ignored if a resource has just been published (then online=offline)\n            CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                report,\n                Long.parseLong(m_timeout),\n                index.getName(),\n                null);\n\n            try {\n\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n                // iterate all configured index sources of this index\n                Iterator sources = index.getSources().iterator();\n                while (sources.hasNext()) {\n                    // get the next index source\n                    CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                    // create the indexer\n                    I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                    // new index creation, use all resources from the index source\n                    indexer.rebuildIndex(writer, threadManager, source);\n                }\n\n                // wait for indexing threads to finish\n                while (wait && threadManager.isRunning()) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // just continue with the loop after interruption\n                    }\n                }\n                // optimize the generated index\n                try {\n                    writer.optimize();\n                } catch (IOException e) {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().key(\n                            Messages.LOG_IO_INDEX_WRITER_OPTIMIZE_1,\n                            index.getPath(),\n                            index.getName()), e);\n                    }\n                }\n\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n            } finally {\n                if (writer != null) {\n                    try {\n                        writer.close();\n                    } catch (IOException e) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            // show information about indexing runtime\n            threadManager.reportStatistics();\n\n        } else {\n            // update the existing index\n\n            List updateCollections = new ArrayList();\n\n            boolean hasResourcesToDelete = false;\n            boolean hasResourcesToUpdate = false;\n\n            // iterate all configured index sources of this index\n            Iterator sources = index.getSources().iterator();\n            while (sources.hasNext()) {\n                // get the next index source\n                CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                // create the indexer\n                I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                // collect the resources to update\n                CmsSearchIndexUpdateData updateData = indexer.getUpdateData(source, resourcesToIndex);\n                if (!updateData.isEmpty()) {\n                    // add the update collection to the internal pipeline\n                    updateCollections.add(updateData);\n                    hasResourcesToDelete = hasResourcesToDelete | updateData.hasResourcesToDelete();\n                    hasResourcesToUpdate = hasResourcesToUpdate | updateData.hasResourceToUpdate();\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n            if (hasResourcesToDelete) {\n                // delete the resource from the index\n                IndexReader reader = null;\n                try {\n                    reader = IndexReader.open(index.getPath());\n                } catch (IOException e) {\n                    LOG.error(\n                        Messages.get().key(Messages.LOG_IO_INDEX_READER_OPEN_2, index.getPath(), index.getName()),\n                        e);\n                }\n                if (reader != null) {\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourcesToDelete()) {\n                                updateCollection.getIndexer().deleteResources(\n                                    reader,\n                                    updateCollection.getResourcesToDelete());\n                            }\n                        }\n                    } finally {\n                        try {\n                            // close the reader after all resources have been deleted\n                            reader.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().key(\n                                Messages.LOG_IO_INDEX_READER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToUpdate) {\n\n                // create an index writer that updates the current index\n                IndexWriter writer = index.getIndexWriter(false);\n\n                if (writer != null) {\n\n                    // create a new thread manager\n                    CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                        report,\n                        Long.parseLong(m_timeout),\n                        index.getName(),\n                        documentCache);\n\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourceToUpdate()) {\n                                updateCollection.getIndexer().updateResources(\n                                    writer,\n                                    threadManager,\n                                    updateCollection.getResourcesToUpdate(),\n                                    index.getSources());\n                            }\n                        }\n                    } finally {\n                        try {\n                            writer.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n\n                    // wait for indexing threads to finish\n                    while (wait && threadManager.isRunning()) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // just continue with the loop after interruption\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n        }\n\n        // clear the cache for search results\n        m_resultCache.clear();\n    }","id":22527,"modified_method":"/**\n     * Updates (if required creates) the index with the given name.<p>\n     * \n     * If the optional List of <code>{@link CmsPublishedResource}<\/code> instances is provided, the index will be \n     * incrementally updated for these resources only. If this List is <code>null<\/code> or empty, \n     * the index will be fully rebuild.<p>\n     * \n     * @param index the index to update or rebuild\n     * @param report the report to write output messages to \n     * @param wait signals to wait until all the indexing threads are finished\n     * @param resourcesToIndex an (optional) list of <code>{@link CmsPublishedResource}<\/code> objects to update in the index\n     * @param documentCache a cache for the created search documents, to avoid multiple text extraction\n     * \n     * @throws CmsException if something goes wrong\n     */\n    protected synchronized void updateIndex(\n        CmsSearchIndex index,\n        I_CmsReport report,\n        boolean wait,\n        List resourcesToIndex,\n        Map documentCache) throws CmsException {\n\n        // copy the stored admin context for the indexing\n        CmsObject cms = OpenCms.initCmsObject(m_adminCms);\n        // make sure a report is available\n        if (report == null) {\n            report = new CmsLogReport(cms.getRequestContext().getLocale(), CmsSearchManager.class);\n        }\n        // set site root and project for this index\n        cms.getRequestContext().setSiteRoot(\"/\");\n        // switch to the index project\n        cms.getRequestContext().setCurrentProject(cms.readProject(index.getProject()));\n\n        if ((resourcesToIndex == null) || resourcesToIndex.isEmpty()) {\n            // rebuild the complete index\n\n            // create a new index writer\n            IndexWriter writer = index.getIndexWriter(true);\n\n            // create a new thread manager for the indexing threads\n            // please note: document cache _must_ be null for full rebuild \n            //              since there may be diffeences between online and offline projects,\n            //              which can only be ignored if a resource has just been published (then online=offline)\n            CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                report,\n                Long.parseLong(m_timeout),\n                index.getName(),\n                null);\n\n            try {\n\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n                // iterate all configured index sources of this index\n                Iterator sources = index.getSources().iterator();\n                while (sources.hasNext()) {\n                    // get the next index source\n                    CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                    // create the indexer\n                    I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                    // new index creation, use all resources from the index source\n                    indexer.rebuildIndex(writer, threadManager, source);\n                }\n\n                // wait for indexing threads to finish\n                while (wait && threadManager.isRunning()) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // just continue with the loop after interruption\n                    }\n                }\n                // optimize the generated index\n                try {\n                    writer.optimize();\n                } catch (IOException e) {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().key(\n                            Messages.LOG_IO_INDEX_WRITER_OPTIMIZE_1,\n                            index.getPath(),\n                            index.getName()), e);\n                    }\n                }\n\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_REBUILD_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n\n            } finally {\n                if (writer != null) {\n                    try {\n                        writer.close();\n                    } catch (IOException e) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            // show information about indexing runtime\n            threadManager.reportStatistics();\n\n        } else {\n            // update the existing index\n\n            List updateCollections = new ArrayList();\n\n            boolean hasResourcesToDelete = false;\n            boolean hasResourcesToUpdate = false;\n\n            // iterate all configured index sources of this index\n            Iterator sources = index.getSources().iterator();\n            while (sources.hasNext()) {\n                // get the next index source\n                CmsSearchIndexSource source = (CmsSearchIndexSource)sources.next();\n                // create the indexer\n                I_CmsIndexer indexer = source.getIndexer().newInstance(cms, report, index);\n                // collect the resources to update\n                CmsSearchIndexUpdateData updateData = indexer.getUpdateData(source, resourcesToIndex);\n                if (!updateData.isEmpty()) {\n                    // add the update collection to the internal pipeline\n                    updateCollections.add(updateData);\n                    hasResourcesToDelete = hasResourcesToDelete | updateData.hasResourcesToDelete();\n                    hasResourcesToUpdate = hasResourcesToUpdate | updateData.hasResourceToUpdate();\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput start information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_BEGIN_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n            if (hasResourcesToDelete) {\n                // delete the resource from the index\n                IndexReader reader = null;\n                try {\n                    reader = IndexReader.open(index.getPath());\n                } catch (IOException e) {\n                    LOG.error(\n                        Messages.get().key(Messages.LOG_IO_INDEX_READER_OPEN_2, index.getPath(), index.getName()),\n                        e);\n                }\n                if (reader != null) {\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourcesToDelete()) {\n                                updateCollection.getIndexer().deleteResources(\n                                    reader,\n                                    updateCollection.getResourcesToDelete());\n                            }\n                        }\n                    } finally {\n                        try {\n                            // close the reader after all resources have been deleted\n                            reader.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().key(\n                                Messages.LOG_IO_INDEX_READER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToUpdate) {\n\n                // create an index writer that updates the current index\n                IndexWriter writer = index.getIndexWriter(false);\n\n                if (writer != null) {\n\n                    // create a new thread manager\n                    CmsIndexingThreadManager threadManager = new CmsIndexingThreadManager(\n                        report,\n                        Long.parseLong(m_timeout),\n                        index.getName(),\n                        documentCache);\n\n                    try {\n                        Iterator i = updateCollections.iterator();\n                        while (i.hasNext()) {\n                            CmsSearchIndexUpdateData updateCollection = (CmsSearchIndexUpdateData)i.next();\n                            if (updateCollection.hasResourceToUpdate()) {\n                                updateCollection.getIndexer().updateResources(\n                                    writer,\n                                    threadManager,\n                                    updateCollection.getResourcesToUpdate());\n                            }\n                        }\n                    } finally {\n                        try {\n                            writer.close();\n                        } catch (IOException e) {\n                            LOG.error(Messages.get().key(\n                                Messages.LOG_IO_INDEX_WRITER_CLOSE_2,\n                                index.getPath(),\n                                index.getName()), e);\n                        }\n                    }\n\n                    // wait for indexing threads to finish\n                    while (wait && threadManager.isRunning()) {\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            // just continue with the loop after interruption\n                        }\n                    }\n                }\n            }\n\n            if (hasResourcesToDelete || hasResourcesToUpdate) {\n                // ouput finish information on the report\n                report.println(\n                    Messages.get().container(Messages.RPT_SEARCH_INDEXING_UPDATE_END_1, index.getName()),\n                    I_CmsReport.FORMAT_HEADLINE);\n            }\n\n        }\n\n        // clear the cache for search results\n        m_resultCache.clear();\n    }","commit_id":"ed977f6fe7e99e954f4f2af95e7473a1357160eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#updateResources(org.apache.lucene.index.IndexWriter, org.opencms.search.CmsIndexingThreadManager, java.util.List, java.util.List)\n     */\n    public void updateResources(IndexWriter writer, CmsIndexingThreadManager threadManager, List resourcesToUpdate, List sources)\n    throws CmsIndexException {\n\n        if ((resourcesToUpdate == null) || resourcesToUpdate.isEmpty()) {\n            // nothing to update\n            return;\n        }\n\n        // collect all source folders of the index, required for later sibling check\n        Set sourceFolderSet = new HashSet();\n        Iterator k = sources.iterator();\n        while (k.hasNext()) {            \n            CmsSearchIndexSource source = (CmsSearchIndexSource)k.next();\n            sourceFolderSet.addAll(source.getResourcesNames());\n        }\n        List sourceFolders = new ArrayList(sourceFolderSet);\n        \n        // contains all resources already updated to avoid multiple updates in case of siblings\n        List resourcesAlreadyUpdated = new ArrayList(resourcesToUpdate.size());\n\n        // index all resources that in the given list\n        Iterator i = resourcesToUpdate.iterator();\n        while (i.hasNext()) {\n            CmsPublishedResource res = (CmsPublishedResource)i.next();\n            CmsResource resource = null;\n            try {\n                resource = m_cms.readResource(res.getRootPath());\n            } catch (CmsException e) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().key(\n                        Messages.LOG_UNABLE_TO_READ_RESOURCE_2,\n                        resource.getRootPath(),\n                        m_index.getName()), e);\n                }\n            }\n            if (resource != null) {\n                List resources = new ArrayList();\n                if (resource.getSiblingCount() > 0) {\n                    // resource has siblings, all siblings must be updated (since the content is the same)\n                    try {\n                        List siblings = m_cms.readSiblings(resource.getRootPath(), CmsResourceFilter.DEFAULT);\n                        Iterator it = siblings.iterator();\n                        while (it.hasNext()) {\n                            // check if the sibling is part of one of the index sources\n                            CmsResource sibling = (CmsResource)it.next();\n                            // use utility method from CmsProject to check if published resource is \"inside\" this index source\n                            if (CmsProject.isInsideProject(sourceFolders, sibling)) {\n                                // the sibling is \"inside\" this index\n                                resources.add(sibling);\n                            }\n                        }                        \n                        \n                    } catch (CmsException e) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().key(\n                                Messages.LOG_UNABLE_TO_READ_SIBLINGS_2,\n                                resource.getRootPath(),\n                                m_index.getName()), e);\n                        }\n                        // ensure at last the \"known\" sibling is updated\n                        resources.add(resource);\n                    }\n                } else {\n                    // resource has no siblings, only one update required    \n                    resources.add(resource);\n                }\n                // update all siblings\n                Iterator j = resources.iterator();\n                while (j.hasNext()) {\n                    CmsResource r = (CmsResource)j.next();\n                    if (!resourcesAlreadyUpdated.contains(r.getRootPath())) {\n                        // ensure resources are only indexed once per update\n                        resourcesAlreadyUpdated.add(r.getRootPath());\n                        updateResource(writer, threadManager, r);\n                    }\n                }\n            }\n        }\n    }","id":22528,"modified_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#updateResources(org.apache.lucene.index.IndexWriter, org.opencms.search.CmsIndexingThreadManager, java.util.List)\n     */\n    public void updateResources(IndexWriter writer, CmsIndexingThreadManager threadManager, List resourcesToUpdate)\n    throws CmsIndexException {\n\n        if ((resourcesToUpdate == null) || resourcesToUpdate.isEmpty()) {\n            // nothing to update\n            return;\n        }\n\n        // contains all resources already updated to avoid multiple updates in case of siblings\n        List resourcesAlreadyUpdated = new ArrayList(resourcesToUpdate.size());\n\n        // index all resources that in the given list\n        Iterator i = resourcesToUpdate.iterator();\n        while (i.hasNext()) {\n            CmsPublishedResource res = (CmsPublishedResource)i.next();\n            CmsResource resource = null;\n            try {\n                resource = m_cms.readResource(res.getRootPath());\n            } catch (CmsException e) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(Messages.get().key(\n                        Messages.LOG_UNABLE_TO_READ_RESOURCE_2,\n                        resource.getRootPath(),\n                        m_index.getName()), e);\n                }\n            }\n            if (resource != null) {\n                if (!resourcesAlreadyUpdated.contains(resource.getRootPath())) {\n                    // ensure resources are only indexed once per update\n                    resourcesAlreadyUpdated.add(resource.getRootPath());\n                    updateResource(writer, threadManager, resource);\n                }\n            }\n        }\n    }","commit_id":"ed977f6fe7e99e954f4f2af95e7473a1357160eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#getUpdateData(org.opencms.search.CmsSearchIndexSource, java.util.List)\n     */\n    public CmsSearchIndexUpdateData getUpdateData(CmsSearchIndexSource source, List publishedResources) {\n\n        // create a new update collection from this indexer and the given index source\n        CmsSearchIndexUpdateData result = new CmsSearchIndexUpdateData(source, this);\n\n        Iterator i = publishedResources.iterator();\n        while (i.hasNext()) {\n            // check all published resources if they match this indexer / source\n            CmsPublishedResource resource = (CmsPublishedResource)i.next();\n            // VFS resources will always have a structure id\n            if (!resource.getStructureId().isNullUUID()) {\n                // use utility method from CmsProject to check if published resource is \"inside\" this index source\n                if (CmsProject.isInsideProject(source.getResourcesNames(), resource.getRootPath())) {\n                    // the resource is \"inside\" this index source\n                    if (resource.isNew()) {\n                        // new resource just needs to be updated\n                        if (isResourceInTimeWindow(resource)) {\n                            // update only if resource is in time window\n                            result.addResourceToUpdate(resource);\n                        }\n                    } else if (resource.isDeleted()) {\n                        // deleted resource just needs to be removed\n                        result.addResourceToDelete(resource);\n                    } else if (resource.isChanged()) {\n                        // changed resource must be removed first, and then updated\n                        result.addResourceToDelete(resource);\n                        if (isResourceInTimeWindow(resource)) {\n                            // update only if resource is in time window\n                            result.addResourceToUpdate(resource);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }","id":22529,"modified_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#getUpdateData(org.opencms.search.CmsSearchIndexSource, java.util.List)\n     */\n    public CmsSearchIndexUpdateData getUpdateData(CmsSearchIndexSource source, List publishedResources) {\n\n        // create a new update collection from this indexer and the given index source\n        CmsSearchIndexUpdateData result = new CmsSearchIndexUpdateData(source, this);\n\n        Iterator i = publishedResources.iterator();\n        while (i.hasNext()) {\n            // check all published resources if they match this indexer / source\n            CmsPublishedResource resource = (CmsPublishedResource)i.next();\n            // VFS resources will always have a structure id\n            if (!resource.getStructureId().isNullUUID()) {\n                // use utility method from CmsProject to check if published resource is \"inside\" this index source\n                if (CmsProject.isInsideProject(source.getResourcesNames(), resource.getRootPath())) {\n                    // the resource is \"inside\" this index source\n                    if (resource.isNew()) {\n                        // new resource just needs to be updated\n                        if (isResourceInTimeWindow(resource)) {\n                            // update only if resource is in time window\n                            result.addResourceToUpdate(resource);\n                        }\n                    } else if (resource.isDeleted()) {\n                        // deleted resource just needs to be removed\n                        result.addResourceToDelete(resource);\n                    } else if (resource.isChanged() || resource.isUnChanged()) {\n                        // changed (or unchaged) resource must be removed first, and then updated\n                        // note: unchanged resources can be siblings that have been added from the online project,\n                        //       these must be treated as if the resource had changed\n                        result.addResourceToDelete(resource);\n                        if (isResourceInTimeWindow(resource)) {\n                            // update only if resource is in time window\n                            result.addResourceToUpdate(resource);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","commit_id":"ed977f6fe7e99e954f4f2af95e7473a1357160eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#deleteResources(org.apache.lucene.index.IndexReader, java.util.List)\n     */\n    public void deleteResources(IndexReader reader, List resourcesToDelete) {\n\n        if ((resourcesToDelete == null) || resourcesToDelete.isEmpty()) {\n            // nothing to d�lete\n            return;\n        }\n\n        // contains all resources already deleted to avoid multiple deleting in case of siblings\n        List resourcesAlreadyDeleted = new ArrayList(resourcesToDelete.size());\n\n        Iterator i = resourcesToDelete.iterator();\n        while (i.hasNext()) {\n            // iterate all resources in the given list of resources to delete\n            CmsPublishedResource res = (CmsPublishedResource)i.next();\n\n            List rootPaths = new ArrayList();\n            if (res.getSiblingCount() > 0) {\n                // the published resource has siblings, all siblings must be updated since they share the same content\n                List siblings = null;\n                try {\n                    siblings = m_cms.readSiblings(res.getRootPath(), CmsResourceFilter.DEFAULT);\n                } catch (CmsException e) {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().key(\n                            Messages.LOG_UNABLE_TO_READ_SIBLINGS_2,\n                            res.getRootPath(),\n                            m_index.getName()), e);\n                    }\n                }\n                if (siblings != null) {\n                    // update all siblings\n                    Iterator j = siblings.iterator();\n                    while (j.hasNext()) {\n                        CmsResource sibling = (CmsResource)j.next();\n                        rootPaths.add(sibling.getRootPath());\n                    }\n                } else {\n                    // error, make sure at last the \"known\" sibling is updated\n                    rootPaths.add(res.getRootPath());\n                }\n            } else {\n                // no siblings, just use path of the single resource\n                rootPaths.add(res.getRootPath());\n            }\n            Iterator j = rootPaths.iterator();\n            while (j.hasNext()) {\n                String rootPath = (String)j.next();\n                if (!resourcesAlreadyDeleted.contains(rootPath)) {\n                    // ensure siblings are only deleted once per update\n                    resourcesAlreadyDeleted.add(rootPath);\n                    // search for an exact match on the document root path\n                    Term term = new Term(I_CmsDocumentFactory.DOC_PATH, rootPath);\n                    try {\n                        // delete all documents with this term from the index\n                        reader.delete(term);\n                    } catch (IOException e) {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(Messages.get().key(\n                                Messages.LOG_IO_INDEX_DOCUMENT_DELETE_2,\n                                rootPath,\n                                m_index.getName()), e);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":22530,"modified_method":"/**\n     * @see org.opencms.search.I_CmsIndexer#deleteResources(org.apache.lucene.index.IndexReader, java.util.List)\n     */\n    public void deleteResources(IndexReader reader, List resourcesToDelete) {\n\n        if ((resourcesToDelete == null) || resourcesToDelete.isEmpty()) {\n            // nothing to d�lete\n            return;\n        }\n\n        // contains all resources already deleted to avoid multiple deleting in case of siblings\n        List resourcesAlreadyDeleted = new ArrayList(resourcesToDelete.size());\n\n        Iterator i = resourcesToDelete.iterator();\n        while (i.hasNext()) {\n            // iterate all resources in the given list of resources to delete\n            CmsPublishedResource res = (CmsPublishedResource)i.next();\n            String rootPath = res.getRootPath();\n            if (!resourcesAlreadyDeleted.contains(rootPath)) {\n                // ensure siblings are only deleted once per update\n                resourcesAlreadyDeleted.add(rootPath);\n                // search for an exact match on the document root path\n                Term term = new Term(I_CmsDocumentFactory.DOC_PATH, rootPath);\n                try {\n                    // delete all documents with this term from the index\n                    reader.delete(term);\n                } catch (IOException e) {\n                    if (LOG.isWarnEnabled()) {\n                        LOG.warn(Messages.get().key(\n                            Messages.LOG_IO_INDEX_DOCUMENT_DELETE_2,\n                            rootPath,\n                            m_index.getName()), e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"ed977f6fe7e99e954f4f2af95e7473a1357160eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the content.<p>\n     *\n     * @param resUtil the resource util\n     * @param iconPath the resource icon\n     * @param state the resource state\n     */\n    public void initContent(CmsResourceUtil resUtil, String iconPath, CmsResourceState state) {\n\n        String content = \"<img src=\\\"\" + iconPath + \"\\\" />\";\n\n        if (resUtil != null) {\n            String lockIcon;\n            switch (resUtil.getLockState()) {\n                case 1:\n                    lockIcon = OpenCmsTheme.LOCK_OTHER;\n                    break;\n\n                case 2:\n                    lockIcon = OpenCmsTheme.LOCK_SHARED;\n                    break;\n                case 3:\n                    lockIcon = OpenCmsTheme.LOCK_USER;\n                    break;\n                default:\n                    lockIcon = null;\n            }\n            if (lockIcon != null) {\n                content += getOverlaySpan(\n                    lockIcon,\n                    CmsVaadinUtils.getMessageText(\n                        Messages.GUI_EXPLORER_LIST_ACTION_LOCK_NAME_2,\n                        resUtil.getLockedByName(),\n                        resUtil.getLockedInProjectName()));\n            }\n        }\n        if (state != null) {\n\n            String title = resUtil != null\n            ? CmsVaadinUtils.getMessageText(org.opencms.workplace.commons.Messages.GUI_LABEL_USER_LAST_MODIFIED_0)\n                + \" \"\n                + resUtil.getUserLastModified()\n            : null;\n            if (state.isChanged()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_CHANGED, title);\n            } else if (state.isNew()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_NEW, title);\n            }\n        }\n        if ((resUtil != null) && (resUtil.getLinkType() == 1)) {\n            content += getOverlaySpan(OpenCmsTheme.SIBLING, null);\n        }\n        setValue(content);\n    }","id":22531,"modified_method":"/**\n     * Initializes the content.<p>\n     *\n     * @param resUtil the resource util\n     * @param iconPath the resource icon\n     * @param state the resource state\n     */\n    public void initContent(CmsResourceUtil resUtil, String iconPath, CmsResourceState state) {\n\n        String content = \"<img src=\\\"\" + iconPath + \"\\\" />\";\n\n        if (resUtil != null) {\n            String lockIcon;\n            switch (resUtil.getLockState()) {\n                case 1:\n                    lockIcon = OpenCmsTheme.LOCK_OTHER;\n                    break;\n\n                case 2:\n                    lockIcon = OpenCmsTheme.LOCK_SHARED;\n                    break;\n                case 3:\n                    lockIcon = OpenCmsTheme.LOCK_USER;\n                    break;\n                default:\n                    lockIcon = null;\n            }\n            if (lockIcon != null) {\n                content += getOverlaySpan(\n                    lockIcon,\n                    CmsVaadinUtils.getMessageText(\n                        Messages.GUI_EXPLORER_LIST_ACTION_LOCK_NAME_2,\n                        resUtil.getLockedByName(),\n                        resUtil.getLockedInProjectName()));\n            }\n        }\n        if (state != null) {\n\n            String title = resUtil != null\n            ? CmsVaadinUtils.getMessageText(org.opencms.workplace.commons.Messages.GUI_LABEL_USER_LAST_MODIFIED_0)\n                + \" \"\n                + resUtil.getUserLastModified()\n            : null;\n            if (state.isChanged() || state.isDeleted()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_CHANGED, title);\n            } else if (state.isNew()) {\n                content += getOverlaySpan(OpenCmsTheme.STATE_NEW, title);\n            }\n        }\n        if ((resUtil != null) && (resUtil.getLinkType() == 1)) {\n            content += getOverlaySpan(OpenCmsTheme.SIBLING, null);\n        }\n        setValue(content);\n    }","commit_id":"71fc5392f1746b8a30e917e706fa1c2431130fe0","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private List<EditableSModelDescriptor> getModelsToSave() {\n    List<EditableSModelDescriptor> modelsToSave = new ArrayList<EditableSModelDescriptor>();\n    for (SModelDescriptor md : myModelsWithOwners.keySet()) {\n      if (md instanceof EditableSModelDescriptor) {\n        EditableSModelDescriptor emd = ((EditableSModelDescriptor) md);\n        if (emd.isChanged()) {\n          modelsToSave.add(emd);\n        }\n      }\n    }\n    return modelsToSave;\n  }","id":22532,"modified_method":"private List<EditableSModelDescriptor> getModelsToSave() {\n    List<EditableSModelDescriptor> modelsToSave = new ArrayList<EditableSModelDescriptor>();\n    for (SModelDescriptor md : myModelsWithOwners.keySet()) {\n      if (md instanceof EditableSModelDescriptor) {\n        EditableSModelDescriptor emd = ((EditableSModelDescriptor) md);\n        // HOTFIX MPS-13326\n        if (emd.isChanged() && !emd.isPackaged()) {\n          modelsToSave.add(emd);\n        }\n      }\n    }\n    return modelsToSave;\n  }","commit_id":"b5a1ba2fb5213be5f46a159ab63650553a3bd6bf","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent ae) {\n            int[] rows = tagTable.getSelectedRows();\n            Set<String> values = new TreeSet<>();\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            if (rows.length == 0 || sel.isEmpty()) return;\n\n            for (int row: rows) {\n                String key = tagData.getValueAt(row, 0).toString();\n                if (sel.isEmpty())\n                    return;\n                for (OsmPrimitive p : sel) {\n                    Collection<String> s = getString(p, key);\n                    if (s != null) {\n                        values.addAll(s);\n                    }\n                }\n            }\n            if (!values.isEmpty()) {\n                Utils.copyToClipboard(Utils.join(\"\\n\", values));\n            }\n        }","id":22533,"modified_method":"@Override\n        public void actionPerformed(ActionEvent ae) {\n            int[] rows = tagTable.getSelectedRows();\n            Set<String> values = new TreeSet<>();\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            if (rows.length == 0 || sel.isEmpty()) return;\n\n            for (int row: rows) {\n                String key = editHelper.getDataKey(row);\n                if (sel.isEmpty())\n                    return;\n                for (OsmPrimitive p : sel) {\n                    Collection<String> s = getString(p, key);\n                    if (s != null) {\n                        values.addAll(s);\n                    }\n                }\n            }\n            if (!values.isEmpty()) {\n                Utils.copyToClipboard(Utils.join(\"\\n\", values));\n            }\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void selectionChanged(Collection<? extends OsmPrimitive> newSelection) {\n        if (!isVisible())\n            return;\n        if (tagTable == null)\n            return; // selection changed may be received in base class constructor before init\n        if (tagTable.getCellEditor() != null) {\n            tagTable.getCellEditor().cancelCellEditing();\n        }\n\n        // Ignore parameter as we do not want to operate always on real selection here, especially in draw mode\n        Collection<OsmPrimitive> newSel = Main.main.getInProgressSelection();\n        if (newSel == null) {\n            newSel = Collections.<OsmPrimitive>emptyList();\n        }\n\n        String selectedTag;\n        Relation selectedRelation = null;\n        selectedTag = editHelper.getChangedKey(); // select last added or last edited key by default\n        if (selectedTag == null && tagTable.getSelectedRowCount() == 1) {\n            selectedTag = (String) tagData.getValueAt(tagTable.getSelectedRow(), 0);\n        }\n        if (membershipTable.getSelectedRowCount() == 1) {\n            selectedRelation = (Relation) membershipData.getValueAt(membershipTable.getSelectedRow(), 0);\n        }\n\n        // re-load tag data\n        tagData.setRowCount(0);\n\n        final boolean displayDiscardableKeys = Main.pref.getBoolean(\"display.discardable-keys\", false);\n        final Map<String, Integer> keyCount = new HashMap<>();\n        final Map<String, String> tags = new HashMap<>();\n        valueCount.clear();\n        Set<TaggingPresetType> types = EnumSet.noneOf(TaggingPresetType.class);\n        for (OsmPrimitive osm : newSel) {\n            types.add(TaggingPresetType.forPrimitive(osm));\n            for (String key : osm.keySet()) {\n                if (displayDiscardableKeys || !OsmPrimitive.getDiscardableKeys().contains(key)) {\n                    String value = osm.get(key);\n                    keyCount.put(key, keyCount.containsKey(key) ? keyCount.get(key) + 1 : 1);\n                    if (valueCount.containsKey(key)) {\n                        Map<String, Integer> v = valueCount.get(key);\n                        v.put(value, v.containsKey(value) ? v.get(value) + 1 : 1);\n                    } else {\n                        Map<String, Integer> v = new TreeMap<>();\n                        v.put(value, 1);\n                        valueCount.put(key, v);\n                    }\n                }\n            }\n        }\n        for (Entry<String, Map<String, Integer>> e : valueCount.entrySet()) {\n            int count = 0;\n            for (Entry<String, Integer> e1 : e.getValue().entrySet()) {\n                count += e1.getValue();\n            }\n            if (count < newSel.size()) {\n                e.getValue().put(\"\", newSel.size() - count);\n            }\n            tagData.addRow(new Object[]{e.getKey(), e.getValue()});\n            tags.put(e.getKey(), e.getValue().size() == 1\n                    ? e.getValue().keySet().iterator().next() : tr(\"<different>\"));\n        }\n\n        membershipData.setRowCount(0);\n\n        Map<Relation, MemberInfo> roles = new HashMap<>();\n        for (OsmPrimitive primitive: newSel) {\n            for (OsmPrimitive ref: primitive.getReferrers(true)) {\n                if (ref instanceof Relation && !ref.isIncomplete() && !ref.isDeleted()) {\n                    Relation r = (Relation) ref;\n                    MemberInfo mi = roles.get(r);\n                    if (mi == null) {\n                        mi = new MemberInfo(newSel);\n                    }\n                    roles.put(r, mi);\n                    int i = 1;\n                    for (RelationMember m : r.getMembers()) {\n                        if (m.getMember() == primitive) {\n                            mi.add(m, i);\n                        }\n                        ++i;\n                    }\n                }\n            }\n        }\n\n        List<Relation> sortedRelations = new ArrayList<>(roles.keySet());\n        Collections.sort(sortedRelations, new Comparator<Relation>() {\n            @Override\n            public int compare(Relation o1, Relation o2) {\n                int comp = Boolean.valueOf(o1.isDisabledAndHidden()).compareTo(o2.isDisabledAndHidden());\n                return comp != 0 ? comp : DefaultNameFormatter.getInstance().getRelationComparator().compare(o1, o2);\n            }\n        });\n\n        for (Relation r: sortedRelations) {\n            membershipData.addRow(new Object[]{r, roles.get(r)});\n        }\n\n        presets.updatePresets(types, tags, presetHandler);\n\n        membershipTable.getTableHeader().setVisible(membershipData.getRowCount() > 0);\n        membershipTable.setVisible(membershipData.getRowCount() > 0);\n\n        boolean hasSelection = !newSel.isEmpty();\n        boolean hasTags = hasSelection && tagData.getRowCount() > 0;\n        boolean hasMemberships = hasSelection && membershipData.getRowCount() > 0;\n        addAction.setEnabled(hasSelection);\n        editAction.setEnabled(hasTags || hasMemberships);\n        deleteAction.setEnabled(hasTags || hasMemberships);\n        tagTable.setVisible(hasTags);\n        tagTable.getTableHeader().setVisible(hasTags);\n        tagTableFilter.setVisible(hasTags);\n        selectSth.setVisible(!hasSelection);\n        pluginHook.setVisible(hasSelection);\n\n        int selectedIndex;\n        if (selectedTag != null && (selectedIndex = findRow(tagData, selectedTag)) != -1) {\n            tagTable.changeSelection(selectedIndex, 0, false, false);\n        } else if (selectedRelation != null && (selectedIndex = findRow(membershipData, selectedRelation)) != -1) {\n            membershipTable.changeSelection(selectedIndex, 0, false, false);\n        } else if (hasTags) {\n            tagTable.changeSelection(0, 0, false, false);\n        } else if (hasMemberships) {\n            membershipTable.changeSelection(0, 0, false, false);\n        }\n\n        if (tagData.getRowCount() != 0 || membershipData.getRowCount() != 0) {\n            if (newSel.size() > 1) {\n                setTitle(tr(\"Objects: {2} / Tags: {0} / Memberships: {1}\",\n                    tagData.getRowCount(), membershipData.getRowCount(), newSel.size()));\n            } else {\n                setTitle(tr(\"Tags: {0} / Memberships: {1}\",\n                    tagData.getRowCount(), membershipData.getRowCount()));\n            }\n        } else {\n            setTitle(tr(\"Tags / Memberships\"));\n        }\n    }","id":22534,"modified_method":"@Override\n    public void selectionChanged(Collection<? extends OsmPrimitive> newSelection) {\n        if (!isVisible())\n            return;\n        if (tagTable == null)\n            return; // selection changed may be received in base class constructor before init\n        if (tagTable.getCellEditor() != null) {\n            tagTable.getCellEditor().cancelCellEditing();\n        }\n\n        // Ignore parameter as we do not want to operate always on real selection here, especially in draw mode\n        Collection<OsmPrimitive> newSel = Main.main.getInProgressSelection();\n        if (newSel == null) {\n            newSel = Collections.<OsmPrimitive>emptyList();\n        }\n\n        String selectedTag;\n        Relation selectedRelation = null;\n        selectedTag = editHelper.getChangedKey(); // select last added or last edited key by default\n        if (selectedTag == null && tagTable.getSelectedRowCount() == 1) {\n            selectedTag = editHelper.getDataKey(tagTable.getSelectedRow());\n        }\n        if (membershipTable.getSelectedRowCount() == 1) {\n            selectedRelation = (Relation) membershipData.getValueAt(membershipTable.getSelectedRow(), 0);\n        }\n\n        // re-load tag data\n        tagData.setRowCount(0);\n\n        final boolean displayDiscardableKeys = Main.pref.getBoolean(\"display.discardable-keys\", false);\n        final Map<String, Integer> keyCount = new HashMap<>();\n        final Map<String, String> tags = new HashMap<>();\n        valueCount.clear();\n        Set<TaggingPresetType> types = EnumSet.noneOf(TaggingPresetType.class);\n        for (OsmPrimitive osm : newSel) {\n            types.add(TaggingPresetType.forPrimitive(osm));\n            for (String key : osm.keySet()) {\n                if (displayDiscardableKeys || !OsmPrimitive.getDiscardableKeys().contains(key)) {\n                    String value = osm.get(key);\n                    keyCount.put(key, keyCount.containsKey(key) ? keyCount.get(key) + 1 : 1);\n                    if (valueCount.containsKey(key)) {\n                        Map<String, Integer> v = valueCount.get(key);\n                        v.put(value, v.containsKey(value) ? v.get(value) + 1 : 1);\n                    } else {\n                        Map<String, Integer> v = new TreeMap<>();\n                        v.put(value, 1);\n                        valueCount.put(key, v);\n                    }\n                }\n            }\n        }\n        for (Entry<String, Map<String, Integer>> e : valueCount.entrySet()) {\n            int count = 0;\n            for (Entry<String, Integer> e1 : e.getValue().entrySet()) {\n                count += e1.getValue();\n            }\n            if (count < newSel.size()) {\n                e.getValue().put(\"\", newSel.size() - count);\n            }\n            tagData.addRow(new Object[]{e.getKey(), e.getValue()});\n            tags.put(e.getKey(), e.getValue().size() == 1\n                    ? e.getValue().keySet().iterator().next() : tr(\"<different>\"));\n        }\n\n        membershipData.setRowCount(0);\n\n        Map<Relation, MemberInfo> roles = new HashMap<>();\n        for (OsmPrimitive primitive: newSel) {\n            for (OsmPrimitive ref: primitive.getReferrers(true)) {\n                if (ref instanceof Relation && !ref.isIncomplete() && !ref.isDeleted()) {\n                    Relation r = (Relation) ref;\n                    MemberInfo mi = roles.get(r);\n                    if (mi == null) {\n                        mi = new MemberInfo(newSel);\n                    }\n                    roles.put(r, mi);\n                    int i = 1;\n                    for (RelationMember m : r.getMembers()) {\n                        if (m.getMember() == primitive) {\n                            mi.add(m, i);\n                        }\n                        ++i;\n                    }\n                }\n            }\n        }\n\n        List<Relation> sortedRelations = new ArrayList<>(roles.keySet());\n        Collections.sort(sortedRelations, new Comparator<Relation>() {\n            @Override\n            public int compare(Relation o1, Relation o2) {\n                int comp = Boolean.valueOf(o1.isDisabledAndHidden()).compareTo(o2.isDisabledAndHidden());\n                return comp != 0 ? comp : DefaultNameFormatter.getInstance().getRelationComparator().compare(o1, o2);\n            }\n        });\n\n        for (Relation r: sortedRelations) {\n            membershipData.addRow(new Object[]{r, roles.get(r)});\n        }\n\n        presets.updatePresets(types, tags, presetHandler);\n\n        membershipTable.getTableHeader().setVisible(membershipData.getRowCount() > 0);\n        membershipTable.setVisible(membershipData.getRowCount() > 0);\n\n        boolean hasSelection = !newSel.isEmpty();\n        boolean hasTags = hasSelection && tagData.getRowCount() > 0;\n        boolean hasMemberships = hasSelection && membershipData.getRowCount() > 0;\n        addAction.setEnabled(hasSelection);\n        editAction.setEnabled(hasTags || hasMemberships);\n        deleteAction.setEnabled(hasTags || hasMemberships);\n        tagTable.setVisible(hasTags);\n        tagTable.getTableHeader().setVisible(hasTags);\n        tagTableFilter.setVisible(hasTags);\n        selectSth.setVisible(!hasSelection);\n        pluginHook.setVisible(hasSelection);\n\n        int selectedIndex;\n        if (selectedTag != null && (selectedIndex = findViewRow(tagTable, tagData, selectedTag)) != -1) {\n            tagTable.changeSelection(selectedIndex, 0, false, false);\n        } else if (selectedRelation != null && (selectedIndex = findViewRow(membershipTable, membershipData, selectedRelation)) != -1) {\n            membershipTable.changeSelection(selectedIndex, 0, false, false);\n        } else if (hasTags) {\n            tagTable.changeSelection(0, 0, false, false);\n        } else if (hasMemberships) {\n            membershipTable.changeSelection(0, 0, false, false);\n        }\n\n        if (tagData.getRowCount() != 0 || membershipData.getRowCount() != 0) {\n            if (newSel.size() > 1) {\n                setTitle(tr(\"Objects: {2} / Tags: {0} / Memberships: {1}\",\n                    tagData.getRowCount(), membershipData.getRowCount(), newSel.size()));\n            } else {\n                setTitle(tr(\"Tags: {0} / Memberships: {1}\",\n                    tagData.getRowCount(), membershipData.getRowCount()));\n            }\n        } else {\n            setTitle(tr(\"Tags / Memberships\"));\n        }\n    }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Returns the selected tag.\n     * @return The current selected tag\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Tag getSelectedProperty() {\n        int row = tagTable.getSelectedRow();\n        if (row == -1) return null;\n        Map<String, Integer> map = (TreeMap<String, Integer>) tagData.getValueAt(row, 1);\n        return new Tag(\n                tagData.getValueAt(row, 0).toString(),\n                map.size() > 1 ? \"\" : map.keySet().iterator().next());\n    }","id":22535,"modified_method":"/**\n     * Returns the selected tag.\n     * @return The current selected tag\n     */\n    public Tag getSelectedProperty() {\n        int row = tagTable.getSelectedRow();\n        if (row == -1) return null;\n        Map<String, Integer> map = editHelper.getDataValues(row);\n        return new Tag(\n                editHelper.getDataKey(row),\n                map.size() > 1 ? \"\" : map.keySet().iterator().next());\n    }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            try {\n                String base = Main.pref.get(\"url.openstreetmap-wiki\", \"http://wiki.openstreetmap.org/wiki/\");\n                String lang = LanguageInfo.getWikiLanguagePrefix();\n                final List<URI> uris = new ArrayList<>();\n                int row;\n                if (tagTable.getSelectedRowCount() == 1) {\n                    row = tagTable.getSelectedRow();\n                    String key = Utils.encodeUrl(tagData.getValueAt(row, 0).toString());\n                    @SuppressWarnings(\"unchecked\")\n                    Map<String, Integer> m = (Map<String, Integer>) tagData.getValueAt(row, 1);\n                    String val = Utils.encodeUrl(m.entrySet().iterator().next().getKey());\n\n                    uris.add(new URI(String.format(\"%s%sTag:%s=%s\", base, lang, key, val)));\n                    uris.add(new URI(String.format(\"%sTag:%s=%s\", base, key, val)));\n                    uris.add(new URI(String.format(\"%s%sKey:%s\", base, lang, key)));\n                    uris.add(new URI(String.format(\"%sKey:%s\", base, key)));\n                    uris.add(new URI(String.format(\"%s%sMap_Features\", base, lang)));\n                    uris.add(new URI(String.format(\"%sMap_Features\", base)));\n                } else if (membershipTable.getSelectedRowCount() == 1) {\n                    row = membershipTable.getSelectedRow();\n                    String type = ((Relation) membershipData.getValueAt(row, 0)).get(\"type\");\n                    if (type != null) {\n                        type = Utils.encodeUrl(type);\n                    }\n\n                    if (type != null && !type.isEmpty()) {\n                        uris.add(new URI(String.format(\"%s%sRelation:%s\", base, lang, type)));\n                        uris.add(new URI(String.format(\"%sRelation:%s\", base, type)));\n                    }\n\n                    uris.add(new URI(String.format(\"%s%sRelations\", base, lang)));\n                    uris.add(new URI(String.format(\"%sRelations\", base)));\n                } else {\n                    // give the generic help page, if more than one element is selected\n                    uris.add(new URI(String.format(\"%s%sMap_Features\", base, lang)));\n                    uris.add(new URI(String.format(\"%sMap_Features\", base)));\n                }\n\n                Main.worker.execute(new Runnable() {\n                    @Override public void run() {\n                        try {\n                            // find a page that actually exists in the wiki\n                            HttpURLConnection conn;\n                            for (URI u : uris) {\n                                conn = Utils.openHttpConnection(u.toURL());\n                                conn.setConnectTimeout(Main.pref.getInteger(\"socket.timeout.connect\", 15)*1000);\n\n                                if (conn.getResponseCode() != 200) {\n                                    Main.info(\"{0} does not exist\", u);\n                                    conn.disconnect();\n                                } else {\n                                    int osize = conn.getContentLength();\n                                    if (osize > -1) {\n                                        conn.disconnect();\n\n                                        conn = Utils.openHttpConnection(new URI(u.toString()\n                                                .replace(\"=\", \"%3D\") /* do not URLencode whole string! */\n                                                .replaceFirst(\"/wiki/\", \"/w/index.php?redirect=no&title=\")\n                                                ).toURL());\n                                        conn.setConnectTimeout(Main.pref.getInteger(\"socket.timeout.connect\", 15)*1000);\n                                    }\n\n                                    /* redirect pages have different content length, but retrieving a \"nonredirect\"\n                                     *  page using index.php and the direct-link method gives slightly different\n                                     *  content lengths, so we have to be fuzzy.. (this is UGLY, recode if u know better)\n                                     */\n                                    if (conn.getContentLength() != -1 && osize > -1 && Math.abs(conn.getContentLength() - osize) > 200) {\n                                        Main.info(\"{0} is a mediawiki redirect\", u);\n                                        conn.disconnect();\n                                    } else {\n                                        Main.info(\"browsing to {0}\", u);\n                                        conn.disconnect();\n\n                                        OpenBrowser.displayUrl(u.toString());\n                                        break;\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            Main.error(e);\n                        }\n                    }\n                });\n            } catch (URISyntaxException e1) {\n                Main.error(e1);\n            }\n        }","id":22536,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            try {\n                String base = Main.pref.get(\"url.openstreetmap-wiki\", \"http://wiki.openstreetmap.org/wiki/\");\n                String lang = LanguageInfo.getWikiLanguagePrefix();\n                final List<URI> uris = new ArrayList<>();\n                int row;\n                if (tagTable.getSelectedRowCount() == 1) {\n                    row = tagTable.getSelectedRow();\n                    String key = Utils.encodeUrl(editHelper.getDataKey(row));\n                    Map<String, Integer> m = editHelper.getDataValues(row);\n                    String val = Utils.encodeUrl(m.entrySet().iterator().next().getKey());\n\n                    uris.add(new URI(String.format(\"%s%sTag:%s=%s\", base, lang, key, val)));\n                    uris.add(new URI(String.format(\"%sTag:%s=%s\", base, key, val)));\n                    uris.add(new URI(String.format(\"%s%sKey:%s\", base, lang, key)));\n                    uris.add(new URI(String.format(\"%sKey:%s\", base, key)));\n                    uris.add(new URI(String.format(\"%s%sMap_Features\", base, lang)));\n                    uris.add(new URI(String.format(\"%sMap_Features\", base)));\n                } else if (membershipTable.getSelectedRowCount() == 1) {\n                    row = membershipTable.getSelectedRow();\n                    String type = ((Relation) membershipData.getValueAt(row, 0)).get(\"type\");\n                    if (type != null) {\n                        type = Utils.encodeUrl(type);\n                    }\n\n                    if (type != null && !type.isEmpty()) {\n                        uris.add(new URI(String.format(\"%s%sRelation:%s\", base, lang, type)));\n                        uris.add(new URI(String.format(\"%sRelation:%s\", base, type)));\n                    }\n\n                    uris.add(new URI(String.format(\"%s%sRelations\", base, lang)));\n                    uris.add(new URI(String.format(\"%sRelations\", base)));\n                } else {\n                    // give the generic help page, if more than one element is selected\n                    uris.add(new URI(String.format(\"%s%sMap_Features\", base, lang)));\n                    uris.add(new URI(String.format(\"%sMap_Features\", base)));\n                }\n\n                Main.worker.execute(new Runnable() {\n                    @Override public void run() {\n                        try {\n                            // find a page that actually exists in the wiki\n                            HttpURLConnection conn;\n                            for (URI u : uris) {\n                                conn = Utils.openHttpConnection(u.toURL());\n                                conn.setConnectTimeout(Main.pref.getInteger(\"socket.timeout.connect\", 15)*1000);\n\n                                if (conn.getResponseCode() != 200) {\n                                    Main.info(\"{0} does not exist\", u);\n                                    conn.disconnect();\n                                } else {\n                                    int osize = conn.getContentLength();\n                                    if (osize > -1) {\n                                        conn.disconnect();\n\n                                        conn = Utils.openHttpConnection(new URI(u.toString()\n                                                .replace(\"=\", \"%3D\") /* do not URLencode whole string! */\n                                                .replaceFirst(\"/wiki/\", \"/w/index.php?redirect=no&title=\")\n                                                ).toURL());\n                                        conn.setConnectTimeout(Main.pref.getInteger(\"socket.timeout.connect\", 15)*1000);\n                                    }\n\n                                    /* redirect pages have different content length, but retrieving a \"nonredirect\"\n                                     *  page using index.php and the direct-link method gives slightly different\n                                     *  content lengths, so we have to be fuzzy.. (this is UGLY, recode if u know better)\n                                     */\n                                    if (conn.getContentLength() != -1 && osize > -1 && Math.abs(conn.getContentLength() - osize) > 200) {\n                                        Main.info(\"{0} is a mediawiki redirect\", u);\n                                        conn.disconnect();\n                                    } else {\n                                        Main.info(\"browsing to {0}\", u);\n                                        conn.disconnect();\n\n                                        OpenBrowser.displayUrl(u.toString());\n                                        break;\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            Main.error(e);\n                        }\n                    }\n                });\n            } catch (URISyntaxException e1) {\n                Main.error(e1);\n            }\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        @SuppressWarnings(\"unchecked\")\n        public void actionPerformed(ActionEvent e) {\n            final String url;\n            if (tagTable.getSelectedRowCount() == 1) {\n                final int row = tagTable.getSelectedRow();\n                final String key = Utils.encodeUrl(tagData.getValueAt(row, 0).toString());\n                Map<String, Integer> values = (Map<String, Integer>) tagData.getValueAt(row, 1);\n                if (values.size() == 1) {\n                    url = TAGINFO_URL_PROP.get() + \"tags/\" + key /* do not URL encode key, otherwise addr:street does not work */\n                            + '=' + Utils.encodeUrl(values.keySet().iterator().next());\n                } else {\n                    url = TAGINFO_URL_PROP.get() + \"keys/\" + key; /* do not URL encode key, otherwise addr:street does not work */\n                }\n            } else if (membershipTable.getSelectedRowCount() == 1) {\n                final String type = ((Relation) membershipData.getValueAt(membershipTable.getSelectedRow(), 0)).get(\"type\");\n                url = TAGINFO_URL_PROP.get() + \"relations/\" + type;\n            } else {\n                return;\n            }\n            OpenBrowser.displayUrl(url);\n        }","id":22537,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            final String url;\n            if (tagTable.getSelectedRowCount() == 1) {\n                final int row = tagTable.getSelectedRow();\n                final String key = Utils.encodeUrl(editHelper.getDataKey(row));\n                Map<String, Integer> values = editHelper.getDataValues(row);\n                if (values.size() == 1) {\n                    url = TAGINFO_URL_PROP.get() + \"tags/\" + key /* do not URL encode key, otherwise addr:street does not work */\n                            + '=' + Utils.encodeUrl(values.keySet().iterator().next());\n                } else {\n                    url = TAGINFO_URL_PROP.get() + \"keys/\" + key; /* do not URL encode key, otherwise addr:street does not work */\n                }\n            } else if (membershipTable.getSelectedRowCount() == 1) {\n                final String type = ((Relation) membershipData.getValueAt(membershipTable.getSelectedRow(), 0)).get(\"type\");\n                url = TAGINFO_URL_PROP.get() + \"relations/\" + type;\n            } else {\n                return;\n            }\n            OpenBrowser.displayUrl(url);\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void deleteTags(int[] rows) {\n            // convert list of rows to HashMap (and find gap for nextKey)\n            Map<String, String> tags = new HashMap<>(rows.length);\n            int nextKeyIndex = rows[0];\n            for (int row : rows) {\n                String key = tagData.getValueAt(row, 0).toString();\n                if (row == nextKeyIndex + 1) {\n                    nextKeyIndex = row; // no gap yet\n                }\n                tags.put(key, null);\n            }\n\n            // find key to select after deleting other tags\n            String nextKey = null;\n            int rowCount = tagData.getRowCount();\n            if (rowCount > rows.length) {\n                if (nextKeyIndex == rows[rows.length-1]) {\n                    // no gap found, pick next or previous key in list\n                    nextKeyIndex = (nextKeyIndex + 1 < rowCount ? nextKeyIndex + 1 : rows[0] - 1);\n                } else {\n                    // gap found\n                    nextKeyIndex++;\n                }\n                nextKey = (String) tagData.getValueAt(nextKeyIndex, 0);\n            }\n\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            Main.main.undoRedo.add(new ChangePropertyCommand(sel, tags));\n\n            membershipTable.clearSelection();\n            if (nextKey != null) {\n                tagTable.changeSelection(findRow(tagData, nextKey), 0, false, false);\n            }\n        }","id":22538,"modified_method":"protected void deleteTags(int[] rows) {\n            // convert list of rows to HashMap (and find gap for nextKey)\n            Map<String, String> tags = new HashMap<>(rows.length);\n            int nextKeyIndex = rows[0];\n            for (int row : rows) {\n                String key = editHelper.getDataKey(row);\n                if (row == nextKeyIndex + 1) {\n                    nextKeyIndex = row; // no gap yet\n                }\n                tags.put(key, null);\n            }\n\n            // find key to select after deleting other tags\n            String nextKey = null;\n            int rowCount = tagData.getRowCount();\n            if (rowCount > rows.length) {\n                if (nextKeyIndex == rows[rows.length-1]) {\n                    // no gap found, pick next or previous key in list\n                    nextKeyIndex = (nextKeyIndex + 1 < rowCount ? nextKeyIndex + 1 : rows[0] - 1);\n                } else {\n                    // gap found\n                    nextKeyIndex++;\n                }\n                nextKey = editHelper.getDataKey(nextKeyIndex);\n            }\n\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            Main.main.undoRedo.add(new ChangePropertyCommand(sel, tags));\n\n            membershipTable.clearSelection();\n            if (nextKey != null) {\n                tagTable.changeSelection(findViewRow(tagTable, tagData, nextKey), 0, false, false);\n            }\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            if (tagTable.getSelectedRowCount() != 1)\n                return;\n            String key = tagData.getValueAt(tagTable.getSelectedRow(), 0).toString();\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            if (sel.isEmpty())\n                return;\n            String sep = \"\";\n            StringBuilder s = new StringBuilder();\n            for (OsmPrimitive p : sel) {\n                String val = p.get(key);\n                if (val == null) {\n                    continue;\n                }\n                String t = \"\";\n                if (!sameType) {\n                    t = \"\";\n                } else if (p instanceof Node) {\n                    t = \"type:node \";\n                } else if (p instanceof Way) {\n                    t = \"type:way \";\n                } else if (p instanceof Relation) {\n                    t = \"type:relation \";\n                }\n                s.append(sep).append('(').append(t).append('\"').append(\n                        org.openstreetmap.josm.actions.search.SearchAction.escapeStringForSearch(key)).append(\"\\\"=\\\"\").append(\n                        org.openstreetmap.josm.actions.search.SearchAction.escapeStringForSearch(val)).append(\"\\\")\");\n                sep = \" OR \";\n            }\n\n            final SearchSetting ss = new SearchSetting();\n            ss.text = s.toString();\n            ss.caseSensitive = true;\n            org.openstreetmap.josm.actions.search.SearchAction.searchWithoutHistory(ss);\n        }","id":22539,"modified_method":"@Override\n        public void actionPerformed(ActionEvent e) {\n            if (tagTable.getSelectedRowCount() != 1)\n                return;\n            String key = editHelper.getDataKey(tagTable.getSelectedRow());\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            if (sel.isEmpty())\n                return;\n            String sep = \"\";\n            StringBuilder s = new StringBuilder();\n            for (OsmPrimitive p : sel) {\n                String val = p.get(key);\n                if (val == null) {\n                    continue;\n                }\n                String t = \"\";\n                if (!sameType) {\n                    t = \"\";\n                } else if (p instanceof Node) {\n                    t = \"type:node \";\n                } else if (p instanceof Way) {\n                    t = \"type:way \";\n                } else if (p instanceof Relation) {\n                    t = \"type:relation \";\n                }\n                s.append(sep).append('(').append(t).append('\"').append(\n                        org.openstreetmap.josm.actions.search.SearchAction.escapeStringForSearch(key)).append(\"\\\"=\\\"\").append(\n                        org.openstreetmap.josm.actions.search.SearchAction.escapeStringForSearch(val)).append(\"\\\")\");\n                sep = \" OR \";\n            }\n\n            final SearchSetting ss = new SearchSetting();\n            ss.text = s.toString();\n            ss.caseSensitive = true;\n            org.openstreetmap.josm.actions.search.SearchAction.searchWithoutHistory(ss);\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"private int findRow(TableModel model, Object value) {\n        for (int i = 0; i < model.getRowCount(); i++) {\n            if (model.getValueAt(i, 0).equals(value))\n                return i;\n        }\n        return -1;\n    }","id":22540,"modified_method":"private int findViewRow(JTable table, TableModel model, Object value) {\n        for (int i = 0; i < model.getRowCount(); i++) {\n            if (model.getValueAt(i, 0).equals(value))\n                return table.convertRowIndexToView(i);\n        }\n        return -1;\n    }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void deleteFromRelation(int row) {\n            Relation cur = (Relation) membershipData.getValueAt(row, 0);\n\n            Relation nextRelation = null;\n            int rowCount = membershipTable.getRowCount();\n            if (rowCount > 1) {\n                nextRelation = (Relation) membershipData.getValueAt(row + 1 < rowCount ? row + 1 : row - 1, 0);\n            }\n\n            ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                    tr(\"Change relation\"),\n                    new String[] {tr(\"Delete from relation\"), tr(\"Cancel\")});\n            ed.setButtonIcons(new String[] {\"dialogs/delete\", \"cancel\"});\n            ed.setContent(tr(\"Really delete selection from relation {0}?\", cur.getDisplayName(DefaultNameFormatter.getInstance())));\n            ed.toggleEnable(DELETE_FROM_RELATION_PREF);\n            ed.showDialog();\n\n            if (ed.getValue() != 1)\n                return;\n\n            Relation rel = new Relation(cur);\n            for (OsmPrimitive primitive: Main.main.getInProgressSelection()) {\n                rel.removeMembersFor(primitive);\n            }\n            Main.main.undoRedo.add(new ChangeCommand(cur, rel));\n\n            tagTable.clearSelection();\n            if (nextRelation != null) {\n                membershipTable.changeSelection(findRow(membershipData, nextRelation), 0, false, false);\n            }\n        }","id":22541,"modified_method":"protected void deleteFromRelation(int row) {\n            Relation cur = (Relation) membershipData.getValueAt(row, 0);\n\n            Relation nextRelation = null;\n            int rowCount = membershipTable.getRowCount();\n            if (rowCount > 1) {\n                nextRelation = (Relation) membershipData.getValueAt(row + 1 < rowCount ? row + 1 : row - 1, 0);\n            }\n\n            ExtendedDialog ed = new ExtendedDialog(Main.parent,\n                    tr(\"Change relation\"),\n                    new String[] {tr(\"Delete from relation\"), tr(\"Cancel\")});\n            ed.setButtonIcons(new String[] {\"dialogs/delete\", \"cancel\"});\n            ed.setContent(tr(\"Really delete selection from relation {0}?\", cur.getDisplayName(DefaultNameFormatter.getInstance())));\n            ed.toggleEnable(DELETE_FROM_RELATION_PREF);\n            ed.showDialog();\n\n            if (ed.getValue() != 1)\n                return;\n\n            Relation rel = new Relation(cur);\n            for (OsmPrimitive primitive: Main.main.getInProgressSelection()) {\n                rel.removeMembersFor(primitive);\n            }\n            Main.main.undoRedo.add(new ChangeCommand(cur, rel));\n\n            tagTable.clearSelection();\n            if (nextRelation != null) {\n                membershipTable.changeSelection(findViewRow(membershipTable, membershipData, nextRelation), 0, false, false);\n            }\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public void actionPerformed(ActionEvent ae) {\n            if (tagTable.getSelectedRowCount() != 1)\n                return;\n            String key = tagData.getValueAt(tagTable.getSelectedRow(), 0).toString();\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            String clipboard = Utils.getClipboardContent();\n            if (sel.isEmpty() || clipboard == null)\n                return;\n            Main.main.undoRedo.add(new ChangePropertyCommand(sel, key, Utils.strip(clipboard)));\n        }","id":22542,"modified_method":"@Override\n        public void actionPerformed(ActionEvent ae) {\n            if (tagTable.getSelectedRowCount() != 1)\n                return;\n            String key = editHelper.getDataKey(tagTable.getSelectedRow());\n            Collection<OsmPrimitive> sel = Main.main.getInProgressSelection();\n            String clipboard = Utils.getClipboardContent();\n            if (sel.isEmpty() || clipboard == null)\n                return;\n            Main.main.undoRedo.add(new ChangePropertyCommand(sel, key, Utils.strip(clipboard)));\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"AddTagsDialog() {\n            super(Main.parent, tr(\"Add value?\"), new String[] {tr(\"OK\"), tr(\"Cancel\")});\n            setButtonIcons(new String[] {\"ok\", \"cancel\"});\n            setCancelButton(2);\n            configureContextsensitiveHelp(\"/Dialog/AddValue\", true /* show help button */);\n\n            JPanel mainPanel = new JPanel(new GridBagLayout());\n            keys = new AutoCompletingComboBox();\n            values = new AutoCompletingComboBox();\n\n            mainPanel.add(new JLabel(\"<html>\"+trn(\"This will change up to {0} object.\",\n                \"This will change up to {0} objects.\", sel.size(), sel.size())\n                +\"<br><br>\"+tr(\"Please select a key\")), GBC.eol().fill(GBC.HORIZONTAL));\n\n            AutoCompletionManager autocomplete = Main.main.getEditLayer().data.getAutoCompletionManager();\n            List<AutoCompletionListItem> keyList = autocomplete.getKeys();\n\n            AutoCompletionListItem itemToSelect = null;\n            // remove the object's tag keys from the list\n            Iterator<AutoCompletionListItem> iter = keyList.iterator();\n            while (iter.hasNext()) {\n                AutoCompletionListItem item = iter.next();\n                if (item.getValue().equals(lastAddKey)) {\n                    itemToSelect = item;\n                }\n                for (int i = 0; i < tagData.getRowCount(); ++i) {\n                    if (item.getValue().equals(tagData.getValueAt(i, 0))) {\n                        if (itemToSelect == item) {\n                            itemToSelect = null;\n                        }\n                        iter.remove();\n                        break;\n                    }\n                }\n            }\n\n            Collections.sort(keyList, defaultACItemComparator);\n            keys.setPossibleACItems(keyList);\n            keys.setEditable(true);\n\n            mainPanel.add(keys, GBC.eop().fill(GBC.HORIZONTAL));\n\n            mainPanel.add(new JLabel(tr(\"Please select a value\")), GBC.eol());\n            values.setEditable(true);\n            mainPanel.add(values, GBC.eop().fill(GBC.HORIZONTAL));\n            if (itemToSelect != null) {\n                keys.setSelectedItem(itemToSelect);\n                if (lastAddValue != null) {\n                    values.setSelectedItem(lastAddValue);\n                }\n            }\n\n            FocusAdapter focus = addFocusAdapter(autocomplete, defaultACItemComparator);\n            // fire focus event in advance or otherwise the popup list will be too small at first\n            focus.focusGained(null);\n\n            int recentTagsToShow = PROPERTY_RECENT_TAGS_NUMBER.get();\n            if (recentTagsToShow > MAX_LRU_TAGS_NUMBER) {\n                recentTagsToShow = MAX_LRU_TAGS_NUMBER;\n            }\n\n            // Add tag on Shift-Enter\n            mainPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(\n                        KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.SHIFT_MASK), \"addAndContinue\");\n                mainPanel.getActionMap().put(\"addAndContinue\", new AbstractAction() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        performTagAdding();\n                        selectKeysComboBox();\n                    }\n                });\n\n            suggestRecentlyAddedTags(mainPanel, recentTagsToShow, focus);\n\n            mainPanel.add(Box.createVerticalGlue(), GBC.eop().fill());\n            setContent(mainPanel, false);\n\n            selectKeysComboBox();\n\n            popupMenu.add(new AbstractAction(tr(\"Set number of recently added tags\")) {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    selectNumberOfTags();\n                }\n            });\n            JCheckBoxMenuItem rememberLastTags = new JCheckBoxMenuItem(\n                new AbstractAction(tr(\"Remember last used tags after a restart\")) {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    boolean sel = ((JCheckBoxMenuItem) e.getSource()).getState();\n                    PROPERTY_REMEMBER_TAGS.put(sel);\n                    if (sel) saveTagsIfNeeded();\n                }\n            });\n            rememberLastTags.setState(PROPERTY_REMEMBER_TAGS.get());\n            popupMenu.add(rememberLastTags);\n        }","id":22543,"modified_method":"AddTagsDialog() {\n            super(Main.parent, tr(\"Add value?\"), new String[] {tr(\"OK\"), tr(\"Cancel\")});\n            setButtonIcons(new String[] {\"ok\", \"cancel\"});\n            setCancelButton(2);\n            configureContextsensitiveHelp(\"/Dialog/AddValue\", true /* show help button */);\n\n            JPanel mainPanel = new JPanel(new GridBagLayout());\n            keys = new AutoCompletingComboBox();\n            values = new AutoCompletingComboBox();\n\n            mainPanel.add(new JLabel(\"<html>\"+trn(\"This will change up to {0} object.\",\n                \"This will change up to {0} objects.\", sel.size(), sel.size())\n                +\"<br><br>\"+tr(\"Please select a key\")), GBC.eol().fill(GBC.HORIZONTAL));\n\n            AutoCompletionManager autocomplete = Main.main.getEditLayer().data.getAutoCompletionManager();\n            List<AutoCompletionListItem> keyList = autocomplete.getKeys();\n\n            AutoCompletionListItem itemToSelect = null;\n            // remove the object's tag keys from the list\n            Iterator<AutoCompletionListItem> iter = keyList.iterator();\n            while (iter.hasNext()) {\n                AutoCompletionListItem item = iter.next();\n                if (item.getValue().equals(lastAddKey)) {\n                    itemToSelect = item;\n                }\n                for (int i = 0; i < tagData.getRowCount(); ++i) {\n                    if (item.getValue().equals(getDataKey(i))) {\n                        if (itemToSelect == item) {\n                            itemToSelect = null;\n                        }\n                        iter.remove();\n                        break;\n                    }\n                }\n            }\n\n            Collections.sort(keyList, defaultACItemComparator);\n            keys.setPossibleACItems(keyList);\n            keys.setEditable(true);\n\n            mainPanel.add(keys, GBC.eop().fill(GBC.HORIZONTAL));\n\n            mainPanel.add(new JLabel(tr(\"Please select a value\")), GBC.eol());\n            values.setEditable(true);\n            mainPanel.add(values, GBC.eop().fill(GBC.HORIZONTAL));\n            if (itemToSelect != null) {\n                keys.setSelectedItem(itemToSelect);\n                if (lastAddValue != null) {\n                    values.setSelectedItem(lastAddValue);\n                }\n            }\n\n            FocusAdapter focus = addFocusAdapter(autocomplete, defaultACItemComparator);\n            // fire focus event in advance or otherwise the popup list will be too small at first\n            focus.focusGained(null);\n\n            int recentTagsToShow = PROPERTY_RECENT_TAGS_NUMBER.get();\n            if (recentTagsToShow > MAX_LRU_TAGS_NUMBER) {\n                recentTagsToShow = MAX_LRU_TAGS_NUMBER;\n            }\n\n            // Add tag on Shift-Enter\n            mainPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(\n                        KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.SHIFT_MASK), \"addAndContinue\");\n                mainPanel.getActionMap().put(\"addAndContinue\", new AbstractAction() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        performTagAdding();\n                        selectKeysComboBox();\n                    }\n                });\n\n            suggestRecentlyAddedTags(mainPanel, recentTagsToShow, focus);\n\n            mainPanel.add(Box.createVerticalGlue(), GBC.eop().fill());\n            setContent(mainPanel, false);\n\n            selectKeysComboBox();\n\n            popupMenu.add(new AbstractAction(tr(\"Set number of recently added tags\")) {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    selectNumberOfTags();\n                }\n            });\n            JCheckBoxMenuItem rememberLastTags = new JCheckBoxMenuItem(\n                new AbstractAction(tr(\"Remember last used tags after a restart\")) {\n                @Override\n                public void actionPerformed(ActionEvent e) {\n                    boolean sel = ((JCheckBoxMenuItem) e.getSource()).getState();\n                    PROPERTY_REMEMBER_TAGS.put(sel);\n                    if (sel) saveTagsIfNeeded();\n                }\n            });\n            rememberLastTags.setState(PROPERTY_REMEMBER_TAGS.get());\n            popupMenu.add(rememberLastTags);\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n    * Edit the value in the tags table row.\n    * @param row The row of the table from which the value is edited.\n    * @param focusOnKey Determines if the initial focus should be set on key instead of value\n    * @since 5653\n    */\n    public void editTag(final int row, boolean focusOnKey) {\n        changedKey = null;\n        sel = Main.main.getInProgressSelection();\n        if (sel == null || sel.isEmpty()) return;\n\n        String key = tagData.getValueAt(row, 0).toString();\n        objKey = key;\n\n        @SuppressWarnings(\"unchecked\")\n        final EditTagDialog editDialog = new EditTagDialog(key,\n                (Map<String, Integer>) tagData.getValueAt(row, 1), focusOnKey);\n        editDialog.showDialog();\n        if (editDialog.getValue() != 1) return;\n        editDialog.performTagEdit();\n    }","id":22544,"modified_method":"/**\n    * Edit the value in the tags table row.\n    * @param row The row of the table from which the value is edited.\n    * @param focusOnKey Determines if the initial focus should be set on key instead of value\n    * @since 5653\n    */\n    public void editTag(final int row, boolean focusOnKey) {\n        changedKey = null;\n        sel = Main.main.getInProgressSelection();\n        if (sel == null || sel.isEmpty()) return;\n\n        String key = getDataKey(row);\n        objKey = key;\n\n        final EditTagDialog editDialog = new EditTagDialog(key, getDataValues(row), focusOnKey);\n        editDialog.showDialog();\n        if (editDialog.getValue() != 1) return;\n        editDialog.performTagEdit();\n    }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void disableTagIfNeeded(final Tag t, final JosmAction action) {\n            // Disable action if its key is already set on the object (the key being absent from the keys list for this reason\n            // performing this action leads to autocomplete to the next key (see #7671 comments)\n            for (int j = 0; j < tagData.getRowCount(); ++j) {\n                if (t.getKey().equals(tagData.getValueAt(j, 0))) {\n                    action.setEnabled(false);\n                    break;\n                }\n            }\n        }","id":22545,"modified_method":"private void disableTagIfNeeded(final Tag t, final JosmAction action) {\n            // Disable action if its key is already set on the object (the key being absent from the keys list for this reason\n            // performing this action leads to autocomplete to the next key (see #7671 comments)\n            for (int j = 0; j < tagData.getRowCount(); ++j) {\n                if (t.getKey().equals(getDataKey(j))) {\n                    action.setEnabled(false);\n                    break;\n                }\n            }\n        }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"TagEditHelper(DefaultTableModel propertyData, Map<String, Map<String, Integer>> valueCount) {\n        this.tagData = propertyData;\n        this.valueCount = valueCount;\n    }","id":22546,"modified_method":"TagEditHelper(JTable tagTable, DefaultTableModel propertyData, Map<String, Map<String, Integer>> valueCount) {\n        this.tagTable = tagTable;\n        this.tagData = propertyData;\n        this.valueCount = valueCount;\n    }","commit_id":"d4bcae26ba05983756bf13d5922b9094a44447eb","url":"https://github.com/openstreetmap/josm"},{"original_method":"public AMQPTransportFrame(Frame performative) {\n        this.performative = performative;\n    }","id":22547,"modified_method":"public AMQPTransportFrame(Frame performative) {\n        setPerformative(performative);\n        setPayload(EMPTY);\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public AMQPTransportFrame(int channel, Frame performative) {\n        setChannel(channel);\n        this.performative = performative;\n        setDoff(calculateDataOffset());\n        setSize(getFrameSize());\n    }","id":22548,"modified_method":"public AMQPTransportFrame(int channel, Frame performative) {\n        setChannel(channel);\n        setPerformative(performative);\n        setPayload(EMPTY);\n        setDoff(calculateDataOffset());\n        setSize(getFrameSize());\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public AMQPTransportFrame(int channel, Frame performative, Buffer payload) {\n        setChannel(channel);\n        this.performative = performative;\n        this.payload = payload;\n        setDoff(calculateDataOffset());\n        setSize(getFrameSize());\n    }","id":22549,"modified_method":"public AMQPTransportFrame(int channel, Frame performative, Buffer payload) {\n        setChannel(channel);\n        setPerformative(performative);\n        setPayload(payload);\n        setDoff(calculateDataOffset());\n        setSize(getFrameSize());\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void setPerformative(Frame performative) {\n        this.performative = performative;\n    }","id":22550,"modified_method":"public void setPerformative(Frame performative) {\n        this.performative = performative;\n        if (this.performative == null) {\n            performative = NoPerformative.INSTANCE;\n        }\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void setPayload(Buffer buffer) {\n        this.payload = payload;\n    }","id":22551,"modified_method":"public void setPayload(Buffer buffer) {\n        this.payload = buffer;\n        if (this.payload == null) {\n            payload = EMPTY;\n        }\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void initExtHeader(Buffer body) {\n        int dataOffset = getDoff() * 4;\n        if ( dataOffset > header.length ) {\n            if (body == null) {\n                extHeader = new Buffer(dataOffset - header.length);\n            } else {\n                extHeader = new Buffer(body.data, 0, dataOffset - header.length);\n                body.offset(dataOffset - header.length);\n            }\n        }\n    }","id":22552,"modified_method":"private void initExtHeader(Buffer body) {\n        int dataOffset = getDoff() * 4;\n        if ( dataOffset > header.length ) {\n            if (body == null || body == EMPTY) {\n                extHeader = new Buffer(dataOffset - header.length);\n            } else {\n                extHeader = new Buffer(body.data, 0, dataOffset - header.length);\n                body.offset(dataOffset - header.length);\n            }\n        }\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public AMQPTransportFrame() {\n\n    }","id":22553,"modified_method":"public AMQPTransportFrame() {\n        setPerformative(NoPerformative.INSTANCE);\n        setPayload(EMPTY);\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void write(DataOutput out) throws Exception {\n        setDoff(calculateDataOffset());\n        setSize(getFrameSize());\n        header.writeTo(out);\n        extHeader.writeTo(out);\n        if (performative != null) {\n            performative.write(out);\n        }\n        if (payload != null) {\n            payload.writeTo(out);\n        }\n    }","id":22554,"modified_method":"public void write(DataOutput out) throws Exception {\n        setDoff(calculateDataOffset());\n        setSize(getFrameSize());\n        header.writeTo(out);\n        extHeader.writeTo(out);\n        performative.write(out);\n        payload.writeTo(out);\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public <T extends Frame> T getPerformative() {\n        return (T)performative;\n    }","id":22555,"modified_method":"public Frame getPerformative() {\n        return performative;\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void initExtHeader() {\n        initExtHeader(null);\n    }","id":22556,"modified_method":"private void initExtHeader() {\n        initExtHeader(EMPTY);\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void fromBuffer(Buffer body) {\n        try {\n            DataByteArrayInputStream in = new DataByteArrayInputStream(body);\n            performative = (Frame) TypeReader.read(in);\n            if (in.available() > 0) {\n                payload = new Buffer(in.available());\n                payload.readFrom((DataInput)in);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error creating frame from buffer : \" + e.getMessage());\n        }\n    }","id":22557,"modified_method":"private void fromBuffer(Buffer body) {\n        try {\n            DataByteArrayInputStream in = new DataByteArrayInputStream(body);\n            if (in.available() > 0) {\n                setPerformative((Frame)TypeReader.read(in));\n            } else {\n                setPerformative(NoPerformative.INSTANCE);\n            }\n            if (in.available() > 0) {\n                Buffer payload = new Buffer(in.available());\n                payload.readFrom((DataInput)in);\n                setPayload(payload);\n            } else {\n                setPayload(EMPTY);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error creating frame from buffer : \" + e.getMessage());\n        }\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testBeginFrame() throws Exception {\n        Begin in = new Begin();\n        in.setIncomingWindow(10L);\n        in.setOutgoingWindow(10L);\n        in.setNextOutgoingID(0L);\n\n        Begin out = TestSupport.encodeDecode(new AMQPTransportFrame(0, in)).getPerformative();\n        assertEquals(in.toString(), out.toString());\n    }","id":22558,"modified_method":"@Test\n    public void testBeginFrame() throws Exception {\n        Begin in = new Begin();\n        in.setIncomingWindow(10L);\n        in.setOutgoingWindow(10L);\n        in.setNextOutgoingID(0L);\n\n        Begin out = (Begin)TestSupport.encodeDecode(new AMQPTransportFrame(0, in)).getPerformative();\n        assertEquals(in.toString(), out.toString());\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testTransferFrame() throws Exception {\n        ValueMessage message = MessageFactory.createValueMessage(new AMQPString(\"HelloWorld!\"));\n        Transfer transfer = new Transfer(0L, 0L, Buffer.ascii(\"0\").buffer());\n        AnnotatedMessage annotatedMessage = MessageFactory.createAnnotatedMessage(message);\n\n        AMQPTransportFrame frame = new AMQPTransportFrame(0, transfer, MessageSupport.toBuffer(annotatedMessage));\n\n        AMQPTransportFrame outFrame = TestSupport.encodeDecode(frame);\n\n        Transfer outTransfer = outFrame.getPerformative();\n\n        System.out.printf(\"Transfer : %s\\n\", outTransfer);\n\n        AnnotatedMessage msg = MessageSupport.decodeAnnotatedMessage(outFrame.getPayload());\n\n        System.out.printf(\"Msg : %s\\n\", msg);\n        assertEquals(transfer.toString(), outTransfer.toString());\n        assertEquals(annotatedMessage.toString(), msg.toString());\n    }","id":22559,"modified_method":"@Test\n    public void testTransferFrame() throws Exception {\n        ValueMessage message = MessageFactory.createValueMessage(new AMQPString(\"HelloWorld!\"));\n        Transfer transfer = new Transfer(0L, 0L, Buffer.ascii(\"0\").buffer());\n        AnnotatedMessage annotatedMessage = MessageFactory.createAnnotatedMessage(message);\n\n        AMQPTransportFrame frame = new AMQPTransportFrame(0, transfer, MessageSupport.toBuffer(annotatedMessage));\n\n        AMQPTransportFrame outFrame = TestSupport.encodeDecode(frame);\n\n        Transfer outTransfer = (Transfer)outFrame.getPerformative();\n\n        System.out.printf(\"Transfer : %s\\n\", outTransfer);\n\n        AnnotatedMessage msg = MessageSupport.decodeAnnotatedMessage(outFrame.getPayload());\n\n        System.out.printf(\"Msg : %s\\n\", msg);\n        assertEquals(transfer.toString(), outTransfer.toString());\n        assertEquals(annotatedMessage.toString(), msg.toString());\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void createFrameFromHeaderAndBody() throws Exception {\n        ValueMessage message = MessageFactory.createValueMessage(new AMQPString(\"HelloWorld!\"));\n        Transfer transfer = new Transfer(0L, 0L, Buffer.ascii(\"0\").buffer());\n        AnnotatedMessage annotatedMessage = MessageFactory.createAnnotatedMessage(message);\n        AMQPTransportFrame inFrame = new AMQPTransportFrame(0, transfer, MessageSupport.toBuffer(annotatedMessage));\n\n        DataByteArrayOutputStream out = new DataByteArrayOutputStream((int)inFrame.getSize());\n        inFrame.write(out);\n        Buffer buf = out.toBuffer();\n\n\n        Buffer header = new Buffer(8);\n\n        DataByteArrayInputStream in = new DataByteArrayInputStream(buf);\n        in.read(header.data);\n        Buffer body = new Buffer(in.available());\n        in.read(body.data);\n\n        AMQPTransportFrame outFrame = new AMQPTransportFrame(header, body);\n\n        Transfer outTransfer = outFrame.getPerformative();\n        AnnotatedMessage msg = MessageSupport.decodeAnnotatedMessage(outFrame.getPayload());\n        assertEquals(transfer.toString(), outTransfer.toString());\n        assertEquals(annotatedMessage.toString(), msg.toString());\n    }","id":22560,"modified_method":"@Test\n    public void createFrameFromHeaderAndBody() throws Exception {\n        ValueMessage message = MessageFactory.createValueMessage(new AMQPString(\"HelloWorld!\"));\n        Transfer transfer = new Transfer(0L, 0L, Buffer.ascii(\"0\").buffer());\n        AnnotatedMessage annotatedMessage = MessageFactory.createAnnotatedMessage(message);\n        AMQPTransportFrame inFrame = new AMQPTransportFrame(0, transfer, MessageSupport.toBuffer(annotatedMessage));\n\n        DataByteArrayOutputStream out = new DataByteArrayOutputStream((int)inFrame.getSize());\n        inFrame.write(out);\n        Buffer buf = out.toBuffer();\n\n\n        Buffer header = new Buffer(8);\n\n        DataByteArrayInputStream in = new DataByteArrayInputStream(buf);\n        in.read(header.data);\n        Buffer body = new Buffer(in.available());\n        in.read(body.data);\n\n        AMQPTransportFrame outFrame = new AMQPTransportFrame(header, body);\n\n        Transfer outTransfer = (Transfer)outFrame.getPerformative();\n        AnnotatedMessage msg = MessageSupport.decodeAnnotatedMessage(outFrame.getPayload());\n        assertEquals(transfer.toString(), outTransfer.toString());\n        assertEquals(annotatedMessage.toString(), msg.toString());\n    }","commit_id":"e7867bb61e4d8d4b28188627daba269999f618ad","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void addPolicy(PolicyAttachment pa) {\n        // TODO - do I need to defensively copy this?\n        Element policyEl = pa.getElement();\n\n        UnknownExtensibilityElement uee = new UnknownExtensibilityElement();\n        uee.setRequired(true);\n        uee.setElementType(DOMUtils.getElementQName(policyEl));\n        uee.setElement(policyEl);\n\n        if (ei.getService().getDescription() == null) {\n            DescriptionInfo description = new DescriptionInfo();\n            description.setName(ei.getService().getName());\n            ei.getService().setDescription(description);\n        }\n        ei.getService().getDescription().addExtensor(uee);\n    }","id":22561,"modified_method":"private void addPolicy(PolicyAttachment pa) {\n        // TODO - do I need to defensively copy this?\n        Element policyEl = pa.getElement();\n\n        UnknownExtensibilityElement uee = new UnknownExtensibilityElement();\n        uee.setRequired(true);\n        uee.setElementType(DOMUtils.getElementQName(policyEl));\n        uee.setElement(policyEl);\n\n        if (ei.getService().getDescription() == null) {\n            DescriptionInfo description = new DescriptionInfo();\n            description.setName(ei.getService().getName());\n            if (!StringUtils.isEmpty(ei.getAddress())) {\n                description.setBaseURI(ei.getAddress() + \"?wsdl\");\n            }\n            \n            ei.getService().setDescription(description);\n        }\n        ei.getService().getDescription().addExtensor(uee);\n    }","commit_id":"5b56a16071a95964670498c167c9fad44a992e08","url":"https://github.com/apache/cxf"},{"original_method":"Policy resolveReference(PolicyReference ref, DescriptionInfo di) {\n        Policy p = null;\n        if (isExternal(ref)) {\n            p = resolveExternal(ref, di.getBaseURI());\n        } else {\n            p = resolveLocal(ref, di);\n        }\n        checkResolved(ref, p);\n        return p;\n    }","id":22562,"modified_method":"Policy resolveReference(PolicyReference ref, DescriptionInfo di) {\n        Policy p = null;\n        if (isExternal(ref)) {\n            String uri = di.getBaseURI();\n            if (uri == null) {\n                uri = Integer.toString(di.hashCode());\n            }\n            p = resolveExternal(ref, uri);\n        } else {\n            p = resolveLocal(ref, di);\n        }\n        checkResolved(ref, p);\n        return p;\n    }","commit_id":"5b56a16071a95964670498c167c9fad44a992e08","url":"https://github.com/apache/cxf"},{"original_method":"Policy getElementPolicy(Extensible ex, boolean includeAttributes, DescriptionInfo di) {\n        if (null == ex || null == di) {\n            return null;\n        }\n        \n        if (di.getProperty(\"registeredPolicy\") == null) {\n            List<UnknownExtensibilityElement> diext = \n                di.getExtensors(UnknownExtensibilityElement.class);\n            if (diext != null) {\n                for (UnknownExtensibilityElement e : diext) {\n                    String uri = e.getElement().getAttributeNS(PolicyConstants.WSU_NAMESPACE_URI,\n                                                  PolicyConstants.WSU_ID_ATTR_NAME);\n                    \n                    if (Constants.isPolicyElement(e.getElementType())\n                        && !StringUtils.isEmpty(uri)) {\n                        try {\n                            Policy policy = builder.getPolicy(e.getElement());\n                            String fragement = \"#\" + uri;\n                            registry.register(fragement, policy);\n                            registry.register(di.getBaseURI() + fragement, policy);\n                        } catch (Exception policyEx) {\n                            //ignore the policy can not be built\n                            LOG.warning(\"Failed to build the policy '\" + uri + \"':\" + policyEx.getMessage());\n                        }\n                    }\n                }\n            }\n            di.setProperty(\"registeredPolicy\", true);\n        }\n        \n        Policy elementPolicy = null;\n        List<UnknownExtensibilityElement> extensions = \n            ex.getExtensors(UnknownExtensibilityElement.class);\n        \n        if (null != extensions) {\n            for (UnknownExtensibilityElement e : extensions) {\n                Policy p = null;\n                if (Constants.isPolicyElement(e.getElementType())) {\n                    p = builder.getPolicy(e.getElement());\n\n                } else if (Constants.isPolicyRef(e.getElementType())) {\n                    PolicyReference ref = builder.getPolicyReference(e.getElement());\n                    if (null != ref) {\n                        p = resolveReference(ref, di);\n                    }\n                }\n                if (null != p) {\n                    if (elementPolicy == null) {\n                        elementPolicy = new Policy();\n                    }\n                    elementPolicy = elementPolicy.merge(p);\n                }\n            }\n        }\n        \n        if (includeAttributes && ex.getExtensionAttributes() != null) {\n            for (Map.Entry<QName, Object> ent : ex.getExtensionAttributes().entrySet()) {\n                if (Constants.isPolicyURIsAttr(ent.getKey())) {\n                    Object attr = ent.getValue();\n                    // can be of type a String, a QName, a list of Srings or a list of QNames\n                    String uris = null;\n                    if (attr instanceof QName) {\n                        uris = ((QName)attr).getLocalPart();\n                    } else if (attr instanceof String) {\n                        uris = (String)attr;\n                    }\n                    if (null != uris) {\n                        StringTokenizer st = new StringTokenizer(uris);\n                        while (st.hasMoreTokens()) {\n                            String uri = st.nextToken();\n                            PolicyReference ref = new PolicyReference();\n                            ref.setURI(uri);\n                            Policy p = resolveReference(ref, di);\n                            if (null != p) {\n                                elementPolicy = elementPolicy == null \n                                    ? new Policy().merge(p) : elementPolicy.merge(p);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return elementPolicy;\n    }","id":22563,"modified_method":"Policy getElementPolicy(Extensible ex, boolean includeAttributes, DescriptionInfo di) {\n        if (null == ex || null == di) {\n            return null;\n        }\n        \n        if (di.getProperty(\"registeredPolicy\") == null) {\n            List<UnknownExtensibilityElement> diext = \n                di.getExtensors(UnknownExtensibilityElement.class);\n            if (diext != null) {\n                for (UnknownExtensibilityElement e : diext) {\n                    String uri = e.getElement().getAttributeNS(PolicyConstants.WSU_NAMESPACE_URI,\n                                                  PolicyConstants.WSU_ID_ATTR_NAME);\n                    \n                    if (Constants.isPolicyElement(e.getElementType())\n                        && !StringUtils.isEmpty(uri)) {\n                        try {\n                            Policy policy = builder.getPolicy(e.getElement());\n                            String fragement = \"#\" + uri;\n                            registry.register(fragement, policy);\n                            if (di.getBaseURI() == null) {\n                                registry.register(Integer.toString(di.hashCode()) + fragement, policy);\n                            } else {\n                                registry.register(di.getBaseURI() + fragement, policy);\n                            }\n                        } catch (Exception policyEx) {\n                            //ignore the policy can not be built\n                            LOG.warning(\"Failed to build the policy '\" + uri + \"':\" + policyEx.getMessage());\n                        }\n                    }\n                }\n            }\n            di.setProperty(\"registeredPolicy\", true);\n        }\n        \n        Policy elementPolicy = null;\n        List<UnknownExtensibilityElement> extensions = \n            ex.getExtensors(UnknownExtensibilityElement.class);\n        \n        if (null != extensions) {\n            for (UnknownExtensibilityElement e : extensions) {\n                Policy p = null;\n                if (Constants.isPolicyElement(e.getElementType())) {\n                    p = builder.getPolicy(e.getElement());\n\n                } else if (Constants.isPolicyRef(e.getElementType())) {\n                    PolicyReference ref = builder.getPolicyReference(e.getElement());\n                    if (null != ref) {\n                        p = resolveReference(ref, di);\n                    }\n                }\n                if (null != p) {\n                    if (elementPolicy == null) {\n                        elementPolicy = new Policy();\n                    }\n                    elementPolicy = elementPolicy.merge(p);\n                }\n            }\n        }\n        \n        if (includeAttributes && ex.getExtensionAttributes() != null) {\n            for (Map.Entry<QName, Object> ent : ex.getExtensionAttributes().entrySet()) {\n                if (Constants.isPolicyURIsAttr(ent.getKey())) {\n                    Object attr = ent.getValue();\n                    // can be of type a String, a QName, a list of Srings or a list of QNames\n                    String uris = null;\n                    if (attr instanceof QName) {\n                        uris = ((QName)attr).getLocalPart();\n                    } else if (attr instanceof String) {\n                        uris = (String)attr;\n                    }\n                    if (null != uris) {\n                        StringTokenizer st = new StringTokenizer(uris);\n                        while (st.hasMoreTokens()) {\n                            String uri = st.nextToken();\n                            PolicyReference ref = new PolicyReference();\n                            ref.setURI(uri);\n                            Policy p = resolveReference(ref, di);\n                            if (null != p) {\n                                elementPolicy = elementPolicy == null \n                                    ? new Policy().merge(p) : elementPolicy.merge(p);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return elementPolicy;\n    }","commit_id":"5b56a16071a95964670498c167c9fad44a992e08","url":"https://github.com/apache/cxf"},{"original_method":"Policy resolveLocal(PolicyReference ref, DescriptionInfo di) {\n        String uri = ref.getURI().substring(1);\n        String absoluteURI = di.getBaseURI() + ref.getURI();\n        Policy resolved = registry.lookup(absoluteURI);\n        if (null != resolved) {\n            return resolved;\n        }\n        \n        ReferenceResolver resolver = new LocalServiceModelReferenceResolver(di, builder);\n        resolved = resolver.resolveReference(uri);\n        if (null != resolved) {\n            ref.setURI(absoluteURI);\n            registry.register(absoluteURI, resolved);\n        }\n        return resolved;\n    }","id":22564,"modified_method":"Policy resolveLocal(PolicyReference ref, DescriptionInfo di) {\n        String uri = ref.getURI().substring(1);\n        String absoluteURI = di.getBaseURI();\n        if (absoluteURI == null) {\n            absoluteURI = Integer.toString(di.hashCode()) + ref.getURI();\n        } else {\n            absoluteURI = absoluteURI + ref.getURI();\n        }\n        Policy resolved = registry.lookup(absoluteURI);\n        if (null != resolved) {\n            return resolved;\n        }\n        \n        ReferenceResolver resolver = new LocalServiceModelReferenceResolver(di, builder);\n        resolved = resolver.resolveReference(uri);\n        if (null != resolved) {\n            ref.setURI(absoluteURI);\n            registry.register(absoluteURI, resolved);\n        }\n        return resolved;\n    }","commit_id":"5b56a16071a95964670498c167c9fad44a992e08","url":"https://github.com/apache/cxf"},{"original_method":"Policy resolveReference(PolicyReference ref, PolicyBuilder builder, Bus bus, DescriptionInfo i) {\n        Policy p = null;\n        if (!ref.getURI().startsWith(\"#\")) {\n            p = resolveExternal(ref, i.getBaseURI(), bus);\n        } else {\n            p = resolveLocal(ref, bus, i);\n        }\n        if (null == p) {\n            throw new PolicyException(new Message(\"UNRESOLVED_POLICY_REFERENCE_EXC\", BUNDLE, ref.getURI()));\n        }\n        \n        return p;\n    }","id":22565,"modified_method":"Policy resolveReference(PolicyReference ref, PolicyBuilder builder, Bus bus, DescriptionInfo i) {\n        Policy p = null;\n        if (!ref.getURI().startsWith(\"#\")) {\n            String base = i == null ? null : i.getBaseURI();\n            p = resolveExternal(ref, base, bus);\n        } else {\n            p = resolveLocal(ref, bus, i);\n        }\n        if (null == p) {\n            throw new PolicyException(new Message(\"UNRESOLVED_POLICY_REFERENCE_EXC\", BUNDLE, ref.getURI()));\n        }\n        \n        return p;\n    }","commit_id":"942e3f021dc5b961bf56a76d481dd5b752c0644c","url":"https://github.com/apache/cxf"},{"original_method":"public static INodeBuilder findBuilderForMatcher(ITemplateGenerator generator, SNode ref) {\n    return generator.findNodeBuilderForSource(GeneratorUtil.findRegexpUsingConstructionFor(ref), \"matcher\");\n  }","id":22566,"modified_method":"public static SNode findOutputMatcher(ITemplateGenerator generator, SNode ref) {\n    return generator.findOutputNodeByInputNodeAndMappingName(GeneratorUtil.findRegexpUsingConstructionFor(ref), \"matcher\");\n  }","commit_id":"c48cb7799755ee81b27a9ccfe693df5ec509e33d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1175155997041(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return GeneratorUtil.findBuilderForMatcher(generator, node).getTargetNode();\n  }","id":22567,"modified_method":"public static SNode referenceMacro_GetReferent_1175155997041(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return GeneratorUtil.findOutputMatcher(generator, node);\n  }","commit_id":"c48cb7799755ee81b27a9ccfe693df5ec509e33d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1175170026388(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return GeneratorUtil.findBuilderForMatcher(generator, node).getTargetNode();\n  }","id":22568,"modified_method":"public static SNode referenceMacro_GetReferent_1175170026388(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return GeneratorUtil.findOutputMatcher(generator, node);\n  }","commit_id":"c48cb7799755ee81b27a9ccfe693df5ec509e33d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode referenceMacro_GetReferent_1174655509856(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return GeneratorUtil.findBuilderForMatcher(generator, node).getTargetNode();\n  }","id":22569,"modified_method":"public static SNode referenceMacro_GetReferent_1174655509856(SNode node, SNode templateNode, SNode outputNode, SModel sourceModel, ITemplateGenerator generator) {\n    return GeneratorUtil.findOutputMatcher(generator, node);\n  }","commit_id":"c48cb7799755ee81b27a9ccfe693df5ec509e33d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String suggestUniqueVariableName(String baseName, PsiElement place, boolean lookForward) {\n    int index = 0;\n    PsiElement scope = PsiTreeUtil.getNonStrictParentOfType(place, PsiStatement.class, PsiCodeBlock.class, PsiMethod.class);\n    NextName:\n    while (true) {\n      String name = baseName;\n      if (index > 0) {\n        name += index;\n      }\n      index++;\n      if (PsiUtil.isVariableNameUnique(name, place)) {\n        if (lookForward) {\n          final String name1 = name;\n          PsiElement run = scope;\n          while (run != null) {\n            class CancelException extends RuntimeException {\n            }\n            try {\n              run.accept(new JavaRecursiveElementWalkingVisitor() {\n                @Override\n                public void visitClass(final PsiClass aClass) {}\n\n                @Override public void visitVariable(PsiVariable variable) {\n                  if (name1.equals(variable.getName())) {\n                    throw new CancelException();\n                  }\n                }\n              });\n            }\n            catch (CancelException e) {\n              continue NextName;\n            }\n            run = run.getNextSibling();\n            if (scope instanceof PsiMethod || scope instanceof PsiForeachStatement) {//do not check next member for param name conflict\n              break;\n            }\n          }\n\n        }\n        return name;\n      }\n    }\n  }","id":22570,"modified_method":"@Override\n  public String suggestUniqueVariableName(String baseName, PsiElement place, boolean lookForward) {\n    return suggestUniqueVariableName(baseName, place, lookForward, false);\n  }","commit_id":"192f18bb1e19a1fa96372147ab47d072d3ee8ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public SuggestedNameInfo suggestUniqueVariableName(@NotNull final SuggestedNameInfo baseNameInfo,\n                                                     PsiElement place,\n                                                     boolean ignorePlaceName,\n                                                     boolean lookForward) {\n    final String[] names = baseNameInfo.names;\n    final LinkedHashSet<String> uniqueNames = new LinkedHashSet<String>(names.length);\n    for (String name : names) {\n      if (ignorePlaceName && place instanceof PsiNamedElement) {\n        final String placeName = ((PsiNamedElement)place).getName();\n        if (Comparing.strEqual(placeName, name)) {\n          uniqueNames.add(name);\n          continue;\n        }\n      }\n      uniqueNames.add(suggestUniqueVariableName(name, place, lookForward));\n    }\n\n    return new SuggestedNameInfo(ArrayUtil.toStringArray(uniqueNames)) {\n      @Override\n      public void nameChosen(String name) {\n        baseNameInfo.nameChosen(name);\n      }\n    };\n  }","id":22571,"modified_method":"@Override\n  @NotNull\n  public SuggestedNameInfo suggestUniqueVariableName(@NotNull final SuggestedNameInfo baseNameInfo,\n                                                     PsiElement place,\n                                                     boolean ignorePlaceName,\n                                                     boolean lookForward) {\n    final String[] names = baseNameInfo.names;\n    final LinkedHashSet<String> uniqueNames = new LinkedHashSet<String>(names.length);\n    for (String name : names) {\n      if (ignorePlaceName && place instanceof PsiNamedElement) {\n        final String placeName = ((PsiNamedElement)place).getName();\n        if (Comparing.strEqual(placeName, name)) {\n          uniqueNames.add(name);\n          continue;\n        }\n      }\n      String unique = suggestUniqueVariableName(name, place, lookForward);\n      if (!unique.equals(name)) {\n        String withShadowing = suggestUniqueVariableName(name, place, lookForward, true);\n        if (withShadowing.equals(name)) {\n          uniqueNames.add(name);\n        }\n      }\n      uniqueNames.add(unique);\n    }\n\n    return new SuggestedNameInfo(ArrayUtil.toStringArray(uniqueNames)) {\n      @Override\n      public void nameChosen(String name) {\n        baseNameInfo.nameChosen(name);\n      }\n    };\n  }","commit_id":"192f18bb1e19a1fa96372147ab47d072d3ee8ed8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void processIntention(@NotNull PsiElement element)\n            throws IncorrectOperationException {\n        final PsiJavaToken switchToken = (PsiJavaToken)element;\n        final PsiSwitchStatement switchStatement =\n                (PsiSwitchStatement)switchToken.getParent();\n        if (switchStatement == null) {\n            return;\n        }\n        final PsiExpression switchExpression = switchStatement.getExpression();\n        if (switchExpression == null) {\n            return;\n        }\n        final PsiType switchExpressionType = switchExpression.getType();\n        if (switchExpressionType == null) {\n            return;\n        }\n        final boolean useEquals =\n                switchExpressionType.equalsToText(\"java.lang.String\");\n        final String declarationString;\n        final boolean hadSideEffects;\n        final String expressionText;\n        final Project project = element.getProject();\n        if (SideEffectChecker.mayHaveSideEffects(switchExpression)) {\n            hadSideEffects = true;\n\n            final JavaCodeStyleManager javaCodeStyleManager =\n                    JavaCodeStyleManager.getInstance(project);\n            final String variableName =\n                    javaCodeStyleManager.suggestUniqueVariableName(\"i\",\n                            switchExpression, true);\n            expressionText = variableName;\n            declarationString =\n                    switchExpressionType.getPresentableText() + ' ' +\n                            variableName + \" = \" +\n                            switchExpression.getText() + ';';\n        } else {\n            hadSideEffects = false;\n            declarationString = null;\n            expressionText = switchExpression.getText();\n        }\n        final PsiCodeBlock body = switchStatement.getBody();\n        if (body == null) {\n            return;\n        }\n        final PsiStatement[] statements = body.getStatements();\n        boolean renameBreaks = false;\n        for (int i = 1; i < statements.length - 1; i++) {\n            if (CaseUtil.containsHiddenBreak(statements[i])) {\n                renameBreaks = true;\n                break;\n            }\n        }\n\n        final List<SwitchStatementBranch> openBranches =\n                new ArrayList<SwitchStatementBranch>();\n        final Set<PsiLocalVariable> declaredVariables =\n                new HashSet<PsiLocalVariable>();\n        final List<SwitchStatementBranch> allBranches =\n                new ArrayList<SwitchStatementBranch>();\n        SwitchStatementBranch currentBranch = null;\n        final PsiElement[] children = body.getChildren();\n        for (int i = 1; i < children.length - 1; i++) {\n            final PsiElement statement = children[i];\n            if (statement instanceof PsiSwitchLabelStatement) {\n                final PsiSwitchLabelStatement label =\n                        (PsiSwitchLabelStatement)statement;\n                if (currentBranch == null) {\n                    openBranches.clear();\n                    currentBranch = new SwitchStatementBranch();\n                    currentBranch.addPendingVariableDeclarations(declaredVariables);\n                    allBranches.add(currentBranch);\n                    openBranches.add(currentBranch);\n                } else if (currentBranch.hasStatements()) {\n                    currentBranch = new SwitchStatementBranch();\n                    allBranches.add(currentBranch);\n                    openBranches.add(currentBranch);\n                }\n                if (label.isDefaultCase()) {\n                    currentBranch.setDefault();\n                } else {\n                    final PsiExpression value = label.getCaseValue();\n                    final String valueText = getCaseValueText(value);\n                    currentBranch.addCaseValue(valueText);\n                }\n            } else {\n                if (statement instanceof PsiStatement) {\n                    if (statement instanceof PsiDeclarationStatement) {\n                        final PsiDeclarationStatement declarationStatement =\n                                (PsiDeclarationStatement)statement;\n                        final PsiElement[] elements =\n                                declarationStatement.getDeclaredElements();\n                        for (PsiElement varElement : elements) {\n                            final PsiLocalVariable variable =\n                                    (PsiLocalVariable)varElement;\n                            declaredVariables.add(variable);\n                        }\n                    }\n                    for (SwitchStatementBranch branch : openBranches) {\n                        branch.addStatement(statement);\n                    }\n                    if (!ControlFlowUtils.statementMayCompleteNormally(\n                            (PsiStatement)statement)) {\n                        currentBranch = null;\n                    }\n                } else {\n                    for (SwitchStatementBranch branch : openBranches) {\n                        if (statement instanceof PsiWhiteSpace) {\n                            branch.addWhiteSpace(statement);\n                        } else {\n                            branch.addComment(statement);\n                        }\n                    }\n                }\n            }\n        }\n        final StringBuilder ifStatementText = new StringBuilder();\n        String breakLabel = null;\n        if (renameBreaks) {\n            breakLabel = CaseUtil.findUniqueLabel(switchStatement, \"Label\");\n            ifStatementText.append(breakLabel);\n            ifStatementText.append(':');\n        }\n        boolean firstBranch = true;\n        SwitchStatementBranch defaultBranch = null;\n        for (SwitchStatementBranch branch : allBranches) {\n            if (branch.isDefault()) {\n                defaultBranch = branch;\n            } else {\n                final List<String> caseValues = branch.getCaseValues();\n                final List<PsiElement> bodyElements = branch.getBodyElements();\n                final Set<PsiLocalVariable> pendingVariableDeclarations =\n                        branch.getPendingVariableDeclarations();\n                dumpBranch(expressionText, caseValues, bodyElements, breakLabel,\n                        pendingVariableDeclarations, firstBranch, renameBreaks,\n                        useEquals, ifStatementText);\n                firstBranch = false;\n            }\n        }\n        if (defaultBranch != null) {\n            final List<PsiElement> bodyElements =\n                    defaultBranch.getBodyElements();\n            final Set<PsiLocalVariable> pendingVariableDeclarations =\n                    defaultBranch.getPendingVariableDeclarations();\n            dumpDefaultBranch(bodyElements, breakLabel,\n                    pendingVariableDeclarations, firstBranch, renameBreaks,\n                    ifStatementText);\n        }\n        final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        if (hadSideEffects) {\n            final PsiStatement declarationStatement =\n                    factory.createStatementFromText(declarationString,\n                            switchStatement);\n            final PsiStatement ifStatement =\n                    factory.createStatementFromText(ifStatementText.toString(),\n                            switchStatement);\n            final PsiElement parent = switchStatement.getParent();\n            parent.addBefore(declarationStatement, switchStatement);\n            switchStatement.replace(ifStatement);\n        } else {\n            final PsiStatement newStatement =\n                    factory.createStatementFromText(ifStatementText.toString(),\n                            switchStatement);\n            switchStatement.replace(newStatement);\n        }\n    }","id":22572,"modified_method":"@Override\n    public void processIntention(@NotNull PsiElement element)\n            throws IncorrectOperationException {\n        final PsiJavaToken switchToken = (PsiJavaToken)element;\n        final PsiSwitchStatement switchStatement =\n                (PsiSwitchStatement)switchToken.getParent();\n        if (switchStatement == null) {\n            return;\n        }\n        final PsiExpression switchExpression = switchStatement.getExpression();\n        if (switchExpression == null) {\n            return;\n        }\n        final PsiType switchExpressionType = switchExpression.getType();\n        if (switchExpressionType == null) {\n            return;\n        }\n        final boolean isSwitchOnString =\n                switchExpressionType.equalsToText(\"java.lang.String\");\n        final String declarationString;\n        final boolean hadSideEffects;\n        final String expressionText;\n        final Project project = element.getProject();\n        if (SideEffectChecker.mayHaveSideEffects(switchExpression)) {\n            hadSideEffects = true;\n\n            final JavaCodeStyleManager javaCodeStyleManager =\n                    JavaCodeStyleManager.getInstance(project);\n            final String variableName;\n            if (isSwitchOnString) {\n                variableName = javaCodeStyleManager.suggestUniqueVariableName(\n                        \"s\", switchExpression, true);\n            } else {\n                variableName = javaCodeStyleManager.suggestUniqueVariableName(\n                        \"i\", switchExpression, true);\n            }\n            expressionText = variableName;\n            declarationString =\n                    switchExpressionType.getPresentableText() + ' ' +\n                            variableName + \" = \" +\n                            switchExpression.getText() + ';';\n        } else {\n            hadSideEffects = false;\n            declarationString = null;\n            expressionText = switchExpression.getText();\n        }\n        final PsiCodeBlock body = switchStatement.getBody();\n        if (body == null) {\n            return;\n        }\n        final PsiStatement[] statements = body.getStatements();\n        boolean renameBreaks = false;\n        for (int i = 1; i < statements.length - 1; i++) {\n            if (CaseUtil.containsHiddenBreak(statements[i])) {\n                renameBreaks = true;\n                break;\n            }\n        }\n\n        final List<SwitchStatementBranch> openBranches =\n                new ArrayList<SwitchStatementBranch>();\n        final Set<PsiLocalVariable> declaredVariables =\n                new HashSet<PsiLocalVariable>();\n        final List<SwitchStatementBranch> allBranches =\n                new ArrayList<SwitchStatementBranch>();\n        SwitchStatementBranch currentBranch = null;\n        final PsiElement[] children = body.getChildren();\n        for (int i = 1; i < children.length - 1; i++) {\n            final PsiElement statement = children[i];\n            if (statement instanceof PsiSwitchLabelStatement) {\n                final PsiSwitchLabelStatement label =\n                        (PsiSwitchLabelStatement)statement;\n                if (currentBranch == null) {\n                    openBranches.clear();\n                    currentBranch = new SwitchStatementBranch();\n                    currentBranch.addPendingVariableDeclarations(declaredVariables);\n                    allBranches.add(currentBranch);\n                    openBranches.add(currentBranch);\n                } else if (currentBranch.hasStatements()) {\n                    currentBranch = new SwitchStatementBranch();\n                    allBranches.add(currentBranch);\n                    openBranches.add(currentBranch);\n                }\n                if (label.isDefaultCase()) {\n                    currentBranch.setDefault();\n                } else {\n                    final PsiExpression value = label.getCaseValue();\n                    final String valueText = getCaseValueText(value);\n                    currentBranch.addCaseValue(valueText);\n                }\n            } else {\n                if (statement instanceof PsiStatement) {\n                    if (statement instanceof PsiDeclarationStatement) {\n                        final PsiDeclarationStatement declarationStatement =\n                                (PsiDeclarationStatement)statement;\n                        final PsiElement[] elements =\n                                declarationStatement.getDeclaredElements();\n                        for (PsiElement varElement : elements) {\n                            final PsiLocalVariable variable =\n                                    (PsiLocalVariable)varElement;\n                            declaredVariables.add(variable);\n                        }\n                    }\n                    for (SwitchStatementBranch branch : openBranches) {\n                        branch.addStatement(statement);\n                    }\n                    if (!ControlFlowUtils.statementMayCompleteNormally(\n                            (PsiStatement)statement)) {\n                        currentBranch = null;\n                    }\n                } else {\n                    for (SwitchStatementBranch branch : openBranches) {\n                        if (statement instanceof PsiWhiteSpace) {\n                            branch.addWhiteSpace(statement);\n                        } else {\n                            branch.addComment(statement);\n                        }\n                    }\n                }\n            }\n        }\n        final StringBuilder ifStatementText = new StringBuilder();\n        String breakLabel = null;\n        if (renameBreaks) {\n            breakLabel = CaseUtil.findUniqueLabel(switchStatement, \"Label\");\n            ifStatementText.append(breakLabel);\n            ifStatementText.append(':');\n        }\n        boolean firstBranch = true;\n        SwitchStatementBranch defaultBranch = null;\n        for (SwitchStatementBranch branch : allBranches) {\n            if (branch.isDefault()) {\n                defaultBranch = branch;\n            } else {\n                final List<String> caseValues = branch.getCaseValues();\n                final List<PsiElement> bodyElements = branch.getBodyElements();\n                final Set<PsiLocalVariable> pendingVariableDeclarations =\n                        branch.getPendingVariableDeclarations();\n                dumpBranch(expressionText, caseValues, bodyElements, breakLabel,\n                        pendingVariableDeclarations, firstBranch, renameBreaks,\n                        isSwitchOnString, ifStatementText);\n                firstBranch = false;\n            }\n        }\n        if (defaultBranch != null) {\n            final List<PsiElement> bodyElements =\n                    defaultBranch.getBodyElements();\n            final Set<PsiLocalVariable> pendingVariableDeclarations =\n                    defaultBranch.getPendingVariableDeclarations();\n            dumpDefaultBranch(bodyElements, breakLabel,\n                    pendingVariableDeclarations, firstBranch, renameBreaks,\n                    ifStatementText);\n        }\n        final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n        final PsiElementFactory factory = psiFacade.getElementFactory();\n        if (hadSideEffects) {\n            final PsiStatement declarationStatement =\n                    factory.createStatementFromText(declarationString,\n                            switchStatement);\n            final PsiStatement ifStatement =\n                    factory.createStatementFromText(ifStatementText.toString(),\n                            switchStatement);\n            final PsiElement parent = switchStatement.getParent();\n            parent.addBefore(declarationStatement, switchStatement);\n            switchStatement.replace(ifStatement);\n        } else {\n            final PsiStatement newStatement =\n                    factory.createStatementFromText(ifStatementText.toString(),\n                            switchStatement);\n            switchStatement.replace(newStatement);\n        }\n    }","commit_id":"bb89d09e473ea2e9b4cf0f15462a1e35ab66c86d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        //-----------------------------\n        // ILLUMINA\n        //-----------------------------\n\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"ILLUMINA\" ) ) {\n            int cycle = offset;\n\t        if( read.getReadNegativeStrandFlag() ) {\n\t            cycle = read.getReadLength() - (offset + 1);\n\t        }\n\t        return cycle;\n        }\n\n        //-----------------------------\n        // 454\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().contains( \"454\" ) ) { // Some bams have \"LS454\" and others have just \"454\"\n            int cycle = 0;\n            //BUGBUG: should reverse directions on negative strand reads!\n            byte prevBase = read.getReadBases()[0];\n            for( int iii = 1; iii <= offset; iii++ ) {\n                if(read.getReadBases()[iii] != prevBase) { // This base doesn't match the previous one so it is a new cycle\n                    cycle++;\n                    prevBase = read.getReadBases()[iii];\n                }\n            }\n            return cycle;\n        }\n\n        //-----------------------------\n        // SOLID\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) {\n            // The ligation cycle according to http://www3.appliedbiosystems.com/cms/groups/mcb_marketing/documents/generaldocuments/cms_057511.pdf\n            //BUGBUG: should reverse directions on negative strand reads!\n        \treturn offset / 5; // integer division\n        }\n\n        //-----------------------------\n        // UNRECOGNIZED PLATFORM\n        //-----------------------------\n\n        else { // Platform is unrecognized so revert to the default platform but warn the user first\n        \tif( !warnedUserBadPlatform ) {\n                if( defaultPlatform != null) { // the user set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to \" + defaultPlatform + \" definition of machine cycle.\" );\n                } else { // the user did not set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to Illumina definition of machine cycle. Users may set the default platform using the --default_platform <String> argument.\" );\n                    defaultPlatform = \"Illumina\";\n                }\n                warnedUserBadPlatform = true;\n            }\n            read.getReadGroup().setPlatform( defaultPlatform );\n            return getValue( read, offset ); // a recursive call\n        }\n    }","id":22573,"modified_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        //-----------------------------\n        // ILLUMINA\n        //-----------------------------\n\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"ILLUMINA\" ) ) {\n            int cycle = offset;\n\t        if( read.getReadNegativeStrandFlag() ) {\n\t            cycle = read.getReadLength() - (offset + 1);\n\t        }\n\t        return cycle;\n        }\n\n        //-----------------------------\n        // 454\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().contains( \"454\" ) ) { // Some bams have \"LS454\" and others have just \"454\"\n            int cycle = 0;\n            //BUGBUG: should reverse directions on negative strand reads!\n            byte[] bases = read.getReadBases();\n            byte prevBase = bases[0];\n            for( int iii = 1; iii <= offset; iii++ ) {\n                if( bases[iii] != prevBase ) { // This base doesn't match the previous one so it is a new cycle\n                    cycle++;\n                    prevBase = bases[iii];\n                }\n            }\n            return cycle;\n        }\n\n        //-----------------------------\n        // SOLID\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) {\n            // The ligation cycle according to http://www3.appliedbiosystems.com/cms/groups/mcb_marketing/documents/generaldocuments/cms_057511.pdf\n            //BUGBUG: should reverse directions on negative strand reads!\n        \treturn offset / 5; // integer division\n        }\n\n        //-----------------------------\n        // UNRECOGNIZED PLATFORM\n        //-----------------------------\n\n        else { // Platform is unrecognized so revert to the default platform but warn the user first\n        \tif( !warnedUserBadPlatform ) {\n                if( defaultPlatform != null) { // the user set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to \" + defaultPlatform + \" definition of machine cycle.\" );\n                } else { // the user did not set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to Illumina definition of machine cycle. Users may set the default platform using the --default_platform <String> argument.\" );\n                    defaultPlatform = \"Illumina\";\n                }\n                warnedUserBadPlatform = true;\n            }\n            read.getReadGroup().setPlatform( defaultPlatform );\n            return getValue( read, offset ); // a recursive call\n        }\n    }","commit_id":"6bb864da2a7941caaebb0de351cb488164b69a7c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n    \t\n    \t// Loop over the list of base quality scores in the window and find the minimum\n        int minQual = read.getBaseQualities()[offset];\n        int minIndex = Math.max(offset - windowReach, 0);\n        int maxIndex = Math.min(offset + windowReach, read.getBaseQualities().length - 1);\n        for ( int iii = minIndex; iii < maxIndex; iii++ ) {\n            if( read.getBaseQualities()[iii] < minQual ) {\n                minQual = read.getBaseQualities()[iii];\n            }\n        }\n        return minQual;\n    }","id":22574,"modified_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n    \t\n    \t// Loop over the list of base quality scores in the window and find the minimum\n        byte[] quals = read.getBaseQualities();\n        int minQual = quals[offset];\n        int minIndex = Math.max(offset - windowReach, 0);\n        int maxIndex = Math.min(offset + windowReach, quals.length - 1);\n        for ( int iii = minIndex; iii < maxIndex; iii++ ) {\n            if( quals[iii] < minQual ) {\n                minQual = quals[iii];\n            }\n        }\n        return minQual;\n    }","commit_id":"6bb864da2a7941caaebb0de351cb488164b69a7c","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each read at this locus get the various covariate values and increment that location in the map based on\n     *   whether or not the base matches the reference at this particular location\n     * @param tracker The reference metadata tracker\n     * @param ref The reference context\n     * @param context The alignment context\n     * @return Returns 1, but this value isn't used in the reduce step\n     */\n    public Integer map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        // Pull out anything passed by -B name,type,file that has the name \"dbsnp\"\n        final RODRecordList<ReferenceOrderedDatum> dbsnpRODs = tracker.getTrackData( \"dbsnp\", null );\n        boolean isSNP = false;\n        if (dbsnpRODs != null) {\n            for( ReferenceOrderedDatum rod : dbsnpRODs ) {\n                if( ((Variation)rod).isSNP() ) {\n                    isSNP = true; // At least one of the rods says this is a snp site\n                    break;\n                }\n            }\n        }\n\n        // Only use data from non-dbsnp sites\n        // Assume every mismatch at a non-dbsnp site is indicitive of poor quality\n        if( !isSNP && ( ++numUnprocessed >= PROCESS_EVERY_NTH_LOCUS ) ) {\n            numUnprocessed = 0; // Reset the counter because we are processing this very locus\n\n            SAMRecord read;\n            int offset;\n            byte refBase;\n            byte prevBase;\n            byte[] colorSpaceQuals;\n\n            // For each read at this locus\n            for ( PileupElement p : context.getPileup() ) {\n                read = p.getRead();\n                offset = p.getOffset();\n\n                RecalDataManager.parseSAMRecord(read, RAC);\n\n                // Skip first and last base because there is no dinuc\n                // BUGBUG: Technically we only have to skip the first base on forward reads and the last base on negative strand reads. Change after passing old integration tests.\n                if( offset > 0 ) {\n                    if( offset < read.getReadLength() - 1 ) {\n                        // Skip if base quality is zero\n                        if( read.getBaseQualities()[offset] > 0 ) {\n\n                            refBase = (byte)ref.getBase();\n                            prevBase = read.getReadBases()[offset - 1];\n\n                            // DinucCovariate is responsible for getting the complement bases if needed\n                            if( read.getReadNegativeStrandFlag() ) {\n                                prevBase = read.getReadBases()[offset + 1];\n                            }\n\n                            // Skip if this base or the previous one was an 'N' or etc.\n                            if( BaseUtils.isRegularBase( (char)prevBase ) && BaseUtils.isRegularBase( (char)(read.getReadBases()[offset]) ) ) {\n\n                                // SOLID bams insert the reference base into the read if the color space quality is zero, so skip over them\n                                colorSpaceQuals = null;\n                                if( read.getReadGroup().getPlatform().equalsIgnoreCase(\"SOLID\") ) {\n                                    colorSpaceQuals = QualityUtils.fastqToPhred((String)read.getAttribute(RecalDataManager.COLOR_SPACE_QUAL_ATTRIBUTE_TAG));\n                                }\n                                if( colorSpaceQuals == null || colorSpaceQuals[offset] > 0 ) //BUGBUG: This isn't exactly correct yet\n                                {\n                                    // This base finally passed all the checks for a good base, so add it to the big data hashmap\n                                    updateDataFromRead( read, offset, refBase );\n                                }\n                            } else {\n                                if( RAC.VALIDATE_OLD_RECALIBRATOR ) {\n                                    countedBases++; // Replicating a small bug in the old recalibrator\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            countedSites++;\n        } else { // We skipped over the dbSNP site, and we are only processing every Nth locus\n            skippedSites++;\n            if( isSNP ) {\n                updateMismatchCounts(dbSNP_counts, context, ref.getBase());// For sanity check to ensure novel mismatch rate vs dnsnp mismatch rate is reasonable\n            }\n        }\n\n        // Do a dbSNP sanity check every so often\n        if( ++lociSinceLastDbsnpCheck == DBSNP_VALIDATION_CHECK_FREQUENCY ) {\n            lociSinceLastDbsnpCheck = 0;\n            validateDbsnpMismatchRate();\n        }\n\n        return 1; // This value isn't actually used anywhere\n    }","id":22575,"modified_method":"/**\n     * For each read at this locus get the various covariate values and increment that location in the map based on\n     *   whether or not the base matches the reference at this particular location\n     * @param tracker The reference metadata tracker\n     * @param ref The reference context\n     * @param context The alignment context\n     * @return Returns 1, but this value isn't used in the reduce step\n     */\n    public Integer map( RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context ) {\n\n        // Pull out anything passed by -B name,type,file that has the name \"dbsnp\"\n        final RODRecordList<ReferenceOrderedDatum> dbsnpRODs = tracker.getTrackData( \"dbsnp\", null );\n        boolean isSNP = false;\n        if (dbsnpRODs != null) {\n            for( ReferenceOrderedDatum rod : dbsnpRODs ) {\n                if( ((Variation)rod).isSNP() ) {\n                    isSNP = true; // At least one of the rods says this is a snp site\n                    break;\n                }\n            }\n        }\n\n        // Only use data from non-dbsnp sites\n        // Assume every mismatch at a non-dbsnp site is indicitive of poor quality\n        if( !isSNP && ( ++numUnprocessed >= PROCESS_EVERY_NTH_LOCUS ) ) {\n            numUnprocessed = 0; // Reset the counter because we are processing this very locus\n\n            SAMRecord read;\n            int offset;\n            byte refBase;\n            byte prevBase;\n            byte[] colorSpaceQuals;\n            byte[] bases;\n\n            // For each read at this locus\n            for ( PileupElement p : context.getPileup() ) {\n                read = p.getRead();\n                offset = p.getOffset();\n\n                RecalDataManager.parseSAMRecord(read, RAC);\n\n                // Skip first and last base because there is no dinuc\n                // BUGBUG: Technically we only have to skip the first base on forward reads and the last base on negative strand reads. Change after passing old integration tests.\n                if( offset > 0 ) {\n                    if( offset < read.getReadLength() - 1 ) {\n                        // Skip if base quality is zero\n                        if( read.getBaseQualities()[offset] > 0 ) {\n\n                            bases = read.getReadBases();\n                            refBase = (byte)ref.getBase();\n                            prevBase = bases[offset - 1];\n\n                            // DinucCovariate is responsible for getting the complement bases if needed\n                            if( read.getReadNegativeStrandFlag() ) {\n                                prevBase = bases[offset + 1];\n                            }\n\n                            // Skip if this base or the previous one was an 'N' or etc.\n                            // BUGBUG: For DinucCovariate we should use previous reference base, not the previous base in this read. \n                            if( BaseUtils.isRegularBase( (char)prevBase ) && BaseUtils.isRegularBase( (char)(bases[offset]) ) ) {\n\n                                // SOLID bams insert the reference base into the read if the color space quality is zero, so skip over them\n                                colorSpaceQuals = null;\n                                if( read.getReadGroup().getPlatform().equalsIgnoreCase(\"SOLID\") ) {\n                                    colorSpaceQuals = QualityUtils.fastqToPhred((String)read.getAttribute(RecalDataManager.COLOR_SPACE_QUAL_ATTRIBUTE_TAG));\n                                }\n                                if( colorSpaceQuals == null || colorSpaceQuals[offset] > 0 ) //BUGBUG: This isn't exactly correct yet\n                                {\n                                    // This base finally passed all the checks for a good base, so add it to the big data hashmap\n                                    updateDataFromRead( read, offset, refBase );\n                                }\n                            } else {\n                                if( RAC.VALIDATE_OLD_RECALIBRATOR ) {\n                                    countedBases++; // Replicating a small bug in the old recalibrator\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            countedSites++;\n        } else { // We skipped over the dbSNP site, and we are only processing every Nth locus\n            skippedSites++;\n            if( isSNP ) {\n                updateMismatchCounts(dbSNP_counts, context, ref.getBase());// For sanity check to ensure novel mismatch rate vs dnsnp mismatch rate is reasonable\n            }\n        }\n\n        // Do a dbSNP sanity check every so often\n        if( ++lociSinceLastDbsnpCheck == DBSNP_VALIDATION_CHECK_FREQUENCY ) {\n            lociSinceLastDbsnpCheck = 0;\n            validateDbsnpMismatchRate();\n        }\n\n        return 1; // This value isn't actually used anywhere\n    }","commit_id":"b89b9adb2cac529daee8d221983b86e7dd5c29fb","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        //-----------------------------\n        // ILLUMINA\n        //-----------------------------\n\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"ILLUMINA\" ) ) {\n            int cycle = offset;\n\t        if( read.getReadNegativeStrandFlag() ) {\n\t            cycle = read.getReadLength() - (offset + 1);\n\t        }\n\t        return cycle;\n        }\n\n        //-----------------------------\n        // 454\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().contains( \"454\" ) ) { // Some bams have \"LS454\" and others have just \"454\"\n            int cycle = 0;\n            //BUGBUG: should reverse directions on negative strand reads!\n            byte prevBase = read.getReadBases()[0];\n            for( int iii = 1; iii <= offset; iii++ ) {\n                if(read.getReadBases()[iii] != prevBase) { // This base doesn't match the previous one so it is a new cycle\n                    cycle++;\n                    prevBase = read.getReadBases()[iii];\n                }\n            }\n            return cycle;\n        }\n\n        //-----------------------------\n        // SOLID\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) {\n            // The ligation cycle according to http://www3.appliedbiosystems.com/cms/groups/mcb_marketing/documents/generaldocuments/cms_057511.pdf\n            //BUGBUG: should reverse directions on negative strand reads!\n        \treturn offset / 5; // integer division\n        }\n\n        //-----------------------------\n        // UNRECOGNIZED PLATFORM\n        //-----------------------------\n\n        else { // Platform is unrecognized so revert to the default platform but warn the user first\n        \tif( !warnedUserBadPlatform ) {\n                if( defaultPlatform != null) { // the user set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to \" + defaultPlatform + \" definition of machine cycle.\" );\n                } else { // the user did not set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to Illumina definition of machine cycle. Users may set the default platform using the --default_platform <String> argument.\" );\n                    defaultPlatform = \"Illumina\";\n                }\n                warnedUserBadPlatform = true;\n            }\n            //ReadHashDatum correctedReadDatum = new ReadHashDatum( readDatum );\n            //correctedReadDatum.platform = defaultPlatform;\n            return 0; // BUGBUG: broken at the moment\n            //return getValue( correctedReadDatum, offset ); // a recursive call\n        }\n                                                        \n    }","id":22576,"modified_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        //-----------------------------\n        // ILLUMINA\n        //-----------------------------\n\n        if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"ILLUMINA\" ) ) {\n            int cycle = offset;\n\t        if( read.getReadNegativeStrandFlag() ) {\n\t            cycle = read.getReadLength() - (offset + 1);\n\t        }\n\t        return cycle;\n        }\n\n        //-----------------------------\n        // 454\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().contains( \"454\" ) ) { // Some bams have \"LS454\" and others have just \"454\"\n            int cycle = 0;\n            //BUGBUG: should reverse directions on negative strand reads!\n            byte prevBase = read.getReadBases()[0];\n            for( int iii = 1; iii <= offset; iii++ ) {\n                if(read.getReadBases()[iii] != prevBase) { // This base doesn't match the previous one so it is a new cycle\n                    cycle++;\n                    prevBase = read.getReadBases()[iii];\n                }\n            }\n            return cycle;\n        }\n\n        //-----------------------------\n        // SOLID\n        //-----------------------------\n\n        else if( read.getReadGroup().getPlatform().equalsIgnoreCase( \"SOLID\" ) ) {\n            // The ligation cycle according to http://www3.appliedbiosystems.com/cms/groups/mcb_marketing/documents/generaldocuments/cms_057511.pdf\n            //BUGBUG: should reverse directions on negative strand reads!\n        \treturn offset / 5; // integer division\n        }\n\n        //-----------------------------\n        // UNRECOGNIZED PLATFORM\n        //-----------------------------\n\n        else { // Platform is unrecognized so revert to the default platform but warn the user first\n        \tif( !warnedUserBadPlatform ) {\n                if( defaultPlatform != null) { // the user set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to \" + defaultPlatform + \" definition of machine cycle.\" );\n                } else { // the user did not set a default platform\n                    Utils.warnUser( \"Platform string (\" + read.getReadGroup().getPlatform() + \") unrecognized in CycleCovariate. \" +\n                            \"Reverting to Illumina definition of machine cycle. Users may set the default platform using the --default_platform <String> argument.\" );\n                    defaultPlatform = \"Illumina\";\n                }\n                warnedUserBadPlatform = true;\n            }\n            read.getReadGroup().setPlatform( defaultPlatform );\n            return getValue( read, offset ); // a recursive call\n        }\n    }","commit_id":"b89b9adb2cac529daee8d221983b86e7dd5c29fb","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        byte base;\n        byte prevBase;\n        // If this is a negative strand read then we need to reverse the direction for our previous base\n        if( read.getReadNegativeStrandFlag() ) {\n            base = (byte)BaseUtils.simpleComplement( (char)(read.getReadBases()[offset]) );\n            prevBase = (byte)BaseUtils.simpleComplement( (char)(read.getReadBases()[offset + 1]) );\n        } else {\n            base = read.getReadBases()[offset];\n            prevBase = read.getReadBases()[offset - 1];\n        }\n        //char[] charArray = {(char)prevBase, (char)base};\n        //return new String( charArray ); // This is an expensive call\n        return dinucHashMap.get( Dinuc.hashBytes( prevBase, base ) );\n        //return String.format(\"%c%c\", prevBase, base); // This return statement is too slow\n    }","id":22577,"modified_method":"public final Comparable getValue( final SAMRecord read, final int offset ) {\n\n        byte base;\n        byte prevBase;\n        byte[] bases = read.getReadBases();\n        // If this is a negative strand read then we need to reverse the direction for our previous base\n        if( read.getReadNegativeStrandFlag() ) {\n            base = (byte)BaseUtils.simpleComplement( (char)(bases[offset]) );\n            prevBase = (byte)BaseUtils.simpleComplement( (char)(bases[offset + 1]) );\n        } else {\n            base = bases[offset];\n            prevBase = bases[offset - 1];\n        }\n        return dinucHashMap.get( Dinuc.hashBytes( prevBase, base ) );\n    }","commit_id":"b89b9adb2cac529daee8d221983b86e7dd5c29fb","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Section of code shared between the two recalibration walkers which uses the command line arguments to adjust attributes of the read such as quals or platform string\n     * @param read The read to adjust\n     * @param RAC The list of shared command line arguments\n     */\n    public static void parseSAMRecord( final SAMRecord read, final RecalibrationArgumentCollection RAC) {\n\n        // Check if we need to use the original quality scores instead\n        if ( RAC.USE_ORIGINAL_QUALS && read.getAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG) != null ) {\n            Object obj = read.getAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG);\n            if ( obj instanceof String )\n                read.setBaseQualities( QualityUtils.fastqToPhred((String)obj) );\n            else {\n                throw new RuntimeException(String.format(\"Value encoded by %s in %s isn't a string!\", RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG, read.getReadName()));\n            }\n        }\n\n        SAMReadGroupRecord readGroup = read.getReadGroup();\n\n        // If there are no read groups we have to default to something, and that something could be specified by the user using command line arguments\n        if( readGroup == null ) {\n            if( !warnUserNullReadGroup && RAC.FORCE_READ_GROUP == null ) {\n                Utils.warnUser(\"The input .bam file contains reads with no read group. \" +\n                                \"Defaulting to read group ID = \" + RAC.DEFAULT_READ_GROUP + \" and platform = \" + RAC.DEFAULT_PLATFORM + \". \" +\n                                \"First observed at read with name = \" + read.getReadName() );\n                warnUserNullReadGroup = true;\n            }\n            // There is no readGroup so defaulting to these values\n            readGroup = new SAMReadGroupRecord( RAC.DEFAULT_READ_GROUP );\n            readGroup.setPlatform( RAC.DEFAULT_PLATFORM );\n            ((GATKSAMRecord)read).setReadGroup( readGroup );\n        }\n\n        if( RAC.FORCE_READ_GROUP != null && !read.getReadGroup().getReadGroupId().equals(RAC.FORCE_READ_GROUP) ) { // Collapse all the read groups into a single common String provided by the user\n            String oldPlatform = readGroup.getPlatform();\n            readGroup = new SAMReadGroupRecord( RAC.FORCE_READ_GROUP );\n            readGroup.setPlatform( oldPlatform );\n            ((GATKSAMRecord)read).setReadGroup( readGroup );\n        }\n\n        if( RAC.FORCE_PLATFORM != null && !read.getReadGroup().getPlatform().equals(RAC.FORCE_PLATFORM)) {\n            read.getReadGroup().setPlatform( RAC.FORCE_PLATFORM );\n        }\n    }","id":22578,"modified_method":"/**\n     * Section of code shared between the two recalibration walkers which uses the command line arguments to adjust attributes of the read such as quals or platform string\n     * @param read The read to adjust\n     * @param RAC The list of shared command line arguments\n     */\n    public static void parseSAMRecord( final SAMRecord read, final RecalibrationArgumentCollection RAC) {\n\n        // Check if we need to use the original quality scores instead\n        if ( RAC.USE_ORIGINAL_QUALS && read.getAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG) != null ) {\n            Object obj = read.getAttribute(RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG);\n            if ( obj instanceof String )\n                read.setBaseQualities( QualityUtils.fastqToPhred((String)obj) );\n            else {\n                throw new RuntimeException(String.format(\"Value encoded by %s in %s isn't a string!\", RecalDataManager.ORIGINAL_QUAL_ATTRIBUTE_TAG, read.getReadName()));\n            }\n        }\n\n        SAMReadGroupRecord readGroup = read.getReadGroup();\n\n        // If there are no read groups we have to default to something, and that something could be specified by the user using command line arguments\n        if( readGroup == null ) {\n            if( !warnUserNullReadGroup && RAC.FORCE_READ_GROUP == null ) {\n                Utils.warnUser(\"The input .bam file contains reads with no read group. \" +\n                                \"Defaulting to read group ID = \" + RAC.DEFAULT_READ_GROUP + \" and platform = \" + RAC.DEFAULT_PLATFORM + \". \" +\n                                \"First observed at read with name = \" + read.getReadName() );\n                warnUserNullReadGroup = true;\n            }\n            // There is no readGroup so defaulting to these values\n            readGroup = new SAMReadGroupRecord( RAC.DEFAULT_READ_GROUP );\n            readGroup.setPlatform( RAC.DEFAULT_PLATFORM );\n            ((GATKSAMRecord)read).setReadGroup( readGroup );\n        }\n\n        if( RAC.FORCE_READ_GROUP != null && !readGroup.getReadGroupId().equals(RAC.FORCE_READ_GROUP) ) { // Collapse all the read groups into a single common String provided by the user\n            String oldPlatform = readGroup.getPlatform();\n            readGroup = new SAMReadGroupRecord( RAC.FORCE_READ_GROUP );\n            readGroup.setPlatform( oldPlatform );\n            ((GATKSAMRecord)read).setReadGroup( readGroup );\n        }\n\n        if( RAC.FORCE_PLATFORM != null && !readGroup.getPlatform().equals(RAC.FORCE_PLATFORM)) {\n            readGroup.setPlatform( RAC.FORCE_PLATFORM );\n        }\n    }","commit_id":"b89b9adb2cac529daee8d221983b86e7dd5c29fb","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * For each covariate read in a value and parse it. Associate those values with the data itself (num observation and num mismatches)\n     * @param line A line of CSV data read from the recalibration table data file\n     */\n    private void addCSVData(String line) {\n        String[] vals = line.split(\",\");\n\n        // Check if the data line is malformed, for example if the read group string contains a comma then it won't be parsed correctly\n        if( vals.length != requestedCovariates.size() + 3 ) { // +3 because of nObservations, nMismatch, and Qempirical\n            throw new StingException(\"Malformed input recalibration file. Found data line with too many fields: \" + line +\n                    \" --Perhaps the read group string contains a comma and isn't parsed correctly.\");\n        }\n\n        ArrayList<Comparable> key = new ArrayList<Comparable>();\n        Covariate cov;\n        int iii;\n        for( iii = 0; iii < requestedCovariates.size(); iii++ ) {\n            cov = requestedCovariates.get( iii );\n            if( RAC.VALIDATE_OLD_RECALIBRATOR ) {\n                if( iii == 1 ) { // Order is different in the old recalibrator unfortunately\n                    key.add( cov.getValue( vals[2] ) );\n                } else if ( iii == 2 ) {\n                    key.add( cov.getValue( vals[1] ) );\n                } else {\n                    key.add( cov.getValue( vals[iii] ) );\n                }\n            } else {\n                key.add( cov.getValue( vals[iii] ) );\n            }\n        }\n        // Create a new datum using the number of observations and number of mismatches\n        RecalDatum datum = new RecalDatum( Long.parseLong( vals[iii] ), Long.parseLong( vals[iii + 1] ) );\n        // Add that datum to all the collapsed tables which will be used in the sequential calculation\n        dataManager.addToAllTables( key, datum );\n        \n    }","id":22579,"modified_method":"/**\n     * For each covariate read in a value and parse it. Associate those values with the data itself (num observation and num mismatches)\n     * @param line A line of CSV data read from the recalibration table data file\n     */\n    private void addCSVData(String line) {\n        String[] vals = line.split(\",\");\n\n        // Check if the data line is malformed, for example if the read group string contains a comma then it won't be parsed correctly\n        if( vals.length != requestedCovariates.size() + 3 ) { // +3 because of nObservations, nMismatch, and Qempirical\n            throw new StingException(\"Malformed input recalibration file. Found data line with too many fields: \" + line +\n                    \" --Perhaps the read group string contains a comma and isn't being parsed correctly.\");\n        }\n\n        ArrayList<Comparable> key = new ArrayList<Comparable>();\n        Covariate cov;\n        int iii;\n        for( iii = 0; iii < requestedCovariates.size(); iii++ ) {\n            cov = requestedCovariates.get( iii );\n            if( RAC.VALIDATE_OLD_RECALIBRATOR ) {\n                if( iii == 1 ) { // Order is different in the old recalibrator unfortunately\n                    key.add( cov.getValue( vals[2] ) );\n                } else if ( iii == 2 ) {\n                    key.add( cov.getValue( vals[1] ) );\n                } else {\n                    key.add( cov.getValue( vals[iii] ) );\n                }\n            } else {\n                key.add( cov.getValue( vals[iii] ) );\n            }\n        }\n        // Create a new datum using the number of observations and number of mismatches\n        RecalDatum datum = new RecalDatum( Long.parseLong( vals[iii] ), Long.parseLong( vals[iii + 1] ) );\n        // Add that datum to all the collapsed tables which will be used in the sequential calculation\n        dataManager.addToAllTables( key, datum );\n        \n    }","commit_id":"b89b9adb2cac529daee8d221983b86e7dd5c29fb","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Close the output bam file\n     * @param output The SAMFileWriter that outputs the bam file\n     */\n    public void onTraversalDone(SAMFileWriter output) {\n        if ( output != null ) {\n            output.close();\n        }\n        super.onTraversalDone(output);\n    }","id":22580,"modified_method":"/**\n     * Close the output bam file\n     * @param output The SAMFileWriter that outputs the bam file\n     */\n    public void onTraversalDone(SAMFileWriter output) {\n        if ( output != null ) {\n            output.close();\n        }\n    }","commit_id":"b89b9adb2cac529daee8d221983b86e7dd5c29fb","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Haplotype getConsensusHaplotype(Haplotype haplotypeA, Haplotype haplotypeB) {\n        byte[] a = haplotypeA.getBasesAsBytes();\n        byte[] b = haplotypeB.getBasesAsBytes();\n\n        if (a.length != b.length)\n            throw new ReviewedStingException(\"Haplotypes a and b must be of same length\");\n\n        byte chA, chB;\n        byte wc = (byte)REGEXP_WILDCARD;\n\n        final int length = a.length;\n        byte[] consensusChars = new byte[length];\n        double[] consensusQuals = new double[length];\n\n        for (int i=0; i < length; i++) {\n            chA = a[i];\n            chB = b[i];\n\n            if ((chA != chB) && (chA != wc) && (chB != wc))\n                return null;\n\n            if ((chA == wc) && (chB == wc)) {\n                consensusChars[i] = wc;\n                consensusQuals[i] = 0.0;\n            }\n            else if ((chA == wc)) {\n                consensusChars[i] = chB;\n                consensusQuals[i] = haplotypeB.getQuals()[i];\n            }\n            else if ((chB == wc)){\n                consensusChars[i] = chA;\n                consensusQuals[i] = haplotypeA.getQuals()[i];\n            } else {\n                consensusChars[i] = chA;\n                consensusQuals[i] = haplotypeA.getQuals()[i]+haplotypeB.getQuals()[i];\n            }\n        }\n\n        return new Haplotype(consensusChars, consensusQuals);\n    }","id":22581,"modified_method":"private Haplotype getConsensusHaplotype(Haplotype haplotypeA, Haplotype haplotypeB) {\n        final byte[] a = haplotypeA.getBasesAsBytes();\n        final byte[] b = haplotypeB.getBasesAsBytes();\n\n        if (a.length != b.length)\n            throw new ReviewedStingException(\"Haplotypes a and b must be of same length\");\n\n        byte chA, chB;\n        byte wc = (byte)REGEXP_WILDCARD;\n\n        final int length = a.length;\n        byte[] consensusChars = new byte[length];\n        double[] consensusQuals = new double[length];\n\n        final double[] qualsA = haplotypeA.getQuals();\n        final double[] qualsB = haplotypeB.getQuals();\n\n        for (int i=0; i < length; i++) {\n            chA = a[i];\n            chB = b[i];\n\n            if ((chA != chB) && (chA != wc) && (chB != wc))\n                return null;\n\n            if ((chA == wc) && (chB == wc)) {\n                consensusChars[i] = wc;\n                consensusQuals[i] = 0.0;\n            }\n            else if ((chA == wc)) {\n                consensusChars[i] = chB;\n                consensusQuals[i] = qualsB[i];\n            }\n            else if ((chB == wc)){\n                consensusChars[i] = chA;\n                consensusQuals[i] = qualsA[i];\n            } else {\n                consensusChars[i] = chA;\n                consensusQuals[i] = qualsA[i]+qualsB[i];\n            }\n        }\n\n        return new Haplotype(consensusChars, consensusQuals);\n    }","commit_id":"4f775810871daffb3d5e7a564253481a2bb88ede","url":"https://github.com/broadgsa/gatk"},{"original_method":"private double scoreReadAgainstHaplotype(SAMRecord read, int baseOffsetStart, int contextSize, Haplotype haplotype ) {\n        double expected = 0.0;\n        double mismatches = 0.0;\n\n        // What's the expected mismatch rate under the model that this read is actually sampled from\n        // this haplotype?  Let's assume the consensus base c is a random choice one of A, C, G, or T, and that\n        // the observed base is actually from a c with an error rate e.  Since e is the rate at which we'd\n        // see a miscalled c, the expected mismatch rate is really e.  So the expected number of mismatches\n        // is just sum_i e_i for i from 1..n for n sites\n        //\n        // Now, what's the probabilistic sum of mismatches?  Suppose that the base b is equal to c.  Well, it could\n        // actually be a miscall in a matching direction, which would happen at a e / 3 rate.  If b != c, then\n        // the chance that it is actually a mismatch is 1 - e, since any of the other 3 options would be a mismatch.\n        // so the probability-weighted mismatch rate is sum_i ( matched ? e_i / 3 : 1 - e_i ) for i = 1 ... n\n        for ( int i = 0; i < contextSize; i++ ) {\n            int baseOffset = i + baseOffsetStart;\n            if ( baseOffset < 0 )\n                continue;\n            if ( baseOffset >= read.getReadLength() )\n                break;\n\n            byte haplotypeBase = haplotype.getBasesAsBytes()[i];\n            byte readBase = read.getReadBases()[baseOffset];\n\n            boolean matched = BaseUtils.basesAreEqual(readBase, haplotypeBase );\n            double e = QualityUtils.qualToErrorProb(read.getBaseQualities()[baseOffset]);\n            expected += e;\n            mismatches += matched ? e : 1 - e / 3;\n\n            // a more sophisticated calculation would include the reference quality, but it's nice to actually penalize\n            // the mismatching of poorly determined regions of the consensus\n\n            if ( DEBUG ) System.out.printf(\"Read %s: scoring %c vs. %c => e = %f Q%d esum %f vs. msum %f%n\",\n                    read.getReadName(), (char)haplotypeBase, (char)readBase, e, read.getBaseQualities()[baseOffset], expected, mismatches);\n        }\n\n        return mismatches - expected;\n    }","id":22582,"modified_method":"private double scoreReadAgainstHaplotype(SAMRecord read, int baseOffsetStart, int contextSize, Haplotype haplotype ) {\n        double expected = 0.0;\n        double mismatches = 0.0;\n\n        // What's the expected mismatch rate under the model that this read is actually sampled from\n        // this haplotype?  Let's assume the consensus base c is a random choice one of A, C, G, or T, and that\n        // the observed base is actually from a c with an error rate e.  Since e is the rate at which we'd\n        // see a miscalled c, the expected mismatch rate is really e.  So the expected number of mismatches\n        // is just sum_i e_i for i from 1..n for n sites\n        //\n        // Now, what's the probabilistic sum of mismatches?  Suppose that the base b is equal to c.  Well, it could\n        // actually be a miscall in a matching direction, which would happen at a e / 3 rate.  If b != c, then\n        // the chance that it is actually a mismatch is 1 - e, since any of the other 3 options would be a mismatch.\n        // so the probability-weighted mismatch rate is sum_i ( matched ? e_i / 3 : 1 - e_i ) for i = 1 ... n\n        final byte[] haplotypeBases = haplotype.getBasesAsBytes();\n        final byte[] readBases = read.getReadBases();\n        final byte[] readQuals = read.getBaseQualities();\n        for ( int i = 0; i < contextSize; i++ ) {\n            int baseOffset = i + baseOffsetStart;\n            if ( baseOffset < 0 )\n                continue;\n            if ( baseOffset >= readBases.length )\n                break;\n\n            byte haplotypeBase = haplotypeBases[i];\n            byte readBase = readBases[baseOffset];\n\n            boolean matched = BaseUtils.basesAreEqual(readBase, haplotypeBase );\n            double e = QualityUtils.qualToErrorProb(readQuals[baseOffset]);\n            expected += e;\n            mismatches += matched ? e : 1 - e / 3;\n\n            // a more sophisticated calculation would include the reference quality, but it's nice to actually penalize\n            // the mismatching of poorly determined regions of the consensus\n\n            if ( DEBUG ) System.out.printf(\"Read %s: scoring %c vs. %c => e = %f Q%d esum %f vs. msum %f%n\",\n                    read.getReadName(), (char)haplotypeBase, (char)readBase, e, readQuals[baseOffset], expected, mismatches);\n        }\n\n        return mismatches - expected;\n    }","commit_id":"4f775810871daffb3d5e7a564253481a2bb88ede","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Haplotype getHaplotypeFromRead(ExtendedPileupElement p, int contextSize) {\n        SAMRecord read = p.getRead();\n        int readOffsetFromPileup = p.getOffset();\n        int baseOffsetStart = readOffsetFromPileup - (contextSize - 1)/2;\n        byte[] haplotypeBases = new byte[contextSize];\n\n        for(int i=0; i < contextSize; i++) {\n            haplotypeBases[i] = (byte)REGEXP_WILDCARD;\n        }\n\n        double[] baseQualities = new double[contextSize];\n        Arrays.fill(baseQualities,0.0);\n\n        for (int i = 0; i < contextSize; i++ ) {\n            int baseOffset = i + baseOffsetStart;\n            if ( baseOffset < 0 )\n                continue;\n            if ( baseOffset >= read.getReadLength() )\n                break;\n\n            haplotypeBases[i] = read.getReadBases()[baseOffset];\n            baseQualities[i] = (double)read.getBaseQualities()[baseOffset];\n        }\n\n        return new Haplotype(haplotypeBases, baseQualities);\n    }","id":22583,"modified_method":"private Haplotype getHaplotypeFromRead(ExtendedPileupElement p, int contextSize) {\n        SAMRecord read = p.getRead();\n        int readOffsetFromPileup = p.getOffset();\n        int baseOffsetStart = readOffsetFromPileup - (contextSize - 1)/2;\n        byte[] haplotypeBases = new byte[contextSize];\n\n        for(int i=0; i < contextSize; i++) {\n            haplotypeBases[i] = (byte)REGEXP_WILDCARD;\n        }\n\n        double[] baseQualities = new double[contextSize];\n        Arrays.fill(baseQualities,0.0);\n\n        final byte[] readBases = read.getReadBases();\n        final byte[] readQuals = read.getBaseQualities();\n        for (int i = 0; i < contextSize; i++ ) {\n            int baseOffset = i + baseOffsetStart;\n            if ( baseOffset < 0 )\n                continue;\n            if ( baseOffset >= readBases.length )\n                break;\n\n            haplotypeBases[i] = readBases[baseOffset];\n            baseQualities[i] = (double)readQuals[baseOffset];\n        }\n\n        return new Haplotype(haplotypeBases, baseQualities);\n    }","commit_id":"4f775810871daffb3d5e7a564253481a2bb88ede","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void removeProcessed(Collection<OsmPrimitive> processed) {\n        if (processed == null) return;\n        toAdd.removeAll(processed);\n        toUpdate.removeAll(processed);\n        toDelete.removeAll(processed);\n    }","id":22584,"modified_method":"public void removeProcessed(Collection<IPrimitive> processed) {\n        if (processed == null) return;\n        toAdd.removeAll(processed);\n        toUpdate.removeAll(processed);\n        toDelete.removeAll(processed);\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/** Compare in detail contiguous subsequences of the two files\n     which are known, as a whole, to match each other.\n\n     The results are recorded in the vectors filevec[N].changed_flag, by\n     storing a 1 in the element for each line that is an insertion or deletion.\n\n     The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.\n\n     Note that XLIM, YLIM are exclusive bounds.\n     All line numbers are origin-0 and discarded lines are not counted.  */\n\n    private void compareseq (int xoff, int xlim, int yoff, int ylim) {\n        /* Slide down the bottom initial diagonal. */\n        while (xoff < xlim && yoff < ylim && xvec[xoff] == yvec[yoff]) {\n            ++xoff; ++yoff;\n        }\n        /* Slide up the top initial diagonal. */\n        while (xlim > xoff && ylim > yoff && xvec[xlim - 1] == yvec[ylim - 1]) {\n            --xlim; --ylim;\n        }\n\n        /* Handle simple cases. */\n        if (xoff == xlim) {\n            while (yoff < ylim) {\n                filevec[1].changed_flag[1+filevec[1].realindexes[yoff++]] = true;\n            }\n        } else if (yoff == ylim) {\n            while (xoff < xlim) {\n                filevec[0].changed_flag[1+filevec[0].realindexes[xoff++]] = true;\n            }\n        } else\n        {\n            /* Find a point of correspondence in the middle of the files.  */\n\n            int d = diag (xoff, xlim, yoff, ylim);\n            int c = cost;\n            int f = fdiag[fdiagoff + d];\n            int b = bdiag[bdiagoff + d];\n\n            if (c == 1)\n                /* This should be impossible, because it implies that\n           one of the two subsequences is empty,\n           and that case was handled above without calling `diag'.\n           Let's verify that this is true.  */\n                throw new IllegalArgumentException(\"Empty subsequence\");\n            else\n            {\n                /* Use that point to split this problem into two subproblems.  */\n                compareseq (xoff, b, yoff, b - d);\n                /* This used to use f instead of b,\n           but that is incorrect!\n           It is not necessarily the case that diagonal d\n           has a snake from b to f.  */\n                compareseq (b, xlim, b - d, ylim);\n            }\n        }\n    }","id":22585,"modified_method":"/** Compare in detail contiguous subsequences of the two files\n     which are known, as a whole, to match each other.\n\n     The results are recorded in the vectors filevec[N].changed_flag, by\n     storing a 1 in the element for each line that is an insertion or deletion.\n\n     The subsequence of file 0 is [XOFF, XLIM) and likewise for file 1.\n\n     Note that XLIM, YLIM are exclusive bounds.\n     All line numbers are origin-0 and discarded lines are not counted.  */\n\n    private void compareseq (int xoff, int xlim, int yoff, int ylim) {\n        /* Slide down the bottom initial diagonal. */\n        while (xoff < xlim && yoff < ylim && xvec[xoff] == yvec[yoff]) {\n            ++xoff; ++yoff;\n        }\n        /* Slide up the top initial diagonal. */\n        while (xlim > xoff && ylim > yoff && xvec[xlim - 1] == yvec[ylim - 1]) {\n            --xlim; --ylim;\n        }\n\n        /* Handle simple cases. */\n        if (xoff == xlim) {\n            while (yoff < ylim) {\n                filevec[1].changed_flag[1+filevec[1].realindexes[yoff++]] = true;\n            }\n        } else if (yoff == ylim) {\n            while (xoff < xlim) {\n                filevec[0].changed_flag[1+filevec[0].realindexes[xoff++]] = true;\n            }\n        } else\n        {\n            /* Find a point of correspondence in the middle of the files.  */\n\n            int d = diag (xoff, xlim, yoff, ylim);\n            int c = cost;\n            //int f = fdiag[fdiagoff + d];\n            int b = bdiag[bdiagoff + d];\n\n            if (c == 1)\n                /* This should be impossible, because it implies that\n           one of the two subsequences is empty,\n           and that case was handled above without calling `diag'.\n           Let's verify that this is true.  */\n                throw new IllegalArgumentException(\"Empty subsequence\");\n            else\n            {\n                /* Use that point to split this problem into two subproblems.  */\n                compareseq (xoff, b, yoff, b - d);\n                /* This used to use f instead of b,\n           but that is incorrect!\n           It is not necessarily the case that diagonal d\n           has a snake from b to f.  */\n                compareseq (b, xlim, b - d, ylim);\n            }\n        }\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/** Prepare to find differences between two arrays.  Each element of\n      the arrays is translated to an \"equivalence number\" based on\n      the result of <code>equals<\/code>.  The original Object arrays\n      are no longer needed for computing the differences.  They will\n      be needed again later to print the results of the comparison as\n      an edit script, if desired.\n     */\n    public Diff(Object[] a,Object[] b) {\n        Hashtable h = new Hashtable(a.length + b.length);\n        filevec[0] = new file_data(a,h);\n        filevec[1] = new file_data(b,h);\n    }","id":22586,"modified_method":"/** Prepare to find differences between two arrays.  Each element of\n      the arrays is translated to an \"equivalence number\" based on\n      the result of <code>equals<\/code>.  The original Object arrays\n      are no longer needed for computing the differences.  They will\n      be needed again later to print the results of the comparison as\n      an edit script, if desired.\n     */\n    public Diff(Object[] a,Object[] b) {\n        Hashtable<Object, Integer> h = new Hashtable<Object, Integer>(a.length + b.length);\n        filevec[0] = new file_data(a,h);\n        filevec[1] = new file_data(b,h);\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"file_data(Object[] data,Hashtable h) {\n            buffered_lines = data.length;\n\n            equivs = new int[buffered_lines];\n            undiscarded = new int[buffered_lines];\n            realindexes = new int[buffered_lines];\n\n            for (int i = 0; i < data.length; ++i) {\n                Integer ir = (Integer)h.get(data[i]);\n                if (ir == null) {\n                    h.put(data[i],new Integer(equivs[i] = equiv_max++));\n                } else {\n                    equivs[i] = ir.intValue();\n                }\n            }\n        }","id":22587,"modified_method":"file_data(Object[] data,Hashtable<Object, Integer> h) {\n            buffered_lines = data.length;\n\n            equivs = new int[buffered_lines];\n            undiscarded = new int[buffered_lines];\n            realindexes = new int[buffered_lines];\n\n            for (int i = 0; i < data.length; ++i) {\n                Integer ir = (Integer)h.get(data[i]);\n                if (ir == null) {\n                    h.put(data[i],new Integer(equivs[i] = equiv_max++));\n                } else {\n                    equivs[i] = ir.intValue();\n                }\n            }\n        }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Clean out the data behind the layer. This means clearing the redo/undo lists,\n     * really deleting all deleted objects and reset the modified flags. This should\n     * be done after an upload, even after a partial upload.\n     *\n     * @param processed A list of all objects that were actually uploaded.\n     *         May be <code>null<\/code>, which means nothing has been uploaded\n     */\n    public void cleanupAfterUpload(final Collection<OsmPrimitive> processed) {\n        // return immediately if an upload attempt failed\n        if (processed == null || processed.isEmpty())\n            return;\n\n        Main.main.undoRedo.clean(this);\n\n        // if uploaded, clean the modified flags as well\n        data.cleanupDeletedPrimitives();\n        for (OsmPrimitive p: data.allPrimitives()) {\n            if (processed.contains(p)) {\n                p.setModified(false);\n            }\n        }\n    }","id":22588,"modified_method":"/**\n     * Clean out the data behind the layer. This means clearing the redo/undo lists,\n     * really deleting all deleted objects and reset the modified flags. This should\n     * be done after an upload, even after a partial upload.\n     *\n     * @param processed A list of all objects that were actually uploaded.\n     *         May be <code>null<\/code>, which means nothing has been uploaded\n     */\n    public void cleanupAfterUpload(final Collection<IPrimitive> processed) {\n        // return immediately if an upload attempt failed\n        if (processed == null || processed.isEmpty())\n            return;\n\n        Main.main.undoRedo.clean(this);\n\n        // if uploaded, clean the modified flags as well\n        data.cleanupDeletedPrimitives();\n        for (OsmPrimitive p: data.allPrimitives()) {\n            if (processed.contains(p)) {\n                p.setModified(false);\n            }\n        }\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates the upload task\n     *\n     * @param strategy the upload strategy specification\n     * @param layer the layer. Must not be null.\n     * @param monitor  a progress monitor. If monitor is null, uses {@see NullProgressMonitor#INSTANCE}\n     * @param changeset the changeset to be used\n     * @throws IllegalArgumentException thrown, if layer is null\n     * @throws IllegalArgumentException thrown if strategy is null\n     */\n    public UploadLayerTask(UploadStrategySpecification strategy, OsmDataLayer layer, ProgressMonitor monitor, Changeset changeset) {\n        CheckParameterUtil.ensureParameterNotNull(layer, \"layer\");\n        CheckParameterUtil.ensureParameterNotNull(strategy, \"strategy\");\n        if (monitor == null) {\n            monitor = NullProgressMonitor.INSTANCE;\n        }\n        this.layer = layer;\n        this.monitor = monitor;\n        this.changeset = changeset;\n        this.strategy = strategy;\n        processedPrimitives = new HashSet<OsmPrimitive>();\n    }","id":22589,"modified_method":"/**\n     * Creates the upload task\n     *\n     * @param strategy the upload strategy specification\n     * @param layer the layer. Must not be null.\n     * @param monitor  a progress monitor. If monitor is null, uses {@see NullProgressMonitor#INSTANCE}\n     * @param changeset the changeset to be used\n     * @throws IllegalArgumentException thrown, if layer is null\n     * @throws IllegalArgumentException thrown if strategy is null\n     */\n    public UploadLayerTask(UploadStrategySpecification strategy, OsmDataLayer layer, ProgressMonitor monitor, Changeset changeset) {\n        CheckParameterUtil.ensureParameterNotNull(layer, \"layer\");\n        CheckParameterUtil.ensureParameterNotNull(strategy, \"strategy\");\n        if (monitor == null) {\n            monitor = NullProgressMonitor.INSTANCE;\n        }\n        this.layer = layer;\n        this.monitor = monitor;\n        this.changeset = changeset;\n        this.strategy = strategy;\n        processedPrimitives = new HashSet<IPrimitive>();\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void run() {\n        monitor.indeterminateSubTask(tr(\"Preparing objects to upload ...\"));\n        APIDataSet ds = new APIDataSet(layer.data);\n        try {\n            ds.adjustRelationUploadOrder();\n        } catch(CyclicUploadDependencyException e) {\n            setLastException(e);\n            return;\n        }\n        toUpload = ds.getPrimitives();\n        if (toUpload.isEmpty())\n            return;\n        writer = new OsmServerWriter();\n        try {\n            while(true) {\n                try {\n                    ProgressMonitor m = monitor.createSubTaskMonitor(ProgressMonitor.ALL_TICKS, false);\n                    if (isCanceled()) return;\n                    writer.uploadOsm(strategy, toUpload, changeset, m);\n                    processedPrimitives.addAll((Collection) writer.getProcessedPrimitives()); // OsmPrimitive in => OsmPrimitive out\n                    break;\n                } catch(OsmApiPrimitiveGoneException e) {\n                    recoverFromGoneOnServer(e, monitor);\n                }\n            }\n            if (strategy.isCloseChangesetAfterUpload()) {\n                if (changeset != null && changeset.getId() > 0) {\n                    OsmApi.getOsmApi().closeChangeset(changeset, monitor.createSubTaskMonitor(0, false));\n                }\n            }\n        } catch (Exception sxe) {\n            if (isCanceled()) {\n                System.out.println(\"Ignoring exception caught because upload is canceled. Exception is: \" + sxe.toString());\n                return;\n            }\n            setLastException(sxe);\n        }\n\n        if (isCanceled())\n            return;\n        layer.cleanupAfterUpload(processedPrimitives);\n        layer.onPostUploadToServer();\n\n        // don't process exceptions remembered with setLastException().\n        // Caller is supposed to deal with them.\n    }","id":22590,"modified_method":"@Override\n    public void run() {\n        monitor.indeterminateSubTask(tr(\"Preparing objects to upload ...\"));\n        APIDataSet ds = new APIDataSet(layer.data);\n        try {\n            ds.adjustRelationUploadOrder();\n        } catch(CyclicUploadDependencyException e) {\n            setLastException(e);\n            return;\n        }\n        toUpload = ds.getPrimitives();\n        if (toUpload.isEmpty())\n            return;\n        writer = new OsmServerWriter();\n        try {\n            while(true) {\n                try {\n                    ProgressMonitor m = monitor.createSubTaskMonitor(ProgressMonitor.ALL_TICKS, false);\n                    if (isCanceled()) return;\n                    writer.uploadOsm(strategy, toUpload, changeset, m);\n                    processedPrimitives.addAll(writer.getProcessedPrimitives()); // OsmPrimitive in => OsmPrimitive out\n                    break;\n                } catch(OsmApiPrimitiveGoneException e) {\n                    recoverFromGoneOnServer(e, monitor);\n                }\n            }\n            if (strategy.isCloseChangesetAfterUpload()) {\n                if (changeset != null && changeset.getId() > 0) {\n                    OsmApi.getOsmApi().closeChangeset(changeset, monitor.createSubTaskMonitor(0, false));\n                }\n            }\n        } catch (Exception sxe) {\n            if (isCanceled()) {\n                System.out.println(\"Ignoring exception caught because upload is canceled. Exception is: \" + sxe.toString());\n                return;\n            }\n            setLastException(sxe);\n        }\n\n        if (isCanceled())\n            return;\n        layer.cleanupAfterUpload(processedPrimitives);\n        layer.onPostUploadToServer();\n\n        // don't process exceptions remembered with setLastException().\n        // Caller is supposed to deal with them.\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Retries to recover the upload operation from an exception which was thrown because\n     * an uploaded primitive was already deleted on the server.\n     *\n     * @param e the exception throw by the API\n     * @param monitor a progress monitor\n     * @throws OsmTransferException  thrown if we can't recover from the exception\n     */\n    protected void recoverFromGoneOnServer(OsmApiPrimitiveGoneException e, ProgressMonitor monitor) throws OsmTransferException{\n        if (!e.isKnownPrimitive()) throw e;\n        OsmPrimitive p = getPrimitive(e.getPrimitiveType(), e.getPrimitiveId());\n        if (p == null) throw e;\n        if (p.isDeleted()) {\n            // we tried to delete an already deleted primitive.\n            //\n            System.out.println(tr(\"Warning: object ''{0}'' is already deleted on the server. Skipping this object and retrying to upload.\", p.getDisplayName(DefaultNameFormatter.getInstance())));\n            processedPrimitives.addAll((Collection) writer.getProcessedPrimitives());\n            processedPrimitives.add(p);\n            toUpload.removeAll(processedPrimitives);\n            return;\n        }\n        // exception was thrown because we tried to *update* an already deleted\n        // primitive. We can't resolve this automatically. Re-throw exception,\n        // a conflict is going to be created later.\n        throw e;\n    }","id":22591,"modified_method":"/**\n     * Retries to recover the upload operation from an exception which was thrown because\n     * an uploaded primitive was already deleted on the server.\n     *\n     * @param e the exception throw by the API\n     * @param monitor a progress monitor\n     * @throws OsmTransferException  thrown if we can't recover from the exception\n     */\n    protected void recoverFromGoneOnServer(OsmApiPrimitiveGoneException e, ProgressMonitor monitor) throws OsmTransferException{\n        if (!e.isKnownPrimitive()) throw e;\n        OsmPrimitive p = getPrimitive(e.getPrimitiveType(), e.getPrimitiveId());\n        if (p == null) throw e;\n        if (p.isDeleted()) {\n            // we tried to delete an already deleted primitive.\n            //\n            System.out.println(tr(\"Warning: object ''{0}'' is already deleted on the server. Skipping this object and retrying to upload.\", p.getDisplayName(DefaultNameFormatter.getInstance())));\n            processedPrimitives.addAll(writer.getProcessedPrimitives());\n            processedPrimitives.add(p);\n            toUpload.removeAll(processedPrimitives);\n            return;\n        }\n        // exception was thrown because we tried to *update* an already deleted\n        // primitive. We can't resolve this automatically. Re-throw exception,\n        // a conflict is going to be created later.\n        throw e;\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override protected void realRun() throws SAXException, IOException {\n        try {\n            uploadloop:while(true) {\n                try {\n                    getProgressMonitor().subTask(trn(\"Uploading {0} object...\", \"Uploading {0} objects...\", toUpload.getSize(), toUpload.getSize()));\n                    synchronized(this) {\n                        writer = new OsmServerWriter();\n                    }\n                    writer.uploadOsm(strategy, toUpload.getPrimitives(), changeset, getProgressMonitor().createSubTaskMonitor(1, false));\n\n                    // if we get here we've successfully uploaded the data. Exit the loop.\n                    //\n                    break;\n                } catch(OsmTransferCanceledException e) {\n                    e.printStackTrace();\n                    uploadCanceled = true;\n                    break uploadloop;\n                } catch(OsmApiPrimitiveGoneException e) {\n                    // try to recover from  410 Gone\n                    //\n                    recoverFromGoneOnServer(e, getProgressMonitor());\n                } catch(ChangesetClosedException e) {\n                    processedPrimitives.addAll((Collection) writer.getProcessedPrimitives()); // OsmPrimitive in => OsmPrimitive out\n                    changeset.setOpen(false);\n                    switch(e.getSource()) {\n                    case UNSPECIFIED:\n                        throw e;\n                    case UPDATE_CHANGESET:\n                        // The changeset was closed when we tried to update it. Probably, our\n                        // local list of open changesets got out of sync with the server state.\n                        // The user will have to select another open changeset.\n                        // Rethrow exception - this will be handled later.\n                        //\n                        throw e;\n                    case UPLOAD_DATA:\n                        // Most likely the changeset is full. Try to recover and continue\n                        // with a new changeset, but let the user decide first (see\n                        // recoverFromChangesetFullException)\n                        //\n                        if (recoverFromChangesetFullException()) {\n                            continue;\n                        }\n                        lastException = e;\n                        break uploadloop;\n                    }\n                } finally {\n                    if (writer != null) {\n                        processedPrimitives.addAll((Collection) writer.getProcessedPrimitives());\n                    }\n                    synchronized(this) {\n                        writer = null;\n                    }\n                }\n            }\n        // if required close the changeset\n        //\n        if (strategy.isCloseChangesetAfterUpload() && changeset != null && !changeset.isNew() && changeset.isOpen()) {\n            OsmApi.getOsmApi().closeChangeset(changeset, progressMonitor.createSubTaskMonitor(0, false));\n        }\n        } catch (Exception e) {\n            if (uploadCanceled) {\n                System.out.println(tr(\"Ignoring caught exception because upload is canceled. Exception is: {0}\", e.toString()));\n            } else {\n                lastException = e;\n            }\n        }\n        if (uploadCanceled && processedPrimitives.isEmpty()) return;\n        cleanupAfterUpload();\n    }","id":22592,"modified_method":"@Override protected void realRun() throws SAXException, IOException {\n        try {\n            uploadloop:while(true) {\n                try {\n                    getProgressMonitor().subTask(trn(\"Uploading {0} object...\", \"Uploading {0} objects...\", toUpload.getSize(), toUpload.getSize()));\n                    synchronized(this) {\n                        writer = new OsmServerWriter();\n                    }\n                    writer.uploadOsm(strategy, toUpload.getPrimitives(), changeset, getProgressMonitor().createSubTaskMonitor(1, false));\n\n                    // if we get here we've successfully uploaded the data. Exit the loop.\n                    //\n                    break;\n                } catch(OsmTransferCanceledException e) {\n                    e.printStackTrace();\n                    uploadCanceled = true;\n                    break uploadloop;\n                } catch(OsmApiPrimitiveGoneException e) {\n                    // try to recover from  410 Gone\n                    //\n                    recoverFromGoneOnServer(e, getProgressMonitor());\n                } catch(ChangesetClosedException e) {\n                    processedPrimitives.addAll(writer.getProcessedPrimitives()); // OsmPrimitive in => OsmPrimitive out\n                    changeset.setOpen(false);\n                    switch(e.getSource()) {\n                    case UNSPECIFIED:\n                        throw e;\n                    case UPDATE_CHANGESET:\n                        // The changeset was closed when we tried to update it. Probably, our\n                        // local list of open changesets got out of sync with the server state.\n                        // The user will have to select another open changeset.\n                        // Rethrow exception - this will be handled later.\n                        //\n                        throw e;\n                    case UPLOAD_DATA:\n                        // Most likely the changeset is full. Try to recover and continue\n                        // with a new changeset, but let the user decide first (see\n                        // recoverFromChangesetFullException)\n                        //\n                        if (recoverFromChangesetFullException()) {\n                            continue;\n                        }\n                        lastException = e;\n                        break uploadloop;\n                    }\n                } finally {\n                    if (writer != null) {\n                        processedPrimitives.addAll(writer.getProcessedPrimitives());\n                    }\n                    synchronized(this) {\n                        writer = null;\n                    }\n                }\n            }\n        // if required close the changeset\n        //\n        if (strategy.isCloseChangesetAfterUpload() && changeset != null && !changeset.isNew() && changeset.isOpen()) {\n            OsmApi.getOsmApi().closeChangeset(changeset, progressMonitor.createSubTaskMonitor(0, false));\n        }\n        } catch (Exception e) {\n            if (uploadCanceled) {\n                System.out.println(tr(\"Ignoring caught exception because upload is canceled. Exception is: {0}\", e.toString()));\n            } else {\n                lastException = e;\n            }\n        }\n        if (uploadCanceled && processedPrimitives.isEmpty()) return;\n        cleanupAfterUpload();\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates the task\n     *\n     * @param strategy the upload strategy. Must not be null.\n     * @param layer  the OSM data layer for which data is uploaded. Must not be null.\n     * @param toUpload the collection of primitives to upload. Set to the empty collection if null.\n     * @param changeset the changeset to use for uploading. Must not be null. changeset.getId()\n     * can be 0 in which case the upload task creates a new changeset\n     * @throws IllegalArgumentException thrown if layer is null\n     * @throws IllegalArgumentException thrown if toUpload is null\n     * @throws IllegalArgumentException thrown if strategy is null\n     * @throws IllegalArgumentException thrown if changeset is null\n     */\n    public UploadPrimitivesTask(UploadStrategySpecification strategy, OsmDataLayer layer, APIDataSet toUpload, Changeset changeset) {\n        super(tr(\"Uploading data for layer ''{0}''\", layer.getName()),false /* don't ignore exceptions */);\n        ensureParameterNotNull(layer,\"layer\");\n        ensureParameterNotNull(strategy, \"strategy\");\n        ensureParameterNotNull(changeset, \"changeset\");\n        this.toUpload = toUpload;\n        this.layer = layer;\n        this.changeset = changeset;\n        this.strategy = strategy;\n        this.processedPrimitives = new HashSet<OsmPrimitive>();\n    }","id":22593,"modified_method":"/**\n     * Creates the task\n     *\n     * @param strategy the upload strategy. Must not be null.\n     * @param layer  the OSM data layer for which data is uploaded. Must not be null.\n     * @param toUpload the collection of primitives to upload. Set to the empty collection if null.\n     * @param changeset the changeset to use for uploading. Must not be null. changeset.getId()\n     * can be 0 in which case the upload task creates a new changeset\n     * @throws IllegalArgumentException thrown if layer is null\n     * @throws IllegalArgumentException thrown if toUpload is null\n     * @throws IllegalArgumentException thrown if strategy is null\n     * @throws IllegalArgumentException thrown if changeset is null\n     */\n    public UploadPrimitivesTask(UploadStrategySpecification strategy, OsmDataLayer layer, APIDataSet toUpload, Changeset changeset) {\n        super(tr(\"Uploading data for layer ''{0}''\", layer.getName()),false /* don't ignore exceptions */);\n        ensureParameterNotNull(layer,\"layer\");\n        ensureParameterNotNull(strategy, \"strategy\");\n        ensureParameterNotNull(changeset, \"changeset\");\n        this.toUpload = toUpload;\n        this.layer = layer;\n        this.changeset = changeset;\n        this.strategy = strategy;\n        this.processedPrimitives = new HashSet<IPrimitive>();\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Retries to recover the upload operation from an exception which was thrown because\n     * an uploaded primitive was already deleted on the server.\n     *\n     * @param e the exception throw by the API\n     * @param monitor a progress monitor\n     * @throws OsmTransferException  thrown if we can't recover from the exception\n     */\n    protected void recoverFromGoneOnServer(OsmApiPrimitiveGoneException e, ProgressMonitor monitor) throws OsmTransferException{\n        if (!e.isKnownPrimitive()) throw e;\n        OsmPrimitive p = layer.data.getPrimitiveById(e.getPrimitiveId(), e.getPrimitiveType());\n        if (p == null) throw e;\n        if (p.isDeleted()) {\n            // we tried to delete an already deleted primitive.\n            //\n            System.out.println(tr(\"Warning: object ''{0}'' is already deleted on the server. Skipping this object and retrying to upload.\", p.getDisplayName(DefaultNameFormatter.getInstance())));\n            monitor.appendLogMessage(tr(\"Object ''{0}'' is already deleted. Skipping object in upload.\",p.getDisplayName(DefaultNameFormatter.getInstance())));\n            processedPrimitives.addAll((Collection) writer.getProcessedPrimitives());\n            processedPrimitives.add(p);\n            toUpload.removeProcessed(processedPrimitives);\n            return;\n        }\n        // exception was thrown because we tried to *update* an already deleted\n        // primitive. We can't resolve this automatically. Re-throw exception,\n        // a conflict is going to be created later.\n        throw e;\n    }","id":22594,"modified_method":"/**\n     * Retries to recover the upload operation from an exception which was thrown because\n     * an uploaded primitive was already deleted on the server.\n     *\n     * @param e the exception throw by the API\n     * @param monitor a progress monitor\n     * @throws OsmTransferException  thrown if we can't recover from the exception\n     */\n    protected void recoverFromGoneOnServer(OsmApiPrimitiveGoneException e, ProgressMonitor monitor) throws OsmTransferException{\n        if (!e.isKnownPrimitive()) throw e;\n        OsmPrimitive p = layer.data.getPrimitiveById(e.getPrimitiveId(), e.getPrimitiveType());\n        if (p == null) throw e;\n        if (p.isDeleted()) {\n            // we tried to delete an already deleted primitive.\n            //\n            System.out.println(tr(\"Warning: object ''{0}'' is already deleted on the server. Skipping this object and retrying to upload.\", p.getDisplayName(DefaultNameFormatter.getInstance())));\n            monitor.appendLogMessage(tr(\"Object ''{0}'' is already deleted. Skipping object in upload.\",p.getDisplayName(DefaultNameFormatter.getInstance())));\n            processedPrimitives.addAll(writer.getProcessedPrimitives());\n            processedPrimitives.add(p);\n            toUpload.removeProcessed(processedPrimitives);\n            return;\n        }\n        // exception was thrown because we tried to *update* an already deleted\n        // primitive. We can't resolve this automatically. Re-throw exception,\n        // a conflict is going to be created later.\n        throw e;\n    }","commit_id":"f8e3f7a4a3b13da445ed3035595fb678a3ec94e5","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void showSimpleModuleChooser(final List<ModuleReference> modules, final String entityString, final ChooserCallback<ModuleReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseMPSChooseModel<ModuleReference> goToModuleModel = new BaseMPSChooseModel<ModuleReference>(project, entityString) {\n      public String doGetFullName(Object element) {\n        return ((BaseModuleItem) element).getModuleReference().getModuleFqName();\n      }\n\n      public String doGetObjectName(ModuleReference module) {\n        return module.getModuleFqName();\n      }\n\n      public NavigationItem doGetNavigationItem(final ModuleReference module) {\n        return new BaseModuleItem(module) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(module);\n          }\n        };\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        return (ModuleReference[]) modules.toArray();\n      }\n    };\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToModuleModel, DefaultMatcherFactory.createAllMatcher(goToModuleModel));\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":22595,"modified_method":"public static void showSimpleModuleChooser(final List<ModuleReference> modules, final String entityString, final ChooserCallback<ModuleReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseMPSChooseModel<ModuleReference> goToModuleModel = new BaseMPSChooseModel<ModuleReference>(project, entityString) {\n      public String doGetFullName(Object element) {\n        return ((BaseModuleItem) element).getModuleReference().getModuleFqName();\n      }\n\n      public String doGetObjectName(ModuleReference module) {\n        return module.getModuleFqName();\n      }\n\n      public NavigationItem doGetNavigationItem(final ModuleReference module) {\n        return new BaseModuleItem(module) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(module);\n          }\n        };\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        return (ModuleReference[]) modules.toArray();\n      }\n    };\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToModuleModel, new MPSItemProvider(DefaultMatcherFactory.createAllMatcher(goToModuleModel)),new FakePsiContext() );\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void showSimpleModelChooser(final List<SModelReference> models, final ChooserCallback<SModelReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getModelReference());\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        return models.toArray(new SModelReference[models.size()]);\n      }\n    };\n\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToModelModel, DefaultMatcherFactory.createAllMatcher(goToModelModel));\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":22596,"modified_method":"public static void showSimpleModelChooser(final List<SModelReference> models, final ChooserCallback<SModelReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getModelReference());\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        return models.toArray(new SModelReference[models.size()]);\n      }\n    };\n\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToModelModel, new MPSItemProvider(DefaultMatcherFactory.createAllMatcher(goToModelModel)), new FakePsiContext());\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void showSimpleNodeChooser(final List<SNode> nodes, final ChooserCallback<SNode> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseNodeModel goToNodeModel = new BaseNodeModel(project) {\n      public NavigationItem doGetNavigationItem(final SNode node) {\n        return new BaseNodeItem(node) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getNode());\n          }\n        };\n      }\n\n      public SNode[] find(IScope scope) {\n        return nodes.toArray(new SNode[nodes.size()]);\n      }\n    };\n\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToNodeModel, new FakePsiContext());\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":22597,"modified_method":"public static void showSimpleNodeChooser(final List<SNode> nodes, final ChooserCallback<SNode> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseNodeModel goToNodeModel = new BaseNodeModel(project) {\n      public NavigationItem doGetNavigationItem(final SNode node) {\n        return new BaseNodeItem(node) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getNode());\n          }\n        };\n      }\n\n      public SNode[] find(IScope scope) {\n        return nodes.toArray(new SNode[nodes.size()]);\n      }\n    };\n\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToNodeModel, new MPSItemProvider(new DefaultMatcher(goToNodeModel, new FakePsiContext())), new FakePsiContext());\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getShortNamePattern(String s) {\n    return ChooseByNameBaseMPS.getNamePattern(myModel, s);\n  }","id":22598,"modified_method":"public String getShortNamePattern(String s) {\n    return MPSItemProvider.getNamePattern(myModel, s);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"goto.model\");\n    //PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            ProjectPane projectPane = ProjectPane.getInstance(project);\n            SModelDescriptor md = SModelRepository.getInstance().getModelDescriptor(modelReference);\n            projectPane.selectModel(md, true);\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> result = new ArrayList<SModelReference>();\n        for (SModelDescriptor md:iter){\n          result.add(md.getSModelReference());\n        }\n        return result.toArray(new SModelReference[result.size()]);\n      }\n    };\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToModelModel, DefaultMatcherFactory.createAllMatcher(goToModelModel));\n    popup.setShowListForEmptyPattern(true);\n    popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n  }","id":22599,"modified_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"goto.model\");\n    //PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            ProjectPane projectPane = ProjectPane.getInstance(project);\n            SModelDescriptor md = SModelRepository.getInstance().getModelDescriptor(modelReference);\n            projectPane.selectModel(md, true);\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> result = new ArrayList<SModelReference>();\n        for (SModelDescriptor md:iter){\n          result.add(md.getSModelReference());\n        }\n        return result.toArray(new SModelReference[result.size()]);\n      }\n    };\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToModelModel,new MPSItemProvider(DefaultMatcherFactory.createAllMatcher(goToModelModel)),new FakePsiContext());\n    popup.setShowListForEmptyPattern(true);\n    popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    //FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.class\");\n    //PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    BaseModuleModel goToModuleModel = new BaseModuleModel(project, \"module\") {\n      public NavigationItem doGetNavigationItem(final ModuleReference ref) {\n        return new BaseModuleItem(ref) {\n          public void navigate(boolean requestFocus) {\n            ProjectPane projectPane = ProjectPane.getInstance(project);\n            IModule module = MPSModuleRepository.getInstance().getModule(ref);\n            projectPane.selectModule(module, true);\n          }\n        };\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        List<ModuleReference> modules = new ArrayList<ModuleReference>();\n        for (IModule module : scope.getVisibleModules()) {\n          if (!(module instanceof Solution || module instanceof Language || module instanceof DevKit)) continue;\n          modules.add(module.getModuleReference());\n        }\n        return modules.toArray(new ModuleReference[modules.size()]);\n      }\n    };\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToModuleModel, DefaultMatcherFactory.createAllMatcher(goToModuleModel));\n\n    popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n  }","id":22600,"modified_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    //FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.class\");\n    //PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    BaseModuleModel goToModuleModel = new BaseModuleModel(project, \"module\") {\n      public NavigationItem doGetNavigationItem(final ModuleReference ref) {\n        return new BaseModuleItem(ref) {\n          public void navigate(boolean requestFocus) {\n            ProjectPane projectPane = ProjectPane.getInstance(project);\n            IModule module = MPSModuleRepository.getInstance().getModule(ref);\n            projectPane.selectModule(module, true);\n          }\n        };\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        List<ModuleReference> modules = new ArrayList<ModuleReference>();\n        for (IModule module : scope.getVisibleModules()) {\n          if (!(module instanceof Solution || module instanceof Language || module instanceof DevKit)) continue;\n          modules.add(module.getModuleReference());\n        }\n        return modules.toArray(new ModuleReference[modules.size()]);\n      }\n    };\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToModuleModel, new MPSItemProvider(DefaultMatcherFactory.createAllMatcher(goToModuleModel)), new FakePsiContext());\n\n    popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    DumbService service = DumbService.getInstance(project);\n    if (service.isDumb()) {\n      return;\n    }\n\n    ChooseByNamePopupMPS popup;\n\n    if (!myUseCache) {\n      FakePsiElement fakePsiContext = new FakePsiElement() {\n        public PsiElement getParent() {\n          return null;\n        }\n      };\n\n      BaseNodeModel baseNodeModel = new BaseNodeModel(project, \"symbol\") {\n        public SNode[] find(IScope scope) {\n          final List<SNode> nodes = new ArrayList<SNode>();\n          Iterable<SModelDescriptor> modelDescriptors = scope.getModelDescriptors();\n\n          Condition<SNode> cond = new Condition<SNode>() {\n            public boolean met(SNode node) {\n              String name = node.getName();\n              return name != null && name.length() > 0;\n            }\n          };\n\n          for (SModelDescriptor modelDescriptor : modelDescriptors) {\n            if (!SModelStereotype.isUserModel(modelDescriptor)) continue;\n\n            Iterable<SNode> iter = new ConditionalIterable<SNode>(modelDescriptor.getSModel().nodes(), cond);\n            nodes.addAll(IterableUtil.asCollection(iter));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n      };\n      popup = ChooseByNamePopupMPS.createPopup(project, baseNodeModel, fakePsiContext);\n    } else {\n      MPSChooseSNodeDescriptor chooseSNodeResult = new MPSChooseSNodeDescriptor(project, new NamedNodeIndex());\n      popup = ChooseByNamePopupMPS.createPopup(project, chooseSNodeResult, new FakePsiContext());\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":22601,"modified_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    DumbService service = DumbService.getInstance(project);\n    if (service.isDumb()) {\n      return;\n    }\n\n    ChooseByNamePopup popup;\n\n    if (!myUseCache) {\n      FakePsiElement fakePsiContext = new FakePsiElement() {\n        public PsiElement getParent() {\n          return null;\n        }\n      };\n\n      BaseNodeModel baseNodeModel = new BaseNodeModel(project, \"symbol\") {\n        public SNode[] find(IScope scope) {\n          final List<SNode> nodes = new ArrayList<SNode>();\n          Iterable<SModelDescriptor> modelDescriptors = scope.getModelDescriptors();\n\n          Condition<SNode> cond = new Condition<SNode>() {\n            public boolean met(SNode node) {\n              String name = node.getName();\n              return name != null && name.length() > 0;\n            }\n          };\n\n          for (SModelDescriptor modelDescriptor : modelDescriptors) {\n            if (!SModelStereotype.isUserModel(modelDescriptor)) continue;\n\n            Iterable<SNode> iter = new ConditionalIterable<SNode>(modelDescriptor.getSModel().nodes(), cond);\n            nodes.addAll(IterableUtil.asCollection(iter));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n      };\n      popup = ChooseByNamePopup.createPopup(project, baseNodeModel,new MPSItemProvider(new DefaultMatcher(baseNodeModel,fakePsiContext)), fakePsiContext);\n    } else {\n      MPSChooseSNodeDescriptor chooseSNodeResult = new MPSChooseSNodeDescriptor(project, new NamedNodeIndex());\n      popup = ChooseByNamePopup.createPopup(project, chooseSNodeResult,new MPSItemProvider(new DefaultMatcher(chooseSNodeResult,new FakePsiContext())), new FakePsiContext());\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    ChooseByNamePopupMPS popup;\n\n    if (!myUseCache) {\n      BaseNodeModel baseNodeModel = new BaseNodeModel(project) {\n        public SNode[] find(IScope scope) {\n          final List<SNode> nodes = new ArrayList<SNode>();\n          Iterable<SModelDescriptor> modelDescriptors = scope.getModelDescriptors();\n          for (SModelDescriptor modelDescriptor : modelDescriptors) {\n            if (!SModelStereotype.isUserModel(modelDescriptor)) continue;\n            for (SNode node : modelDescriptor.getSModel().roots()) {\n              nodes.add(node);\n            }\n          }\n          return nodes.toArray(new SNode[0]);\n        }\n      };\n      popup = ChooseByNamePopupMPS.createPopup(project, baseNodeModel, new FakePsiContext());\n    } else {\n      MPSChooseSNodeDescriptor chooseSNodeResult = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex());\n      popup = ChooseByNamePopupMPS.createPopup(project, chooseSNodeResult, new FakePsiContext());\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":22602,"modified_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    ChooseByNamePopup popup;\n\n    if (!myUseCache) {\n      BaseNodeModel baseNodeModel = new BaseNodeModel(project) {\n        public SNode[] find(IScope scope) {\n          final List<SNode> nodes = new ArrayList<SNode>();\n          Iterable<SModelDescriptor> modelDescriptors = scope.getModelDescriptors();\n          for (SModelDescriptor modelDescriptor : modelDescriptors) {\n            if (!SModelStereotype.isUserModel(modelDescriptor)) continue;\n            for (SNode node : modelDescriptor.getSModel().roots()) {\n              nodes.add(node);\n            }\n          }\n          return nodes.toArray(new SNode[0]);\n        }\n      };\n      popup = ChooseByNamePopup.createPopup(project, baseNodeModel, new MPSItemProvider(new DefaultMatcher(baseNodeModel, new FakePsiContext())), new FakePsiContext());\n    } else {\n      MPSChooseSNodeDescriptor chooseSNodeResult = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex());\n      popup = ChooseByNamePopup.createPopup(project, chooseSNodeResult,new MPSItemProvider(new DefaultMatcher(chooseSNodeResult, new FakePsiContext())), new FakePsiContext());\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImport(final Project project, final IModule module, final SModelDescriptor model) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new AddModelItem(project, model, modelReference, module);\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> filteredModelRefs = new ArrayList<SModelReference>();\n        for (SModelDescriptor md:iter){\n          filteredModelRefs.add(md.getSModelReference());\n        }\n        return filteredModelRefs.toArray(new SModelReference[filteredModelRefs.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import model:\";\n      }\n    };\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToModelModel, fakePsiContext);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":22603,"modified_method":"public static void addModelImport(final Project project, final IModule module, final SModelDescriptor model) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new AddModelItem(project, model, modelReference, module);\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> filteredModelRefs = new ArrayList<SModelReference>();\n        for (SModelDescriptor md:iter){\n          filteredModelRefs.add(md.getSModelReference());\n        }\n        return filteredModelRefs.toArray(new SModelReference[filteredModelRefs.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import model:\";\n      }\n    };\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToModelModel, new MPSItemProvider(new DefaultMatcher(goToModelModel,fakePsiContext)), fakePsiContext);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseMPSChooseModel goToNodeModel;\n    if (!myUseCache) {\n      goToNodeModel = new BaseNodeModel(project) {\n        public NavigationItem doGetNavigationItem(SNode node) {\n          return new BaseNodeItem(node) {\n            public void navigate(boolean requestFocus) {\n              new AddModelItem(project, model, getNode().getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        public SNode[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor);\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n\n          final List<SNode> nodes = new ArrayList<SNode>();\n          for (SModelDescriptor modelDescriptor : iter) {\n            SModel model = modelDescriptor.getSModel();\n            if (model == null) continue;\n            nodes.addAll(IterableUtil.asCollection(model.roots()));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    } else {\n      goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n        public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n          return new RootNodeElement(object) {\n            public void navigate(boolean requestFocus) {\n              SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n              SModel modelDescriptor = descriptor.getSModel();\n              SNode node = object.getNode(modelDescriptor);\n              new AddModelItem(project, model, node.getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    }\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToNodeModel, new DefaultMatcher(goToNodeModel,fakePsiContext), initialText);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":22604,"modified_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseMPSChooseModel goToNodeModel;\n    if (!myUseCache) {\n      goToNodeModel = new BaseNodeModel(project) {\n        public NavigationItem doGetNavigationItem(SNode node) {\n          return new BaseNodeItem(node) {\n            public void navigate(boolean requestFocus) {\n              new AddModelItem(project, model, getNode().getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        public SNode[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor);\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n\n          final List<SNode> nodes = new ArrayList<SNode>();\n          for (SModelDescriptor modelDescriptor : iter) {\n            SModel model = modelDescriptor.getSModel();\n            if (model == null) continue;\n            nodes.addAll(IterableUtil.asCollection(model.roots()));\n          }\n          return nodes.toArray(new SNode[nodes.size()]);\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    } else {\n      goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n        public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n          return new RootNodeElement(object) {\n            public void navigate(boolean requestFocus) {\n              SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n              SModel modelDescriptor = descriptor.getSModel();\n              SNode node = object.getNode(modelDescriptor);\n              new AddModelItem(project, model, node.getModel().getSModelReference(), contextModule).navigate(requestFocus);\n            }\n          };\n        }\n\n        @Nullable\n        public String getPromptText() {\n          return \"Import model that contains root:\";\n        }\n      };\n    }\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToNodeModel, new MPSItemProvider(new DefaultMatcher(goToNodeModel,fakePsiContext)),fakePsiContext ,initialText);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addLanguageImport(Project project, final IModule contextModule, final SModelDescriptor model) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseLanguageModel goToLanguageModel = new BaseLanguageModel(project) {\n      public NavigationItem doGetNavigationItem(ModuleReference ref) {\n        return new AddLanguageItem(ref, contextModule, model);\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        ArrayList<ModuleReference> res = new ArrayList<ModuleReference>();\n        for (Language l:scope.getVisibleLanguages()){\n          res.add(l.getModuleReference());\n        }\n        return res.toArray(new ModuleReference[res.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import language:\";\n      }\n    };\n    ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(project, goToLanguageModel, fakePsiContext);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":22605,"modified_method":"public static void addLanguageImport(Project project, final IModule contextModule, final SModelDescriptor model) {\n    FakePsiElement fakePsiContext = new FakePsiElement() {\n      public PsiElement getParent() {\n        return null;\n      }\n    };\n\n    BaseLanguageModel goToLanguageModel = new BaseLanguageModel(project) {\n      public NavigationItem doGetNavigationItem(ModuleReference ref) {\n        return new AddLanguageItem(ref, contextModule, model);\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        ArrayList<ModuleReference> res = new ArrayList<ModuleReference>();\n        for (Language l:scope.getVisibleLanguages()){\n          res.add(l.getModuleReference());\n        }\n        return res.toArray(new ModuleReference[res.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import language:\";\n      }\n    };\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(project, goToLanguageModel,new MPSItemProvider(new DefaultMatcher(goToLanguageModel,fakePsiContext)), fakePsiContext);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<IModule> modules = ListSequence.fromList(new ArrayList<IModule>());\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modules).addSequence(ListSequence.fromList(MPSModuleRepository.getInstance().getAllModules()));\n        }\n      });\n      BaseModuleModel baseSolutionModel = new BaseModuleModel(((Project) MapSequence.fromMap(_params).get(\"project\")), \"runtime module\") {\n        public ModuleReference[] find(IScope p0) {\n          return ListSequence.fromList(modules).<ModuleReference>select(new ISelector<IModule, ModuleReference>() {\n            public ModuleReference select(IModule it) {\n              return it.getModuleReference();\n            }\n          }).toGenericArray(ModuleReference.class);\n        }\n\n        public NavigationItem doGetNavigationItem(final ModuleReference module) {\n          return new BaseModuleItem(module) {\n            public void navigate(boolean p0) {\n              if (module == null) {\n                return;\n              }\n              final Language language = (Language) ((IModule) MapSequence.fromMap(_params).get(\"contextModule\"));\n              Dependency dependency = new Dependency();\n              dependency.setModuleRef(module);\n              language.getModuleDescriptor().getRuntimeModules().add(dependency);\n              final MPSTree mpsTree = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"treeNode\"))).getTree();\n              ModelAccess.instance().runWriteInEDT(new Runnable() {\n                public void run() {\n                  language.save();\n                  mpsTree.rebuildLater();\n                }\n              });\n            }\n          };\n        }\n      };\n      ChooseByNamePopupMPS popup = ChooseByNamePopupMPS.createPopup(((Project) MapSequence.fromMap(_params).get(\"project\")), baseSolutionModel, new FakePsiContext());\n      popup.invoke(new ChooseByNamePopupComponent.Callback() {\n        public void elementChosen(Object p0) {\n          ((NavigationItem) p0).navigate(true);\n        }\n      }, ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewRuntimeModule\", t);\n      }\n    }\n  }","id":22606,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<IModule> modules = ListSequence.fromList(new ArrayList<IModule>());\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modules).addSequence(ListSequence.fromList(MPSModuleRepository.getInstance().getAllModules()));\n        }\n      });\n      BaseModuleModel baseSolutionModel = new BaseModuleModel(((Project) MapSequence.fromMap(_params).get(\"project\")), \"runtime module\") {\n        public ModuleReference[] find(IScope p0) {\n          return ListSequence.fromList(modules).<ModuleReference>select(new ISelector<IModule, ModuleReference>() {\n            public ModuleReference select(IModule it) {\n              return it.getModuleReference();\n            }\n          }).toGenericArray(ModuleReference.class);\n        }\n\n        public NavigationItem doGetNavigationItem(final ModuleReference module) {\n          return new BaseModuleItem(module) {\n            public void navigate(boolean p0) {\n              if (module == null) {\n                return;\n              }\n              final Language language = (Language) ((IModule) MapSequence.fromMap(_params).get(\"contextModule\"));\n              Dependency dependency = new Dependency();\n              dependency.setModuleRef(module);\n              language.getModuleDescriptor().getRuntimeModules().add(dependency);\n              final MPSTree mpsTree = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"treeNode\"))).getTree();\n              ModelAccess.instance().runWriteInEDT(new Runnable() {\n                public void run() {\n                  language.save();\n                  mpsTree.rebuildLater();\n                }\n              });\n            }\n          };\n        }\n      };\n      FakePsiContext fpc = new FakePsiContext();\n      ChooseByNamePopup popup = ChooseByNamePopup.createPopup(((Project) MapSequence.fromMap(_params).get(\"project\")), baseSolutionModel, new MPSItemProvider(new DefaultMatcher(baseSolutionModel, fpc)), fpc);\n      popup.invoke(new ChooseByNamePopupComponent.Callback() {\n        public void elementChosen(Object p0) {\n          ((NavigationItem) p0).navigate(true);\n        }\n      }, ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewRuntimeModule\", t);\n      }\n    }\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SmartChooseByNamePanel(ChooseByNameModel model, boolean checkboxVisible) {\n    super(MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext()), model, \"\", new DefaultMatcher(model,new FakePsiContext()));\n    myCheckboxVisible = checkboxVisible;\n  }","id":22607,"modified_method":"public SmartChooseByNamePanel(ChooseByNameModel model, boolean checkboxVisible) {\n    this(model,checkboxVisible,new DefaultMatcher(model, new FakePsiContext()));\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SmartChooseByNamePanel(ChooseByNameModel model, boolean checkboxVisible, EntityMatcher matcher) {\n    super(MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext()), model, \"\", matcher);\n    myCheckboxVisible = checkboxVisible;\n  }","id":22608,"modified_method":"public SmartChooseByNamePanel(ChooseByNameModel model, boolean checkboxVisible, EntityMatcher matcher) {\n    super(MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext()), model, new MPSItemProvider(matcher), null, new FakePsiContext(), \"\");\n    myCheckboxVisible = checkboxVisible;\n  }","commit_id":"404224df057b63aa78c62c049e54185e80ed3275","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void bulkIndex(List<Rule> rules) throws IOException {\n    String[] ids = new String[rules.size()];\n    BytesStream[] docs = new BytesStream[rules.size()];\n    int index = 0;\n    for (Rule rule: rules) {\n      ids[index] = rule.getId().toString();\n      docs[index] = ruleDocument(rule);\n      index ++;\n    }\n    searchIndex.bulkIndex(INDEX_RULES, TYPE_RULE, ids, docs);\n  }","id":22609,"modified_method":"private void bulkIndex(List<Rule> rules) throws IOException {\n    String[] ids = new String[rules.size()];\n    BytesStream[] docs = new BytesStream[rules.size()];\n    int index = 0;\n    TimeProfiler profiler = new TimeProfiler();\n    profiler.start(\"Build rules documents\");\n    for (Rule rule: rules) {\n      ids[index] = rule.getId().toString();\n      docs[index] = ruleDocument(rule);\n      index ++;\n    }\n    profiler.stop();\n    profiler.start(\"Index rules\");\n    searchIndex.bulkIndex(INDEX_RULES, TYPE_RULE, ids, docs);\n    profiler.stop();\n  }","commit_id":"e227eb896d80afe714ff285812368507055aa637","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void bulkRegisterRules() {\n    TimeProfiler profiler = new TimeProfiler();\n    DatabaseSession session = sessionFactory.getSession();\n    profiler.start(\"Rebuilding rules index\");\n\n    List<Rule> rules = session.getResults(Rule.class);\n\n    try {\n      bulkIndex(rules);\n    } catch(IOException ioe) {\n      throw new IllegalStateException(\"Unable to index rules\", ioe);\n    } finally {\n      profiler.stop();\n    }\n  }","id":22610,"modified_method":"public void bulkRegisterRules() {\n    TimeProfiler profiler = new TimeProfiler();\n    DatabaseSession session = sessionFactory.getSession();\n\n    profiler.start(\"Rebuilding rules index - query\");\n    List<Rule> rules = session.getResults(Rule.class);\n    profiler.stop();\n\n    try {\n      bulkIndex(rules);\n    } catch(IOException ioe) {\n      throw new IllegalStateException(\"Unable to index rules\", ioe);\n    }\n  }","commit_id":"e227eb896d80afe714ff285812368507055aa637","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addMapping(String index, String type, String mapping) {\n    IndicesAdminClient indices = client.admin().indices();\n    try {\n      if (! indices.exists(new IndicesExistsRequest(index)).get().isExists()) {\n        indices.prepareCreate(index).execute().actionGet();\n      }\n    } catch (Exception e) {\n      LOG.error(\"While checking for index existence\", e);\n    }\n\n    try {\n      indices.putMapping(Requests.putMappingRequest(index).type(type).source(mapping)).actionGet();\n    } catch(ElasticSearchParseException parseException) {\n      throw new IllegalArgumentException(\"Invalid mapping file\", parseException);\n    }\n  }","id":22611,"modified_method":"private void addMapping(String index, String type, String mapping) {\n    IndicesAdminClient indices = client.admin().indices();\n    TimeProfiler profiler = newDebugProfiler();\n    try {\n      if (! indices.exists(new IndicesExistsRequest(index)).get().isExists()) {\n        profiler.start(format(\"create index '%s'\", index));\n        indices.prepareCreate(index).execute().actionGet();\n      }\n    } catch (Exception e) {\n      LOG.error(\"While checking for index existence\", e);\n    } finally {\n      profiler.stop();\n    }\n\n    profiler.start(format(\"put mapping on index '%s' for type '%s'\", index, type));\n    try {\n      indices.putMapping(Requests.putMappingRequest(index).type(type).source(mapping)).actionGet();\n    } catch(ElasticSearchParseException parseException) {\n      throw new IllegalArgumentException(\"Invalid mapping file\", parseException);\n    } finally {\n      profiler.stop();\n    }\n  }","commit_id":"e227eb896d80afe714ff285812368507055aa637","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void internalPut(String index, String type, String id, BytesStream source, boolean refresh) {\n    client.prepareIndex(index, type, id).setSource(source.bytes()).setRefresh(refresh).execute().actionGet();\n  }","id":22612,"modified_method":"private void internalPut(String index, String type, String id, BytesStream source, boolean refresh) {\n    IndexRequestBuilder builder = client.prepareIndex(index, type, id).setSource(source.bytes()).setRefresh(refresh);\n    TimeProfiler profiler = newDebugProfiler();\n    profiler.start(format(\"put document with id '%s' with type '%s' into index '%s'\", id, type, index));\n    builder.execute().actionGet();\n    profiler.stop();\n  }","commit_id":"e227eb896d80afe714ff285812368507055aa637","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<String> findDocumentIds(SearchQuery searchQuery) {\n    List<String> result = Lists.newArrayList();\n    final int scrollTime = 100;\n\n    SearchResponse scrollResp = searchQuery.toBuilder(client).addField(\"_id\")\n            .setSearchType(SearchType.SCAN)\n            .setScroll(new TimeValue(scrollTime))\n            .setSize(searchQuery.scrollSize()).execute().actionGet();\n    //Scroll until no hits are returned\n    while (true) {\n      scrollResp = client.prepareSearchScroll(scrollResp.getScrollId()).setScroll(new TimeValue(scrollTime)).execute().actionGet();\n      for (SearchHit hit : scrollResp.getHits()) {\n        result.add(hit.getId());\n      }\n      //Break condition: No hits are returned\n      if (scrollResp.getHits().getHits().length == 0) {\n        break;\n      }\n    }\n\n    return result;\n  }","id":22613,"modified_method":"public List<String> findDocumentIds(SearchQuery searchQuery) {\n    List<String> result = Lists.newArrayList();\n    final int scrollTime = 100;\n\n    SearchRequestBuilder builder = searchQuery.toBuilder(client);\n    LOG.debug(\"findDocumentIds\" + builder.internalBuilder().toString());\n    TimeProfiler profiler = newDebugProfiler();\n    profiler.start(\"findDocumentIds\");\n    SearchResponse scrollResp = builder.addField(\"_id\")\n            .setSearchType(SearchType.SCAN)\n            .setScroll(new TimeValue(scrollTime))\n            .setSize(searchQuery.scrollSize()).execute().actionGet();\n    //Scroll until no hits are returned\n    while (true) {\n      scrollResp = client.prepareSearchScroll(scrollResp.getScrollId()).setScroll(new TimeValue(scrollTime)).execute().actionGet();\n      for (SearchHit hit : scrollResp.getHits()) {\n        result.add(hit.getId());\n      }\n      //Break condition: No hits are returned\n      if (scrollResp.getHits().getHits().length == 0) {\n        break;\n      }\n    }\n    profiler.stop();\n\n    return result;\n  }","commit_id":"e227eb896d80afe714ff285812368507055aa637","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void bulkIndex(String index, String type, String[] ids, BytesStream[] sources) {\n    BulkRequestBuilder builder = new BulkRequestBuilder(client);\n    for (int i=0; i<ids.length; i++) {\n      builder.add(client.prepareIndex(index, type, ids[i]).setSource(sources[i].bytes()));\n    }\n    try {\n      BulkResponse bulkResponse = client.bulk(builder.setRefresh(true).request()).get();\n      if (bulkResponse.hasFailures()) {\n        // Retry once per failed doc -- ugly\n        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {\n          if(bulkItemResponse.isFailed()) {\n            int itemId = bulkItemResponse.getItemId();\n            put(index, type, ids[itemId], sources[itemId]);\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      LOG.error(\"Interrupted during bulk operation\", e);\n    } catch (ExecutionException e) {\n      LOG.error(\"Execution of bulk operation failed\", e);\n    }\n  }","id":22614,"modified_method":"public void bulkIndex(String index, String type, String[] ids, BytesStream[] sources) {\n    BulkRequestBuilder builder = new BulkRequestBuilder(client);\n    for (int i=0; i<ids.length; i++) {\n      builder.add(client.prepareIndex(index, type, ids[i]).setSource(sources[i].bytes()));\n    }\n    TimeProfiler profiler = newDebugProfiler();\n    try {\n      profiler.start(format(\"bulk index of %d documents with type '%s' into index '%s'\", ids.length, type, index));\n      BulkResponse bulkResponse = client.bulk(builder.setRefresh(true).request()).get();\n      if (bulkResponse.hasFailures()) {\n        // Retry once per failed doc -- ugly\n        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {\n          if(bulkItemResponse.isFailed()) {\n            int itemId = bulkItemResponse.getItemId();\n            put(index, type, ids[itemId], sources[itemId]);\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      LOG.error(\"Interrupted during bulk operation\", e);\n    } catch (ExecutionException e) {\n      LOG.error(\"Execution of bulk operation failed\", e);\n    } finally {\n      profiler.stop();\n    }\n  }","commit_id":"e227eb896d80afe714ff285812368507055aa637","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n    public void testSimpleTTL() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .addMapping(\"type1\", XContentFactory.jsonBuilder()\n                        .startObject()\n                        .startObject(\"type1\")\n                        .startObject(\"_timestamp\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                        .startObject(\"_ttl\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                        .endObject()\n                        .endObject())\n                .addMapping(\"type2\", XContentFactory.jsonBuilder()\n                        .startObject()\n                        .startObject(\"type2\")\n                        .startObject(\"_timestamp\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                        .startObject(\"_ttl\").field(\"enabled\", true).field(\"store\", \"yes\").field(\"default\", \"1d\").endObject()\n                        .endObject()\n                        .endObject()));\n        ensureGreen();\n\n        final NumShards test = getNumShards(\"test\");\n\n        long providedTTLValue = 3000;\n        logger.info(\"--> checking ttl\");\n        // Index one doc without routing, one doc with routing, one doc with not TTL and no default and one doc with default TTL\n        client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRefresh(true).execute().actionGet();\n        long now = System.currentTimeMillis();\n        client().prepareIndex(\"test\", \"type1\", \"with_routing\").setSource(\"field1\", \"value1\").setTTL(providedTTLValue).setRouting(\"routing\").setRefresh(true).execute().actionGet();\n        client().prepareIndex(\"test\", \"type1\", \"no_ttl\").setSource(\"field1\", \"value1\").execute().actionGet();\n        client().prepareIndex(\"test\", \"type2\", \"default_ttl\").setSource(\"field1\", \"value1\").execute().actionGet();\n\n        // realtime get check\n        long currentTime = System.currentTimeMillis();\n        GetResponse getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        long ttl0;\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, greaterThan(-PURGE_INTERVAL));\n            assertThat(ttl0, lessThan(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThan(0l));\n        }\n        // verify the ttl is still decreasing when going to the replica\n        currentTime = System.currentTimeMillis();\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, greaterThan(-PURGE_INTERVAL));\n            assertThat(ttl0, lessThan(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThan(0l));\n        }\n        // non realtime get (stored)\n        currentTime = System.currentTimeMillis();\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, greaterThan(-PURGE_INTERVAL));\n            assertThat(ttl0, lessThan(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThan(0l));\n        }\n        // non realtime get going the replica\n        currentTime = System.currentTimeMillis();\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, greaterThan(-PURGE_INTERVAL));\n            assertThat(ttl0, lessThan(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThan(0l));\n        }\n\n        // no TTL provided so no TTL fetched\n        getResponse = client().prepareGet(\"test\", \"type1\", \"no_ttl\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.getField(\"_ttl\"), nullValue());\n        // no TTL provided make sure it has default TTL\n        getResponse = client().prepareGet(\"test\", \"type2\", \"default_ttl\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n        assertThat(ttl0, greaterThan(0L));\n\n        IndicesStatsResponse response = client().admin().indices().prepareStats(\"test\").clear().setIndexing(true).get();\n        assertThat(response.getIndices().get(\"test\").getTotal().getIndexing().getTotal().getDeleteCount(), equalTo(0L));\n\n        // make sure the purger has done its job for all indexed docs that are expired\n        long shouldBeExpiredDate = now + providedTTLValue + PURGE_INTERVAL + 2000;\n        currentTime = System.currentTimeMillis();\n        if (shouldBeExpiredDate - currentTime > 0) {\n            Thread.sleep(shouldBeExpiredDate - currentTime);\n        }\n\n        // We can't assume that after waiting for ttl + purgeInterval (waitTime) that the document have actually been deleted.\n        // The ttl purging happens in the background in a different thread, and might not have been completed after waiting for waitTime.\n        // But we can use index statistics' delete count to be sure that deletes have been executed, that must be incremented before\n        // ttl purging has finished.\n        logger.info(\"--> checking purger\");\n        assertThat(awaitBusy(new Predicate<Object>() {\n            @Override\n            public boolean apply(Object input) {\n                if (rarely()) {\n                    client().admin().indices().prepareFlush(\"test\").setFull(true).get();\n                } else if (rarely()) {\n                    client().admin().indices().prepareOptimize(\"test\").setMaxNumSegments(1).get();\n                }\n                IndicesStatsResponse response = client().admin().indices().prepareStats(\"test\").clear().setIndexing(true).get();\n                // TTL deletes two docs, but it is indexed in the primary shard and replica shard.\n                return response.getIndices().get(\"test\").getTotal().getIndexing().getTotal().getDeleteCount() == 2L * test.dataCopies;\n            }\n        }, 5, TimeUnit.SECONDS), equalTo(true));\n\n        // realtime get check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        // replica realtime get check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n\n        // Need to run a refresh, in order for the non realtime get to work.\n        client().admin().indices().prepareRefresh(\"test\").execute().actionGet();\n\n        // non realtime get (stored) check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        // non realtime get going the replica check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n    }","id":22615,"modified_method":"@Test\n    public void testSimpleTTL() throws Exception {\n        assertAcked(prepareCreate(\"test\")\n                .addMapping(\"type1\", XContentFactory.jsonBuilder()\n                        .startObject()\n                        .startObject(\"type1\")\n                        .startObject(\"_timestamp\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                        .startObject(\"_ttl\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                        .endObject()\n                        .endObject())\n                .addMapping(\"type2\", XContentFactory.jsonBuilder()\n                        .startObject()\n                        .startObject(\"type2\")\n                        .startObject(\"_timestamp\").field(\"enabled\", true).field(\"store\", \"yes\").endObject()\n                        .startObject(\"_ttl\").field(\"enabled\", true).field(\"store\", \"yes\").field(\"default\", \"1d\").endObject()\n                        .endObject()\n                        .endObject()));\n        ensureYellow(\"test\");\n\n        final NumShards test = getNumShards(\"test\");\n\n        long providedTTLValue = 3000;\n        logger.info(\"--> checking ttl\");\n        // Index one doc without routing, one doc with routing, one doc with not TTL and no default and one doc with default TTL\n        long now = System.currentTimeMillis();\n        IndexResponse indexResponse = client().prepareIndex(\"test\", \"type1\", \"1\").setSource(\"field1\", \"value1\")\n                .setTimestamp(String.valueOf(now)).setTTL(providedTTLValue).setRefresh(true).get();\n        assertThat(indexResponse.isCreated(), is(true));\n        indexResponse = client().prepareIndex(\"test\", \"type1\", \"with_routing\").setSource(\"field1\", \"value1\")\n                .setTimestamp(String.valueOf(now)).setTTL(providedTTLValue).setRouting(\"routing\").setRefresh(true).get();\n        assertThat(indexResponse.isCreated(), is(true));\n        indexResponse = client().prepareIndex(\"test\", \"type1\", \"no_ttl\").setSource(\"field1\", \"value1\").get();\n        assertThat(indexResponse.isCreated(), is(true));\n        indexResponse = client().prepareIndex(\"test\", \"type2\", \"default_ttl\").setSource(\"field1\", \"value1\").get();\n        assertThat(indexResponse.isCreated(), is(true));\n\n        // realtime get check\n        long currentTime = System.currentTimeMillis();\n        GetResponse getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").get();\n        long ttl0;\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, lessThanOrEqualTo(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThanOrEqualTo(0l));\n        }\n        // verify the ttl is still decreasing when going to the replica\n        currentTime = System.currentTimeMillis();\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").get();\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, lessThanOrEqualTo(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThanOrEqualTo(0l));\n        }\n        // non realtime get (stored)\n        currentTime = System.currentTimeMillis();\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).get();\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, lessThanOrEqualTo(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThanOrEqualTo(0l));\n        }\n        // non realtime get going the replica\n        currentTime = System.currentTimeMillis();\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).get();\n        if (getResponse.isExists()) {\n            ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n            assertThat(ttl0, lessThanOrEqualTo(providedTTLValue - (currentTime - now)));\n        } else {\n            assertThat(providedTTLValue - (currentTime - now), lessThanOrEqualTo(0l));\n        }\n\n        // no TTL provided so no TTL fetched\n        getResponse = client().prepareGet(\"test\", \"type1\", \"no_ttl\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.getField(\"_ttl\"), nullValue());\n        // no TTL provided make sure it has default TTL\n        getResponse = client().prepareGet(\"test\", \"type2\", \"default_ttl\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        ttl0 = ((Number) getResponse.getField(\"_ttl\").getValue()).longValue();\n        assertThat(ttl0, greaterThan(0L));\n\n        IndicesStatsResponse response = client().admin().indices().prepareStats(\"test\").clear().setIndexing(true).get();\n        assertThat(response.getIndices().get(\"test\").getTotal().getIndexing().getTotal().getDeleteCount(), equalTo(0L));\n\n        // make sure the purger has done its job for all indexed docs that are expired\n        long shouldBeExpiredDate = now + providedTTLValue + PURGE_INTERVAL + 2000;\n        currentTime = System.currentTimeMillis();\n        if (shouldBeExpiredDate - currentTime > 0) {\n            Thread.sleep(shouldBeExpiredDate - currentTime);\n        }\n\n        // We can't assume that after waiting for ttl + purgeInterval (waitTime) that the document have actually been deleted.\n        // The ttl purging happens in the background in a different thread, and might not have been completed after waiting for waitTime.\n        // But we can use index statistics' delete count to be sure that deletes have been executed, that must be incremented before\n        // ttl purging has finished.\n        logger.info(\"--> checking purger\");\n        assertThat(awaitBusy(new Predicate<Object>() {\n            @Override\n            public boolean apply(Object input) {\n                if (rarely()) {\n                    client().admin().indices().prepareFlush(\"test\").setFull(true).get();\n                } else if (rarely()) {\n                    client().admin().indices().prepareOptimize(\"test\").setMaxNumSegments(1).get();\n                }\n                IndicesStatsResponse response = client().admin().indices().prepareStats(\"test\").clear().setIndexing(true).get();\n                // TTL deletes two docs, but it is indexed in the primary shard and replica shard.\n                return response.getIndices().get(\"test\").getTotal().getIndexing().getTotal().getDeleteCount() == 2L * test.dataCopies;\n            }\n        }, 5, TimeUnit.SECONDS), equalTo(true));\n\n        // realtime get check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        // replica realtime get check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(true).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n\n        // Need to run a refresh, in order for the non realtime get to work.\n        client().admin().indices().prepareRefresh(\"test\").execute().actionGet();\n\n        // non realtime get (stored) check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        // non realtime get going the replica check\n        getResponse = client().prepareGet(\"test\", \"type1\", \"1\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n        getResponse = client().prepareGet(\"test\", \"type1\", \"with_routing\").setRouting(\"routing\").setFields(\"_ttl\").setRealtime(false).execute().actionGet();\n        assertThat(getResponse.isExists(), equalTo(false));\n    }","commit_id":"d3065acf14a76c1c6ef597f8d6acf9a9c3da24c8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected\n\tvoid doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal String pi = Https.getThisPathInfo(request);\n//\t\tif (log.finerable()) log.finer(\"Path info: \"+pi);\n\n\t\tfinal boolean withpi = pi != null && pi.length() != 0;\n\t\tif (withpi && pi.startsWith(ClassWebResource.PATH_PREFIX)) {\n\t\t\t//use HttpSession to avoid loading SerializableSession in GAE\n\t\t\t//and don't retrieve session if possible\n\t\t\tfinal ClassWebResource cwr = getClassWebResource();\n\t\t\tfinal HttpSession sess =\n\t\t\t\tshallSession(cwr, pi) ? request.getSession(false): null;\n\t\t\tif (sess == null)\n\t\t\t\tSessionsCtrl.setCurrent(new SessionResolverImpl(_ctx, request));\n\t\t\t\t//it might be created later\n\n\t\t\tfinal Object old = sess != null?\n\t\t\t\tI18Ns.setup(sess, request, response, \"UTF-8\"):\n\t\t\t\tCharsets.setup(null, request, response, \"UTF-8\");\n\t\t\ttry {\n\t\t\t\tcwr.service(request, response,\n\t\t\t\t\t\tpi.substring(ClassWebResource.PATH_PREFIX.length()));\n\t\t\t} finally {\n\t\t\t\tif (sess != null) I18Ns.cleanup(request, old);\n\t\t\t\telse Charsets.cleanup(request, old);\n\t\t\t}\n\t\t\treturn; //done\n\t\t}\n\n\t\tfinal Session sess = WebManager.getSession(_ctx, request, false);\n\t\tif (withpi) {\n\t\t\tfinal AuExtension aue = getAuExtensionByPath(pi);\n\t\t\tif (aue == null) {\n\t\t\t\tresponse.setIntHeader(\"ZK-Error\", response.SC_NOT_FOUND);\n\t\t\t\t\t//Don't use sendError since browser might handle it\n\t\t\t\tlog.warning(\"Unknown path info: \"+pi);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (sess == null)\n\t\t\t\tSessionsCtrl.setCurrent(new SessionResolverImpl(_ctx, request));\n\t\t\t\t//it might be created later\n\n\t\t\tfinal Object old = sess != null?\n\t\t\t\tI18Ns.setup(sess, request, response, \"UTF-8\"):\n\t\t\t\tCharsets.setup(null, request, response, \"UTF-8\");\n\t\t\ttry {\n\t\t\t\taue.service(request, response, pi);\n\t\t\t} finally {\n\t\t\t\tif (sess != null) I18Ns.cleanup(request, old);\n\t\t\t\telse Charsets.cleanup(request, old);\n\t\t\t}\n\t\t\treturn; //done\n\t\t}\n\n\t\t//AU\n\t\tif (sess == null) {\n\t\t\tresponse.setIntHeader(\"ZK-Error\", response.SC_GONE); //denote timeout\n\t\t\t//Bug 1849088: rmDesktop might be sent after invalidate\n\t\t\t//Bug 1859776: need send response to client for redirect or others\n\t\t\tfinal String dtid = request.getParameter(\"dtid\");\n\t\t\tif (dtid != null)\n\t\t\t\tsessionTimeout(request, response,\n\t\t\t\t\tWebManager.getWebManager(_ctx).getWebApp().getConfiguration(),\n\t\t\t\t\tdtid);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object old = I18Ns.setup(sess, request, response, \"UTF-8\");\n\t\ttry {\n\t\t\tprocess(sess, request, response);\n\t\t} finally {\n\t\t\tI18Ns.cleanup(request, old);\n\t\t}\n\t}","id":22616,"modified_method":"protected\n\tvoid doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\n\t\tfinal String pi = Https.getThisPathInfo(request);\n//\t\tif (log.finerable()) log.finer(\"Path info: \"+pi);\n\n\t\tfinal boolean withpi = pi != null && pi.length() != 0;\n\t\tif (withpi && pi.startsWith(ClassWebResource.PATH_PREFIX)) {\n\t\t\t//use HttpSession to avoid loading SerializableSession in GAE\n\t\t\t//and don't retrieve session if possible\n\t\t\tfinal ClassWebResource cwr = getClassWebResource();\n\t\t\tfinal HttpSession sess =\n\t\t\t\tshallSession(cwr, pi) ? request.getSession(false): null;\n\t\t\tObject oldsess = null;\n\t\t\tif (sess == null) {\n\t\t\t\toldsess = SessionsCtrl.getRawCurrent();\n\t\t\t\tSessionsCtrl.setCurrent(new SessionResolverImpl(_ctx, request));\n\t\t\t\t//it might be created later\n\t\t\t}\n\n\t\t\tfinal Object old = sess != null?\n\t\t\t\tI18Ns.setup(sess, request, response, \"UTF-8\"):\n\t\t\t\tCharsets.setup(null, request, response, \"UTF-8\");\n\t\t\ttry {\n\t\t\t\tcwr.service(request, response,\n\t\t\t\t\t\tpi.substring(ClassWebResource.PATH_PREFIX.length()));\n\t\t\t} finally {\n\t\t\t\tif (sess != null) I18Ns.cleanup(request, old);\n\t\t\t\telse {\n\t\t\t\t\tCharsets.cleanup(request, old);\n\t\t\t\t\tSessionsCtrl.setRawCurrent(oldsess);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn; //done\n\t\t}\n\n\t\tfinal Session sess = WebManager.getSession(_ctx, request, false);\n\t\tif (withpi) {\n\t\t\tfinal AuExtension aue = getAuExtensionByPath(pi);\n\t\t\tif (aue == null) {\n\t\t\t\tresponse.setIntHeader(\"ZK-Error\", response.SC_NOT_FOUND);\n\t\t\t\t\t//Don't use sendError since browser might handle it\n\t\t\t\tlog.warning(\"Unknown path info: \"+pi);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tObject oldsess = null;\n\t\t\tif (sess == null) {\n\t\t\t\toldsess = SessionsCtrl.getRawCurrent();\n\t\t\t\tSessionsCtrl.setCurrent(new SessionResolverImpl(_ctx, request));\n\t\t\t\t//it might be created later\n\t\t\t}\n\n\t\t\tfinal Object old = sess != null?\n\t\t\t\tI18Ns.setup(sess, request, response, \"UTF-8\"):\n\t\t\t\tCharsets.setup(null, request, response, \"UTF-8\");\n\t\t\ttry {\n\t\t\t\taue.service(request, response, pi);\n\t\t\t} finally {\n\t\t\t\tif (sess != null) I18Ns.cleanup(request, old);\n\t\t\t\telse {\n\t\t\t\t\tCharsets.cleanup(request, old);\n\t\t\t\t\tSessionsCtrl.setRawCurrent(oldsess);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn; //done\n\t\t}\n\n\t\t//AU\n\t\tif (sess == null) {\n\t\t\tresponse.setIntHeader(\"ZK-Error\", response.SC_GONE); //denote timeout\n\t\t\t//Bug 1849088: rmDesktop might be sent after invalidate\n\t\t\t//Bug 1859776: need send response to client for redirect or others\n\t\t\tfinal String dtid = request.getParameter(\"dtid\");\n\t\t\tif (dtid != null)\n\t\t\t\tsessionTimeout(request, response,\n\t\t\t\t\tWebManager.getWebManager(_ctx).getWebApp().getConfiguration(),\n\t\t\t\t\tdtid);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Object old = I18Ns.setup(sess, request, response, \"UTF-8\");\n\t\ttry {\n\t\t\tprocess(sess, request, response);\n\t\t} finally {\n\t\t\tI18Ns.cleanup(request, old);\n\t\t}\n\t}","commit_id":"5a5c0eddf999599d819c2d587eaefceaf4b3f17b","url":"https://github.com/zkoss/zk"},{"original_method":"public LWComponent getFirst() {\n        \n        return (LWComponent)elementList.getFirst();\n    }","id":22617,"modified_method":"public LWComponent getFirst() {\n        \n        LWComponent firstElement = null;\n        \n        try\n        {\n            firstElement = (LWComponent)elementList.getFirst();\n        }\n        \n        catch(NoSuchElementException ne)\n        {\n            firstElement = null;\n        }\n        \n        return firstElement;\n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"public LWComponent getLast() {\n        return (LWComponent)elementList.getLast();\n    }","id":22618,"modified_method":"public LWComponent getLast() {\n        \n        LWComponent lastElement = null;\n        \n        try\n        {\n            lastElement = (LWComponent)elementList.getLast();\n        }\n        \n        catch(NoSuchElementException ne)\n        {\n            lastElement = null;\n        }\n        \n        return lastElement;\n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"/**Sets the current pathway to the given pathway and updates the control panel accordingly*/\n    public void setCurrentPathway(LWPathway pathway)\n    {\n        currentPathway = pathway;\n        \n        //setting the current node of the pathway to the first node\n        currentPathway.setCurrent(currentPathway.getFirst());\n        pathwayList.setSelectedItem(pathway);\n        \n        updateControlPanel();\n        \n        //update the inspector here\n        //VUE.getPathwayInspector().setPathway(currentPathway);\n        //LWPathwayInspector.setPathway(pathway);\n    }","id":22619,"modified_method":"/**Sets the current pathway to the given pathway and updates the control panel accordingly*/\n    public void setCurrentPathway(LWPathway pathway)\n    {\n        currentPathway = pathway;\n        \n        if ((currentPathway.getCurrent() == null) && (currentPathway.getFirst() != null) )\n            currentPathway.setCurrent(currentPathway.getFirst());\n        \n        pathwayList.setSelectedItem(pathway);\n        \n        updateControlPanel();\n        \n        //update the inspector here\n        //VUE.getPathwayInspector().setPathway(currentPathway);\n        //LWPathwayInspector.setPathway(pathway);\n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"public PathwayDialog(JDialog dialog)\n        {\n            super(dialog, \"New Pathway Name\", true);\n            setSize(200, 200);\n            setUpUI();\n        }","id":22620,"modified_method":"public PathwayDialog(JDialog dialog)\n        {\n            super(dialog, \"New Pathway Name\", true);\n            setSize(250, 100);\n            setUpUI();\n        }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"/** Creates a new instance of PathwayControl */\n    public PathwayControl(JFrame parent) \n    {   \n        super(parent, \"Pathway Control\");\n        currentPathway = null;\n        pathwayManager = null;\n        pathwayList = new JComboBox();\n        \n        getContentPane().setLayout(new BorderLayout());\n        getContentPane().setBackground(Color.white);\n        //getContentPane().setBorder(new LineBorder(Color.black));\n        \n        firstButton = new JButton(\"<<\");\n        lastButton = new JButton(\">>\");\n        forwardButton = new JButton(\">\");\n        backButton = new JButton(\"<\");\n        nodeLabel = new JLabel(emptyLabel);\n        \n        /**\n        firstButton.setEnabled(false);\n        lastButton.setEnabled(false);\n        forwardButton.setEnabled(false);\n        backButton.setEnabled(false);\n        */\n        \n        firstButton.addActionListener(this);\n        lastButton.addActionListener(this);\n        forwardButton.addActionListener(this);\n        backButton.addActionListener(this);\n        \n         //temporarily here\n        removeButton = new JButton(\"remove\");\n        removeButton.addActionListener(this);\n        \n        pathwayList.setRenderer(new pathwayRenderer());\n        //pathwayList.setMaximumRowCount();\n        pathwayList.addItemListener(this);\n        pathwayList.addItem(noPathway);\n        pathwayList.addItem(addPathway);\n        \n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setLayout(new FlowLayout());\n        buttonPanel.setBackground(Color.white);\n        buttonPanel.add(firstButton);\n        buttonPanel.add(backButton);\n        buttonPanel.add(forwardButton);\n        buttonPanel.add(lastButton);\n        buttonPanel.add(removeButton);\n         \n        JPanel descriptionPanel = new JPanel();\n        descriptionPanel.setLayout(new FlowLayout());\n        descriptionPanel.setBackground(Color.white);\n        descriptionPanel.add(new JLabel(\"Label:\"));\n        descriptionPanel.add(nodeLabel);\n        \n        JPanel bottomPanel = new JPanel();\n        bottomPanel.add(pathwayList);\n        bottomPanel.add(buttonPanel);\n        \n        getContentPane().add(bottomPanel, BorderLayout.SOUTH);\n        getContentPane().add(descriptionPanel, BorderLayout.CENTER);\n        \n        super.addWindowListener(new WindowAdapter()\n            {\n                public void windowClosing(WindowEvent e) \n                {\n                    displayAction.setButton(false);\n                }\n            }\n        );\n    }","id":22621,"modified_method":"/** Creates a new instance of PathwayControl */\n    public PathwayControl(JFrame parent) \n    {   \n        super(parent, \"Pathway Control\");\n        setSize(450, 300);\n        \n        currentPathway = null;\n        pathwayManager = null;\n        pathwayList = new JComboBox();\n        \n        getContentPane().setLayout(new BorderLayout());\n        getContentPane().setBackground(Color.white);\n        //getContentPane().setBorder(new LineBorder(Color.black));\n        \n        firstButton = new JButton(\"<<\");\n        lastButton = new JButton(\">>\");\n        forwardButton = new JButton(\">\");\n        backButton = new JButton(\"<\");\n        nodeLabel = new JLabel(emptyLabel);\n        \n        /**\n        firstButton.setEnabled(false);\n        lastButton.setEnabled(false);\n        forwardButton.setEnabled(false);\n        backButton.setEnabled(false);\n        */\n        \n        firstButton.addActionListener(this);\n        lastButton.addActionListener(this);\n        forwardButton.addActionListener(this);\n        backButton.addActionListener(this);\n        \n         //temporarily here\n        removeButton = new JButton(\"remove\");\n        removeButton.addActionListener(this);\n        \n        pathwayList.setRenderer(new pathwayRenderer());\n        //pathwayList.setMaximumRowCount();\n        pathwayList.addItemListener(this);\n        pathwayList.addItem(noPathway);\n        pathwayList.addItem(addPathway);\n        \n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setLayout(new FlowLayout());\n        buttonPanel.setBackground(Color.white);\n        buttonPanel.add(firstButton);\n        buttonPanel.add(backButton);\n        buttonPanel.add(forwardButton);\n        buttonPanel.add(lastButton);\n        buttonPanel.add(removeButton);\n         \n        JPanel descriptionPanel = new JPanel();\n        descriptionPanel.setLayout(new FlowLayout());\n        descriptionPanel.setBackground(Color.white);\n        descriptionPanel.add(new JLabel(\"Label:\"));\n        descriptionPanel.add(nodeLabel);\n        \n        JPanel bottomPanel = new JPanel();\n        bottomPanel.add(pathwayList);\n        bottomPanel.add(buttonPanel);\n        \n        getContentPane().add(bottomPanel, BorderLayout.SOUTH);\n        getContentPane().add(descriptionPanel, BorderLayout.CENTER);\n        \n        super.addWindowListener(new WindowAdapter()\n            {\n                public void windowClosing(WindowEvent e) \n                {\n                    displayAction.setButton(false);\n                }\n            }\n        );\n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"/**Reacts to item events dispatched by the combo box*/\n    public void itemStateChanged(ItemEvent ie)\n    {\n        if (ie.getStateChange() == ItemEvent.SELECTED) \n        {\n            //if the pathway was selected, then sets the current pathway to the selected pathway and updates accordingly\n            if (pathwayList.getSelectedItem() instanceof LWPathway)\n            {\n                System.out.println(\"pathway selected\");\n                currentPathway = (LWPathway)pathwayList.getSelectedItem();\n                updateControlPanel();\n            }\n            \n            //if \"no\" pathway was selected, then set the current pathway to nothing and updates accordingly\n            else if (pathwayList.getSelectedItem().equals(noPathway))\n            {\n                System.out.println(\"selecting empty string\");\n                currentPathway = null;\n                updateControlPanel();\n            }\n            \n            //if \"add\" pathway was selected, then adds a pathway, sets it to the current pathway, and updates accordingly\n            else if (pathwayList.getSelectedItem().equals(addPathway))\n            {\n                System.out.println(\"adding a new pathway\");\n                \n                PathwayDialog dialog = new PathwayDialog(this);\n                dialog.show();\n                \n                pathwayList.setSelectedIndex(pathwayList.getModel().getSize() - 1);\n            }\n        } \n    }","id":22622,"modified_method":"/**Reacts to item events dispatched by the combo box*/\n    public void itemStateChanged(ItemEvent ie)\n    {\n        if (ie.getStateChange() == ItemEvent.SELECTED) \n        {\n            //if the pathway was selected, then sets the current pathway to the selected pathway and updates accordingly\n            if (pathwayList.getSelectedItem() instanceof LWPathway)\n            {\n                System.out.println(\"pathway selected\");\n                currentPathway = (LWPathway)pathwayList.getSelectedItem();\n                \n                if (pathwayManager != null)\n                {\n                    System.out.println(\"setting the current pathway in the manager\");\n                    pathwayManager.setCurrentPathway(currentPathway);\n                }\n                \n                updateControlPanel();\n            }\n            \n            //if \"no\" pathway was selected, then set the current pathway to nothing and updates accordingly\n            else if (pathwayList.getSelectedItem().equals(noPathway))\n            {\n                System.out.println(\"selecting empty string\");\n                currentPathway = null;\n                \n                //if there is a pathwayManager currently set \n                if (pathwayManager != null)\n                    pathwayManager.setCurrentPathway(null);\n                \n                updateControlPanel();\n            }\n            \n            //if \"add\" pathway was selected, then adds a pathway, sets it to the current pathway, and updates accordingly\n            else if (pathwayList.getSelectedItem().equals(addPathway))\n            {\n                System.out.println(\"adding a new pathway\");\n                \n                PathwayDialog dialog = new PathwayDialog(this);\n                dialog.show();\n                \n                pathwayList.setSelectedIndex(pathwayList.getModel().getSize() - 1);\n            }\n        } \n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"/**Sets the pathway manager to the given pathway manager*/\n    public void setPathwayManager(LWPathwayManager pathwayManager)\n    {\n        this.pathwayManager = pathwayManager;\n        \n        //iterting through to add existing pathways to the combo box list\n        for (Iterator i = pathwayManager.getPathwayIterator(); i.hasNext();)\n        {\n            pathwayList.addItem((LWPathway)i.next());           \n        }\n        \n        //sets the current pathway to the current pathway \n        LWPathway pathway;\n        if ((pathway = this.pathwayManager.getCurrentPathway()) != null)\n          setCurrentPathway(pathway);\n        \n    }","id":22623,"modified_method":"/**Sets the pathway manager to the given pathway manager*/\n    public void setPathwayManager(LWPathwayManager pathwayManager)\n    {\n        this.pathwayManager = pathwayManager;\n        \n        //clears the combo box list \n        //come up with a better way\n        pathwayList.removeAllItems();\n        pathwayList.addItem(noPathway);\n        pathwayList.addItem(addPathway);\n        \n        //iterting through to add existing pathways to the combo box list\n        for (Iterator i = pathwayManager.getPathwayIterator(); i.hasNext();)\n        {\n            pathwayList.addItem((LWPathway)i.next());           \n        }\n        \n        //sets the current pathway to the current pathway \n        LWPathway pathway;\n        if ((pathway = this.pathwayManager.getCurrentPathway()) != null)\n          setCurrentPathway(pathway);\n        \n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String[] args)\n    {\n        String laf = null;\n        //laf = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n        //laf = javax.swing.UIManager.getCrossPlatformLookAndFeelClassName();\n        try {\n            if (laf != null)\n                javax.swing.UIManager.setLookAndFeel(laf);\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n        \n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        tabbedPane = new JTabbedPane();\n        tabbedPane.setTabPlacement(SwingConstants.BOTTOM);\n        tabbedPane.setPreferredSize(new Dimension(500,400));\n        \n        if (args.length < 1) {\n            //-------------------------------------------------------\n            // Temporary: create example map(s)\n            //-------------------------------------------------------\n            LWMap map1 = new LWMap(\"One\");\n            LWMap map2 = new LWMap(\"Two\");\n\n            installExampleMap(map1);\n            installExampleMap(map2);\n            installExampleNodes(map1);\n            \n            displayMap(map1);\n            displayMap(map2);\n\n            // Create an empty map\n            //displayMap(new LWMap(\"New Map\"));\n        }\n\n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n        toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n        //toolPanel.add(new MapItemInspector(), BorderLayout.SOUTH);\n\n\n        JSplitPane splitPane = new JSplitPane();\n        //JScrollPane leftScroller = new JScrollPane(toolPanel);\n\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(true);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n        splitPane.setRightComponent(tabbedPane);\n\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        //vuePanel.add(splitPane);\n\n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        //inspectorTool.addTool(new MapItemInspector());\n        \n        LWPathwayManager manager = getActiveMap().getPathwayManager();\n        //LWPathwayInspector pathwayInspect = new LWPathwayInspector(frame);\n\n        pathwayInspector = new LWPathwayInspector(frame);\n\n        //inspector = new LWPathwayInspector(frame, manager.getCurrentPathway());\n        \n        //added by Daisuke Fujiwara\n        control = new PathwayControl(frame, manager);\n        \n        Action[] windowActions = { pannerTool.getDisplayAction(),\n                                   inspectorTool.getDisplayAction(),\n                                   pathwayInspector.getDisplayAction(),\n                                   control.getDisplayAction()\n                                 };\n\n        // adding the menus and toolbars\n        setMenuToolbars(frame, windowActions);\n        \n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        Dimension d = frame.getToolkit().getScreenSize();\n        int x = d.width/2 - frame.getWidth()/2;\n        int y = d.height/2 - frame.getHeight()/2;\n        frame.setLocation(x, y);\n        \n        frame.show();\n\n        if (args.length > 0) {\n            VUE.activateWaitCursor();\n            try {\n                LWMap map = OpenAction.loadMap(args[0]);\n                if (map != null)\n                    displayMap(map);\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n    }","id":22624,"modified_method":"public static void main(String[] args)\n    {\n        String laf = null;\n        //laf = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\n        //laf = javax.swing.UIManager.getCrossPlatformLookAndFeelClassName();\n        try {\n            if (laf != null)\n                javax.swing.UIManager.setLookAndFeel(laf);\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n        \n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n\n        tabbedPane = new JTabbedPane();\n        tabbedPane.setTabPlacement(SwingConstants.BOTTOM);\n        tabbedPane.setPreferredSize(new Dimension(500,400));\n         \n        if (args.length < 1) {\n            //-------------------------------------------------------\n            // Temporary: create example map(s)\n            //-------------------------------------------------------\n            LWMap map1 = new LWMap(\"One\");\n            LWMap map2 = new LWMap(\"Two\");\n\n            installExampleMap(map1);\n            installExampleMap(map2);\n            installExampleNodes(map1);\n            \n            displayMap(map1);\n            displayMap(map2);\n\n            // Create an empty map\n            //displayMap(new LWMap(\"New Map\"));\n        }\n\n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        JPanel toolPanel = new JPanel();\n        toolPanel.setLayout(new BorderLayout());\n        toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n        toolPanel.add(new LWCInspector(), BorderLayout.SOUTH);\n        //toolPanel.add(new MapItemInspector(), BorderLayout.SOUTH);\n\n\n        JSplitPane splitPane = new JSplitPane();\n        //JScrollPane leftScroller = new JScrollPane(toolPanel);\n\n        splitPane.setResizeWeight(0.25); // 25% space to the left component\n        splitPane.setContinuousLayout(true);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //splitPane.setLeftComponent(leftScroller);\n        splitPane.setRightComponent(tabbedPane);\n\n\n        frame = new VueFrame();\n        JPanel vuePanel = new VuePanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n        //vuePanel.add(splitPane);\n\n        // Create the tool windows\n        ToolWindow pannerTool = new ToolWindow(\"Panner\", frame);\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        ToolWindow inspectorTool = new ToolWindow(\"Inspector\", frame);\n        inspectorTool.addTool(new LWCInspector());\n        //inspectorTool.addTool(new MapItemInspector());\n        \n        pathwayInspector = new LWPathwayInspector(frame);\n        \n        //inspector = new LWPathwayInspector(frame, manager.getCurrentPathway());\n        \n        //added by Daisuke Fujiwara\n        LWPathwayManager manager = getActiveMap().getPathwayManager();\n        control = new PathwayControl(frame, manager);\n         \n        //accomodates pathway manager swapping when the displayed map is changed\n        tabbedPane.addChangeListener(\n            new ChangeListener()\n            {\n                public void stateChanged(ChangeEvent ce)\n                {\n                    System.out.println(\"map is being changed\");\n                    control.setPathwayManager(getActiveMap().getPathwayManager());\n                }\n            }\n        );\n        \n        //End of addition by Daisuke Fujiwara\n        Action[] windowActions = { pannerTool.getDisplayAction(),\n                                   inspectorTool.getDisplayAction(),\n                                   pathwayInspector.getDisplayAction(),\n                                   control.getDisplayAction()\n                                 };\n\n        // adding the menus and toolbars\n        setMenuToolbars(frame, windowActions);\n        \n        frame.getContentPane().add(vuePanel,BorderLayout.CENTER);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        frame.setBackground(Color.white);\n        frame.pack();\n\n        Dimension d = frame.getToolkit().getScreenSize();\n        int x = d.width/2 - frame.getWidth()/2;\n        int y = d.height/2 - frame.getHeight()/2;\n        frame.setLocation(x, y);\n        \n        frame.show();\n\n        if (args.length > 0) {\n            VUE.activateWaitCursor();\n            try {\n                LWMap map = OpenAction.loadMap(args[0]);\n                if (map != null)\n                    displayMap(map);\n            } finally {\n                VUE.clearWaitCursor();\n            }\n        }\n    }","commit_id":"db891f6adc270eb22fafcfe778973fb2d4eeabc4","url":"https://github.com/VUE/VUE"},{"original_method":"/** {@inheritDoc} */\n    public void migrate(XWikiHibernateMigrationManager manager, final XWikiContext context)\n        throws XWikiException\n    {\n        // migrate data\n        manager.getStore(context).executeWrite(context, true, new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                try {\n                    Statement stmt = session.connection().createStatement();\n                    ResultSet rs;\n                    try {\n                        // We place an empty character in archives for documents that have already been migrated so\n                        // that we can re-execute this migrator and not start over.\n                        // Note that we cannot use NULL since in old databases (prior to 1.1) the XWD_ARCHIVE column\n                        // had a not null constraint and since this column has disappeared in 1.2 and after, the\n                        // hibernate update script will not have modified the nullability of it...\n                        // (see http://jira.xwiki.org/jira/browse/XWIKI-2074).\n                        rs = stmt.executeQuery(\"select XWD_ID, XWD_ARCHIVE, XWD_FULLNAME from xwikidoc where (XWD_ARCHIVE is not null and XWD_ARCHIVE <> ' ') order by XWD_VERSION\");\n                    } catch (SQLException e) {\n                        // most likely there is no XWD_ARCHIVE column, so migration is not needed\n                        // is there easier way to find what column is not exist?\n                        return null;\n                    }\n                    Transaction originalTransaction = ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).getTransaction(context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setSession(null, context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setTransaction(null, context);\n                    PreparedStatement deleteStatement = session.connection().prepareStatement(\"update xwikidoc set XWD_ARCHIVE=' ' where XWD_ID=?\");\n\n                    while (rs.next()) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Updating document [\" + rs.getString(3) + \"]...\");\n                        }\n                        long docId = Long.parseLong(rs.getString(1));\n                        String sArchive = rs.getString(2);\n\n                        // In some weird cases it can happen that the XWD_ARCHIVE field is empty (that shouldn't happen but we've seen it happening).\n                        // In this case just ignore the archive...\n                        if (sArchive.trim().length() != 0) {\n                            XWikiDocumentArchive docArchive = new XWikiDocumentArchive(docId);\n                            docArchive.setArchive(sArchive);\n                            context.getWiki().getVersioningStore().saveXWikiDocArchive(docArchive, true, context);\n                        } else {\n                            LOG.warn(\"Empty revision found for document [\" + rs.getString(3) + \"]. Ignoring non-fatal error.\");\n                        }\n                        deleteStatement.setLong(1, docId);\n                        deleteStatement.executeUpdate();\n                    }\n                    deleteStatement.close();\n                    stmt.close();\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setSession(session, context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setTransaction(originalTransaction, context);\n                } catch (SQLException e) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_STORE_MIGRATION, getName() + \" migration failed\", e);\n                }\n                return Boolean.TRUE;\n            }\n        });\n    }","id":22625,"modified_method":"/** {@inheritDoc} */\n    public void migrate(XWikiHibernateMigrationManager manager, final XWikiContext context)\n        throws XWikiException\n    {\n        // migrate data\n        manager.getStore(context).executeWrite(context, true, new HibernateCallback<Object>()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    Statement stmt = session.connection().createStatement();\n                    ResultSet rs;\n                    try {\n                        // We place an empty character in archives for documents that have already\n                        // been migrated so\n                        // that we can re-execute this migrator and not start over.\n                        // Note that we cannot use NULL since in old databases (prior to 1.1) the\n                        // XWD_ARCHIVE column\n                        // had a not null constraint and since this column has disappeared in 1.2\n                        // and after, the\n                        // hibernate update script will not have modified the nullability of it...\n                        // (see http://jira.xwiki.org/jira/browse/XWIKI-2074).\n                        rs =\n                            stmt\n                                .executeQuery(\"select XWD_ID, XWD_ARCHIVE, XWD_FULLNAME from xwikidoc where (XWD_ARCHIVE is not null and XWD_ARCHIVE <> ' ') order by XWD_VERSION\");\n                    } catch (SQLException e) {\n                        // most likely there is no XWD_ARCHIVE column, so migration is not needed\n                        // is there easier way to find what column is not exist?\n                        return null;\n                    }\n                    Transaction originalTransaction =\n                        ((XWikiHibernateVersioningStore) context.getWiki().getVersioningStore())\n                            .getTransaction(context);\n                    ((XWikiHibernateVersioningStore) context.getWiki().getVersioningStore())\n                        .setSession(null, context);\n                    ((XWikiHibernateVersioningStore) context.getWiki().getVersioningStore())\n                        .setTransaction(null, context);\n                    PreparedStatement deleteStatement =\n                        session.connection().prepareStatement(\n                            \"update xwikidoc set XWD_ARCHIVE=' ' where XWD_ID=?\");\n\n                    while (rs.next()) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Updating document [\" + rs.getString(3) + \"]...\");\n                        }\n                        long docId = Long.parseLong(rs.getString(1));\n                        String sArchive = rs.getString(2);\n\n                        // In some weird cases it can happen that the XWD_ARCHIVE field is empty\n                        // (that shouldn't happen but we've seen it happening).\n                        // In this case just ignore the archive...\n                        if (sArchive.trim().length() != 0) {\n                            XWikiDocumentArchive docArchive = new XWikiDocumentArchive(docId);\n                            docArchive.setArchive(sArchive);\n                            context.getWiki().getVersioningStore().saveXWikiDocArchive(\n                                docArchive, true, context);\n                        } else {\n                            LOG.warn(\"Empty revision found for document [\" + rs.getString(3)\n                                + \"]. Ignoring non-fatal error.\");\n                        }\n                        deleteStatement.setLong(1, docId);\n                        deleteStatement.executeUpdate();\n                    }\n                    deleteStatement.close();\n                    stmt.close();\n                    ((XWikiHibernateVersioningStore) context.getWiki().getVersioningStore())\n                        .setSession(session, context);\n                    ((XWikiHibernateVersioningStore) context.getWiki().getVersioningStore())\n                        .setTransaction(originalTransaction, context);\n                } catch (SQLException e) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_STORE_MIGRATION,\n                        getName() + \" migration failed\",\n                        e);\n                }\n                return Boolean.TRUE;\n            }\n        });\n    }","commit_id":"d84b1de92b8a5a503c4191ce5bd6c314c90409ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/** {@inheritDoc} */\n    public void migrate(XWikiHibernateMigrationManager manager, final XWikiContext context)\n        throws XWikiException\n    {\n        // migrate data\n        manager.getStore(context).executeWrite(context, true, new XWikiHibernateBaseStore.HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                try {\n                    Query query = session.createQuery(\"select rcs.id, rcs.patch, doc.fullName \"\n                        + \"from XWikiDocument as doc, XWikiRCSNodeContent as rcs where \"\n                        + \"doc.id = rcs.id.docId and rcs.patch.diff = true and rcs.patch.content like '<?xml%'\");\n                    Iterator it = query.list().iterator();\n\n                    Transaction originalTransaction = ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).getTransaction(context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setSession(null, context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setTransaction(null, context);\n\n                    while (it.hasNext()) {\n                        Object[] result = (Object[]) it.next();\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Fixing document [\" + result[2] + \"]...\");\n                        }\n\n                        // Reconstruct a XWikiRCSNodeContent object with isDiff set to false and update it.\n                        XWikiRCSNodeId nodeId = (XWikiRCSNodeId) result[0];\n                        XWikiRCSNodeContent fixedNodeContent = new XWikiRCSNodeContent(nodeId);\n                        XWikiPatch patch = (XWikiPatch) result[1];\n                        patch.setDiff(false);\n                        fixedNodeContent.setPatch(patch);\n\n                        session.update(fixedNodeContent);\n                    }\n\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setSession(session, context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setTransaction(originalTransaction, context);\n                } catch (Exception e) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_STORE_MIGRATION, getName() + \" migration failed\", e);\n                }\n                return Boolean.TRUE;\n            }\n        });\n    }","id":22626,"modified_method":"/** {@inheritDoc} */\n    public void migrate(XWikiHibernateMigrationManager manager, final XWikiContext context)\n        throws XWikiException\n    {\n        // migrate data\n        manager.getStore(context).executeWrite(context, true, new XWikiHibernateBaseStore.HibernateCallback<Object>() {\n            public Object doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                try {\n                    Query query = session.createQuery(\"select rcs.id, rcs.patch, doc.fullName \"\n                        + \"from XWikiDocument as doc, XWikiRCSNodeContent as rcs where \"\n                        + \"doc.id = rcs.id.docId and rcs.patch.diff = true and rcs.patch.content like '<?xml%'\");\n                    Iterator it = query.list().iterator();\n\n                    Transaction originalTransaction = ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).getTransaction(context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setSession(null, context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setTransaction(null, context);\n\n                    while (it.hasNext()) {\n                        Object[] result = (Object[]) it.next();\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Fixing document [\" + result[2] + \"]...\");\n                        }\n\n                        // Reconstruct a XWikiRCSNodeContent object with isDiff set to false and update it.\n                        XWikiRCSNodeId nodeId = (XWikiRCSNodeId) result[0];\n                        XWikiRCSNodeContent fixedNodeContent = new XWikiRCSNodeContent(nodeId);\n                        XWikiPatch patch = (XWikiPatch) result[1];\n                        patch.setDiff(false);\n                        fixedNodeContent.setPatch(patch);\n\n                        session.update(fixedNodeContent);\n                    }\n\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setSession(session, context);\n                    ((XWikiHibernateVersioningStore)context.getWiki().getVersioningStore()).setTransaction(originalTransaction, context);\n                } catch (Exception e) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                        XWikiException.ERROR_XWIKI_STORE_MIGRATION, getName() + \" migration failed\", e);\n                }\n                return Boolean.TRUE;\n            }\n        });\n    }","commit_id":"d84b1de92b8a5a503c4191ce5bd6c314c90409ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/** {@inheritDoc} */\n    public void migrate(XWikiHibernateMigrationManager manager, final XWikiContext context)\n        throws XWikiException\n    {\n        manager.getStore(context).executeWrite(context, true, new HibernateCallback()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    Statement stmt = session.connection().createStatement();\n                    stmt.executeUpdate(\"ALTER TABLE xwikidoc DROP COLUMN XWD_ARCHIVE\");\n                    stmt.close();\n                } catch (SQLException ex) {\n                    // Maybe the column doesn't exist. Anyway, in case we're using a DBMS which\n                    // doesn't support DROP COLUMN (such as Derby < 10.3.1.4), we can try to alter\n                    // the column to allow NULL values.\n                    // TODO Can we check the exception and see what is happening?\n                    try {\n                        Statement stmt = session.connection().createStatement();\n                        stmt.executeUpdate(\"ALTER TABLE xwikidoc ALTER COLUMN XWD_ARCHIVE \"\n                            + \"SET DEFAULT ' '\");\n                        stmt.close();\n                    } catch (SQLException ex2) {\n                        // Maybe the column doesn't exist, after all.\n                        /*\n                         * TODO Can we check the exception and see what is happening? If the\n                         * statements failed because they are not supported by the DBMS, then this\n                         * is a fatal error, perhaps we should stop serving request and notify the\n                         * admin\n                         */\n                    }\n                }\n                return Boolean.TRUE;\n            }\n        });\n    }","id":22627,"modified_method":"/** {@inheritDoc} */\n    public void migrate(XWikiHibernateMigrationManager manager, final XWikiContext context)\n        throws XWikiException\n    {\n        manager.getStore(context).executeWrite(context, true, new HibernateCallback<Object>()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    Statement stmt = session.connection().createStatement();\n                    stmt.executeUpdate(\"ALTER TABLE xwikidoc DROP COLUMN XWD_ARCHIVE\");\n                    stmt.close();\n                } catch (SQLException ex) {\n                    // Maybe the column doesn't exist. Anyway, in case we're using a DBMS which\n                    // doesn't support DROP COLUMN (such as Derby < 10.3.1.4), we can try to alter\n                    // the column to allow NULL values.\n                    // TODO Can we check the exception and see what is happening?\n                    try {\n                        Statement stmt = session.connection().createStatement();\n                        stmt.executeUpdate(\"ALTER TABLE xwikidoc ALTER COLUMN XWD_ARCHIVE \"\n                            + \"SET DEFAULT ' '\");\n                        stmt.close();\n                    } catch (SQLException ex2) {\n                        // Maybe the column doesn't exist, after all.\n                        /*\n                         * TODO Can we check the exception and see what is happening? If the\n                         * statements failed because they are not supported by the DBMS, then this\n                         * is a fatal error, perhaps we should stop serving request and notify the\n                         * admin\n                         */\n                    }\n                }\n                return Boolean.TRUE;\n            }\n        });\n    }","commit_id":"d84b1de92b8a5a503c4191ce5bd6c314c90409ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/** {@inheritDoc} */\n    protected List getAllMigrations(XWikiContext context) throws XWikiException\n    {\n        List result = new ArrayList();\n        // TODO: how to register migrations?\n        // 1st way:\n        result.add(new R4340XWIKI883Migrator());\n        result.add(new R4359XWIKI1459Migrator());\n        result.add(new R6079XWIKI1878Migrator());\n        result.add(new R6405XWIKI1933Migrator());\n        result.add(new R7350XWIKI2079Migrator());\n        // 2nd way - via classloader\n        \n        return result;\n    }","id":22628,"modified_method":"/** {@inheritDoc} */\n    protected List<XWikiMigratorInterface> getAllMigrations(XWikiContext context) throws XWikiException\n    {\n        List<XWikiMigratorInterface> result = new ArrayList<XWikiMigratorInterface>();\n        // TODO: how to register migrations?\n        // 1st way:\n        result.add(new R4340XWIKI883Migrator());\n        result.add(new R4359XWIKI1459Migrator());\n        result.add(new R6079XWIKI1878Migrator());\n        result.add(new R6405XWIKI1933Migrator());\n        result.add(new R7350XWIKI2079Migrator());\n        // 2nd way - via component manager\n        \n        return result;\n    }","commit_id":"d84b1de92b8a5a503c4191ce5bd6c314c90409ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/** {@inheritDoc} */\n    protected void setDBVersion(final XWikiDBVersion version, XWikiContext context) throws XWikiException {\n        getStore(context).executeWrite(context, true, new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                session.createQuery(\"delete from \"+XWikiDBVersion.class.getName()).executeUpdate();\n                session.save(version);\n                return null;\n            }\n        });\n    }","id":22629,"modified_method":"/** {@inheritDoc} */\n    protected void setDBVersion(final XWikiDBVersion version, XWikiContext context) throws XWikiException {\n        getStore(context).executeWrite(context, true, new HibernateCallback<Object>() {\n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                session.createQuery(\"delete from \"+XWikiDBVersion.class.getName()).executeUpdate();\n                session.save(version);\n                return null;\n            }\n        });\n    }","commit_id":"d84b1de92b8a5a503c4191ce5bd6c314c90409ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/** {@inheritDoc} */\n    public XWikiDBVersion getDBVersion(XWikiContext context) throws XWikiException {\n        XWikiDBVersion ver = getDBVersionFromConfig(context);\n        return ver != null ? ver : (XWikiDBVersion) getStore(context).executeRead(context, true,\n            new HibernateCallback() { \n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                XWikiDBVersion result = (XWikiDBVersion) session.createCriteria(\n                    XWikiDBVersion.class).uniqueResult();\n                return result==null ? new XWikiDBVersion(0) : result;\n            }\n        });\n    }","id":22630,"modified_method":"/** {@inheritDoc} */\n    public XWikiDBVersion getDBVersion(XWikiContext context) throws XWikiException {\n        XWikiDBVersion ver = getDBVersionFromConfig(context);\n        return ver != null ? ver : getStore(context).executeRead(context, true,\n            new HibernateCallback<XWikiDBVersion>() { \n            public XWikiDBVersion doInHibernate(Session session) throws HibernateException\n            {\n                XWikiDBVersion result = (XWikiDBVersion) session.createCriteria(\n                    XWikiDBVersion.class).uniqueResult();\n                return result==null ? new XWikiDBVersion(0) : result;\n            }\n        });\n    }","commit_id":"d84b1de92b8a5a503c4191ce5bd6c314c90409ca","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Execute method for read-write operations in hibernate. spring like.\r\n     * \r\n     * @return {@link HibernateCallback#doInHibernate(Session)}\r\n     * @param context - used everywhere.\r\n     * @param bTransaction - should store to use old transaction(false) or create new (true)\r\n     * @param cb - callback to execute\r\n     * @throws XWikiException if any error\r\n     * @see #execute(XWikiContext, boolean, boolean,\r\n     *      com.xpn.xwiki.store.XWikiHibernateBaseStore.HibernateCallback)\r\n     */\r\n    public Object executeWrite(XWikiContext context, boolean bTransaction, HibernateCallback cb)\r\n        throws XWikiException\r\n    {\r\n        return execute(context, bTransaction, true, cb);\r\n    }","id":22631,"modified_method":"/**\r\n     * Execute method for read-write operations in hibernate. spring like.\r\n     * \r\n     * @return {@link HibernateCallback#doInHibernate(Session)}\r\n     * @param context - used everywhere.\r\n     * @param bTransaction - should store to use old transaction(false) or create new (true)\r\n     * @param cb - callback to execute\r\n     * @throws XWikiException if any error\r\n     * @see #execute(XWikiContext, boolean, boolean,\r\n     *      com.xpn.xwiki.store.XWikiHibernateBaseStore.HibernateCallback)\r\n     */\r\n    public <T> T executeWrite(XWikiContext context, boolean bTransaction, HibernateCallback<T> cb)\r\n        throws XWikiException\r\n    {\r\n        return execute(context, bTransaction, true, cb);\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Execute method for read-only operations in hibernate. spring like.\r\n     * \r\n     * @return {@link HibernateCallback#doInHibernate(Session)}\r\n     * @param context - used everywhere.\r\n     * @param bTransaction - should store to use old transaction(false) or create new (true)\r\n     * @param cb - callback to execute\r\n     * @throws XWikiException if any error\r\n     * @see #execute(XWikiContext, boolean, boolean,\r\n     *      com.xpn.xwiki.store.XWikiHibernateBaseStore.HibernateCallback)\r\n     */\r\n    public Object executeRead(XWikiContext context, boolean bTransaction, HibernateCallback cb)\r\n        throws XWikiException\r\n    {\r\n        return execute(context, bTransaction, false, cb);\r\n    }","id":22632,"modified_method":"/**\r\n     * Execute method for read-only operations in hibernate. spring like.\r\n     * \r\n     * @return {@link HibernateCallback#doInHibernate(Session)}\r\n     * @param context - used everywhere.\r\n     * @param bTransaction - should store to use old transaction(false) or create new (true)\r\n     * @param cb - callback to execute\r\n     * @throws XWikiException if any error\r\n     * @see #execute(XWikiContext, boolean, boolean,\r\n     *      com.xpn.xwiki.store.XWikiHibernateBaseStore.HibernateCallback)\r\n     */\r\n    public <T> T executeRead(XWikiContext context, boolean bTransaction, HibernateCallback<T> cb)\r\n        throws XWikiException\r\n    {\r\n        return execute(context, bTransaction, false, cb);\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n         * method executed by {@link XWikiHibernateBaseStore} and pass open session to it.\r\n         * \r\n         * @param session - open hibernate session\r\n         * @return any you need be returned by\r\n         *         {@link XWikiHibernateBaseStore#execute(XWikiContext, boolean, boolean, HibernateCallback)}\r\n         * @throws HibernateException if any store specific exception\r\n         * @throws XWikiException if exception in xwiki.\r\n         */\r\n        Object doInHibernate(Session session) throws HibernateException, XWikiException;","id":22633,"modified_method":"/**\r\n         * method executed by {@link XWikiHibernateBaseStore} and pass open session to it.\r\n         * \r\n         * @param session - open hibernate session\r\n         * @return any you need be returned by\r\n         *         {@link XWikiHibernateBaseStore#execute(XWikiContext, boolean, boolean, HibernateCallback)}\r\n         * @throws HibernateException if any store specific exception\r\n         * @throws XWikiException if exception in xwiki.\r\n         */\r\n        T doInHibernate(Session session) throws HibernateException, XWikiException;","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Execute method for operations in hibernate. spring like.\r\n     * \r\n     * @return {@link HibernateCallback#doInHibernate(Session)}\r\n     * @param context - used everywhere.\r\n     * @param bTransaction - should store use old transaction(false) or create new (true)\r\n     * @param doCommit - should store commit changes(if any), or rollback it.\r\n     * @param cb - callback to execute\r\n     * @throws XWikiException if any error\r\n     */\r\n    public Object execute(XWikiContext context, boolean bTransaction, boolean doCommit,\r\n        HibernateCallback cb) throws XWikiException\r\n    {\r\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\r\n        try {\r\n            // Start monitoring timer\r\n            if (monitor != null) {\r\n                monitor.startTimer(\"hibernate\");\r\n            }\r\n\r\n            if (bTransaction) {\r\n                checkHibernate(context);\r\n                bTransaction = beginTransaction(context);\r\n            }\r\n\r\n            return cb.doInHibernate(getSession(context));\r\n        } catch (Exception e) {\r\n            doCommit = false;\r\n            if (e instanceof XWikiException) {\r\n                throw (XWikiException) e;\r\n            }\r\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\r\n                XWikiException.ERROR_XWIKI_UNKNOWN,\r\n                \"Exception while hibernate execute\",\r\n                e);\r\n        } finally {\r\n            try {\r\n                if (bTransaction) {\r\n                    endTransaction(context, doCommit);\r\n                }\r\n                if (monitor != null) {\r\n                    monitor.endTimer(\"hibernate\");\r\n                }\r\n            } catch (Exception e) {\r\n                if (log.isErrorEnabled())\r\n                    log.error(\"Exeption while close transaction\", e);\r\n            }\r\n        }\r\n    }","id":22634,"modified_method":"/**\r\n     * Execute method for operations in hibernate. spring like.\r\n     * \r\n     * @return {@link HibernateCallback#doInHibernate(Session)}\r\n     * @param context - used everywhere.\r\n     * @param bTransaction - should store use old transaction(false) or create new (true)\r\n     * @param doCommit - should store commit changes(if any), or rollback it.\r\n     * @param cb - callback to execute\r\n     * @throws XWikiException if any error\r\n     */\r\n    public <T> T execute(XWikiContext context, boolean bTransaction, boolean doCommit,\r\n        HibernateCallback<T> cb) throws XWikiException\r\n    {\r\n        MonitorPlugin monitor = Util.getMonitorPlugin(context);\r\n        try {\r\n            // Start monitoring timer\r\n            if (monitor != null) {\r\n                monitor.startTimer(\"hibernate\");\r\n            }\r\n\r\n            if (bTransaction) {\r\n                checkHibernate(context);\r\n                bTransaction = beginTransaction(context);\r\n            }\r\n\r\n            return cb.doInHibernate(getSession(context));\r\n        } catch (Exception e) {\r\n            doCommit = false;\r\n            if (e instanceof XWikiException) {\r\n                throw (XWikiException) e;\r\n            }\r\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\r\n                XWikiException.ERROR_XWIKI_UNKNOWN,\r\n                \"Exception while hibernate execute\",\r\n                e);\r\n        } finally {\r\n            try {\r\n                if (bTransaction) {\r\n                    endTransaction(context, doCommit);\r\n                }\r\n                if (monitor != null) {\r\n                    monitor.endTimer(\"hibernate\");\r\n                }\r\n            } catch (Exception e) {\r\n                if (log.isErrorEnabled())\r\n                    log.error(\"Exeption while close transaction\", e);\r\n            }\r\n        }\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void saveXWikiDocArchive(final XWikiDocumentArchive archivedoc, boolean bTransaction,\r\n        XWikiContext context) throws XWikiException\r\n    {\r\n        executeWrite(context, bTransaction, new HibernateCallback()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException\r\n            {\r\n                for (Iterator it = archivedoc.getDeletedNodeInfo().iterator(); it.hasNext();) {\r\n                    XWikiRCSNodeInfo nodeInfo = (XWikiRCSNodeInfo) it.next();\r\n                    session.delete(nodeInfo);\r\n                    it.remove();\r\n                }\r\n                for (Iterator it = archivedoc.getUpdatedNodeInfos().iterator(); it.hasNext();) {\r\n                    XWikiRCSNodeInfo nodeInfo = (XWikiRCSNodeInfo) it.next();\r\n                    session.saveOrUpdate(nodeInfo);\r\n                    it.remove();\r\n                }\r\n                for (Iterator it = archivedoc.getUpdatedNodeContents().iterator(); it.hasNext();) {\r\n                    XWikiRCSNodeContent nodeContent = (XWikiRCSNodeContent) it.next();\r\n                    session.update(nodeContent);\r\n                    it.remove();\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n    }","id":22635,"modified_method":"public void saveXWikiDocArchive(final XWikiDocumentArchive archivedoc, boolean bTransaction,\r\n        XWikiContext context) throws XWikiException\r\n    {\r\n        executeWrite(context, bTransaction, new HibernateCallback<Object>()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException\r\n            {\r\n                for (Iterator<XWikiRCSNodeInfo> it = archivedoc.getDeletedNodeInfo().iterator(); it.hasNext();) {\r\n                    XWikiRCSNodeInfo nodeInfo = it.next();\r\n                    session.delete(nodeInfo);\r\n                    it.remove();\r\n                }\r\n                for (Iterator<XWikiRCSNodeInfo> it = archivedoc.getUpdatedNodeInfos().iterator(); it.hasNext();) {\r\n                    XWikiRCSNodeInfo nodeInfo = it.next();\r\n                    session.saveOrUpdate(nodeInfo);\r\n                    it.remove();\r\n                }\r\n                for (Iterator<XWikiRCSNodeContent> it = archivedoc.getUpdatedNodeContents().iterator(); it.hasNext();) {\r\n                    XWikiRCSNodeContent nodeContent = it.next();\r\n                    session.update(nodeContent);\r\n                    it.remove();\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Version[] getXWikiDocVersions(XWikiDocument doc, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        try {\r\n            XWikiDocumentArchive archive = getXWikiDocumentArchive(doc, context);\r\n            if (archive == null)\r\n                return new Version[0];\r\n            Collection nodes = archive.getNodes();\r\n            Version[] versions = new Version[nodes.size()];\r\n            Iterator it = nodes.iterator();\r\n            for (int i = 0; i < versions.length; i++) {\r\n                XWikiRCSNodeInfo node = (XWikiRCSNodeInfo) it.next();\r\n                versions[versions.length - 1 - i] = node.getId().getVersion();\r\n            }\r\n            return versions;\r\n        } catch (Exception e) {\r\n            Object[] args = {doc.getFullName()};\r\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\r\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_READING_REVISIONS,\r\n                \"Exception while reading document {0} revisions\",\r\n                e,\r\n                args);\r\n        }\r\n    }","id":22636,"modified_method":"public Version[] getXWikiDocVersions(XWikiDocument doc, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        try {\r\n            XWikiDocumentArchive archive = getXWikiDocumentArchive(doc, context);\r\n            if (archive == null)\r\n                return new Version[0];\r\n            Collection<XWikiRCSNodeInfo> nodes = archive.getNodes();\r\n            Version[] versions = new Version[nodes.size()];\r\n            Iterator<XWikiRCSNodeInfo> it = nodes.iterator();\r\n            for (int i = 0; i < versions.length; i++) {\r\n                XWikiRCSNodeInfo node = it.next();\r\n                versions[versions.length - 1 - i] = node.getId().getVersion();\r\n            }\r\n            return versions;\r\n        } catch (Exception e) {\r\n            Object[] args = {doc.getFullName()};\r\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\r\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_READING_REVISIONS,\r\n                \"Exception while reading document {0} revisions\",\r\n                e,\r\n                args);\r\n        }\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void loadXWikiDocArchive(XWikiDocumentArchive archivedoc, boolean bTransaction,\r\n        XWikiContext context) throws XWikiException\r\n    {\r\n        try {\r\n            List nodes = loadAllRCSNodeInfo(context, archivedoc.getId(), bTransaction);\r\n            archivedoc.setNodes(nodes);\r\n        } catch (Exception e) {\r\n            Object[] args = {new Long(archivedoc.getId())};\r\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\r\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\r\n                \"Exception while loading archive {0}\",\r\n                e,\r\n                args);\r\n        }\r\n    }","id":22637,"modified_method":"public void loadXWikiDocArchive(XWikiDocumentArchive archivedoc, boolean bTransaction,\r\n        XWikiContext context) throws XWikiException\r\n    {\r\n        try {\r\n            List<XWikiRCSNodeInfo> nodes = loadAllRCSNodeInfo(context, archivedoc.getId(), bTransaction);\r\n            archivedoc.setNodes(nodes);\r\n        } catch (Exception e) {\r\n            Object[] args = {new Long(archivedoc.getId())};\r\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\r\n                XWikiException.ERROR_XWIKI_STORE_HIBERNATE_LOADING_OBJECT,\r\n                \"Exception while loading archive {0}\",\r\n                e,\r\n                args);\r\n        }\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void resetRCSArchive(final XWikiDocument doc, boolean bTransaction,\r\n        final XWikiContext context) throws XWikiException\r\n    {\r\n        executeWrite(context, true, new HibernateCallback()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException,\r\n                XWikiException\r\n            {\r\n                XWikiDocumentArchive archive = getXWikiDocumentArchive(doc, context);\r\n                archive.resetArchive();\r\n                archive.getDeletedNodeInfo().clear();\r\n                doc.setMinorEdit(false);\r\n                deleteArchive(doc, false, context);\r\n                updateXWikiDocArchive(doc, false, context);\r\n                return null;\r\n            }\r\n        });\r\n    }","id":22638,"modified_method":"public void resetRCSArchive(final XWikiDocument doc, boolean bTransaction,\r\n        final XWikiContext context) throws XWikiException\r\n    {\r\n        executeWrite(context, true, new HibernateCallback<Object>()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException,\r\n                XWikiException\r\n            {\r\n                XWikiDocumentArchive archive = getXWikiDocumentArchive(doc, context);\r\n                archive.resetArchive();\r\n                archive.getDeletedNodeInfo().clear();\r\n                doc.setMinorEdit(false);\r\n                deleteArchive(doc, false, context);\r\n                updateXWikiDocArchive(doc, false, context);\r\n                return null;\r\n            }\r\n        });\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    public XWikiRCSNodeContent loadRCSNodeContent(final XWikiRCSNodeId id, boolean bTransaction,\r\n        XWikiContext context) throws XWikiException\r\n    {\r\n        return (XWikiRCSNodeContent) executeRead(context, bTransaction, new HibernateCallback()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException\r\n            {\r\n                XWikiRCSNodeContent content = new XWikiRCSNodeContent(id);\r\n                session.load(content, content.getId());\r\n                return content;\r\n            }\r\n        });\r\n    }","id":22639,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    public XWikiRCSNodeContent loadRCSNodeContent(final XWikiRCSNodeId id, boolean bTransaction,\r\n        XWikiContext context) throws XWikiException\r\n    {\r\n        return executeRead(context, bTransaction, new HibernateCallback<XWikiRCSNodeContent>()\r\n        {\r\n            public XWikiRCSNodeContent doInHibernate(Session session) throws HibernateException\r\n            {\r\n                XWikiRCSNodeContent content = new XWikiRCSNodeContent(id);\r\n                session.load(content, content.getId());\r\n                return content;\r\n            }\r\n        });\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected List loadAllRCSNodeInfo(XWikiContext context, final long id, boolean bTransaction)\r\n        throws XWikiException\r\n    {\r\n        return (List) executeRead(context, bTransaction, new HibernateCallback()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException\r\n            {\r\n                try {\r\n                    return session.createCriteria(XWikiRCSNodeInfo.class).add(\r\n                        Restrictions.eq(\"id.docId\", Long.valueOf(id))).add(\r\n                        Restrictions.isNotNull(\"diff\")).list();\r\n                } catch (IllegalArgumentException ex) {\r\n                    // This happens when the database has wrong values...\r\n                    log.warn(\"Invalid history for document \" + id);\r\n                    return Collections.emptyList();\r\n                }\r\n            }\r\n        });\r\n    }","id":22640,"modified_method":"protected List<XWikiRCSNodeInfo> loadAllRCSNodeInfo(XWikiContext context, final long id, boolean bTransaction)\r\n        throws XWikiException\r\n    {\r\n        return executeRead(context, bTransaction, new HibernateCallback<List<XWikiRCSNodeInfo>>()\r\n        {\r\n            @SuppressWarnings(\"unchecked\")\r\n            public List<XWikiRCSNodeInfo> doInHibernate(Session session) throws HibernateException\r\n            {\r\n                try {\r\n                    return session.createCriteria(XWikiRCSNodeInfo.class).add(\r\n                        Restrictions.eq(\"id.docId\", Long.valueOf(id))).add(\r\n                        Restrictions.isNotNull(\"diff\")).list();\r\n                } catch (IllegalArgumentException ex) {\r\n                    // This happens when the database has wrong values...\r\n                    log.warn(\"Invalid history for document \" + id);\r\n                    return Collections.emptyList();\r\n                }\r\n            }\r\n        });\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    public void deleteArchive(final XWikiDocument doc, boolean bTransaction, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        executeWrite(context, bTransaction, new HibernateCallback()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException,\r\n                XWikiException\r\n            {\r\n                session.createQuery(\r\n                    \"delete from \" + XWikiRCSNodeInfo.class.getName() + \" where id.docId=?\")\r\n                    .setLong(0, doc.getId()).executeUpdate();\r\n                return null;\r\n            }\r\n        });\r\n    }","id":22641,"modified_method":"/**\r\n     * {@inheritDoc}\r\n     */\r\n    public void deleteArchive(final XWikiDocument doc, boolean bTransaction, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n        executeWrite(context, bTransaction, new HibernateCallback<Object>()\r\n        {\r\n            public Object doInHibernate(Session session) throws HibernateException,\r\n                XWikiException\r\n            {\r\n                session.createQuery(\r\n                    \"delete from \" + XWikiRCSNodeInfo.class.getName() + \" where id.docId=?\")\r\n                    .setLong(0, doc.getId()).executeUpdate();\r\n                return null;\r\n            }\r\n        });\r\n    }","commit_id":"635354c82cc2fffcb859592308e1fdb8de2eff19","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiDeletedDocument[] getAllDeletedDocuments(final XWikiDocument doc, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        return (XWikiDeletedDocument[]) executeRead(context, bTransaction, new HibernateCallback()\n        {\n            public Object doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                List lst =\n                    session.createCriteria(XWikiDeletedDocument.class).add(\n                        Restrictions.eq(\"fullName\", doc.getFullName())).add(\n                        Restrictions.eq(\"language\", doc.getLanguage())).addOrder(Order.desc(\"date\")).list();\n                XWikiDeletedDocument[] result = new XWikiDeletedDocument[lst.size()];\n                return lst.toArray(result);\n            }\n        });\n    }","id":22642,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiDeletedDocument[] getAllDeletedDocuments(final XWikiDocument doc, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, bTransaction, new HibernateCallback<XWikiDeletedDocument[]>()\n        {\n            public XWikiDeletedDocument[] doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                Criteria c = session.createCriteria(XWikiDeletedDocument.class);\n                c.add(Restrictions.eq(\"fullName\", doc.getFullName()));\n                c.add(Restrictions.eq(\"language\", doc.getLanguage()));\n                c.addOrder(Order.desc(\"date\"));\n                @SuppressWarnings(\"unchecked\")\n                List<XWikiDeletedDocument> deletedVersions = c.list();\n                XWikiDeletedDocument[] result = new XWikiDeletedDocument[deletedVersions.size()];\n                return deletedVersions.toArray(result);\n            }\n        });\n    }","commit_id":"0becbdb374c14877ac9506b530a06d37f7888148","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public DeletedAttachment[] getAllDeletedAttachments(final XWikiDocument doc,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return (DeletedAttachment[]) executeRead(context, bTransaction, new HibernateCallback()\n        {\n            @SuppressWarnings(\"unchecked\")\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                assert doc != null;\n                List<DeletedAttachment> lst =\n                    session.createCriteria(DeletedAttachment.class).add(\n                        Restrictions.eq(\"docId\", doc.getId())).addOrder(Order.desc(\"date\"))\n                        .list();\n                DeletedAttachment[] result = new DeletedAttachment[lst.size()];\n                return lst.toArray(result);\n            }\n        });\n    }","id":22643,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public List<DeletedAttachment> getAllDeletedAttachments(final XWikiDocument doc,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, bTransaction,\n            new HibernateCallback<List<DeletedAttachment>>()\n            {\n                @SuppressWarnings(ANOTATE_UNCHECKED)\n                public List<DeletedAttachment> doInHibernate(Session session)\n                    throws HibernateException, XWikiException\n                {\n                    assert doc != null;\n                    return session.createCriteria(DeletedAttachment.class).add(\n                        Restrictions.eq(DOC_ID, doc.getId())).addOrder(Order.desc(DATE)).list();\n                }\n            });\n    }","commit_id":"86b32d0f770e1a1a744975f46a3ce29785021fae","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiAttachment restoreFromRecycleBin(final XWikiAttachment attachment,\n        final long index, final XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return (XWikiAttachment) executeRead(context, bTransaction, new HibernateCallback()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    DeletedAttachment trashAttachment =\n                        (DeletedAttachment) session.load(DeletedAttachment.class, Long\n                            .valueOf(index));\n                    return trashAttachment.restoreAttachment(attachment, context);\n                } catch (Exception ex) {\n                    return null;\n                }\n            }\n        });\n    }","id":22644,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiAttachment restoreFromRecycleBin(final XWikiAttachment attachment,\n        final long index, final XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, bTransaction, new HibernateCallback<XWikiAttachment>()\n        {\n            public XWikiAttachment doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    DeletedAttachment trashAttachment =\n                        (DeletedAttachment) session.load(DeletedAttachment.class, Long\n                            .valueOf(index));\n                    return trashAttachment.restoreAttachment(attachment, context);\n                } catch (Exception ex) {\n                    // Invalid recycle entry.\n                    return null;\n                }\n            }\n        });\n    }","commit_id":"86b32d0f770e1a1a744975f46a3ce29785021fae","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public DeletedAttachment getDeletedAttachment(final long index, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        return (DeletedAttachment) executeRead(context, bTransaction, new HibernateCallback()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                return session.get(DeletedAttachment.class, Long.valueOf(index));\n            }\n        });\n    }","id":22645,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public DeletedAttachment getDeletedAttachment(final long index, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        return (DeletedAttachment) executeRead(context, bTransaction,\n            new HibernateCallback<DeletedAttachment>()\n            {\n                public DeletedAttachment doInHibernate(Session session)\n                    throws HibernateException, XWikiException\n                {\n                    return (DeletedAttachment) session.get(DeletedAttachment.class, Long\n                        .valueOf(index));\n                }\n            });\n    }","commit_id":"86b32d0f770e1a1a744975f46a3ce29785021fae","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public DeletedAttachment[] getAllDeletedAttachments(final XWikiAttachment attachment,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return (DeletedAttachment[]) executeRead(context, bTransaction, new HibernateCallback()\n        {\n            @SuppressWarnings(\"unchecked\")\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                Criteria c = session.createCriteria(DeletedAttachment.class);\n                if (attachment != null) {\n                    c.add(Restrictions.eq(\"docId\", attachment.getDocId()));\n                    if (!StringUtils.isBlank(attachment.getFilename())) {\n                        c.add(Restrictions.eq(\"filename\", attachment.getFilename()));\n                    }\n                }\n                List<DeletedAttachment> lst = c.addOrder(Order.desc(\"date\")).list();\n                DeletedAttachment[] result = new DeletedAttachment[lst.size()];\n                return lst.toArray(result);\n            }\n        });\n    }","id":22646,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public List<DeletedAttachment> getAllDeletedAttachments(final XWikiAttachment attachment,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, bTransaction,\n            new HibernateCallback<List<DeletedAttachment>>()\n            {\n                @SuppressWarnings(\"unchecked\")\n                public List<DeletedAttachment> doInHibernate(Session session)\n                    throws HibernateException, XWikiException\n                {\n                    Criteria c = session.createCriteria(DeletedAttachment.class);\n                    if (attachment != null) {\n                        c.add(Restrictions.eq(DOC_ID, attachment.getDocId()));\n                        if (!StringUtils.isBlank(attachment.getFilename())) {\n                            c.add(Restrictions.eq(\"filename\", attachment.getFilename()));\n                        }\n                    }\n                    return (List<DeletedAttachment>) c.addOrder(Order.desc(DATE)).list();\n                }\n            });\n    }","commit_id":"86b32d0f770e1a1a744975f46a3ce29785021fae","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void saveToRecycleBin(XWikiAttachment attachment, String deleter, Date date,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        final DeletedAttachment trashAtachment =\n            new DeletedAttachment(attachment, deleter, date, context);\n        executeWrite(context, bTransaction, new HibernateCallback()\n        {\n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                session.save(trashAtachment);\n                return null;\n            }\n        });\n    }","id":22647,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void saveToRecycleBin(XWikiAttachment attachment, String deleter, Date date,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        final DeletedAttachment trashAtachment =\n            new DeletedAttachment(attachment, deleter, date, context);\n        executeWrite(context, bTransaction, new HibernateCallback<Object>()\n        {\n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                session.save(trashAtachment);\n                return null;\n            }\n        });\n    }","commit_id":"86b32d0f770e1a1a744975f46a3ce29785021fae","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void deleteFromRecycleBin(final long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        executeWrite(context, bTransaction, new HibernateCallback()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    session.createQuery(\n                        \"delete from \" + DeletedAttachment.class.getName() + \" where id=?\")\n                        .setLong(0, index).executeUpdate();\n                } catch (Exception ex) {\n                    // Invalid ID?\n                }\n                return null;\n            }\n        });\n    }","id":22648,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void deleteFromRecycleBin(final long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        executeWrite(context, bTransaction, new HibernateCallback<Object>()\n        {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                try {\n                    session.createQuery(\n                        \"delete from \" + DeletedAttachment.class.getName() + \" where id=?\")\n                        .setLong(0, index).executeUpdate();\n                } catch (Exception ex) {\n                    // Invalid ID?\n                }\n                return null;\n            }\n        });\n    }","commit_id":"86b32d0f770e1a1a744975f46a3ce29785021fae","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiDocument restoreFromRecycleBin(final XWikiDocument doc, final long index, \n        final XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return (XWikiDocument) executeRead(context, bTransaction, new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                XWikiDeletedDocument trashdoc = (XWikiDeletedDocument) session.load(\n                    XWikiDeletedDocument.class, Long.valueOf(index));\n                return trashdoc.restoreDocument(null, context);\n            }\n        });\n    }","id":22649,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiDocument restoreFromRecycleBin(final XWikiDocument doc, final long index, \n        final XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, bTransaction, new HibernateCallback<XWikiDocument>() {\n            public XWikiDocument doInHibernate(Session session) throws HibernateException, XWikiException\n            {\n                XWikiDeletedDocument trashdoc = (XWikiDeletedDocument) session.load(\n                    XWikiDeletedDocument.class, Long.valueOf(index));\n                return trashdoc.restoreDocument(null, context);\n            }\n        });\n    }","commit_id":"a2f231d064e83ad2999495093b9117ea74794ba6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void saveToRecycleBin(XWikiDocument doc, String deleter, Date date,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        final XWikiDeletedDocument trashdoc = new XWikiDeletedDocument(doc, deleter, date,\n            context);\n        executeWrite(context, bTransaction, new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                session.save(trashdoc);\n                return null;\n            }\n        });\n    }","id":22650,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void saveToRecycleBin(XWikiDocument doc, String deleter, Date date,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        final XWikiDeletedDocument trashdoc = new XWikiDeletedDocument(doc, deleter, date,\n            context);\n        executeWrite(context, bTransaction, new HibernateCallback<Object>() {\n            public Object doInHibernate(Session session) throws HibernateException\n            {\n                session.save(trashdoc);\n                return null;\n            }\n        });\n    }","commit_id":"a2f231d064e83ad2999495093b9117ea74794ba6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void deleteFromRecycleBin(XWikiDocument doc, final long index, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        executeWrite(context, bTransaction, new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                session.createQuery(\"delete from \"+XWikiDeletedDocument.class.getName()\n                    + \" where id=?\").setLong(0, index)\n                    .executeUpdate();\n                return null;\n            }\n        });\n    }","id":22651,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void deleteFromRecycleBin(XWikiDocument doc, final long index, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        executeWrite(context, bTransaction, new HibernateCallback<Object>() {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                session.createQuery(\"delete from \"+XWikiDeletedDocument.class.getName()\n                    + \" where id=?\").setLong(0, index)\n                    .executeUpdate();\n                return null;\n            }\n        });\n    }","commit_id":"a2f231d064e83ad2999495093b9117ea74794ba6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiDeletedDocument getDeletedDocument(XWikiDocument doc, final long index,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return (XWikiDeletedDocument) executeRead(context, bTransaction, new HibernateCallback() {\n            public Object doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                return session.get(XWikiDeletedDocument.class, Long.valueOf(index));\n            }\n        });\n    }","id":22652,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public XWikiDeletedDocument getDeletedDocument(XWikiDocument doc, final long index,\n        XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, bTransaction, new HibernateCallback<XWikiDeletedDocument>() {\n            public XWikiDeletedDocument doInHibernate(Session session) throws HibernateException,\n                XWikiException\n            {\n                return (XWikiDeletedDocument) session.get(XWikiDeletedDocument.class, Long\n                    .valueOf(index));\n            }\n        });\n    }","commit_id":"a2f231d064e83ad2999495093b9117ea74794ba6","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String getSharedLibraryName(String libraryName) {\n        return OperatingSystem.current().getSharedLibraryName(libraryName);\n    }","id":22653,"modified_method":"public String getSharedLibraryName(String libraryName) {\n        return operatingSystem.getSharedLibraryName(libraryName);\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public String getExecutableName(String executablePath) {\n        return OperatingSystem.current().getExecutableName(executablePath);\n    }","id":22654,"modified_method":"public String getExecutableName(String executablePath) {\n        return operatingSystem.getExecutableName(executablePath);\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public ToolChainAvailability getAvailability() {\n        if (availability == null) {\n            availability = new ToolChainAvailability();\n            checkAvailable(availability);\n        }\n        return availability;\n    }","id":22655,"modified_method":"protected AbstractToolChain(OperatingSystem operatingSystem) {\n        this.operatingSystem = operatingSystem;\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public String getStaticLibraryName(String libraryName) {\n        return OperatingSystem.current().getStaticLibraryName(libraryName);\n    }","id":22656,"modified_method":"public String getStaticLibraryName(String libraryName) {\n        return operatingSystem.getStaticLibraryName(libraryName);\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<File> getFiles() {\n            return Collections.singleton(getOutputFile());\n        }","id":22657,"modified_method":"public Set<File> getFiles() {\n            return Collections.singleton(outputFile);\n        }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskDependency getBuildDependencies() {\n            return DefaultSharedLibraryBinary.this.getBuildDependencies();\n        }","id":22658,"modified_method":"private RuntimeFiles(File outputFile) {\n            this.outputFile = outputFile;\n        }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public NativeDependencySet getAsNativeDependencySet() {\n        return new NativeDependencySet() {\n            public FileCollection getIncludeRoots() {\n                return library.getHeaders();\n            }\n\n            public FileCollection getLinkFiles() {\n                return new FileCollectionAdapter(new RuntimeFiles());\n            }\n\n            public FileCollection getRuntimeFiles() {\n                return getLinkFiles();\n            }\n        };\n    }","id":22659,"modified_method":"public NativeDependencySet getAsNativeDependencySet() {\n        return new NativeDependencySet() {\n            public FileCollection getIncludeRoots() {\n                return library.getHeaders();\n            }\n\n            public FileCollection getLinkFiles() {\n                return new FileCollectionAdapter(new RuntimeFiles(getLinkFile()));\n            }\n\n            public FileCollection getRuntimeFiles() {\n                return new FileCollectionAdapter(new RuntimeFiles(getOutputFile()));\n            }\n        };\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public UnavailableToolChain(List<String> messages) {\n            this.messages = messages;\n        }","id":22660,"modified_method":"public UnavailableToolChain(List<String> messages) {\n            super(OperatingSystem.current());\n            this.messages = messages;\n        }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public GppToolChain(OperatingSystem operatingSystem, Factory<ExecAction> execActionFactory) {\n        this(findExecutable(operatingSystem), operatingSystem.findInPath(AR), execActionFactory, new GppVersionDeterminer());\n    }","id":22661,"modified_method":"public GppToolChain(OperatingSystem operatingSystem, Factory<ExecAction> execActionFactory) {\n        super(operatingSystem);\n        gppExecutable = findExecutable(operatingSystem);\n        arExecutable = operatingSystem.findInPath(AR);\n        this.execActionFactory = execActionFactory;\n        this.versionDeterminer = new GppVersionDeterminer();\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public void collectArguments(LinkerSpec spec, ArgCollector collector) {\n            collector.args(spec.getArgs());\n            collector.args(\"/OUT:\" + spec.getOutputFile().getAbsolutePath());\n            collector.args(\"/NOLOGO\");\n            if (spec instanceof SharedLibraryLinkerSpec) {\n                collector.args(\"/DLL\");\n            }\n            for (File file : spec.getSource()) {\n                collector.args(file.getAbsolutePath());\n            }\n            // TODO:DAZ There must be a better place for this\n            for (File file : spec.getLibs()) {\n                collector.args(file.getAbsolutePath().replaceFirst(\"\\\\.dll$\", \".lib\"));\n            }\n        }","id":22662,"modified_method":"public void collectArguments(LinkerSpec spec, ArgCollector collector) {\n            collector.args(spec.getArgs());\n            collector.args(\"/OUT:\" + spec.getOutputFile().getAbsolutePath());\n            collector.args(\"/NOLOGO\");\n            if (spec instanceof SharedLibraryLinkerSpec) {\n                collector.args(\"/DLL\");\n            }\n            for (File file : spec.getSource()) {\n                collector.args(file.getAbsolutePath());\n            }\n            for (File file : spec.getLibs()) {\n                collector.args(file.getAbsolutePath());\n            }\n        }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"public VisualCppToolChain(OperatingSystem operatingSystem, Factory<ExecAction> execActionFactory) {\n        this(operatingSystem.findInPath(COMPILER_EXE), operatingSystem.findInPath(LINKER_EXE), operatingSystem.findInPath(STATIC_LINKER_EXE), execActionFactory);\n    }","id":22663,"modified_method":"public VisualCppToolChain(OperatingSystem operatingSystem, Factory<ExecAction> execActionFactory) {\n        super(operatingSystem);\n        this.compilerExe = operatingSystem.findInPath(COMPILER_EXE);\n        this.linkerExe = operatingSystem.findInPath(LINKER_EXE);\n        this.staticLinkerExe = operatingSystem.findInPath(STATIC_LINKER_EXE);\n        this.execActionFactory = execActionFactory;\n    }","commit_id":"0c9705cd728971a553134b868ea2bb39a9304e74","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n\tpublic void validateCloudConfiguration(final ValidationContext validationContext)\n\t\t\tthrows CloudProvisioningException {\n\n\t\tString cloudFolder = CLOUDS_FOLDER_PATH + FILE_SEPARATOR + cloud.getName();\n\t\tString groovyFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.groovy\";\n\t\tString propertiesFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.properties\";\n\n\t\tvalidationContext.validationEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\tgetFormattedMessage(\"validating_all_templates\"));\n\n\t\tfinal Map<String, ComputeTemplate> templates = cloud.getCloudCompute().getTemplates();\n\n\t\tfinal String mangementTemplateName = cloud.getConfiguration().getManagementMachineTemplate();\n\t\tfinal ComputeTemplate managementComputeTemplate =\n\t\t\t\tcloud.getCloudCompute().getTemplates().get(mangementTemplateName);\n\n\t\t// validating openstack endpoint\n\t\tthis.validateOpenstackEndpoint(validationContext, managementComputeTemplate);\n\n\t\t// validating management network/subnets configuration\n\t\tfinal CloudNetwork cloudNetwork = configuration.getCloud().getCloudNetwork();\n\t\tthis.validateManagementNetwork(validationContext, managementComputeTemplate, cloudNetwork);\n\n\t\t// validating templates networks configuration\n\t\tif (cloudNetwork != null) {\n\t\t\tthis.validateTemplateNetworks(validationContext, cloudNetwork);\n\t\t}\n\n\t\t// validating templates\n\t\tthis.validateComputeTemplates(validationContext, groovyFile, propertiesFile, templates);\n\n\t}","id":22664,"modified_method":"@Override\n\tpublic void validateCloudConfiguration(final ValidationContext validationContext)\n\t\t\tthrows CloudProvisioningException {\n\n\t\tString cloudFolder = CLOUDS_FOLDER_PATH + FILE_SEPARATOR + cloud.getName();\n\t\tString groovyFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.groovy\";\n\t\tString propertiesFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.properties\";\n\n\t\tvalidationContext.validationEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\tgetFormattedMessage(\"validating_all_templates\"));\n\n\t\tfinal Map<String, ComputeTemplate> templates = cloud.getCloudCompute().getTemplates();\n\n\t\tfinal String mangementTemplateName = cloud.getConfiguration().getManagementMachineTemplate();\n\t\tfinal ComputeTemplate managementComputeTemplate =\n\t\t\t\tcloud.getCloudCompute().getTemplates().get(mangementTemplateName);\n\n\t\t// validating openstack endpoint\n\t\tthis.validateOpenstackEndpoint(validationContext, managementComputeTemplate);\n\n\t\t// validating credentials\n\t\tvalidateCredentials(validationContext);\n\n\t\t// validating management network/subnets configuration\n\t\tfinal CloudNetwork cloudNetwork = configuration.getCloud().getCloudNetwork();\n\t\tthis.validateManagementNetwork(validationContext, managementComputeTemplate, cloudNetwork);\n\n\t\t// validating templates networks configuration\n\t\tif (cloudNetwork != null) {\n\t\t\tthis.validateTemplateNetworks(validationContext, cloudNetwork, templates.values());\n\t\t}\n\n\t\t// validating templates\n\t\tthis.validateComputeTemplates(validationContext, groovyFile, propertiesFile, templates);\n\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateComputeTemplates(final ValidationContext validationContext,\n\t\t\tfinal String groovyFile,\n\t\t\tfinal String propertiesFile,\n\t\t\tfinal Map<String, ComputeTemplate> templates)\n\t\t\tthrows CloudProvisioningException {\n\t\tString templateName;\n\t\tfor (Entry<String, ComputeTemplate> entry : templates.entrySet()) {\n\t\t\tfinal ComputeTemplate computeTemplate = entry.getValue();\n\t\t\ttemplateName = entry.getKey();\n\n\t\t\tvalidationContext.validationEvent(ValidationMessageType.GROUP_VALIDATION_MESSAGE,\n\t\t\t\t\tgetFormattedMessage(\"validating_template\", templateName));\n\n\t\t\tthis.validateImageHardwareLocation(validationContext, groovyFile, propertiesFile, computeTemplate);\n\n\t\t\t// validating static securityGroupNames\n\t\t\tthis.validateStaticSecgroups(validationContext, groovyFile, propertiesFile, computeTemplate);\n\n\t\t\t// validating static network\n\t\t\tthis.validateStaticNetworks(validationContext, groovyFile, propertiesFile, computeTemplate);\n\t\t}\n\t}","id":22665,"modified_method":"private void validateComputeTemplates(final ValidationContext validationContext,\n\t\t\tfinal String groovyFile,\n\t\t\tfinal String propertiesFile,\n\t\t\tfinal Map<String, ComputeTemplate> templates)\n\t\t\tthrows CloudProvisioningException {\n\t\tString templateName;\n\t\tfor (Entry<String, ComputeTemplate> entry : templates.entrySet()) {\n\t\t\tfinal ComputeTemplate computeTemplate = entry.getValue();\n\t\t\ttemplateName = entry.getKey();\n\n\t\t\tvalidationContext.validationEvent(ValidationMessageType.GROUP_VALIDATION_MESSAGE,\n\t\t\t\t\tgetFormattedMessage(\"validating_template\", templateName));\n\n\t\t\tfinal String imageLocation = computeTemplate.getImageId();\n\t\t\tif (!imageLocation.contains(\"/\")) {\n\t\t\t\tthrow new CloudProvisioningException(\"'imageId' should be formatted as region/imageId.\"\n\t\t\t\t\t\t+ \" Verify the cloud template : \" + templateName);\n\t\t\t}\n\t\t\tfinal String hardwareLocation = computeTemplate.getHardwareId();\n\t\t\tif (!hardwareLocation.contains(\"/\")) {\n\t\t\t\tthrow new CloudProvisioningException(\"'hardwareId' should be formatted as region/flavorId.\"\n\t\t\t\t\t\t+ \" Verify the cloud template : \" + templateName);\n\t\t\t}\n\n\t\t\tthis.validateImageHardwareLocation(validationContext, groovyFile, propertiesFile, computeTemplate);\n\n\t\t\t// validating static securityGroupNames\n\t\t\tthis.validateStaticSecgroups(validationContext, groovyFile, propertiesFile, computeTemplate);\n\n\t\t\t// validating static network\n\t\t\tthis.validateStaticNetworks(validationContext, groovyFile, propertiesFile, computeTemplate);\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateTemplateNetworks(final ValidationContext validationContext, final CloudNetwork cloudNetwork)\n\t\t\tthrows CloudProvisioningException {\n\t\tMap<String, NetworkConfiguration> templateNetworkConfigurations = cloudNetwork.getTemplates();\n\t\tif (templateNetworkConfigurations != null) {\n\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.ENTRY_VALIDATION_MESSAGE,\n\t\t\t\t\t\"Validating templates network configuration\");\n\n\t\t\tfor (Entry<String, NetworkConfiguration> networkConfigurationEntry : templateNetworkConfigurations\n\t\t\t\t\t.entrySet()) {\n\n\t\t\t\tif (!networkHelper.isValidNetworkName(networkConfigurationEntry.getValue())) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tthrow new CloudProvisioningException(String.format(\n\t\t\t\t\t\t\t\"The name of template network configuration is missing. \"\n\t\t\t\t\t\t\t\t\t+ \"Please check template network in '%s'\",\n\t\t\t\t\t\t\tnetworkConfigurationEntry.getKey()));\n\t\t\t\t}\n\n\t\t\t\tList<org.cloudifysource.domain.cloud.network.Subnet> templateNetworkSubnets =\n\t\t\t\t\t\tnetworkConfigurationEntry.getValue().getSubnets();\n\n\t\t\t\tif (templateNetworkSubnets == null || templateNetworkSubnets.isEmpty()) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\"Subnets list is empty. At least one subnet is required. \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"Please check template network configuration in '%s'.\",\n\t\t\t\t\t\t\t\t\tnetworkConfigurationEntry.getValue().getName()));\n\t\t\t\t}\n\n\t\t\t\tfor (org.cloudifysource.domain.cloud.network.Subnet mSub : templateNetworkSubnets) {\n\n\t\t\t\t\tif (!networkHelper.isValidSubnetName(mSub)) {\n\t\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\"The name of the subnet is missing.\"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" Please check subnet name in template network \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"configuration '%s' \",\n\t\t\t\t\t\t\t\t\t\tnetworkConfigurationEntry.getValue().getName()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mSub.getRange() == null || StringUtils.trim(mSub.getRange()).isEmpty()) {\n\t\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\"The range is missing in subnet '%s'. \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"Please check subnet range in template network \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"configuration '%s' \",\n\t\t\t\t\t\t\t\t\t\tmSub.getName(), networkConfigurationEntry.getKey()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// template networks subnets are OK\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t}\n\t}","id":22666,"modified_method":"private void validateTemplateNetworks(final ValidationContext validationContext, final CloudNetwork cloudNetwork,\n\t\t\tfinal Collection<ComputeTemplate> templates)\n\t\t\tthrows CloudProvisioningException {\n\n\t\t// boolean networkInCloud = false;\n\t\tMap<String, NetworkConfiguration> templateNetworkConfigurations = cloudNetwork.getTemplates();\n\t\tif (templateNetworkConfigurations != null && !templateNetworkConfigurations.isEmpty()) {\n\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.ENTRY_VALIDATION_MESSAGE,\n\t\t\t\t\t\"Validating templates network configuration\");\n\n\t\t\tfor (Entry<String, NetworkConfiguration> networkConfigurationEntry : templateNetworkConfigurations\n\t\t\t\t\t.entrySet()) {\n\n\t\t\t\tif (!networkHelper.isValidNetworkName(networkConfigurationEntry.getValue())) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tthrow new CloudProvisioningException(String.format(\n\t\t\t\t\t\t\t\"The name of template network configuration is missing. \"\n\t\t\t\t\t\t\t\t\t+ \"Please check template network in '%s'\",\n\t\t\t\t\t\t\tnetworkConfigurationEntry.getKey()));\n\t\t\t\t}\n\n\t\t\t\tList<org.cloudifysource.domain.cloud.network.Subnet> templateNetworkSubnets =\n\t\t\t\t\t\tnetworkConfigurationEntry.getValue().getSubnets();\n\n\t\t\t\tif (templateNetworkSubnets == null || templateNetworkSubnets.isEmpty()) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\"Subnets list is empty. At least one subnet is required. \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"Please check template network configuration in '%s'.\",\n\t\t\t\t\t\t\t\t\tnetworkConfigurationEntry.getValue().getName()));\n\t\t\t\t}\n\n\t\t\t\tfor (org.cloudifysource.domain.cloud.network.Subnet mSub : templateNetworkSubnets) {\n\n\t\t\t\t\tif (!networkHelper.isValidSubnetName(mSub)) {\n\t\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\"The name of the subnet is missing.\"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" Please check subnet name in template network \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"configuration '%s' \",\n\t\t\t\t\t\t\t\t\t\tnetworkConfigurationEntry.getValue().getName()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mSub.getRange() == null || StringUtils.trim(mSub.getRange()).isEmpty()) {\n\t\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\t\t\t\"The range is missing in subnet '%s'. \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"Please check subnet range in template network \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"configuration '%s' \",\n\t\t\t\t\t\t\t\t\t\tmSub.getName(), networkConfigurationEntry.getKey()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tManagementNetwork managementNetwork = cloud.getCloudNetwork().getManagement();\n\n\t\tif (managementNetwork.getNetworkConfiguration() != null\n\t\t\t\t&& managementNetwork.getNetworkConfiguration().getName() == null\n\t\t\t\t&& managementNetwork.getNetworkConfiguration().getSubnets() != null\n\t\t\t\t&& managementNetwork.getNetworkConfiguration().getSubnets().isEmpty()) {\n\n\t\t\tboolean isNetworkInTemplates = true;\n\t\t\tfor (ComputeTemplate template : templates) {\n\t\t\t\tif (template.getComputeNetwork() != null) {\n\t\t\t\t\tList<String> networks = template.getComputeNetwork().getNetworks();\n\t\t\t\t\tif (networks == null || networks.isEmpty()) {\n\t\t\t\t\t\tisNetworkInTemplates = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isNetworkInTemplates) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\"A network must be provided for all templates,\"\n\t\t\t\t\t\t\t\t+ \" since management network is missing.\");\n\n\t\t\t}\n\t\t}\n\n\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateImageHardwareLocation(final ValidationContext validationContext, final String groovyFile,\n\t\t\tfinal String propertiesFile, final ComputeTemplate computeTemplate) throws CloudProvisioningException {\n\n\t\tfinal String imageLocation = computeTemplate.getImageId();\n\t\tif (!imageLocation.contains(\"/\")) {\n\t\t\tthrow new CloudProvisioningException(\"'imageId' should be formatted as region/imageId\");\n\t\t}\n\t\tfinal String hardwareLocation = computeTemplate.getHardwareId();\n\t\tif (!hardwareLocation.contains(\"/\")) {\n\t\t\tthrow new CloudProvisioningException(\"'hardwareId' should be formatted as region/flavorId\");\n\t\t}\n\n\t\tfinal String imageId = imageLocation.split(\"/\")[1];\n\t\tfinal String hardwareId = hardwareLocation.split(\"/\")[1];\n\t\tfinal String locationId = imageLocation.split(\"/\")[0];\n\n\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.ENTRY_VALIDATION_MESSAGE,\n\t\t\t\tgetFormattedMessage(\"validating_image_hardware_location_combination\",\n\t\t\t\t\t\timageId == null ? \"\" : imageId, hardwareId == null ? \"\" : hardwareId,\n\t\t\t\t\t\tlocationId == null ? \"\" : locationId));\n\t\t// validating imageIds\n\t\ttry {\n\t\t\tif (imageId != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcomputeApi.getImage(imageId);\n\t\t\t\t} catch (final OpenstackException e) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tfinal String availableResources = this.formatResourceList(computeApi.getImages());\n\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\tgetFormattedMessage(\"error_image_id_validation\",\n\t\t\t\t\t\t\t\t\timageId == null ? \"\" : imageId, availableResources));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// validating hardwareId\n\t\t\tif (hardwareId != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcomputeApi.getFlavor(hardwareId);\n\t\t\t\t} catch (final OpenstackException e) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tfinal String availableResources = this.formatResourceList(computeApi.getFlavors());\n\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\tgetFormattedMessage(\"error_hardware_id_validation\",\n\t\t\t\t\t\t\t\t\thardwareId == null ? \"\" : hardwareId, availableResources));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (final OpenstackException ex) {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\tgetFormattedMessage(\"error_image_hardware_location_combination_validation\",\n\t\t\t\t\t\t\timageId == null ? \"\" : imageId,\n\t\t\t\t\t\t\thardwareId == null ? \"\" : hardwareId, locationId == null ? \"\" : locationId,\n\t\t\t\t\t\t\tgroovyFile, propertiesFile), ex);\n\t\t}\n\n\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t}","id":22667,"modified_method":"private void validateImageHardwareLocation(final ValidationContext validationContext, final String groovyFile,\n\t\t\tfinal String propertiesFile, final ComputeTemplate computeTemplate) throws CloudProvisioningException {\n\n\t\tfinal String imageId = computeTemplate.getImageId().split(\"/\")[1];\n\t\tfinal String hardwareId = computeTemplate.getHardwareId().split(\"/\")[1];\n\t\tfinal String locationId = computeTemplate.getImageId().split(\"/\")[0];\n\n\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.ENTRY_VALIDATION_MESSAGE,\n\t\t\t\tgetFormattedMessage(\"validating_image_hardware_location_combination\",\n\t\t\t\t\t\timageId == null ? \"\" : imageId, hardwareId == null ? \"\" : hardwareId,\n\t\t\t\t\t\tlocationId == null ? \"\" : locationId));\n\t\t// validating imageIds\n\t\ttry {\n\t\t\tif (imageId != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcomputeApi.getImage(imageId);\n\t\t\t\t} catch (final OpenstackException e) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tfinal String availableResources = this.formatResourceList(computeApi.getImages());\n\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\tgetFormattedMessage(\"error_image_id_validation\",\n\t\t\t\t\t\t\t\t\timageId == null ? \"\" : imageId, availableResources));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// validating hardwareId\n\t\t\tif (hardwareId != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcomputeApi.getFlavor(hardwareId);\n\t\t\t\t} catch (final OpenstackException e) {\n\t\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\t\tfinal String availableResources = this.formatResourceList(computeApi.getFlavors());\n\t\t\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\t\tgetFormattedMessage(\"error_hardware_id_validation\",\n\t\t\t\t\t\t\t\t\thardwareId == null ? \"\" : hardwareId, availableResources));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (final OpenstackException ex) {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\tgetFormattedMessage(\"error_image_hardware_location_combination_validation\",\n\t\t\t\t\t\t\timageId == null ? \"\" : imageId,\n\t\t\t\t\t\t\thardwareId == null ? \"\" : hardwareId, locationId == null ? \"\" : locationId,\n\t\t\t\t\t\t\tgroovyFile, propertiesFile), ex);\n\t\t}\n\n\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateOpenstackEndpoint(final ValidationContext validationContext,\n\t\t\tfinal ComputeTemplate managementComputeTemplate) throws CloudProvisioningException {\n\n\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.ENTRY_VALIDATION_MESSAGE,\n\t\t\t\t\"Validating openstack endpoint property\");\n\n\t\tif (managementComputeTemplate.getOverrides() != null\n\t\t\t\t&& !managementComputeTemplate.getOverrides().isEmpty()) {\n\n\t\t\tString openstackProperty =\n\t\t\t\t\t(String) managementComputeTemplate.getOverrides().get(OPENSTACK_ENDPOINT);\n\n\t\t\tif (openstackProperty == null || openstackProperty.trim().isEmpty()) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tthrow new CloudProvisioningException((String.format(\n\t\t\t\t\t\t\"The openstack endpoint option '%s' is missing. \"\n\t\t\t\t\t\t\t\t+ \"Please check overrides block in management template '%s'. \",\n\t\t\t\t\t\tOPENSTACK_ENDPOINT, cloud.getConfiguration().getManagementMachineTemplate())));\n\t\t\t}\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t} else {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tthrow new CloudProvisioningException(String.format(\n\t\t\t\t\t\"The openstack endpoint option '%s' is missing. \"\n\t\t\t\t\t\t\t+ \"Please check overrides block in management template \",\n\t\t\t\t\tOPENSTACK_ENDPOINT));\n\t\t}\n\t}","id":22668,"modified_method":"private void validateOpenstackEndpoint(final ValidationContext validationContext,\n\t\t\tfinal ComputeTemplate managementComputeTemplate) throws CloudProvisioningException {\n\n\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.ENTRY_VALIDATION_MESSAGE,\n\t\t\t\t\"Validating openstack endpoint property\");\n\n\t\tif (managementComputeTemplate.getOverrides() != null\n\t\t\t\t&& !managementComputeTemplate.getOverrides().isEmpty()) {\n\n\t\t\tString openstackProperty =\n\t\t\t\t\t(String) managementComputeTemplate.getOverrides().get(OPENSTACK_ENDPOINT);\n\n\t\t\tif (openstackProperty == null || openstackProperty.trim().isEmpty()) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tthrow new CloudProvisioningException((String.format(\n\t\t\t\t\t\t\"The openstack endpoint '%s' is missing. \"\n\t\t\t\t\t\t\t\t+ \"Please check overrides block in management template '%s'. \",\n\t\t\t\t\t\tOPENSTACK_ENDPOINT, cloud.getConfiguration().getManagementMachineTemplate())));\n\t\t\t}\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t} else {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tthrow new CloudProvisioningException(String.format(\n\t\t\t\t\t\"The openstack endpoint option '%s' is missing. \"\n\t\t\t\t\t\t\t+ \"Please check overrides block in management template \",\n\t\t\t\t\tOPENSTACK_ENDPOINT));\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void wrongCredentials() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22669,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void wrongCredentials() throws Exception {\n\n\t\ttry {\n\t\t\tMockito.when(this.computeApi.getServers()).thenThrow(new OpenstackServerException(200, 401, null));\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"wrongCredentials\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"Authentification operation failed. Please check credentials informations\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingStaticSecurityGroup() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22670,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void missingStaticSecurityGroup() throws Exception {\n\n\t\ttry {\n\t\t\tMockito.when(networkApi.getSecurityGroups()).thenThrow(new OpenstackException());\n\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"wrongSecurityGroops\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"Error requesting security groups\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingNetworksForApplications() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22671,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void missingNetworksForApplications() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingNetworksForApplications\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"A network must be provided for all templates\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void wrongHardwareIdResource() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22672,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void wrongHardwareIdResource() throws Exception {\n\n\t\ttry {\n\t\t\tMockito.reset(this.computeApi);\n\t\t\tMockito.when(this.computeApi.getFlavor(Mockito.anyString())).thenThrow(new OpenstackException());\n\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"ok\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\n\t\t} catch (CloudProvisioningException e) {\n\t\t\tif (!e.getMessage().contains(\"Hardware ID \\\"hardwareId\\\" is invalid\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void wrongImageIdResource() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22673,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void wrongImageIdResource() throws Exception {\n\n\t\ttry {\n\t\t\tMockito.reset(this.computeApi);\n\t\t\tMockito.when(this.computeApi.getImage(Mockito.anyString())).thenThrow(new OpenstackException());\n\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"ok\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\n\t\t} catch (CloudProvisioningException e) {\n\t\t\tif (!e.getMessage().contains(\"Image ID \\\"imageId\\\" is invalid\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingManagementSubnetRange() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22674,"modified_method":"@Test\n\tpublic void missingManagementSubnetRange() throws Exception {\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingManagementSubnetRange\", false);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"The range is missing in subnet\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingNetworksForManagements() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\n\t}","id":22675,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void missingNetworksForManagements() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingNetworksForManagements\", false);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"has no networks for cloudify communications\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingOpenstackEndpoint() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22676,"modified_method":"@Test\n\tpublic void missingOpenstackEndpoint() throws Exception {\n\t\tString openstackEndPoint = \"openstack.endpoint\";\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingOpenstackEndpoint\", false);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(String.format(\"The openstack endpoint '%s' is missing\", openstackEndPoint))) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingApplicationSubnetRange() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22677,"modified_method":"@Test\n\tpublic void missingApplicationSubnetRange() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingApplicationSubnetRange\", false);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"The range is missing in subnet\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void wrongHardwareIdFormat() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22678,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void wrongHardwareIdFormat() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"wrongFormatHardwareId\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\n\t\t} catch (CloudProvisioningException e) {\n\t\t\tif (!e.getMessage().contains(\"'hardwareId' should be formatted as region/flavorId\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void wrongImageIdFormat() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22679,"modified_method":"@Test(expected = CloudProvisioningException.class)\n\tpublic void wrongImageIdFormat() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"wrongFormatImageId\", true);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\n\t\t} catch (CloudProvisioningException e) {\n\t\t\tif (!e.getMessage().contains(\"'imageId' should be formatted as region/imageId\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingManagementNetworkName() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\n\t}","id":22680,"modified_method":"@Test\n\tpublic void missingManagementNetworkName() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingManagementNetworkName\", false);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\n\t\t\t\t\t\"The name of Management network is missing. Please check management network configuration\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void missingManagementSubnetName() throws Exception {\n\t\tAssert.fail(\"To be implemented\");\n\t}","id":22681,"modified_method":"@Test\n\tpublic void missingManagementSubnetName() throws Exception {\n\n\t\ttry {\n\t\t\tOpenStackCloudifyDriver newDriverInstance = this.newDriverInstance(\"missingManagementSubnetName\", false);\n\t\t\tnewDriverInstance.validateCloudConfiguration(new ValidationContextStub());\n\t\t} catch (Exception e) {\n\t\t\tif (!e.getMessage().contains(\"The Name of subnet is missing\")) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail(\"Validation must fail: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"367c1f0c0ed67ded16df90578f25b6d1ce405da1","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void validateCloudConfiguration(final ValidationContext validationContext)\n\t\t\tthrows CloudProvisioningException {\n\n\t\tString cloudFolder = CLOUDS_FOLDER_PATH + FILE_SEPARATOR + cloud.getName();\n\t\tString groovyFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.groovy\";\n\t\tString propertiesFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.properties\";\n\n\t\tvalidationContext.validationEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\tgetFormattedMessage(\"validating_all_templates\"));\n\n\t\tfinal Map<String, ComputeTemplate> templates = cloud.getCloudCompute().getTemplates();\n\n\t\tfinal String mangementTemplateName = cloud.getConfiguration().getManagementMachineTemplate();\n\t\tfinal ComputeTemplate managementComputeTemplate =\n\t\t\t\tcloud.getCloudCompute().getTemplates().get(mangementTemplateName);\n\n\t\t// validating openstack endpoint\n\t\tthis.validateOpenstackEndpoint(validationContext, managementComputeTemplate);\n\n\t\t// validating credentials\n\t\tvalidateCredentials(validationContext);\n\t\t\n\t\t// validate network quotas\n\t\tvalidateNetworkQuotas(validationContext);\n\t\t\n\t\t// validate compute quotas\n\t\tvalidateComputeQuotas(validationContext, managementComputeTemplate);\n\n\t\t// validating management network/subnets configuration\n\t\tfinal CloudNetwork cloudNetwork = configuration.getCloud().getCloudNetwork();\n\t\tthis.validateManagementNetwork(validationContext, managementComputeTemplate, cloudNetwork);\n\n\t\t// validating templates networks configuration\n\t\tif (cloudNetwork != null) {\n\t\t\tthis.validateTemplateNetworks(validationContext, cloudNetwork, templates.values());\n\t\t}\n\n\t\t// validating templates\n\t\tthis.validateComputeTemplates(validationContext, groovyFile, propertiesFile, templates);\n\n\t}","id":22682,"modified_method":"@Override\n\tpublic void validateCloudConfiguration(final ValidationContext validationContext)\n\t\t\tthrows CloudProvisioningException {\n\n\t\tString cloudFolder = CLOUDS_FOLDER_PATH + FILE_SEPARATOR + cloud.getName();\n\t\tString groovyFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.groovy\";\n\t\tString propertiesFile = cloudFolder + FILE_SEPARATOR + cloud.getName() + \"-cloud.properties\";\n\n\t\tvalidationContext.validationEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\tgetFormattedMessage(\"validating_all_templates\"));\n\n\t\tfinal Map<String, ComputeTemplate> templates = cloud.getCloudCompute().getTemplates();\n\n\t\tfinal String mangementTemplateName = cloud.getConfiguration().getManagementMachineTemplate();\n\t\tfinal ComputeTemplate managementComputeTemplate =\n\t\t\t\tcloud.getCloudCompute().getTemplates().get(mangementTemplateName);\n\n\t\t// validating openstack endpoint\n\t\tthis.validateOpenstackEndpoint(validationContext, managementComputeTemplate);\n\n\t\t// validating credentials\n\t\tvalidateCredentials(validationContext);\n\t\t\n\t\t// validate compute quotas\n\t\tvalidateComputeQuotas(validationContext, managementComputeTemplate);\n\t\t\n\t\t// validate network quotas\n\t\tvalidateNetworkQuotas(validationContext);\n\n\t\t// validating management network/subnets configuration\n\t\tfinal CloudNetwork cloudNetwork = configuration.getCloud().getCloudNetwork();\n\t\tthis.validateManagementNetwork(validationContext, managementComputeTemplate, cloudNetwork);\n\n\t\t// validating templates networks configuration\n\t\tif (cloudNetwork != null) {\n\t\t\tthis.validateTemplateNetworks(validationContext, cloudNetwork, templates.values());\n\t\t}\n\n\t\t// validating templates\n\t\tthis.validateComputeTemplates(validationContext, groovyFile, propertiesFile, templates);\n\n\t}","commit_id":"0f6f7393852470bd36f1ded300f82195e43c1234","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateComputeQuotas(\n\t\t\tfinal ValidationContext validationContext,\n\t\t\tfinal ComputeTemplate managementComputeTemplate)\n\t\t\tthrows CloudProvisioningException {\n\t\ttry {\n\t\t\tfinal ComputeLimits limits = this.computeApi.getLimits();\n\t\t\tif (limits == null) {\n\t\t\t\tthrow new OpenstackException(\n\t\t\t\t\t\t\"Failed getting cloud compute quotas.\");\n\t\t\t}\n\t\t} catch (final OpenstackException e) {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Failed validating cloud compute resources. Reason: \"\n\t\t\t\t\t\t\t+ e.getMessage(), e);\n\t\t}\n\n\t}","id":22683,"modified_method":"private void validateComputeQuotas(\n\t\t\tfinal ValidationContext validationContext,\n\t\t\tfinal ComputeTemplate managementComputeTemplate)\n\t\t\tthrows CloudProvisioningException {\n\t\ttry {\n\t\t\t\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.GROUP_VALIDATION_MESSAGE, \n\t\t\t\t\t\"Validating compute quotas\");\n\t\t\t\n\t\t\tfinal ComputeLimits limits = this.computeApi.getLimits();\n\t\t\tif (limits == null) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tlogger.warning(\"Failed to retrieve compute limits, skipping compute quotas validation\");\n\t\t\t\treturn;\n\t\t\t\t// TODO: where is the actual call to the validations?\n\t\t\t\t// TODO noak: fail the bootstrap on this?\n\t\t\t\t// throw new OpenstackException(\"Failed getting cloud compute quotas.\");\n\t\t\t}\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t} catch (final OpenstackException e) {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t// TODO noak: fail the bootstrap on this?\n\t\t\tthrow new CloudProvisioningException(\"Failed validating cloud compute resources. Reason: \"\n\t\t\t\t\t+ e.getMessage(), e);\n\t\t}\n\n\t}","commit_id":"0f6f7393852470bd36f1ded300f82195e43c1234","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateNetworkQuotas(final ValidationContext validationContext) throws CloudProvisioningException {\n\t\ttry {\n\t\t\tfinal String tenantId = computeApi.getTenantId();\n\t\t\tfinal Quota quotas = this.networkApi.getQuotasForTenant(tenantId);\n\t\t\tif (quotas == null) {\n\t\t\t\tthrow new OpenstackException(\"Failed getting network quotas.\");\n\t\t\t}\n\t\t\t\n\t\t\tvalidateSecurityGroupsQuota(validationContext, quotas.getSecurityGroup(), tenantId);\n\t\t\tvalidateSecurityGroupRulesQuota(validationContext, quotas.getSecurityGroupRule(), tenantId);\n\t\t\tvalidateRoutersQuota(validationContext, quotas.getRouter(), tenantId);\n\t\t\tvalidateNetworksQuota(validationContext, quotas.getNetwork(), tenantId);\n\t\t\tvalidateSubnetsQuota(validationContext, quotas.getSubnet(), tenantId);\n\t\t\tvalidateFloatingIpsQuota(validationContext, quotas.getFloatingip());\n\n\t\t} catch (final OpenstackException e) {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Failed validating cloud network resources. Reason: \"\n\t\t\t\t\t\t\t+ e.getMessage(), e);\n\t\t}\n\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\n\t}","id":22684,"modified_method":"private void validateNetworkQuotas(final ValidationContext validationContext) throws CloudProvisioningException {\n\t\ttry {\n\t\t\t// TODO noak use getFormattedMessage\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.GROUP_VALIDATION_MESSAGE, \n\t\t\t\t\t\"Validating network quotas\");\n\t\t\tfinal String tenantId = computeApi.getTenantId();\n\t\t\tif (StringUtils.isBlank(tenantId)) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tlogger.info(\"Failed to retrieve tenant id, skipping network quotas validation\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfinal Quota quotas = this.networkApi.getQuotasForTenant(tenantId);\n\t\t\tif (quotas == null) {\n\t\t\t\tthrow new OpenstackException(\"Failed getting network quotas.\");\n\t\t\t}\n\t\t\t\n\t\t\tvalidateSecurityGroupsQuota(validationContext, quotas.getSecurityGroup(), tenantId);\n\t\t\tvalidateSecurityGroupRulesQuota(validationContext, quotas.getSecurityGroupRule(), tenantId);\n\t\t\tvalidateRoutersQuota(validationContext, quotas.getRouter(), tenantId);\n\t\t\tvalidateNetworksQuota(validationContext, quotas.getNetwork(), tenantId);\n\t\t\tvalidateSubnetsQuota(validationContext, quotas.getSubnet(), tenantId);\n\t\t\tvalidateFloatingIpsQuota(validationContext, quotas.getFloatingip());\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t} catch (final OpenstackException e) {\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\tlogger.info(\"Failed to retrieve tenant id, skipping network quotas validation\");\n\t\t\t// TODO noak: should we throw an exception and fail bootstrap on this?\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Failed validating cloud network resources. Reason: \"\n\t\t\t\t\t\t\t+ e.getMessage(), e);\n\t\t}\n\n\t}","commit_id":"0f6f7393852470bd36f1ded300f82195e43c1234","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateUrl(final String cloudifyUrl, final ValidationContext validationContext) \n\t\t\tthrows CloudProvisioningException {\n\n\t\tDefaultHttpClient httpClient = new DefaultHttpClient();\n\t\t\n\t\tHttpHead httpMethod = new HttpHead(cloudifyUrl);\n\t\ttry {\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\t\tShellUtils.getFormattedMessage(CloudifyErrorMessages.EVENT_VALIDATING_CLOUDIFY_URL.getName(),\n\t\t\t\t\t\t\tcloudifyUrl));\n\t\t\tHttpResponse response = httpClient.execute(httpMethod);\n\t\t\tif (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tlogger.warning(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t\t\tthrow new CloudProvisioningException(\"Invalid cloudify URL: \" + cloudifyUrl);\n\t\t\t}\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t} catch (ClientProtocolException e) {\n\t\t\tSystem.out.println(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.WARNING);\n\t\t\tlogger.info(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.WARNING);\n\t\t\tlogger.info(\"Failed to validate Cloudify URL:  \" + cloudifyUrl);\n\t\t}\n\t}","id":22685,"modified_method":"private void validateUrl(final String cloudifyUrl, final ValidationContext validationContext) \n\t\t\tthrows CloudProvisioningException {\n\n\t\tDefaultHttpClient httpClient = new DefaultHttpClient();\n\t\t\n\t\tHttpHead httpMethod = new HttpHead(cloudifyUrl);\n\t\ttry {\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\t\tShellUtils.getFormattedMessage(CloudifyErrorMessages.EVENT_VALIDATING_CLOUDIFY_URL.getName(),\n\t\t\t\t\t\t\tcloudifyUrl));\n\t\t\tHttpResponse response = httpClient.execute(httpMethod);\n\t\t\tif (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n\t\t\t\tvalidationContext.validationEventEnd(ValidationResultType.ERROR);\n\t\t\t\tlogger.warning(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t\t\tthrow new CloudProvisioningException(\"Invalid cloudify URL: \" + cloudifyUrl);\n\t\t\t}\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.OK);\n\t\t} catch (ClientProtocolException e) {\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\t\t\" Unable to validate URL\");\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.WARNING);\n\t\t\tlogger.fine(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t} catch (IOException e) {\n\t\t\tvalidationContext.validationOngoingEvent(ValidationMessageType.TOP_LEVEL_VALIDATION_MESSAGE,\n\t\t\t\t\t\" Unable to validate URL\");\n\t\t\tvalidationContext.validationEventEnd(ValidationResultType.WARNING);\n\t\t\tlogger.fine(\"Failed to validate Cloudify URL: \" + cloudifyUrl);\n\t\t}\n\t}","commit_id":"6b99c12d7e73d4edb50a9e7ffd8ab7b022cf8f74","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"abstract void handle(Connection connection, Set<DatabaseCharsetChecker.Flag> flags) throws SQLException;","id":22686,"modified_method":"abstract void handle(Connection connection, DatabaseCharsetChecker.State state) throws SQLException;","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void start() {\n    check();\n  }","id":22687,"modified_method":"@Override\n  public void start() {\n    DatabaseCharsetChecker.State state = DatabaseCharsetChecker.State.STARTUP;\n    if (upgradeStatus.isUpgraded()) {\n      state = DatabaseCharsetChecker.State.UPGRADE;\n    } else if (upgradeStatus.isFreshInstall()) {\n      state = DatabaseCharsetChecker.State.FRESH_INSTALL;\n    }\n    charsetChecker.check(state);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void enforce_utf8_if_fresh_install() {\n    when(upgradeStatus.isFreshInstall()).thenReturn(true);\n\n    underTest.start();\n\n    verify(charsetChecker).check(ENFORCE_UTF8);\n  }","id":22688,"modified_method":"@Test\n  public void test_fresh_install() {\n    when(upgradeStatus.isFreshInstall()).thenReturn(true);\n\n    underTest.start();\n\n    verify(charsetChecker).check(DatabaseCharsetChecker.State.FRESH_INSTALL);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  @CheckForNull\n  CharsetHandler getHandler(Dialect dialect) {\n    switch (dialect.getId()) {\n      case H2.ID:\n        // nothing to check\n        return null;\n      case Oracle.ID:\n        return new OracleCharsetHandler(selectExecutor);\n      case PostgreSql.ID:\n        return new PostgresCharsetHandler(selectExecutor);\n      case MySql.ID:\n        return new MysqlCharsetHandler(selectExecutor);\n      case MsSql.ID:\n        return new MssqlCharsetHandler(selectExecutor);\n      default:\n        throw new IllegalArgumentException(\"Database not supported: \" + dialect.getId());\n    }\n  }","id":22689,"modified_method":"@VisibleForTesting\n  @CheckForNull\n  CharsetHandler getHandler(Dialect dialect) {\n    switch (dialect.getId()) {\n      case H2.ID:\n        // nothing to check\n        return null;\n      case Oracle.ID:\n        return new OracleCharsetHandler(sqlExecutor);\n      case PostgreSql.ID:\n        return new PostgresCharsetHandler(sqlExecutor, new PostgresMetadataReader(sqlExecutor));\n      case MySql.ID:\n        return new MysqlCharsetHandler(sqlExecutor);\n      case MsSql.ID:\n        return new MssqlCharsetHandler(sqlExecutor, new MssqlMetadataReader(sqlExecutor));\n      default:\n        throw new IllegalArgumentException(\"Database not supported: \" + dialect.getId());\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  DatabaseCharsetChecker(Database db, SqlExecutor selectExecutor) {\n    this.db = db;\n    this.selectExecutor = selectExecutor;\n  }","id":22690,"modified_method":"@VisibleForTesting\n  DatabaseCharsetChecker(Database db, SqlExecutor sqlExecutor) {\n    this.db = db;\n    this.sqlExecutor = sqlExecutor;\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void throws_ISE_if_handler_fails() throws Exception {\n    Oracle dialect = new Oracle();\n    when(underTest.getHandler(dialect)).thenReturn(handler);\n    when(db.getDialect()).thenReturn(dialect);\n    doThrow(new SQLException(\"failure\")).when(handler).handle(any(Connection.class), anySet());\n\n    expectedException.expect(IllegalStateException.class);\n    expectedException.expectMessage(\"failure\");\n    underTest.check(AUTO_REPAIR_COLLATION);\n  }","id":22691,"modified_method":"@Test\n  public void throws_ISE_if_handler_fails() throws Exception {\n    Oracle dialect = new Oracle();\n    when(underTest.getHandler(dialect)).thenReturn(handler);\n    when(db.getDialect()).thenReturn(dialect);\n    doThrow(new SQLException(\"failure\")).when(handler).handle(any(Connection.class), any(DatabaseCharsetChecker.State.class));\n\n    expectedException.expect(IllegalStateException.class);\n    expectedException.expectMessage(\"failure\");\n    underTest.check(DatabaseCharsetChecker.State.UPGRADE);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void executes_handler() throws Exception {\n    Oracle dialect = new Oracle();\n    when(underTest.getHandler(dialect)).thenReturn(handler);\n    when(db.getDialect()).thenReturn(dialect);\n\n    underTest.check(ENFORCE_UTF8);\n    verify(handler).handle(any(Connection.class), argThat(new TypeSafeMatcher<Set<DatabaseCharsetChecker.Flag>>() {\n      @Override\n      protected boolean matchesSafely(Set<DatabaseCharsetChecker.Flag> flags) {\n        return flags.contains(ENFORCE_UTF8) && flags.size() == 1;\n      }\n\n      @Override\n      public void describeTo(Description description) {\n      }\n    }));\n  }","id":22692,"modified_method":"@Test\n  public void executes_handler() throws Exception {\n    Oracle dialect = new Oracle();\n    when(underTest.getHandler(dialect)).thenReturn(handler);\n    when(db.getDialect()).thenReturn(dialect);\n\n    underTest.check(DatabaseCharsetChecker.State.UPGRADE);\n    verify(handler).handle(any(Connection.class), eq(DatabaseCharsetChecker.State.UPGRADE));\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  void handle(Connection connection, Set<DatabaseCharsetChecker.Flag> flags) throws SQLException {\n    logInit(flags);\n\n    // All VARCHAR columns are returned. No need to check database general collation.\n    // Example of row:\n    // issues | kee | Latin1_General_CS_AS or Latin1_General_100_CI_AS_KS_WS\n    Set<String> errors = new LinkedHashSet<>();\n    List<ColumnDef> columns = select(connection,\n      ColumnDef.SELECT_COLUMNS +\n        \"FROM [INFORMATION_SCHEMA].[COLUMNS] \" +\n        \"WHERE collation_name is not null \" +\n        \"ORDER BY table_name,column_name\",\n      ColumnDef.ColumnDefRowConverter.INSTANCE);\n    for (ColumnDef column : from(columns).filter(ColumnDef.IsInSonarQubeTablePredicate.INSTANCE)) {\n      if (!isCollationCorrect(column)) {\n        if (flags.contains(AUTO_REPAIR_COLLATION)) {\n          repairColumnCollation(connection, column);\n        } else {\n          errors.add(format(\"%s.%s\", column.getTable(), column.getColumn()));\n        }\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw MessageException.of(format(\"Case-sensitive and accent-sensitive collation is required for database columns [%s]\",\n        Joiner.on(\", \").join(errors)));\n    }\n  }","id":22693,"modified_method":"@Override\n  void handle(Connection connection, DatabaseCharsetChecker.State state) throws SQLException {\n    expectCaseSensitiveDefaultCollation(connection);\n    if (state == DatabaseCharsetChecker.State.UPGRADE || state == DatabaseCharsetChecker.State.STARTUP) {\n      repairColumns(connection);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void logInit(Set<DatabaseCharsetChecker.Flag> flags) {\n    if (flags.contains(AUTO_REPAIR_COLLATION)) {\n      LOGGER.info(\"Repair case-insensitive or accent-insensitive database columns\");\n    } else {\n      LOGGER.info(\"Verify that database columns are case-sensitive and accent-sensitive\");\n    }\n  }","id":22694,"modified_method":"/**\n   * Collation is correct if contains {@link #CASE_SENSITIVE_ACCENT_SENSITIVE} or {@link #BIN} or {@link #BIN2}.\n   */\n  private static boolean isCollationCorrect(String collation) {\n    return containsIgnoreCase(collation, CASE_SENSITIVE_ACCENT_SENSITIVE)\n      || containsIgnoreCase(collation, BIN)\n      || containsIgnoreCase(collation, BIN2);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void repairColumnCollation(Connection connection, ColumnDef column) throws SQLException {\n    // 1. select the indices defined on this column\n    String selectIndicesSql = format(\"SELECT I.name as index_name, I.is_unique as unik, IndexedColumns \" +\n      \"     FROM sys.indexes I \" +\n      \"     JOIN sys.tables T ON T.Object_id = I.Object_id \" +\n      \"     JOIN (SELECT * FROM ( \" +\n      \"     SELECT IC2.object_id, IC2.index_id, \" +\n      \"     STUFF((SELECT ' ,' + C.name \" +\n      \"     FROM sys.index_columns IC1 \" +\n      \"     JOIN sys.columns C \" +\n      \"     ON C.object_id = IC1.object_id \" +\n      \"     AND C.column_id = IC1.column_id \" +\n      \"     AND IC1.is_included_column = 0 \" +\n      \"     WHERE IC1.object_id = IC2.object_id \" +\n      \"     AND IC1.index_id = IC2.index_id \" +\n      \"     GROUP BY IC1.object_id,C.name,index_id \" +\n      \"     ORDER BY MAX(IC1.key_ordinal) \" +\n      \"     FOR XML PATH('')), 1, 2, '') IndexedColumns \" +\n      \"     FROM sys.index_columns IC2 \" +\n      \"     GROUP BY IC2.object_id ,IC2.index_id) tmp1 )tmp2 \" +\n      \"     ON I.object_id = tmp2.object_id AND I.Index_id = tmp2.index_id \" +\n      \"     WHERE I.is_primary_key = 0 AND I.is_unique_constraint = 0 \" +\n      \"     and T.name =('%s') \" +\n      \"     and CHARINDEX ('%s',IndexedColumns)>0\", column.getTable(), column.getColumn());\n    List<ColumnIndex> indices = getSqlExecutor().executeSelect(connection, selectIndicesSql, ColumnIndexConverter.INSTANCE);\n\n    // 2. drop indices\n    for (ColumnIndex index : indices) {\n      getSqlExecutor().executeUpdate(connection, format(\"DROP INDEX %s.%s\", column.getTable(), index.name));\n    }\n\n    // 3. alter collation of column\n    String csCollation = toCaseSensitive(column.getCollation());\n\n    String nullability = column.isNullable() ? \"NULL\" : \"NOT NULL\";\n    String size = column.getSize() >= 0 ? String.valueOf(column.getSize()) : \"max\";\n    String alterSql = format(\"ALTER TABLE %s ALTER COLUMN %s %s(%s) COLLATE %s %s\",\n      column.getTable(), column.getColumn(), column.getDataType(), size, csCollation, nullability);\n    LOGGER.info(\"Changing collation of column [{}.{}] from {} to {} | sql=\", column.getTable(), column.getColumn(), column.getCollation(), csCollation, alterSql);\n    getSqlExecutor().executeUpdate(connection, alterSql);\n\n    // 4. re-create indices\n    for (ColumnIndex index : indices) {\n      String uniqueSql = index.unique ? \"UNIQUE\" : \"\";\n      String createIndexSql = format(\"CREATE %s INDEX %s ON %s (%s)\", uniqueSql, index.name, column.getTable(), index.csvColumns);\n      getSqlExecutor().executeUpdate(connection, createIndexSql);\n    }\n  }","id":22695,"modified_method":"private void repairColumnCollation(Connection connection, ColumnDef column, String expectedCollation) throws SQLException {\n    // 1. select the indices defined on this column\n    List<ColumnIndex> indices = metadata.getColumnIndices(connection, column);\n\n    // 2. drop indices\n    for (ColumnIndex index : indices) {\n      getSqlExecutor().executeDdl(connection, format(\"DROP INDEX %s.%s\", column.getTable(), index.name));\n    }\n\n    // 3. alter collation of column\n    String nullability = column.isNullable() ? \"NULL\" : \"NOT NULL\";\n    String size = column.getSize() >= 0 ? String.valueOf(column.getSize()) : \"max\";\n    String alterSql = format(\"ALTER TABLE %s ALTER COLUMN %s %s(%s) COLLATE %s %s\",\n      column.getTable(), column.getColumn(), column.getDataType(), size, expectedCollation, nullability);\n    LOGGER.info(\"Changing collation of column [{}.{}] from {} to {} | sql=\", column.getTable(), column.getColumn(), column.getCollation(), expectedCollation, alterSql);\n    getSqlExecutor().executeDdl(connection, alterSql);\n\n    // 4. re-create indices\n    for (ColumnIndex index : indices) {\n      String uniqueSql = index.unique ? \"UNIQUE\" : \"\";\n      String createIndexSql = format(\"CREATE %s INDEX %s ON %s (%s)\", uniqueSql, index.name, column.getTable(), index.csvColumns);\n      getSqlExecutor().executeDdl(connection, createIndexSql);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected MssqlCharsetHandler(SqlExecutor selectExecutor) {\n    super(selectExecutor);\n  }","id":22696,"modified_method":"MssqlCharsetHandler(SqlExecutor selectExecutor, MssqlMetadataReader metadataReader) {\n    super(selectExecutor);\n    this.metadata = metadataReader;\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void support_the_max_size_of_varchar_column() throws Exception {\n    // returned size is -1\n    answerColumns(asList(new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"Latin1_General\", \"Latin1_General_CI_AI\", \"nvarchar\", -1, false)));\n    answerIndices(Collections.<MssqlCharsetHandler.ColumnIndex>emptyList());\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor).executeUpdate(connection, \"ALTER TABLE projects ALTER COLUMN name nvarchar(max) COLLATE Latin1_General_CS_AS NOT NULL\");\n  }","id":22697,"modified_method":"@Test\n  public void support_the_max_size_of_varchar_column() throws Exception {\n    answerDefaultCollation(\"Latin1_General_CS_AS\");\n    // returned size is -1\n    answerColumnDefs(new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"Latin1_General\", \"Latin1_General_CI_AI\", \"nvarchar\", -1, false));\n    answerIndices();\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor).executeDdl(connection, \"ALTER TABLE projects ALTER COLUMN name nvarchar(max) COLLATE Latin1_General_CS_AS NOT NULL\");\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@DataProvider\n  public static Object[][] combinationsOfCsAsAndSuffix() {\n    List<String[]> res = new ArrayList<>();\n    for (String sensitivity : Arrays.asList(\"CI_AI\", \"CI_AS\", \"CS_AI\")) {\n      for (String suffix : Arrays.asList(\"\", \"_KS_WS\")) {\n        res.add(new String[] {\n          format(\"Latin1_General_%s%s\", sensitivity, suffix),\n          format(\"Latin1_General_CS_AS%s\", suffix)\n        });\n      }\n    }\n    return res.stream().toArray(Object[][]::new);\n  }","id":22698,"modified_method":"@DataProvider\n  public static Object[][] combinationsOfCsAsAndSuffix() {\n    List<String[]> res = new ArrayList<>();\n    for (String sensitivity : asList(\"CI_AI\", \"CI_AS\", \"CS_AI\")) {\n      for (String suffix : asList(\"\", \"_KS_WS\")) {\n        res.add(new String[] {\n          format(\"Latin1_General_%s%s\", sensitivity, suffix),\n          format(\"Latin1_General_CS_AS%s\", suffix)\n        });\n      }\n    }\n    return res.stream().toArray(Object[][]::new);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void answerColumns(List<ColumnDef> columnDefs) throws SQLException {\n    when(selectExecutor.executeSelect(any(Connection.class), anyString(), eq(ColumnDef.ColumnDefRowConverter.INSTANCE))).thenReturn(columnDefs);\n  }","id":22699,"modified_method":"private void answerColumnDefs(ColumnDef... columnDefs) throws SQLException {\n    when(metadata.getColumnDefs(connection)).thenReturn(asList(columnDefs));\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@DataProvider\n  public static Object[][] combinationOfBin2AndSuffix() {\n    return Arrays.asList(\"\", \"_KS_WS\")\n      .stream()\n      .map(suffix -> new String[] {format(\"Latin1_General_BIN2%s\", suffix)})\n      .toArray(Object[][]::new);\n  }","id":22700,"modified_method":"@DataProvider\n  public static Object[][] combinationOfBin2AndSuffix() {\n    return Stream.of(\"\", \"_KS_WS\")\n      .map(suffix -> new String[] {format(\"Latin1_General_BIN2%s\", suffix)})\n      .toArray(Object[][]::new);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @UseDataProvider(\"combinationsOfCsAsAndSuffix\")\n  public void repair_case_insensitive_accent_insensitive_combinations_with_or_without_suffix(String collation, String expectedCollation) throws Exception {\n    answerColumns(Collections.singletonList(new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"Latin1_General\", collation, \"varchar\", 10, false)));\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor).executeUpdate(connection, \"ALTER TABLE issues ALTER COLUMN kee varchar(10) COLLATE \" + expectedCollation + \" NOT NULL\");\n  }","id":22701,"modified_method":"@Test\n  @UseDataProvider(\"combinationsOfCsAsAndSuffix\")\n  public void repair_case_insensitive_accent_insensitive_combinations_with_or_without_suffix(String collation, String expectedCollation)\n    throws Exception {\n    answerDefaultCollation(\"Latin1_General_CS_AS\");\n    answerColumnDefs(new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"Latin1_General\", collation, \"varchar\", 10, false));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor).executeDdl(connection, \"ALTER TABLE issues ALTER COLUMN kee varchar(10) COLLATE \" + expectedCollation + \" NOT NULL\");\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @UseDataProvider(\"combinationOfBin2AndSuffix\")\n  public void do_not_repair_if_collation_contains_BIN2(String collation) throws Exception {\n    answerColumns(asList(new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"Latin1_General\", collation, \"varchar\", 10, false)));\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor, never()).executeUpdate(any(Connection.class), anyString());\n  }","id":22702,"modified_method":"@Test\n  @UseDataProvider(\"combinationOfBin2AndSuffix\")\n  public void do_not_repair_if_collation_contains_BIN2(String collation) throws Exception {\n    answerDefaultCollation(\"Latin1_General_CS_AS\");\n    answerColumnDefs(new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"Latin1_General\", collation, \"varchar\", 10, false));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor, never()).executeDdl(any(Connection.class), anyString());\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@DataProvider\n  public static Object[][] combinationOfBinAndSuffix() {\n    return Arrays.asList(\"\", \"_KS_WS\")\n      .stream()\n      .map(suffix -> new String[] {format(\"Latin1_General_BIN%s\", suffix)})\n      .toArray(Object[][]::new);\n  }","id":22703,"modified_method":"@DataProvider\n  public static Object[][] combinationOfBinAndSuffix() {\n    return Stream.of(\"\", \"_KS_WS\")\n      .map(suffix -> new String[] {format(\"Latin1_General_BIN%s\", suffix)})\n      .toArray(Object[][]::new);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  @UseDataProvider(\"combinationOfBinAndSuffix\")\n  public void do_not_repair_if_collation_contains_BIN(String collation) throws Exception {\n    answerColumns(asList(new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"Latin1_General\", collation, \"varchar\", 10, false)));\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor, never()).executeUpdate(any(Connection.class), anyString());\n  }","id":22704,"modified_method":"@Test\n  @UseDataProvider(\"combinationOfBinAndSuffix\")\n  public void do_not_repair_if_collation_contains_BIN(String collation) throws Exception {\n    answerDefaultCollation(\"Latin1_General_CS_AS\");\n    answerColumnDefs(new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"Latin1_General\", collation, \"varchar\", 10, false));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor, never()).executeDdl(any(Connection.class), anyString());\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_not_repair_system_tables_of_sql_azure() throws Exception {\n    answerColumns(asList(new ColumnDef(\"sys.sysusers\", COLUMN_NAME, \"Latin1_General\", \"Latin1_General_CI_AI\", \"varchar\", 10, false)));\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor, never()).executeUpdate(any(Connection.class), anyString());\n  }","id":22705,"modified_method":"@Test\n  public void do_not_repair_system_tables_of_sql_azure() throws Exception {\n    answerDefaultCollation(\"Latin1_General_CS_AS\");\n    answerColumnDefs(new ColumnDef(\"sys.sysusers\", COLUMN_NAME, \"Latin1_General\", \"Latin1_General_CI_AI\", \"varchar\", 10, false));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor, never()).executeDdl(any(Connection.class), anyString());\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void answerIndices(List<MssqlCharsetHandler.ColumnIndex> indices) throws SQLException {\n    when(selectExecutor.executeSelect(any(Connection.class), anyString(), eq(MssqlCharsetHandler.ColumnIndexConverter.INSTANCE))).thenReturn(indices);\n  }","id":22706,"modified_method":"private void answerIndices(MssqlCharsetHandler.ColumnIndex... indices) throws SQLException {\n    when(metadata.getColumnIndices(same(connection), any(ColumnDef.class))).thenReturn(asList(indices));\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected MysqlCharsetHandler(SqlExecutor selectExecutor) {\n    super(selectExecutor);\n  }","id":22707,"modified_method":"MysqlCharsetHandler(SqlExecutor selectExecutor) {\n    super(selectExecutor);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void repairCaseInsensitiveColumn(Connection connection, ColumnDef column)\n    throws SQLException {\n    String csCollation = toCaseSensitive(column.getCollation());\n\n    String nullability = column.isNullable() ? \"NULL\" : \"NOT NULL\";\n    String type = column.getDataType().equalsIgnoreCase(TYPE_LONGTEXT) ? TYPE_LONGTEXT : format(\"%s(%d)\", column.getDataType(), column.getSize());\n    String alterSql = format(\"ALTER TABLE %s MODIFY %s %s CHARACTER SET '%s' COLLATE '%s' %s\",\n      column.getTable(), column.getColumn(), type, column.getCharset(), csCollation, nullability);\n    LOGGER.info(\"Changing collation of column [{}.{}] from {} to {} | sql={}\", column.getTable(), column.getColumn(), column.getCollation(), csCollation, alterSql);\n    getSqlExecutor().executeUpdate(connection, alterSql);\n  }","id":22708,"modified_method":"private void repairCaseInsensitiveColumn(Connection connection, ColumnDef column)\n    throws SQLException {\n    String csCollation = toCaseSensitive(column.getCollation());\n\n    String nullability = column.isNullable() ? \"NULL\" : \"NOT NULL\";\n    String type = column.getDataType().equalsIgnoreCase(TYPE_LONGTEXT) ? TYPE_LONGTEXT : format(\"%s(%d)\", column.getDataType(), column.getSize());\n    String alterSql = format(\"ALTER TABLE %s MODIFY %s %s CHARACTER SET '%s' COLLATE '%s' %s\",\n      column.getTable(), column.getColumn(), type, column.getCharset(), csCollation, nullability);\n    LOGGER.info(\"Changing collation of column [{}.{}] from {} to {} | sql={}\", column.getTable(), column.getColumn(), column.getCollation(), csCollation, alterSql);\n    getSqlExecutor().executeDdl(connection, alterSql);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@VisibleForTesting\n  static String toCaseSensitive(String caseInsensitiveCollation) {\n    // Example: big5_chinese_ci becomes big5_bin\n    // Full list of collations is available with SQL request \"show collation\"\n    return StringUtils.substringBefore(caseInsensitiveCollation, \"_\") + \"_bin\";\n  }","id":22709,"modified_method":"private static String toCaseSensitive(String caseInsensitiveCollation) {\n    // Example: big5_chinese_ci becomes big5_bin\n    // Full list of collations is available with SQL request \"show collation\"\n    return StringUtils.substringBefore(caseInsensitiveCollation, \"_\") + \"_bin\";\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  void handle(Connection connection, Set<DatabaseCharsetChecker.Flag> flags) throws SQLException {\n    logInit(flags);\n    checkCollation(connection, flags);\n  }","id":22710,"modified_method":"@Override\n  void handle(Connection connection, DatabaseCharsetChecker.State state) throws SQLException {\n    // all the VARCHAR columns have always been created with UTF8 charset on mysql\n    // (since SonarQube 2.12 to be precise). The default charset does not require\n    // to be UTF8. It is not used. No need to verify it.\n    // Still if a column has been accidentally created with a case-insensitive collation,\n    // then we can repair it by moving to the same case-sensitive collation. That should\n    // never occur.\n    if (state == DatabaseCharsetChecker.State.UPGRADE) {\n      repairCaseInsensitiveColumns(connection);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void repair_case_insensitive_column() throws Exception {\n    answerColumnDef(asList(\n      new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"utf8\", \"utf8_bin\", \"varchar\", 10, false),\n      new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"latin1\", \"latin1_swedish_ci\", \"varchar\", 10, false)));\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor).executeUpdate(connection, \"ALTER TABLE projects MODIFY name varchar(10) CHARACTER SET 'latin1' COLLATE 'latin1_bin' NOT NULL\");\n  }","id":22711,"modified_method":"@Test\n  public void repair_case_insensitive_column() throws Exception {\n    answerColumnDef(\n      new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"big5_chinese\", \"big5_chinese_ci\", \"varchar\", 10, false),\n      new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"latin1\", \"latin1_swedish_ci\", \"varchar\", 10, false));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor).executeDdl(connection, \"ALTER TABLE issues MODIFY kee varchar(10) CHARACTER SET 'big5_chinese' COLLATE 'big5_bin' NOT NULL\");\n    verify(sqlExecutor).executeDdl(connection, \"ALTER TABLE projects MODIFY name varchar(10) CHARACTER SET 'latin1' COLLATE 'latin1_bin' NOT NULL\");\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void size_should_be_ignored_on_longtext_column() throws Exception {\n    answerColumnDef(asList(new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"latin1\", \"latin1_german1_ci\", \"longtext\", 4_294_967_295L, false)));\n\n    Connection connection = mock(Connection.class);\n    underTest.handle(connection, immutableEnumSet(AUTO_REPAIR_COLLATION));\n\n    verify(selectExecutor).executeUpdate(connection, \"ALTER TABLE \" + TABLE_ISSUES + \" MODIFY \" + COLUMN_KEE + \" longtext CHARACTER SET 'latin1' COLLATE 'latin1_bin' NOT NULL\");\n  }","id":22712,"modified_method":"@Test\n  public void size_should_be_ignored_on_longtext_column() throws Exception {\n    answerColumnDef(\n      new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"latin1\", \"latin1_german1_ci\", \"longtext\", 4_294_967_295L, false));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n\n    verify(sqlExecutor).executeDdl(connection, \"ALTER TABLE \" + TABLE_ISSUES + \" MODIFY \" + COLUMN_KEE + \" longtext CHARACTER SET 'latin1' COLLATE 'latin1_bin' NOT NULL\");\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void answerColumnDef(List<ColumnDef> columnDefs) throws SQLException {\n    when(selectExecutor.executeSelect(any(Connection.class), anyString(), eq(ColumnDef.ColumnDefRowConverter.INSTANCE))).thenReturn(columnDefs);\n  }","id":22713,"modified_method":"private void answerColumnDef(ColumnDef... columnDefs) throws SQLException {\n    when(sqlExecutor.select(any(Connection.class), anyString(), eq(ColumnDef.ColumnDefRowConverter.INSTANCE)))\n      .thenReturn(asList(columnDefs));\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_not_fail_if_charsets_of_all_columns_are_utf8_and_case_sensitive() throws Exception {\n    answerColumnDef(asList(\n      new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"utf8\", \"utf8_bin\", \"varchar\", 10, false),\n      new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"utf8\", \"utf8_bin\", \"varchar\", 10, false)));\n\n    // all columns are utf8\n    underTest.handle(mock(Connection.class), immutableEnumSet(ENFORCE_UTF8));\n  }","id":22714,"modified_method":"@Test\n  public void upgrade_verifies_that_columns_are_utf8_and_case_sensitive() throws Exception {\n    answerColumnDef(\n      new ColumnDef(TABLE_ISSUES, COLUMN_KEE, \"utf8\", \"utf8_bin\", \"varchar\", 10, false),\n      new ColumnDef(TABLE_PROJECTS, COLUMN_NAME, \"utf8\", \"utf8_bin\", \"varchar\", 10, false));\n\n    // all columns are utf8\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected OracleCharsetHandler(SqlExecutor selectExecutor) {\n    super(selectExecutor);\n  }","id":22715,"modified_method":"OracleCharsetHandler(SqlExecutor selectExecutor) {\n    super(selectExecutor);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void checkUtf8(Connection connection) throws SQLException {\n    String charset = selectSingleString(connection, \"select value from nls_database_parameters where parameter='NLS_CHARACTERSET'\");\n    String sort = selectSingleString(connection, \"select value from nls_database_parameters where parameter='NLS_SORT'\");\n    if (!containsIgnoreCase(charset, UTF8) || !\"BINARY\".equalsIgnoreCase(sort)) {\n      throw MessageException.of(format(\"Oracle must be have UTF8 charset and BINARY sort. NLS_CHARACTERSET is %s and NLS_SORT is %s.\", charset, sort));\n    }\n  }","id":22716,"modified_method":"private void expectUtf8(Connection connection) throws SQLException {\n    // Oracle does not allow to override character set on tables. Only global charset is verified.\n    String charset = getSqlExecutor().selectSingleString(connection, \"select value from nls_database_parameters where parameter='NLS_CHARACTERSET'\");\n    String sort = getSqlExecutor().selectSingleString(connection, \"select value from nls_database_parameters where parameter='NLS_SORT'\");\n    if (!containsIgnoreCase(charset, UTF8) || !\"BINARY\".equalsIgnoreCase(sort)) {\n      throw MessageException.of(format(\"Oracle must be have UTF8 charset and BINARY sort. NLS_CHARACTERSET is %s and NLS_SORT is %s.\", charset, sort));\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Connection connection, Set<DatabaseCharsetChecker.Flag> flags) throws SQLException {\n    // Oracle does not allow to override character set on tables. Only global charset is verified.\n    if (flags.contains(ENFORCE_UTF8)) {\n      Loggers.get(getClass()).info(\"Verify that database charset is UTF8\");\n      checkUtf8(connection);\n    }\n  }","id":22717,"modified_method":"@Override\n  public void handle(Connection connection, DatabaseCharsetChecker.State state) throws SQLException {\n    // Charset is a global setting on Oracle, it can't be set on a specified schema with a\n    // different value. To not block users who already have a SonarQube schema, charset\n    // is verified only on fresh installs but not on upgrades. Let's hope they won't face\n    // any errors related to charset if they didn't follow the UTF8 requirement when creating\n    // the schema in previous SonarQube versions.\n    if (state == DatabaseCharsetChecker.State.FRESH_INSTALL) {\n      Loggers.get(getClass()).info(\"Verify that database charset is UTF8\");\n      expectUtf8(connection);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fails_if_charset_is_not_utf8() throws Exception {\n    answerSql(\n      singletonList(new String[] {\"LATIN\"}), singletonList(new String[] {\"BINARY\"}));\n\n    expectedException.expect(MessageException.class);\n    expectedException.expectMessage(\"Oracle must be have UTF8 charset and BINARY sort. NLS_CHARACTERSET is LATIN and NLS_SORT is BINARY.\");\n\n    underTest.handle(mock(Connection.class), ENFORCE_UTF8_FLAGS);\n  }","id":22718,"modified_method":"@Test\n  public void fresh_install_fails_if_charset_is_not_utf8() throws Exception {\n    answerSql(\n      singletonList(new String[] {\"LATIN\"}), singletonList(new String[] {\"BINARY\"}));\n\n    expectedException.expect(MessageException.class);\n    expectedException.expectMessage(\"Oracle must be have UTF8 charset and BINARY sort. NLS_CHARACTERSET is LATIN and NLS_SORT is BINARY.\");\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.FRESH_INSTALL);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fails_if_can_not_get_charset() throws Exception {\n    answerSql(Collections.<String[]>emptyList(), Collections.<String[]>emptyList());\n\n    expectedException.expect(MessageException.class);\n\n    underTest.handle(mock(Connection.class), ENFORCE_UTF8_FLAGS);\n  }","id":22719,"modified_method":"@Test\n  public void fails_if_can_not_get_charset() throws Exception {\n    answerSql(Collections.emptyList(), Collections.emptyList());\n\n    expectedException.expect(MessageException.class);\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.FRESH_INSTALL);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void answerSql(List<String[]> firstRequest, List<String[]>... otherRequests) throws SQLException {\n    when(selectExecutor.executeSelect(any(Connection.class), anyString(), any(SqlExecutor.StringsConverter.class))).thenReturn(firstRequest, otherRequests);\n  }","id":22720,"modified_method":"private void answerSql(List<String[]> firstRequest, List<String[]>... otherRequests) throws SQLException {\n    when(sqlExecutor.select(any(Connection.class), anyString(), any(SqlExecutor.StringsConverter.class))).thenReturn(firstRequest, otherRequests);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fails_if_not_case_sensitive() throws Exception {\n    answerSql(\n      singletonList(new String[] {\"UTF8\"}), singletonList(new String[] {\"LINGUISTIC\"}));\n\n    expectedException.expect(MessageException.class);\n    expectedException.expectMessage(\"Oracle must be have UTF8 charset and BINARY sort. NLS_CHARACTERSET is UTF8 and NLS_SORT is LINGUISTIC.\");\n\n    underTest.handle(mock(Connection.class), ENFORCE_UTF8_FLAGS);\n  }","id":22721,"modified_method":"@Test\n  public void fresh_install_fails_if_not_case_sensitive() throws Exception {\n    answerSql(\n      singletonList(new String[] {\"UTF8\"}), singletonList(new String[] {\"LINGUISTIC\"}));\n\n    expectedException.expect(MessageException.class);\n    expectedException.expectMessage(\"Oracle must be have UTF8 charset and BINARY sort. NLS_CHARACTERSET is UTF8 and NLS_SORT is LINGUISTIC.\");\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.FRESH_INSTALL);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void supports_al32utf8() throws Exception {\n    answerSql(\n      singletonList(new String[] {\"AL32UTF8\"}), singletonList(new String[] {\"BINARY\"}));\n\n    underTest.handle(mock(Connection.class), ENFORCE_UTF8_FLAGS);\n  }","id":22722,"modified_method":"@Test\n  public void fresh_install_supports_al32utf8() throws Exception {\n    answerSql(\n      singletonList(new String[] {\"AL32UTF8\"}), singletonList(new String[] {\"BINARY\"}));\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.FRESH_INSTALL);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void configureLevel() {\n    add(GeneratePluginIndex.class,\n      RegisterServletFilters.class,\n      ServerLifecycleNotifier.class);\n\n    addIfStartupLeader(\n      CheckDatabaseCollationDuringMigration.class,\n      IndexerStartupTask.class,\n      RegisterMetrics.class,\n      RegisterQualityGates.class,\n      RegisterRules.class,\n      RegisterQualityProfiles.class,\n      RegisterNewMeasureFilters.class,\n      RegisterDashboards.class,\n      RegisterPermissionTemplates.class,\n      RenameDeprecatedPropertyKeys.class,\n      RegisterIssueFilters.class,\n      RenameIssueWidgets.class,\n      DisplayLogOnDeprecatedProjects.class,\n      ClearRulesOverloadedDebt.class,\n      DeleteOldAnalysisReportsFromFs.class);\n  }","id":22723,"modified_method":"@Override\n  protected void configureLevel() {\n    add(GeneratePluginIndex.class,\n      RegisterServletFilters.class,\n      ServerLifecycleNotifier.class);\n\n    addIfStartupLeader(\n      IndexerStartupTask.class,\n      RegisterMetrics.class,\n      RegisterQualityGates.class,\n      RegisterRules.class,\n      RegisterQualityProfiles.class,\n      RegisterNewMeasureFilters.class,\n      RegisterDashboards.class,\n      RegisterPermissionTemplates.class,\n      RenameDeprecatedPropertyKeys.class,\n      RegisterIssueFilters.class,\n      RenameIssueWidgets.class,\n      DisplayLogOnDeprecatedProjects.class,\n      ClearRulesOverloadedDebt.class,\n      DeleteOldAnalysisReportsFromFs.class);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected PostgresCharsetHandler(SqlExecutor selectExecutor) {\n    super(selectExecutor);\n  }","id":22724,"modified_method":"PostgresCharsetHandler(SqlExecutor selectExecutor, PostgresMetadataReader metadata) {\n    super(selectExecutor);\n    this.metadata = metadata;\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void checkUtf8(Connection connection) throws SQLException {\n    // Character set is defined globally and can be overridden on each column.\n    // This request returns all VARCHAR columns. Collation may be empty.\n    // Examples:\n    // issues | key | ''\n    // projects | name | utf8\n    List<String[]> rows = select(connection, \"select table_name, column_name, collation_name \" +\n      \"from information_schema.columns \" +\n      \"where table_schema='public' \" +\n      \"and udt_name='varchar' \" +\n      \"order by table_name, column_name\", new SqlExecutor.StringsConverter(3 /* columns returned by SELECT */));\n    boolean mustCheckGlobalCollation = false;\n    Set<String> errors = new LinkedHashSet<>();\n    for (String[] row : rows) {\n      if (StringUtils.isBlank(row[2])) {\n        mustCheckGlobalCollation = true;\n      } else if (!containsIgnoreCase(row[2], UTF8)) {\n        errors.add(format(\"%s.%s\", row[0], row[1]));\n      }\n    }\n\n    if (mustCheckGlobalCollation) {\n      String charset = selectSingleString(connection, \"SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname = current_database()\");\n      if (!containsIgnoreCase(charset, UTF8)) {\n        throw MessageException.of(format(\"Database collation is %s. It must support UTF8.\", charset));\n      }\n    }\n    if (!errors.isEmpty()) {\n      throw MessageException.of(format(\"Database columns [%s] must support UTF8 collation.\", Joiner.on(\", \").join(errors)));\n    }\n  }","id":22725,"modified_method":"private void expectUtf8Columns(Connection connection) throws SQLException {\n    // Charset is defined globally and can be overridden on each column.\n    // This request returns all VARCHAR columns. Charset may be empty.\n    // Examples:\n    // issues | key | ''\n    // projects | name | utf8\n    List<String[]> rows = getSqlExecutor().select(connection, \"select table_name, column_name, collation_name \" +\n      \"from information_schema.columns \" +\n      \"where table_schema='public' \" +\n      \"and udt_name='varchar' \" +\n      \"order by table_name, column_name\", new SqlExecutor.StringsConverter(3 /* columns returned by SELECT */));\n    Set<String> errors = new LinkedHashSet<>();\n    for (String[] row : rows) {\n      if (!isBlank(row[2]) && !containsIgnoreCase(row[2], UTF8)) {\n        errors.add(format(\"%s.%s\", row[0], row[1]));\n      }\n    }\n\n    if (!errors.isEmpty()) {\n      throw MessageException.of(format(\"Database columns [%s] must have UTF8 charset.\", Joiner.on(\", \").join(errors)));\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  void handle(Connection connection, Set<DatabaseCharsetChecker.Flag> flags) throws SQLException {\n    // PostgreSQL does not support case-insensitive collations. Only charset must be verified.\n    if (flags.contains(ENFORCE_UTF8)) {\n      Loggers.get(getClass()).info(\"Verify that database collation supports UTF8\");\n      checkUtf8(connection);\n    }\n  }","id":22726,"modified_method":"@Override\n  void handle(Connection connection, DatabaseCharsetChecker.State state) throws SQLException {\n    // PostgreSQL does not have concept of case-sensitive collation. Only charset (\"encoding\" in postgresql terminology)\n    // must be verified.\n    expectUtf8AsDefault(connection);\n\n    if (state == DatabaseCharsetChecker.State.UPGRADE || state == DatabaseCharsetChecker.State.STARTUP) {\n      // no need to check columns on fresh installs... as they are not supposed to exist!\n      expectUtf8Columns(connection);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void answerSql(List<String[]> firstRequest, List<String[]>... otherRequests) throws SQLException {\n    when(selectExecutor.executeSelect(any(Connection.class), anyString(), any(SqlExecutor.StringsConverter.class))).thenReturn(firstRequest, otherRequests);\n  }","id":22727,"modified_method":"private void answerColumns(List<String[]> firstRequest) throws SQLException {\n    when(sqlExecutor.select(same(connection), anyString(), any(SqlExecutor.StringsConverter.class))).thenReturn(firstRequest);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fails_if_non_utf8_column() throws Exception {\n    answerSql(asList(\n      new String[] {TABLE_ISSUES, COLUMN_KEE, \"utf8\"},\n      new String[] {TABLE_PROJECTS, COLUMN_KEE, \"latin\"},\n      new String[] {TABLE_PROJECTS, COLUMN_NAME, \"latin\"}));\n\n    expectedException.expect(MessageException.class);\n    expectedException.expectMessage(\"Database columns [projects.kee, projects.name] must support UTF8 collation.\");\n\n    underTest.handle(mock(Connection.class), immutableEnumSet(ENFORCE_UTF8));\n  }","id":22728,"modified_method":"@Test\n  public void upgrade_fails_if_non_utf8_column() throws Exception {\n    // default charset is ok but two columns are not\n    answerDefaultCharset(\"utf8\");\n    answerColumns(asList(\n      new String[] {TABLE_ISSUES, COLUMN_KEE, \"utf8\"},\n      new String[] {TABLE_PROJECTS, COLUMN_KEE, \"latin\"},\n      new String[] {TABLE_PROJECTS, COLUMN_NAME, \"latin\"}));\n\n    expectedException.expect(MessageException.class);\n    expectedException.expectMessage(\"Database columns [projects.kee, projects.name] must have UTF8 charset.\");\n\n    underTest.handle(connection, DatabaseCharsetChecker.State.UPGRADE);\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testExecuteQuery() throws Exception {\n    DbSession session = dbTester.getSession();\n    dbTester.getDbClient().userDao().insert(session, new UserDto().setLogin(\"him\").setName(\"Him\"));\n    dbTester.getDbClient().userDao().insert(session, new UserDto().setLogin(\"her\").setName(\"Her\"));\n    session.commit();\n\n    try (Connection connection = dbTester.openConnection()) {\n      List<String[]> rows = underTest.executeSelect(connection, \"select login, name from users order by login\", new SqlExecutor.StringsConverter(2));\n      assertThat(rows).hasSize(2);\n      assertThat(rows.get(0)[0]).isEqualTo(\"her\");\n      assertThat(rows.get(0)[1]).isEqualTo(\"Her\");\n      assertThat(rows.get(1)[0]).isEqualTo(\"him\");\n      assertThat(rows.get(1)[1]).isEqualTo(\"Him\");\n    }\n  }","id":22729,"modified_method":"@Test\n  public void testExecuteQuery() throws Exception {\n    DbSession session = dbTester.getSession();\n    dbTester.getDbClient().userDao().insert(session, new UserDto().setLogin(\"him\").setName(\"Him\"));\n    dbTester.getDbClient().userDao().insert(session, new UserDto().setLogin(\"her\").setName(\"Her\"));\n    session.commit();\n\n    try (Connection connection = dbTester.openConnection()) {\n      List<String[]> rows = underTest.select(connection, \"select login, name from users order by login\", new SqlExecutor.StringsConverter(2));\n      assertThat(rows).hasSize(2);\n      assertThat(rows.get(0)[0]).isEqualTo(\"her\");\n      assertThat(rows.get(0)[1]).isEqualTo(\"Her\");\n      assertThat(rows.get(1)[0]).isEqualTo(\"him\");\n      assertThat(rows.get(1)[1]).isEqualTo(\"Him\");\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public <T> List<T> executeSelect(Connection connection, String sql, RowConverter<T> rowConverter) throws SQLException {\n    PreparedStatement stmt = null;\n    ResultSet rs = null;\n    try {\n      stmt = connection.prepareStatement(sql);\n      rs = stmt.executeQuery();\n      List<T> result = new ArrayList<>();\n      while (rs.next()) {\n        result.add(rowConverter.convert(rs));\n      }\n      return result;\n\n    } finally {\n      DatabaseUtils.closeQuietly(rs);\n      DatabaseUtils.closeQuietly(stmt);\n    }\n  }","id":22730,"modified_method":"public <T> List<T> select(Connection connection, String sql, RowConverter<T> rowConverter) throws SQLException {\n    PreparedStatement stmt = null;\n    ResultSet rs = null;\n    try {\n      stmt = connection.prepareStatement(sql);\n      rs = stmt.executeQuery();\n      List<T> result = new ArrayList<>();\n      while (rs.next()) {\n        result.add(rowConverter.convert(rs));\n      }\n      return result;\n\n    } finally {\n      DatabaseUtils.closeQuietly(rs);\n      DatabaseUtils.closeQuietly(stmt);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void executeUpdate(Connection connection, String sql) throws SQLException {\n    PreparedStatement stmt = null;\n    try {\n      stmt = connection.prepareStatement(sql);\n      stmt.executeUpdate();\n    } finally {\n      DatabaseUtils.closeQuietly(stmt);\n    }\n  }","id":22731,"modified_method":"public void executeDdl(Connection connection, String sql) throws SQLException {\n    try (Statement stmt = connection.createStatement()) {\n      stmt.execute(sql);\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void executeSelect_executes_PreparedStatement() throws Exception {\n    dbTester.executeInsert(USERS_DB_TABLE, ImmutableMap.of(LOGIN_DB_COLUMN, \"login1\", NAME_DB_COLUMN, \"name one\"));\n    dbTester.executeInsert(USERS_DB_TABLE, ImmutableMap.of(LOGIN_DB_COLUMN, \"login2\", NAME_DB_COLUMN, \"name two\"));\n\n    try (Connection connection = dbTester.openConnection()) {\n      List<String[]> users = underTest.executeSelect(connection, \"select \" + LOGIN_DB_COLUMN + \", \" + NAME_DB_COLUMN + \" from users order by id\", new SqlExecutor.StringsConverter(\n        2));\n      assertThat(users).hasSize(2);\n      assertThat(users.get(0)[0]).isEqualTo(\"login1\");\n      assertThat(users.get(0)[1]).isEqualTo(\"name one\");\n      assertThat(users.get(1)[0]).isEqualTo(\"login2\");\n      assertThat(users.get(1)[1]).isEqualTo(\"name two\");\n    }\n  }","id":22732,"modified_method":"@Test\n  public void executeSelect_executes_PreparedStatement() throws Exception {\n    dbTester.executeInsert(USERS_DB_TABLE, ImmutableMap.of(LOGIN_DB_COLUMN, \"login1\", NAME_DB_COLUMN, \"name one\"));\n    dbTester.executeInsert(USERS_DB_TABLE, ImmutableMap.of(LOGIN_DB_COLUMN, \"login2\", NAME_DB_COLUMN, \"name two\"));\n\n    try (Connection connection = dbTester.openConnection()) {\n      List<String[]> users = underTest.select(connection, \"select \" + LOGIN_DB_COLUMN + \", \" + NAME_DB_COLUMN + \" from users order by id\", new SqlExecutor.StringsConverter(\n        2));\n      assertThat(users).hasSize(2);\n      assertThat(users.get(0)[0]).isEqualTo(\"login1\");\n      assertThat(users.get(0)[1]).isEqualTo(\"name one\");\n      assertThat(users.get(1)[0]).isEqualTo(\"login2\");\n      assertThat(users.get(1)[1]).isEqualTo(\"name two\");\n    }\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void executeUpdate_executes_PreparedStatement() throws Exception {\n    dbTester.executeInsert(USERS_DB_TABLE, ImmutableMap.of(LOGIN_DB_COLUMN, \"the_login\", NAME_DB_COLUMN, \"the name\"));\n\n    try (Connection connection = dbTester.openConnection()) {\n      underTest.executeUpdate(connection, \"update users set \" + NAME_DB_COLUMN + \"='new name' where \" + LOGIN_DB_COLUMN + \"='the_login'\");\n    }\n    Map<String, Object> row = dbTester.selectFirst(\"select \" + NAME_DB_COLUMN + \" from users where \" + LOGIN_DB_COLUMN + \"='the_login'\");\n    assertThat(row).isNotEmpty();\n    assertThat(row.get(\"NAME\")).isEqualTo(\"new name\");\n  }","id":22733,"modified_method":"@Test\n  public void executeUpdate_executes_PreparedStatement() throws Exception {\n    dbTester.executeInsert(USERS_DB_TABLE, ImmutableMap.of(LOGIN_DB_COLUMN, \"the_login\", NAME_DB_COLUMN, \"the name\"));\n\n    try (Connection connection = dbTester.openConnection()) {\n      underTest.executeDdl(connection, \"update users set \" + NAME_DB_COLUMN + \"='new name' where \" + LOGIN_DB_COLUMN + \"='the_login'\");\n    }\n    Map<String, Object> row = dbTester.selectFirst(\"select \" + NAME_DB_COLUMN + \" from users where \" + LOGIN_DB_COLUMN + \"='the_login'\");\n    assertThat(row).isNotEmpty();\n    assertThat(row.get(\"NAME\")).isEqualTo(\"new name\");\n  }","commit_id":"6603e70aa5abee4dd7eccf2b0b1c7ad829a028e4","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"AstAwareResourceLoader() {\n    myClass2File = Collections.synchronizedMap(new HashMap<String, File>());\n  }","id":22734,"modified_method":"AstAwareResourceLoader(Map<String, File> class2File) {\n    myClass2File = Collections.synchronizedMap(class2File);\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public URL loadGroovySource(String className) throws MalformedURLException {\n    if (className == null) return null;\n\n    File file = myClass2File.get(className);\n    if (file != null) {\n      return file.toURL();\n    }\n\n    file = new File(className);\n    if (file.exists()) {\n      return file.toURL();\n    }\n\n    return null;\n  }","id":22735,"modified_method":"public URL loadGroovySource(String className) throws MalformedURLException {\n    if (className == null) return null;\n\n    File file = getSourceFile(className);\n    if (file != null) {\n      return file.toURL();\n    }\n\n    file = new File(className);\n    if (file.exists()) {\n      return file.toURL();\n    }\n\n    return null;\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Builder.ExitCode build(final CompileContext context, ModuleChunk chunk) throws ProjectBuildException {\n    ExitCode exitCode = ExitCode.OK;\n    final List<File> toCompile = new ArrayList<File>();\n    try {\n      final TimestampStorage tsStorage = context.getBuildDataManager().getTimestampStorage(getName());\n      context.processFiles(chunk, new FileProcessor() {\n        @Override\n        public boolean apply(Module module, File file, String sourceRoot) throws Exception {\n          String path = file.getPath();\n          if ((path.endsWith(\".groovy\") || path.endsWith(\".gpp\")) && isFileDirty(file, context, tsStorage)) { //todo file type check\n            toCompile.add(file);\n          }\n          return true;\n        }\n      });\n\n      if (toCompile.isEmpty()) {\n        return exitCode;\n      }\n\n      final List<String> cp = new ArrayList<String>();\n      //groovy_rt.jar\n      // IMPORTANT! must be the first in classpath\n      cp.add(ClasspathBootstrap.getResourcePath(GroovyCompilerWrapper.class).getPath());\n\n      for (File file : context.getProjectPaths().getClasspathFiles(chunk, ClasspathKind.compile(context.isCompilingTests()), false)) {\n        cp.add(FileUtil.toCanonicalPath(file.getPath()));\n      }\n\n      final File tempFile = FileUtil.createTempFile(\"ideaGroovyToCompile\", \".txt\", true);\n      final Module representativeModule = chunk.getModules().iterator().next();\n      File moduleOutputDir = context.getProjectPaths().getModuleOutputDir(representativeModule, context.isCompilingTests());\n      final File dir = myForStubs ? FileUtil.createTempDirectory(/*new File(\"/tmp/stubs/\"), */\"groovyStubs\", null) : moduleOutputDir;\n\n      assert dir != null;\n\n      fillFileWithGroovycParameters(tempFile, FileUtil.toCanonicalPath(dir.getPath()), toCompile, FileUtil.toCanonicalPath(moduleOutputDir.getPath()));\n\n      if (myForStubs) {\n        JavaBuilder.addTempSourcePathRoot(context, dir);\n      }\n\n      // todo cmd.add(\"-bootclasspath\");\n      //todo module jdk path\n      final List<String> cmd = ExternalProcessUtil.buildJavaCommandLine(\n        SystemProperties.getJavaHome() + \"/bin/java\",\n        \"org.jetbrains.groovy.compiler.rt.GroovycRunner\",\n        Collections.<String>emptyList(), cp,\n        Arrays.asList(\"-Xmx384m\"/*, \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5858\"*/),\n        Arrays.<String>asList(myForStubs ? \"stubs\" : \"groovyc\", tempFile.getPath())\n      );\n\n      context.deleteCorrespondingClasses(toCompile);\n\n      List<GroovycOSProcessHandler.OutputItem> successfullyCompiled = Collections.emptyList();\n      try {\n        final Process process = Runtime.getRuntime().exec(cmd.toArray(new String[cmd.size()]));\n        GroovycOSProcessHandler handler = new GroovycOSProcessHandler(process, null) {\n          @Override\n          protected void updateStatus(@Nullable String status) {\n            context.processMessage(new ProgressMessage(status == null ? GROOVY_COMPILER_IN_OPERATION : status));\n          }\n        };\n        handler.startNotify();\n        handler.waitFor();\n\n        successfullyCompiled = handler.getSuccessfullyCompiled();\n\n        final List<CompilerMessage> messages = handler.getCompilerMessages();\n        for (CompilerMessage message : messages) {\n          context.processMessage(message);\n        }\n\n        boolean hasMessages = !messages.isEmpty();\n\n        final StringBuffer unparsedBuffer = handler.getStdErr();\n        if (unparsedBuffer.length() != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, unparsedBuffer.toString()));\n          hasMessages = true;\n        }\n\n        final int exitValue = handler.getProcess().exitValue();\n        if (!hasMessages && exitValue != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, \"Internal groovyc error: code \" + exitValue));\n        }\n      }\n      finally {\n        if (myForStubs) {\n          for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n            tsStorage.saveStamp(new File(item.sourcePath));\n          }\n        }\n        else {\n          final Mappings delta = context.createDelta();\n          final List<File> successfullyCompiledFiles = new ArrayList<File>();\n          if (!successfullyCompiled.isEmpty()) {\n            final Callbacks.Backend callback = delta.getCallback();\n            final OutputToSourceMapping storage = context.getBuildDataManager().getOutputToSourceStorage();\n\n            for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n              final String sourcePath = FileUtil.toSystemIndependentName(item.sourcePath);\n              final String outputPath = FileUtil.toSystemIndependentName(item.outputPath);\n              storage.update(outputPath, sourcePath);\n              callback.associate(outputPath, Callbacks.getDefaultLookup(sourcePath), new ClassReader(FileUtil.loadFileBytes(new File(outputPath))));\n              successfullyCompiledFiles.add(new File(sourcePath));\n            }\n          }\n\n          final boolean needSecondPass = updateMappings(context, delta, chunk, toCompile, successfullyCompiledFiles);\n          if (needSecondPass) {\n            exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n          }\n        }\n      }\n\n      return exitCode;\n    }\n    catch (Exception e) {\n      throw new ProjectBuildException(e);\n    }\n  }","id":22736,"modified_method":"public Builder.ExitCode build(final CompileContext context, ModuleChunk chunk) throws ProjectBuildException {\n    ExitCode exitCode = ExitCode.OK;\n    final List<File> toCompile = new ArrayList<File>();\n    try {\n      final TimestampStorage tsStorage = context.getBuildDataManager().getTimestampStorage(getName());\n      context.processFiles(chunk, new FileProcessor() {\n        @Override\n        public boolean apply(Module module, File file, String sourceRoot) throws Exception {\n          file = file.getCanonicalFile();\n          String path = file.getPath();\n          if ((path.endsWith(\".groovy\") || path.endsWith(\".gpp\")) && isFileDirty(file, context, tsStorage)) { //todo file type check\n            toCompile.add(file);\n          }\n          return true;\n        }\n      });\n\n      if (toCompile.isEmpty()) {\n        return exitCode;\n      }\n\n      final List<String> cp = new ArrayList<String>();\n      //groovy_rt.jar\n      // IMPORTANT! must be the first in classpath\n      cp.add(ClasspathBootstrap.getResourcePath(GroovyCompilerWrapper.class).getPath());\n\n      for (File file : context.getProjectPaths().getClasspathFiles(chunk, ClasspathKind.compile(context.isCompilingTests()), false)) {\n        cp.add(FileUtil.toCanonicalPath(file.getPath()));\n      }\n\n      final File tempFile = FileUtil.createTempFile(\"ideaGroovyToCompile\", \".txt\", true);\n      final Module representativeModule = chunk.getModules().iterator().next();\n      File moduleOutputDir = context.getProjectPaths().getModuleOutputDir(representativeModule, context.isCompilingTests());\n      final File dir = myForStubs ? FileUtil.createTempDirectory(/*new File(\"/tmp/stubs/\"), */\"groovyStubs\", null) : moduleOutputDir;\n      assert dir != null;\n\n      Set<String> toCompilePaths = new LinkedHashSet<String>();\n      for (File file : toCompile) {\n        toCompilePaths.add(FileUtil.toCanonicalPath(file.getPath()));\n      }\n      \n      String moduleOutputPath = FileUtil.toCanonicalPath(moduleOutputDir.getPath());\n      if (!moduleOutputPath.endsWith(\"/\")) {\n        moduleOutputPath += \"/\";\n      }\n      Map<String, String> class2Src = buildClassToSourceMap(context, toCompilePaths, moduleOutputPath);\n\n      fillFileWithGroovycParameters(tempFile, FileUtil.toCanonicalPath(dir.getPath()), toCompilePaths, moduleOutputPath, class2Src);\n\n      if (myForStubs) {\n        JavaBuilder.addTempSourcePathRoot(context, dir);\n      }\n\n      // todo cmd.add(\"-bootclasspath\");\n      //todo module jdk path\n      final List<String> cmd = ExternalProcessUtil.buildJavaCommandLine(\n        SystemProperties.getJavaHome() + \"/bin/java\",\n        \"org.jetbrains.groovy.compiler.rt.GroovycRunner\",\n        Collections.<String>emptyList(), cp,\n        Arrays.asList(\"-Xmx384m\"/*, \"-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5858\"*/),\n        Arrays.<String>asList(myForStubs ? \"stubs\" : \"groovyc\", tempFile.getPath())\n      );\n\n      context.deleteCorrespondingClasses(toCompile);\n\n      List<GroovycOSProcessHandler.OutputItem> successfullyCompiled = Collections.emptyList();\n      try {\n        final Process process = Runtime.getRuntime().exec(cmd.toArray(new String[cmd.size()]));\n        GroovycOSProcessHandler handler = new GroovycOSProcessHandler(process, null) {\n          @Override\n          protected void updateStatus(@Nullable String status) {\n            context.processMessage(new ProgressMessage(status == null ? GROOVY_COMPILER_IN_OPERATION : status));\n          }\n        };\n        handler.startNotify();\n        handler.waitFor();\n\n        successfullyCompiled = handler.getSuccessfullyCompiled();\n\n        final List<CompilerMessage> messages = handler.getCompilerMessages();\n        for (CompilerMessage message : messages) {\n          context.processMessage(message);\n        }\n\n        boolean hasMessages = !messages.isEmpty();\n\n        final StringBuffer unparsedBuffer = handler.getStdErr();\n        if (unparsedBuffer.length() != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, unparsedBuffer.toString()));\n          hasMessages = true;\n        }\n\n        final int exitValue = handler.getProcess().exitValue();\n        if (!hasMessages && exitValue != 0) {\n          context.processMessage(new CompilerMessage(BUILDER_NAME, BuildMessage.Kind.ERROR, \"Internal groovyc error: code \" + exitValue));\n        }\n      }\n      finally {\n        if (myForStubs) {\n          for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n            tsStorage.saveStamp(new File(item.sourcePath));\n          }\n        }\n        else {\n          final Mappings delta = context.createDelta();\n          final List<File> successfullyCompiledFiles = new ArrayList<File>();\n          if (!successfullyCompiled.isEmpty()) {\n            final Callbacks.Backend callback = delta.getCallback();\n            final OutputToSourceMapping storage = context.getBuildDataManager().getOutputToSourceStorage();\n\n            for (GroovycOSProcessHandler.OutputItem item : successfullyCompiled) {\n              final String sourcePath = FileUtil.toSystemIndependentName(item.sourcePath);\n              final String outputPath = FileUtil.toSystemIndependentName(item.outputPath);\n              storage.update(outputPath, sourcePath);\n              callback.associate(outputPath, Callbacks.getDefaultLookup(sourcePath), new ClassReader(FileUtil.loadFileBytes(new File(outputPath))));\n              successfullyCompiledFiles.add(new File(sourcePath));\n            }\n          }\n\n          final boolean needSecondPass = updateMappings(context, delta, chunk, toCompile, successfullyCompiledFiles);\n          if (needSecondPass) {\n            exitCode = ExitCode.ADDITIONAL_PASS_REQUIRED;\n          }\n        }\n      }\n\n      return exitCode;\n    }\n    catch (Exception e) {\n      throw new ProjectBuildException(e);\n    }\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void fillFileWithGroovycParameters(File tempFile, final String outputDir, final Collection<File> files, String finalOutput) throws IOException {\n    final Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile)));\n    try {\n      for (File file : files) {\n        writer.write(\"src_file\\n\");\n        writer.write(file.getPath());\n        writer.write(\"\\n\");\n      }\n\n      //todo patchers\n      writer.write(\"encoding\\n\");\n      writer.write(\"UTF-8\\n\");  //todo encoding\n      writer.write(\"outputpath\\n\");\n      writer.write(outputDir);\n      writer.write(\"\\n\");\n      writer.write(\"final_outputpath\\n\");\n      writer.write(finalOutput);\n      writer.write(\"\\n\");\n    }\n    finally {\n      writer.close();\n    }\n  }","id":22737,"modified_method":"private static void fillFileWithGroovycParameters(File tempFile, final String outputDir, final Collection<String> files, String finalOutput, Map<String, String> class2Src) throws IOException {\n    final Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile)));\n    try {\n      for (String file : files) {\n        writer.write(\"src_file\\n\");\n        writer.write(file);\n        writer.write(\"\\n\");\n      }\n      \n      writer.write(\"class2src\\n\");\n      for (Map.Entry<String, String> entry : class2Src.entrySet()) {\n        writer.write(entry.getKey() + \"\\n\");\n        writer.write(entry.getValue() + \"\\n\");\n      }\n      writer.write(\"end\\n\");\n\n      //todo patchers\n      writer.write(\"encoding\\n\");\n      writer.write(\"UTF-8\\n\");  //todo encoding\n      writer.write(\"outputpath\\n\");\n      writer.write(outputDir);\n      writer.write(\"\\n\");\n      writer.write(\"final_outputpath\\n\");\n      writer.write(finalOutput);\n      writer.write(\"\\n\");\n    }\n    finally {\n      writer.close();\n    }\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List compile(List collector, boolean forStubs, final CompilationUnit unit) {\n    List compiledFiles = new ArrayList();\n    try {\n      unit.compile(forStubs ? Phases.CONVERSION : Phases.ALL);\n      addCompiledFiles(unit, compiledFiles, forStubs);\n    }\n    catch (CompilationFailedException e) {\n      processCompilationException(e, collector, forStubs);\n    }\n    catch (IOException e) {\n      processException(e, collector, forStubs);\n    }\n    catch (NoClassDefFoundError e) {\n      final String className = e.getMessage();\n      if (className.startsWith(\"org/apache/ivy/\")) {\n        addMessageWithoutLocation(collector, \"Cannot @Grab without Ivy, please add it to your module dependencies (NoClassDefFoundError: \" + className + \")\", true);\n      } else {\n        addMessageWithoutLocation(collector, \"Groovyc error: \" + className + \" class not found\", !forStubs);\n      }\n\n    }\n    finally {\n      addWarnings(unit.getErrorCollector(), collector);\n    }\n    return compiledFiles;\n  }","id":22738,"modified_method":"public static List compile(List collector, boolean forStubs, final CompilationUnit unit) {\n    List compiledFiles = new ArrayList();\n    try {\n      unit.compile(forStubs ? Phases.CONVERSION : Phases.ALL);\n      addCompiledFiles(unit, compiledFiles, forStubs);\n    }\n    catch (CompilationFailedException e) {\n      processCompilationException(e, collector, forStubs);\n    }\n    catch (IOException e) {\n      processException(e, collector, forStubs);\n    }\n    catch (NoClassDefFoundError e) {\n      final String className = e.getMessage();\n      if (className.startsWith(\"org/apache/ivy/\")) {\n        addMessageWithoutLocation(collector, \"Cannot @Grab without Ivy, please add it to your module dependencies (NoClassDefFoundError: \" + className + \")\", true);\n      } else {\n        throw e;\n      }\n\n    }\n    finally {\n      addWarnings(unit.getErrorCollector(), collector);\n    }\n    return compiledFiles;\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) {\n    /*\n    if (ourController != null) {\n      try {\n        ourController.startCPUProfiling(ProfilingModes.CPU_SAMPLING, null);\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n    */\n\n    if (args.length != 2) {\n      System.err.println(\"There is no arguments for groovy compiler\");\n      return;\n    }\n\n    final boolean forStubs = \"stubs\".equals(args[0]);\n    final File argsFile = new File(args[1]);\n\n    if (!argsFile.exists()) {\n      System.err.println(\"Arguments file for groovy compiler not found\");\n      return;\n    }\n\n    try {\n      final CompilerConfiguration compilerConfiguration = new CompilerConfiguration();\n      compilerConfiguration.setOutput(new PrintWriter(System.err));\n      compilerConfiguration.setWarningLevel(WarningMessage.PARANOIA);\n\n      final List<CompilerMessage> compilerMessages = new ArrayList<CompilerMessage>();\n      final List<CompilationUnitPatcher> patchers = new ArrayList<CompilationUnitPatcher>();\n      final List<File> srcFiles = new ArrayList<File>();\n\n      final String[] finalOutput = new String[1];\n      fillFromArgsFile(argsFile, compilerConfiguration, patchers, compilerMessages, srcFiles, finalOutput);\n      if (srcFiles.isEmpty()) return;\n\n      if (forStubs) {\n        Map<String, Object> options = new HashMap<String, Object>();\n        options.put(\"stubDir\", compilerConfiguration.getTargetDirectory());\n        options.put(\"keepStubs\", Boolean.TRUE);\n        compilerConfiguration.setJointCompilationOptions(options);\n\n        compilerConfiguration.setTargetBytecode(CompilerConfiguration.POST_JDK5);\n      }\n\n      System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: loading sources...\");\n      final CompilationUnit unit = createCompilationUnit(forStubs, compilerConfiguration, finalOutput[0]);\n      addSources(forStubs, srcFiles, unit);\n      runPatchers(patchers, compilerMessages, unit);\n\n      System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: compiling...\");\n      final List compiledFiles = GroovyCompilerWrapper.compile(compilerMessages, forStubs, unit);\n      System.out.println(CLEAR_PRESENTABLE);\n\n      System.out.println();\n      reportCompiledItems(compiledFiles);\n\n      System.out.println();\n      if (compiledFiles.isEmpty()) {\n        reportNotCompiledItems(srcFiles);\n      }\n\n      int errorCount = 0;\n      for (CompilerMessage message : compilerMessages) {\n        if (message.getCategory() == CompilerMessage.ERROR) {\n          if (errorCount > 100) {\n            continue;\n          }\n          errorCount++;\n        }\n\n        printMessage(message);\n      }\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n    }\n    /*\n    finally {\n      if (ourController != null) {\n        try {\n          ourController.captureSnapshot(ProfilingModes.SNAPSHOT_WITHOUT_HEAP);\n          ourController.stopCPUProfiling();\n        }\n        catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }\n    */\n  }","id":22739,"modified_method":"public static void main(String[] args) {\n    /*\n    if (ourController != null) {\n      try {\n        ourController.startCPUProfiling(ProfilingModes.CPU_SAMPLING, null);\n      }\n      catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n    */\n\n    if (args.length != 2) {\n      System.err.println(\"There is no arguments for groovy compiler\");\n      return;\n    }\n\n    final boolean forStubs = \"stubs\".equals(args[0]);\n    final File argsFile = new File(args[1]);\n\n    if (!argsFile.exists()) {\n      System.err.println(\"Arguments file for groovy compiler not found\");\n      return;\n    }\n\n    try {\n      final CompilerConfiguration config = new CompilerConfiguration();\n      config.setClasspath(\"\");\n      config.setOutput(new PrintWriter(System.err));\n      config.setWarningLevel(WarningMessage.PARANOIA);\n\n      final List<CompilerMessage> compilerMessages = new ArrayList<CompilerMessage>();\n      final List<CompilationUnitPatcher> patchers = new ArrayList<CompilationUnitPatcher>();\n      final List<File> srcFiles = new ArrayList<File>();\n      final Map<String, File> class2File = new HashMap<String, File>();\n\n      final String[] finalOutput = new String[1];\n      fillFromArgsFile(argsFile, config, patchers, compilerMessages, srcFiles, class2File, finalOutput);\n      if (srcFiles.isEmpty()) return;\n\n      if (forStubs) {\n        Map<String, Object> options = new HashMap<String, Object>();\n        options.put(\"stubDir\", config.getTargetDirectory());\n        options.put(\"keepStubs\", Boolean.TRUE);\n        config.setJointCompilationOptions(options);\n\n        config.setTargetBytecode(CompilerConfiguration.POST_JDK5);\n      }\n\n      System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: loading sources...\");\n      final AstAwareResourceLoader resourceLoader = new AstAwareResourceLoader(class2File);\n      final CompilationUnit unit = createCompilationUnit(forStubs, config, finalOutput[0], buildClassLoaderFor(config, resourceLoader));\n      unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() {\n        public void call(SourceUnit source) throws CompilationFailedException {\n          File file = new File(source.getName());\n          for (ClassNode aClass : source.getAST().getClasses()) {\n            resourceLoader.myClass2File.put(aClass.getName(), file);\n          }\n        }\n      }, Phases.CONVERSION);\n\n      addSources(forStubs, srcFiles, unit);\n      runPatchers(patchers, compilerMessages, unit, resourceLoader);\n\n      System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: compiling...\");\n      final List compiledFiles = GroovyCompilerWrapper.compile(compilerMessages, forStubs, unit);\n      System.out.println(CLEAR_PRESENTABLE);\n\n      System.out.println();\n      reportCompiledItems(compiledFiles);\n\n      System.out.println();\n      if (compiledFiles.isEmpty()) {\n        reportNotCompiledItems(srcFiles);\n      }\n\n      int errorCount = 0;\n      for (CompilerMessage message : compilerMessages) {\n        if (message.getCategory() == CompilerMessage.ERROR) {\n          if (errorCount > 100) {\n            continue;\n          }\n          errorCount++;\n        }\n\n        printMessage(message);\n      }\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n    }\n    /*\n    finally {\n      if (ourController != null) {\n        try {\n          ourController.captureSnapshot(ProfilingModes.SNAPSHOT_WITHOUT_HEAP);\n          ourController.stopCPUProfiling();\n        }\n        catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }\n    */\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void runPatchers(List<CompilationUnitPatcher> patchers, List<CompilerMessage> compilerMessages, CompilationUnit unit) {\n    if (!patchers.isEmpty()) {\n      final AstAwareResourceLoader loader = new AstAwareResourceLoader();\n      unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() {\n        public void call(SourceUnit source) throws CompilationFailedException {\n          File file = new File(source.getName());\n          for (ClassNode aClass : source.getAST().getClasses()) {\n            loader.myClass2File.put(aClass.getName(), file);\n          }\n        }\n      }, Phases.CONVERSION);\n      for (CompilationUnitPatcher patcher : patchers) {\n        try {\n          patcher.patchCompilationUnit(unit, loader);\n        }\n        catch (LinkageError e) {\n          addExceptionInfo(compilerMessages, e, \"Couldn't run \" + patcher.getClass().getName());\n        }\n      }\n    }\n  }","id":22740,"modified_method":"private static void runPatchers(List<CompilationUnitPatcher> patchers, List<CompilerMessage> compilerMessages, CompilationUnit unit, final AstAwareResourceLoader loader) {\n    if (!patchers.isEmpty()) {\n      for (CompilationUnitPatcher patcher : patchers) {\n        try {\n          patcher.patchCompilationUnit(unit, loader);\n        }\n        catch (LinkageError e) {\n          addExceptionInfo(compilerMessages, e, \"Couldn't run \" + patcher.getClass().getName());\n        }\n      }\n    }\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static GroovyClassLoader buildClassLoaderFor(final CompilerConfiguration compilerConfiguration) {\n    return AccessController.doPrivileged(new PrivilegedAction<GroovyClassLoader>() {\n      public GroovyClassLoader run() {\n        return new GroovyClassLoader(getClass().getClassLoader(), compilerConfiguration) {\n          public Class loadClass(String name, boolean lookupScriptFiles, boolean preferClassOverScript)\n            throws ClassNotFoundException, CompilationFailedException {\n            try {\n              return super.loadClass(name, lookupScriptFiles, preferClassOverScript);\n            }\n            catch (NoClassDefFoundError e) {\n              final String ncdfe = e.getMessage();\n\n              throw new RuntimeException(\"Groovyc error: \" + ncdfe + \" class not found while resolving class \" + name, e);\n            }\n            catch (LinkageError e) {\n              throw new RuntimeException(\"Problem loading class \" + name, e);\n            }\n          }\n        };\n      }\n    });\n  }","id":22741,"modified_method":"static GroovyClassLoader buildClassLoaderFor(final CompilerConfiguration compilerConfiguration, final AstAwareResourceLoader resourceLoader) {\n    GroovyClassLoader classLoader = AccessController.doPrivileged(new PrivilegedAction<GroovyClassLoader>() {\n      public GroovyClassLoader run() {\n        return new GroovyClassLoader(getClass().getClassLoader(), compilerConfiguration) {\n          public Class loadClass(String name, boolean lookupScriptFiles, boolean preferClassOverScript)\n            throws ClassNotFoundException, CompilationFailedException {\n            Class aClass;\n            try {\n              aClass = super.loadClass(name, lookupScriptFiles, preferClassOverScript);\n            }\n            catch (NoClassDefFoundError e) {\n              throw new ClassNotFoundException(name);\n            }\n            catch (LinkageError e) {\n              throw new RuntimeException(\"Problem loading class \" + name, e);\n            }\n\n            if (resourceLoader.getSourceFile(name) != null) {\n              try {\n                aClass.getDeclaredMethods();\n                aClass.getDeclaredFields();\n                aClass.getDeclaredClasses();\n                aClass.getDeclaredAnnotations();\n              }\n              catch (NoClassDefFoundError e) {\n                throw new ClassNotFoundException(name);\n              }\n            }\n\n            return aClass;\n          }\n        };\n      }\n    });\n    classLoader.setResourceLoader(resourceLoader);\n    return classLoader;\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String fillFromArgsFile(File argsFile, CompilerConfiguration compilerConfiguration, List<CompilationUnitPatcher> patchers, List<CompilerMessage> compilerMessages,\n                                         List<File> srcFiles, String[] finalOutput) {\n    String moduleClasspath = null;\n\n    BufferedReader reader = null;\n    FileInputStream stream;\n\n    try {\n      stream = new FileInputStream(argsFile);\n      reader = new BufferedReader(new InputStreamReader(stream));\n\n      String line;\n\n      while ((line = reader.readLine()) != null) {\n        if (!SRC_FILE.equals(line)) {\n          break;\n        }\n\n        final File file = new File(reader.readLine());\n        srcFiles.add(file);\n      }\n\n      while (line != null) {\n        if (line.startsWith(PATCHERS)) {\n          String s;\n          while (!END.equals(s = reader.readLine())) {\n            try {\n              final CompilationUnitPatcher patcher = (CompilationUnitPatcher)Class.forName(s).newInstance();\n              patchers.add(patcher);\n            }\n            catch (InstantiationException e) {\n              addExceptionInfo(compilerMessages, e, \"Couldn't instantiate \" + s);\n            }\n            catch (IllegalAccessException e) {\n              addExceptionInfo(compilerMessages, e, \"Couldn't instantiate \" + s);\n            }\n            catch (ClassNotFoundException e) {\n              addExceptionInfo(compilerMessages, e, \"Couldn't instantiate \" + s);\n            }\n          }\n        }\n        else if (line.startsWith(ENCODING)) {\n          compilerConfiguration.setSourceEncoding(reader.readLine());\n        }\n        else if (line.startsWith(OUTPUTPATH)) {\n          compilerConfiguration.setTargetDirectory(reader.readLine());\n        }\n        else if (line.startsWith(FINAL_OUTPUTPATH)) {\n          finalOutput[0] = reader.readLine();\n        }\n\n        line = reader.readLine();\n      }\n\n    }\n    catch (FileNotFoundException e) {\n      e.printStackTrace();\n    }\n    catch (IOException e) {\n      e.printStackTrace();\n    }\n    finally {\n      try {\n        reader.close();\n      }\n      catch (IOException e) {\n        e.printStackTrace();\n      }\n      finally {\n        argsFile.delete();\n      }\n    }\n    return moduleClasspath;\n  }","id":22742,"modified_method":"private static String fillFromArgsFile(File argsFile, CompilerConfiguration compilerConfiguration, List<CompilationUnitPatcher> patchers, List<CompilerMessage> compilerMessages,\n                                         List<File> srcFiles, Map<String, File> class2File, String[] finalOutput) {\n    String moduleClasspath = null;\n\n    BufferedReader reader = null;\n    FileInputStream stream;\n\n    try {\n      stream = new FileInputStream(argsFile);\n      reader = new BufferedReader(new InputStreamReader(stream));\n\n      String line;\n\n      while ((line = reader.readLine()) != null) {\n        if (!SRC_FILE.equals(line)) {\n          break;\n        }\n\n        final File file = new File(reader.readLine());\n        srcFiles.add(file);\n      }\n\n      while (line != null) {\n        if (line.equals(\"class2src\")) {\n          while (!END.equals(line = reader.readLine())) {\n            class2File.put(line, new File(reader.readLine()));\n          }\n        }\n        else if (line.startsWith(PATCHERS)) {\n          String s;\n          while (!END.equals(s = reader.readLine())) {\n            try {\n              final CompilationUnitPatcher patcher = (CompilationUnitPatcher)Class.forName(s).newInstance();\n              patchers.add(patcher);\n            }\n            catch (InstantiationException e) {\n              addExceptionInfo(compilerMessages, e, \"Couldn't instantiate \" + s);\n            }\n            catch (IllegalAccessException e) {\n              addExceptionInfo(compilerMessages, e, \"Couldn't instantiate \" + s);\n            }\n            catch (ClassNotFoundException e) {\n              addExceptionInfo(compilerMessages, e, \"Couldn't instantiate \" + s);\n            }\n          }\n        }\n        else if (line.startsWith(ENCODING)) {\n          compilerConfiguration.setSourceEncoding(reader.readLine());\n        }\n        else if (line.startsWith(OUTPUTPATH)) {\n          compilerConfiguration.setTargetDirectory(reader.readLine());\n        }\n        else if (line.startsWith(FINAL_OUTPUTPATH)) {\n          finalOutput[0] = reader.readLine();\n        }\n\n        line = reader.readLine();\n      }\n\n    }\n    catch (FileNotFoundException e) {\n      e.printStackTrace();\n    }\n    catch (IOException e) {\n      e.printStackTrace();\n    }\n    finally {\n      try {\n        reader.close();\n      }\n      catch (IOException e) {\n        e.printStackTrace();\n      }\n      finally {\n        argsFile.delete();\n      }\n    }\n    return moduleClasspath;\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static CompilationUnit createCompilationUnit(final boolean forStubs, final CompilerConfiguration config, final String finalOutput) {\n    config.setClasspath(\"\");\n\n    final GroovyClassLoader classLoader = buildClassLoaderFor(config);\n\n    try {\n      if (forStubs) {\n        return createStubGenerator(config, classLoader);\n      }\n    }\n    catch (NoClassDefFoundError ignore) { // older groovy distributions just don't have stub generation capability\n    }\n\n    final GroovyClassLoader transformLoader = new GroovyClassLoader(classLoader) {\n      public Enumeration<URL> getResources(String name) throws IOException {\n        if (name.endsWith(\"org.codehaus.groovy.transform.ASTTransformation\")) {\n          final Enumeration<URL> resources = super.getResources(name);\n          final ArrayList<URL> list = Collections.list(resources);\n          for (Iterator iterator = list.iterator(); iterator.hasNext();) {\n            final URL url = (URL)iterator.next();\n            try {\n              final String file = new File(new URI(url.toString())).getCanonicalPath();\n              if (file.startsWith(finalOutput) || file.startsWith(\"/\" + finalOutput)) {\n                iterator.remove();\n              }\n            }\n            catch (Exception ignored) {\n              System.out.println(\"Invalid URI syntax: \" + url.toString());\n            }\n          }\n          return Collections.enumeration(list);\n        }\n        return super.getResources(name);\n      }\n    };\n    CompilationUnit unit;\n    try {\n      unit = new CompilationUnit(config, null, classLoader, transformLoader) {\n\n        public void gotoPhase(int phase) throws CompilationFailedException {\n          super.gotoPhase(phase);\n          if (phase <= Phases.ALL) {\n            System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: \" + getPhaseDescription());\n          }\n        }\n      };\n    }\n    catch (NoSuchMethodError e) {\n      //groovy 1.5.x\n      unit = new CompilationUnit(config, null, classLoader) {\n\n        public void gotoPhase(int phase) throws CompilationFailedException {\n          super.gotoPhase(phase);\n          if (phase <= Phases.ALL) {\n            System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: \" + getPhaseDescription());\n          }\n        }\n      };\n    }\n    return unit;\n  }","id":22743,"modified_method":"private static CompilationUnit createCompilationUnit(final boolean forStubs,\n                                                       final CompilerConfiguration config,\n                                                       final String finalOutput, final GroovyClassLoader classLoader) {\n\n    try {\n      if (forStubs) {\n        return createStubGenerator(config, classLoader);\n      }\n    }\n    catch (NoClassDefFoundError ignore) { // older groovy distributions just don't have stub generation capability\n    }\n\n    final GroovyClassLoader transformLoader = new GroovyClassLoader(classLoader) {\n      public Enumeration<URL> getResources(String name) throws IOException {\n        if (name.endsWith(\"org.codehaus.groovy.transform.ASTTransformation\")) {\n          final Enumeration<URL> resources = super.getResources(name);\n          final ArrayList<URL> list = Collections.list(resources);\n          for (Iterator iterator = list.iterator(); iterator.hasNext();) {\n            final URL url = (URL)iterator.next();\n            try {\n              final String file = new File(new URI(url.toString())).getCanonicalPath();\n              if (file.startsWith(finalOutput) || file.startsWith(\"/\" + finalOutput)) {\n                iterator.remove();\n              }\n            }\n            catch (Exception ignored) {\n              System.out.println(\"Invalid URI syntax: \" + url.toString());\n            }\n          }\n          return Collections.enumeration(list);\n        }\n        return super.getResources(name);\n      }\n    };\n    CompilationUnit unit;\n    try {\n      unit = new CompilationUnit(config, null, classLoader, transformLoader) {\n\n        public void gotoPhase(int phase) throws CompilationFailedException {\n          super.gotoPhase(phase);\n          if (phase <= Phases.ALL) {\n            System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: \" + getPhaseDescription());\n          }\n        }\n      };\n    }\n    catch (NoSuchMethodError e) {\n      //groovy 1.5.x\n      unit = new CompilationUnit(config, null, classLoader) {\n\n        public void gotoPhase(int phase) throws CompilationFailedException {\n          super.gotoPhase(phase);\n          if (phase <= Phases.ALL) {\n            System.out.println(PRESENTABLE_MESSAGE + \"Groovyc: \" + getPhaseDescription());\n          }\n        }\n      };\n    }\n    return unit;\n  }","commit_id":"9447420c113b9fbe827f350852fb93beaec798d1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doOpen(@NotNull File _dir, @Nullable File _toSelect) throws IOException, ExecutionException {\n    String dir = FileUtil.toCanonicalPath(_dir.getPath());\n    String toSelect = _toSelect != null ? FileUtil.toCanonicalPath(_toSelect.getPath()) : null;\n\n    if (SystemInfo.isWindows) {\n      String cmd = toSelect != null ? \"explorer /select,\" + toSelect : \"explorer /root,\" + dir;\n      Process process = Runtime.getRuntime().exec(cmd);  // no quoting/escaping is needed\n      new CapturingProcessHandler(process, null, cmd).runProcess().checkSuccess(LOG);\n    }\n    else if (SystemInfo.isMac) {\n      GeneralCommandLine cmd = toSelect != null ? new GeneralCommandLine(\"open\", \"-R\", toSelect) : new GeneralCommandLine(\"open\", dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (canUseNautilus.getValue()) {\n      GeneralCommandLine cmd = new GeneralCommandLine(\"nautilus\", toSelect != null ? toSelect : dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (SystemInfo.hasXdgOpen()) {\n      GeneralCommandLine cmd = new GeneralCommandLine(\"/usr/bin/xdg-open\", dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.OPEN)) {\n      Desktop.getDesktop().open(new File(dir));\n    }\n    else {\n      Messages.showErrorDialog(\"This action isn't supported on the current platform\", \"Cannot Open File\");\n    }\n  }","id":22744,"modified_method":"private static void doOpen(@NotNull File _dir, @Nullable File _toSelect) throws IOException, ExecutionException {\n    String dir = FileUtil.toSystemDependentName(FileUtil.toCanonicalPath(_dir.getPath()));\n    String toSelect = _toSelect != null ? FileUtil.toSystemDependentName(FileUtil.toCanonicalPath(_toSelect.getPath())) : null;\n\n    if (SystemInfo.isWindows) {\n      String cmd = toSelect != null ? \"explorer /select,\" + toSelect : \"explorer /root,\" + dir;\n      Process process = Runtime.getRuntime().exec(cmd);  // no quoting/escaping is needed\n      new CapturingProcessHandler(process, null, cmd).runProcess().checkSuccess(LOG);\n    }\n    else if (SystemInfo.isMac) {\n      GeneralCommandLine cmd = toSelect != null ? new GeneralCommandLine(\"open\", \"-R\", toSelect) : new GeneralCommandLine(\"open\", dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (canUseNautilus.getValue()) {\n      GeneralCommandLine cmd = new GeneralCommandLine(\"nautilus\", toSelect != null ? toSelect : dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (SystemInfo.hasXdgOpen()) {\n      GeneralCommandLine cmd = new GeneralCommandLine(\"/usr/bin/xdg-open\", dir);\n      ExecUtil.execAndGetOutput(cmd).checkSuccess(LOG);\n    }\n    else if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.OPEN)) {\n      Desktop.getDesktop().open(new File(dir));\n    }\n    else {\n      Messages.showErrorDialog(\"This action isn't supported on the current platform\", \"Cannot Open File\");\n    }\n  }","commit_id":"aaba1877fcd3edee63643b98341fae09f4a84499","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void updatePermissions(Layout layout) throws Exception {\n\t\tlong companyId = layout.getCompanyId();\n\t\tString name = Layout.class.getName();\n\t\tint scope =\tResourceConstants.SCOPE_INDIVIDUAL;\n\t\tString primKey = String.valueOf(layout.getPrimaryKey());\n\n\t\tResource resource = ResourceLocalServiceUtil.getResource(\n\t\t\tcompanyId, name, scope, primKey);\n\n\t\tUser defaultUser = UserLocalServiceUtil.getDefaultUser(companyId);\n\n\t\tlong userId = defaultUser.getUserId();\n\t\tString[] actionIds = new String[] {ActionKeys.VIEW};\n\t\tlong resourceId = resource.getResourceId();\n\n\t\tPermissionLocalServiceUtil.unsetUserPermissions(\n\t\t\tuserId, actionIds, resourceId);\n\t}","id":22745,"modified_method":"protected void updatePermissions(Layout layout) throws Exception {\n\t\tlong companyId = layout.getCompanyId();\n\t\tString name = Layout.class.getName();\n\t\tint scope =\tResourceConstants.SCOPE_INDIVIDUAL;\n\t\tString primKey = String.valueOf(layout.getPrimaryKey());\n\n\t\tResource resource = ResourceLocalServiceUtil.getResource(\n\t\t\tcompanyId, name, scope, primKey);\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tcompanyId, RoleConstants.GUEST);\n\t\tString[] actionIds = new String[] {};\n\n\t\tPermissionLocalServiceUtil.setRolePermissions(\n\t\t\trole.getRoleId(), actionIds, resource.getResourceId());\n\n\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\tcompanyId, RoleConstants.POWER_USER);\n\n\t\tPermissionLocalServiceUtil.setRolePermissions(\n\t\t\trole.getRoleId(), actionIds, resource.getResourceId());\n\t}","commit_id":"1d21b7c7be0811d37b4fb828533dbcd5ec23dcae","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * @see com.google.gwt.core.client.EntryPoint#onModuleLoad()\n     */\n    @Override\n    public void onModuleLoad() {\n\n        super.onModuleLoad();\n\n        I_CmsLayoutBundle.INSTANCE.rootCss().ensureInjected();\n        I_CmsLayoutBundle.INSTANCE.pageCss().ensureInjected();\n\n        RootPanel.getBodyElement().addClassName(I_CmsLayoutBundle.INSTANCE.rootCss().root());\n\n        CmsToolbar toolBar = new CmsToolbar();\n        toolBar.addLeft(new CmsImageButton(I_CmsImageBundle.INSTANCE.style().editorIcon(), true));\n        toolBar.addRight(new CmsImageButton(I_CmsImageBundle.INSTANCE.style().deleteIcon(), true));\n        RootPanel.get().add(toolBar);\n\n        RootPanel.get().add(new CmsToolbarPlaceHolder());\n        CmsHeader title = new CmsHeader(Messages.get().key(\n            Messages.GUI_EDITOR_TITLE_1,\n            CmsSitemapProvider.get().getUri()));\n        title.addStyleName(I_CmsLayoutBundle.INSTANCE.rootCss().pageCenter());\n        RootPanel.get().add(title);\n\n        final CmsPage page = new CmsPage();\n        RootPanel.get().add(page);\n\n        final Label loadingLabel = new Label(Messages.get().key(Messages.GUI_LOADING_0));\n        page.add(loadingLabel);\n\n        CmsRpcAction<CmsClientSitemapEntry> getRootAction = new CmsRpcAction<CmsClientSitemapEntry>() {\n\n            /**\n            * @see org.opencms.gwt.client.rpc.CmsRpcAction#execute()\n            */\n            @Override\n            public void execute() {\n\n                // Make the call to the sitemap service\n                start(500);\n                getSitemapService().getSitemapEntry(\"/demo_t3/\", this);\n            }\n\n            /**\n            * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)\n            */\n            @Override\n            public void onResponse(CmsClientSitemapEntry root) {\n\n                root.setName(\"demo_t3\");\n                page.remove(loadingLabel);\n\n                CmsLazyTree<CmsSitemapTreeItem> tree = new CmsLazyTree<CmsSitemapTreeItem>(\n                    new A_CmsLazyOpenHandler<CmsSitemapTreeItem>() {\n\n                        /**\n                         * @see org.opencms.gwt.client.ui.lazytree.I_CmsLazyOpenHandler#load(org.opencms.gwt.client.ui.lazytree.CmsLazyTreeItem)\n                         */\n                        public void load(final CmsSitemapTreeItem target) {\n\n                            CmsRpcAction<CmsClientSitemapEntry[]> getChildrenAction = new CmsRpcAction<CmsClientSitemapEntry[]>() {\n\n                                /**\n                                * @see org.opencms.gwt.client.rpc.CmsRpcAction#execute()\n                                */\n                                @Override\n                                public void execute() {\n\n                                    // Make the call to the sitemap service\n                                    start(1000);\n                                    getSitemapService().getSitemapChildren(target.getEntry().getSitePath(), this);\n                                }\n\n                                /**\n                                * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)\n                                */\n                                @Override\n                                public void onResponse(CmsClientSitemapEntry[] result) {\n\n                                    target.removeItems();\n                                    for (CmsClientSitemapEntry entry : result) {\n                                        target.addItem(entry);\n                                    }\n                                    target.setState(true);\n                                    stop();\n                                }\n                            };\n                            getChildrenAction.execute();\n                        }\n\n                    });\n                tree.addItem(new CmsSitemapTreeItem(root));\n                page.add(tree);\n                stop();\n            }\n\n        };\n        getRootAction.execute();\n    }","id":22746,"modified_method":"/**\n     * @see com.google.gwt.core.client.EntryPoint#onModuleLoad()\n     */\n    @Override\n    public void onModuleLoad() {\n\n        super.onModuleLoad();\n\n        I_CmsLayoutBundle.INSTANCE.rootCss().ensureInjected();\n        I_CmsLayoutBundle.INSTANCE.pageCss().ensureInjected();\n\n        RootPanel.getBodyElement().addClassName(I_CmsLayoutBundle.INSTANCE.rootCss().root());\n\n        CmsToolbar toolBar = new CmsToolbar();\n        toolBar.addLeft(new CmsImageButton(I_CmsImageBundle.INSTANCE.style().editorIcon(), true));\n        toolBar.addRight(new CmsImageButton(I_CmsImageBundle.INSTANCE.style().deleteIcon(), true));\n        RootPanel.get().add(toolBar);\n\n        RootPanel.get().add(new CmsToolbarPlaceHolder());\n        CmsHeader title = new CmsHeader(Messages.get().key(\n            Messages.GUI_EDITOR_TITLE_1,\n            CmsSitemapProvider.get().getUri()));\n        title.addStyleName(I_CmsLayoutBundle.INSTANCE.rootCss().pageCenter());\n        RootPanel.get().add(title);\n\n        final CmsPage page = new CmsPage();\n        RootPanel.get().add(page);\n\n        final Label loadingLabel = new Label(Messages.get().key(Messages.GUI_LOADING_0));\n        page.add(loadingLabel);\n\n        CmsRpcAction<CmsClientSitemapEntry> getRootAction = new CmsRpcAction<CmsClientSitemapEntry>() {\n\n            /**\n            * @see org.opencms.gwt.client.rpc.CmsRpcAction#execute()\n            */\n            @Override\n            public void execute() {\n\n                // Make the call to the sitemap service\n                start(500);\n                getSitemapService().getSitemapEntry(\"/demo_t3/\", this);\n            }\n\n            /**\n            * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)\n            */\n            @Override\n            public void onResponse(CmsClientSitemapEntry root) {\n\n                root.setName(\"demo_t3\");\n                page.remove(loadingLabel);\n\n                CmsLazyTree<CmsSitemapTreeItem> tree = new CmsLazyTree<CmsSitemapTreeItem>(\n                    new A_CmsLazyOpenHandler<CmsSitemapTreeItem>() {\n\n                        /**\n                         * @see org.opencms.gwt.client.ui.tree.I_CmsLazyOpenHandler#load(org.opencms.gwt.client.ui.tree.CmsLazyTreeItem)\n                         */\n                        public void load(final CmsSitemapTreeItem target) {\n\n                            CmsRpcAction<CmsClientSitemapEntry[]> getChildrenAction = new CmsRpcAction<CmsClientSitemapEntry[]>() {\n\n                                /**\n                                * @see org.opencms.gwt.client.rpc.CmsRpcAction#execute()\n                                */\n                                @Override\n                                public void execute() {\n\n                                    // Make the call to the sitemap service\n                                    start(1000);\n                                    getSitemapService().getSitemapChildren(target.getEntry().getSitePath(), this);\n                                }\n\n                                /**\n                                * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)\n                                */\n                                @Override\n                                public void onResponse(CmsClientSitemapEntry[] result) {\n\n                                    target.clearChildren();\n                                    for (CmsClientSitemapEntry entry : result) {\n                                        target.addChild(entry);\n                                    }\n                                    target.onFinishLoading();\n                                    stop();\n                                }\n                            };\n                            getChildrenAction.execute();\n                        }\n\n                    });\n                tree.addItem(new CmsSitemapTreeItem(root));\n                page.add(tree);\n                stop();\n            }\n\n        };\n        getRootAction.execute();\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the client message instance.<p>\n     * \n     * @return the client message instance\n     */\n    public static CmsSitemapProvider get() {\n\n        if (INSTANCE == null) {\n            INSTANCE = new CmsSitemapProvider();\n        }\n        return INSTANCE;\n    }","id":22747,"modified_method":"/**\n     * Returns the client message instance.<p>\n     * \n     * @return the client message instance\n     */\n    public static CmsSitemapProvider get() {\n\n        if (INSTANCE == null) {\n            INSTANCE = init();\n        }\n        return INSTANCE;\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if the current sitemap is editable.<p>\n     *\n     * @return <code>true<\/code> if the current sitemap is editable\n     */\n    public boolean isEditable() {\n\n        return m_editable;\n    }","id":22748,"modified_method":"/**\n     * Checks if the current sitemap is editable.<p>\n     *\n     * @return <code>true<\/code> if the current sitemap is editable\n     */\n    public boolean isEditable() {\n\n        return CmsStringUtil.isEmptyOrWhitespaceOnly(getNoEditReason());\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Prevent instantiation.<p> \n     */\n    private CmsSitemapProvider() {\n\n        Dictionary dict = Dictionary.getDictionary(DICT_NAME.replace('.', '_'));\n        m_toolbar = Boolean.parseBoolean(dict.get(KEY_TOOLBAR));\n        m_uri = dict.get(KEY_URI_SITEMAP);\n        m_noEditReason = dict.get(KEY_EDIT);\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(m_noEditReason)) {\n            m_editable = true;\n        }\n        m_cntPageType = Integer.parseInt(dict.get(KEY_TYPE_CNTPAGE));\n    }","id":22749,"modified_method":"/**\n     * Prevent instantiation.<p> \n     */\n    protected CmsSitemapProvider() {\n\n        // empty\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the cntPageType.<p>\n     *\n     * @return the cntPageType\n     */\n    public int getCntPageType() {\n\n        return m_cntPageType;\n    }","id":22750,"modified_method":"/**\n     * Returns the cntPageType.<p>\n     *\n     * @return the cntPageType\n     */\n    public native int getCntPageType() /*-{\n        return this[@org.opencms.ade.sitemap.shared.I_CmsSitemapProviderConstants::KEY_TYPE_CNTPAGE];\n    }-*/;","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Checks if the toolbar has to be displayed.<p>\n     *\n     * @return <code>true<\/code> if the toolbar has to be displayed\n     */\n    public boolean showToolbar() {\n\n        return m_toolbar;\n    }","id":22751,"modified_method":"/**\n     * Checks if the toolbar has to be displayed.<p>\n     *\n     * @return <code>true<\/code> if the toolbar has to be displayed\n     */\n    public native boolean showToolbar() /*-{\n        return this[@org.opencms.ade.sitemap.shared.I_CmsSitemapProviderConstants::KEY_TOOLBAR];\n    }-*/;","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the reason not to be able to edit the sitemap.<p>\n     *\n     * @return the reason not to be able to edit the sitemap\n     */\n    public String getNoEditReason() {\n\n        return m_noEditReason;\n    }","id":22752,"modified_method":"/**\n     * Returns the reason not to be able to edit the sitemap.<p>\n     *\n     * @return the reason not to be able to edit the sitemap\n     */\n    public native String getNoEditReason() /*-{\n        return this[@org.opencms.ade.sitemap.shared.I_CmsSitemapProviderConstants::KEY_EDIT];\n    }-*/;","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the current sitemap uri.<p>\n     *\n     * @return the current sitemap uri\n     */\n    public String getUri() {\n\n        return m_uri;\n    }","id":22753,"modified_method":"/**\n     * Returns the current sitemap uri.<p>\n     *\n     * @return the current sitemap uri\n     */\n    public native String getUri() /*-{\n        return this[@org.opencms.ade.sitemap.shared.I_CmsSitemapProviderConstants::KEY_URI_SITEMAP];\n    }-*/;","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Converts a site entry bean into a JSON object.<p>\n     * \n     * @param entry the entry to convert\n     * \n     * @return the JSON representation, can be <code>null<\/code> in case of not enough permissions\n     */\n    protected CmsClientSitemapEntry toGwtEntry(CmsSitemapEntry entry) {\n\n        CmsClientSitemapEntry gwtEntry = new CmsClientSitemapEntry();\n        gwtEntry.setId(entry.getId().toString());\n        gwtEntry.setName(entry.getName());\n        gwtEntry.setTitle(entry.getTitle());\n        gwtEntry.setResourceId(entry.getResourceId().toString());\n        gwtEntry.setProperties(new HashMap<String, String>(entry.getProperties()));\n        gwtEntry.setSitePath(entry.getSitePath(getCmsObject()));\n        return gwtEntry;\n    }","id":22754,"modified_method":"/**\n     * Converts a site entry bean into a JSON object.<p>\n     * \n     * @param entry the entry to convert\n     * \n     * @return the JSON representation, can be <code>null<\/code> in case of not enough permissions\n     * \n     * @throws CmsException should never happen \n     */\n    protected CmsClientSitemapEntry toGwtEntry(CmsSitemapEntry entry) throws CmsException {\n\n        CmsClientSitemapEntry gwtEntry = new CmsClientSitemapEntry();\n        gwtEntry.setId(entry.getId().toString());\n        gwtEntry.setName(entry.getName());\n        gwtEntry.setTitle(entry.getTitle());\n        String vfsPath = \"broken\";\n        if (getCmsObject().existsResource(entry.getResourceId())) {\n            vfsPath = getCmsObject().getSitePath(getCmsObject().readResource(entry.getResourceId()));\n        }\n        gwtEntry.setVfsPath(vfsPath);\n        gwtEntry.setProperties(new HashMap<String, String>(entry.getProperties()));\n        gwtEntry.setSitePath(entry.getSitePath(getCmsObject()));\n        return gwtEntry;\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds a child for the given entry.<p>\n     * \n     * @param entry the child entry to add\n     */\n    public void addItem(CmsClientSitemapEntry entry) {\n\n        addItem(new CmsSitemapTreeItem(entry));\n    }","id":22755,"modified_method":"/**\n     * Adds a child for the given entry.<p>\n     * \n     * @param entry the child entry to add\n     */\n    public void addChild(CmsClientSitemapEntry entry) {\n\n        addChild(new CmsSitemapTreeItem(entry));\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Default constructor.<p>\n     * \n     * @param entry the sitemap entry to use\n     */\n    public CmsSitemapTreeItem(final CmsClientSitemapEntry entry) {\n\n        super();\n        m_entry = entry;\n        CmsListInfoBean infoBean = new CmsListInfoBean();\n        infoBean.setTitle(m_entry.getTitle());\n        infoBean.setSubTitle(\"blah\");\n        infoBean.addAdditionalInfo(Messages.get().key(Messages.GUI_NAME_0), m_entry.getName());\n        infoBean.addAdditionalInfo(Messages.get().key(Messages.GUI_URL_0), entry.getSitePath());\n        infoBean.addAdditionalInfo(Messages.get().key(Messages.GUI_VFS_PATH_0), entry.getResourceId());\n        CmsListItemWidget listItem = new CmsListItemWidget(infoBean);\n        listItem.setWidth(\"500px\");\n        CmsImageButton linkIcon = new CmsImageButton(I_CmsImageBundle.INSTANCE.style().magnifierIcon(), false);\n        linkIcon.setTitle(\"Go to page\");\n        linkIcon.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                Window.Location.replace(CmsCoreProvider.get().link(entry.getSitePath()));\n            }\n        });\n        linkIcon.setAccessKey('G');\n        listItem.addButton(linkIcon);\n        setWidget(listItem);\n    }","id":22756,"modified_method":"/**\n     * Default constructor.<p>\n     * \n     * @param entry the sitemap entry to use\n     */\n    public CmsSitemapTreeItem(final CmsClientSitemapEntry entry) {\n\n        super(createWidget(entry));\n        m_entry = entry;\n    }","commit_id":"d1b848111badad7a4f9d7f82090424ea934c3792","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public Set preparePublishedItemAttachmentSet(PublishedItemData publishedItem,\n                                             Set itemAttachmentSet) {\n    HashSet h = new HashSet();\n    Iterator o = itemAttachmentSet.iterator();\n    while (o.hasNext()) {\n      ItemAttachment itemAttachment = (ItemAttachment) o.next();\n      PublishedItemAttachment publishedItemAttachment = new PublishedItemAttachment(\n        null, publishedItem, itemAttachment.getResourceId(), itemAttachment.getFilename(),\n        itemAttachment.getMimeType(), itemAttachment.getFileSize(), itemAttachment.getDescription(),\n        itemAttachment.getLocation(), itemAttachment.getIsLink(), itemAttachment.getStatus(),\n        itemAttachment.getCreatedBy(), itemAttachment.getCreatedDate(), itemAttachment.getLastModifiedBy(),\n        itemAttachment.getLastModifiedDate());\n      h.add(publishedItemAttachment);\n    }\n    return h;\n  }","id":22757,"modified_method":"public Set preparePublishedItemAttachmentSet(PublishedItemData publishedItem,\n                                             Set itemAttachmentSet) {\n    HashSet h = new HashSet();\n    Iterator o = itemAttachmentSet.iterator();\n    while (o.hasNext()) {\n      ItemAttachment itemAttachment = (ItemAttachment) o.next();\n      try{\n        // create a copy of the resource\n        ContentResource cr = ContentHostingService.getResource(itemAttachment.getResourceId());\n        ContentResource cr_copy = ContentHostingService.addAttachmentResource(\n                                  itemAttachment.getFilename(), cr.getContentType(), cr.getContent(),\n                                  cr.getProperties());\n\n        PublishedItemAttachment publishedItemAttachment = new PublishedItemAttachment(\n          null, publishedItem, cr_copy.getId(), itemAttachment.getFilename(),\n          itemAttachment.getMimeType(), itemAttachment.getFileSize(), itemAttachment.getDescription(),\n          itemAttachment.getLocation(), itemAttachment.getIsLink(), itemAttachment.getStatus(),\n          itemAttachment.getCreatedBy(), itemAttachment.getCreatedDate(), itemAttachment.getLastModifiedBy(),\n          itemAttachment.getLastModifiedDate());\n        h.add(publishedItemAttachment);\n      }\n      catch (Exception e){\n        log.warn(e.getMessage());\n      }\n    }\n    return h;\n  }","commit_id":"1f35fa7567faf2163fb51e98f4e42c7f70969f36","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * If there are attachments set put them into ATTACHMENTx field in XML.\n   * @param assessmentXml the XML\n   * @param securedIPAddressSet the Set\n   */\n  public void updateAttachmentSet(Assessment assessmentXml, Set attachmentSet)\n  {\n    String ipAddresses = \"\";\n    Iterator iter = attachmentSet.iterator();\n    int i = 1;\n    while (iter.hasNext())\n    {\n    \tAttachmentData attachmentData = (AttachmentData) iter.next();\n    \tStringBuffer attachment = new StringBuffer(attachmentData.getResourceId());\n    \tattachment.append(\"|\");\n    \tattachment.append(attachmentData.getFilename());\n    \tattachment.append(\"|\");\n    \tattachment.append(attachmentData.getMimeType());\n    \t\n    \tassessmentXml.setFieldentry(\"ATTACHMENT\" + i, attachment.toString());\n    \ti++;\n    }\n  }","id":22758,"modified_method":"/**\n   * If there are attachments set put them into ATTACHMENT field in XML.\n   * @param assessmentXml the XML\n   * @param securedIPAddressSet the Set\n   */\n  public void updateAttachmentSet(Assessment assessmentXml, Set attachmentSet)\n  {\n    Iterator iter = attachmentSet.iterator();\n    AttachmentData attachmentData = null;\n    StringBuffer attachment = new StringBuffer();\n    while (iter.hasNext())\n    {\n    \tattachmentData = (AttachmentData) iter.next();\n    \tattachment.append(attachmentData.getResourceId());\n    \tattachment.append(\"|\");\n    \tattachment.append(attachmentData.getFilename());\n    \tattachment.append(\"|\");\n    \tattachment.append(attachmentData.getMimeType());\n    \tattachment.append(\"\\n\");\n    }\n    assessmentXml.setFieldentry(\"ATTACHMENT\", attachment.toString());\n  }","commit_id":"2da44cce359228867e6c5fec071fff7b327f2767","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Get an assessment in Document form.\n   *\n   * @param assessmentId the assessment's Id\n   * @param is a stream containing the unpopulated XML document\n   * @return the Document with the published assessment data\n   */\n  public Document getAssessment(String assessmentId, InputStream is)\n  {\n    try\n    {\n      String authors;\n      String objectives;\n      String keywords;\n      String rubrics;\n      String bgColor;\n      String bgImage;\n\n      AssessmentService assessmentService = new AssessmentService();\n      QTIHelperFactory factory = new QTIHelperFactory();\n\n      AssessmentFacade assessment =\n        assessmentService.getAssessment(assessmentId);\n      // convert assessment to document\n      AssessmentHelperIfc assessmentHelper =\n        factory.getAssessmentHelperInstance(this.qtiVersion);\n      Assessment assessmentXml = assessmentHelper.readXMLDocument(is);\n      assessmentXml.setIdent(assessmentId);\n      assessmentXml.setTitle(assessment.getTitle());\n      assessmentHelper.setDescriptiveText(assessment.getDescription(),\n                                          assessmentXml);\n\n      authors =\n        assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.AUTHORS);\n      objectives = assessment.getAssessmentMetaDataByLabel(\n        AssessmentMetaDataIfc.OBJECTIVES);\n      keywords = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        KEYWORDS);\n      rubrics = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        RUBRICS);\n      bgColor = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        BGCOLOR);\n      bgImage = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        BGIMAGE);\n\n      if (authors != null)\n      {\n        assessmentXml.setFieldentry(\"AUTHORS\", authors);\n      }\n      else\n      {\n    \tAgentHelperImpl helper = new AgentHelperImpl();\n        String createdBy = assessment.getCreatedBy();\n        String eid = helper.getEidById(createdBy);\n        if (eid != null)\n        {\n          assessmentXml.setFieldentry(\"AUTHORS\", eid);\n        }\n        else\n        {\n          log.debug(\"\\n\\nNO AUTHORS\");\n        }\n      }\n\n      if (objectives != null)\n      {\n        assessmentXml.setFieldentry(\"ASSESSMENT_OBJECTIVES\", objectives);\n      }\n      if (keywords != null)\n      {\n        assessmentXml.setFieldentry(\"ASSESSMENT_KEYWORDS\", keywords);\n      }\n      if (rubrics != null)\n      {\n        assessmentXml.setFieldentry(\"ASSESSMENT_RUBRICS\", rubrics);\n      }\n      if (bgColor != null)\n      {\n        assessmentXml.setFieldentry(\"BGCOLOR\", bgColor);\n      }\n      if (bgImage != null)\n      {\n        assessmentXml.setFieldentry(\"BGIMG\", bgImage);\n      }\n\n      // fieldentry properties\n      EvaluationModelIfc evaluationModel = assessment.getEvaluationModel();\n      if (evaluationModel != null)\n      {\n        assessmentHelper.updateEvaluationModel(assessmentXml,\n                                               evaluationModel);\n      }\n      AssessmentFeedbackIfc assessmentFeedback = assessment.\n        getAssessmentFeedback();\n      if (assessmentFeedback != null)\n      {\n        assessmentHelper.updateFeedbackModel(assessmentXml, assessmentFeedback);\n      }\n      AssessmentAccessControlIfc assessmentAccessControl = assessment.\n        getAssessmentAccessControl();\n      if (assessmentAccessControl != null)\n      {\n        assessmentHelper.updateAccessControl(assessmentXml,\n                                             assessmentAccessControl);\n      }\n      Set securedIPAddressSet = (Set) assessment.getSecuredIPAddressSet();\n      if (securedIPAddressSet != null)\n      {\n        assessmentHelper.updateIPAddressSet(assessmentXml,\n                                             securedIPAddressSet);\n      }\n      /*\n      Set attachmentSet = (Set) assessment.getAssessmentAttachmentSet();\n      \n   \t  if (attachmentSet !=null || attachmentSet.size() != 0)    \t  \n      {\n        assessmentHelper.updateAttachmentSet(assessmentXml, attachmentSet);\n      }\n      */\n\n      assessmentHelper.updateMetaData(assessmentXml, assessment);\n\n      // sections\n      factory = new QTIHelperFactory();\n      SectionHelperIfc sectionHelper =\n        factory.getSectionHelperInstance(this.qtiVersion);\n      List sectionList = assessment.getSectionArraySorted();\n      for (int i = 0; i < sectionList.size(); i++)\n      {\n        SectionDataIfc section = (SectionDataIfc) sectionList.get(i);\n        InputStream sis =\n          ax.getTemplateInputStream(ax.SECTION);\n        Section sectionXml = sectionHelper.readXMLDocument(sis);\n        sectionXml.update(section);\n        addSection(assessmentXml, sectionXml);\n      }\n\n      return assessmentXml.getDocument();\n    }\n    catch (Exception e)\n    {\n      log.error(e.getMessage(), e);\n    }\n    return null;\n  }","id":22759,"modified_method":"/**\n   * Get an assessment in Document form.\n   *\n   * @param assessmentId the assessment's Id\n   * @param is a stream containing the unpopulated XML document\n   * @return the Document with the published assessment data\n   */\n  public Document getAssessment(String assessmentId, InputStream is)\n  {\n    try\n    {\n      String authors;\n      String objectives;\n      String keywords;\n      String rubrics;\n      String bgColor;\n      String bgImage;\n\n      AssessmentService assessmentService = new AssessmentService();\n      QTIHelperFactory factory = new QTIHelperFactory();\n\n      AssessmentFacade assessment =\n        assessmentService.getAssessment(assessmentId);\n      // convert assessment to document\n      AssessmentHelperIfc assessmentHelper =\n        factory.getAssessmentHelperInstance(this.qtiVersion);\n      Assessment assessmentXml = assessmentHelper.readXMLDocument(is);\n      assessmentXml.setIdent(assessmentId);\n      assessmentXml.setTitle(assessment.getTitle());\n      assessmentHelper.setDescriptiveText(assessment.getDescription(),\n                                          assessmentXml);\n\n      authors =\n        assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.AUTHORS);\n      objectives = assessment.getAssessmentMetaDataByLabel(\n        AssessmentMetaDataIfc.OBJECTIVES);\n      keywords = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        KEYWORDS);\n      rubrics = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        RUBRICS);\n      bgColor = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        BGCOLOR);\n      bgImage = assessment.getAssessmentMetaDataByLabel(AssessmentMetaDataIfc.\n        BGIMAGE);\n\n      if (authors != null)\n      {\n        assessmentXml.setFieldentry(\"AUTHORS\", authors);\n      }\n      else\n      {\n    \tAgentHelperImpl helper = new AgentHelperImpl();\n        String createdBy = assessment.getCreatedBy();\n        String eid = helper.getEidById(createdBy);\n        if (eid != null)\n        {\n          assessmentXml.setFieldentry(\"AUTHORS\", eid);\n        }\n        else\n        {\n          log.debug(\"\\n\\nNO AUTHORS\");\n        }\n      }\n\n      if (objectives != null)\n      {\n        assessmentXml.setFieldentry(\"ASSESSMENT_OBJECTIVES\", objectives);\n      }\n      if (keywords != null)\n      {\n        assessmentXml.setFieldentry(\"ASSESSMENT_KEYWORDS\", keywords);\n      }\n      if (rubrics != null)\n      {\n        assessmentXml.setFieldentry(\"ASSESSMENT_RUBRICS\", rubrics);\n      }\n      if (bgColor != null)\n      {\n        assessmentXml.setFieldentry(\"BGCOLOR\", bgColor);\n      }\n      if (bgImage != null)\n      {\n        assessmentXml.setFieldentry(\"BGIMG\", bgImage);\n      }\n\n      // fieldentry properties\n      EvaluationModelIfc evaluationModel = assessment.getEvaluationModel();\n      if (evaluationModel != null)\n      {\n        assessmentHelper.updateEvaluationModel(assessmentXml,\n                                               evaluationModel);\n      }\n      AssessmentFeedbackIfc assessmentFeedback = assessment.\n        getAssessmentFeedback();\n      if (assessmentFeedback != null)\n      {\n        assessmentHelper.updateFeedbackModel(assessmentXml, assessmentFeedback);\n      }\n      AssessmentAccessControlIfc assessmentAccessControl = assessment.\n        getAssessmentAccessControl();\n      if (assessmentAccessControl != null)\n      {\n        assessmentHelper.updateAccessControl(assessmentXml,\n                                             assessmentAccessControl);\n      }\n      Set securedIPAddressSet = (Set) assessment.getSecuredIPAddressSet();\n      if (securedIPAddressSet != null)\n      {\n        assessmentHelper.updateIPAddressSet(assessmentXml,\n                                             securedIPAddressSet);\n      }\n      \n      Set attachmentSet = (Set) assessment.getAssessmentAttachmentSet();\n      \n   \t  if (attachmentSet != null && attachmentSet.size() != 0)    \t  \n      {\n        assessmentHelper.updateAttachmentSet(assessmentXml, attachmentSet);\n      }\n\n      assessmentHelper.updateMetaData(assessmentXml, assessment);\n\n      // sections\n      factory = new QTIHelperFactory();\n      SectionHelperIfc sectionHelper =\n        factory.getSectionHelperInstance(this.qtiVersion);\n      List sectionList = assessment.getSectionArraySorted();\n      for (int i = 0; i < sectionList.size(); i++)\n      {\n        SectionDataIfc section = (SectionDataIfc) sectionList.get(i);\n        InputStream sis =\n          ax.getTemplateInputStream(ax.SECTION);\n        Section sectionXml = sectionHelper.readXMLDocument(sis);\n        sectionXml.update(section);\n        addSection(assessmentXml, sectionXml);\n      }\n\n      return assessmentXml.getDocument();\n    }\n    catch (Exception e)\n    {\n      log.error(e.getMessage(), e);\n    }\n    return null;\n  }","commit_id":"2da44cce359228867e6c5fec071fff7b327f2767","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    //log.info(\"ExportAssessmentListener\");\n    //log.info(\"ExportAssessmentListener processAction\");\n    String assessmentId = (String) cu.lookupParam(\"assessmentId\");\n    //log.info(\"ExportAssessmentListener assessmentId=\"+assessmentId);\n    XMLController xmlController = (XMLController) cu.lookupBean(\n                                          \"xmlController\");\n    //log.info(\"ExportAssessmentListener xmlController.setId(assessmentId)\");\n    xmlController.setId(assessmentId);\n// debug\n//    xmlController.setQtiVersion(2);\n    //log.info(\"xmlController.setQtiVersion(1)\");\n    xmlController.setQtiVersion(1);\n    //log.info(\"ExportAssessmentListener xmlController.displayAssessmentXml\");\n    xmlController.displayAssessmentXml();\n    //log.info(\"ExportAssessmentListener processAction done\");\n  }","id":22760,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    //log.info(\"ExportAssessmentListener\");\n    //log.info(\"ExportAssessmentListener processAction\");\n    String assessmentId = (String) ContextUtil.lookupParam(\"assessmentId\");\n    log.info(\"ExportAssessmentListener assessmentId=\"+assessmentId);\n    XMLController xmlController = (XMLController) ContextUtil.lookupBean(\n                                          \"xmlController\");\n    //log.info(\"ExportAssessmentListener xmlController.setId(assessmentId)\");\n    xmlController.setId(assessmentId);\n    // debug\n    // xmlController.setQtiVersion(2);\n    //log.info(\"xmlController.setQtiVersion(1)\");\n    xmlController.setQtiVersion(1);\n    //log.info(\"ExportAssessmentListener xmlController.displayAssessmentXml\");\n    xmlController.displayAssessmentXml();\n    //log.info(\"ExportAssessmentListener processAction done\");\n  }","commit_id":"2da44cce359228867e6c5fec071fff7b327f2767","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Update XML from perisistence\n   * @param item\n   */\n  public void update(ItemDataIfc item)\n  {\n    // metadata\n    setFieldentry(\"ITEM_OBJECTIVE\",\n      item.getItemMetaDataByLabel(ItemMetaDataIfc.OBJECTIVE ));\n    setFieldentry(\"ITEM_KEYWORD\",\n      item.getItemMetaDataByLabel(ItemMetaDataIfc.KEYWORD));\n    setFieldentry(\"ITEM_RUBRIC\", item.getItemMetaDataByLabel(ItemMetaDataIfc.RUBRIC ));\n \n    // set TIMEALLOWED and NUM_OF_ATTEMPTS for audio recording questions:\n    if (item.getDuration()!=null){\n    \tsetFieldentry(\"TIMEALLOWED\",\n    \t\t\titem.getDuration().toString()); \n    }\n    if (item.getTriesAllowed()!=null){\n    \tsetFieldentry(\"NUM_OF_ATTEMPTS\",\n    \t\t\titem.getTriesAllowed().toString());\n    }\n    //  rshastri: SAK-1824\n    if(item !=null &&(item.getTypeId().equals(TypeIfc.TRUE_FALSE) ||\n    \t\titem.getTypeId().equals(TypeIfc.MULTIPLE_CHOICE)||\n    \t\titem.getTypeId().equals(TypeIfc.MULTIPLE_CORRECT)) && item.getHasRationale() !=null)\n    {\t\n    \tsetFieldentry(\"hasRationale\", item.getHasRationale().toString());\n    }\n    //  rshastri: SAK-1824\n    // item data\n//    ItemHelper helper = new ItemHelper();\n    if (!this.isSurvey()) //surveys are unscored\n    {\n      helper.addMaxScore(item.getScore(), this);\n      helper.addMinScore(item.getScore(), this);\n    }\n\n    if(item !=null &&(item.getTypeId().equals(TypeIfc.FILL_IN_BLANK))) {\n    \tsetFieldentry(\"MUTUALLY_EXCLUSIVE\", item.getItemMetaDataByLabel(ItemMetaDataIfc.MUTUALLY_EXCLUSIVE_FOR_FIB ));\n       \tsetFieldentry(\"CASE_SENSITIVE\", item.getItemMetaDataByLabel(ItemMetaDataIfc.CASE_SENSITIVE_FOR_FIB ));\n    }\n    \n    String instruction = item.getInstruction();\n    if (this.isMatching() || this.isFIB() || this.isFIN())\n    {\n      if ( instruction != null)\n        {\n    \t  helper.setItemText(instruction, this);\n        }\n    }\n    ArrayList itemTexts = item.getItemTextArraySorted();\n\n    setItemTexts(itemTexts);\n    if (this.isTrueFalse()) // we know what the answers are (T/F)\n    {\n      Boolean isTrue = item.getIsTrue();\n      if (isTrue == null)\n        isTrue = Boolean.FALSE;\n      setAnswerTrueFalse(isTrue.booleanValue());\n    }\n    else\n    if (!this.isSurvey()) //answers for surveys are a stereotyped scale\n    {\n      setAnswers(itemTexts);\n    }\n    setFeedback(itemTexts);\n  }","id":22761,"modified_method":"/**\n   * Update XML from perisistence\n   * @param item\n   */\n  public void update(ItemDataIfc item)\n  {\n    // metadata\n    setFieldentry(\"ITEM_OBJECTIVE\",\n      item.getItemMetaDataByLabel(ItemMetaDataIfc.OBJECTIVE ));\n    setFieldentry(\"ITEM_KEYWORD\",\n      item.getItemMetaDataByLabel(ItemMetaDataIfc.KEYWORD));\n    setFieldentry(\"ITEM_RUBRIC\", item.getItemMetaDataByLabel(ItemMetaDataIfc.RUBRIC ));\n    setFieldentry(\"ATTACHMENT\", getAttachment(item));\n    \n    // set TIMEALLOWED and NUM_OF_ATTEMPTS for audio recording questions:\n    if (item.getDuration()!=null){\n    \tsetFieldentry(\"TIMEALLOWED\",\n    \t\t\titem.getDuration().toString()); \n    }\n    if (item.getTriesAllowed()!=null){\n    \tsetFieldentry(\"NUM_OF_ATTEMPTS\",\n    \t\t\titem.getTriesAllowed().toString());\n    }\n    //  rshastri: SAK-1824\n    if(item !=null &&(item.getTypeId().equals(TypeIfc.TRUE_FALSE) ||\n    \t\titem.getTypeId().equals(TypeIfc.MULTIPLE_CHOICE)||\n    \t\titem.getTypeId().equals(TypeIfc.MULTIPLE_CORRECT)) && item.getHasRationale() !=null)\n    {\t\n    \tsetFieldentry(\"hasRationale\", item.getHasRationale().toString());\n    }\n    //  rshastri: SAK-1824\n    // item data\n//    ItemHelper helper = new ItemHelper();\n    if (!this.isSurvey()) //surveys are unscored\n    {\n      helper.addMaxScore(item.getScore(), this);\n      helper.addMinScore(item.getScore(), this);\n    }\n\n    if(item !=null &&(item.getTypeId().equals(TypeIfc.FILL_IN_BLANK))) {\n    \tsetFieldentry(\"MUTUALLY_EXCLUSIVE\", item.getItemMetaDataByLabel(ItemMetaDataIfc.MUTUALLY_EXCLUSIVE_FOR_FIB ));\n       \tsetFieldentry(\"CASE_SENSITIVE\", item.getItemMetaDataByLabel(ItemMetaDataIfc.CASE_SENSITIVE_FOR_FIB ));\n    }\n    \n    String instruction = item.getInstruction();\n    if (this.isMatching() || this.isFIB() || this.isFIN())\n    {\n      if ( instruction != null)\n        {\n    \t  helper.setItemText(instruction, this);\n        }\n    }\n    ArrayList itemTexts = item.getItemTextArraySorted();\n\n    setItemTexts(itemTexts);\n    if (this.isTrueFalse()) // we know what the answers are (T/F)\n    {\n      Boolean isTrue = item.getIsTrue();\n      if (isTrue == null)\n        isTrue = Boolean.FALSE;\n      setAnswerTrueFalse(isTrue.booleanValue());\n    }\n    else\n    if (!this.isSurvey()) //answers for surveys are a stereotyped scale\n    {\n      setAnswers(itemTexts);\n    }\n    setFeedback(itemTexts);\n  }","commit_id":"2da44cce359228867e6c5fec071fff7b327f2767","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Update XML from persistence\n   * @param section\n   */\n  public void update(SectionDataIfc section)\n  {\n    // identity\n    setIdent(\"\" + section.getSectionId());\n    setTitle(section.getTitle());\n    // metadata\n    // Where the heck do these come from?  Looks like not being used.\n    // If required we could extract keywords by weighting, and\n    // set rubrics identical to description, or, we could eliminate these from XML.\n\n    // well, we can add metadata from users' input - lydial \n    \n    setFieldentry(\"SECTION_OBJECTIVE\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.OBJECTIVES));\n    setFieldentry(\"SECTION_KEYWORD\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.KEYWORDS));\n    setFieldentry(\"SECTION_RUBRIC\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.RUBRICS));\n    setFieldentry(\"ATTACHMENT\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.ATTACHMENTS));\n    \n    // items\n    ArrayList items = section.getItemArray();\n    addItems(items);\n  }","id":22762,"modified_method":"/**\n   * Update XML from persistence\n   * @param section\n   */\n  public void update(SectionDataIfc section)\n  {\n    // identity\n    setIdent(\"\" + section.getSectionId());\n    setTitle(section.getTitle());\n    // metadata\n    // Where the heck do these come from?  Looks like not being used.\n    // If required we could extract keywords by weighting, and\n    // set rubrics identical to description, or, we could eliminate these from XML.\n\n    // well, we can add metadata from users' input - lydial \n    \n    setFieldentry(\"SECTION_OBJECTIVE\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.OBJECTIVES));\n    setFieldentry(\"SECTION_KEYWORD\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.KEYWORDS));\n    setFieldentry(\"SECTION_RUBRIC\", section.getSectionMetaDataByLabel(SectionMetaDataIfc.RUBRICS));\n    setFieldentry(\"ATTACHMENT\", getAttachment(section));\n    \n    // items\n    ArrayList items = section.getItemArray();\n    addItems(items);\n  }","commit_id":"2da44cce359228867e6c5fec071fff7b327f2767","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public synchronized AmazonEC2 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        if (account == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 access_key defined for s3 gateway\");\n        }\n        if (key == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 secret_key defined for s3 gateway\");\n        }\n\n        this.client = new AmazonEC2Client(new BasicAWSCredentials(account, key), clientConfiguration);\n\n        if (componentSettings.get(\"ec2.endpoint\") != null) {\n            client.setEndpoint(componentSettings.get(\"ec2.endpoint\"));\n        } else if (componentSettings.get(\"region\") != null) {\n            String endpoint;\n            String region = componentSettings.get(\"region\");\n            if (\"us-east\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-east-1.amazonaws.com\";\n            } else if (\"us-east-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-east-1.amazonaws.com\";\n            } else if (\"us-west\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-west-1.amazonaws.com\";\n            } else if (\"us-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-west-1.amazonaws.com\";\n            } else if (\"ap-southeast\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-southeast-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (\"eu-west\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.eu-west-1.amazonaws.com\";\n            } else if (\"eu-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.eu-west-1.amazonaws.com\";\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            client.setEndpoint(endpoint);\n        }\n\n        return this.client;\n\n    }","id":22763,"modified_method":"public synchronized AmazonEC2 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        if (account == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 access_key defined for s3 gateway\");\n        }\n        if (key == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 secret_key defined for s3 gateway\");\n        }\n\n        this.client = new AmazonEC2Client(new BasicAWSCredentials(account, key), clientConfiguration);\n\n        if (componentSettings.get(\"ec2.endpoint\") != null) {\n            client.setEndpoint(componentSettings.get(\"ec2.endpoint\"));\n        } else if (componentSettings.get(\"region\") != null) {\n            String endpoint;\n            String region = componentSettings.get(\"region\");\n            if (\"us-east\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-east-1.amazonaws.com\";\n            } else if (\"us-east-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-east-1.amazonaws.com\";\n            } else if (\"us-west\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-west-1.amazonaws.com\";\n            } else if (\"us-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.us-west-1.amazonaws.com\";\n            } else if (\"ap-southeast\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-southeast-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (\"eu-west\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.eu-west-1.amazonaws.com\";\n            } else if (\"eu-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"ec2.eu-west-1.amazonaws.com\";\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            if (endpoint != null) {\n                client.setEndpoint(endpoint);\n            }\n        }\n\n        return this.client;\n\n    }","commit_id":"05283c7f6dae821570e006e722614eb44a984547","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public synchronized AmazonS3 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        if (account == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 access_key defined for s3 gateway\");\n        }\n        if (key == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 secret_key defined for s3 gateway\");\n        }\n\n        this.client = new AmazonS3Client(new BasicAWSCredentials(account, key), clientConfiguration);\n\n        if (componentSettings.get(\"s3.endpoint\") != null) {\n            client.setEndpoint(componentSettings.get(\"s3.endpoint\"));\n        } else if (componentSettings.get(\"region\") != null) {\n            String endpoint;\n            String region = componentSettings.get(\"region\");\n            if (\"us-east\".equals(region.toLowerCase())) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-east-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-west\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"us-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"ap-southeast\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-southeast-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"eu-west\".equals(region.toLowerCase())) {\n                endpoint = null; // no specific endpoint for EU (still can be used for region)\n            } else if (\"eu-west-1\".equals(region.toLowerCase())) {\n                endpoint = null; // no specific endpoint for EU (still can be used for region)\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            client.setEndpoint(endpoint);\n        }\n\n        return this.client;\n    }","id":22764,"modified_method":"public synchronized AmazonS3 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        if (account == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 access_key defined for s3 gateway\");\n        }\n        if (key == null) {\n            throw new ElasticSearchIllegalArgumentException(\"No s3 secret_key defined for s3 gateway\");\n        }\n\n        this.client = new AmazonS3Client(new BasicAWSCredentials(account, key), clientConfiguration);\n\n        if (componentSettings.get(\"s3.endpoint\") != null) {\n            client.setEndpoint(componentSettings.get(\"s3.endpoint\"));\n        } else if (componentSettings.get(\"region\") != null) {\n            String endpoint;\n            String region = componentSettings.get(\"region\");\n            if (\"us-east\".equals(region.toLowerCase())) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-east-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-west\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"us-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"ap-southeast\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-southeast-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"eu-west\".equals(region.toLowerCase())) {\n                endpoint = null; // no specific endpoint for EU (still can be used for region)\n            } else if (\"eu-west-1\".equals(region.toLowerCase())) {\n                endpoint = null; // no specific endpoint for EU (still can be used for region)\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            if (endpoint != null) {\n                client.setEndpoint(endpoint);\n            }\n        }\n\n        return this.client;\n    }","commit_id":"05283c7f6dae821570e006e722614eb44a984547","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public synchronized AmazonEC2 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        String proxyHost = componentSettings.get(\"proxy_host\");\n        if (proxyHost != null) {\n            String portString = componentSettings.get(\"proxy_port\", \"80\");\n            Integer proxyPort;\n            try {\n                proxyPort = Integer.parseInt(portString, 10);\n            } catch (NumberFormatException ex) {\n                throw new ElasticSearchIllegalArgumentException(\"The configured proxy port value [\" + portString + \"] is invalid\", ex);\n            }\n            clientConfiguration.withProxyHost(proxyHost).setProxyPort(proxyPort);\n        }\n\n        AWSCredentialsProvider credentials;\n\n        if (account == null && key == null) {\n            credentials = new AWSCredentialsProviderChain(\n                    new EnvironmentVariableCredentialsProvider(),\n                    new SystemPropertiesCredentialsProvider(),\n                    new InstanceProfileCredentialsProvider()\n            );\n        } else {\n            credentials = new AWSCredentialsProviderChain(\n                    new StaticCredentialsProvider(new BasicAWSCredentials(account, key))\n            );\n        }\n\n        this.client = new AmazonEC2Client(credentials, clientConfiguration);\n\n        if (componentSettings.get(\"ec2.endpoint\") != null) {\n            client.setEndpoint(componentSettings.get(\"ec2.endpoint\"));\n        } else if (componentSettings.get(\"region\") != null) {\n            String region = componentSettings.get(\"region\").toLowerCase();\n            String endpoint;\n            if (region.equals(\"us-east-1\") || region.equals(\"us-east\")) {\n                endpoint = \"ec2.us-east-1.amazonaws.com\";\n            } else if (region.equals(\"us-west\") || region.equals(\"us-west-1\")) {\n                endpoint = \"ec2.us-west-1.amazonaws.com\";\n            } else if (region.equals(\"us-west-2\")) {\n                endpoint = \"ec2.us-west-2.amazonaws.com\";\n            } else if (region.equals(\"ap-southeast\")) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (region.equals(\"ap-southeast-1\")) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (region.equals(\"ap-northeast\") || region.equals(\"ap-northeast-1\")) {\n                endpoint = \"ec2.ap-northeast-1.amazonaws.com\";\n            } else if (region.equals(\"eu-west\") || region.equals(\"eu-west-1\")) {\n                endpoint = \"ec2.eu-west-1.amazonaws.com\";\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            if (endpoint != null) {\n                client.setEndpoint(endpoint);\n            }\n        }\n\n        return this.client;\n\n    }","id":22765,"modified_method":"public synchronized AmazonEC2 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        String proxyHost = componentSettings.get(\"proxy_host\");\n        if (proxyHost != null) {\n            String portString = componentSettings.get(\"proxy_port\", \"80\");\n            Integer proxyPort;\n            try {\n                proxyPort = Integer.parseInt(portString, 10);\n            } catch (NumberFormatException ex) {\n                throw new ElasticSearchIllegalArgumentException(\"The configured proxy port value [\" + portString + \"] is invalid\", ex);\n            }\n            clientConfiguration.withProxyHost(proxyHost).setProxyPort(proxyPort);\n        }\n\n        AWSCredentialsProvider credentials;\n\n        if (account == null && key == null) {\n            credentials = new AWSCredentialsProviderChain(\n                    new EnvironmentVariableCredentialsProvider(),\n                    new SystemPropertiesCredentialsProvider(),\n                    new InstanceProfileCredentialsProvider()\n            );\n        } else {\n            credentials = new AWSCredentialsProviderChain(\n                    new StaticCredentialsProvider(new BasicAWSCredentials(account, key))\n            );\n        }\n\n        this.client = new AmazonEC2Client(credentials, clientConfiguration);\n\n        if (componentSettings.get(\"ec2.endpoint\") != null) {\n            String endpoint = componentSettings.get(\"ec2.endpoint\");\n            logger.debug(\"using explicit ec2 region [{}]\", endpoint);\n            client.setEndpoint(endpoint);\n        } else if (componentSettings.get(\"region\") != null) {\n            String region = componentSettings.get(\"region\").toLowerCase();\n            String endpoint;\n            if (region.equals(\"us-east-1\") || region.equals(\"us-east\")) {\n                endpoint = \"ec2.us-east-1.amazonaws.com\";\n            } else if (region.equals(\"us-west\") || region.equals(\"us-west-1\")) {\n                endpoint = \"ec2.us-west-1.amazonaws.com\";\n            } else if (region.equals(\"us-west-2\")) {\n                endpoint = \"ec2.us-west-2.amazonaws.com\";\n            } else if (region.equals(\"ap-southeast\")) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (region.equals(\"ap-southeast-1\")) {\n                endpoint = \"ec2.ap-southeast-1.amazonaws.com\";\n            } else if (region.equals(\"ap-northeast\") || region.equals(\"ap-northeast-1\")) {\n                endpoint = \"ec2.ap-northeast-1.amazonaws.com\";\n            } else if (region.equals(\"eu-west\") || region.equals(\"eu-west-1\")) {\n                endpoint = \"ec2.eu-west-1.amazonaws.com\";\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            if (endpoint != null) {\n                logger.debug(\"using ec2 region [{}], with endpoint [{}]\", region, endpoint);\n                client.setEndpoint(endpoint);\n            }\n        }\n\n        return this.client;\n\n    }","commit_id":"89048479335ab4459acaa3ec0fc1cc3b9ebae188","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public synchronized AmazonS3 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        String proxyHost = componentSettings.get(\"proxy_host\");\n        if (proxyHost != null) {\n            String portString = componentSettings.get(\"proxy_port\", \"80\");\n            Integer proxyPort;\n            try {\n                proxyPort = Integer.parseInt(portString, 10);\n            } catch (NumberFormatException ex) {\n                throw new ElasticSearchIllegalArgumentException(\"The configured proxy port value [\" + portString + \"] is invalid\", ex);\n            }\n            clientConfiguration.withProxyHost(proxyHost).setProxyPort(proxyPort);\n        }\n\n        AWSCredentialsProvider credentials;\n\n        if (account == null && key == null) {\n            credentials = new AWSCredentialsProviderChain(\n                    new EnvironmentVariableCredentialsProvider(),\n                    new SystemPropertiesCredentialsProvider(),\n                    new InstanceProfileCredentialsProvider()\n            );\n        } else {\n            credentials = new AWSCredentialsProviderChain(\n                    new StaticCredentialsProvider(new BasicAWSCredentials(account, key))\n            );\n        }\n        this.client = new AmazonS3Client(credentials, clientConfiguration);\n\n        if (componentSettings.get(\"s3.endpoint\") != null) {\n            client.setEndpoint(componentSettings.get(\"s3.endpoint\"));\n        } else if (componentSettings.get(\"region\") != null) {\n            String endpoint;\n            String region = componentSettings.get(\"region\");\n            if (\"us-east\".equals(region.toLowerCase())) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-east-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-west\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"us-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"us-west-2\".equals(region.toLowerCase())) {\n                endpoint = \"s3-us-west-2.amazonaws.com\";\n            } else if (\"ap-southeast\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-southeast-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-northeast\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-northeast-1.amazonaws.com\";\n            } else if (\"ap-northeast-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-ap-northeast-1.amazonaws.com\";\n            } else if (\"eu-west\".equals(region.toLowerCase())) {\n                endpoint = \"s3-eu-west-1.amazonaws.com\";\n            } else if (\"eu-west-1\".equals(region.toLowerCase())) {\n                endpoint = \"s3-eu-west-1.amazonaws.com\";\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            if (endpoint != null) {\n                client.setEndpoint(endpoint);\n            }\n        }\n\n        return this.client;\n    }","id":22766,"modified_method":"public synchronized AmazonS3 client() {\n        if (client != null) {\n            return client;\n        }\n\n        ClientConfiguration clientConfiguration = new ClientConfiguration();\n        String protocol = componentSettings.get(\"protocol\", \"http\").toLowerCase();\n        if (\"http\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTP);\n        } else if (\"https\".equals(protocol)) {\n            clientConfiguration.setProtocol(Protocol.HTTPS);\n        } else {\n            throw new ElasticSearchIllegalArgumentException(\"No protocol supported [\" + protocol + \"], can either be [http] or [https]\");\n        }\n        String account = componentSettings.get(\"access_key\", settings.get(\"cloud.account\"));\n        String key = componentSettings.get(\"secret_key\", settings.get(\"cloud.key\"));\n\n        String proxyHost = componentSettings.get(\"proxy_host\");\n        if (proxyHost != null) {\n            String portString = componentSettings.get(\"proxy_port\", \"80\");\n            Integer proxyPort;\n            try {\n                proxyPort = Integer.parseInt(portString, 10);\n            } catch (NumberFormatException ex) {\n                throw new ElasticSearchIllegalArgumentException(\"The configured proxy port value [\" + portString + \"] is invalid\", ex);\n            }\n            clientConfiguration.withProxyHost(proxyHost).setProxyPort(proxyPort);\n        }\n\n        AWSCredentialsProvider credentials;\n\n        if (account == null && key == null) {\n            credentials = new AWSCredentialsProviderChain(\n                    new EnvironmentVariableCredentialsProvider(),\n                    new SystemPropertiesCredentialsProvider(),\n                    new InstanceProfileCredentialsProvider()\n            );\n        } else {\n            credentials = new AWSCredentialsProviderChain(\n                    new StaticCredentialsProvider(new BasicAWSCredentials(account, key))\n            );\n        }\n        this.client = new AmazonS3Client(credentials, clientConfiguration);\n\n        if (componentSettings.get(\"s3.endpoint\") != null) {\n            String endpoint = componentSettings.get(\"s3.endpoint\");\n            logger.debug(\"using explicit s3 region [{}]\", endpoint);\n            client.setEndpoint(endpoint);\n        } else if (componentSettings.get(\"region\") != null) {\n            String endpoint;\n            String region = componentSettings.get(\"region\").toLowerCase();\n            if (\"us-east\".equals(region)) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-east-1\".equals(region)) {\n                endpoint = \"s3.amazonaws.com\";\n            } else if (\"us-west\".equals(region)) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"us-west-1\".equals(region)) {\n                endpoint = \"s3-us-west-1.amazonaws.com\";\n            } else if (\"us-west-2\".equals(region)) {\n                endpoint = \"s3-us-west-2.amazonaws.com\";\n            } else if (\"ap-southeast\".equals(region)) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-southeast-1\".equals(region)) {\n                endpoint = \"s3-ap-southeast-1.amazonaws.com\";\n            } else if (\"ap-northeast\".equals(region)) {\n                endpoint = \"s3-ap-northeast-1.amazonaws.com\";\n            } else if (\"ap-northeast-1\".equals(region)) {\n                endpoint = \"s3-ap-northeast-1.amazonaws.com\";\n            } else if (\"eu-west\".equals(region)) {\n                endpoint = \"s3-eu-west-1.amazonaws.com\";\n            } else if (\"eu-west-1\".equals(region)) {\n                endpoint = \"s3-eu-west-1.amazonaws.com\";\n            } else {\n                throw new ElasticSearchIllegalArgumentException(\"No automatic endpoint could be derived from region [\" + region + \"]\");\n            }\n            if (endpoint != null) {\n                logger.debug(\"using s3 region [{}], with endpoint [{}]\", region, endpoint);\n                client.setEndpoint(endpoint);\n            }\n        }\n\n        return this.client;\n    }","commit_id":"89048479335ab4459acaa3ec0fc1cc3b9ebae188","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private boolean doMatchWithTheType(final PsiType type, MatchContext context) {\n    if (type instanceof PsiClassType) {\n      PsiClass clazz = ((PsiClassType)type).resolve();\n\n      return checkClass(clazz, context);\n    } else {\n      if (type!=null) {\n        return delegate.doMatch(type.getPresentableText(),context);\n      } else {\n        return false;\n      }\n    }\n  }","id":22767,"modified_method":"private boolean doMatchWithTheType(final PsiType type, MatchContext context) {\n    if (type instanceof PsiClassType) {\n      PsiClass clazz = ((PsiClassType)type).resolve();\n\n      if (clazz!=null) return checkClass(clazz, context);\n    }\n\n    if (type!=null) {\n      final String presentableText = type.getPresentableText();\n      boolean result = delegate.doMatch(presentableText,context);\n\n      if (!result && type instanceof PsiArrayType && ((PsiArrayType)type).getComponentType() instanceof PsiClassType) {\n        PsiClass clazz = ((PsiClassType)((PsiArrayType)type).getComponentType()).resolve();\n\n        if (clazz!=null) { // presentable text for array is not qualified!\n          result = delegate.doMatch(clazz.getQualifiedName()+\"[]\",context);\n        }\n      }\n      return result;\n    } else {\n      return false;\n    }\n  }","commit_id":"646e21c9f1e2a86b317e61d9c8c4112f91211a8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int eatTypedVarCondition(int index,\n                                          String pattern,\n                                          StringBuffer miscBuffer,\n                                          MatchVariableConstraint constraint) {\n    if (index<pattern.length() && pattern.charAt(index)==':') {\n      ++index;\n\n      final char ch = pattern.charAt(index);\n\n      if (ch=='+' || ch=='*' ) {\n        // this is type axis navigation relation\n        switch(ch) {\n          case '+':\n            constraint.setStrictlyWithinHierarchy(true);\n            break;\n          case '*':\n            constraint.setWithinHierarchy(true);\n            break;\n        }\n\n        ++index;\n      }\n\n      if (pattern.charAt(index)=='[') {\n        // eat complete condition\n\n        miscBuffer.setLength(0);\n        for(++index;pattern.charAt(index)!=']';++index) {\n          miscBuffer.append(pattern.charAt(index));\n        }\n        ++index;\n        parseCondition(constraint,miscBuffer.toString());\n      } else {\n        // eat reg exp constraint\n        miscBuffer.setLength(0);\n        index = handleRegExp(index, pattern, miscBuffer, constraint);\n      }\n    }\n    return index;\n  }","id":22768,"modified_method":"private static int eatTypedVarCondition(int index,\n                                          String pattern,\n                                          StringBuffer miscBuffer,\n                                          MatchVariableConstraint constraint) {\n    if (index<pattern.length() && pattern.charAt(index)==':') {\n      ++index;\n\n      final char ch = pattern.charAt(index);\n\n      if (ch=='+' || ch=='*' ) {\n        // this is type axis navigation relation\n        switch(ch) {\n          case '+':\n            constraint.setStrictlyWithinHierarchy(true);\n            break;\n          case '*':\n            constraint.setWithinHierarchy(true);\n            break;\n        }\n\n        ++index;\n      }\n\n      if (pattern.charAt(index)=='[') {\n        // eat complete condition\n\n        miscBuffer.setLength(0);\n        for(++index;pattern.charAt(index)!=']' || pattern.charAt(index-1)=='\\\\';++index) {\n          miscBuffer.append(pattern.charAt(index));\n        }\n        ++index;\n        parseCondition(constraint,miscBuffer.toString());\n      } else {\n        // eat reg exp constraint\n        miscBuffer.setLength(0);\n        index = handleRegExp(index, pattern, miscBuffer, constraint);\n      }\n    }\n    return index;\n  }","commit_id":"646e21c9f1e2a86b317e61d9c8c4112f91211a8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSearchExpressions() {\n    assertFalse(\"subexpr match\",findMatchesCount(s2,s3)==0);\n    assertEquals(\"search for new \",findMatchesCount(s10,s11),0);\n    assertEquals(\"search for anonymous classes\",findMatchesCount(s12,s13),1);\n    // expr in definition intiialiZer\n    assertEquals(\n      \"expr in def initializer\",\n      findMatchesCount(s53,s54),\n      3\n    );\n\n    // a.class expression search\n    assertEquals(\n      \"a.class pattern\",\n      findMatchesCount(s55,s56),\n      1\n    );\n\n    String complexCode = \"interface I { void b(); } interface I2 extends I {} class I3 extends I {} \" +\n        \"class A implements I2 {  void b() {} } class B implements I3 { void b() {}} \" +\n        \"I2 a; I3 b; a.b(); b.b(); b.b(); A c; B d; c.b(); d.b(); d.b(); \";\n\n    String exprTypePattern1 = \"'t:[exprtype( I2 )].b();\";\n    String exprTypePattern2 = \"'t:[!exprtype( I2 )].b();\";\n\n    String exprTypePattern3 = \"'t:[exprtype( *I2 )].b();\";\n    String exprTypePattern4 = \"'t:[!exprtype( *I2 )].b();\";\n\n    assertEquals(\n      \"expr type condition\",\n      findMatchesCount(complexCode,exprTypePattern1),\n      1\n    );\n\n    assertEquals(\n      \"expr type condition 2\",\n      findMatchesCount(complexCode,exprTypePattern2),\n      5\n    );\n\n    assertEquals(\n      \"expr type condition 3\",\n      findMatchesCount(complexCode,exprTypePattern3),\n      2\n    );\n\n    assertEquals(\n      \"expr type condition 4\",\n      findMatchesCount(complexCode,exprTypePattern4),\n      4\n    );\n\n    assertEquals(\n      \"no smart detection of search target\",\n      findMatchesCount(\"processInheritors(1,2,3,4); processInheritors(1,2,3); processInheritors(1,2,3,4,5,6);\",\"'instance?.processInheritors('_param1{1,6});\"),\n      3\n    );\n\n    String arrays = \"int[] a = new int[20];\\n\" +\n                    \"byte[] b = new byte[30]\";\n    String arrayPattern = \"new int[$a$]\";\n    assertEquals(\n      \"Improper array search\",\n      1,\n      findMatchesCount(arrays,arrayPattern)\n    );\n\n    String someCode = \"a *= 2; a+=2;\";\n    String otherCode = \"a *= 2;\";\n\n    assertEquals(\n      \"Improper *= 2 search\",\n      1,\n      findMatchesCount(someCode,otherCode)\n    );\n\n    String s1 = \"Thread t = new Thread(\\\"my thread\\\",\\\"my another thread\\\") {\\n\" +\n                \"    public void run() {\\n\" +\n                \"        // do stuff\\n\" +\n                \"    }\\n\" +\n                \"}\";\n    String s2 = \"new Thread('args*) { '_Other* }\";\n\n    assertEquals(\n      \"Find inner class parameters\",\n      2,\n      findMatchesCount(s1,s2)\n    );\n\n    String s3 = \"Thread t = new Thread(\\\"my thread\\\") {\\n\" +\n                \"    public void run() {\\n\" +\n                \"        // do stuff\\n\" +\n                \"    }\\n\" +\n                \"};\";\n    String s4 = \"new Thread($args$)\";\n\n    assertEquals(\n      \"Find inner class by new\",\n      1,\n      findMatchesCount(s3,s4)\n    );\n\n    String s5 = \"class A {\\n\" +\n                \"public static <T> T[] copy(T[] array, Class<T> aClass) {\\n\" +\n                \"    int i = (int)0;\\n\" +\n                \"    int b = (int)0;\\n\" +\n                \"    return (T[])array.clone();\\n\" +\n                \"  }\\n\" +\n                \"}\";\n    String s6 = \"($T$[])$expr$\";\n\n    assertEquals(\n      \"Find cast to array\",\n      1,\n      findMatchesCount(s5,s6)\n    );\n  }","id":22769,"modified_method":"public void testSearchExpressions() {\n    assertFalse(\"subexpr match\",findMatchesCount(s2,s3)==0);\n    assertEquals(\"search for new \",findMatchesCount(s10,s11),0);\n    assertEquals(\"search for anonymous classes\",findMatchesCount(s12,s13),1);\n    // expr in definition intiialiZer\n    assertEquals(\n      \"expr in def initializer\",\n      findMatchesCount(s53,s54),\n      3\n    );\n\n    // a.class expression search\n    assertEquals(\n      \"a.class pattern\",\n      findMatchesCount(s55,s56),\n      1\n    );\n\n    String complexCode = \"interface I { void b(); } interface I2 extends I {} class I3 extends I {} \" +\n        \"class A implements I2 {  void b() {} } class B implements I3 { void b() {}} \" +\n        \"I2 a; I3 b; a.b(); b.b(); b.b(); A c; B d; c.b(); d.b(); d.b(); \";\n\n    String exprTypePattern1 = \"'t:[exprtype( I2 )].b();\";\n    String exprTypePattern2 = \"'t:[!exprtype( I2 )].b();\";\n\n    String exprTypePattern3 = \"'t:[exprtype( *I2 )].b();\";\n    String exprTypePattern4 = \"'t:[!exprtype( *I2 )].b();\";\n\n    assertEquals(\n      \"expr type condition\",\n      findMatchesCount(complexCode,exprTypePattern1),\n      1\n    );\n\n    assertEquals(\n      \"expr type condition 2\",\n      findMatchesCount(complexCode,exprTypePattern2),\n      5\n    );\n\n    assertEquals(\n      \"expr type condition 3\",\n      findMatchesCount(complexCode,exprTypePattern3),\n      2\n    );\n\n    assertEquals(\n      \"expr type condition 4\",\n      findMatchesCount(complexCode,exprTypePattern4),\n      4\n    );\n\n    assertEquals(\n      \"no smart detection of search target\",\n      findMatchesCount(\"processInheritors(1,2,3,4); processInheritors(1,2,3); processInheritors(1,2,3,4,5,6);\",\"'instance?.processInheritors('_param1{1,6});\"),\n      3\n    );\n\n    String arrays = \"int[] a = new int[20];\\n\" +\n                    \"byte[] b = new byte[30]\";\n    String arrayPattern = \"new int[$a$]\";\n    assertEquals(\n      \"Improper array search\",\n      1,\n      findMatchesCount(arrays,arrayPattern)\n    );\n\n    String someCode = \"a *= 2; a+=2;\";\n    String otherCode = \"a *= 2;\";\n\n    assertEquals(\n      \"Improper *= 2 search\",\n      1,\n      findMatchesCount(someCode,otherCode)\n    );\n\n    String s1 = \"Thread t = new Thread(\\\"my thread\\\",\\\"my another thread\\\") {\\n\" +\n                \"    public void run() {\\n\" +\n                \"        // do stuff\\n\" +\n                \"    }\\n\" +\n                \"}\";\n    String s2 = \"new Thread('args*) { '_Other* }\";\n\n    assertEquals(\n      \"Find inner class parameters\",\n      2,\n      findMatchesCount(s1,s2)\n    );\n\n    String s3 = \"Thread t = new Thread(\\\"my thread\\\") {\\n\" +\n                \"    public void run() {\\n\" +\n                \"        // do stuff\\n\" +\n                \"    }\\n\" +\n                \"};\";\n    String s4 = \"new Thread($args$)\";\n\n    assertEquals(\n      \"Find inner class by new\",\n      1,\n      findMatchesCount(s3,s4)\n    );\n\n    String s5 = \"class A {\\n\" +\n                \"public static <T> T[] copy(T[] array, Class<T> aClass) {\\n\" +\n                \"    int i = (int)0;\\n\" +\n                \"    int b = (int)0;\\n\" +\n                \"    return (T[])array.clone();\\n\" +\n                \"  }\\n\" +\n                \"}\";\n    String s6 = \"($T$[])$expr$\";\n\n    assertEquals(\n      \"Find cast to array\",\n      1,\n      findMatchesCount(s5,s6)\n    );\n\n    String s7 = \"import java.math.BigDecimal;\\n\" +\n                \"\\n\" +\n                \"public class Prorator {\\n\" +\n                \"        public void prorate(BigDecimal[] array) {\\n\" +\n                \"                // do nothing\\n\" +\n                \"        }\\n\" +\n                \"        public void prorate2(java.math.BigDecimal[] array) {\\n\" +\n                \"                // do nothing\\n\" +\n                \"        }\\n\" +\n                \"        public void prorate(BigDecimal bd) {\\n\" +\n                \"                // do nothing\\n\" +\n                \"        }\\n\" +\n                \"\\n\" +\n                \"        public static void main(String[] args) {\\n\" +\n                \"                BigDecimal[] something = new BigDecimal[2];\\n\" +\n                \"                java.math.BigDecimal[] something2 = new BigDecimal[2];\\n\" +\n                \"                something[0] = new BigDecimal(1.0);\\n\" +\n                \"                something[1] = new BigDecimal(1.0);\\n\" +\n                \"\\n\" +\n                \"                Prorator prorator = new Prorator();\\n\" +\n                \"\\n\" +\n                \"// ---------------------------------------------------\\n\" +\n                \"// the line below should've been found, in my opinion.\\n\" +\n                \"// --------------------------------------------------\\n\" +\n                \"                prorator.prorate(something);\\n\" +\n                \"                prorator.prorate(something2);\\n\" +\n\n                \"                prorator.prorate(something[0]);\\n\" +\n                \"                prorator.prorate(something[1]);\\n\" +\n                \"                prorator.prorate(something[0]);\\n\" +\n                \"        }\\n\" +\n                \"}\";\n    String s8 = \"'_Instance.'_MethodCall:[regex( prorate )]('_Param:[exprtype( BigDecimal\\\\[\\\\] )]) \";\n\n    assertEquals(\n      \"Find method call with array for parameter expr type\",\n      2,\n      findMatchesCount(s7,s8,true)\n    );\n  }","commit_id":"646e21c9f1e2a86b317e61d9c8c4112f91211a8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String buildErrorString(PsiElement location){\n        final PsiExpression expression = (PsiExpression) location;\n        final PsiType type = expression.getType();\n        final String text = type.getPresentableText();\n        return InspectionGadgetsBundle.message(\"hibernate.resource.opened.not.closed.problem.descriptor\", text);\n    }","id":22770,"modified_method":"public String buildErrorString(PsiElement location){\n        final PsiExpression expression = (PsiExpression) location;\n        final PsiType type = expression.getType();\n        final String text;\n        if (type == null) {\n            text = \"\";\n        } else {\n            text = type.getPresentableText();\n        }\n        return InspectionGadgetsBundle.message(\n                \"hibernate.resource.opened.not.closed.problem.descriptor\",\n                text);\n    }","commit_id":"6427dfd4dd91a217a70b472b7989322e2c5b0185","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(@NotNull PsiMethodCallExpression expression){\n            super.visitMethodCallExpression(expression);\n            if(!isHibernateFactoryMethod(expression)) {\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(!(parent instanceof PsiAssignmentExpression)) {\n                registerError(expression);\n                return;\n            }\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) parent;\n            final PsiExpression lhs = assignment.getLExpression();\n            if(!(lhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement referent =\n                    ((PsiReference) lhs).resolve();\n            if(referent == null || !(referent instanceof PsiVariable)) {\n                return;\n            }\n            final PsiVariable boundVariable = (PsiVariable) referent;\n\n            PsiElement currentContext = expression;\n            while(true){\n                final PsiTryStatement tryStatement =\n                        PsiTreeUtil.getParentOfType(currentContext,\n                                                    PsiTryStatement.class);\n                if(tryStatement == null) {\n                    registerError(expression);\n                    return;\n                }\n                if(resourceIsOpenedInTryAndClosedInFinally(tryStatement,\n                                                           expression,\n                                                           boundVariable)) {\n                    return;\n                }\n                currentContext = tryStatement;\n            }\n        }","id":22771,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression){\n            super.visitMethodCallExpression(expression);\n            if(!isHibernateFactoryMethod(expression)){\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(!(parent instanceof PsiAssignmentExpression)) {\n                final PsiType type = expression.getType();\n                if(type != null){\n                    registerError(expression);\n                }\n                return;\n            }\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) parent;\n            final PsiExpression lhs = assignment.getLExpression();\n            if(!(lhs instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression)lhs;\n            final PsiElement referent = referenceExpression.resolve();\n            if(referent == null || !(referent instanceof PsiVariable)){\n                return;\n            }\n            final PsiVariable boundVariable = (PsiVariable) referent;\n            PsiElement currentContext = expression;\n            while(true){\n                final PsiTryStatement tryStatement =\n                        PsiTreeUtil.getParentOfType(currentContext,\n                                PsiTryStatement.class);\n                if(tryStatement == null){\n                    final PsiType type = expression.getType();\n                    if(type != null){\n                        registerError(expression);\n                    }\n                    return;\n                }\n                if(resourceIsOpenedInTryAndClosedInFinally(\n                        tryStatement, expression, boundVariable)){\n                    return;\n                }\n                currentContext = tryStatement;\n            }\n        }","commit_id":"6427dfd4dd91a217a70b472b7989322e2c5b0185","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(@NotNull PsiMethodCallExpression call){\n            if(containsClose){\n                return;\n            }\n            super.visitMethodCallExpression(call);\n            final PsiReferenceExpression methodExpression =\n                    call.getMethodExpression();\n            if(methodExpression == null){\n                return;\n            }\n            final String methodName = methodExpression.getReferenceName();\n            if(!HardcodedMethodConstants.CLOSE.equals(methodName)) {\n              return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if(!(qualifier instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiElement referent =\n                    ((PsiReference) qualifier).resolve();\n            if(referent == null)\n            {\n                return;\n            }\n            if(referent.equals(elementToClose)){\n                containsClose = true;\n            }\n        }","id":22772,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression call){\n            if(containsClose){\n                return;\n            }\n            super.visitMethodCallExpression(call);\n            final PsiReferenceExpression methodExpression =\n                    call.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if(!HardcodedMethodConstants.CLOSE.equals(methodName)){\n                return;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if(!(qualifier instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression)qualifier;\n            final PsiElement referent = referenceExpression.resolve();\n            if(referent == null){\n                return;\n            }\n            if(referent.equals(elementToClose)){\n                containsClose = true;\n            }\n        }","commit_id":"6427dfd4dd91a217a70b472b7989322e2c5b0185","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendTypeString(StringBuilder buffer, final PsiType type, PsiElement context) {\n    if (type != null) {\n      JavaDocInfoGenerator.generateType(buffer, type, context);\n    }\n    else {\n      buffer.append(GrModifier.DEF);\n    }\n  }","id":22773,"modified_method":"public static void appendTypeString(StringBuilder buffer, final PsiType type, PsiElement context) {\n    if (type != null) {\n      JavaDocInfoGenerator.generateType(buffer, type, context);\n    }\n    else {\n      buffer.append(GrModifier.DEF);\n    }\n  }","commit_id":"049f3bd8fd3df4a2d943babacd1aabeaba399783","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getQuickNavigateInfo(PsiElement element, PsiElement originalElement) {\n    if (element instanceof GrVariable || element instanceof GrImplicitVariable) {\n      StringBuilder buffer = new StringBuilder();\n      PsiVariable variable = (PsiVariable)element;\n\n      if (originalElement instanceof GrVariableDeclaration && ((GrVariableDeclaration)originalElement).getVariables().length > 1) {\n        for (GrVariable var :((GrVariableDeclaration)originalElement).getVariables()) {\n          generateVariableInfo(originalElement, buffer, var);\n          buffer.append(\"\\n\\n\");\n        }\n      }\n      else {\n        generateVariableInfo(originalElement, buffer, variable);\n      }\n      return buffer.toString();\n    }\n    else if (element instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression)element;\n      StringBuilder buffer = new StringBuilder();\n      PsiType type = null;\n      if (refExpr.getParent() instanceof GrAssignmentExpression) {\n        GrAssignmentExpression assignment = (GrAssignmentExpression)refExpr.getParent();\n        if (refExpr.equals(assignment.getLValue())) {\n          GrExpression rvalue = assignment.getRValue();\n          if (rvalue != null) {\n            type = rvalue.getType();\n          }\n        }\n      }\n      appendTypeString(buffer, type, originalElement);\n      buffer.append(\" \");\n      buffer.append(refExpr.getReferenceName());\n      return buffer.toString();\n    }\n    else if (element instanceof PsiMethod) {\n      StringBuilder buffer = new StringBuilder();\n      PsiMethod method = (PsiMethod)element;\n      if (method instanceof GrGdkMethod) {\n        buffer.append(\"[GDK] \");\n      }\n      else {\n        PsiClass hisClass = method.getContainingClass();\n        if (hisClass != null) {\n          String qName = hisClass.getQualifiedName();\n          if (qName != null) {\n            buffer.append(qName).append(\"\\n\");\n          }\n        }\n      }\n\n      PsiSubstitutor substitutor = calcSubstitutor(originalElement);\n      if (!method.isConstructor()) {\n        final PsiType substituted = substitutor.substitute(PsiUtil.getSmartReturnType(method));\n        appendTypeString(buffer, substituted, originalElement);\n        buffer.append(\" \");\n      }\n      buffer.append(method.getName()).append(\" \");\n      buffer.append(\"(\");\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        if (i > 0) buffer.append(\", \");\n        if (parameter instanceof GrParameter) {\n          GroovyPresentationUtil.appendParameterPresentation((GrParameter)parameter, substitutor, false, buffer);\n        }\n        else {\n          PsiType type = parameter.getType();\n          appendTypeString(buffer, substitutor.substitute(type), originalElement);\n          buffer.append(\" \");\n          buffer.append(parameter.getName());\n        }\n      }\n      buffer.append(\")\");\n      final PsiClassType[] referencedTypes = method.getThrowsList().getReferencedTypes();\n      if (referencedTypes.length > 0) {\n        buffer.append(\"\\nthrows \");\n        for (PsiClassType referencedType : referencedTypes) {\n          appendTypeString(buffer, referencedType, originalElement);\n          buffer.append(\", \");\n        }\n        buffer.delete(buffer.length() - 2, buffer.length());\n      }\n      return buffer.toString();\n    }\n    else if (element instanceof GrTypeDefinition) {\n      return generateClassInfo((GrTypeDefinition)element);\n    }\n\n    return null;\n  }","id":22774,"modified_method":"@Nullable\n  public String getQuickNavigateInfo(PsiElement element, PsiElement originalElement) {\n    if (element instanceof GrVariable || element instanceof GrImplicitVariable) {\n      StringBuilder buffer = new StringBuilder();\n      PsiVariable variable = (PsiVariable)element;\n\n      if (originalElement instanceof GrVariableDeclaration && ((GrVariableDeclaration)originalElement).getVariables().length > 1) {\n        for (GrVariable var :((GrVariableDeclaration)originalElement).getVariables()) {\n          generateVariableInfo(originalElement, buffer, var);\n          buffer.append(\"\\n\\n\");\n        }\n      }\n      else {\n        generateVariableInfo(originalElement, buffer, variable);\n      }\n      return buffer.toString();\n    }\n    else if (element instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression)element;\n      StringBuilder buffer = new StringBuilder();\n      PsiType type = null;\n      if (refExpr.getParent() instanceof GrAssignmentExpression) {\n        GrAssignmentExpression assignment = (GrAssignmentExpression)refExpr.getParent();\n        if (refExpr.equals(assignment.getLValue())) {\n          GrExpression rvalue = assignment.getRValue();\n          if (rvalue != null) {\n            type = rvalue.getType();\n          }\n        }\n      }\n      appendTypeString(buffer, type, originalElement);\n      buffer.append(\" \");\n      buffer.append(refExpr.getReferenceName());\n      return buffer.toString();\n    }\n    else if (element instanceof PsiMethod) {\n      StringBuilder buffer = new StringBuilder();\n      PsiMethod method = (PsiMethod)element;\n      if (method instanceof GrGdkMethod) {\n        buffer.append(\"[GDK] \");\n      }\n      else {\n        PsiClass hisClass = method.getContainingClass();\n        if (hisClass != null) {\n          String qName = hisClass.getQualifiedName();\n          if (qName != null) {\n            buffer.append(qName).append(\"\\n\");\n          }\n        }\n      }\n\n      PsiSubstitutor substitutor = calcSubstitutor(originalElement);\n      if (!method.isConstructor()) {\n        final PsiType substituted = substitutor.substitute(PsiUtil.getSmartReturnType(method));\n        appendTypeString(buffer, substituted, originalElement);\n        buffer.append(\" \");\n      }\n      buffer.append(method.getName()).append(\" \");\n      buffer.append(\"(\");\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        if (i > 0) buffer.append(\", \");\n        if (parameter instanceof GrParameter) {\n          GroovyPresentationUtil.appendParameterPresentation((GrParameter)parameter, substitutor, TypePresentation.LINK, buffer);\n        }\n        else {\n          PsiType type = parameter.getType();\n          appendTypeString(buffer, substitutor.substitute(type), originalElement);\n          buffer.append(\" \");\n          buffer.append(parameter.getName());\n        }\n      }\n      buffer.append(\")\");\n      final PsiClassType[] referencedTypes = method.getThrowsList().getReferencedTypes();\n      if (referencedTypes.length > 0) {\n        buffer.append(\"\\nthrows \");\n        for (PsiClassType referencedType : referencedTypes) {\n          appendTypeString(buffer, referencedType, originalElement);\n          buffer.append(\", \");\n        }\n        buffer.delete(buffer.length() - 2, buffer.length());\n      }\n      return buffer.toString();\n    }\n    else if (element instanceof GrTypeDefinition) {\n      return generateClassInfo((GrTypeDefinition)element);\n    }\n\n    return null;\n  }","commit_id":"049f3bd8fd3df4a2d943babacd1aabeaba399783","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendParameterText(PsiParameter param, PsiSubstitutor substitutor, StringBuilder buffer) {\n    if (param instanceof GrParameter) {\n      GrParameter grParam = (GrParameter)param;\n      GroovyPresentationUtil.appendParameterPresentation(grParam, substitutor, true, buffer);\n\n      final GrExpression initializer = grParam.getInitializerGroovy();\n      if (initializer != null) {\n        buffer.append(\" = \").append(initializer.getText());\n      }\n      else if (grParam.isOptional()) {\n        buffer.append(\" = null\");\n      }\n    } else {\n      PsiType t = param.getType();\n      PsiType paramType = substitutor.substitute(t);\n      buffer.append(paramType.getPresentableText());\n      String name = param.getName();\n      if (name != null) {\n        buffer.append(\" \");\n        buffer.append(name);\n      }\n    }\n  }","id":22775,"modified_method":"private static void appendParameterText(PsiParameter param, PsiSubstitutor substitutor, StringBuilder buffer) {\n    if (param instanceof GrParameter) {\n      GrParameter grParam = (GrParameter)param;\n      GroovyPresentationUtil.appendParameterPresentation(grParam, substitutor, TypePresentation.PRESENTABLE, buffer);\n\n      final GrExpression initializer = grParam.getInitializerGroovy();\n      if (initializer != null) {\n        buffer.append(\" = \").append(initializer.getText());\n      }\n      else if (grParam.isOptional()) {\n        buffer.append(\" = null\");\n      }\n    } else {\n      PsiType t = param.getType();\n      PsiType paramType = substitutor.substitute(t);\n      buffer.append(paramType.getPresentableText());\n      String name = param.getName();\n      if (name != null) {\n        buffer.append(\" \");\n        buffer.append(name);\n      }\n    }\n  }","commit_id":"049f3bd8fd3df4a2d943babacd1aabeaba399783","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void appendParameterPresentation(GrParameter parameter,\n                                                 PsiSubstitutor substitutor,\n                                                 boolean presentable,\n                                                 StringBuilder builder) {\n    for (PsiAnnotation annotation : parameter.getModifierList().getAnnotations()) {\n      builder.append(annotation.getText()).append(' ');\n    }\n\n    PsiType type = parameter.getTypeGroovy();\n    if (type != null) {\n      type = substitutor.substitute(type);\n      builder.append(presentable ? type.getPresentableText() : type.getCanonicalText()).append(' ').append(parameter.getName());\n    }\n    else {\n      builder.append(parameter.getName());\n      final Set<String> structural = Collections.synchronizedSet(new LinkedHashSet<String>());\n      ReferencesSearch.search(parameter).forEach(new Processor<PsiReference>() {\n        public boolean process(PsiReference ref) {\n          PsiElement parent = ref.getElement().getParent();\n          if (parent instanceof GrReferenceExpression) {\n\n            if (structural.size() >= CONSTRAINTS_NUMBER) { //handle too many constraints\n              structural.add(\"...\");\n              return false;\n            }\n\n            StringBuilder builder1 = new StringBuilder();\n            builder1.append(((GrReferenceElement)parent).getReferenceName());\n            PsiType[] argTypes = PsiUtil.getArgumentTypes(parent, true);\n            if (argTypes != null) {\n              builder1.append(\"(\");\n              if (argTypes.length > 0) {\n                builder1.append(argTypes.length);\n                if (argTypes.length == 1) {\n                  builder1.append(\" arg\");\n                }\n                else {\n                  builder1.append(\" args\");\n                }\n              }\n              builder1.append(')');\n            }\n\n            structural.add(builder1.toString());\n          }\n\n          return true;\n        }\n      });\n\n      if (!structural.isEmpty()) {\n        builder.append(\".\");\n        String[] array = ArrayUtil.toStringArray(structural);\n        if (array.length > 1) builder.append(\"[\");\n        for (int i = 0; i < array.length; i++) {\n          if (i > 0) builder.append(\", \");\n          builder.append(array[i]);\n        }\n        if (array.length > 1) builder.append(\"]\");\n      }\n    }\n  }","id":22776,"modified_method":"public static void appendParameterPresentation(GrParameter parameter,\n                                                 PsiSubstitutor substitutor,\n                                                 TypePresentation typePresentation,\n                                                 StringBuilder builder) {\n    for (PsiAnnotation annotation : parameter.getModifierList().getAnnotations()) {\n      builder.append(annotation.getText()).append(' ');\n    }\n\n    PsiType type = parameter.getTypeGroovy();\n    type = substitutor.substitute(type);\n\n    if (typePresentation == TypePresentation.LINK) {\n      GroovyDocumentationProvider.appendTypeString(builder, type, parameter);\n      builder.append(' ').append(parameter.getName());\n      return;\n    }\n\n    if (type != null) {\n      if (typePresentation == TypePresentation.PRESENTABLE) {\n        builder.append(type.getPresentableText()).append(' ').append(parameter.getName());\n      }\n      else if (typePresentation == TypePresentation.CANONICAL) {\n        builder.append(type.getCanonicalText()).append(' ').append(parameter.getName());\n      }\n    }\n    else {\n      builder.append(parameter.getName());\n      final Set<String> structural = Collections.synchronizedSet(new LinkedHashSet<String>());\n      ReferencesSearch.search(parameter).forEach(new Processor<PsiReference>() {\n        public boolean process(PsiReference ref) {\n          PsiElement parent = ref.getElement().getParent();\n          if (parent instanceof GrReferenceExpression) {\n\n            if (structural.size() >= CONSTRAINTS_NUMBER) { //handle too many constraints\n              structural.add(\"...\");\n              return false;\n            }\n\n            StringBuilder builder1 = new StringBuilder();\n            builder1.append(((GrReferenceElement)parent).getReferenceName());\n            PsiType[] argTypes = PsiUtil.getArgumentTypes(parent, true);\n            if (argTypes != null) {\n              builder1.append(\"(\");\n              if (argTypes.length > 0) {\n                builder1.append(argTypes.length);\n                if (argTypes.length == 1) {\n                  builder1.append(\" arg\");\n                }\n                else {\n                  builder1.append(\" args\");\n                }\n              }\n              builder1.append(')');\n            }\n\n            structural.add(builder1.toString());\n          }\n\n          return true;\n        }\n      });\n\n      if (!structural.isEmpty()) {\n        builder.append(\".\");\n        String[] array = ArrayUtil.toStringArray(structural);\n        if (array.length > 1) builder.append(\"[\");\n        for (int i = 0; i < array.length; i++) {\n          if (i > 0) builder.append(\", \");\n          builder.append(array[i]);\n        }\n        if (array.length > 1) builder.append(\"]\");\n      }\n    }\n  }","commit_id":"049f3bd8fd3df4a2d943babacd1aabeaba399783","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendTypeString(StringBuilder buffer, PsiType type) {\n    if (type != null) {\n      buffer.append(StringUtil.escapeXml(type.getCanonicalText()));\n    }\n    else {\n      buffer.append(GrModifier.DEF);\n    }\n  }","id":22777,"modified_method":"private static void appendTypeString(StringBuilder buffer, PsiType type, PsiSubstitutor substitutor) {\n    if (type != null) {\n      buffer.append(StringUtil.escapeXml(substitutor.substitute(type).getCanonicalText()));\n    }\n    else {\n      buffer.append(GrModifier.DEF);\n    }\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private static String generateClassInfo(PsiClass aClass) {\n    StringBuilder buffer = new StringBuilder();\n    GroovyFile file = (GroovyFile)aClass.getContainingFile();\n\n    String packageName = file.getPackageName();\n    if (packageName.length() > 0) {\n      buffer.append(packageName).append(\"\\n\");\n    }\n\n    final String classString =\n      aClass.isInterface() ? \"interface\" : aClass instanceof PsiTypeParameter ? \"type parameter\" : aClass.isEnum() ? \"enum\" : \"class\";\n    buffer.append(classString).append(\" \");\n\n    buffer.append(aClass.getName());\n\n    if (aClass.hasTypeParameters()) {\n      PsiTypeParameter[] typeParameters = aClass.getTypeParameters();\n\n      buffer.append(\"<\");\n\n      for (int i = 0; i < typeParameters.length; i++) {\n        if (i > 0) buffer.append(\", \");\n\n        PsiTypeParameter tp = typeParameters[i];\n\n        buffer.append(tp.getName());\n\n        PsiClassType[] refs = tp.getExtendsListTypes();\n\n        if (refs.length > 0) {\n          buffer.append(\" extends \");\n\n          for (int j = 0; j < refs.length; j++) {\n            if (j > 0) buffer.append(\" & \");\n            appendTypeString(buffer, refs[j]);\n          }\n        }\n      }\n\n      buffer.append(\">\");\n    }\n\n    PsiClassType[] refs = aClass.getExtendsListTypes();\n    if (refs.length > 0 || !aClass.isInterface() && !\"java.lang.Object\".equals(aClass.getQualifiedName())) {\n      buffer.append(\" extends \");\n      if (refs.length == 0) {\n        buffer.append(\"Object\");\n      }\n      else {\n        for (int i = 0; i < refs.length; i++) {\n          if (i > 0) buffer.append(\", \");\n          appendTypeString(buffer, refs[i]);\n        }\n      }\n    }\n\n    refs = aClass.getImplementsListTypes();\n    if (refs.length > 0) {\n      buffer.append(\"\\nimplements \");\n      for (int i = 0; i < refs.length; i++) {\n        if (i > 0) buffer.append(\", \");\n        appendTypeString(buffer, refs[i]);\n\n      }\n    }\n\n    return buffer.toString();\n  }","id":22778,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  private static String generateClassInfo(PsiClass aClass) {\n    StringBuilder buffer = new StringBuilder();\n    GroovyFile file = (GroovyFile)aClass.getContainingFile();\n\n    String packageName = file.getPackageName();\n    if (packageName.length() > 0) {\n      buffer.append(packageName).append(\"\\n\");\n    }\n\n    final String classString =\n      aClass.isInterface() ? \"interface\" : aClass instanceof PsiTypeParameter ? \"type parameter\" : aClass.isEnum() ? \"enum\" : \"class\";\n    buffer.append(classString).append(\" \");\n\n    buffer.append(aClass.getName());\n\n    if (aClass.hasTypeParameters()) {\n      PsiTypeParameter[] typeParameters = aClass.getTypeParameters();\n\n      buffer.append(\"<\");\n\n      for (int i = 0; i < typeParameters.length; i++) {\n        if (i > 0) buffer.append(\", \");\n\n        PsiTypeParameter tp = typeParameters[i];\n\n        buffer.append(tp.getName());\n\n        PsiClassType[] refs = tp.getExtendsListTypes();\n\n        if (refs.length > 0) {\n          buffer.append(\" extends \");\n\n          for (int j = 0; j < refs.length; j++) {\n            if (j > 0) buffer.append(\" & \");\n            appendTypeString(buffer, refs[j], PsiSubstitutor.EMPTY);\n          }\n        }\n      }\n\n      buffer.append(\">\");\n    }\n\n    PsiClassType[] refs = aClass.getExtendsListTypes();\n    if (refs.length > 0 || !aClass.isInterface() && !\"java.lang.Object\".equals(aClass.getQualifiedName())) {\n      buffer.append(\" extends \");\n      if (refs.length == 0) {\n        buffer.append(\"Object\");\n      }\n      else {\n        for (int i = 0; i < refs.length; i++) {\n          if (i > 0) buffer.append(\", \");\n          appendTypeString(buffer, refs[i], PsiSubstitutor.EMPTY);\n        }\n      }\n    }\n\n    refs = aClass.getImplementsListTypes();\n    if (refs.length > 0) {\n      buffer.append(\"\\nimplements \");\n      for (int i = 0; i < refs.length; i++) {\n        if (i > 0) buffer.append(\", \");\n        appendTypeString(buffer, refs[i], PsiSubstitutor.EMPTY);\n\n      }\n    }\n\n    return buffer.toString();\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getQuickNavigateInfo(PsiElement element, PsiElement originalElement) {\n    if (element instanceof GrVariable) {\n      GrVariable variable = (GrVariable)element;\n      StringBuilder buffer = new StringBuilder();\n      if (element instanceof GrField) {\n        final PsiClass parentClass = ((GrField)element).getContainingClass();\n        if (parentClass != null) {\n          buffer.append(JavaDocUtil.getShortestClassName(parentClass, element));\n          newLine(buffer);\n        }\n        generateModifiers(buffer, element);\n      }\n      final PsiType type = variable.getDeclaredType();\n      appendTypeString(buffer, type);\n      buffer.append(\" \");\n      buffer.append(variable.getName());\n      newLine(buffer);\n\n      PsiReference ref;\n      while (originalElement != null && ((ref = originalElement.getReference()) == null || ref.resolve() == null)) {\n        originalElement = originalElement.getParent();\n      }\n\n      appendInferredType(originalElement, buffer);\n\n      return buffer.toString();\n    }\n    else if (element instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression)element;\n      StringBuilder buffer = new StringBuilder();\n      PsiType type = null;\n      if (refExpr.getParent() instanceof GrAssignmentExpression) {\n        GrAssignmentExpression assignment = (GrAssignmentExpression)refExpr.getParent();\n        if (refExpr.equals(assignment.getLValue())) {\n          GrExpression rvalue = assignment.getRValue();\n          if (rvalue != null) {\n            type = rvalue.getType();\n          }\n        }\n      }\n      appendTypeString(buffer, type);\n      buffer.append(\" \");\n      buffer.append(refExpr.getReferenceName());\n      return buffer.toString();\n    }\n    else if (element instanceof PsiMethod) {\n      StringBuilder buffer = new StringBuilder();\n      PsiMethod method = (PsiMethod)element;\n      if (method instanceof GrGdkMethod) {\n        buffer.append(\"[GDK] \");\n      }\n      else {\n        PsiClass hisClass = method.getContainingClass();\n        if (hisClass != null) {\n          String qName = hisClass.getQualifiedName();\n          if (qName != null) {\n            buffer.append(qName).append(\"\\n\");\n          }\n        }\n      }\n\n      if (!method.isConstructor()) {\n        appendTypeString(buffer, PsiUtil.getSmartReturnType(method));\n        buffer.append(\" \");\n      }\n      buffer.append(method.getName()).append(\" \");\n      buffer.append(\"(\");\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        if (i > 0) buffer.append(\", \");\n        if (parameter instanceof GrParameter) {\n          buffer.append(GroovyPresentationUtil.getParameterPresentation((GrParameter)parameter, PsiSubstitutor.EMPTY));\n        }\n        else {\n          PsiType type = parameter.getType();\n          appendTypeString(buffer, type);\n          buffer.append(\" \");\n          buffer.append(parameter.getName());\n        }\n      }\n      buffer.append(\")\");\n      final PsiClassType[] referencedTypes = method.getThrowsList().getReferencedTypes();\n      if (referencedTypes.length > 0) {\n        buffer.append(\"\\nthrows \");\n        for (PsiClassType referencedType : referencedTypes) {\n          appendTypeString(buffer, referencedType);\n          buffer.append(\", \");\n        }\n        buffer.delete(buffer.length() - 2, buffer.length());\n      }\n      return buffer.toString();\n    }\n    else if (element instanceof GrTypeDefinition) {\n      return generateClassInfo((GrTypeDefinition)element);\n    }\n\n    //todo\n    return null;\n  }","id":22779,"modified_method":"@Nullable\n  public String getQuickNavigateInfo(PsiElement element, PsiElement originalElement) {\n    if (element instanceof GrVariable) {\n      GrVariable variable = (GrVariable)element;\n      StringBuilder buffer = new StringBuilder();\n      if (element instanceof GrField) {\n        final PsiClass parentClass = ((GrField)element).getContainingClass();\n        if (parentClass != null) {\n          buffer.append(JavaDocUtil.getShortestClassName(parentClass, element));\n          newLine(buffer);\n        }\n        generateModifiers(buffer, element);\n      }\n      final PsiType type = variable.getDeclaredType();\n      appendTypeString(buffer, type, calcSubstitutor(originalElement));\n      buffer.append(\" \");\n      buffer.append(variable.getName());\n      newLine(buffer);\n\n      PsiReference ref;\n      while (originalElement != null && ((ref = originalElement.getReference()) == null || ref.resolve() == null)) {\n        originalElement = originalElement.getParent();\n      }\n\n      appendInferredType(originalElement, buffer);\n\n      return buffer.toString();\n    }\n    else if (element instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression)element;\n      StringBuilder buffer = new StringBuilder();\n      PsiType type = null;\n      if (refExpr.getParent() instanceof GrAssignmentExpression) {\n        GrAssignmentExpression assignment = (GrAssignmentExpression)refExpr.getParent();\n        if (refExpr.equals(assignment.getLValue())) {\n          GrExpression rvalue = assignment.getRValue();\n          if (rvalue != null) {\n            type = rvalue.getType();\n          }\n        }\n      }\n      appendTypeString(buffer, type, PsiSubstitutor.EMPTY);\n      buffer.append(\" \");\n      buffer.append(refExpr.getReferenceName());\n      return buffer.toString();\n    }\n    else if (element instanceof PsiMethod) {\n      StringBuilder buffer = new StringBuilder();\n      PsiMethod method = (PsiMethod)element;\n      if (method instanceof GrGdkMethod) {\n        buffer.append(\"[GDK] \");\n      }\n      else {\n        PsiClass hisClass = method.getContainingClass();\n        if (hisClass != null) {\n          String qName = hisClass.getQualifiedName();\n          if (qName != null) {\n            buffer.append(qName).append(\"\\n\");\n          }\n        }\n      }\n\n      PsiSubstitutor substitutor = calcSubstitutor(originalElement);\n      if (!method.isConstructor()) {\n        appendTypeString(buffer, PsiUtil.getSmartReturnType(method), substitutor);\n        buffer.append(\" \");\n      }\n      buffer.append(method.getName()).append(\" \");\n      buffer.append(\"(\");\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        if (i > 0) buffer.append(\", \");\n        if (parameter instanceof GrParameter) {\n          buffer.append(GroovyPresentationUtil.getParameterPresentation((GrParameter)parameter, substitutor, false));\n        }\n        else {\n          PsiType type = parameter.getType();\n          appendTypeString(buffer, type, substitutor);\n          buffer.append(\" \");\n          buffer.append(parameter.getName());\n        }\n      }\n      buffer.append(\")\");\n      final PsiClassType[] referencedTypes = method.getThrowsList().getReferencedTypes();\n      if (referencedTypes.length > 0) {\n        buffer.append(\"\\nthrows \");\n        for (PsiClassType referencedType : referencedTypes) {\n          appendTypeString(buffer, referencedType, PsiSubstitutor.EMPTY);\n          buffer.append(\", \");\n        }\n        buffer.delete(buffer.length() - 2, buffer.length());\n      }\n      return buffer.toString();\n    }\n    else if (element instanceof GrTypeDefinition) {\n      return generateClassInfo((GrTypeDefinition)element);\n    }\n\n    //todo\n    return null;\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendInferredType(PsiElement originalElement, StringBuilder buffer) {\n    if (originalElement != null) {\n      if (originalElement instanceof GrReferenceExpression) {\n        final PsiType inferredType = ((GrReferenceExpression)originalElement).getType();\n        if (inferredType != null) {\n          buffer.append(\"[inferred type] \");\n          appendTypeString(buffer, inferredType);\n          return;\n        }\n      }\n    }\n    buffer.append(\"[cannot infer type]\");\n  }","id":22780,"modified_method":"private static void appendInferredType(PsiElement originalElement, StringBuilder buffer) {\n    if (originalElement != null) {\n      if (originalElement instanceof GrReferenceExpression) {\n        final PsiType inferredType = ((GrReferenceExpression)originalElement).getType();\n        if (inferredType != null) {\n          buffer.append(\"[inferred type] \");\n          appendTypeString(buffer, inferredType, PsiSubstitutor.EMPTY);\n          return;\n        }\n      }\n    }\n    buffer.append(\"[cannot infer type]\");\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void appendParameterText(PsiParameter parm, PsiSubstitutor substitutor, StringBuffer buffer) {\n    if (parm instanceof GrParameter) {\n      GrParameter grParam = (GrParameter)parm;\n      buffer.append(GroovyPresentationUtil.getParameterPresentation(grParam, substitutor));\n\n      final GrExpression initializer = grParam.getDefaultInitializer();\n      if (initializer != null) {\n        buffer.append(\" = \").append(initializer.getText());\n      }\n      else if (grParam.isOptional()) {\n        buffer.append(\" = null\");\n      }\n    } else {\n      PsiType t = parm.getType();\n      PsiType paramType = substitutor.substitute(t);\n      buffer.append(paramType.getPresentableText());\n      String name = parm.getName();\n      if (name != null) {\n        buffer.append(\" \");\n        buffer.append(name);\n      }\n    }\n  }","id":22781,"modified_method":"private static void appendParameterText(PsiParameter parm, PsiSubstitutor substitutor, StringBuffer buffer) {\n    if (parm instanceof GrParameter) {\n      GrParameter grParam = (GrParameter)parm;\n      buffer.append(GroovyPresentationUtil.getParameterPresentation(grParam, substitutor, true));\n\n      final GrExpression initializer = grParam.getDefaultInitializer();\n      if (initializer != null) {\n        buffer.append(\" = \").append(initializer.getText());\n      }\n      else if (grParam.isOptional()) {\n        buffer.append(\" = null\");\n      }\n    } else {\n      PsiType t = parm.getType();\n      PsiType paramType = substitutor.substitute(t);\n      buffer.append(paramType.getPresentableText());\n      String name = parm.getName();\n      if (name != null) {\n        buffer.append(\" \");\n        buffer.append(name);\n      }\n    }\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getParameterPresentation(GrParameter parameter, PsiSubstitutor substitutor) {\n    StringBuilder builder = new StringBuilder();\n    PsiType type = parameter.getTypeGroovy();\n    if (type != null) {\n      type = substitutor.substitute(type);\n      return builder.append(type.getPresentableText()).append(\" \").append(parameter.getName()).toString();\n    } else {\n      builder.append(parameter.getName());\n      final Set<String> structural = Collections.synchronizedSet(new LinkedHashSet<String>());\n      ReferencesSearch.search(parameter).forEach(new Processor<PsiReference>() {\n        public boolean process(PsiReference ref) {\n          PsiElement parent = ref.getElement().getParent();\n          if (parent instanceof GrReferenceExpression) {\n\n            if (structural.size() >= CONSTRAINTS_NUMBER) { //handle too many constraints\n              structural.add(\"...\");\n              return false;\n            }\n\n            StringBuilder builder1 = new StringBuilder();\n            builder1.append(((GrReferenceElement) parent).getReferenceName());\n            PsiType[] argTypes = PsiUtil.getArgumentTypes(parent, true);\n            if (argTypes != null) {\n              builder1.append(\"(\");\n              if (argTypes.length > 0) {\n                builder1.append(argTypes.length);\n                if (argTypes.length == 1) {\n                  builder1.append(\" arg\");\n                } else {\n                  builder1.append(\" args\");\n                }\n              }\n              builder1.append(\")\");\n            }\n\n            structural.add(builder1.toString());\n          }\n\n          return true;\n        }\n      });\n\n      if (!structural.isEmpty()) {\n        builder.append(\".\");\n        String[] array = ArrayUtil.toStringArray(structural);\n        if (array.length> 1) builder.append(\"[\");\n        for (int i = 0; i < array.length; i++) {\n          if (i > 0) builder.append(\", \");\n          builder.append(array[i]);\n        }\n        if (array.length> 1) builder.append(\"]\");\n      }\n      return builder.toString();\n    }\n  }","id":22782,"modified_method":"public static String getParameterPresentation(GrParameter parameter, PsiSubstitutor substitutor, boolean presentable) {\n    StringBuilder builder = new StringBuilder();\n    PsiType type = parameter.getTypeGroovy();\n    if (type != null) {\n      type = substitutor.substitute(type);\n      return builder.append(presentable ? type.getPresentableText() : type.getCanonicalText()).append(\" \").append(parameter.getName()).toString();\n    } else {\n      builder.append(parameter.getName());\n      final Set<String> structural = Collections.synchronizedSet(new LinkedHashSet<String>());\n      ReferencesSearch.search(parameter).forEach(new Processor<PsiReference>() {\n        public boolean process(PsiReference ref) {\n          PsiElement parent = ref.getElement().getParent();\n          if (parent instanceof GrReferenceExpression) {\n\n            if (structural.size() >= CONSTRAINTS_NUMBER) { //handle too many constraints\n              structural.add(\"...\");\n              return false;\n            }\n\n            StringBuilder builder1 = new StringBuilder();\n            builder1.append(((GrReferenceElement) parent).getReferenceName());\n            PsiType[] argTypes = PsiUtil.getArgumentTypes(parent, true);\n            if (argTypes != null) {\n              builder1.append(\"(\");\n              if (argTypes.length > 0) {\n                builder1.append(argTypes.length);\n                if (argTypes.length == 1) {\n                  builder1.append(\" arg\");\n                } else {\n                  builder1.append(\" args\");\n                }\n              }\n              builder1.append(\")\");\n            }\n\n            structural.add(builder1.toString());\n          }\n\n          return true;\n        }\n      });\n\n      if (!structural.isEmpty()) {\n        builder.append(\".\");\n        String[] array = ArrayUtil.toStringArray(structural);\n        if (array.length> 1) builder.append(\"[\");\n        for (int i = 0; i < array.length; i++) {\n          if (i > 0) builder.append(\", \");\n          builder.append(array[i]);\n        }\n        if (array.length> 1) builder.append(\"]\");\n      }\n      return builder.toString();\n    }\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public static String generateMethodInfo(PsiMethod method) {\n    StringBuilder buffer = new StringBuilder();\n\n    PsiClass parentClass = method.getContainingClass();\n\n    if (parentClass != null) {\n      buffer.append(JavaDocUtil.getShortestClassName(parentClass, method));\n      newLine(buffer);\n    }\n\n    generateModifiers(buffer, method);\n\n    PsiTypeParameter[] params = method.getTypeParameters();\n\n    if (params.length > 0) {\n      buffer.append(\"&lt;\");\n      for (int i = 0; i < params.length; i++) {\n        PsiTypeParameter param = params[i];\n\n        buffer.append(param.getName());\n\n        PsiClassType[] extendees = param.getExtendsList().getReferencedTypes();\n\n        if (extendees.length > 0) {\n          buffer.append(\" extends \");\n\n          for (int j = 0; j < extendees.length; j++) {\n            JavaDocInfoGenerator.generateType(buffer, extendees[j], method, false);\n\n            if (j < extendees.length - 1) {\n              buffer.append(\" & \");\n            }\n          }\n        }\n\n        if (i < params.length - 1) {\n          buffer.append(\", \");\n        }\n      }\n      buffer.append(\"&gt; \");\n    }\n\n    if (method.getReturnType() != null) {\n      JavaDocInfoGenerator.generateType(buffer, method.getReturnType(), method, false);\n      buffer.append(\" \");\n    }\n\n    buffer.append(method.getName());\n\n    buffer.append(\" (\");\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    for (int i = 0; i < parms.length; i++) {\n      PsiParameter parm = parms[i];\n      JavaDocInfoGenerator.generateType(buffer, parm.getType(), method, false);\n      buffer.append(\" \");\n      if (parm.getName() != null) {\n        buffer.append(parm.getName());\n      }\n      if (i < parms.length - 1) {\n        buffer.append(\", \");\n      }\n    }\n\n    buffer.append(\")\");\n\n    PsiClassType[] refs = method.getThrowsList().getReferencedTypes();\n    if (refs.length > 0) {\n      newLine(buffer);\n      buffer.append(\" throws \");\n      for (int i = 0; i < refs.length; i++) {\n        PsiClass throwsClass = refs[i].resolve();\n\n        if (throwsClass != null) {\n          buffer.append(JavaDocUtil.getShortestClassName(throwsClass, method));\n        }\n        else {\n          buffer.append(refs[i].getPresentableText());\n        }\n\n        if (i < refs.length - 1) {\n          buffer.append(\", \");\n        }\n      }\n    }\n\n    return buffer.toString();\n  }","id":22783,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public static String generateMethodInfo(PsiMethod method, PsiSubstitutor substitutor) {\n    StringBuilder buffer = new StringBuilder();\n\n    PsiClass parentClass = method.getContainingClass();\n\n    if (parentClass != null) {\n      buffer.append(JavaDocUtil.getShortestClassName(parentClass, method));\n      newLine(buffer);\n    }\n\n    generateModifiers(buffer, method);\n\n    PsiTypeParameter[] params = method.getTypeParameters();\n\n    if (params.length > 0) {\n      buffer.append(\"&lt;\");\n      for (int i = 0; i < params.length; i++) {\n        PsiTypeParameter param = params[i];\n\n        buffer.append(param.getName());\n\n        PsiClassType[] extendees = param.getExtendsList().getReferencedTypes();\n\n        if (extendees.length > 0) {\n          buffer.append(\" extends \");\n\n          for (int j = 0; j < extendees.length; j++) {\n            JavaDocInfoGenerator.generateType(buffer, extendees[j], method, false);\n\n            if (j < extendees.length - 1) {\n              buffer.append(\" & \");\n            }\n          }\n        }\n\n        if (i < params.length - 1) {\n          buffer.append(\", \");\n        }\n      }\n      buffer.append(\"&gt; \");\n    }\n\n    if (method.getReturnType() != null) {\n      JavaDocInfoGenerator.generateType(buffer, substitutor.substitute(method.getReturnType()), method, false);\n      buffer.append(\" \");\n    }\n\n    buffer.append(method.getName());\n\n    buffer.append(\" (\");\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    for (int i = 0; i < parms.length; i++) {\n      PsiParameter parm = parms[i];\n      JavaDocInfoGenerator.generateType(buffer, substitutor.substitute(parm.getType()), method, false);\n      buffer.append(\" \");\n      if (parm.getName() != null) {\n        buffer.append(parm.getName());\n      }\n      if (i < parms.length - 1) {\n        buffer.append(\", \");\n      }\n    }\n\n    buffer.append(\")\");\n\n    PsiClassType[] refs = method.getThrowsList().getReferencedTypes();\n    if (refs.length > 0) {\n      newLine(buffer);\n      buffer.append(\" throws \");\n      for (int i = 0; i < refs.length; i++) {\n        PsiClass throwsClass = refs[i].resolve();\n\n        if (throwsClass != null) {\n          buffer.append(JavaDocUtil.getShortestClassName(throwsClass, method));\n        }\n        else {\n          buffer.append(refs[i].getPresentableText());\n        }\n\n        if (i < refs.length - 1) {\n          buffer.append(\", \");\n        }\n      }\n    }\n\n    return buffer.toString();\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String generateFieldInfo(PsiField field) {\n    StringBuilder buffer = new StringBuilder();\n    PsiClass parentClass = field.getContainingClass();\n\n    if (parentClass != null && !(parentClass instanceof PsiAnonymousClass)) {\n      buffer.append(JavaDocUtil.getShortestClassName(parentClass, field));\n      newLine(buffer);\n    }\n\n    generateModifiers(buffer, field);\n\n    JavaDocInfoGenerator.generateType(buffer, field.getType(), field, false);\n    buffer.append(\" \");\n    buffer.append(field.getName());\n\n    generateInitializer(buffer, field);\n\n    return buffer.toString();\n  }","id":22784,"modified_method":"private static String generateFieldInfo(PsiField field, PsiSubstitutor substitutor) {\n    StringBuilder buffer = new StringBuilder();\n    PsiClass parentClass = field.getContainingClass();\n\n    if (parentClass != null && !(parentClass instanceof PsiAnonymousClass)) {\n      buffer.append(JavaDocUtil.getShortestClassName(parentClass, field));\n      newLine(buffer);\n    }\n\n    generateModifiers(buffer, field);\n\n    JavaDocInfoGenerator.generateType(buffer, substitutor.substitute(field.getType()), field, false);\n    buffer.append(\" \");\n    buffer.append(field.getName());\n\n    generateInitializer(buffer, field);\n\n    return buffer.toString();\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getQuickNavigateInfo(PsiElement element, PsiElement originalElement) {\n    if (element instanceof PsiClass) {\n      return generateClassInfo((PsiClass)element);\n    }\n    else if (element instanceof PsiMethod) {\n      return generateMethodInfo((PsiMethod)element);\n    }\n    else if (element instanceof PsiField) {\n      return generateFieldInfo((PsiField)element);\n    }\n    else if (element instanceof PsiVariable) {\n      return generateVariableInfo((PsiVariable)element);\n    }\n    else if (element instanceof PsiPackage) {\n      return generatePackageInfo((PsiPackage)element);\n    }\n    else if (element instanceof BeanPropertyElement) {\n      return generateMethodInfo(((BeanPropertyElement) element).getMethod());\n    }\n    return null;\n  }","id":22785,"modified_method":"public String getQuickNavigateInfo(PsiElement element, PsiElement originalElement) {\n    if (element instanceof PsiClass) {\n      return generateClassInfo((PsiClass)element);\n    }\n    else if (element instanceof PsiMethod) {\n      return generateMethodInfo((PsiMethod)element, calcSubstitutor(originalElement));\n    }\n    else if (element instanceof PsiField) {\n      return generateFieldInfo((PsiField)element, calcSubstitutor(originalElement));\n    }\n    else if (element instanceof PsiVariable) {\n      return generateVariableInfo((PsiVariable)element);\n    }\n    else if (element instanceof PsiPackage) {\n      return generatePackageInfo((PsiPackage)element);\n    }\n    else if (element instanceof BeanPropertyElement) {\n      return generateMethodInfo(((BeanPropertyElement) element).getMethod(), PsiSubstitutor.EMPTY);\n    }\n    return null;\n  }","commit_id":"6390e2c3122487a7fff0ae2272abf7a10197382f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String buildErrorString(Object... infos){\n        final PsiType type = (PsiType)infos[0];\n        return InspectionGadgetsBundle.message(\n                \"hibernate.resource.opened.not.closed.problem.descriptor\",\n                type.getPresentableText());\n    }","id":22786,"modified_method":"@Override\n    @NotNull\n    public String buildErrorString(Object... infos){\n        final PsiExpression expression = (PsiExpression) infos[0];\n        final PsiType type = expression.getType();\n        assert type != null;\n        final String text = type.getPresentableText();\n        return InspectionGadgetsBundle.message(\n                \"hibernate.resource.opened.not.closed.problem.descriptor\",\n                text);\n    }","commit_id":"27a89cbc93300dc073aaf1ce904760cc556237da","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean satisfiedBy(PsiElement element) {\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n      if (lambdaExpression != null) {\n        PsiParameter[] parameters = lambdaExpression.getParameterList().getParameters();\n        if (parameters.length == 0) return false;\n        for (PsiParameter parameter : parameters) {\n          if (parameter.getTypeElement() != null) {\n            return false;\n          }\n        }\n        if (PsiTreeUtil.isAncestor(lambdaExpression.getParameterList(), element, false)) {\n          final PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n          if (functionalInterfaceType != null && LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType) != null && LambdaUtil.isLambdaFullyInferred(lambdaExpression, functionalInterfaceType)) {\n            myInferredTypesText = getInferredTypes(functionalInterfaceType, lambdaExpression);\n            return myInferredTypesText != null;\n          }\n        }\n      }\n      return false;\n    }","id":22787,"modified_method":"@Override\n    public boolean satisfiedBy(PsiElement element) {\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n      if (lambdaExpression != null) {\n        PsiParameter[] parameters = lambdaExpression.getParameterList().getParameters();\n        if (parameters.length == 0) return false;\n        for (PsiParameter parameter : parameters) {\n          if (parameter.getTypeElement() != null) {\n            return false;\n          }\n        }\n        if (PsiTreeUtil.isAncestor(lambdaExpression.getParameterList(), element, false)) {\n          final PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n          if (functionalInterfaceType != null && LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType) != null && LambdaUtil.isLambdaFullyInferred(lambdaExpression, functionalInterfaceType)) {\n            myInferredTypesText = getInferredTypes(functionalInterfaceType, lambdaExpression, false);\n            return myInferredTypesText != null;\n          }\n        }\n      }\n      return false;\n    }","commit_id":"09e8df037d03a9dcf150883c0beaa6563ad1bb3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String getInferredTypes(PsiType functionalInterfaceType, final PsiLambdaExpression lambdaExpression) {\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"(\");\n    final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    LOG.assertTrue(interfaceMethod != null);\n    final PsiParameter[] parameters = interfaceMethod.getParameterList().getParameters();\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    if (parameters.length != lambdaParameters.length) return null;\n    for (int i = 0; i < parameters.length; i++) {\n      PsiParameter parameter = parameters[i];\n      final PsiType psiType = GenericsUtil.eliminateWildcards(LambdaUtil.getSubstitutor(interfaceMethod, resolveResult).substitute(parameter.getType()));\n      if (psiType != null) {\n        buf.append(psiType.getPresentableText()).append(\" \").append(lambdaParameters[i].getName());\n      }\n      else {\n        buf.append(lambdaParameters[i].getName());\n      }\n      if (i < parameters.length - 1) {\n        buf.append(\", \");\n      }\n    }\n    buf.append(\")\");\n    return buf.toString();\n  }","id":22788,"modified_method":"@Nullable\n  private static String getInferredTypes(PsiType functionalInterfaceType, final PsiLambdaExpression lambdaExpression, boolean useFQN) {\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n    final StringBuilder buf = new StringBuilder();\n    buf.append(\"(\");\n    final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);\n    LOG.assertTrue(interfaceMethod != null);\n    final PsiParameter[] parameters = interfaceMethod.getParameterList().getParameters();\n    final PsiParameter[] lambdaParameters = lambdaExpression.getParameterList().getParameters();\n    if (parameters.length != lambdaParameters.length) return null;\n    for (int i = 0; i < parameters.length; i++) {\n      PsiParameter parameter = parameters[i];\n      final PsiType psiType = GenericsUtil.eliminateWildcards(LambdaUtil.getSubstitutor(interfaceMethod, resolveResult).substitute(parameter.getType()));\n      if (psiType != null) {\n        buf.append(useFQN ? psiType.getCanonicalText() : psiType.getPresentableText()).append(\" \").append(lambdaParameters[i].getName());\n      }\n      else {\n        buf.append(lambdaParameters[i].getName());\n      }\n      if (i < parameters.length - 1) {\n        buf.append(\", \");\n      }\n    }\n    buf.append(\")\");\n    return buf.toString();\n  }","commit_id":"09e8df037d03a9dcf150883c0beaa6563ad1bb3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void processIntention(@NotNull PsiElement element) throws IncorrectOperationException {\n    final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n    LOG.assertTrue(lambdaExpression != null);\n    final PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n    final String buf = getInferredTypes(functionalInterfaceType, lambdaExpression);\n    lambdaExpression.getParameterList().replace(JavaPsiFacade.getElementFactory(element.getProject()).createMethodFromText(\"void foo\" + buf,\n                                                                                                                           element).getParameterList());\n  }","id":22789,"modified_method":"@Override\n  protected void processIntention(@NotNull PsiElement element) throws IncorrectOperationException {\n    final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n    LOG.assertTrue(lambdaExpression != null);\n    final PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n    final String buf = getInferredTypes(functionalInterfaceType, lambdaExpression, true);\n    final Project project = element.getProject();\n    final PsiMethod methodFromText = JavaPsiFacade.getElementFactory(project).createMethodFromText(\"void foo\" + buf, element);\n    JavaCodeStyleManager.getInstance(project).shortenClassReferences(lambdaExpression.getParameterList().replace(methodFromText.getParameterList()));\n  }","commit_id":"09e8df037d03a9dcf150883c0beaa6563ad1bb3b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private final void printComponentsJson(final PrintWriter pw,\n        final List<ComponentConfigurationDTO> configurations,\n        final boolean details) throws JSONException\n    {\n        final JSONWriter jw = new JSONWriter(pw);\n        jw.object();\n        jw.key(\"components\"); //$NON-NLS-1$\n        jw.array();\n        \n        // render components\n        for (final ComponentConfigurationDTO cfg : configurations)\n        {\n            plugin.component(jw, cfg, details);\n        }\n        \n        jw.endArray();\n        jw.endObject();\n    }","id":22790,"modified_method":"private final void printComponentsJson(final PrintWriter pw,\n        final List<ComponentDescriptionDTO> disabled,\n        final List<ComponentConfigurationDTO> configurations,\n        final boolean details) throws JSONException\n    {\n        final JSONWriter jw = new JSONWriter(pw);\n        jw.object();\n        jw.key(\"components\"); //$NON-NLS-1$\n        jw.array();\n\n        // render disabled descriptions\n        for(final ComponentDescriptionDTO cd : disabled)\n        {\n            plugin.disabledComponent(jw, cd);\n        }\n        // render configurations\n        for (final ComponentConfigurationDTO cfg : configurations)\n        {\n            plugin.component(jw, cfg, details);\n        }\n\n        jw.endArray();\n        jw.endObject();\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinter#print(java.io.PrintWriter, org.apache.felix.inventory.Format, boolean)\n     */\n    public void print(PrintWriter pw, Format format, boolean isZip)\n    {\n        final List<ComponentDescriptionDTO> descriptions = new ArrayList<ComponentDescriptionDTO>();\n        final List<ComponentConfigurationDTO> configurations = new ArrayList<ComponentConfigurationDTO>();\n\n        final Collection<ComponentDescriptionDTO> descs = scrService.getComponentDescriptionDTOs();\n        for(final ComponentDescriptionDTO d : descs)\n        {\n            for(final ComponentConfigurationDTO cfg : scrService.getComponentConfigurationDTOs(d))\n            {\n                configurations.add(cfg);\n            }\n            descriptions.add(d);\n        }\n        Collections.sort(configurations, Util.COMPONENT_COMPARATOR);\n\n        if (Format.JSON.equals(format))\n        {\n            try\n            {\n                printComponentsJson(pw, configurations, isZip);\n            }\n            catch (JSONException t)\n            {\n                // ignore\n            }\n        }\n        else\n        {\n            printComponentsText(pw, configurations);\n        }\n    }","id":22791,"modified_method":"/**\n     * @see org.apache.felix.inventory.InventoryPrinter#print(java.io.PrintWriter, org.apache.felix.inventory.Format, boolean)\n     */\n    public void print(PrintWriter pw, Format format, boolean isZip)\n    {\n        final List<ComponentDescriptionDTO> disabled = new ArrayList<ComponentDescriptionDTO>();\n        final List<ComponentConfigurationDTO> configurations = new ArrayList<ComponentConfigurationDTO>();\n\n        final Collection<ComponentDescriptionDTO> descs = scrService.getComponentDescriptionDTOs();\n        for(final ComponentDescriptionDTO d : descs)\n        {\n            if ( !scrService.isComponentEnabled(d) )\n            {\n                disabled.add(d);\n            }\n            configurations.addAll(scrService.getComponentConfigurationDTOs(d));\n        }\n        Collections.sort(configurations, Util.COMPONENT_COMPARATOR);\n\n        if (Format.JSON.equals(format))\n        {\n            try\n            {\n                printComponentsJson(pw, disabled, configurations, isZip);\n            }\n            catch (JSONException t)\n            {\n                // ignore\n            }\n        }\n        else\n        {\n            printComponentsText(pw, disabled, configurations);\n        }\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"private static final void printComponentsText(final PrintWriter pw,\n            final List<ComponentConfigurationDTO> configurations)\n    {\n        if (configurations.size() == 0)\n        {\n            pw.println(\"Status: No Components Registered\");\n        }\n        else\n        {\n            // order components by id\n            TreeMap<Long, ComponentConfigurationDTO> componentMap = new TreeMap<Long, ComponentConfigurationDTO>();\n            for(final ComponentConfigurationDTO cfg : configurations)\n            {\n                componentMap.put(new Long(cfg.id), cfg);\n            }\n\n            // render components\n            for (final ComponentConfigurationDTO cfg : componentMap.values())\n            {\n                component(pw, cfg);\n            }\n        }\n    }","id":22792,"modified_method":"private static final void printComponentsText(final PrintWriter pw,\n            final List<ComponentDescriptionDTO> disabled,\n            final List<ComponentConfigurationDTO> configurations)\n    {\n        if ( !disabled.isEmpty())\n        {\n            pw.println(\"Disabled components:\");\n        }\n        for(final ComponentDescriptionDTO cd : disabled)\n        {\n            disabledComponent(pw, cd);\n        }\n\n        if (configurations.size() == 0)\n        {\n            pw.println(\"Status: No Component Configurations\");\n        }\n        else\n        {\n            pw.println(\"Component Configurations:\");\n            // order components by id\n            TreeMap<Long, ComponentConfigurationDTO> componentMap = new TreeMap<Long, ComponentConfigurationDTO>();\n            for(final ComponentConfigurationDTO cfg : configurations)\n            {\n                componentMap.put(new Long(cfg.id), cfg);\n            }\n\n            // render components\n            for (final ComponentConfigurationDTO cfg : componentMap.values())\n            {\n                component(pw, cfg);\n            }\n        }\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n    * @see org.apache.felix.webconsole.bundleinfo.BundleInfoProvider#getBundleInfo(org.osgi.framework.Bundle,\r\n    *      java.lang.String, java.util.Locale)\r\n    */\r\n    public BundleInfo[] getBundleInfo(Bundle bundle, String webConsoleRoot, Locale locale)\r\n    {\r\n        final List<ComponentDescriptionDTO> descriptions = new ArrayList<ComponentDescriptionDTO>();\r\n        final List<ComponentConfigurationDTO> configurations = new ArrayList<ComponentConfigurationDTO>();\r\n\r\n        final Collection<ComponentDescriptionDTO> descs = scrService.getComponentDescriptionDTOs(bundle);\r\n        for(final ComponentDescriptionDTO d : descs)\r\n        {\r\n            for(final ComponentConfigurationDTO cfg : scrService.getComponentConfigurationDTOs(d))\r\n            {\r\n                configurations.add(cfg);\r\n            }\r\n            descriptions.add(d);\r\n        }\r\n        Collections.sort(configurations, Util.COMPONENT_COMPARATOR);\r\n\r\n        if (configurations.size() == 0)\r\n        {\r\n            return NO_INFO;\r\n        }\r\n\r\n        BundleInfo[] ret = new BundleInfo[configurations.size()];\r\n        int i=0;\r\n        for (final ComponentConfigurationDTO cfg : configurations)\r\n        {\r\n            ret[i] = toInfo(cfg, webConsoleRoot, locale);\r\n            i++;\r\n        }\r\n        return ret;\r\n    }","id":22793,"modified_method":"/**\r\n    * @see org.apache.felix.webconsole.bundleinfo.BundleInfoProvider#getBundleInfo(org.osgi.framework.Bundle,\r\n    *      java.lang.String, java.util.Locale)\r\n    */\r\n    public BundleInfo[] getBundleInfo(Bundle bundle, String webConsoleRoot, Locale locale)\r\n    {\r\n        final List<ComponentDescriptionDTO> disabled = new ArrayList<ComponentDescriptionDTO>();\r\n        final List<ComponentConfigurationDTO> configurations = new ArrayList<ComponentConfigurationDTO>();\r\n\r\n        final Collection<ComponentDescriptionDTO> descs = scrService.getComponentDescriptionDTOs(bundle);\r\n        for(final ComponentDescriptionDTO d : descs)\r\n        {\r\n            if ( !scrService.isComponentEnabled(d))\r\n            {\r\n                disabled.add(d);\r\n            }\r\n            configurations.addAll(scrService.getComponentConfigurationDTOs(d));\r\n        }\r\n        Collections.sort(configurations, Util.COMPONENT_COMPARATOR);\r\n\r\n        if (configurations.size() == 0)\r\n        {\r\n            return NO_INFO;\r\n        }\r\n\r\n        BundleInfo[] ret = new BundleInfo[configurations.size() + disabled.size()];\r\n        int i=0;\r\n        for (final ComponentDescriptionDTO cfg : disabled)\r\n        {\r\n            ret[i] = toInfo(cfg, webConsoleRoot, locale);\r\n            i++;\r\n        }\r\n        for (final ComponentConfigurationDTO cfg : configurations)\r\n        {\r\n            ret[i] = toInfo(cfg, webConsoleRoot, locale);\r\n            i++;\r\n        }\r\n        return ret;\r\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"private BundleInfo toInfo(final ComponentConfigurationDTO cfg, String webConsoleRoot, Locale locale)\r\n    {\r\n        final ResourceBundle bundle = localization.getResourceBundle(locale);\r\n        final String state = ComponentConfigurationPrinter.toStateString(cfg.state);\r\n        final String name = cfg.description.name;\r\n        final String descr = bundle.getString(\"info.descr\"); //$NON-NLS-1$;\r\n        String key = bundle.getString(\"info.key\"); //$NON-NLS-1$;\r\n        // Component #{0} {1}, state {2}\r\n        key = MessageFormat.format(key, new Object[] { String.valueOf(cfg.id), //\r\n                name != null ? name : \"\", //$NON-NLS-1$\r\n                state, //\r\n        });\r\n        return new BundleInfo(key, (webConsoleRoot == null ? \"\" : webConsoleRoot) + \"/components/\" + cfg.id, //$NON-NLS-1$\r\n            BundleInfoType.LINK, descr);\r\n    }","id":22794,"modified_method":"private BundleInfo toInfo(final ComponentConfigurationDTO cfg, String webConsoleRoot, Locale locale)\r\n    {\r\n        final ResourceBundle bundle = localization.getResourceBundle(locale);\r\n        final String state = ComponentConfigurationPrinter.toStateString(cfg.state);\r\n        final String name = cfg.description.name;\r\n        final String descr = bundle.getString(\"info.descr\"); //$NON-NLS-1$;\r\n        String key = bundle.getString(\"info.key\"); //$NON-NLS-1$;\r\n        // Component #{0} {1}, state {2}\r\n        key = MessageFormat.format(key, new Object[] { String.valueOf(cfg.id),\r\n                name,\r\n                state\r\n        });\r\n        return new BundleInfo(key, (webConsoleRoot == null ? \"\" : webConsoleRoot) + \"/components/\" + cfg.id, //$NON-NLS-1$\r\n            BundleInfoType.LINK, descr);\r\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException\n    {\n        String path = request.getPathInfo();\n        // don't process if this is request to load a resource\n        if (!path.startsWith(RES))\n        {\n            final RequestInfo reqInfo = new RequestInfo(request);\n            if (reqInfo.component == null && reqInfo.componentRequested)\n            {\n                response.sendError(404);\n                return;\n            }\n            if (reqInfo.extension.equals(\"json\")) //$NON-NLS-1$\n            {\n                response.setContentType(\"application/json\"); //$NON-NLS-1$\n                response.setCharacterEncoding(\"UTF-8\"); //$NON-NLS-1$\n\n                this.renderResult(response.getWriter(), reqInfo, reqInfo.component);\n\n                // nothing more to do\n                return;\n            }\n        }\n        super.doGet(request, response);\n    }","id":22795,"modified_method":"/**\n     * @see org.apache.felix.webconsole.AbstractWebConsolePlugin#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n        throws ServletException, IOException\n    {\n        String path = request.getPathInfo();\n        // don't process if this is request to load a resource\n        if (!path.startsWith(RES))\n        {\n            final RequestInfo reqInfo = new RequestInfo(request, true);\n            if (reqInfo.component == null && reqInfo.componentRequested)\n            {\n                response.sendError(404);\n                return;\n            }\n            if (reqInfo.extension.equals(\"json\")) //$NON-NLS-1$\n            {\n                response.setContentType(\"application/json\"); //$NON-NLS-1$\n                response.setCharacterEncoding(\"UTF-8\"); //$NON-NLS-1$\n\n                this.renderResult(response.getWriter(), reqInfo, reqInfo.component);\n\n                // nothing more to do\n                return;\n            }\n        }\n        super.doGet(request, response);\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"private void renderResult(final PrintWriter pw, RequestInfo info, final ComponentConfigurationDTO component)\n        throws IOException\n    {\n        final JSONWriter jw = new JSONWriter(pw);\n        try\n        {\n            jw.object();\n\n            final ServiceComponentRuntime scrService = getScrService();\n            if (scrService == null)\n            {\n                jw.key(\"status\"); //$NON-NLS-1$\n                jw.value(-1);\n            }\n            else\n            {\n                if (info.configurations.size() == 0)\n                {\n                    jw.key(\"status\"); //$NON-NLS-1$\n                    jw.value(0);\n                }\n                else\n                {\n                    final StringBuffer buffer = new StringBuffer();\n                    buffer.append(info.configurations.size());\n                    buffer.append(\" component\"); //$NON-NLS-1$\n                    if (info.configurations.size() != 1)\n                    {\n                        buffer.append('s');\n                    }\n                    buffer.append(\" installed.\"); //$NON-NLS-1$\n                    jw.key(\"status\"); //$NON-NLS-1$\n                    jw.value(info.configurations.size());\n\n                    // render components\n                    jw.key(\"data\"); //$NON-NLS-1$\n                    jw.array();\n                    if (component != null)\n                    {\n                        component(jw, component, true);\n                    }\n                    else\n                    {\n                        for (final ComponentConfigurationDTO cfg : info.configurations)\n                        {\n                            component(jw, cfg, false);\n                        }\n                    }\n                    jw.endArray();\n                }\n            }\n\n            jw.endObject();\n        }\n        catch (JSONException je)\n        {\n            throw new IOException(je.toString());\n        }\n    }","id":22796,"modified_method":"private void renderResult(final PrintWriter pw, RequestInfo info, final ComponentConfigurationDTO component)\n        throws IOException\n    {\n        final JSONWriter jw = new JSONWriter(pw);\n        try\n        {\n            jw.object();\n\n            jw.key(\"status\"); //$NON-NLS-1$\n            final ServiceComponentRuntime scrService = getScrService();\n            if (scrService == null)\n            {\n                jw.value(-1);\n            }\n            else\n            {\n                jw.value(info.configurations.size());\n                if ( !info.configurations.isEmpty())\n                {\n                    // render components\n                    jw.key(\"data\"); //$NON-NLS-1$\n                    jw.array();\n                    if (component != null)\n                    {\n                        component(jw, component, true);\n                    }\n                    else\n                    {\n                        for( final ComponentDescriptionDTO cd : info.disabled )\n                        {\n                            disabledComponent(jw, cd);\n                        }\n                        for (final ComponentConfigurationDTO cfg : info.configurations)\n                        {\n                            component(jw, cfg, false);\n                        }\n                    }\n                    jw.endArray();\n                }\n            }\n\n            jw.endObject();\n        }\n        catch (JSONException je)\n        {\n            throw new IOException(je.toString());\n        }\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"protected RequestInfo(final HttpServletRequest request)\n        {\n            this.scrService = getScrService();\n            if ( scrService != null )\n            {\n                final Collection<ComponentDescriptionDTO> descs = scrService.getComponentDescriptionDTOs();\n                for(final ComponentDescriptionDTO d : descs)\n                {\n                    for(final ComponentConfigurationDTO cfg : scrService.getComponentConfigurationDTOs(d))\n                    {\n                        configurations.add(cfg);\n                    }\n                    descriptions.add(d);\n                }\n                Collections.sort(configurations, Util.COMPONENT_COMPARATOR);\n            }\n\n            String info = request.getPathInfo();\n            // remove label and starting slash\n            info = info.substring(getLabel().length() + 1);\n\n            // get extension\n            if (info.endsWith(\".json\")) //$NON-NLS-1$\n            {\n                extension = \"json\"; //$NON-NLS-1$\n                info = info.substring(0, info.length() - 5);\n            }\n            else\n            {\n                extension = \"html\"; //$NON-NLS-1$\n            }\n\n            if (info.length() > 1 && info.startsWith(\"/\")) //$NON-NLS-1$\n            {\n                this.componentRequested = true;\n                info = info.substring(1);\n                ComponentConfigurationDTO component = getComponentId(info);\n                if (component == null)\n                {\n                    component = getComponentByName(info);\n                }\n                this.component = component;\n            }\n            else\n            {\n                this.componentRequested = false;\n                this.component = null;\n            }\n\n            request.setAttribute(WebConsolePlugin.this.getClass().getName(), this);\n        }","id":22797,"modified_method":"protected RequestInfo(final HttpServletRequest request, final boolean checkPathInfo)\n        {\n            this.scrService = getScrService();\n            if ( scrService != null )\n            {\n                final Collection<ComponentDescriptionDTO> descs = scrService.getComponentDescriptionDTOs();\n                for(final ComponentDescriptionDTO d : descs)\n                {\n                    descriptions.add(d);\n                    if ( !scrService.isComponentEnabled(d) )\n                    {\n                        disabled.add(d);\n                    }\n                    configurations.addAll(scrService.getComponentConfigurationDTOs(d));\n                }\n                Collections.sort(configurations, Util.COMPONENT_COMPARATOR);\n            }\n\n            String info = request.getPathInfo();\n            // remove label and starting slash\n            info = info.substring(getLabel().length() + 1);\n\n            // get extension\n            if (info.endsWith(\".json\")) //$NON-NLS-1$\n            {\n                extension = \"json\"; //$NON-NLS-1$\n                info = info.substring(0, info.length() - 5);\n            }\n            else\n            {\n                extension = \"html\"; //$NON-NLS-1$\n            }\n\n            if (checkPathInfo && info.length() > 1 && info.startsWith(\"/\")) //$NON-NLS-1$\n            {\n                this.componentRequested = true;\n                info = info.substring(1);\n                ComponentConfigurationDTO component = getComponentId(info);\n                if (component == null)\n                {\n                    component = getComponentByName(info);\n                }\n                this.component = component;\n            }\n            else\n            {\n                this.componentRequested = false;\n                this.component = null;\n            }\n            this.name = info;\n\n            request.setAttribute(WebConsolePlugin.this.getClass().getName(), this);\n        }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n        throws IOException\n    {\n        final RequestInfo reqInfo = new RequestInfo(request);\n        if (reqInfo.component == null && reqInfo.componentRequested)\n        {\n            response.sendError(404);\n            return;\n        }\n        if (!reqInfo.componentRequested)\n        {\n            response.sendError(500);\n            return;\n        }\n        String op = request.getParameter(OPERATION);\n        if (OPERATION_ENABLE.equals(op))\n        {\n            getScrService().enableComponent(reqInfo.component.description);\n        }\n        else if (OPERATION_DISABLE.equals(op))\n        {\n            getScrService().disableComponent(reqInfo.component.description);\n        }\n\n        final PrintWriter pw = response.getWriter();\n        response.setContentType(\"application/json\"); //$NON-NLS-1$\n        response.setCharacterEncoding(\"UTF-8\"); //$NON-NLS-1$\n        renderResult(pw, reqInfo, null);\n    }","id":22798,"modified_method":"/**\n     * @see javax.servlet.http.HttpServlet#doPost(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n        throws IOException\n    {\n        final String op = request.getParameter(OPERATION);\n        RequestInfo reqInfo = new RequestInfo(request, true);\n        if (reqInfo.component == null && reqInfo.componentRequested)\n        {\n            boolean found = false;\n            if (OPERATION_ENABLE.equals(op))\n            {\n                final String name = reqInfo.name;\n                for(final ComponentDescriptionDTO cd : reqInfo.disabled)\n                {\n                    if ( name.equals(cd.name) )\n                    {\n                        wait(getScrService().enableComponent(cd));\n                        reqInfo = new RequestInfo(request, false);\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if ( !found )\n            {\n                response.sendError(404);\n                return;\n            }\n        }\n        else\n        {\n            if (!reqInfo.componentRequested)\n            {\n                response.sendError(500);\n                return;\n            }\n            if (OPERATION_DISABLE.equals(op))\n            {\n                wait(getScrService().disableComponent(reqInfo.component.description));\n                reqInfo = new RequestInfo(request, false);\n            }\n        }\n\n        final PrintWriter pw = response.getWriter();\n        response.setContentType(\"application/json\"); //$NON-NLS-1$\n        response.setCharacterEncoding(\"UTF-8\"); //$NON-NLS-1$\n        renderResult(pw, reqInfo, null);\n    }","commit_id":"a1c92f8906771697070987acde49c36d9a571c78","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected String createEndpointUri() {\n        return \"file://\" + getFile().getAbsolutePath();\n    }","id":22799,"modified_method":"@Override\n    protected String createEndpointUri() {\n        return getFile().toURI().toString();\n    }","commit_id":"33ba067fde2ba20daed0f3271c65289c7a4bb994","url":"https://github.com/apache/camel"},{"original_method":"String getWadlPath(String uri) {\n        return !uri.contains(\"://\") ? StringUtilities.join(\"file://\", new File(configRoot, uri).getAbsolutePath()) : uri;\n    }","id":22800,"modified_method":"String getWadlPath(String uri) {\n        return new File(configRoot, uri).toURI().toString();\n    }","commit_id":"77d6e1407f520f5711e568f5542b167d23f7fd51","url":"https://github.com/rackerlabs/repose"},{"original_method":"private String getWadlPath(String uri, String configRoot) {\n        return !uri.contains(\"://\") ? StringUtilities.join(\"file://\", new File(configRoot, uri).getAbsolutePath()) : uri;\n    }","id":22801,"modified_method":"private String getWadlPath(String uri, String configRoot) {\n        return new File(configRoot, uri).toURI().toString();\n    }","commit_id":"77d6e1407f520f5711e568f5542b167d23f7fd51","url":"https://github.com/rackerlabs/repose"},{"original_method":"protected DeletionService createDeletionService() {\n    return new DeletionService(exec) {\n      @Override\n      public void delete(String user, Path subDir, Path... baseDirs) {\n        // Don't do any deletions.\n        LOG.info(\"Psuedo delete: user - \" + user + \", subDir - \" + subDir\n            + \", baseDirs - \" + baseDirs); \n      };\n    };\n  }","id":22802,"modified_method":"protected DeletionService createDeletionService() {\n    return new DeletionService(exec) {\n      @Override\n      public void delete(String user, Path subDir, Path... baseDirs) {\n        // Don't do any deletions.\n        LOG.info(\"Psuedo delete: user - \" + user + \", subDir - \" + subDir\n            + \", baseDirs - \" + Arrays.asList(baseDirs));\n      };\n    };\n  }","commit_id":"e2d59e2c7b18a3d2f3917558463905a6b087b16f","url":"https://github.com/apache/hadoop"},{"original_method":"private boolean waitAndCheckLogNum(\n      LogAggregationService logAggregationService, ApplicationId application,\n      int maxAttempts, int expectNum, boolean sizeLimited, String lastLogFile)\n      throws IOException, InterruptedException {\n    int count = 0;\n    while (numOfLogsAvailable(logAggregationService, application, sizeLimited,\n      lastLogFile) != expectNum && count <= maxAttempts) {\n      Thread.sleep(500);\n      count++;\n    }\n    return numOfLogsAvailable(logAggregationService, application, sizeLimited,\n      lastLogFile) == expectNum;\n  }","id":22803,"modified_method":"private boolean waitAndCheckLogNum(\n      LogAggregationService logAggregationService, ApplicationId application,\n      int maxAttempts, int expectNum, boolean sizeLimited, String lastLogFile)\n      throws IOException, InterruptedException {\n    int count = 0;\n    int logFiles=numOfLogsAvailable(logAggregationService, application, sizeLimited,\n        lastLogFile);\n    while ((logFiles != expectNum)\n        && (count <= maxAttempts)) {\n      Thread.sleep(500);\n      count++;\n      logFiles =\n          numOfLogsAvailable(logAggregationService, application, sizeLimited,\n              lastLogFile);\n    }\n    return (logFiles == expectNum);\n  }","commit_id":"e2d59e2c7b18a3d2f3917558463905a6b087b16f","url":"https://github.com/apache/hadoop"},{"original_method":"private void writeContainerLogs(File appLogDir, ContainerId containerId,\n      String[] fileName) throws IOException {\n    // ContainerLogDir should be created\n    String containerStr = ConverterUtils.toString(containerId);\n    File containerLogDir = new File(appLogDir, containerStr);\n    containerLogDir.mkdir();\n    for (String fileType : fileName) {\n      Writer writer11 = new FileWriter(new File(containerLogDir, fileType));\n      writer11.write(containerStr + \" Hello \" + fileType + \"!\");\n      writer11.close();\n    }\n  }","id":22804,"modified_method":"private void writeContainerLogs(File appLogDir, ContainerId containerId,\n      String[] fileName) throws IOException {\n    // ContainerLogDir should be created\n    String containerStr = ConverterUtils.toString(containerId);\n    File containerLogDir = new File(appLogDir, containerStr);\n    boolean created = containerLogDir.mkdirs();\n    LOG.info(\"Created Dir:\" + containerLogDir.getAbsolutePath() + \" status :\"\n        + created);\n    for (String fileType : fileName) {\n      Writer writer11 = new FileWriter(new File(containerLogDir, fileType));\n      writer11.write(containerStr + \" Hello \" + fileType + \"!\");\n      writer11.close();\n    }\n  }","commit_id":"e2d59e2c7b18a3d2f3917558463905a6b087b16f","url":"https://github.com/apache/hadoop"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  private void testLogAggregationService(boolean retentionSizeLimitation)\n      throws Exception {\n    LogAggregationContext logAggregationContextWithInterval =\n        Records.newRecord(LogAggregationContext.class);\n    // set IncludePattern/excludePattern in rolling fashion\n    // we expect all the logs except std_final will be uploaded\n    // when app is running. The std_final will be uploaded when\n    // the app finishes.\n    logAggregationContextWithInterval.setRolledLogsIncludePattern(\".*\");\n    logAggregationContextWithInterval.setRolledLogsExcludePattern(\"std_final\");\n    this.conf.set(YarnConfiguration.NM_LOG_DIRS, localLogDir.getAbsolutePath());\n    //configure YarnConfiguration.NM_REMOTE_APP_LOG_DIR to\n    //have fully qualified path\n    this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n      \"file://\" + this.remoteRootLogDir.getAbsolutePath());\n    this.conf.setLong(\n      YarnConfiguration.NM_LOG_AGGREGATION_ROLL_MONITORING_INTERVAL_SECONDS,\n      3600);\n    if (retentionSizeLimitation) {\n      // set the retention size as 1. The number of logs for one application\n      // in one NM should be 1.\n      this.conf.setInt(YarnConfiguration.NM_PREFIX\n          + \"log-aggregation.num-log-files-per-app\", 1);\n    }\n\n    // by setting this configuration, the log files will not be deleted immediately after\n    // they are aggregated to remote directory.\n    // We could use it to test whether the previous aggregated log files will be aggregated\n    // again in next cycle.\n    this.conf.setLong(YarnConfiguration.DEBUG_NM_DELETE_DELAY_SEC, 3600);\n\n    ApplicationId application = BuilderUtils.newApplicationId(123456, 1);\n    ApplicationAttemptId appAttemptId =\n        BuilderUtils.newApplicationAttemptId(application, 1);\n    ContainerId container = createContainer(appAttemptId, 1,\n        ContainerType.APPLICATION_MASTER);\n\n    ConcurrentMap<ApplicationId, Application> maps =\n        this.context.getApplications();\n    Application app = mock(Application.class);\n    maps.put(application, app);\n    when(app.getContainers()).thenReturn(this.context.getContainers());\n\n    LogAggregationService logAggregationService =\n        new LogAggregationService(dispatcher, context, this.delSrvc,\n          super.dirsHandler);\n\n    logAggregationService.init(this.conf);\n    logAggregationService.start();\n\n    // AppLogDir should be created\n    File appLogDir =\n        new File(localLogDir, ConverterUtils.toString(application));\n    appLogDir.mkdir();\n    logAggregationService.handle(new LogHandlerAppStartedEvent(application,\n      this.user, null, this.acls, logAggregationContextWithInterval));\n\n    LogFileStatusInLastCycle logFileStatusInLastCycle = null;\n    // Simulate log-file creation\n    // create std_final in log directory which will not be aggregated\n    // until the app finishes.\n    String[] logFiles1WithFinalLog =\n        new String[] { \"stdout\", \"stderr\", \"syslog\", \"std_final\" };\n    String[] logFiles1 = new String[] { \"stdout\", \"stderr\", \"syslog\"};\n    writeContainerLogs(appLogDir, container, logFiles1WithFinalLog);\n\n    // Do log aggregation\n    AppLogAggregatorImpl aggregator =\n        (AppLogAggregatorImpl) logAggregationService.getAppLogAggregators()\n          .get(application);\n    aggregator.doLogAggregationOutOfBand();\n\n    if (retentionSizeLimitation) {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, true, null));\n    } else {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, false, null));\n    }\n    // Container logs should be uploaded\n    logFileStatusInLastCycle = verifyContainerLogs(logAggregationService, application,\n        new ContainerId[] { container }, logFiles1, 3, true);\n    for(String logFile : logFiles1) {\n      Assert.assertTrue(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n        .contains(logFile));\n    }\n    // Make sure the std_final is not uploaded.\n    Assert.assertFalse(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n      .contains(\"std_final\"));\n\n    Thread.sleep(2000);\n\n    // There is no log generated at this time. Do the log aggregation again.\n    aggregator.doLogAggregationOutOfBand();\n\n    // Same logs will not be aggregated again.\n    // Only one aggregated log file in Remote file directory.\n    Assert.assertEquals(numOfLogsAvailable(logAggregationService,\n        application, true, null), 1);\n\n    Thread.sleep(2000);\n\n    // Do log aggregation\n    String[] logFiles2 = new String[] { \"stdout_1\", \"stderr_1\", \"syslog_1\" };\n    writeContainerLogs(appLogDir, container, logFiles2);\n\n    aggregator.doLogAggregationOutOfBand();\n\n    if (retentionSizeLimitation) {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, true, logFileStatusInLastCycle.getLogFilePathInLastCycle()));\n    } else {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 2, false, null));\n    }\n    // Container logs should be uploaded\n    logFileStatusInLastCycle = verifyContainerLogs(logAggregationService, application,\n        new ContainerId[] { container }, logFiles2, 3, true);\n\n    for(String logFile : logFiles2) {\n      Assert.assertTrue(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n        .contains(logFile));\n    }\n    // Make sure the std_final is not uploaded.\n    Assert.assertFalse(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n      .contains(\"std_final\"));\n\n    Thread.sleep(2000);\n\n    // create another logs\n    String[] logFiles3 = new String[] { \"stdout_2\", \"stderr_2\", \"syslog_2\" };\n    writeContainerLogs(appLogDir, container, logFiles3);\n\n    logAggregationService.handle(\n      new LogHandlerContainerFinishedEvent(container, 0));\n\n    dispatcher.await();\n    logAggregationService.handle(new LogHandlerAppFinishedEvent(application));\n    if (retentionSizeLimitation) {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, true, logFileStatusInLastCycle.getLogFilePathInLastCycle()));\n    } else {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 3, false, null));\n    }\n\n    // the app is finished. The log \"std_final\" should be aggregated this time.\n    String[] logFiles3WithFinalLog =\n        new String[] { \"stdout_2\", \"stderr_2\", \"syslog_2\", \"std_final\" };\n    verifyContainerLogs(logAggregationService, application,\n      new ContainerId[] { container }, logFiles3WithFinalLog, 4, true);\n    logAggregationService.stop();\n    assertEquals(0, logAggregationService.getNumAggregators());\n  }","id":22805,"modified_method":"@SuppressWarnings(\"unchecked\")\n  private void testLogAggregationService(boolean retentionSizeLimitation)\n      throws Exception {\n    LogAggregationContext logAggregationContextWithInterval =\n        Records.newRecord(LogAggregationContext.class);\n    // set IncludePattern/excludePattern in rolling fashion\n    // we expect all the logs except std_final will be uploaded\n    // when app is running. The std_final will be uploaded when\n    // the app finishes.\n    logAggregationContextWithInterval.setRolledLogsIncludePattern(\".*\");\n    logAggregationContextWithInterval.setRolledLogsExcludePattern(\"std_final\");\n    this.conf.set(YarnConfiguration.NM_LOG_DIRS, localLogDir.getAbsolutePath());\n    //configure YarnConfiguration.NM_REMOTE_APP_LOG_DIR to\n    //have fully qualified path\n    this.conf.set(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        this.remoteRootLogDir.toURI().toString());\n    this.conf.setLong(\n      YarnConfiguration.NM_LOG_AGGREGATION_ROLL_MONITORING_INTERVAL_SECONDS,\n      3600);\n    if (retentionSizeLimitation) {\n      // set the retention size as 1. The number of logs for one application\n      // in one NM should be 1.\n      this.conf.setInt(YarnConfiguration.NM_PREFIX\n          + \"log-aggregation.num-log-files-per-app\", 1);\n    }\n\n    // by setting this configuration, the log files will not be deleted immediately after\n    // they are aggregated to remote directory.\n    // We could use it to test whether the previous aggregated log files will be aggregated\n    // again in next cycle.\n    this.conf.setLong(YarnConfiguration.DEBUG_NM_DELETE_DELAY_SEC, 3600);\n\n    ApplicationId application =\n        BuilderUtils.newApplicationId(System.currentTimeMillis(), 1);\n    ApplicationAttemptId appAttemptId =\n        BuilderUtils.newApplicationAttemptId(application, 1);\n    ContainerId container = createContainer(appAttemptId, 1,\n        ContainerType.APPLICATION_MASTER);\n\n    ConcurrentMap<ApplicationId, Application> maps =\n        this.context.getApplications();\n    Application app = mock(Application.class);\n    maps.put(application, app);\n    when(app.getContainers()).thenReturn(this.context.getContainers());\n\n    LogAggregationService logAggregationService =\n        new LogAggregationService(dispatcher, context, this.delSrvc,\n          super.dirsHandler);\n\n    logAggregationService.init(this.conf);\n    logAggregationService.start();\n\n    // AppLogDir should be created\n    File appLogDir =\n        new File(localLogDir, ConverterUtils.toString(application));\n    appLogDir.mkdir();\n    logAggregationService.handle(new LogHandlerAppStartedEvent(application,\n      this.user, null, this.acls, logAggregationContextWithInterval));\n\n    LogFileStatusInLastCycle logFileStatusInLastCycle = null;\n    // Simulate log-file creation\n    // create std_final in log directory which will not be aggregated\n    // until the app finishes.\n    String[] logFiles1WithFinalLog =\n        new String[] { \"stdout\", \"stderr\", \"syslog\", \"std_final\" };\n    String[] logFiles1 = new String[] { \"stdout\", \"stderr\", \"syslog\"};\n    writeContainerLogs(appLogDir, container, logFiles1WithFinalLog);\n\n    // Do log aggregation\n    AppLogAggregatorImpl aggregator =\n        (AppLogAggregatorImpl) logAggregationService.getAppLogAggregators()\n          .get(application);\n    aggregator.doLogAggregationOutOfBand();\n\n    if (retentionSizeLimitation) {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, true, null));\n    } else {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, false, null));\n    }\n    // Container logs should be uploaded\n    logFileStatusInLastCycle = verifyContainerLogs(logAggregationService, application,\n        new ContainerId[] { container }, logFiles1, 3, true);\n    for(String logFile : logFiles1) {\n      Assert.assertTrue(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n        .contains(logFile));\n    }\n    // Make sure the std_final is not uploaded.\n    Assert.assertFalse(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n      .contains(\"std_final\"));\n\n    Thread.sleep(2000);\n\n    // There is no log generated at this time. Do the log aggregation again.\n    aggregator.doLogAggregationOutOfBand();\n\n    // Same logs will not be aggregated again.\n    // Only one aggregated log file in Remote file directory.\n    Assert.assertTrue(\n        \"Only one aggregated log file in Remote file directory expected\",\n        waitAndCheckLogNum(logAggregationService, application, 50, 1, true,\n            null));\n\n    Thread.sleep(2000);\n\n    // Do log aggregation\n    String[] logFiles2 = new String[] { \"stdout_1\", \"stderr_1\", \"syslog_1\" };\n    writeContainerLogs(appLogDir, container, logFiles2);\n\n    aggregator.doLogAggregationOutOfBand();\n\n    if (retentionSizeLimitation) {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, true, logFileStatusInLastCycle.getLogFilePathInLastCycle()));\n    } else {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 2, false, null));\n    }\n    // Container logs should be uploaded\n    logFileStatusInLastCycle = verifyContainerLogs(logAggregationService, application,\n        new ContainerId[] { container }, logFiles2, 3, true);\n\n    for(String logFile : logFiles2) {\n      Assert.assertTrue(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n        .contains(logFile));\n    }\n    // Make sure the std_final is not uploaded.\n    Assert.assertFalse(logFileStatusInLastCycle.getLogFileTypesInLastCycle()\n      .contains(\"std_final\"));\n\n    Thread.sleep(2000);\n\n    // create another logs\n    String[] logFiles3 = new String[] { \"stdout_2\", \"stderr_2\", \"syslog_2\" };\n    writeContainerLogs(appLogDir, container, logFiles3);\n\n    logAggregationService.handle(\n      new LogHandlerContainerFinishedEvent(container, 0));\n\n    dispatcher.await();\n    logAggregationService.handle(new LogHandlerAppFinishedEvent(application));\n    if (retentionSizeLimitation) {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 1, true, logFileStatusInLastCycle.getLogFilePathInLastCycle()));\n    } else {\n      Assert.assertTrue(waitAndCheckLogNum(logAggregationService, application,\n        50, 3, false, null));\n    }\n\n    // the app is finished. The log \"std_final\" should be aggregated this time.\n    String[] logFiles3WithFinalLog =\n        new String[] { \"stdout_2\", \"stderr_2\", \"syslog_2\", \"std_final\" };\n    verifyContainerLogs(logAggregationService, application,\n      new ContainerId[] { container }, logFiles3WithFinalLog, 4, true);\n    logAggregationService.stop();\n    assertEquals(0, logAggregationService.getNumAggregators());\n  }","commit_id":"e2d59e2c7b18a3d2f3917558463905a6b087b16f","url":"https://github.com/apache/hadoop"},{"original_method":"private int numOfLogsAvailable(LogAggregationService logAggregationService,\n      ApplicationId appId, boolean sizeLimited, String lastLogFile)\n      throws IOException {\n    Path appLogDir = logAggregationService.getRemoteAppLogDir(appId, this.user);\n    RemoteIterator<FileStatus> nodeFiles = null;\n    try {\n      Path qualifiedLogDir =\n          FileContext.getFileContext(this.conf).makeQualified(appLogDir);\n      nodeFiles =\n          FileContext.getFileContext(qualifiedLogDir.toUri(), this.conf)\n            .listStatus(appLogDir);\n    } catch (FileNotFoundException fnf) {\n      return -1;\n    }\n    int count = 0;\n    while (nodeFiles.hasNext()) {\n      FileStatus status = nodeFiles.next();\n      String filename = status.getPath().getName();\n      if (filename.contains(LogAggregationUtils.TMP_FILE_SUFFIX)\n          || (lastLogFile != null && filename.contains(lastLogFile)\n              && sizeLimited)) {\n        return -1;\n      }\n      if (filename.contains(LogAggregationUtils\n        .getNodeString(logAggregationService.getNodeId()))) {\n        count++;\n      }\n    }\n    return count;\n  }","id":22806,"modified_method":"private int numOfLogsAvailable(LogAggregationService logAggregationService,\n      ApplicationId appId, boolean sizeLimited, String lastLogFile)\n      throws IOException {\n    Path appLogDir = logAggregationService.getRemoteAppLogDir(appId, this.user);\n    RemoteIterator<FileStatus> nodeFiles = null;\n    try {\n      Path qualifiedLogDir =\n          FileContext.getFileContext(this.conf).makeQualified(appLogDir);\n      nodeFiles =\n          FileContext.getFileContext(qualifiedLogDir.toUri(), this.conf)\n            .listStatus(appLogDir);\n    } catch (FileNotFoundException fnf) {\n      LOG.info(\"Context file not vailable: \" + fnf);\n      return -1;\n    }\n    int count = 0;\n    while (nodeFiles.hasNext()) {\n      FileStatus status = nodeFiles.next();\n      String filename = status.getPath().getName();\n      if (filename.contains(LogAggregationUtils.TMP_FILE_SUFFIX)\n          || (lastLogFile != null && filename.contains(lastLogFile)\n              && sizeLimited)) {\n        LOG.info(\"fileName :\" + filename);\n        LOG.info(\"lastLogFile :\" + lastLogFile);\n        return -1;\n      }\n      if (filename.contains(LogAggregationUtils\n        .getNodeString(logAggregationService.getNodeId()))) {\n        LOG.info(\"Node list filename :\" + filename);\n        count++;\n      }\n    }\n    LOG.info(\"File Count :\" + count);\n    return count;\n  }","commit_id":"e2d59e2c7b18a3d2f3917558463905a6b087b16f","url":"https://github.com/apache/hadoop"},{"original_method":"public LocalTemplateDownloader(StorageLayer storageLayer, String downloadUrl, String toDir, long maxTemplateSizeInBytes, DownloadCompleteCallback callback) {\n        super(storageLayer, downloadUrl, toDir, maxTemplateSizeInBytes, callback);\n        String filename = downloadUrl.substring(downloadUrl.lastIndexOf(File.separator));\n        _toFile = toDir.endsWith(File.separator) ? (toDir + filename) : (toDir + File.separator + filename);\n    }","id":22807,"modified_method":"public LocalTemplateDownloader(StorageLayer storageLayer, String downloadUrl, String toDir, long maxTemplateSizeInBytes, DownloadCompleteCallback callback) {\n        super(storageLayer, downloadUrl, toDir, maxTemplateSizeInBytes, callback);\n        String filename = new File(downloadUrl).getName();\n        _toFile = toDir.endsWith(File.separator) ? (toDir + filename) : (toDir + File.separator + filename);\n    }","commit_id":"ea92fc15ce2084ef701bf1af7069b6a7ec7013da","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void localTemplateDownloaderTest() {\n        String url =  \"file://\" + new File(\"pom.xml\").getAbsolutePath();\n        TemplateDownloader td = new LocalTemplateDownloader(null, url, \"/tmp\", TemplateDownloader.DEFAULT_MAX_TEMPLATE_SIZE_IN_BYTES, null);\n        long bytes = td.download(true, null);\n        if (!(bytes > 0)) {\n            fail(\"Failed download\");\n        }\n    }","id":22808,"modified_method":"@Test\n    public void localTemplateDownloaderTest() throws Exception {\n        String url = new File(\"pom.xml\").toURI().toURL().toString();\n        TemplateDownloader td = new LocalTemplateDownloader(null, url, System.getProperty(\"java.io.tmpdir\"), TemplateDownloader.DEFAULT_MAX_TEMPLATE_SIZE_IN_BYTES, null);\n        long bytes = td.download(true, null);\n        if (!(bytes > 0)) {\n            fail(\"Failed download\");\n        }\n    }","commit_id":"ea92fc15ce2084ef701bf1af7069b6a7ec7013da","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public NodeBuilder select(@Nonnull NodeBuilder history)\n            throws RepositoryException {\n        long latestDate = Long.MIN_VALUE;\n        NodeBuilder latestVersion = null;\n        for (String name: history.getChildNodeNames()) {\n            NodeBuilder v = history.getChildNode(name);\n            if (name.equals(JcrConstants.JCR_ROOTVERSION)) {\n                // ignore root version\n                continue;\n            }\n            long c = v.getProperty(JcrConstants.JCR_CREATED).getValue(Type.DATE);\n            if (c > latestDate && c <= timestamp) {\n                latestDate = c;\n                latestVersion = v;\n            }\n        }\n        return latestVersion;\n    }","id":22809,"modified_method":"@Override\n    public NodeBuilder select(@Nonnull NodeBuilder history)\n            throws RepositoryException {\n        long latestDate = Long.MIN_VALUE;\n        NodeBuilder latestVersion = null;\n        for (String name: history.getChildNodeNames()) {\n            NodeBuilder v = history.getChildNode(name);\n            if (name.equals(JcrConstants.JCR_ROOTVERSION)\n                    || name.equals(JcrConstants.JCR_VERSIONLABELS)) {\n                // ignore root version and labels node\n                continue;\n            }\n            long c = v.getProperty(JcrConstants.JCR_CREATED).getValue(Type.DATE);\n            if (c > latestDate && c <= timestamp) {\n                latestDate = c;\n                latestVersion = v;\n            }\n        }\n        return latestVersion;\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public QueryEngine getQueryEngine() {\n        throw new UnsupportedOperationException();\n    }","id":22810,"modified_method":"@Nonnull\n    @Override\n    public QueryEngine getQueryEngine() {\n        return new QueryEngineImpl(new PropertyIndexProvider()) {\n            @Override\n            protected NodeState getRootState() {\n                return rootTree.state;\n            }\n\n            @Override\n            protected Tree getRootTree() {\n                return rootTree;\n            }\n        };\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testImmutable() {\n\n        try {\n            root.commit();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.rebase();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.refresh();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.getBlobFactory();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.getQueryEngine();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.move(\"/x\", \"/b\");\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.copy(\"/x\", \"/b\");\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n    }","id":22811,"modified_method":"@Test\n    public void testImmutable() {\n\n        try {\n            root.commit();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.rebase();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.refresh();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.getBlobFactory();\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.move(\"/x\", \"/b\");\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n\n        try {\n            root.copy(\"/x\", \"/b\");\n            fail();\n        } catch (UnsupportedOperationException e) {\n            // success\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * <i>Copied from Apache Jackrabbit Core<\/i>\n     * <p>\n     * Calculates the name of the new version that will be created by a\n     * checkin call. The name is determined as follows:\n     * <ul>\n     * <li> first the predecessor version with the shortest name is searched.\n     * <li> if that predecessor version is the root version, the new version gets\n     *      the name \"{number of successors}+1\" + \".0\"\n     * <li> if that predecessor version has no successor, the last digit of it's\n     *      version number is incremented.\n     * <li> if that predecessor version has successors but the incremented name\n     *      does not exist, that name is used.\n     * <li> otherwise a \".0\" is added to the name until a non conflicting name\n     *      is found.\n     * <ul>\n     * <\/p>\n     * Example Graph:\n     * <pre>\n     * jcr:rootVersion\n     *  |     |\n     * 1.0   2.0\n     *  |\n     * 1.1\n     *  |\n     * 1.2 ---\\  ------\\\n     *  |      \\        \\\n     * 1.3   1.2.0   1.2.0.0\n     *  |      |\n     * 1.4   1.2.1 ----\\\n     *  |      |        \\\n     * 1.5   1.2.2   1.2.1.0\n     *  |      |        |\n     * 1.6     |     1.2.1.1\n     *  |-----/\n     * 1.7\n     * <\/pre>\n     *\n     * @param history the version history\n     * @param versionable the node to checkin\n     * @return the new version name\n     * @throws IllegalStateException if mandatory version properties are missing.\n     */\n    protected String calculateVersion(@Nonnull NodeBuilder history,\n                                      @Nonnull NodeBuilder versionable)\n            throws IllegalStateException {\n\n        // 1. search a predecessor, suitable for generating the new name\n        PropertyState predecessors = versionable.getProperty(JCR_PREDECESSORS);\n\n        if (predecessors == null || predecessors.count() == 0) {\n            String message;\n            if (predecessors == null) {\n                message = \"Mandatory jcr:predecessors property missing on node \" + uuidFromNode(versionable);\n            } else {\n                message = \"Mandatory jcr:predecessors property is empty on node \" + uuidFromNode(versionable);\n            }\n            throw new IllegalStateException(message);\n        }\n\n        // FIXME: inefficient because it iterates over all versions!\n        Set<String> uuids = ImmutableSet.copyOf(predecessors.getValue(Type.REFERENCES));\n        String best = null;\n        for (String name : history.getChildNodeNames()) {\n            if (name.equals(JCR_VERSIONLABELS)) {\n                continue;\n            }\n            NodeBuilder child = history.getChildNode(name);\n            if (uuids.contains(uuidFromNode(child))) {\n                if (best == null || name.length() < best.length()) {\n                    best = name;\n                }\n            }\n        }\n\n        if (best == null) {\n            String message = \"Could not find 'best' predecessor node for \" +\n                    uuidFromNode(versionable);\n            throw new IllegalStateException(message);\n        }\n\n        // 2. generate version name (assume no namespaces in version names)\n        String versionName = best;\n        int pos = versionName.lastIndexOf('.');\n        if (pos > 0) {\n            String newVersionName = versionName.substring(0, pos + 1)\n                    + (Integer.parseInt(versionName.substring(pos + 1)) + 1);\n            while (history.hasChildNode(newVersionName)) {\n                versionName += \".0\";\n                newVersionName = versionName;\n            }\n            return newVersionName;\n        } else {\n            // best is root version\n            checkState(history.hasChildNode(JCR_ROOTVERSION));\n            NodeBuilder v = history.getChildNode(JCR_ROOTVERSION);\n            return String.valueOf(v.getProperty(JCR_SUCCESSORS).count() + 1) + \".0\";\n        }\n    }","id":22812,"modified_method":"/**\n     * <i>Copied from Apache Jackrabbit Core<\/i>\n     * <p>\n     * Calculates the name of the new version that will be created by a\n     * checkin call. The name is determined as follows:\n     * <ul>\n     * <li> first the predecessor version with the shortest name is searched.\n     * <li> if that predecessor version is the root version, the new version gets\n     *      the name \"{number of successors}+1\" + \".0\"\n     * <li> if that predecessor version has no successor, the last digit of it's\n     *      version number is incremented.\n     * <li> if that predecessor version has successors but the incremented name\n     *      does not exist, that name is used.\n     * <li> otherwise a \".0\" is added to the name until a non conflicting name\n     *      is found.\n     * <ul>\n     * <\/p>\n     * Example Graph:\n     * <pre>\n     * jcr:rootVersion\n     *  |     |\n     * 1.0   2.0\n     *  |\n     * 1.1\n     *  |\n     * 1.2 ---\\  ------\\\n     *  |      \\        \\\n     * 1.3   1.2.0   1.2.0.0\n     *  |      |\n     * 1.4   1.2.1 ----\\\n     *  |      |        \\\n     * 1.5   1.2.2   1.2.1.0\n     *  |      |        |\n     * 1.6     |     1.2.1.1\n     *  |-----/\n     * 1.7\n     * <\/pre>\n     *\n     * @param history the version history\n     * @param versionable the node to checkin\n     * @return the new version name\n     * @throws IllegalStateException if mandatory version properties are missing.\n     */\n    protected String calculateVersion(@Nonnull NodeBuilder history,\n                                      @Nonnull NodeBuilder versionable)\n            throws IllegalStateException {\n\n        // 1. search a predecessor, suitable for generating the new name\n        PropertyState predecessors = versionable.getProperty(JCR_PREDECESSORS);\n\n        if (predecessors == null || predecessors.count() == 0) {\n            String message;\n            if (predecessors == null) {\n                message = \"Mandatory jcr:predecessors property missing on node \" + uuidFromNode(versionable);\n            } else {\n                message = \"Mandatory jcr:predecessors property is empty on node \" + uuidFromNode(versionable);\n            }\n            throw new IllegalStateException(message);\n        }\n\n        String best = null;\n        for (String id : predecessors.getValue(Type.REFERENCES)) {\n            String name = PathUtils.getName(getIdentifierManager().getPath(id));\n            if (best == null || name.length() < best.length()) {\n                best = name;\n            }\n        }\n\n        if (best == null) {\n            String message = \"Could not find 'best' predecessor node for \" +\n                    uuidFromNode(versionable);\n            throw new IllegalStateException(message);\n        }\n\n        // 2. generate version name (assume no namespaces in version names)\n        String versionName = best;\n        int pos = versionName.lastIndexOf('.');\n        if (pos > 0) {\n            String newVersionName = versionName.substring(0, pos + 1)\n                    + (Integer.parseInt(versionName.substring(pos + 1)) + 1);\n            while (history.hasChildNode(newVersionName)) {\n                versionName += \".0\";\n                newVersionName = versionName;\n            }\n            return newVersionName;\n        } else {\n            // best is root version\n            checkState(history.hasChildNode(JCR_ROOTVERSION));\n            NodeBuilder v = history.getChildNode(JCR_ROOTVERSION);\n            return String.valueOf(v.getProperty(JCR_SUCCESSORS).count() + 1) + \".0\";\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void restore(@Nonnull NodeBuilder versionable,\n                        @Nonnull String versionUUID)\n            throws CommitFailedException {\n        NodeBuilder history = getOrCreateVersionHistory(versionable);\n        // FIXME: inefficient because it iterates over all versions (worst case)\n        NodeBuilder version = null;\n        for (String name : history.getChildNodeNames()) {\n            if (name.equals(JCR_VERSIONLABELS)) {\n                continue;\n            }\n            NodeBuilder child = history.getChildNode(name);\n            if (versionUUID.equals(uuidFromNode(child))) {\n                version = child;\n            }\n        }\n        if (version == null) {\n            throw new CommitFailedException(CommitFailedException.VERSION,\n                    VersionExceptionCode.NO_SUCH_VERSION.ordinal(),\n                    \"The VersionHistory with UUID: \" + uuidFromNode(versionable) +\n                            \" does not have a Version with UUID: \" + versionUUID);\n        }\n        VersionableState versionableState = VersionableState.forRestore(\n                version, versionable, ntMgr);\n        versionableState.restore();\n    }","id":22813,"modified_method":"/**\n     * Resolves the <code>relPath<\/code> based on the given <code>node<\/code>\n     * and returns the resulting node, possibly non-existing.\n     *\n     * @param node the resolved node.\n     * @param relPath a relative path.\n     * @return the resolved node.\n     */\n    @Nonnull\n    private NodeBuilder resolve(NodeBuilder node, String relPath) {\n        checkArgument(!PathUtils.isAbsolute(relPath), \"Not a relative path\");\n        for (String name : PathUtils.elements(relPath)) {\n            node = node.getChildNode(name);\n        }\n        return node;\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a version in the given version history. If the given version\n     * history does not yet have a version, then a root version is created and\n     * the versionable node is in a checked out state. Otherwise a version is\n     * created and the versionable node is set to checked in.\n     *\n     * @param vHistory the version history node.\n     * @param versionable the versionable node.\n     * @return the created version (nt:version) node.\n     * @throws CommitFailedException if creating the version fails. E.g. because\n     * the versionable node contains a OPV item with ABORT.\n     */\n    private NodeBuilder createVersion(@Nonnull NodeBuilder vHistory,\n                                      @Nonnull NodeBuilder versionable)\n            throws IllegalArgumentException, CommitFailedException {\n        List<String> predecessors;\n        NodeBuilder version;\n        boolean isRootVersion;\n        if (!vHistory.hasChildNode(JCR_ROOTVERSION)) {\n            // create root version\n            isRootVersion = true;\n            predecessors = Collections.emptyList();\n            version = vHistory.child(JCR_ROOTVERSION);\n        } else {\n            isRootVersion = false;\n            checkState(versionable.hasProperty(JCR_PREDECESSORS));\n            PropertyState state = versionable.getProperty(JCR_PREDECESSORS);\n            predecessors = ImmutableList.copyOf(state.getValue(Type.REFERENCES));\n            version = vHistory.child(calculateVersion(vHistory, versionable));\n        }\n        String versionUUID = IdentifierManager.generateUUID();\n        version.setProperty(JCR_UUID, versionUUID, Type.STRING);\n        version.setProperty(JCR_PRIMARYTYPE, NT_VERSION, Type.NAME);\n        long now = System.currentTimeMillis();\n        version.setProperty(JCR_CREATED, now, Type.DATE);\n        version.setProperty(JCR_PREDECESSORS, predecessors, Type.REFERENCES);\n        version.setProperty(JCR_SUCCESSORS, Collections.<String>emptyList(), Type.REFERENCES);\n\n        // update successors of versions identified by predecessors\n        // FIXME: inefficient because it iterates over all versions\n        for (String name : vHistory.getChildNodeNames()) {\n            if (name.equals(JCR_VERSIONLABELS)) {\n                continue;\n            }\n            NodeBuilder predecessor = vHistory.getChildNode(name);\n            if (predecessors.contains(uuidFromNode(predecessor))) {\n                PropertyState state = predecessor.getProperty(JCR_SUCCESSORS);\n                if (state == null) {\n                    throw new IllegalStateException(\"Missing \" + JCR_SUCCESSORS +\n                            \" property on \" + predecessor);\n                }\n                Set<String> refs = Sets.newHashSet(state.getValue(Type.REFERENCES));\n                refs.add(versionUUID);\n                predecessor.setProperty(JCR_SUCCESSORS, refs, Type.REFERENCES);\n            }\n        }\n\n        // jcr:frozenNode of created version\n        VersionableState versionableState = VersionableState.fromVersion(\n                version, versionable, ntMgr);\n        if (!isRootVersion) {\n            versionableState.create();\n        }\n\n        // set jcr:isCheckedOut, jcr:versionHistory, jcr:baseVersion and\n        // jcr:predecessors on versionable node\n        versionable.setProperty(JCR_ISCHECKEDOUT, isRootVersion, Type.BOOLEAN);\n        versionable.setProperty(JCR_VERSIONHISTORY,\n                uuidFromNode(vHistory), Type.REFERENCE);\n        versionable.setProperty(JCR_BASEVERSION, versionUUID, Type.REFERENCE);\n        if (isRootVersion) {\n            // set predecessors to base version if this is the root version\n            predecessors = Collections.singletonList(versionUUID);\n        } else {\n            // otherwise clear predecessors for check-in\n            predecessors = Collections.emptyList();\n        }\n        versionable.setProperty(JCR_PREDECESSORS, predecessors, Type.REFERENCES);\n        return version;\n    }","id":22814,"modified_method":"/**\n     * Creates a version in the given version history. If the given version\n     * history does not yet have a version, then a root version is created and\n     * the versionable node is in a checked out state. Otherwise a version is\n     * created and the versionable node is set to checked in.\n     *\n     * @param vHistory the version history node.\n     * @param versionable the versionable node.\n     * @return the created version (nt:version) node.\n     * @throws CommitFailedException if creating the version fails. E.g. because\n     * the versionable node contains a OPV item with ABORT.\n     */\n    private NodeBuilder createVersion(@Nonnull NodeBuilder vHistory,\n                                      @Nonnull NodeBuilder versionable)\n            throws IllegalArgumentException, CommitFailedException {\n        List<String> predecessors;\n        NodeBuilder version;\n        boolean isRootVersion;\n        if (!vHistory.hasChildNode(JCR_ROOTVERSION)) {\n            // create root version\n            isRootVersion = true;\n            predecessors = Collections.emptyList();\n            version = vHistory.child(JCR_ROOTVERSION);\n        } else {\n            isRootVersion = false;\n            checkState(versionable.hasProperty(JCR_PREDECESSORS));\n            PropertyState state = versionable.getProperty(JCR_PREDECESSORS);\n            predecessors = ImmutableList.copyOf(state.getValue(Type.REFERENCES));\n            version = vHistory.child(calculateVersion(vHistory, versionable));\n        }\n        String versionUUID = IdentifierManager.generateUUID();\n        version.setProperty(JCR_UUID, versionUUID, Type.STRING);\n        version.setProperty(JCR_PRIMARYTYPE, NT_VERSION, Type.NAME);\n        long now = System.currentTimeMillis();\n        version.setProperty(JCR_CREATED, now, Type.DATE);\n        version.setProperty(JCR_PREDECESSORS, predecessors, Type.REFERENCES);\n        version.setProperty(JCR_SUCCESSORS, Collections.<String>emptyList(), Type.REFERENCES);\n\n        // update successors of versions identified by predecessors\n        for (String id : predecessors) {\n            String name = PathUtils.getName(getIdentifierManager().getPath(id));\n            NodeBuilder predecessor = vHistory.getChildNode(name);\n            PropertyState state = predecessor.getProperty(JCR_SUCCESSORS);\n            if (state == null) {\n                throw new IllegalStateException(\"Missing \" + JCR_SUCCESSORS +\n                        \" property on \" + predecessor);\n            }\n            Set<String> refs = Sets.newHashSet(state.getValue(Type.REFERENCES));\n            refs.add(versionUUID);\n            predecessor.setProperty(JCR_SUCCESSORS, refs, Type.REFERENCES);\n        }\n\n        // jcr:frozenNode of created version\n        VersionableState versionableState = VersionableState.fromVersion(\n                version, vHistory, versionable, this, ntMgr);\n        if (!isRootVersion) {\n            versionableState.create();\n        }\n\n        // set jcr:isCheckedOut, jcr:versionHistory, jcr:baseVersion and\n        // jcr:predecessors on versionable node\n        versionable.setProperty(JCR_ISCHECKEDOUT, isRootVersion, Type.BOOLEAN);\n        versionable.setProperty(JCR_VERSIONHISTORY,\n                uuidFromNode(vHistory), Type.REFERENCE);\n        versionable.setProperty(JCR_BASEVERSION, versionUUID, Type.REFERENCE);\n        if (isRootVersion) {\n            // set predecessors to base version if this is the root version\n            predecessors = Collections.singletonList(versionUUID);\n        } else {\n            // otherwise clear predecessors for check-in\n            predecessors = Collections.emptyList();\n        }\n        versionable.setProperty(JCR_PREDECESSORS, predecessors, Type.REFERENCES);\n        return version;\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Returns the <code>jcr:primaryType<\/code> value of the given\n     * <code>node<\/code>.\n     *\n     * @param node a node.\n     * @return the <code>jcr:primaryType<\/code> value.\n     * @throws IllegalStateException if the node does not have a <code>jcr:primaryType<\/code>\n     *                               property.\n     */\n    @Nonnull\n    static String primaryTypeOf(@Nonnull NodeBuilder node)\n            throws IllegalStateException {\n        String primaryType = node.getName(JCR_PRIMARYTYPE);\n        if (primaryType == null) {\n            throw new IllegalStateException(\"Node does not have a jcr:primaryType\");\n        }\n        return primaryType;\n    }","id":22815,"modified_method":"/**\n     * Returns the <code>jcr:primaryType<\/code> value of the given\n     * <code>node<\/code>.\n     *\n     * @param node a node.\n     * @return the <code>jcr:primaryType<\/code> value.\n     * @throws IllegalStateException if the node does not have a <code>jcr:primaryType<\/code>\n     *                               property.\n     */\n    @Nonnull\n    static String primaryTypeOf(@Nonnull NodeBuilder node)\n            throws IllegalStateException {\n        String primaryType = checkNotNull(node).getName(JCR_PRIMARYTYPE);\n        if (primaryType == null) {\n            throw new IllegalStateException(\"Node does not have a jcr:primaryType\");\n        }\n        return primaryType;\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after)\n            throws CommitFailedException {\n        if (!isVersionable()) {\n            if (!isVersionProperty(after) && wasCheckedIn()) {\n                throwCheckedIn(\"Cannot change property \" + after.getName()\n                        + \" on checked in node\");\n            }\n            return;\n        }\n        String propName = after.getName();\n        if (propName.equals(VersionConstants.JCR_ISCHECKEDOUT)) {\n            if (wasCheckedIn()) {\n                vMgr.checkout(node);\n            } else {\n                vMgr.checkin(node);\n            }\n        } else if (propName.equals(VersionConstants.JCR_BASEVERSION)) {\n            vMgr.restore(node, after.getValue(Type.REFERENCE));\n        } else if (isVersionProperty(after)) {\n            throwProtected(after.getName());\n        } else if (wasReadOnly) {\n            throwCheckedIn(\"Cannot change property \" + after.getName()\n                    + \" on checked in node\");\n        }\n    }","id":22816,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after)\n            throws CommitFailedException {\n        if (!isVersionable()) {\n            if (!isVersionProperty(after) && wasCheckedIn()) {\n                throwCheckedIn(\"Cannot change property \" + after.getName()\n                        + \" on checked in node\");\n            }\n            return;\n        }\n        String propName = after.getName();\n        if (propName.equals(VersionConstants.JCR_ISCHECKEDOUT)) {\n            if (wasCheckedIn()) {\n                vMgr.checkout(node);\n            } else {\n                vMgr.checkin(node);\n            }\n        } else if (propName.equals(VersionConstants.JCR_BASEVERSION)) {\n            vMgr.restore(node, after.getValue(Type.REFERENCE), null);\n        } else if (isVersionProperty(after)) {\n            throwProtected(after.getName());\n        } else if (wasReadOnly) {\n            throwCheckedIn(\"Cannot change property \" + after.getName()\n                    + \" on checked in node\");\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyAdded(PropertyState after)\n            throws CommitFailedException {\n        if (after.getName().equals(JcrConstants.JCR_BASEVERSION)\n                && this.after.hasProperty(JcrConstants.JCR_VERSIONHISTORY)\n                && !this.after.hasProperty(JcrConstants.JCR_ISCHECKEDOUT)\n                && !this.before.exists()) {\n            // sentinel node for restore\n            vMgr.restore(node, after.getValue(Type.REFERENCE));\n            return;\n        }\n        if (!wasReadOnly) {\n            return;\n        }\n        // JCR allows to put a lock on a checked in node.\n        if (after.getName().equals(JcrConstants.JCR_LOCKOWNER)\n                || after.getName().equals(JcrConstants.JCR_LOCKISDEEP)) {\n            return;\n        }\n        throwCheckedIn(\"Cannot add property \" + after.getName()\n                + \" on checked in node\");\n    }","id":22817,"modified_method":"@Override\n    public void propertyAdded(PropertyState after)\n            throws CommitFailedException {\n        if (after.getName().equals(JcrConstants.JCR_BASEVERSION)\n                && this.after.hasProperty(JcrConstants.JCR_VERSIONHISTORY)\n                && !this.after.hasProperty(JcrConstants.JCR_ISCHECKEDOUT)\n                && !this.before.exists()) {\n            // sentinel node for restore\n            vMgr.restore(node, after.getValue(Type.REFERENCE), null);\n            return;\n        }\n        if (!wasReadOnly) {\n            return;\n        }\n        // JCR allows to put a lock on a checked in node.\n        if (after.getName().equals(JcrConstants.JCR_LOCKOWNER)\n                || after.getName().equals(JcrConstants.JCR_LOCKISDEEP)) {\n            return;\n        }\n        throwCheckedIn(\"Cannot add property \" + after.getName()\n                + \" on checked in node\");\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a frozen node under the version and initializes it with the basic\n     * frozen properties (jcr:frozenPrimaryType, jcr:frozenMixinTypes and\n     * jcr:frozenUuid) from the given node. The node must be referenceable.\n     *\n     * @return this versionable state.\n     */\n    private VersionableState initFrozen(NodeBuilder frozen,\n                                        NodeBuilder referenceable) {\n        // initialize jcr:frozenNode\n        frozen.setProperty(JCR_UUID, IdentifierManager.generateUUID(), Type.STRING);\n        frozen.setProperty(JCR_PRIMARYTYPE, NT_FROZENNODE, Type.NAME);\n        Iterable<String> mixinTypes;\n        if (referenceable.hasProperty(JCR_MIXINTYPES)) {\n            mixinTypes = referenceable.getNames(JCR_MIXINTYPES);\n        } else {\n            mixinTypes = Collections.emptyList();\n        }\n        frozen.setProperty(JCR_FROZENMIXINTYPES, mixinTypes, Type.NAMES);\n        frozen.setProperty(JCR_FROZENPRIMARYTYPE, primaryTypeOf(referenceable), Type.NAME);\n        frozen.setProperty(JCR_FROZENUUID, uuidFromNode(referenceable), Type.STRING);\n        return this;\n    }","id":22818,"modified_method":"/**\n     * Creates a frozen node under the version and initializes it with the basic\n     * frozen properties (jcr:frozenPrimaryType, jcr:frozenMixinTypes and\n     * jcr:frozenUuid) from the given node. The node must be referenceable.\n     *\n     * @return this versionable state.\n     */\n    private VersionableState initFrozen(NodeBuilder frozen,\n                                        NodeBuilder referenceable) {\n        // initialize jcr:frozenNode\n        frozen.setProperty(JCR_UUID, IdentifierManager.generateUUID(), Type.STRING);\n        frozen.setProperty(JCR_PRIMARYTYPE, NT_FROZENNODE, Type.NAME);\n        List<String> mixinTypes;\n        if (referenceable.hasProperty(JCR_MIXINTYPES)) {\n            mixinTypes = Lists.newArrayList(referenceable.getNames(JCR_MIXINTYPES));\n        } else {\n            mixinTypes = Collections.emptyList();\n        }\n        frozen.setProperty(JCR_FROZENUUID, uuidFromNode(referenceable), Type.STRING);\n        frozen.setProperty(JCR_FROZENPRIMARYTYPE, primaryTypeOf(referenceable), Type.NAME);\n        if (mixinTypes.isEmpty()) {\n            frozen.removeProperty(JCR_FROZENMIXINTYPES);\n        } else {\n            frozen.setProperty(JCR_FROZENMIXINTYPES, mixinTypes, Type.NAMES);\n        }\n        return this;\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Restores children of a <code>src<\/code>.\n     */\n    private void restoreChildren(NodeBuilder src,\n                                 NodeBuilder dest,\n                                 VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        // 15.7.6 Restoring Child Nodes\n        for (String name : src.getChildNodeNames()) {\n            NodeBuilder srcChild = src.getChildNode(name);\n            int action = getOPV(dest, srcChild, name);\n            if (action == COPY || action == VERSION) {\n                // replace on destination\n                dest.removeChildNode(name);\n                restoreState(srcChild, dest.child(name), selector);\n            }\n        }\n        for (String name : dest.getChildNodeNames()) {\n            if (src.hasChildNode(name)) {\n                continue;\n            }\n            NodeBuilder destChild = dest.getChildNode(name);\n            int action = getOPV(dest, destChild, name);\n            if (action == COPY || action == VERSION || action == ABORT) {\n                dest.removeChildNode(name);\n            } else if (action == IGNORE) {\n                // no action\n            } else if (action == INITIALIZE) {\n                TODO.unimplemented().doNothing();\n            } else if (action == COMPUTE) {\n                // there are currently no child node definitions\n                // with OPV compute\n            }\n        }\n    }","id":22819,"modified_method":"/**\n     * Restores children of a <code>src<\/code>.\n     */\n    private void restoreChildren(NodeBuilder src,\n                                 NodeBuilder dest,\n                                 VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        // 15.7.6 Restoring Child Nodes\n        for (String name : src.getChildNodeNames()) {\n            NodeBuilder srcChild = src.getChildNode(name);\n            int action = getOPV(dest, srcChild, name);\n            if (action == COPY) {\n                // replace on destination\n                dest.removeChildNode(name);\n                restoreNode(srcChild, dest.child(name), selector);\n            } else if (action == VERSION) {\n                restoreState(srcChild, dest, name, selector);\n            }\n        }\n        for (String name : dest.getChildNodeNames()) {\n            if (src.hasChildNode(name)) {\n                continue;\n            }\n            NodeBuilder destChild = dest.getChildNode(name);\n            int action = getOPV(dest, destChild, name);\n            if (action == COPY || action == VERSION || action == ABORT) {\n                dest.removeChildNode(name);\n            } else if (action == IGNORE) {\n                // no action\n            } else if (action == INITIALIZE) {\n                TODO.unimplemented().doNothing();\n            } else if (action == COMPUTE) {\n                // there are currently no child node definitions\n                // with OPV compute\n            }\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Restore a copied node.\n     */\n    private void restoreNode(NodeBuilder src,\n                             NodeBuilder dest,\n                             VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        copyProperties(src, dest, OPVForceCopy.INSTANCE, false);\n        restoreChildren(src, dest, selector);\n    }","id":22820,"modified_method":"/**\n     * Restore a copied node.\n     */\n    private void restoreNode(NodeBuilder src,\n                             NodeBuilder dest,\n                             VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        if (primaryTypeOf(src).equals(NT_FROZENNODE)) {\n            restoreFrozen(src, dest);\n            copyProperties(src, dest, OPVForceCopy.INSTANCE, true);\n        } else {\n            copyProperties(src, dest, OPVForceCopy.INSTANCE, false);\n        }\n        restoreChildren(src, dest, selector);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void createFrozen(NodeBuilder src, NodeBuilder dest)\n            throws CommitFailedException, RepositoryException {\n        initFrozen(dest, src);\n        copyProperties(src, dest, new OPVProvider() {\n            @Override\n            public int getAction(NodeBuilder src,\n                                 NodeBuilder dest,\n                                 PropertyState prop)\n                    throws RepositoryException {\n                return getOPV(src, prop);\n            }\n        }, true);\n\n        // add the frozen children and histories\n        for (String name : src.getChildNodeNames()) {\n            NodeBuilder child = src.getChildNode(name);\n            int opv = getOPV(src, child, name);\n\n            if (opv == OnParentVersionAction.ABORT) {\n                throw new CommitFailedException(CommitFailedException.VERSION,\n                        VersionExceptionCode.OPV_ABORT_ITEM_PRESENT.ordinal(),\n                        \"Checkin aborted due to OPV abort in \" + name);\n            }\n            if (opv == OnParentVersionAction.VERSION) {\n                if (ntMgr.isNodeType(new ReadOnlyTree(child.getNodeState()), MIX_VERSIONABLE)) {\n                    // create frozen versionable child\n                    versionedChild(child, dest.child(name));\n                } else if (isReferenceable(child)) {\n                    createFrozen(child, dest.child(name));\n                } else {\n                    // else copy\n                    copy(child, dest.child(name));\n                }\n            } else if (opv == COPY) {\n                if (isReferenceable(child)) {\n                    createFrozen(child, dest.child(name));\n                } else {\n                    copy(child, dest.child(name));\n                }\n            }\n        }\n    }","id":22821,"modified_method":"private void createFrozen(NodeBuilder src, NodeBuilder dest)\n            throws CommitFailedException, RepositoryException {\n        initFrozen(dest, src);\n        copyProperties(src, dest, new OPVProvider() {\n            @Override\n            public int getAction(NodeBuilder src,\n                                 NodeBuilder dest,\n                                 PropertyState prop)\n                    throws RepositoryException {\n                return getOPV(src, prop);\n            }\n        }, true);\n\n        // add the frozen children and histories\n        for (String name : src.getChildNodeNames()) {\n            NodeBuilder child = src.getChildNode(name);\n            int opv = getOPV(src, child, name);\n\n            if (opv == OnParentVersionAction.ABORT) {\n                throw new CommitFailedException(CommitFailedException.VERSION,\n                        VersionExceptionCode.OPV_ABORT_ITEM_PRESENT.ordinal(),\n                        \"Checkin aborted due to OPV abort in \" + name);\n            }\n            if (opv == OnParentVersionAction.VERSION) {\n                if (ntMgr.isNodeType(new ReadOnlyTree(child.getNodeState()), MIX_VERSIONABLE)) {\n                    // create frozen versionable child\n                    versionedChild(child, dest.child(name));\n                } else {\n                    // else copy\n                    copy(child, dest.child(name));\n                }\n            } else if (opv == COPY) {\n                copy(child, dest.child(name));\n            }\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private VersionableState(@Nonnull NodeBuilder version,\n                             @Nonnull NodeBuilder versionable,\n                             @Nonnull ReadOnlyNodeTypeManager ntMgr) {\n        this.version = checkNotNull(version);\n        this.frozenNode = version.child(JCR_FROZENNODE);\n        this.versionable = checkNotNull(versionable);\n        this.ntMgr = checkNotNull(ntMgr);\n    }","id":22822,"modified_method":"private VersionableState(@Nonnull NodeBuilder version,\n                             @Nonnull NodeBuilder history,\n                             @Nonnull NodeBuilder versionable,\n                             @Nonnull ReadWriteVersionManager vMgr,\n                             @Nonnull ReadOnlyNodeTypeManager ntMgr) {\n        this.version = checkNotNull(version);\n        this.history = checkNotNull(history);\n        this.frozenNode = version.child(JCR_FROZENNODE);\n        this.versionable = checkNotNull(versionable);\n        this.vMgr = checkNotNull(vMgr);\n        this.ntMgr = checkNotNull(ntMgr);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a frozen node under the version and initializes it with the basic\n     * frozen properties (jcr:frozenPrimaryType, jcr:frozenMixinTypes and\n     * jcr:frozenUuid) from the given versionable node.\n     *\n     * @param version the parent node of the frozen node.\n     * @param versionable the versionable node.\n     * @param ntMgr the node type manager.\n     * @return a versionable state\n     */\n    @Nonnull\n    static VersionableState fromVersion(@Nonnull NodeBuilder version,\n                                        @Nonnull NodeBuilder versionable,\n                                        @Nonnull ReadOnlyNodeTypeManager ntMgr) {\n        VersionableState state = new VersionableState(version, versionable, ntMgr);\n        return state.initFrozen(version.child(JCR_FROZENNODE), versionable);\n    }","id":22823,"modified_method":"/**\n     * Creates a frozen node under the version and initializes it with the basic\n     * frozen properties (jcr:frozenPrimaryType, jcr:frozenMixinTypes and\n     * jcr:frozenUuid) from the given versionable node.\n     *\n     * @param version the parent node of the frozen node.\n     * @param history the history node of the version.\n     * @param versionable the versionable node.\n     * @param vMgr the version manager.\n     * @param ntMgr the node type manager.\n     * @return a versionable state\n     */\n    @Nonnull\n    static VersionableState fromVersion(@Nonnull NodeBuilder version,\n                                        @Nonnull NodeBuilder history,\n                                        @Nonnull NodeBuilder versionable,\n                                        @Nonnull ReadWriteVersionManager vMgr,\n                                        @Nonnull ReadOnlyNodeTypeManager ntMgr) {\n        VersionableState state = new VersionableState(version, history, versionable, vMgr, ntMgr);\n        return state.initFrozen(version.child(JCR_FROZENNODE), versionable);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a versionable state for a restore.\n     *\n     * @param version the version to restore.\n     * @param versionable the versionable node.\n     * @param ntMgr the node type manager.\n     * @return a versionable state.\n     */\n    static VersionableState forRestore(@Nonnull NodeBuilder version,\n                                       @Nonnull NodeBuilder versionable,\n                                       @Nonnull ReadOnlyNodeTypeManager ntMgr) {\n        return new VersionableState(version, versionable, ntMgr);\n    }","id":22824,"modified_method":"/**\n     * Creates a versionable state for a restore.\n     *\n     * @param version the version to restore.\n     * @param history the history node of the version.\n     * @param versionable the versionable node.\n     * @param vMgr the version manager.\n     * @param ntMgr the node type manager.\n     * @return a versionable state.\n     */\n    static VersionableState forRestore(@Nonnull NodeBuilder version,\n                                       @Nonnull NodeBuilder history,\n                                       @Nonnull NodeBuilder versionable,\n                                       @Nonnull ReadWriteVersionManager vMgr,\n                                       @Nonnull ReadOnlyNodeTypeManager ntMgr) {\n        return new VersionableState(version, history, versionable, vMgr, ntMgr);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void restoreState(@Nonnull NodeBuilder src,\n                              @Nonnull NodeBuilder dest,\n                              @Nonnull VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        String primaryType = primaryTypeOf(src);\n        if (primaryType.equals(NT_FROZENNODE)) {\n            restoreFrozen(src, dest, selector);\n        } else if (primaryType.equals(NT_VERSIONEDCHILD)) {\n            restoreVersionedChild(src, dest, selector);\n        } else {\n            restoreNode(src, dest, selector);\n        }\n    }","id":22825,"modified_method":"/**\n     * Restores the state from <code>src<\/code> to a child node of\n     * <code>destParent<\/code> with the same name as <code>src<\/code>.\n     *\n     * @param src the source node.\n     * @param destParent the parent of the destination node.\n     * @param name the name of the source node.\n     * @param selector the version selector.\n     */\n    private void restoreState(@Nonnull NodeBuilder src,\n                              @Nonnull NodeBuilder destParent,\n                              @Nonnull String name,\n                              @Nonnull VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        checkNotNull(name);\n        checkNotNull(destParent);\n        String primaryType = primaryTypeOf(src);\n        if (primaryType.equals(NT_FROZENNODE)) {\n            // replace with frozen state\n            destParent.removeChildNode(name);\n            restoreFrozen(src, destParent.child(name), selector);\n        } else if (primaryType.equals(NT_VERSIONEDCHILD)) {\n            // only perform chained restore if the node didn't exist\n            // before. see 15.7.5 and RestoreTest#testRestoreName\n            if (!destParent.hasChildNode(name)) {\n                restoreVersionedChild(src, destParent.child(name), selector);\n            }\n        } else {\n            // replace\n            destParent.removeChildNode(name);\n            restoreNode(src, destParent.child(name), selector);\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void copy(NodeBuilder src,\n                      NodeBuilder dest)\n            throws RepositoryException, CommitFailedException {\n        copyProperties(src, dest, OPVForceCopy.INSTANCE, false);\n        for (String name : src.getChildNodeNames()) {\n            NodeBuilder child = src.getChildNode(name);\n            if (isReferenceable(child)) {\n                createFrozen(child, dest.child(name));\n            } else {\n                copy(child, dest.child(name));\n            }\n        }\n    }","id":22826,"modified_method":"private void copy(NodeBuilder src,\n                      NodeBuilder dest)\n            throws RepositoryException, CommitFailedException {\n        if (isReferenceable(src)) {\n            initFrozen(dest, src);\n            copyProperties(src, dest, OPVForceCopy.INSTANCE, true);\n        } else {\n            copyProperties(src, dest, OPVForceCopy.INSTANCE, false);\n        }\n        for (String name : src.getChildNodeNames()) {\n            NodeBuilder child = src.getChildNode(name);\n            copy(child, dest.child(name));\n        }\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * 15.7.7 Simple vs. Full Versioning after Restore\n     */\n    private void restoreVersionable(@Nonnull NodeBuilder versionable,\n                                    @Nonnull NodeBuilder version) {\n        checkNotNull(versionable).setProperty(JCR_ISCHECKEDOUT,\n                false, Type.BOOLEAN);\n        versionable.setProperty(JCR_BASEVERSION,\n                uuidFromNode(version), Type.REFERENCE);\n        versionable.setProperty(JCR_PREDECESSORS,\n                Collections.<String>emptyList(), Type.REFERENCES);\n    }","id":22827,"modified_method":"/**\n     * 15.7.7 Simple vs. Full Versioning after Restore\n     */\n    private void restoreVersionable(@Nonnull NodeBuilder versionable,\n                                    @Nonnull NodeBuilder version) {\n        checkNotNull(versionable).setProperty(JCR_ISCHECKEDOUT,\n                false, Type.BOOLEAN);\n        versionable.setProperty(JCR_VERSIONHISTORY, uuidFromNode(history));\n        versionable.setProperty(JCR_BASEVERSION,\n                uuidFromNode(version), Type.REFERENCE);\n        versionable.setProperty(JCR_PREDECESSORS,\n                Collections.<String>emptyList(), Type.REFERENCES);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Restore an nt:versionedChild node.\n     */\n    private void restoreVersionedChild(NodeBuilder versionedChild,\n                                       NodeBuilder dest,\n                                       VersionSelector selector)\n            throws RepositoryException {\n        // 15.7.5 Chained Versions on Restore\n        TODO.unimplemented().doNothing();\n        // ...\n        // restoreVersionable(dest, selector.select(history));\n    }","id":22828,"modified_method":"/**\n     * Restore an nt:versionedChild node.\n     */\n    private void restoreVersionedChild(NodeBuilder versionedChild,\n                                       NodeBuilder dest,\n                                       VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        // 15.7.5 Chained Versions on Restore\n        PropertyState id = versionedChild.getProperty(JCR_CHILDVERSIONHISTORY);\n        if (id == null) {\n            throw new RepositoryException(\"Mandatory property \" +\n                    JCR_CHILDVERSIONHISTORY + \" is missing.\");\n        }\n        vMgr.restore(id.getValue(Type.REFERENCE), selector, dest);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Restore a nt:frozenNode.\n     */\n    private void restoreFrozen(NodeBuilder frozen,\n                               NodeBuilder dest,\n                               VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        // 15.7.2 Restoring Type and Identifier\n        dest.setProperty(JCR_PRIMARYTYPE,\n                frozen.getName(JCR_FROZENPRIMARYTYPE), Type.NAME);\n        dest.setProperty(JCR_UUID,\n                frozen.getProperty(JCR_FROZENUUID).getValue(Type.STRING),\n                Type.STRING);\n        if (frozen.hasProperty(JCR_FROZENMIXINTYPES)) {\n            dest.setProperty(JCR_MIXINTYPES,\n                    frozen.getNames(JCR_FROZENMIXINTYPES), Type.NAMES);\n        }\n        // 15.7.3 Restoring Properties\n        for (PropertyState p : frozen.getProperties()) {\n            if (BASIC_FROZEN_PROPERTIES.contains(p.getName())) {\n                // ignore basic frozen properties we restored earlier\n                continue;\n            }\n            int action = getOPV(dest, p);\n            if (action == COPY || action == VERSION) {\n                dest.setProperty(p);\n            }\n        }\n        for (PropertyState p : dest.getProperties()) {\n            if (BASIC_PROPERTIES.contains(p.getName())) {\n                continue;\n            }\n            if (frozen.hasProperty(p.getName())) {\n                continue;\n            }\n            int action = getOPV(dest, p);\n            if (action == COPY || action == VERSION || action == ABORT) {\n                dest.removeProperty(p.getName());\n            } else if (action == IGNORE) {\n                // no action\n            } else if (action == INITIALIZE) {\n                resetToDefaultValue(dest, p);\n            } else if (action == COMPUTE) {\n                // only COMPUTE property definitions currently are\n                // jcr:primaryType and jcr:mixinTypes\n                // do nothing for now\n            }\n        }\n        restoreChildren(frozen, dest, selector);\n    }","id":22829,"modified_method":"/**\n     * Restore a nt:frozenNode.\n     */\n    private void restoreFrozen(@Nonnull NodeBuilder frozen,\n                               @Nonnull NodeBuilder dest,\n                               @Nonnull VersionSelector selector)\n            throws RepositoryException, CommitFailedException {\n        // 15.7.2 Restoring Type and Identifier\n        restoreFrozen(frozen, dest);\n        // 15.7.3 Restoring Properties\n        for (PropertyState p : frozen.getProperties()) {\n            if (BASIC_FROZEN_PROPERTIES.contains(p.getName())) {\n                // ignore basic frozen properties we restored earlier\n                continue;\n            }\n            int action = getOPV(dest, p);\n            if (action == COPY || action == VERSION) {\n                dest.setProperty(p);\n            }\n        }\n        for (PropertyState p : dest.getProperties()) {\n            if (BASIC_PROPERTIES.contains(p.getName())) {\n                continue;\n            }\n            if (frozen.hasProperty(p.getName())) {\n                continue;\n            }\n            int action = getOPV(dest, p);\n            if (action == COPY || action == VERSION || action == ABORT) {\n                dest.removeProperty(p.getName());\n            } else if (action == IGNORE) {\n                // no action\n            } else if (action == INITIALIZE) {\n                resetToDefaultValue(dest, p);\n            } else if (action == COMPUTE) {\n                // only COMPUTE property definitions currently are\n                // jcr:primaryType and jcr:mixinTypes\n                // do nothing for now\n            }\n        }\n        restoreChildren(frozen, dest, selector);\n    }","commit_id":"60045a4919e72573953c17854a8c23a53bfa2d9c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Collection<TestCase> testCasesCoveringLine(int line) {\n    List<TestCase> testCases = newArrayList();\n    for (Edge edge : getCovers()){\n      if (Iterables.contains(getCoveredLines(edge), Long.valueOf(line))){\n        Vertex vertexTestable = edge.getVertex(Direction.OUT);\n        DefaultTestCase testCase = beanGraph().wrap(vertexTestable, DefaultTestCase.class);\n        testCases.add(testCase);\n      }\n    }\n    return testCases;\n  }","id":22830,"modified_method":"public Collection<TestCase> testCasesOfLine(int line) {\n    ImmutableList.Builder<TestCase> cases = ImmutableList.builder();\n    for (Edge edge : getCovers()) {\n      if (Iterables.contains(testedLines(edge), Long.valueOf(line))) {\n        Vertex vertexTestable = edge.getVertex(Direction.OUT);\n        DefaultTestCase testCase = beanGraph().wrap(vertexTestable, DefaultTestCase.class);\n        cases.add(testCase);\n      }\n    }\n    return cases.build();\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Collection<TestCase> coveringTestCases() {\n    List<TestCase> testCases = newArrayList();\n    for (Edge edge : getCovers()){\n      Vertex testable = edge.getVertex(Direction.OUT);\n      testCases.add(beanGraph().wrap(testable, DefaultTestCase.class));\n    }\n    return testCases;\n  }","id":22831,"modified_method":"public Collection<TestCase> testCases() {\n    List<TestCase> testCases = newArrayList();\n    for (Edge edge : getCovers()) {\n      Vertex testable = edge.getVertex(Direction.OUT);\n      testCases.add(beanGraph().wrap(testable, DefaultTestCase.class));\n    }\n    return testCases;\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private List<Long> getCoveredLines(Edge edge){\n    return (List<Long>) edge.getProperty(\"lines\");\n  }","id":22832,"modified_method":"private List<Long> testedLines(Edge edge) {\n    return (List<Long>) edge.getProperty(\"lines\");\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SortedSet<Long> coveredLines() {\n    SortedSet<Long> coveredLines = newTreeSet();\n    for (Edge edge : getCovers()){\n      coveredLines.addAll(getCoveredLines(edge));\n    }\n    return coveredLines;\n  }","id":22833,"modified_method":"public SortedSet<Long> testedLines() {\n    ImmutableSortedSet.Builder<Long> coveredLines = ImmutableSortedSet.naturalOrder();\n    for (Edge edge : getCovers()) {\n      coveredLines.addAll(testedLines(edge));\n    }\n    return coveredLines.build();\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static <T extends Element> T single(Iterable<T> iterable) {\n    Iterator<T> iterator = iterable.iterator();\n    T result = null;\n    if (iterator.hasNext()) {\n      result = iterator.next();\n      if (iterator.hasNext()) {\n        throw new MultipleElementsException(\"More than one elements\");\n      }\n    }\n    return result;\n  }","id":22834,"modified_method":"public static <T extends Element> T single(Iterable<T> iterable) {\n    Iterator<T> iterator = iterable.iterator();\n    T result = null;\n    if (iterator.hasNext()) {\n      result = iterator.next();\n      if (iterator.hasNext()) {\n        throw new MultipleElementsException(\"More than one element\");\n      }\n    }\n    return result;\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void save() {\n    LoggerFactory.getLogger(ScanGraphStore.class).info(\"Persisting graphs of components\");\n    BatchSession session = myBatis.openBatchSession();\n    GraphDtoMapper mapper = session.getMapper(GraphDtoMapper.class);\n    try {\n      GraphWriter writer = new GraphWriter();\n      for (ComponentVertex component : projectGraph.getComponents()) {\n        Long snapshotId = (Long) component.element().getProperty(\"sid\");\n        if (snapshotId != null) {\n          for (PerspectiveBuilder builder : builders) {\n            Perspective perspective = builder.load(component);\n            if (perspective != null) {\n              Graph subGraph = SubGraph.extract(component.element(), builder.path());\n              String data = writer.write(subGraph);\n              mapper.insert(new GraphDto()\n                .setData(data)\n                .setFormat(\"graphson\")\n                .setPerspective(builder.getPerspectiveKey())\n                .setVersion(1)\n                .setResourceId((Long) component.element().getProperty(\"rid\"))\n                .setSnapshotId(snapshotId)\n                .setRootVertexId(component.element().getId().toString())\n              );\n            }\n          }\n        }\n      }\n      session.commit();\n    } finally {\n      session.close();\n    }\n  }","id":22835,"modified_method":"public void save() {\n    LoggerFactory.getLogger(ScanGraphStore.class).info(\"Persisting graphs of components\");\n    BatchSession session = myBatis.openBatchSession();\n    GraphDtoMapper mapper = session.getMapper(GraphDtoMapper.class);\n    try {\n      GraphWriter writer = new GraphWriter();\n      for (ComponentVertex component : projectGraph.getComponents()) {\n        Long snapshotId = (Long) component.element().getProperty(\"sid\");\n        if (snapshotId != null) {\n          for (PerspectiveBuilder builder : builders) {\n            Perspective perspective = builder.load(component);\n            if (perspective != null) {\n              Graph subGraph = SubGraph.extract(component.element(), builder.storagePath());\n              String data = writer.write(subGraph);\n              mapper.insert(new GraphDto()\n                .setData(data)\n                .setFormat(\"graphson\")\n                .setPerspective(builder.getPerspectiveKey())\n                .setVersion(1)\n                .setResourceId((Long) component.element().getProperty(\"rid\"))\n                .setSnapshotId(snapshotId)\n                .setRootVertexId(component.element().getId().toString())\n              );\n            }\n          }\n        }\n      }\n      session.commit();\n    } finally {\n      session.close();\n    }\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private Vertex copy(Vertex v) {\n    Vertex to = sub.addVertex(v.getId());\n    ElementHelper.copyProperties(v, to);\n    return to;\n  }","id":22836,"modified_method":"private Vertex copy(Vertex v) {\n    Vertex to = sub.getVertex(v.getId());\n    if (to == null) {\n      to = sub.addVertex(v.getId());\n      ElementHelper.copyProperties(v, to);\n    }\n    return to;\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_extract_graph() {\n    Graph sub = SubGraph.extract(a, \"uses\", Direction.OUT, \"implements\", Direction.OUT);\n\n    // a -uses-> b\n    // a -uses-> d -implements-> e\n    assertThat(sub.getVertices()).hasSize(4);\n    assertThat(sub.getVertex(a.getId()).getProperty(\"key\")).isEqualTo(\"a\");\n    assertThat(sub.getVertex(b.getId()).getProperty(\"key\")).isEqualTo(\"b\");\n    assertThat(sub.getVertex(c.getId())).isNull();\n    assertThat(sub.getVertex(d.getId()).getProperty(\"key\")).isEqualTo(\"d\");\n    assertThat(sub.getVertex(e.getId()).getProperty(\"key\")).isEqualTo(\"e\");\n\n    assertThat(sub.getEdges()).hasSize(3);\n    assertThat(sub.getEdge(ab.getId()).getLabel()).isEqualTo(\"uses\");\n    assertThat(sub.getEdge(ab.getId()).toString()).isEqualTo(ab.toString());\n    assertThat(sub.getEdge(bc.getId())).isNull();\n    assertThat(sub.getEdge(ad.getId()).toString()).isEqualTo(ad.toString());\n    assertThat(sub.getEdge(de.getId()).toString()).isEqualTo(de.toString());\n  }","id":22837,"modified_method":"@Test\n  public void should_extract_graph() {\n    TinkerGraph graph = new TinkerGraph();\n    Vertex a = GraphHelper.addVertex(graph, null, \"key\", \"a\");\n    Vertex b = GraphHelper.addVertex(graph, null, \"key\", \"b\");\n    Vertex c = GraphHelper.addVertex(graph, null, \"key\", \"c\");\n    Vertex d = GraphHelper.addVertex(graph, null, \"key\", \"d\");\n    Vertex e = GraphHelper.addVertex(graph, null, \"key\", \"e\");\n\n    Edge ab = GraphHelper.addEdge(graph, null, a, b, \"uses\");\n    Edge bc = GraphHelper.addEdge(graph, null, b, c, \"inherits\");\n    Edge ad = GraphHelper.addEdge(graph, null, a, d, \"uses\");\n    Edge de = GraphHelper.addEdge(graph, null, d, e, \"implements\");\n\n    // a -uses-> b -inherits -> c\n    // a -uses-> d -implements-> e\n\n    Graph sub = SubGraph.extract(a, \"uses\", Direction.OUT, \"implements\", Direction.OUT);\n\n    // a -uses-> b\n    // a -uses-> d -implements-> e\n    assertThat(sub.getVertices()).hasSize(4);\n    assertThat(sub.getVertex(a.getId()).getProperty(\"key\")).isEqualTo(\"a\");\n    assertThat(sub.getVertex(b.getId()).getProperty(\"key\")).isEqualTo(\"b\");\n    assertThat(sub.getVertex(c.getId())).isNull();\n    assertThat(sub.getVertex(d.getId()).getProperty(\"key\")).isEqualTo(\"d\");\n    assertThat(sub.getVertex(e.getId()).getProperty(\"key\")).isEqualTo(\"e\");\n\n    assertThat(sub.getEdges()).hasSize(3);\n    assertThat(sub.getEdge(ab.getId()).getLabel()).isEqualTo(\"uses\");\n    assertThat(sub.getEdge(ab.getId()).toString()).isEqualTo(ab.toString());\n    assertThat(sub.getEdge(bc.getId())).isNull();\n    assertThat(sub.getEdge(ad.getId()).toString()).isEqualTo(ad.toString());\n    assertThat(sub.getEdge(de.getId()).toString()).isEqualTo(de.toString());\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_check_edge_direction() {\n    Graph sub = SubGraph.extract(a, \"uses\", Direction.IN /* instead of out */, \"implements\", Direction.OUT);\n\n    assertThat(sub.getVertices()).hasSize(1);\n    assertThat(sub.getVertex(a.getId())).isNotNull();\n    assertThat(sub.getEdges()).isEmpty();\n  }","id":22838,"modified_method":"@Test\n  public void should_check_edge_direction() {\n    TinkerGraph graph = new TinkerGraph();\n    Vertex a = GraphHelper.addVertex(graph, null, \"key\", \"a\");\n    Vertex b = GraphHelper.addVertex(graph, null, \"key\", \"b\");\n    Vertex c = GraphHelper.addVertex(graph, null, \"key\", \"c\");\n    Vertex d = GraphHelper.addVertex(graph, null, \"key\", \"d\");\n    Vertex e = GraphHelper.addVertex(graph, null, \"key\", \"e\");\n\n    Edge ab = GraphHelper.addEdge(graph, null, a, b, \"uses\");\n    Edge bc = GraphHelper.addEdge(graph, null, b, c, \"inherits\");\n    Edge ad = GraphHelper.addEdge(graph, null, a, d, \"uses\");\n    Edge de = GraphHelper.addEdge(graph, null, d, e, \"implements\");\n\n    // a -uses-> b -inherits -> c\n    // a -uses-> d -implements-> e\n\n    Graph sub = SubGraph.extract(a, \"uses\", Direction.IN /* instead of out */, \"implements\", Direction.OUT);\n\n    assertThat(sub.getVertices()).hasSize(1);\n    assertThat(sub.getVertex(a.getId())).isNotNull();\n    assertThat(sub.getEdges()).isEmpty();\n  }","commit_id":"7a1de48e56dcefa56e13891205c84adbd86da741","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\r\n\tprotected void onRender(final MarkupStream markupStream)\r\n\t{\r\n\t\tfinal int markupStart = markupStream.getCurrentIndex();\r\n\t\tResponse response = RequestCycle.get().getResponse();\r\n\t\tint widths[] = computeColumnWidths();\r\n\t\t\t\r\n\t\tif (columns.isEmpty() == false)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < columns.size(); ++i)\r\n\t\t\t{\r\n\t\t\t\tComponent component = components.get(i);\r\n\t\t\t\t\r\n\t\t\t\tresponse.write(\"<span class=\\\"column\\\" style=\\\"width:\" + widths[i] + \"%\\\">\");\r\n\t\t\t\tresponse.write(\"<span class=\\\"column-inner\\\">\");\r\n\r\n\t\t\t\tmarkupStream.setCurrentIndex(markupStart);\t\t\t\t\r\n\t\t\t\tcomponent.render(markupStream);\r\n\t\t\t\t\r\n\t\t\t\tresponse.write(\"<\/span><\/span>\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmarkupStream.skipComponent();\r\n\t\t}\t\t\r\n\t}","id":22839,"modified_method":"@Override\r\n\tprotected void onRender(final MarkupStream markupStream)\r\n\t{\r\n\t\tfinal int markupStart = markupStream.getCurrentIndex();\r\n\t\tResponse response = RequestCycle.get().getResponse();\r\n\t\tint widths[] = computeColumnWidths();\r\n\t\tboolean rendered = false;\t\r\n\t\t\r\n\t\tfor (int i = 0; i < columns.size(); ++i)\r\n\t\t{\r\n\t\t\tComponent component = components.get(i);\r\n\t\t\tRenderable renderable = renderables.get(i);\r\n\t\t\t\r\n\t\t\tresponse.write(\"<span class=\\\"column\\\" style=\\\"width:\" + widths[i] + \"%\\\">\");\r\n\t\t\tresponse.write(\"<span class=\\\"column-inner\\\">\");\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tif (component != null)\r\n\t\t\t{\r\n\t\t\t\tmarkupStream.setCurrentIndex(markupStart);\r\n\t\t\t\tcomponent.render(markupStream);\r\n\t\t\t\trendered = true;\r\n\t\t\t}\r\n\t\t\telse if (renderable != null)\r\n\t\t\t{\r\n\t\t\t\trenderable.render(response);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthrow new IllegalStateException(\"Either renderable or cell component must be created for this noode\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresponse.write(\"<\/span><\/span>\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tif (rendered == false)\r\n\t\t{\r\n\t\t\tmarkupStream.skipComponent();\r\n\t\t}\t\t\r\n\t}","commit_id":"24ade2ee492b95abd5b2cf9349410ff4b9552652","url":"https://github.com/apache/wicket"},{"original_method":"public void addColumn(Column column, Component component)\r\n\t{\r\n\t\tif (column.isVisible())\r\n\t\t{\r\n\t\t\tcolumns.add(column);\r\n\t\t\tcomponents.add(component);\r\n\t\t}\r\n\t}","id":22840,"modified_method":"public void addColumn(Column column, Component component, Renderable renderable)\r\n\t{\r\n\t\tif (column.isVisible())\r\n\t\t{\r\n\t\t\tcolumns.add(column);\r\n\t\t\tcomponents.add(component);\r\n\t\t\trenderables.add(renderable);\t\t\t\t\t\r\n\t\t}\r\n\t}","commit_id":"24ade2ee492b95abd5b2cf9349410ff4b9552652","url":"https://github.com/apache/wicket"},{"original_method":"@Override\r\n\tprotected void onRender(final MarkupStream markupStream)\r\n\t{\r\n\t\tfinal int markupStart = markupStream.getCurrentIndex();\r\n\t\tResponse response = RequestCycle.get().getResponse();\r\n\t\r\n\t\tboolean firstLeft = true; // whether there was no left column rendered yet\r\n\t\t\r\n\t\tif (columns.isEmpty() == false)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < columns.size(); ++i)\r\n\t\t\t{\r\n\t\t\t\tColumn column = columns.get(i);\r\n\t\t\t\tComponent component = components.get(i);\r\n\t\t\t\t\r\n\t\t\t\tresponse.write(\"<span class=\\\"column\\\" style=\\\"\" + renderColumnStyle(column) + \"\\\">\");\r\n\t\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT && firstLeft == true)\r\n\t\t\t\t{\r\n\t\t\t\t\tresponse.write(\"<span class=\\\"column-inner-first\\\">\");\r\n\t\t\t\t\tfirstLeft = false;\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tresponse.write(\"<span class=\\\"column-inner\\\">\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmarkupStream.setCurrentIndex(markupStart);\t\t\t\t\r\n\t\t\t\tcomponent.render(markupStream);\r\n\t\t\t\t\r\n\t\t\t\tresponse.write(\"<\/span><\/span>\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmarkupStream.skipComponent();\r\n\t\t}\t\t\r\n\t}","id":22841,"modified_method":"@Override\r\n\tprotected void onRender(final MarkupStream markupStream)\r\n\t{\r\n\t\tfinal int markupStart = markupStream.getCurrentIndex();\r\n\t\tResponse response = RequestCycle.get().getResponse();\r\n\t\r\n\t\tboolean firstLeft = true; // whether there was no left column rendered yet\r\n\t\tboolean rendered = false;\r\n\t\t\r\n\t\tfor (int i = 0; i < columns.size(); ++i)\r\n\t\t{\r\n\t\t\tColumn column = columns.get(i);\r\n\t\t\tComponent component = components.get(i);\r\n\t\t\tRenderable renderable = renderables.get(i);\r\n\t\t\t\r\n\t\t\tresponse.write(\"<span class=\\\"column\\\" style=\\\"\" + renderColumnStyle(column) + \"\\\">\");\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT && firstLeft == true)\r\n\t\t\t{\r\n\t\t\t\tresponse.write(\"<span class=\\\"column-inner-first\\\">\");\r\n\t\t\t\tfirstLeft = false;\r\n\t\t\t}\t\t\t\t\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresponse.write(\"<span class=\\\"column-inner\\\">\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (component != null)\r\n\t\t\t{\r\n\t\t\t\tmarkupStream.setCurrentIndex(markupStart);\r\n\t\t\t\tcomponent.render(markupStream);\r\n\t\t\t\trendered = true;\r\n\t\t\t}\r\n\t\t\telse if (renderable != null)\r\n\t\t\t{\r\n\t\t\t\trenderable.render(response);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthrow new IllegalStateException(\"Either renderable or cell component must be created for this noode\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tresponse.write(\"<\/span><\/span>\\n\");\r\n\t\t}\r\n\t\t\r\n\t\tif (rendered == false)\r\n\t\t{\r\n\t\t\tmarkupStream.skipComponent();\r\n\t\t}\t\t\r\n\t}","commit_id":"24ade2ee492b95abd5b2cf9349410ff4b9552652","url":"https://github.com/apache/wicket"},{"original_method":"public void addColumn(Column column, Component component)\r\n\t{\r\n\t\tif (column.isVisible())\r\n\t\t{\r\n\t\t\tcolumns.add(column);\r\n\t\t\tcomponents.add(component);\r\n\t\t}\r\n\t}","id":22842,"modified_method":"public void addColumn(Column column, Component component, Renderable renderable)\r\n\t{\r\n\t\tif (column.isVisible())\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT)\r\n\t\t\t{\r\n\t\t\t\tcolumns.add(column);\r\n\t\t\t\tcomponents.add(component);\r\n\t\t\t\trenderables.add(renderable);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcolumns.add(0, column);\r\n\t\t\t\tcomponents.add(0, component);\r\n\t\t\t\trenderables.add(0, renderable);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"24ade2ee492b95abd5b2cf9349410ff4b9552652","url":"https://github.com/apache/wicket"},{"original_method":"@Override\r\n\tprotected void populateTreeItem(WebMarkupContainer<TreeNode> item, int level) \r\n\t{\t\r\n\t\tfinal TreeNode node = item.getModelObject();\r\n\r\n\t\tint i = 0;\r\n\t\t\r\n\t\tSideColumnsView sideColumns = new SideColumnsView(item, \"sideColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT ||\r\n\t\t\t\tcolumn.getLocation().getAlignment() == Alignment.RIGHT)\r\n\t\t\t{\r\n\t\t\t\tComponent component = column.createCell(sideColumns, \"\" + i++, node, level);\r\n\t\t\t\tsideColumns.addColumn(column, component);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ti = 0;\r\n\t\t\r\n\t\tMiddleColumnsView middleColumns = new MiddleColumnsView(item, \"middleColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.MIDDLE)\r\n\t\t\t{\r\n\t\t\t\tComponent component = column.createCell(middleColumns, \"\" + i++, node, level);\r\n\t\t\t\tmiddleColumns.addColumn(column, component);\r\n\t\t\t}\r\n\t\t}\t\t\t\r\n\t\t\r\n\t\t// do distinguish between selected and unselected rows we add an behavior\r\n\t\t// that modifies row css class.\r\n\t\titem.add(new AbstractBehavior() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onComponentTag(Component component, ComponentTag tag) {\r\n\t\t\t\tsuper.onComponentTag(component, tag);\r\n\t\t\t\tif (getTreeState().isNodeSelected(node))\r\n\t\t\t\t\ttag.put(\"class\", \"row-selected\");\r\n\t\t\t\telse\r\n\t\t\t\t\ttag.put(\"class\", \"row\");\r\n\t\t\t}\r\n\t\t});\t\t\r\n\t}","id":22843,"modified_method":"@Override\r\n\tprotected void populateTreeItem(WebMarkupContainer<TreeNode> item, int level) \r\n\t{\t\r\n\t\tfinal TreeNode node = item.getModelObject();\r\n\r\n\t\tint i = 0;\r\n\t\t\r\n\t\tSideColumnsView sideColumns = new SideColumnsView(item, \"sideColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT ||\r\n\t\t\t\tcolumn.getLocation().getAlignment() == Alignment.RIGHT)\r\n\t\t\t{\r\n\t\t\t\tComponent component;\r\n\t\t\t\tRenderable renderable = column.createCell(node, level);\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif (renderable == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcomponent = column.createCell(sideColumns, \"\" + i++, node, level);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcomponent = null;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tsideColumns.addColumn(column, component, renderable);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ti = 0;\r\n\t\t\r\n\t\tMiddleColumnsView middleColumns = new MiddleColumnsView(item, \"middleColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.MIDDLE)\r\n\t\t\t{\r\n\t\t\t\tComponent component;\r\n\t\t\t\tRenderable renderable = column.createCell(node, level);\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif (renderable == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcomponent = column.createCell(sideColumns, \"\" + i++, node, level);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcomponent = null;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tmiddleColumns.addColumn(column, component, renderable);\r\n\t\t\t}\r\n\t\t}\t\t\t\r\n\t\t\r\n\t\t// do distinguish between selected and unselected rows we add an behavior\r\n\t\t// that modifies row css class.\r\n\t\titem.add(new AbstractBehavior() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onComponentTag(Component component, ComponentTag tag) {\r\n\t\t\t\tsuper.onComponentTag(component, tag);\r\n\t\t\t\tif (getTreeState().isNodeSelected(node))\r\n\t\t\t\t\ttag.put(\"class\", \"row-selected\");\r\n\t\t\t\telse\r\n\t\t\t\t\ttag.put(\"class\", \"row\");\r\n\t\t\t}\r\n\t\t});\t\t\r\n\t}","commit_id":"24ade2ee492b95abd5b2cf9349410ff4b9552652","url":"https://github.com/apache/wicket"},{"original_method":"protected void addHeader() \r\n\t{\r\n\t\tint i = 0;\r\n\t\t\r\n\t\tSideColumnsView sideColumns = new SideColumnsView(this, \"sideColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT ||\r\n\t\t\t\tcolumn.getLocation().getAlignment() == Alignment.RIGHT)\r\n\t\t\t{\r\n\t\t\t\tComponent component = column.createHeader(sideColumns, \"\" + i++);\r\n\t\t\t\tsideColumns.addColumn(column, component);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ti = 0;\r\n\t\t\r\n\t\tMiddleColumnsView middleColumns = new MiddleColumnsView(this, \"middleColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.MIDDLE)\r\n\t\t\t{\r\n\t\t\t\tComponent component = column.createHeader(middleColumns, \"\" + i++);\r\n\t\t\t\tmiddleColumns.addColumn(column, component);\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","id":22844,"modified_method":"protected void addHeader() \r\n\t{\r\n\t\tint i = 0;\r\n\t\t\r\n\t\tSideColumnsView sideColumns = new SideColumnsView(this, \"sideColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.LEFT ||\r\n\t\t\t\tcolumn.getLocation().getAlignment() == Alignment.RIGHT)\r\n\t\t\t{\r\n\t\t\t\tComponent component = column.createHeader(sideColumns, \"\" + i++);\r\n\t\t\t\tsideColumns.addColumn(column, component, null);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ti = 0;\r\n\t\t\r\n\t\tMiddleColumnsView middleColumns = new MiddleColumnsView(this, \"middleColumns\");\r\n\t\tfor (Column column: columns)\r\n\t\t{\r\n\t\t\tif (column.getLocation().getAlignment() == Alignment.MIDDLE)\r\n\t\t\t{\r\n\t\t\t\tComponent component = column.createHeader(middleColumns, \"\" + i++);\r\n\t\t\t\tmiddleColumns.addColumn(column, component, null);\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}","commit_id":"24ade2ee492b95abd5b2cf9349410ff4b9552652","url":"https://github.com/apache/wicket"},{"original_method":"private HSSFWorkbook getAsWorkbook(List<List<Object>> spreadsheetData) {\n\t\tHSSFWorkbook wb = new HSSFWorkbook();\n\t\tHSSFSheet sheet = wb.createSheet();\n\t\tIterator<List<Object>> dataIter = spreadsheetData.iterator();\n\t\t\n\t\t// By convention, the first list in the list contains column headers.\n\t\tHSSFRow headerRow = sheet.createRow((short)0);\n\t\tList<Object> headerList = dataIter.next();\n\t\tfor (short i = 0; i < headerList.size(); i++) {\n\t\t\tcreateCell(headerRow, i).setCellValue((String)headerList.get(i));\n\t\t}\n\t\t\n\t\tshort rowPos = 1;\n\t\twhile (dataIter.hasNext()) {\n\t\t\tList<Object> rowData = dataIter.next();\n\t\t\tHSSFRow row = sheet.createRow(rowPos++);\n\t\t\tfor (short i = 0; i < rowData.size(); i++) {\n\t\t\t\tHSSFCell cell = createCell(row, i);\n\t\t\t\tObject data = rowData.get(i);\n\t\t\t\tif (data != null) {\n\t\t\t\t\tif (data instanceof Double) {\n\t\t\t\t\t\tcell.setCellValue(((Double)data).doubleValue());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcell.setCellValue(data.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn wb;\n\t}","id":22845,"modified_method":"private HSSFWorkbook getAsWorkbook(List<List<Object>> spreadsheetData) {\n\t\tHSSFWorkbook wb = new HSSFWorkbook();\n\t\tHSSFSheet sheet = wb.createSheet();\n\t\tHSSFCellStyle headerCs = wb.createCellStyle();\n\t\tIterator<List<Object>> dataIter = spreadsheetData.iterator();\n\t\t\n\t\t// Set the header style\n\t\theaderCs.setBorderBottom(HSSFCellStyle.BORDER_THIN);\n\t\theaderCs.setFillBackgroundColor(HSSFColor.BLUE_GREY.index);\n\n\t\t// By convention, the first list in the list contains column headers.\n\t\tHSSFRow headerRow = sheet.createRow((short)0);\n\t\tList<Object> headerList = dataIter.next();\n\t\tfor (short i = 0; i < headerList.size(); i++) {\n\t\t\tHSSFCell headerCell = createCell(headerRow, i);\n\t\t\theaderCell.setCellValue((String)headerList.get(i));\n\t\t\theaderCell.setCellStyle(headerCs);\n\t\t\tsheet.autoSizeColumn(i);\n\t\t}\n\t\t\n\t\tshort rowPos = 1;\n\t\twhile (dataIter.hasNext()) {\n\t\t\tList<Object> rowData = dataIter.next();\n\t\t\tHSSFRow row = sheet.createRow(rowPos++);\n\t\t\tfor (short i = 0; i < rowData.size(); i++) {\n\t\t\t\tHSSFCell cell = createCell(row, i);\n\t\t\t\tObject data = rowData.get(i);\n\t\t\t\tif (data != null) {\n\t\t\t\t\tif (data instanceof Double) {\n\t\t\t\t\t\tcell.setCellValue(((Double)data).doubleValue());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcell.setCellValue(data.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn wb;\n\t}","commit_id":"fc20116a6d81a5b8cfb2afe265c1b681b4d85b98","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classifier = CreateMethodDeclarationUtil.getClassifier(node);\n    boolean isSameClassifier = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false) == classifier;\n    final String name = CreateMethodDeclarationUtil.getMethodName(editorContext);\n    SNode type;\n    SNode inferType = TypeChecker.getInstance().getInferredTypeOf(node);\n    if (SNodeOperations.isInstanceOf(inferType, \"jetbrains.mps.baseLanguage.structure.Type\")) {\n      type = SNodeOperations.cast(inferType, \"jetbrains.mps.baseLanguage.structure.Type\");\n    } else {\n      type = new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a0a0a0f0h().createNode();\n    }\n    SNode method = new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a0a6a7().createNode(type, name);\n    if (!(isSameClassifier)) {\n      SLinkOperations.setTarget(method, \"visibility\", new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a2a0a7a7().createNode(), true);\n    }\n    ListSequence.fromList(SLinkOperations.getTargets(classifier, \"method\", true)).addElement(method);\n    SNodeOperations.replaceWithAnother(node, new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a1a9a7().createNode(method));\n    if (isSameClassifier) {\n      editorContext.selectWRTFocusPolicy(method);\n    } else {\n      IOperationContext operationContext = editorContext.getOperationContext();\n      Editor editor = new MPSEditorOpener(ProjectHelper.toIdeaProject(operationContext.getProject())).editNode(classifier, operationContext);\n      editor.getEditorContext().selectWRTFocusPolicy(method);\n    }\n  }","id":22846,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode classifier = CreateMethodDeclarationUtil.getClassifier(node);\n    boolean isSameClassifier = SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false) == classifier;\n    final String name = CreateMethodDeclarationUtil.getMethodName(editorContext);\n    SNode type;\n    SNode inferType = TypeChecker.getInstance().getInferredTypeOf(node);\n    if (SNodeOperations.isInstanceOf(inferType, \"jetbrains.mps.baseLanguage.structure.Type\")) {\n      type = SNodeOperations.cast(inferType, \"jetbrains.mps.baseLanguage.structure.Type\");\n    } else {\n      type = new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a0a0a0f0h().createNode();\n    }\n    SNode method = new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a0a6a7().createNode(type, name);\n    if (!(isSameClassifier)) {\n      SLinkOperations.setTarget(method, \"visibility\", new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a2a0a7a7().createNode(), true);\n    }\n    ListSequence.fromList(SLinkOperations.getTargets(classifier, \"method\", true)).addElement(method);\n    SNodeOperations.replaceWithAnother(node, new CreateMethodDeclaration_Intention.QuotationClass_qv3pxx_a1a9a7().createNode(method));\n    if (isSameClassifier) {\n      editorContext.selectWRTFocusPolicy(method);\n    } else {\n      IOperationContext operationContext = editorContext.getOperationContext();\n      Editor editor = NavigationSupport.getInstance().openNode(operationContext, classifier, true, false);\n      editor.getEditorContext().selectWRTFocusPolicy(method);\n    }\n  }","commit_id":"ee2008fe600cdee6dd146af3a221d2d54565a0f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Opens node in the editor. Requires: model read, EDT.\n   *\n   * @param node    alive node from model repository\n   * @param context context\n   * @param focus   move focus if needed - to editor or to inspector\n   * @param select  select node (or its parent) in editor and inspector (if exist)\n   */\n  public abstract void openNode(@NotNull IOperationContext context, @NotNull SNode node, boolean focus, boolean select);","id":22847,"modified_method":"/**\n   * Opens node in the editor. Requires: model read, EDT.\n   *\n   * @param node    alive node from model repository\n   * @param context context\n   * @param focus   move focus if needed - to editor or to inspector\n   * @param select  select node (or its parent) in editor and inspector (if exist)\n   */\n  public abstract Editor openNode(@NotNull IOperationContext context, @NotNull SNode node, boolean focus, boolean select);","commit_id":"ee2008fe600cdee6dd146af3a221d2d54565a0f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void openNode(@NotNull IOperationContext context, @NotNull SNode node, boolean focus, boolean select) {\n    new MPSEditorOpener(ProjectHelper.toIdeaProject(context.getProject())).openNode(node, context, focus, select);\n  }","id":22848,"modified_method":"@Override\n  public Editor openNode(@NotNull IOperationContext context, @NotNull SNode node, boolean focus, boolean select) {\n    return new MPSEditorOpener(ProjectHelper.toIdeaProject(context.getProject())).openNode(node, context, focus, select);\n  }","commit_id":"ee2008fe600cdee6dd146af3a221d2d54565a0f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(ActionContext context) {\n    SNode node = context.get(SNode.class);\n    if (!(node instanceof ConceptDeclaration)) return;\n\n    final IdeMain ide = context.get(IdeMain.class);\n    final IOperationContext operationContext = context.get(IOperationContext.class);\n\n    final String editorName = node.getName() + \"_Editor\";\n    SModel languageStructure = node.getModel();\n    final Language language = SModelUtil.getDeclaringLanguage((ConceptDeclaration) node, operationContext);\n    if (language == null) {\n      JOptionPane.showMessageDialog(null, \"Couldn't find Language for structure model \" + languageStructure.getUID());\n      return;\n    }\n    final SModel languageEditor = language.getEditorModel();\n    if (languageEditor != null) {\n      Iterator<SNode> iterator = languageEditor.roots();\n      while (iterator.hasNext()) {\n        SNode root = iterator.next();\n        if (editorName.equals(root.getName())) {\n          AbstractEditorComponent editor = ide.getEditorsPane().openEditor(root, operationContext);\n          editor.selectNode(root);\n          return;\n        }\n      }\n\n      int option = JOptionPane.showConfirmDialog(\n              null, \"The \" + editorName + \" wasn't found in \" + languageEditor.getUID() + \"\\nDo you want to create such an editor?\",\n              \"Editor not found\",\n              JOptionPane.YES_NO_OPTION,\n              JOptionPane.QUESTION_MESSAGE);\n\n      if (option == JOptionPane.YES_OPTION) {\n        final ConceptEditorDeclaration[] editorDeclaration = new ConceptEditorDeclaration[1];\n        final ConceptDeclaration conceptDeclaration = (ConceptDeclaration) node;\n        CommandProcessor.instance().executeCommand(new Runnable() {\n          public void run() {\n            editorDeclaration[0] = new ConceptEditorDeclaration(languageEditor);\n            editorDeclaration[0].setConceptDeclaration(conceptDeclaration);\n            editorDeclaration[0].getModel().addRoot(editorDeclaration[0]);\n          }\n        });\n\n        ide.getProjectPane().selectNode(editorDeclaration[0]);\n        ide.getProjectPane().openEditor(operationContext);\n        JOptionPane.showMessageDialog(null, \"Editor \" + editorName + \" created\");\n      }\n\n    } else {\n      //\n\n      String path;\n      try {\n        MPSFileModelDescriptor fileModelDescriptor = (MPSFileModelDescriptor) language.getStructureModelDescriptor();\n        final File languageDir = (new File(fileModelDescriptor.getFileName())).getParentFile();\n        path = languageDir.getAbsolutePath();\n      }\n      catch (Exception e) {\n        JOptionPane.showMessageDialog(\n                null,\n                \"Editor model for \\\"\" + node.getModel().getUID() + \"\\\" is not in the project\"\n        );\n        return;\n      }\n      int option = JOptionPane.showConfirmDialog(\n              null,\n              \"Editor model for \\\"\" + node.getModel().getUID() + \"\\\" is not in the project\" + \"\\nDo you want to create it? \\n(file \" + path + \"\\\\editor.mps )\",\n              \"Editor model not found\",\n              JOptionPane.YES_NO_OPTION,\n              JOptionPane.QUESTION_MESSAGE\n      );\n\n      if (option == JOptionPane.YES_OPTION) {\n        final BootstrapLanguages bootstrapLanguages = ApplicationComponents.getInstance().getComponent(BootstrapLanguages.class);\n        SModelDescriptor editor = operationContext.createModel(new SModelUID(language.getNamespace(), \"editor\", \"\"), path, language.getNamespace());\n        editor.getSModel().addImportedModel(language.getStructureModelDescriptor().getModelUID());\n        editor.getSModel().addImportedModel(bootstrapLanguages.getCoreLanguage().getStructureModelDescriptor().getModelUID());\n        editor.getSModel().addLanguage(bootstrapLanguages.getEditorLanguage());\n        //editor.getSModel().addLanguage(bootstrapLanguages.getBaseLanguage());\n        editor.save();\n\n        final SModel smodel = new SModel(new SModelUID(\"z\", \"z\", \"\"));\n        AbstractSModelDescriptor abstractModelDescriptor = new DummySModelDescriptor(smodel);\n        operationContext.registerModelDescriptor(abstractModelDescriptor);\n\n        CommandProcessor.instance().executeCommand(new Runnable() {\n          public void run() {\n            LanguageDescriptor descriptor = language.getCopyOfLanguageDescriptor(smodel, operationContext);\n\n            smodel.addLanguage(bootstrapLanguages.getProjectLanguage());\n            Model editorModel = Model.newInstance(smodel);\n            editorModel.setName(language.getNamespace() + \".editor\");\n            Editor editorNode = Editor.newInstance(smodel);\n            editorNode.setStereotype(\"\");\n            editorNode.setEditorModel(editorModel);\n            descriptor.addEditor(editorNode);\n\n            language.setLanguageDescriptor(descriptor, operationContext);\n            language.save();\n          }\n        });\n\n\n        operationContext.unRegisterModelDescriptor(abstractModelDescriptor);\n        ProjectPane projectPane = operationContext.getComponent(ProjectPane.class);\n        projectPane.rebuildTree();\n        JOptionPane.showMessageDialog(null, \"Editor model created\");\n        execute(context);\n      }\n    }\n  }","id":22849,"modified_method":"public void execute(ActionContext context) {\n    SNode node = context.get(SNode.class);\n    if (!(node instanceof ConceptDeclaration)) return;\n\n    final IdeMain ide = context.get(IdeMain.class);\n    final IOperationContext operationContext = context.get(IOperationContext.class);\n    final AbstractEditorComponent currentEditor = ide.getEditorsPane().getCurrentEditor();\n\n    final String editorName = node.getName() + \"_Editor\";\n    SModel languageStructure = node.getModel();\n    final Language language = SModelUtil.getDeclaringLanguage((ConceptDeclaration) node, operationContext);\n    if (language == null) {\n      JOptionPane.showMessageDialog(null, \"Couldn't find Language for structure model \" + languageStructure.getUID());\n      return;\n    }\n    final SModel languageEditor = language.getEditorModel();\n    if (languageEditor != null) {\n      Iterator<SNode> iterator = languageEditor.roots();\n      while (iterator.hasNext()) {\n        SNode root = iterator.next();\n        if (editorName.equals(root.getName())) {\n\n          final SNode finalRoot = root;\n\n          NavigationActionProcessor.executeNavigationAction(new EditorNavigationRunnable() {\n            public AbstractEditorComponent run(AbstractEditorComponent sourceEditor) {\n              AbstractEditorComponent editor = ide.getEditorsPane().openEditor(finalRoot, operationContext);\n              editor.selectNode(finalRoot);\n              return editor;\n            }\n\n            public AbstractEditorComponent getSourceEditor() {\n              return currentEditor;\n            }\n\n            public EditorsPane getEditorsPane() {\n              return ide.getEditorsPane();\n            }\n          });\n\n          return;\n        }\n      }\n\n      int option = JOptionPane.showConfirmDialog(\n              null, \"The \" + editorName + \" wasn't found in \" + languageEditor.getUID() + \"\\nDo you want to create such an editor?\",\n              \"Editor not found\",\n              JOptionPane.YES_NO_OPTION,\n              JOptionPane.QUESTION_MESSAGE);\n\n      if (option == JOptionPane.YES_OPTION) {\n        final ConceptEditorDeclaration[] editorDeclaration = new ConceptEditorDeclaration[1];\n        final ConceptDeclaration conceptDeclaration = (ConceptDeclaration) node;\n        CommandProcessor.instance().executeCommand(new Runnable() {\n          public void run() {\n            editorDeclaration[0] = new ConceptEditorDeclaration(languageEditor);\n            editorDeclaration[0].setConceptDeclaration(conceptDeclaration);\n            editorDeclaration[0].getModel().addRoot(editorDeclaration[0]);\n          }\n        });\n\n        ide.getProjectPane().selectNode(editorDeclaration[0]);\n\n        NavigationActionProcessor.executeNavigationAction(new EditorNavigationRunnable() {\n          public AbstractEditorComponent run(AbstractEditorComponent sourceEditor) {\n            return ide.getProjectPane().openEditor(operationContext);\n          }\n\n          public AbstractEditorComponent getSourceEditor() {\n            return currentEditor;\n          }\n\n          public EditorsPane getEditorsPane() {\n            return ide.getEditorsPane();\n          }\n        });\n\n\n        JOptionPane.showMessageDialog(null, \"Editor \" + editorName + \" created\");\n      }\n\n    } else {\n      //\n\n      String path;\n      try {\n        MPSFileModelDescriptor fileModelDescriptor = (MPSFileModelDescriptor) language.getStructureModelDescriptor();\n        final File languageDir = (new File(fileModelDescriptor.getFileName())).getParentFile();\n        path = languageDir.getAbsolutePath();\n      }\n      catch (Exception e) {\n        JOptionPane.showMessageDialog(\n                null,\n                \"Editor model for \\\"\" + node.getModel().getUID() + \"\\\" is not in the project\"\n        );\n        return;\n      }\n      int option = JOptionPane.showConfirmDialog(\n              null,\n              \"Editor model for \\\"\" + node.getModel().getUID() + \"\\\" is not in the project\" + \"\\nDo you want to create it? \\n(file \" + path + \"\\\\editor.mps )\",\n              \"Editor model not found\",\n              JOptionPane.YES_NO_OPTION,\n              JOptionPane.QUESTION_MESSAGE\n      );\n\n      if (option == JOptionPane.YES_OPTION) {\n        final BootstrapLanguages bootstrapLanguages = ApplicationComponents.getInstance().getComponent(BootstrapLanguages.class);\n        SModelDescriptor editor = operationContext.createModel(new SModelUID(language.getNamespace(), \"editor\", \"\"), path, language.getNamespace());\n        editor.getSModel().addImportedModel(language.getStructureModelDescriptor().getModelUID());\n        editor.getSModel().addImportedModel(bootstrapLanguages.getCoreLanguage().getStructureModelDescriptor().getModelUID());\n        editor.getSModel().addLanguage(bootstrapLanguages.getEditorLanguage());\n        //editor.getSModel().addLanguage(bootstrapLanguages.getBaseLanguage());\n        editor.save();\n\n        final SModel smodel = new SModel(new SModelUID(\"z\", \"z\", \"\"));\n        AbstractSModelDescriptor abstractModelDescriptor = new DummySModelDescriptor(smodel);\n        operationContext.registerModelDescriptor(abstractModelDescriptor);\n\n        CommandProcessor.instance().executeCommand(new Runnable() {\n          public void run() {\n            LanguageDescriptor descriptor = language.getCopyOfLanguageDescriptor(smodel, operationContext);\n\n            smodel.addLanguage(bootstrapLanguages.getProjectLanguage());\n            Model editorModel = Model.newInstance(smodel);\n            editorModel.setName(language.getNamespace() + \".editor\");\n            Editor editorNode = Editor.newInstance(smodel);\n            editorNode.setStereotype(\"\");\n            editorNode.setEditorModel(editorModel);\n            descriptor.addEditor(editorNode);\n\n            language.setLanguageDescriptor(descriptor, operationContext);\n            language.save();\n          }\n        });\n\n\n        operationContext.unRegisterModelDescriptor(abstractModelDescriptor);\n        ProjectPane projectPane = operationContext.getComponent(ProjectPane.class);\n        projectPane.rebuildTree();\n        JOptionPane.showMessageDialog(null, \"Editor model created\");\n        execute(context);\n      }\n    }\n  }","commit_id":"eee3ca081cc7f7d8516a866dc7839c3fee945861","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void openEditor(IOperationContext operationContext) {\n    TreePath selectionPath = myTree.getSelectionPath();\n    if (selectionPath == null) return;\n    if (!(selectionPath.getLastPathComponent() instanceof SNodeTreeNode)) return;\n    SNodeTreeNode selectedTreeNode = (SNodeTreeNode) selectionPath.getLastPathComponent();\n    SNode semanticNode = selectedTreeNode.getSNode();\n    myIDE.openNode(semanticNode, operationContext);\n  }","id":22850,"modified_method":"public AbstractEditorComponent openEditor(IOperationContext operationContext) {\n    TreePath selectionPath = myTree.getSelectionPath();\n    if (selectionPath == null) return null;\n    if (!(selectionPath.getLastPathComponent() instanceof SNodeTreeNode)) return null;\n    SNodeTreeNode selectedTreeNode = (SNodeTreeNode) selectionPath.getLastPathComponent();\n    SNode semanticNode = selectedTreeNode.getSNode();\n    return myIDE.openNode(semanticNode, operationContext);\n  }","commit_id":"eee3ca081cc7f7d8516a866dc7839c3fee945861","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void openNode(@NotNull IOperationContext context, @NotNull SNode node, boolean focus, boolean select) {\n    new MPSEditorOpener(ProjectHelper.toIdeaProject(context.getProject())).openNode(node, context, focus, select);\n  }","id":22851,"modified_method":"@Override\n  public Editor openNode(@NotNull IOperationContext context, @NotNull SNode node, boolean focus, boolean select) {\n    return new MPSEditorOpener(ProjectHelper.toIdeaProject(context.getProject())).openNode(node, context, focus, select);\n  }","commit_id":"438a72f0e9916330ddd585d4f40c488373e4cdb5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void checkImplementedMethodsOfClass(AnnotationHolder holder, GrTypeDefinition typeDefinition) {\n    if (typeDefinition.hasModifierProperty(GrModifier.ABSTRACT)) return;\n    if (typeDefinition.isEnum() || typeDefinition.isAnnotationType()) return;\n    if (typeDefinition instanceof GrTypeParameter) return;\n\n    Collection<CandidateInfo> collection = GroovyOverrideImplementUtil.getMethodsToImplement(typeDefinition);\n    if (collection.isEmpty()) return;\n\n    final PsiElement element = collection.iterator().next().getElement();\n    assert element instanceof PsiNamedElement;\n    String notImplementedMethodName = ((PsiNamedElement)element).getName();\n\n    final TextRange range = getHeaderTextRange(typeDefinition);\n    final Annotation annotation = holder.createErrorAnnotation(range,\n                                                               GroovyBundle.message(\"method.is.not.implemented\", notImplementedMethodName));\n    registerImplementsMethodsFix(typeDefinition, annotation);\n  }","id":22852,"modified_method":"private static void checkImplementedMethodsOfClass(AnnotationHolder holder, GrTypeDefinition typeDefinition) {\n    if (typeDefinition.hasModifierProperty(GrModifier.ABSTRACT)) return;\n    if (typeDefinition.isAnnotationType()) return;\n    if (typeDefinition instanceof GrTypeParameter) return;\n\n    Collection<CandidateInfo> collection = GroovyOverrideImplementUtil.getMethodsToImplement(typeDefinition);\n    if (collection.isEmpty()) return;\n\n    final PsiElement element = collection.iterator().next().getElement();\n    assert element instanceof PsiNamedElement;\n    String notImplementedMethodName = ((PsiNamedElement)element).getName();\n\n    final TextRange range = getHeaderTextRange(typeDefinition);\n    final Annotation annotation = holder.createErrorAnnotation(range,\n                                                               GroovyBundle.message(\"method.is.not.implemented\", notImplementedMethodName));\n    registerImplementsMethodsFix(typeDefinition, annotation);\n  }","commit_id":"1f980405ebb4f6dbff67d07c14f760a11d6f8db7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isInheritor(@NotNull PsiManager manager,\n                                     @NotNull PsiClass candidateClass,\n                                     @NotNull PsiClass baseClass,\n                                     boolean checkDeep,\n                                     @Nullable Set<PsiClass> checkedClasses) {\n    if (candidateClass instanceof PsiAnonymousClass) {\n      final PsiClass baseCandidateClass = ((PsiAnonymousClass)candidateClass).getBaseClassType().resolve();\n      return baseCandidateClass != null && InheritanceUtil.isInheritorOrSelf(baseCandidateClass, baseClass, checkDeep);\n    }\n    if(checkDeep && LOG.isDebugEnabled()){\n      LOG.debug(\"Using uncached version for \" + candidateClass.getQualifiedName() + \" and \" + baseClass);\n    }\n\n    JavaPsiFacade facade = JavaPsiFacade.getInstance(manager.getProject());\n    if (hasObjectQualifiedName(baseClass)) {\n      PsiClass objectClass = facade.findClass(CommonClassNames.JAVA_LANG_OBJECT, candidateClass.getResolveScope());\n      if (manager.areElementsEquivalent(baseClass, objectClass)) {\n        if (manager.areElementsEquivalent(candidateClass, objectClass)) return false;\n        if (checkDeep || candidateClass.isInterface()) return true;\n        return manager.areElementsEquivalent(candidateClass.getSuperClass(), objectClass);\n      }\n    }\n\n    if (!checkDeep) {\n      if (candidateClass instanceof PsiCompiledElement) {\n        String baseQName = baseClass.getQualifiedName();\n        if (baseQName == null) return false;\n\n        GlobalSearchScope scope = candidateClass.getResolveScope();\n\n        if (CommonClassNames.JAVA_LANG_ENUM.equals(baseQName) &&\n            candidateClass.isEnum() &&\n            facade.findClass(baseQName, scope) != null) {\n          return true;\n        }\n        if (CommonClassNames.JAVA_LANG_ANNOTATION_ANNOTATION.equals(baseQName) &&\n            candidateClass.isAnnotationType() &&\n            facade.findClass(baseQName, scope) != null) {\n          return true;\n        }\n\n        boolean isCandidateInterface = candidateClass.isInterface();\n        boolean isBaseInterface = baseClass.isInterface();\n\n        if (isCandidateInterface == isBaseInterface && checkReferenceListWithQualifiedNames(baseQName, candidateClass.getExtendsList(), scope, facade)) return true;\n        return isBaseInterface && !isCandidateInterface && checkReferenceListWithQualifiedNames(baseQName, candidateClass.getImplementsList(), scope, facade);\n      }\n      boolean isCandidateInterface = candidateClass.isInterface();\n      boolean isBaseInterface = baseClass.isInterface();\n      String baseName = baseClass.getName();\n      if (isCandidateInterface == isBaseInterface) {\n        return PsiClassImplUtil.isInExtendsList(candidateClass, baseClass, baseName, manager);\n      }\n      if (!isCandidateInterface) {\n        return PsiClassImplUtil.isInReferenceList(candidateClass.getImplementsList(), baseClass, baseName, manager);\n      }\n\n      return false;\n    }\n\n    return isInheritorWithoutCaching(manager, candidateClass, baseClass, checkedClasses);\n  }","id":22853,"modified_method":"private static boolean isInheritor(@NotNull PsiManager manager,\n                                     @NotNull PsiClass candidateClass,\n                                     @NotNull PsiClass baseClass,\n                                     boolean checkDeep,\n                                     @Nullable Set<PsiClass> checkedClasses) {\n    if (candidateClass instanceof PsiAnonymousClass) {\n      final PsiClass baseCandidateClass = ((PsiAnonymousClass)candidateClass).getBaseClassType().resolve();\n      return baseCandidateClass != null && InheritanceUtil.isInheritorOrSelf(baseCandidateClass, baseClass, checkDeep);\n    }\n    if(checkDeep && LOG.isDebugEnabled()){\n      LOG.debug(\"Using uncached version for \" + candidateClass.getQualifiedName() + \" and \" + baseClass);\n    }\n\n    JavaPsiFacade facade = JavaPsiFacade.getInstance(manager.getProject());\n    if (hasObjectQualifiedName(baseClass)) {\n      PsiClass objectClass = facade.findClass(CommonClassNames.JAVA_LANG_OBJECT, candidateClass.getResolveScope());\n      if (manager.areElementsEquivalent(baseClass, objectClass)) {\n        if (manager.areElementsEquivalent(candidateClass, objectClass)) return false;\n        if (checkDeep || candidateClass.isInterface()) return true;\n        return manager.areElementsEquivalent(candidateClass.getSuperClass(), objectClass);\n      }\n    }\n\n    if (!checkDeep) {\n      if (candidateClass instanceof PsiCompiledElement) {\n        String baseQName = baseClass.getQualifiedName();\n        if (baseQName == null) return false;\n\n        if (CommonClassNames.JAVA_LANG_ENUM.equals(baseQName)) {\n          return candidateClass.isEnum();\n        }\n        if (CommonClassNames.JAVA_LANG_ANNOTATION_ANNOTATION.equals(baseQName)) {\n          return candidateClass.isAnnotationType();\n        }\n\n        boolean isCandidateInterface = candidateClass.isInterface();\n        boolean isBaseInterface = baseClass.isInterface();\n\n        if (isCandidateInterface == isBaseInterface &&\n            checkReferenceListWithQualifiedNamesInClsClass(baseQName, candidateClass.getExtendsList(), facade)) {\n          return true;\n        }\n        return isBaseInterface && !isCandidateInterface &&\n               checkReferenceListWithQualifiedNamesInClsClass(baseQName, candidateClass.getImplementsList(), facade);\n      }\n      boolean isCandidateInterface = candidateClass.isInterface();\n      boolean isBaseInterface = baseClass.isInterface();\n      String baseName = baseClass.getName();\n      if (isCandidateInterface == isBaseInterface) {\n        return PsiClassImplUtil.isInExtendsList(candidateClass, baseClass, baseName, manager);\n      }\n      if (!isCandidateInterface) {\n        return PsiClassImplUtil.isInReferenceList(candidateClass.getImplementsList(), baseClass, baseName, manager);\n      }\n\n      return false;\n    }\n\n    return isInheritorWithoutCaching(manager, candidateClass, baseClass, checkedClasses);\n  }","commit_id":"43877fe6fa4c3524dc559768b36982205764db15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean checkReferenceListWithQualifiedNames(@NotNull final String baseQName,\n                                                              @Nullable final PsiReferenceList extList,\n                                                              @NotNull final GlobalSearchScope scope,\n                                                              @NotNull JavaPsiFacade facade) {\n    if (extList != null) {\n      for (PsiJavaCodeReferenceElement ref : extList.getReferenceElements()) {\n        if (Comparing.equal(PsiNameHelper.getQualifiedClassName(ref.getQualifiedName(), false), baseQName) && facade.findClass(baseQName, scope) != null)\n          return true;\n      }\n    }\n    return false;\n  }","id":22854,"modified_method":"private static boolean checkReferenceListWithQualifiedNamesInClsClass(@NotNull final String baseQName,\n                                                                        @Nullable final PsiReferenceList extList,\n                                                                        @NotNull JavaPsiFacade facade) {\n    if (extList != null) {\n      // in Cls class it's fast\n      PsiJavaCodeReferenceElement[] referenceElements = extList.getReferenceElements();\n      if (referenceElements.length != 0) {\n        GlobalSearchScope scope = extList.getResolveScope();\n        for (PsiJavaCodeReferenceElement ref : referenceElements) {\n          if (Comparing.equal(PsiNameHelper.getQualifiedClassName(ref.getQualifiedName(), false), baseQName) && facade.findClass(baseQName, scope) != null)\n            return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"43877fe6fa4c3524dc559768b36982205764db15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkTypeDefinition(AnnotationHolder holder, GrTypeDefinition typeDefinition) {\n    if (typeDefinition != null &&\n        typeDefinition.isAnnotationType()) {\n      Annotation annotation = holder.createInfoAnnotation(typeDefinition.getNameIdentifierGroovy(), null);\n      annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n    }\n\n    if (GroovyElementTypes.CLASS_BODY.equals(typeDefinition.getNode().getTreeParent().getElementType())) {\n      holder.createErrorAnnotation(typeDefinition.getNameIdentifierGroovy(), \"Inner classes are not supported in Groovy\");\n    }\n\n    //TODO: add quickfix to change implements -> extends or class to interface \n    Annotation annotation = null;\n\n    final GrImplementsClause implementsClause = typeDefinition.getImplementsClause();\n    final GrExtendsClause extendsClause = typeDefinition.getExtendsClause();\n\n    if (implementsClause != null) {\n      annotation = checkForImplementingInterface(holder, implementsClause);\n      if (annotation != null) {\n        annotation.registerFix(new ChangeExtendsImplementsQuickFix(extendsClause, implementsClause));\n      }\n    }\n\n    if (extendsClause != null) {\n      annotation = checkForExtendingClass(holder, extendsClause);\n      if (annotation != null) {\n        annotation.registerFix(new ChangeExtendsImplementsQuickFix(extendsClause, implementsClause));\n      }\n    }\n  }","id":22855,"modified_method":"private void checkTypeDefinition(AnnotationHolder holder, GrTypeDefinition typeDefinition) {\n    if (typeDefinition.isAnnotationType()) {\n      Annotation annotation = holder.createInfoAnnotation(typeDefinition.getNameIdentifierGroovy(), null);\n      annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n    }\n\n    if (GroovyElementTypes.CLASS_BODY.equals(typeDefinition.getNode().getTreeParent().getElementType())) {\n      holder.createErrorAnnotation(typeDefinition.getNameIdentifierGroovy(), \"Inner classes are not supported in Groovy\");\n    }\n\n    //TODO: add quickfix to change implements -> extends or class to interface \n    Annotation annotation;\n\n    final GrImplementsClause implementsClause = typeDefinition.getImplementsClause();\n    final GrExtendsClause extendsClause = typeDefinition.getExtendsClause();\n\n    if (implementsClause != null) {\n      annotation = checkForImplementingInterface(holder, implementsClause);\n      if (annotation != null) {\n        annotation.registerFix(new ChangeExtendsImplementsQuickFix(extendsClause, implementsClause));\n      }\n    }\n\n    if (extendsClause != null) {\n      annotation = checkForExtendingClass(holder, extendsClause);\n      if (annotation != null) {\n        annotation.registerFix(new ChangeExtendsImplementsQuickFix(extendsClause, implementsClause));\n      }\n    }\n  }","commit_id":"2c1fecccc0d6af454cc98e0f60500783e908bc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReturnStatement(GrReturnStatement returnStatement, AnnotationHolder holder) {\n    final GrExpression value = returnStatement.getReturnValue();\n    if (value != null) {\n      final PsiType type = value.getType();\n      if (type != null) {\n        final GrMethod method = PsiTreeUtil.getParentOfType(returnStatement, GrMethod.class);\n        if (method != null) {\n          if (method.isConstructor()) {\n            holder.createErrorAnnotation(value, GroovyBundle.message(\"cannot.return.from.constructor\"));\n          } else {\n            final PsiType returnType = method.getReturnType();\n            if (returnType != null) {\n              if (PsiType.VOID.equals(returnType)) {\n                holder.createErrorAnnotation(value, GroovyBundle.message(\"cannot.return.from.void.method\"));\n              } else {\n                checkAssignability(holder, returnType, type, value);\n              }\n            }\n          }\n        }\n      }\n    }\n  }","id":22856,"modified_method":"private void checkReturnStatement(GrReturnStatement returnStatement, AnnotationHolder holder) {\n    final GrExpression value = returnStatement.getReturnValue();\n    if (value != null) {\n      final PsiType type = value.getType();\n      if (type != null) {\n        final GrMethod method = PsiTreeUtil.getParentOfType(returnStatement, GrMethod.class);\n        if (method != null) {\n          if (method.isConstructor()) {\n            holder.createErrorAnnotation(value, GroovyBundle.message(\"cannot.return.from.constructor\"));\n          } else {\n            final PsiType methodType = method.getReturnType();\n            final PsiType returnType = value.getType();\n            if (methodType != null) {\n              if (PsiType.VOID.equals(methodType)) {\n                holder.createErrorAnnotation(value, GroovyBundle.message(\"cannot.return.from.void.method\"));\n              } else if (returnType != null) {\n                checkAssignability(holder, methodType, returnType, value);\n              }\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"2c1fecccc0d6af454cc98e0f60500783e908bc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n    if (element instanceof GrCodeReferenceElement) {\n      checkReferenceElement(holder, (GrCodeReferenceElement) element);\n    } else if (element instanceof GrReferenceExpression) {\n      checkReferenceExpression(holder, (GrReferenceExpression) element);\n    } else if (element instanceof GrTypeDefinition) {\n      checkTypeDefinition(holder, (GrTypeDefinition) element);\n      checkTypeDefinitionModifiers(holder, (GrTypeDefinition) element);\n      checkDuplicateMethod(((GrTypeDefinition) element).getBody().getMethods(), holder);\n      checkImplementedMethodsOfClass(holder, (GrTypeDefinition) element);\n    } else if (element instanceof GrMethod) {\n      checkMethodDefinitionModifiers(holder, (GrMethod) element);\n      checkInnerMethod(holder, (GrMethod) element);\n      addOverrideGutter(holder, (GrMethod) element);\n    } else if (element instanceof GrVariableDeclaration) {\n      checkVariableDeclaration(holder, (GrVariableDeclaration) element);\n    } else if (element instanceof GrVariable) {\n      if (element instanceof GrMember) highlightMember(holder, ((GrMember) element));\n      checkVariable(holder, (GrVariable) element);\n    } else if (element instanceof GrAssignmentExpression) {\n      checkAssignmentExpression((GrAssignmentExpression) element, holder);\n    } else if (element instanceof GrNamedArgument) {\n      checkCommandArgument((GrNamedArgument) element, holder);\n    } else if (element instanceof GrReturnStatement) {\n      checkReturnStatement((GrReturnStatement) element, holder);\n    } else if (element instanceof GrListOrMap) {\n      checkMap(((GrListOrMap) element).getNamedArguments(), holder);\n    } else if (element instanceof GrNewExpression) {\n      checkNewExpression(holder, (GrNewExpression) element);\n    } else if (element instanceof GrConstructorInvocation) {\n      checkConstructorInvocation(holder, (GrConstructorInvocation) element);\n    } else if (element instanceof GroovyFile) {\n      final GroovyFile file = (GroovyFile) element;\n      if (file.isScript()) {\n        checkScriptDuplicateMethod(file.getTopLevelDefinitions(), holder);\n      }\n      if (DomainClassUtils.isDomainClass(element.getContainingFile().getVirtualFile())) {\n        checkDomainClass((GroovyFile) element, holder);\n      }\n    } else {\n      final ASTNode node = element.getNode();\n      if (node != null && !(element instanceof PsiWhiteSpace) && !GroovyTokenTypes.COMMENT_SET.contains(node.getElementType()) &&\n          element.getContainingFile() instanceof GroovyFile) {\n        GroovyImportsTracker.getInstance(element.getProject()).markFileAnnotated((GroovyFile) element.getContainingFile());\n      }\n    }\n  }","id":22857,"modified_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n    if (element instanceof GrCodeReferenceElement) {\n      checkReferenceElement(holder, (GrCodeReferenceElement) element);\n    } else if (element instanceof GrReferenceExpression) {\n      checkReferenceExpression(holder, (GrReferenceExpression) element);\n    } else if (element instanceof GrTypeDefinition) {\n      checkTypeDefinition(holder, (GrTypeDefinition) element);\n      checkTypeDefinitionModifiers(holder, (GrTypeDefinition) element);\n      checkDuplicateMethod(((GrTypeDefinition) element).getBody().getMethods(), holder);\n      checkImplementedMethodsOfClass(holder, (GrTypeDefinition) element);\n    } else if (element instanceof GrMethod) {\n      final GrMethod method = (GrMethod) element;\n      checkMethodDefinitionModifiers(holder, method);\n      checkInnerMethod(holder, method);\n      checkMethodReturnExpression(holder, method);\n      addOverrideGutter(holder, method);\n    } else if (element instanceof GrVariableDeclaration) {\n      checkVariableDeclaration(holder, (GrVariableDeclaration) element);\n    } else if (element instanceof GrVariable) {\n      if (element instanceof GrMember) highlightMember(holder, ((GrMember) element));\n      checkVariable(holder, (GrVariable) element);\n    } else if (element instanceof GrAssignmentExpression) {\n      checkAssignmentExpression((GrAssignmentExpression) element, holder);\n    } else if (element instanceof GrNamedArgument) {\n      checkCommandArgument((GrNamedArgument) element, holder);\n    } else if (element instanceof GrReturnStatement) {\n      checkReturnStatement((GrReturnStatement) element, holder);\n    } else if (element instanceof GrListOrMap) {\n      checkMap(((GrListOrMap) element).getNamedArguments(), holder);\n    } else if (element instanceof GrNewExpression) {\n      checkNewExpression(holder, (GrNewExpression) element);\n    } else if (element instanceof GrConstructorInvocation) {\n      checkConstructorInvocation(holder, (GrConstructorInvocation) element);\n    } else if (element instanceof GroovyFile) {\n      final GroovyFile file = (GroovyFile) element;\n      if (file.isScript()) {\n        checkScriptDuplicateMethod(file.getTopLevelDefinitions(), holder);\n      }\n      if (DomainClassUtils.isDomainClass(element.getContainingFile().getVirtualFile())) {\n        checkDomainClass((GroovyFile) element, holder);\n      }\n    } else {\n      final ASTNode node = element.getNode();\n      if (node != null && !(element instanceof PsiWhiteSpace) && !GroovyTokenTypes.COMMENT_SET.contains(node.getElementType()) &&\n          element.getContainingFile() instanceof GroovyFile) {\n        GroovyImportsTracker.getInstance(element.getProject()).markFileAnnotated((GroovyFile) element.getContainingFile());\n      }\n    }\n  }","commit_id":"2c1fecccc0d6af454cc98e0f60500783e908bc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates Groovy PSI element by given AST node\n   *\n   * @param node Given node\n   * @return Respective PSI element\n   */\n  public static PsiElement createElement(ASTNode node) {\n    IElementType elem = node.getElementType();\n\n    //Identifiers & literal\n    if (elem.equals(LITERAL)) return new GrLiteralImpl(node);\n    if (elem.equals(LABEL)) return new GrLabelImpl(node);\n\n    //Lists, mapetc...\n    if (elem.equals(LIST_OR_MAP)) return new GrListOrMapImpl(node);\n\n    if (elem.equals(MODIFIERS)) return new GrModifierListImpl(node);\n    if (elem.equals(ANNOTATION)) return new GrAnnotationImpl(node);\n    if (elem.equals(ANNOTATION_ARGUMENTS)) return new GrAnnotationArgumentListImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIR)) return new GrAnnotationNameValuePairImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIRS)) return new GrAnnotationNameValuePairsImpl(node);\n\n    if (elem.equals(DEFAULT_ANNOTATION_VALUE)) return new GrDefaultAnnotationValueImpl(node);\n\n    //throws\n    if (elem.equals(THROW_CLAUSE)) return new GrThrowsClauseImpl(node);\n\n    // Imports\n    if (elem.equals(IMPORT_STATEMENT)) return new GrImportStatementImpl(node);\n\n    // Packaging\n    if (elem.equals(PACKAGE_DEFINITION)) return new GrPackageDefinitionImpl(node);\n\n    //statements\n    if (elem.equals(LABELED_STATEMENT)) return new GrLabeledStatementImpl(node);\n    if (elem.equals(IF_STATEMENT)) return new GrIfStatementImpl(node);\n    if (elem.equals(FOR_STATEMENT)) return new GrForStatementImpl(node);\n    if (elem.equals(FOR_IN_CLAUSE)) return new GrForInClauseImpl(node);\n    if (elem.equals(FOR_TRADITIONAL_CLAUSE)) return new GrTraditionalForClauseImpl(node);\n    if (elem.equals(WHILE_STATEMENT)) return new GrWhileStatementImpl(node);\n    if (elem.equals(WITH_STATEMENT)) return new GrWithStatementImpl(node);\n    if (elem.equals(TRY_BLOCK_STATEMENT)) return new GrTryCatchStatementImpl(node);\n    if (elem.equals(CATCH_CLAUSE)) return new GrCatchClauseImpl(node);\n    if (elem.equals(FINALLY_CLAUSE)) return new GrFinallyClauseImpl(node);\n    if (elem.equals(SYNCHRONIZED_STATEMENT)) return new GrSynchronizedStatementImpl(node);\n    if (elem.equals(SWITCH_STATEMENT)) return new GrSwitchStatementImpl(node);\n    if (elem.equals(CASE_LABEL)) return new GrCaseLabelImpl(node);\n    if (elem.equals(CASE_SECTION)) return new GrCaseSectionImpl(node);\n    if (elem.equals(VARIABLE_DEFINITION) || elem.equals(VARIABLE_DEFINITION_ERROR))\n      return new GrVariableDeclarationImpl(node);\n    if (elem.equals(VARIABLE)) return new GrVariableImpl(node);\n\n    if (elem.equals(FIELD)) return new GrFieldImpl(node);\n\n    //type definitions\n    if (elem.equals(CLASS_DEFINITION) || elem.equals(CLASS_DEFINITION_ERROR)) return new GrClassDefinitionImpl(node);\n    if (elem.equals(INTERFACE_DEFINITION) || elem.equals(INTERFACE_DEFINITION_ERROR))\n      return new GrInterfaceDefinitionImpl(node);\n    if (elem.equals(ENUM_DEFINITION) || elem.equals(ENUM_DEFINITION_ERROR)) return new GrEnumTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_DEFINITION) || elem.equals(ANNOTATION_DEFINITION_ERROR))\n      return new GrAnnotationTypeDefinitionImpl(node);\n    if (elem.equals(DEFAULT_ANNOTATION_MEMBER)) return new GrDefaultAnnotationMemberImpl(node);\n\n    if (elem.equals(REFERENCE_ELEMENT)) return new GrCodeReferenceElementImpl(node);\n    if (elem.equals(CLASS_TYPE_ELEMENT)) return new GrClassTypeElementImpl(node);\n\n    //clauses\n    if (elem.equals(IMPLEMENTS_CLAUSE)) return new GrImplementsClauseImpl(node);\n    if (elem.equals(EXTENDS_CLAUSE)) return new GrExtendsClauseImpl(node);\n\n    //bodies\n    if (elem.equals(CLASS_BODY)) return new GrTypeDefinitionBodyImpl(node);\n    if (elem.equals(CLOSABLE_BLOCK)) return new GrClosableBlockImpl(node);\n    if (elem.equals(OPEN_BLOCK)) return new GrOpenBlockImpl(node);\n    if (elem.equals(BLOCK_STATEMENT)) return new GrBlockStatementImpl(node);\n    if (elem.equals(EXPLICIT_CONSTRUCTOR)) return new GrConstructorInvocationImpl(node);\n\n    //enum\n    if (elem.equals(ENUM_CONSTANTS)) return new GrEnumConstantListImpl(node);\n    if (elem.equals(ENUM_CONSTANT)) return new GrEnumConstantImpl(node);\n\n    //members\n    if (elem.equals(CONSTRUCTOR_DEFINITION)) return new GrConstructorDefinitionImpl(node);\n    if (elem.equals(METHOD_DEFINITION)) return new GrMethodDefinitionImpl(node);\n\n    //parameters\n    if (elem.equals(PARAMETERS_LIST)) return new GrParameterListImpl(node);\n    if (elem.equals(PARAMETER)) return new GrParameterImpl(node);\n\n    //type parameters\n    if (elem.equals(TYPE_ARGUMENT)) return new GrWildcardTypeArgumentImpl(node);\n    if (elem.equals(TYPE_ARGUMENTS)) return new GrTypeArgumentListImpl(node);\n\n\n    if (elem.equals(TYPE_PARAMETER_LIST)) return new GrTypeParameterListImpl(node);\n    if (elem.equals(TYPE_PARAMETER)) return new GrTypeParameterImpl(node);\n    if (elem.equals(TYPE_EXTENDS_BOUND_LIST)) return new GrTypeExtendsBoundsImpl(node);\n\n    //Branch statements\n    if (elem.equals(RETURN_STATEMENT)) return new GrReturnStmtImpl(node);\n    if (elem.equals(THROW_STATEMENT)) return new GrThrowStatementImpl(node);\n    if (elem.equals(ASSERT_STATEMENT)) return new GrAssertStatementImpl(node);\n    if (elem.equals(BREAK_STATEMENT)) return new GrBreakStatementImpl(node);\n    if (elem.equals(CONTINUE_STATEMENT)) return new GrContinueStatementImpl(node);\n\n    //expressions\n    if (elem.equals(CALL_EXPRESSION)) return new GrApplicationStatementImpl(node);\n    if (elem.equals(COMMAND_ARGUMENTS)) return new GrCommandArgumentListImpl(node);\n    if (elem.equals(COMMAND_ARGUMENT)) return new GrCommandArgumentImpl(node);\n    if (elem.equals(CONDITIONAL_EXPRESSION)) return new GrConditionalExprImpl(node);\n    if (elem.equals(ELVIS_EXPRESSION)) return new GrElvisExprImpl(node);\n    if (elem.equals(ASSIGNMENT_EXPRESSION)) return new GrAssignmentExpressionImpl(node);\n    if (elem.equals(LOGICAL_OR_EXPRESSION)) return new GrLogicalOrExprImpl(node);\n    if (elem.equals(LOGICAL_AND_EXPRESSION)) return new GrLogicalAndExprImpl(node);\n    if (elem.equals(EXCLUSIVE_OR_EXPRESSION)) return new GrExclusiveOrExpressionImpl(node);\n    if (elem.equals(INCLUSIVE_OR_EXPRESSION)) return new GrInclusiveOrExpressionImpl(node);\n    if (elem.equals(AND_EXPRESSION)) return new GrAndExpressionImpl(node);\n    if (elem.equals(REGEX_EXPRESSION)) return new GrRegexExprImpl(node);\n    if (elem.equals(EQUALITY_EXPRESSION)) return new GrEqualityExprImpl(node);\n    if (elem.equals(RELATIONAL_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(SHIFT_EXPRESSION)) return new GrShiftExprImpl(node);\n    if (elem.equals(RANGE_EXPRESSION)) return new GrRangeExprImpl(node);\n    if (elem.equals(COMPOSITE_SHIFT_SIGN)) return new GrOperationSignImpl(node);\n    if (elem.equals(ADDITIVE_EXPRESSION)) return new GrAdditiveExprImpl(node);\n    if (elem.equals(MULTIPLICATIVE_EXPRESSION)) return new GrMultiplicativeExprImpl(node);\n    if (elem.equals(POWER_EXPRESSION)) return new GrPowerExprImpl(node);\n    if (elem.equals(POWER_EXPRESSION_SIMPLE)) return new GrPowerExprImpl(node);\n    if (elem.equals(UNARY_EXPRESSION)) return new GrUnaryExpressionImpl(node);\n    if (elem.equals(POSTFIX_EXPRESSION)) return new GrPostfixExprImpl(node);\n    if (elem.equals(CAST_EXPRESSION)) return new GrTypeCastExpressionImpl(node);\n    if (elem.equals(SAFE_CAST_EXPRESSION)) return new GrSafeCastExpressionImpl(node);\n    if (elem.equals(INSTANCEOF_EXPRESSION)) return new GrInstanceofExpressionImpl(node);\n    if (elem.equals(ARRAY_TYPE)) return new GrArrayTypeElementImpl(node);\n    if (elem.equals(BUILT_IN_TYPE)) return new GrBuiltInTypeElementImpl(node);\n    if (elem.equals(GSTRING)) return new GrStringImpl(node);\n    if (elem.equals(REGEX)) return new GrRegexImpl(node);\n    if (elem.equals(REFERENCE_EXPRESSION)) return new GrReferenceExpressionImpl(node);\n    if (elem.equals(THIS_REFERENCE_EXPRESSION)) return new GrThisReferenceExpressionImpl(node);\n    if (elem.equals(SUPER_REFERENCE_EXPRESSION)) return new GrSuperReferenceExpressionImpl(node);\n    if (elem.equals(PARENTHESIZED_EXPRESSION)) return new GrParenthesizedExprImpl(node);\n    if (elem.equals(NEW_EXPRESSION)) return new GrNewExpressionImpl(node);\n    if (elem.equals(ARRAY_DECLARATOR)) return new GrArrayDeclarationImpl(node);\n\n    //Paths\n    if (elem.equals(PATH_PROPERTY)) return new GrPropertySelectorImpl(node);\n    if (elem.equals(PATH_PROPERTY_REFERENCE)) return new GrPropertySelectionImpl(node);\n    if (elem.equals(PATH_METHOD_CALL)) return new GrMethodCallExpressionImpl(node);\n    if (elem.equals(PATH_INDEX_PROPERTY)) return new GrIndexPropertyImpl(node);\n\n    // Arguments\n    if (elem.equals(ARGUMENTS)) return new GrArgumentListImpl(node);\n    if (elem.equals(ARGUMENT)) return new GrNamedArgumentImpl(node);\n    if (elem.equals(ARGUMENT_LABEL)) return new GrArgumentLabelImpl(node);\n\n    if (elem.equals(BALANCED_BRACKETS)) return new GrBalancedBracketsImpl(node);\n\n    // GSP-specific Element types\n    if (GROOVY_EXPR_CODE.equals(elem)) return new GrGspExprInjectionImpl();\n    if (GROOVY_DECLARATION.equals(elem)) return new GrGspDeclarationHolderImpl();\n\n    if (GSP_CLASS.equals(elem)) return new GrGspClassImpl(node);\n    if (GSP_RUN_METHOD.equals(elem)) return new GrGspRunMethodImpl(node);\n    if (GSP_RUN_BLOCK.equals(elem)) return new GrGspRunBlockImpl(node);\n\n\n    return new ASTWrapperPsiElement(node);\n  }","id":22858,"modified_method":"/**\n   * Creates Groovy PSI element by given AST node\n   *\n   * @param node Given node\n   * @return Respective PSI element\n   */\n  public static PsiElement createElement(ASTNode node) {\n    IElementType elem = node.getElementType();\n\n    //Identifiers & literal\n    if (elem.equals(LITERAL)) return new GrLiteralImpl(node);\n    if (elem.equals(LABEL)) return new GrLabelImpl(node);\n\n    //Lists, mapetc...\n    if (elem.equals(LIST_OR_MAP)) return new GrListOrMapImpl(node);\n\n    if (elem.equals(MODIFIERS)) return new GrModifierListImpl(node);\n    if (elem.equals(ANNOTATION)) return new GrAnnotationImpl(node);\n    if (elem.equals(ANNOTATION_ARGUMENTS)) return new GrAnnotationArgumentListImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIR)) return new GrAnnotationNameValuePairImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIRS)) return new GrAnnotationNameValuePairsImpl(node);\n\n    if (elem.equals(DEFAULT_ANNOTATION_VALUE)) return new GrDefaultAnnotationValueImpl(node);\n\n    //throws\n    if (elem.equals(THROW_CLAUSE)) return new GrThrowsClauseImpl(node);\n\n    // Imports\n    if (elem.equals(IMPORT_STATEMENT)) return new GrImportStatementImpl(node);\n\n    // Packaging\n    if (elem.equals(PACKAGE_DEFINITION)) return new GrPackageDefinitionImpl(node);\n\n    //statements\n    if (elem.equals(LABELED_STATEMENT)) return new GrLabeledStatementImpl(node);\n    if (elem.equals(IF_STATEMENT)) return new GrIfStatementImpl(node);\n    if (elem.equals(FOR_STATEMENT)) return new GrForStatementImpl(node);\n    if (elem.equals(FOR_IN_CLAUSE)) return new GrForInClauseImpl(node);\n    if (elem.equals(FOR_TRADITIONAL_CLAUSE)) return new GrTraditionalForClauseImpl(node);\n    if (elem.equals(WHILE_STATEMENT)) return new GrWhileStatementImpl(node);\n    if (elem.equals(WITH_STATEMENT)) return new GrWithStatementImpl(node);\n    if (elem.equals(TRY_BLOCK_STATEMENT)) return new GrTryCatchStatementImpl(node);\n    if (elem.equals(CATCH_CLAUSE)) return new GrCatchClauseImpl(node);\n    if (elem.equals(FINALLY_CLAUSE)) return new GrFinallyClauseImpl(node);\n    if (elem.equals(SYNCHRONIZED_STATEMENT)) return new GrSynchronizedStatementImpl(node);\n    if (elem.equals(SWITCH_STATEMENT)) return new GrSwitchStatementImpl(node);\n    if (elem.equals(CASE_LABEL)) return new GrCaseLabelImpl(node);\n    if (elem.equals(CASE_SECTION)) return new GrCaseSectionImpl(node);\n    if (elem.equals(VARIABLE_DEFINITION) || elem.equals(VARIABLE_DEFINITION_ERROR))\n      return new GrVariableDeclarationImpl(node);\n    if (elem.equals(VARIABLE)) return new GrVariableImpl(node);\n\n    if (elem.equals(FIELD)) return new GrFieldImpl(node);\n\n    //type definitions\n    if (elem.equals(CLASS_DEFINITION) || elem.equals(CLASS_DEFINITION_ERROR)) return new GrClassDefinitionImpl(node);\n    if (elem.equals(INTERFACE_DEFINITION) || elem.equals(INTERFACE_DEFINITION_ERROR))\n      return new GrInterfaceDefinitionImpl(node);\n    if (elem.equals(ENUM_DEFINITION) || elem.equals(ENUM_DEFINITION_ERROR)) return new GrEnumTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_DEFINITION) || elem.equals(ANNOTATION_DEFINITION_ERROR))\n      return new GrAnnotationTypeDefinitionImpl(node);\n    if (elem.equals(DEFAULT_ANNOTATION_MEMBER)) return new GrDefaultAnnotationMemberImpl(node);\n\n    if (elem.equals(REFERENCE_ELEMENT)) return new GrCodeReferenceElementImpl(node);\n    if (elem.equals(CLASS_TYPE_ELEMENT)) return new GrClassTypeElementImpl(node);\n\n    //clauses\n    if (elem.equals(IMPLEMENTS_CLAUSE)) return new GrImplementsClauseImpl(node);\n    if (elem.equals(EXTENDS_CLAUSE)) return new GrExtendsClauseImpl(node);\n\n    //bodies\n    if (elem.equals(CLASS_BODY)) return new GrTypeDefinitionBodyImpl(node);\n    if (elem.equals(CLOSABLE_BLOCK)) return new GrClosableBlockImpl(node);\n    if (elem.equals(OPEN_BLOCK)) return new GrOpenBlockImpl(node);\n    if (elem.equals(BLOCK_STATEMENT)) return new GrBlockStatementImpl(node);\n    if (elem.equals(EXPLICIT_CONSTRUCTOR)) return new GrConstructorInvocationImpl(node);\n\n    //enum\n    if (elem.equals(ENUM_CONSTANTS)) return new GrEnumConstantListImpl(node);\n    if (elem.equals(ENUM_CONSTANT)) return new GrEnumConstantImpl(node);\n\n    //members\n    if (elem.equals(CONSTRUCTOR_DEFINITION)) return new GrConstructorDefinitionImpl(node);\n    if (elem.equals(METHOD_DEFINITION)) return new GrMethodDefinitionImpl(node);\n\n    //parameters\n    if (elem.equals(PARAMETERS_LIST)) return new GrParameterListImpl(node);\n    if (elem.equals(PARAMETER)) return new GrParameterImpl(node);\n\n    //type parameters\n    if (elem.equals(TYPE_ARGUMENT)) return new GrWildcardTypeArgumentImpl(node);\n    if (elem.equals(TYPE_ARGUMENTS)) return new GrTypeArgumentListImpl(node);\n\n\n    if (elem.equals(TYPE_PARAMETER_LIST)) return new GrTypeParameterListImpl(node);\n    if (elem.equals(TYPE_PARAMETER)) return new GrTypeParameterImpl(node);\n    if (elem.equals(TYPE_EXTENDS_BOUND_LIST)) return new GrTypeExtendsBoundsImpl(node);\n\n    //Branch statements\n    if (elem.equals(RETURN_STATEMENT)) return new GrReturnStatementImpl(node);\n    if (elem.equals(THROW_STATEMENT)) return new GrThrowStatementImpl(node);\n    if (elem.equals(ASSERT_STATEMENT)) return new GrAssertStatementImpl(node);\n    if (elem.equals(BREAK_STATEMENT)) return new GrBreakStatementImpl(node);\n    if (elem.equals(CONTINUE_STATEMENT)) return new GrContinueStatementImpl(node);\n\n    //expressions\n    if (elem.equals(CALL_EXPRESSION)) return new GrApplicationStatementImpl(node);\n    if (elem.equals(COMMAND_ARGUMENTS)) return new GrCommandArgumentListImpl(node);\n    if (elem.equals(COMMAND_ARGUMENT)) return new GrCommandArgumentImpl(node);\n    if (elem.equals(CONDITIONAL_EXPRESSION)) return new GrConditionalExprImpl(node);\n    if (elem.equals(ELVIS_EXPRESSION)) return new GrElvisExprImpl(node);\n    if (elem.equals(ASSIGNMENT_EXPRESSION)) return new GrAssignmentExpressionImpl(node);\n    if (elem.equals(LOGICAL_OR_EXPRESSION)) return new GrLogicalOrExprImpl(node);\n    if (elem.equals(LOGICAL_AND_EXPRESSION)) return new GrLogicalAndExprImpl(node);\n    if (elem.equals(EXCLUSIVE_OR_EXPRESSION)) return new GrExclusiveOrExpressionImpl(node);\n    if (elem.equals(INCLUSIVE_OR_EXPRESSION)) return new GrInclusiveOrExpressionImpl(node);\n    if (elem.equals(AND_EXPRESSION)) return new GrAndExpressionImpl(node);\n    if (elem.equals(REGEX_EXPRESSION)) return new GrRegexExprImpl(node);\n    if (elem.equals(EQUALITY_EXPRESSION)) return new GrEqualityExprImpl(node);\n    if (elem.equals(RELATIONAL_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(SHIFT_EXPRESSION)) return new GrShiftExprImpl(node);\n    if (elem.equals(RANGE_EXPRESSION)) return new GrRangeExprImpl(node);\n    if (elem.equals(COMPOSITE_SHIFT_SIGN)) return new GrOperationSignImpl(node);\n    if (elem.equals(ADDITIVE_EXPRESSION)) return new GrAdditiveExprImpl(node);\n    if (elem.equals(MULTIPLICATIVE_EXPRESSION)) return new GrMultiplicativeExprImpl(node);\n    if (elem.equals(POWER_EXPRESSION)) return new GrPowerExprImpl(node);\n    if (elem.equals(POWER_EXPRESSION_SIMPLE)) return new GrPowerExprImpl(node);\n    if (elem.equals(UNARY_EXPRESSION)) return new GrUnaryExpressionImpl(node);\n    if (elem.equals(POSTFIX_EXPRESSION)) return new GrPostfixExprImpl(node);\n    if (elem.equals(CAST_EXPRESSION)) return new GrTypeCastExpressionImpl(node);\n    if (elem.equals(SAFE_CAST_EXPRESSION)) return new GrSafeCastExpressionImpl(node);\n    if (elem.equals(INSTANCEOF_EXPRESSION)) return new GrInstanceofExpressionImpl(node);\n    if (elem.equals(ARRAY_TYPE)) return new GrArrayTypeElementImpl(node);\n    if (elem.equals(BUILT_IN_TYPE)) return new GrBuiltInTypeElementImpl(node);\n    if (elem.equals(GSTRING)) return new GrStringImpl(node);\n    if (elem.equals(REGEX)) return new GrRegexImpl(node);\n    if (elem.equals(REFERENCE_EXPRESSION)) return new GrReferenceExpressionImpl(node);\n    if (elem.equals(THIS_REFERENCE_EXPRESSION)) return new GrThisReferenceExpressionImpl(node);\n    if (elem.equals(SUPER_REFERENCE_EXPRESSION)) return new GrSuperReferenceExpressionImpl(node);\n    if (elem.equals(PARENTHESIZED_EXPRESSION)) return new GrParenthesizedExprImpl(node);\n    if (elem.equals(NEW_EXPRESSION)) return new GrNewExpressionImpl(node);\n    if (elem.equals(ARRAY_DECLARATOR)) return new GrArrayDeclarationImpl(node);\n\n    //Paths\n    if (elem.equals(PATH_PROPERTY)) return new GrPropertySelectorImpl(node);\n    if (elem.equals(PATH_PROPERTY_REFERENCE)) return new GrPropertySelectionImpl(node);\n    if (elem.equals(PATH_METHOD_CALL)) return new GrMethodCallExpressionImpl(node);\n    if (elem.equals(PATH_INDEX_PROPERTY)) return new GrIndexPropertyImpl(node);\n\n    // Arguments\n    if (elem.equals(ARGUMENTS)) return new GrArgumentListImpl(node);\n    if (elem.equals(ARGUMENT)) return new GrNamedArgumentImpl(node);\n    if (elem.equals(ARGUMENT_LABEL)) return new GrArgumentLabelImpl(node);\n\n    if (elem.equals(BALANCED_BRACKETS)) return new GrBalancedBracketsImpl(node);\n\n    // GSP-specific Element types\n    if (GROOVY_EXPR_CODE.equals(elem)) return new GrGspExprInjectionImpl();\n    if (GROOVY_DECLARATION.equals(elem)) return new GrGspDeclarationHolderImpl();\n\n    if (GSP_CLASS.equals(elem)) return new GrGspClassImpl(node);\n    if (GSP_RUN_METHOD.equals(elem)) return new GrGspRunMethodImpl(node);\n    if (GSP_RUN_BLOCK.equals(elem)) return new GrGspRunBlockImpl(node);\n\n\n    return new ASTWrapperPsiElement(node);\n  }","commit_id":"2c1fecccc0d6af454cc98e0f60500783e908bc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int translateFlags(GrTypeDefinitionStub classStub) {\n    int flags = 0;\n    if (classStub.isInterface()) {\n      flags |= IndexTree.INTERFACE;\n    }\n    if (classStub.isEnum()) {\n      flags |= IndexTree.ENUM;\n    }\n    if (classStub.isAnnotationType()) {\n      flags |= IndexTree.ANNOTATION;\n    }\n    if (GrStubUtils.isGroovyStaticMemberStub(classStub)) {\n      flags |= IndexTree.STATIC;\n    }\n    return flags;\n  }","id":22859,"modified_method":"private static int translateFlags(GrTypeDefinitionStub classStub) {\n    int flags = 0;\n    flags = BitUtil.set(flags, IndexTree.ENUM, classStub.isEnum());\n    flags = BitUtil.set(flags, IndexTree.ANNOTATION, classStub.isAnnotationType());\n    return flags;\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int hashIdentifier(@Nullable String s) {\n    if (s == null) return 0;\n\n    // not using String.hashCode because this way there's less collisions for short package names like 'com'\n    int hash = 0;\n    for (int i = 0; i < s.length(); i++) {\n      hash = hash * 239 + s.charAt(i);\n    }\n    return hash;\n  }","id":22860,"modified_method":"public static int hashIdentifier(@Nullable String s) {\n    if (StringUtil.isEmpty(s)) return 0;\n\n    // not using String.hashCode because this way there's less collisions for short package names like 'com'\n    int hash = 0;\n    for (int i = 0; i < s.length(); i++) {\n      hash = hash * 239 + s.charAt(i);\n    }\n    return hash == 0 ? 1 : hash;\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int translateFlags(PsiClassStubImpl<?> classStub, int accessModifiers) {\n    int flags = 0;\n    if (classStub.isInterface()) {\n      flags |= IndexTree.INTERFACE;\n    }\n    if (classStub.isEnum()) {\n      flags |= IndexTree.ENUM;\n    }\n    if (classStub.isAnnotationType()) {\n      flags |= IndexTree.ANNOTATION;\n    }\n    if (ModifierFlags.hasModifierProperty(PsiModifier.STATIC, accessModifiers)) {\n      flags |= IndexTree.STATIC;\n    }\n    return flags;\n  }","id":22861,"modified_method":"private static int translateFlags(PsiClassStubImpl<?> classStub, int accessModifiers) {\n    int flags = 0;\n    flags = BitUtil.set(flags, IndexTree.ENUM, classStub.isEnum());\n    flags = BitUtil.set(flags, IndexTree.ANNOTATION, classStub.isAnnotationType());\n    return flags;\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int checkFlags(long flags, Symbol owner, boolean compiled) {\n    int mask = 0;\n    if (owner.isClass() && (owner.myOwner.isPackage() || owner.isStatic())) {\n      if ((flags & (IndexTree.INTERFACE | IndexTree.ENUM | IndexTree.STATIC)) != 0) {\n        mask |= IndexTree.STATIC;\n      }\n    }\n    if ((flags & IndexTree.SUPERS_UNRESOLVED) != 0) {\n      mask |= IndexTree.SUPERS_UNRESOLVED;\n    }\n    if (compiled) {\n      mask |= IndexTree.COMPILED;\n    }\n    return mask;\n  }","id":22862,"modified_method":"private static int checkFlags(long flags, Symbol owner, boolean compiled) {\n    int mask = 0;\n    if ((flags & IndexTree.SUPERS_UNRESOLVED) != 0) {\n      mask |= IndexTree.SUPERS_UNRESOLVED;\n    }\n    if (compiled) {\n      mask |= IndexTree.COMPILED;\n    }\n    return mask;\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getVersion() {\n    return IndexTree.STUB_HIERARCHY_ENABLED ? 6 + Arrays.stream(ourIndexers).mapToInt(StubHierarchyIndexer::getVersion).sum() : 0;\n  }","id":22863,"modified_method":"@Override\n  public int getVersion() {\n    return IndexTree.STUB_HIERARCHY_ENABLED ? 7 + Arrays.stream(ourIndexers).mapToInt(StubHierarchyIndexer::getVersion).sum() : 0;\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processInheritedMembers(Symbol.ClassSymbol s,\n                                       @ShortName int name,\n                                       boolean requireStatic,\n                                       Set<Symbol> symbols,\n                                       @Nullable Set<Symbol> processed) throws IncompleteHierarchyException {\n    processMembers(s.getMembers(), name, symbols, requireStatic);\n\n    @CompactArray(Symbol.ClassSymbol.class) Object supers = s.getSuperClasses(myConnector);\n    if (supers == null) return;\n\n    if (processed == null) processed = new HashSet<>();\n    if (!processed.add(s)) return;\n\n    if (supers instanceof Symbol.ClassSymbol) {\n      processInheritedMembers((Symbol.ClassSymbol)supers, name, requireStatic, symbols, processed);\n    } else if (supers instanceof Symbol.ClassSymbol[]) {\n      for (Symbol.ClassSymbol st : (Symbol.ClassSymbol[])supers) {\n        processInheritedMembers(st, name, requireStatic, symbols, processed);\n      }\n    }\n  }","id":22864,"modified_method":"private void processInheritedMembers(Symbol.ClassSymbol s,\n                                       @ShortName int name,\n                                       Set<Symbol> symbols,\n                                       @Nullable Set<Symbol> processed) throws IncompleteHierarchyException {\n    processMembers(s.getMembers(), name, symbols);\n\n    @CompactArray(Symbol.ClassSymbol.class) Object supers = s.getSuperClasses(myConnector);\n    if (supers == null) return;\n\n    if (processed == null) processed = new HashSet<>();\n    if (!processed.add(s)) return;\n\n    if (supers instanceof Symbol.ClassSymbol) {\n      processInheritedMembers((Symbol.ClassSymbol)supers, name, symbols, processed);\n    } else if (supers instanceof Symbol.ClassSymbol[]) {\n      for (Symbol.ClassSymbol st : (Symbol.ClassSymbol[])supers) {\n        processInheritedMembers(st, name, symbols, processed);\n      }\n    }\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processMembers(Symbol.ClassSymbol[] members, @ShortName int name, Set<Symbol> symbols, boolean requireStatic) {\n    int index = getIndex(name, members);\n    if (index < 0) return;\n\n    // elem\n    Symbol.ClassSymbol member = members[index];\n    if (!requireStatic || member.isStatic()) {\n      symbols.add(member);\n    }\n    // on the left\n    int i = index - 1;\n    while (i >= 0 && members[i].myShortName == name) {\n      member = members[i];\n      if (!requireStatic || member.isStatic()) {\n        symbols.add(member);\n      }\n      i--;\n    }\n    // on the right\n    i = index + 1;\n    while (i < members.length && members[i].myShortName == name) {\n      member = members[i];\n      if (!requireStatic || member.isStatic()) {\n        symbols.add(member);\n      }\n      i++;\n    }\n  }","id":22865,"modified_method":"private static void processMembers(Symbol.ClassSymbol[] members, @ShortName int name, Set<Symbol> symbols) {\n    int index = getIndex(name, members);\n    if (index < 0) return;\n\n    // elem\n    symbols.add(members[index]);\n    // on the left\n    int i = index - 1;\n    while (i >= 0 && members[i].myShortName == name) {\n      symbols.add(members[i]);\n      i--;\n    }\n    // on the right\n    i = index + 1;\n    while (i < members.length && members[i].myShortName == name) {\n      symbols.add(members[i]);\n      i++;\n    }\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findMemberType(Symbol s, @ShortName int name, Set<Symbol> symbols) throws IncompleteHierarchyException {\n    if (s.isClass()) {\n      processInheritedMembers((Symbol.ClassSymbol)s, name, false, symbols, null);\n    } else {\n      processMembers(s.getMembers(), name, symbols, false);\n    }\n  }","id":22866,"modified_method":"private void findMemberType(Symbol s, @ShortName int name, Set<Symbol> symbols) throws IncompleteHierarchyException {\n    if (s.isClass()) {\n      processInheritedMembers((Symbol.ClassSymbol)s, name, symbols, null);\n    } else {\n      processMembers(s.getMembers(), name, symbols);\n    }\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void importNamedStatic(final Symbol.ClassSymbol tsym, @ShortName final int name, final Set<Symbol> symbols) throws IncompleteHierarchyException {\n    processInheritedMembers(tsym, name, true, symbols, null);\n  }","id":22867,"modified_method":"private void importNamedStatic(final Symbol.ClassSymbol tsym, @ShortName final int name, final Set<Symbol> symbols) throws IncompleteHierarchyException {\n    processInheritedMembers(tsym, name, symbols, null);\n  }","commit_id":"88944e57ef2b98e18c53e49ac857b1c45060cb26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Determines whether the cached content for this channel is still valid.\n     * <p>\n     * Return <code>true<\/code> when:<br>\n     * <ol>\n     * <li>We have not just received an event<\/li>\n     * <li>No runtime parameters are sent to the channel<\/li>\n     * <li>The focus hasn't switched.<\/li>\n     * <\/ol>\n     * Otherwise, return <code>false<\/code>.  \n     * <p>\n     * In other words, cache the content in all cases <b>except<\/b> \n     * for when a user clicks a channel button, a link or form button within the channel, \n     * or the <i>focus<\/i> or <i>unfocus<\/i> button.\n     * @param validity the validity object\n     * @param uid the unique identifier\n     * @return <code>true<\/code> if the cache is still valid, otherwise <code>false<\/code>\n     */\n    public boolean isCacheValid(Object validity, String uid) {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelStaticData staticData = channelState.getStaticData();\n        ChannelRuntimeData runtimeData = channelState.getRuntimeData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        ChannelData cd = channelState.getChannelData();\n\n        // Determine if the channel focus has changed\n        boolean previouslyFocused = cd.isFocused();\n        cd.setFocused(runtimeData.isRenderingAsRoot());\n        boolean focusHasSwitched = cd.isFocused() != previouslyFocused;\n    \n        // Dirty cache only when we receive an event, one or more request params, or a change in focus\n        boolean cacheValid = !(cd.hasReceivedEvent() || runtimeData.isTargeted() || focusHasSwitched);\n    \n        cd.setReceivedEvent(false);\n        return cacheValid;\n    }","id":22868,"modified_method":"/**\n     * Determines whether the cached content for this channel is still valid.\n     * <p>\n     * Return <code>true<\/code> when:<br>\n     * <ol>\n     * <li>We have not just received an event<\/li>\n     * <li>No runtime parameters are sent to the channel<\/li>\n     * <li>The focus hasn't switched.<\/li>\n     * <\/ol>\n     * Otherwise, return <code>false<\/code>.  \n     * <p>\n     * In other words, cache the content in all cases <b>except<\/b> \n     * for when a user clicks a channel button, a link or form button within the channel, \n     * or the <i>focus<\/i> or <i>unfocus<\/i> button.\n     * @param validity the validity object\n     * @param uid the unique identifier\n     * @return <code>true<\/code> if the cache is still valid, otherwise <code>false<\/code>\n     */\n    public boolean isCacheValid(Object validity, String uid) {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelStaticData staticData = channelState.getStaticData();\n        ChannelRuntimeData runtimeData = channelState.getRuntimeData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        ChannelData cd = channelState.getChannelData();\n        \n        PortletWindow pw = cd.getPortletWindow();\n        PortletEntity pe = pw.getPortletEntity();\n        PortletDefinition pd = pe.getPortletDefinition();\n        \n        //Expiration based caching support for the portlet.\n        String exprCacheTimeStr = pd.getExpirationCache();\n        Long exprCacheTimeObj = (Long)staticData.get(CACHE_TIMEOUT_KEY);\n        Long lastRenderTimeObj = (Long)staticData.get(LAST_RENDER_TIME_KEY);\n\n        try {\n            if (exprCacheTimeObj == null)\n                exprCacheTimeObj = new Long(exprCacheTimeStr);\n            \n            long exprCacheTime = exprCacheTimeObj.longValue();\n            \n            if (exprCacheTime == 0) {\n                return false;\n            }\n            else if (exprCacheTime > 0 && lastRenderTimeObj != null) {\n                long lastRenderTime = lastRenderTimeObj.longValue();\n                \n                if ((lastRenderTime + (exprCacheTime * 1000)) < System.currentTimeMillis())\n                    return false;\n            }\n        }\n        catch (Exception e) {\n            String portletId = staticData.getParameter(portletDefinitionIdParamName);\n            log.warn(\"Error parsing portlet expiration time (\" + exprCacheTimeStr + \") for portlet (\" + portletId + \").\", e);\n        }\n\n        // Determine if the channel focus has changed\n        boolean previouslyFocused = cd.isFocused();\n        cd.setFocused(runtimeData.isRenderingAsRoot());\n        boolean focusHasSwitched = cd.isFocused() != previouslyFocused;\n    \n        // Dirty cache only when we receive an event, one or more request params, or a change in focus\n        boolean cacheValid = !(cd.hasReceivedEvent() || runtimeData.isTargeted() || focusHasSwitched);\n    \n        cd.setReceivedEvent(false);\n        return cacheValid;\n    }","commit_id":"a21940a6cf95af73375276489b96432092f2f98b","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected void initPortletContainer(String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n\n        try {\n            PortletContainerEnvironmentImpl environment = new PortletContainerEnvironmentImpl();        \n            LogServiceImpl logService = new LogServiceImpl();\n            FactoryManagerServiceImpl factorManagerService = new FactoryManagerServiceImpl();\n            InformationProviderServiceImpl informationProviderService = new InformationProviderServiceImpl();\n            logService.init(servletConfig, null);\n            factorManagerService.init(servletConfig, null);\n            informationProviderService.init(servletConfig, null);\n            environment.addContainerService(logService);\n            environment.addContainerService(factorManagerService);\n            environment.addContainerService(informationProviderService);\n\n            portletContainer = new PortletContainerImpl();\n            portletContainer.init(uniqueContainerName, servletConfig, environment, new Properties());\n            \n            portletContainerInitialized = true;\n        \n        } catch (Exception e) {\n            String message = \"Initialization of the portlet container failed.\";\n            log.error( message, e);\n            throw new PortalException(message, e);\n        }\n    }","id":22869,"modified_method":"protected void initPortletContainer(String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n\n        try {\n            PortletContainerEnvironmentImpl environment = new PortletContainerEnvironmentImpl();        \n            LogServiceImpl logService = new LogServiceImpl();\n            FactoryManagerServiceImpl factorManagerService = new FactoryManagerServiceImpl();\n            InformationProviderServiceImpl informationProviderService = new InformationProviderServiceImpl();\n            PropertyManagerService propertyManagerService = new PropertyManagerServiceImpl();\n            \n            logService.init(servletConfig, null);\n            factorManagerService.init(servletConfig, null);\n            informationProviderService.init(servletConfig, null);\n            \n            environment.addContainerService(logService);\n            environment.addContainerService(factorManagerService);\n            environment.addContainerService(informationProviderService);\n            environment.addContainerService(propertyManagerService);\n\n            portletContainer = new PortletContainerImpl();\n            portletContainer.init(uniqueContainerName, servletConfig, environment, new Properties());\n            \n            portletContainerInitialized = true;\n        \n        } catch (Exception e) {\n            String message = \"Initialization of the portlet container failed.\";\n            log.error( message, e);\n            throw new PortalException(message, e);\n        }\n    }","commit_id":"a21940a6cf95af73375276489b96432092f2f98b","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * This is where we do the real work of getting the markup.\n     * This is called from both renderXML() and renderCharacters().\n     * @param uid a unique ID used to identify the state of the channel\n     */\n    protected synchronized String getMarkup(String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelRuntimeData rd = channelState.getRuntimeData();\n        ChannelStaticData sd = channelState.getStaticData();\n        ChannelData cd = channelState.getChannelData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        \n        String markup = \"<b>Problem rendering portlet \" + sd.getParameter(\"portletDefinitionId\") + \"<\/b>\";\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            HttpServletRequest wrappedRequest = ((PortletWindowImpl)cd.getPortletWindow()).getHttpServletRequest();\n            HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n            transferActionResultsToRequest(channelState, wrappedRequest);\n            \n                                                \n            // Hide the request parameters if this portlet isn't targeted\n            if (!rd.isTargeted()) {\n                wrappedRequest = new EmptyRequestImpl(wrappedRequest);\n            }\n            \n            // Add the user information\n            wrappedRequest.setAttribute(PortletRequest.USER_INFO, cd.getUserInfo());\n            \n            //System.out.println(\"Rendering portlet \" + cd.getPortletWindow().getId());\n            portletContainer.renderPortlet(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n            \n            markup = sw.toString();\n            \n            cd.setProcessedAction(false);\n            ((PortletWindowImpl)cd.getPortletWindow()).setInternalActionResponse(null);\n                        \n        } catch (Throwable t) {\n            // TODO: review this\n            // t.printStackTrace();\n            // since the stack trace will be logged, this printStackTrace()\n            // was overkill? -andrew.petro@yale.edu\n            \n            log.error(t, t);\n            throw new PortalException(t.getMessage());\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n        return markup;\n    }","id":22870,"modified_method":"/**\n     * This is where we do the real work of getting the markup.\n     * This is called from both renderXML() and renderCharacters().\n     * @param uid a unique ID used to identify the state of the channel\n     */\n    protected synchronized String getMarkup(String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelRuntimeData rd = channelState.getRuntimeData();\n        ChannelStaticData sd = channelState.getStaticData();\n        ChannelData cd = channelState.getChannelData();\n        PortletWindow portletWindow = cd.getPortletWindow();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        \n        String markup = \"<b>Problem rendering portlet \" + sd.getParameter(\"portletDefinitionId\") + \"<\/b>\";\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            HttpServletRequest wrappedRequest = ((PortletWindowImpl)cd.getPortletWindow()).getHttpServletRequest();\n            HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n            transferActionResultsToRequest(channelState, wrappedRequest);\n            \n                                                \n            // Hide the request parameters if this portlet isn't targeted\n            if (!rd.isTargeted()) {\n                wrappedRequest = new EmptyRequestImpl(wrappedRequest);\n            }\n            \n            // Add the user information\n            wrappedRequest.setAttribute(PortletRequest.USER_INFO, cd.getUserInfo());\n            \n            //System.out.println(\"Rendering portlet \" + cd.getPortletWindow().getId());\n            portletContainer.renderPortlet(portletWindow, wrappedRequest, wrappedResponse);\n            \n            //Support for the portlet modifying it's cache timeout\n            Map properties = PropertyManager.getRequestProperties(portletWindow, wrappedRequest);\n            String[] exprCacheTimeStr = (String[])properties.get(RenderResponse.EXPIRATION_CACHE);\n            \n            if (exprCacheTimeStr != null && exprCacheTimeStr.length > 0) {\n                PortletEntity pe = portletWindow.getPortletEntity();\n                PortletDefinition pd = pe.getPortletDefinition();\n                                \n                try {\n                    sd.put(CACHE_TIMEOUT_KEY, new Long(exprCacheTimeStr[0]));\n                }\n                catch (NumberFormatException nfe) {\n                    log.error(\"The specified RenderResponse.EXPIRATION_CACHE value of (\" + exprCacheTimeStr + \") is not a number.\", nfe);\n                    throw nfe;\n                }\n            }\n            \n            markup = sw.toString();\n            \n            cd.setProcessedAction(false);\n            ((PortletWindowImpl)cd.getPortletWindow()).setInternalActionResponse(null);\n                        \n        } catch (Throwable t) {\n            // TODO: review this\n            // t.printStackTrace();\n            // since the stack trace will be logged, this printStackTrace()\n            // was overkill? -andrew.petro@yale.edu\n            \n            log.error(t, t);\n            throw new PortalException(t.getMessage());\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n        //Keep track of the last time the portlet was successfully rendered\n        sd.put(LAST_RENDER_TIME_KEY, new Long(System.currentTimeMillis()));\n        \n        return markup;\n    }","commit_id":"a21940a6cf95af73375276489b96432092f2f98b","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Sets the channel runtime data.\n     * @param rd the channel runtime data\n     * @param uid a unique ID used to identify the state of the channel\n     * @throws org.jasig.portal.PortalException\n     */\n    public void setRuntimeData(ChannelRuntimeData rd, String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        channelState.setRuntimeData(rd);\n        \n        ChannelData cd = channelState.getChannelData();\n        \n        \n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n            \n            if (cd.isPortletWindowInitialized()) {\n\t\t\t\tPortalControlStructures pcs = channelState.getPortalControlStructures();\n\t\t\t\tServletRequestImpl wrappedRequest = new ServletRequestImpl(pcs.getHttpServletRequest());\n                // Put the current runtime data into the portlet window\n                PortletWindowImpl portletWindow = (PortletWindowImpl)cd.getPortletWindow();\n                portletWindow.setChannelRuntimeData(rd);\n                portletWindow.setHttpServletRequest(wrappedRequest);\n                // Get the portlet url manager which will analyze the request parameters\n                DynamicInformationProvider dip = InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest());\n                PortletStateManager psm = ((DynamicInformationProviderImpl)dip).getPortletStateManager(portletWindow);\n                \n                // If portlet is rendering as root, change mode to maximized, otherwise minimized\n                PortletActionProvider pap = dip.getPortletActionProvider(portletWindow);\n                if (rd.isRenderingAsRoot()) {\n                    pap.changePortletWindowState(WindowState.MAXIMIZED);\n                } else {\n                    pap.changePortletWindowState(WindowState.NORMAL);\n                }\n                \n                // Process action if this is the targeted channel and the URL is an action URL\n                if (rd.isTargeted() && psm.isAction()) {\n                    try {\n                        StringWriter sw = new StringWriter();\n                        PrintWriter pw = new PrintWriter(sw);\n                        HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n                        //System.out.println(\"Processing portlet action on \" + cd.getPortletWindow().getId());\n                        portletContainer.processPortletAction(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n                        InternalActionResponse actionResponse = (InternalActionResponse)PortletObjectAccess.getActionResponse(cd.getPortletWindow(), pcs.getHttpServletRequest(), pcs.getHttpServletResponse());\n                        cd.setProcessedAction(true);\n                    } catch (Exception e) {\n                        throw new PortalException(e);\n                    }\n                }\n            }\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n    }","id":22871,"modified_method":"/**\n     * Sets the channel runtime data.\n     * @param rd the channel runtime data\n     * @param uid a unique ID used to identify the state of the channel\n     * @throws org.jasig.portal.PortalException\n     */\n    public void setRuntimeData(ChannelRuntimeData rd, String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        channelState.setRuntimeData(rd);\n        \n        ChannelData cd = channelState.getChannelData();\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n            \n            if (cd.isPortletWindowInitialized()) {\n\t\t\t\tPortalControlStructures pcs = channelState.getPortalControlStructures();\n\t\t\t\tServletRequestImpl wrappedRequest = new ServletRequestImpl(pcs.getHttpServletRequest());\n                \n                // Put the current runtime data and wrapped request into the portlet window\n                PortletWindowImpl portletWindow = (PortletWindowImpl)cd.getPortletWindow();\n                portletWindow.setChannelRuntimeData(rd);\n                portletWindow.setHttpServletRequest(wrappedRequest);\n                \n                // Get the portlet url manager which will analyze the request parameters\n                DynamicInformationProvider dip = InformationProviderAccess.getDynamicProvider(wrappedRequest);\n                PortletStateManager psm = ((DynamicInformationProviderImpl)dip).getPortletStateManager(portletWindow);\n                \n                // If portlet is rendering as root, change mode to maximized, otherwise minimized\n                PortletActionProvider pap = dip.getPortletActionProvider(portletWindow);\n                if (rd.isRenderingAsRoot()) {\n                    pap.changePortletWindowState(WindowState.MAXIMIZED);\n                } else {\n                    pap.changePortletWindowState(WindowState.NORMAL);\n                }\n                \n                // Process action if this is the targeted channel and the URL is an action URL\n                if (rd.isTargeted() && psm.isAction()) {\n                    try {\n                        StringWriter sw = new StringWriter();\n                        PrintWriter pw = new PrintWriter(sw);\n                        HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n                        //System.out.println(\"Processing portlet action on \" + cd.getPortletWindow().getId());\n                        portletContainer.processPortletAction(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n                        InternalActionResponse actionResponse = (InternalActionResponse)PortletObjectAccess.getActionResponse(cd.getPortletWindow(), pcs.getHttpServletRequest(), pcs.getHttpServletResponse());\n                        cd.setProcessedAction(true);\n                    } catch (Exception e) {\n                        throw new PortalException(e);\n                    }\n                }\n            }\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n    }","commit_id":"451d18bf21899c4b2b9062883d63f1be87e70bfb","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * This is where we do the real work of getting the markup.\n     * This is called from both renderXML() and renderCharacters().\n     * @param uid a unique ID used to identify the state of the channel\n     */\n    protected synchronized String getMarkup(String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelRuntimeData rd = channelState.getRuntimeData();\n        ChannelStaticData sd = channelState.getStaticData();\n        ChannelData cd = channelState.getChannelData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        \n        String markup = \"<b>Problem rendering portlet \" + sd.getParameter(\"portletDefinitionId\") + \"<\/b>\";\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            HttpServletRequest wrappedRequest = new ServletRequestImpl(pcs.getHttpServletRequest());\n            HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n            \n            // Check if this portlet has just processed an action during this request.\n            // If so, then we capture the changes that the portlet may have made during\n            // its processAction implementation (captured in the portlet's ActionResponse)\n            // and we pass them to the render request.\n            // Pluto's portlet container implementation does this by creating a new render URL \n            // and redirecting, but we have overidden that behavior in our own version of PortletContainerImpl.\n            if (cd.hasProcessedAction()) {\n                InternalActionResponse actionResponse = ((PortletWindowImpl)cd.getPortletWindow()).getInternalActionResponse();\n                PortletActionProvider pap = InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest()).getPortletActionProvider(cd.getPortletWindow());\n                // Change modes\n                if (actionResponse.getChangedPortletMode() != null) {\n                    pap.changePortletMode(actionResponse.getChangedPortletMode());\n                }\n                // Change window states\n                if (actionResponse.getChangedWindowState() != null) {\n                    pap.changePortletWindowState(actionResponse.getChangedWindowState());\n                }\n                // Change render parameters\n                Map renderParameters = actionResponse.getRenderParameters();\n                ((ServletRequestImpl)wrappedRequest).setParameters(renderParameters);\n            }\n                                    \n            // Hide the request parameters if this portlet isn't targeted\n            if (!rd.isTargeted()) {\n                wrappedRequest = new EmptyRequestImpl(wrappedRequest);\n            }\n            \n            //System.out.println(\"Rendering portlet \" + cd.getPortletWindow().getId());\n            portletContainer.renderPortlet(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n            \n            markup = sw.toString();\n            \n            cd.setProcessedAction(false);\n            ((PortletWindowImpl)cd.getPortletWindow()).setInternalActionResponse(null);\n                        \n        } catch (Throwable t) {\n            t.printStackTrace();\n            LogService.log(LogService.ERROR, t);\n            throw new PortalException(t.getMessage());\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n        return markup;\n    }","id":22872,"modified_method":"/**\n     * This is where we do the real work of getting the markup.\n     * This is called from both renderXML() and renderCharacters().\n     * @param uid a unique ID used to identify the state of the channel\n     */\n    protected synchronized String getMarkup(String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelRuntimeData rd = channelState.getRuntimeData();\n        ChannelStaticData sd = channelState.getStaticData();\n        ChannelData cd = channelState.getChannelData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        \n        String markup = \"<b>Problem rendering portlet \" + sd.getParameter(\"portletDefinitionId\") + \"<\/b>\";\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            HttpServletRequest wrappedRequest = ((PortletWindowImpl)cd.getPortletWindow()).getHttpServletRequest();\n            HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n            \n            // Check if this portlet has just processed an action during this request.\n            // If so, then we capture the changes that the portlet may have made during\n            // its processAction implementation (captured in the portlet's ActionResponse)\n            // and we pass them to the render request.\n            // Pluto's portlet container implementation does this by creating a new render URL \n            // and redirecting, but we have overidden that behavior in our own version of PortletContainerImpl.\n            if (cd.hasProcessedAction()) {\n                InternalActionResponse actionResponse = ((PortletWindowImpl)cd.getPortletWindow()).getInternalActionResponse();\n                PortletActionProvider pap = InformationProviderAccess.getDynamicProvider(wrappedRequest).getPortletActionProvider(cd.getPortletWindow());\n                // Change modes\n                if (actionResponse.getChangedPortletMode() != null) {\n                    pap.changePortletMode(actionResponse.getChangedPortletMode());\n                }\n                // Change window states\n                if (actionResponse.getChangedWindowState() != null) {\n                    pap.changePortletWindowState(actionResponse.getChangedWindowState());\n                }\n                // Change render parameters\n                Map renderParameters = actionResponse.getRenderParameters();\n                ((ServletRequestImpl)wrappedRequest).setParameters(renderParameters);\n            }\n                                    \n            // Hide the request parameters if this portlet isn't targeted\n            if (!rd.isTargeted()) {\n                wrappedRequest = new EmptyRequestImpl(wrappedRequest);\n            }\n            \n            //System.out.println(\"Rendering portlet \" + cd.getPortletWindow().getId());\n            portletContainer.renderPortlet(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n            \n            markup = sw.toString();\n            \n            cd.setProcessedAction(false);\n            ((PortletWindowImpl)cd.getPortletWindow()).setInternalActionResponse(null);\n                        \n        } catch (Throwable t) {\n            t.printStackTrace();\n            LogService.log(LogService.ERROR, t);\n            throw new PortalException(t.getMessage());\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n        return markup;\n    }","commit_id":"451d18bf21899c4b2b9062883d63f1be87e70bfb","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * This is where we do the real work of getting the markup.\n     * This is called from both renderXML() and renderCharacters().\n     * @param uid a unique ID used to identify the state of the channel\n     */\n    protected synchronized String getMarkup(String uid) {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelRuntimeData rd = channelState.getRuntimeData();\n        ChannelStaticData sd = channelState.getStaticData();\n        ChannelData cd = channelState.getChannelData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        \n        String markup = \"<b>Problem rendering portlet \" + sd.getParameter(\"portletDefinitionId\") + \"<\/b>\";\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n            \n            // Check if this portlet has just processed an action during this request.\n            // If so, then we capture the changes that the portlet may have made during\n            // its processAction implementation and we pass them to the render request.\n            // Pluto's normally does this by creating a new render URL and redirecting,\n            // but we have overidden that behavior in our own version of PortletContainerImpl.\n            if (cd.hasProcessedAction()) {\n                InternalActionResponse actionResponse = (InternalActionResponse)PortletObjectAccess.getActionResponse(cd.getPortletWindow(), pcs.getHttpServletRequest(), pcs.getHttpServletResponse());\n                PortletActionProvider pap = InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest()).getPortletActionProvider(cd.getPortletWindow());\n                // Change modes\n                if (actionResponse.getChangedPortletMode() != null) {\n                    pap.changePortletMode(actionResponse.getChangedPortletMode());\n                }\n                // Change window states\n                if (actionResponse.getChangedWindowState() != null) {\n                    pap.changePortletWindowState(actionResponse.getChangedWindowState());\n                }\n                // Change render parameters\n                Map renderParameters = actionResponse.getRenderParameters();\n                PortletStateManager pum = ((DynamicInformationProviderImpl)InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest())).getPortletURLManager(cd.getPortletWindow());\n                pum.setParameters(renderParameters);\n            }\n\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            HttpServletRequest wrappedRequest = pcs.getHttpServletRequest();\n            HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n                                    \n            // Hide the request parameters if this portlet isn't targeted\n            if (!rd.isTargeted()) {\n                wrappedRequest = new EmptyRequestImpl(wrappedRequest);\n            }\n            \n            //System.out.println(\"Rendering portlet \" + cd.getPortletWindow().getId());\n            portletContainer.renderPortlet(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n            \n            markup = sw.toString();\n            \n            cd.setProcessedAction(false);\n                        \n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n        return markup;\n    }","id":22873,"modified_method":"/**\n     * This is where we do the real work of getting the markup.\n     * This is called from both renderXML() and renderCharacters().\n     * @param uid a unique ID used to identify the state of the channel\n     */\n    protected synchronized String getMarkup(String uid) {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        ChannelRuntimeData rd = channelState.getRuntimeData();\n        ChannelStaticData sd = channelState.getStaticData();\n        ChannelData cd = channelState.getChannelData();\n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        \n        String markup = \"<b>Problem rendering portlet \" + sd.getParameter(\"portletDefinitionId\") + \"<\/b>\";\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n            \n            // Check if this portlet has just processed an action during this request.\n            // If so, then we capture the changes that the portlet may have made during\n            // its processAction implementation (captured in the portlet's ActionResponse)\n            //  and we pass them to the render request.\n            // Pluto's portlet container implementation does this by creating a new render URL \n            // and redirecting, but we have overidden that behavior in our own version of PortletContainerImpl.\n            if (cd.hasProcessedAction()) {\n                InternalActionResponse actionResponse = ((PortletWindowImpl)cd.getPortletWindow()).getInternalActionResponse();\n                PortletActionProvider pap = InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest()).getPortletActionProvider(cd.getPortletWindow());\n                // Change modes\n                if (actionResponse.getChangedPortletMode() != null) {\n                    pap.changePortletMode(actionResponse.getChangedPortletMode());\n                }\n                // Change window states\n                if (actionResponse.getChangedWindowState() != null) {\n                    pap.changePortletWindowState(actionResponse.getChangedWindowState());\n                }\n                // Change render parameters\n                Map renderParameters = actionResponse.getRenderParameters();\n                PortletStateManager pum = ((DynamicInformationProviderImpl)InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest())).getPortletURLManager(cd.getPortletWindow());\n                pum.setParameters(renderParameters);\n            }\n\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            HttpServletRequest request = pcs.getHttpServletRequest();\n            HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n                                    \n            // Hide the request parameters if this portlet isn't targeted\n            if (!rd.isTargeted()) {\n                request = new EmptyRequestImpl(request);\n            }\n            \n            //System.out.println(\"Rendering portlet \" + cd.getPortletWindow().getId());\n            portletContainer.renderPortlet(cd.getPortletWindow(), request, wrappedResponse);\n            \n            markup = sw.toString();\n            \n            cd.setProcessedAction(false);\n                        \n        } catch (Throwable t) {\n            t.printStackTrace();\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n        return markup;\n    }","commit_id":"ee98c48d49581a4d5319892eac6076608e7683bc","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Sets the channel runtime data.\n     * @param rd the channel runtime data\n     * @param uid a unique ID used to identify the state of the channel\n     * @throws org.jasig.portal.PortalException\n     */\n    public void setRuntimeData(ChannelRuntimeData rd, String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        channelState.setRuntimeData(rd);\n        \n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        ChannelData cd = channelState.getChannelData();\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n            \n            if (cd.isPortletWindowInitialized()) {\n                // Put the current runtime data into the portlet window\n                PortletWindowImpl portletWindow = (PortletWindowImpl)cd.getPortletWindow();\n                portletWindow.setChannelRuntimeData(rd);\n                portletWindow.setHttpServletRequest(pcs.getHttpServletRequest());\n                \n                // Get the portlet url manager which will analyze the request parameters\n                DynamicInformationProvider dip = InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest());\n                PortletStateManager pum = ((DynamicInformationProviderImpl)dip).getPortletURLManager(portletWindow);\n                \n                // If portlet is rendering as root, change mode to maximized, otherwise minimized\n                PortletActionProvider pap = dip.getPortletActionProvider(portletWindow);\n                if (rd.isRenderingAsRoot()) {\n                    pap.changePortletWindowState(WindowState.MAXIMIZED);\n                } else {\n                    pap.changePortletWindowState(WindowState.NORMAL);\n                }\n                \n                // Process action if this is the targeted channel and the URL is an action URL\n                if (rd.isTargeted() && pum.isAction()) {\n                    try {\n                        StringWriter sw = new StringWriter();\n                        PrintWriter pw = new PrintWriter(sw);\n                        HttpServletRequest wrappedRequest = pcs.getHttpServletRequest();\n                        HttpServletResponse wrappedResponse = new StoredServletResponseImpl(pcs.getHttpServletResponse(), pw);\n                        //System.out.println(\"Processing portlet action on \" + cd.getPortletWindow().getId());\n                        portletContainer.processPortletAction(cd.getPortletWindow(), wrappedRequest, wrappedResponse);\n                        cd.setProcessedAction(true);\n                    } catch (Exception e) {\n                        throw new PortalException(e);\n                    }\n                }\n            }\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n    }","id":22874,"modified_method":"/**\n     * Sets the channel runtime data.\n     * @param rd the channel runtime data\n     * @param uid a unique ID used to identify the state of the channel\n     * @throws org.jasig.portal.PortalException\n     */\n    public void setRuntimeData(ChannelRuntimeData rd, String uid) throws PortalException {\n        ChannelState channelState = (ChannelState)channelStateMap.get(uid);\n        channelState.setRuntimeData(rd);\n        \n        PortalControlStructures pcs = channelState.getPortalControlStructures();\n        ChannelData cd = channelState.getChannelData();\n        \n        try {\n            PortletContainerServices.prepare(uniqueContainerName);\n            \n            if (cd.isPortletWindowInitialized()) {\n                // Put the current runtime data into the portlet window\n                PortletWindowImpl portletWindow = (PortletWindowImpl)cd.getPortletWindow();\n                portletWindow.setChannelRuntimeData(rd);\n                portletWindow.setHttpServletRequest(pcs.getHttpServletRequest());\n                \n                // Get the portlet url manager which will analyze the request parameters\n                DynamicInformationProvider dip = InformationProviderAccess.getDynamicProvider(pcs.getHttpServletRequest());\n                PortletStateManager pum = ((DynamicInformationProviderImpl)dip).getPortletURLManager(portletWindow);\n                \n                // If portlet is rendering as root, change mode to maximized, otherwise minimized\n                PortletActionProvider pap = dip.getPortletActionProvider(portletWindow);\n                if (rd.isRenderingAsRoot()) {\n                    pap.changePortletWindowState(WindowState.MAXIMIZED);\n                } else {\n                    pap.changePortletWindowState(WindowState.NORMAL);\n                }\n                \n                // Process action if this is the targeted channel and the URL is an action URL\n                if (rd.isTargeted() && pum.isAction()) {\n                    try {\n                        StringWriter sw = new StringWriter();\n                        PrintWriter pw = new PrintWriter(sw);\n                        HttpServletRequest request = pcs.getHttpServletRequest();\n                        HttpServletResponse wrappedResponse = ServletObjectAccess.getStoredServletResponse(pcs.getHttpServletResponse(), pw);\n                        //System.out.println(\"Processing portlet action on \" + cd.getPortletWindow().getId());\n                        portletContainer.processPortletAction(cd.getPortletWindow(), request, wrappedResponse);\n                        InternalActionResponse actionResponse = (InternalActionResponse)PortletObjectAccess.getActionResponse(cd.getPortletWindow(), pcs.getHttpServletRequest(), pcs.getHttpServletResponse());\n                        cd.setProcessedAction(true);\n                    } catch (Exception e) {\n                        throw new PortalException(e);\n                    }\n                }\n            }\n        } finally {\n            PortletContainerServices.release();\n        }\n        \n    }","commit_id":"ee98c48d49581a4d5319892eac6076608e7683bc","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected void redirect(String location, \n                            PortletWindow portletWindow, \n                            HttpServletRequest servletRequest, \n                            HttpServletResponse servletResponse, \n                            InternalActionResponse _actionResponse) \n    throws IOException {\n        \n        // Don't do anything.\n        \n    }","id":22875,"modified_method":"protected void redirect(String location, \n                            PortletWindow portletWindow, \n                            HttpServletRequest servletRequest, \n                            HttpServletResponse servletResponse, \n                            InternalActionResponse _actionResponse) \n    throws IOException {\n        \n        // Rather than redirect, we shall capture the internal action response\n        // and make it available to the portlet adapter via the portlet window\n        ((PortletWindowImpl)portletWindow).setInternalActionResponse(_actionResponse);\n        \n    }","commit_id":"ee98c48d49581a4d5319892eac6076608e7683bc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void prefetchMessages( Folder folder, Message[] msgList ) throws MessagingException\n\t{\n\t\t// Prefetch all the key information and headers\n\t\t\n\t\tFetchProfile fp = new FetchProfile();\n\t\tfp.add( FetchProfile.Item.ENVELOPE );\n\t\t\n\t\tfor( int i = 0; i < PREFETCH_HEADERS.length; i++ ) {\n\t\t\tfp.add( PREFETCH_HEADERS[i] );\n\t\t}\n\t\tfolder.fetch( msgList, fp );\n\t}","id":22876,"modified_method":"private void prefetchMessages( Folder folder, Message[] msgList ) throws MessagingException\n\t{\n\t\t// Prefetch all the key information and headers\n\t\t\n\t\tFetchProfile fp = new FetchProfile();\n\t\tfp.add( FetchProfile.Item.ENVELOPE );\n\t\t\n        for (String PREFETCH_HEADERS : PREFETCH_HEADERS) {\n            fp.add(PREFETCH_HEADERS);\n        }\n\t\tfolder.fetch( msgList, fp );\n\t}","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"private Sequence getMessageListAsXML( Sequence[] args, Sequence contextSequence ) throws XPathException\n\t{\n\t\tMessage[] \t\t msgList;\n\t\tSequence \t\t ret\t\t= Sequence.EMPTY_SEQUENCE;\n\t\t\n\t\t// was a msgList handle specified?\n\t\tif( args[0].isEmpty() ) {\n\t\t\tthrow( new XPathException(this, \"Message List handle not specified\" ) );\n\t\t}\n\n\t\t// get the MessageList\n\t\tlong msgListHandle = ((IntegerValue)args[0].itemAt(0)).getLong();\n\t\tmsgList = MailModule.retrieveMessageList( context, msgListHandle );\n\t\tif( msgList == null ) {\n\t\t\tthrow( new XPathException(this, \"Invalid Message List handle specified\" ) );\n\t\t}\n\t\t\n\t\tif( msgList.length > 0 ) {\n\t\t\t\n\t\t\tboolean includeHeaders = args[1].effectiveBooleanValue();\n\t\t\t\n\t\t\tMemTreeBuilder builder = context.getDocumentBuilder();\n        \n\t        builder.startDocument();\n\t        builder.startElement( new QName( \"messages\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t        builder.addAttribute( new QName( \"count\", null, null ), String.valueOf( msgList.length ) );\n\t\t\t\n\t\t\ttry {\n\t\t\t\tfor( int i = 0; i < msgList.length; i++ ) {\n\t\t\t\t\tMessage message = msgList[ i ];\n\t\t\t\t\t\n\t\t\t\t\tbuilder.startElement( new QName( \"message\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\n\t\t\t\t\tbuilder.addAttribute( new QName( \"number\", null, null ), String.valueOf( i ) );\n\t\t\t\t\t\n\t\t\t\t\t// Sent Date\n\t\t\t\t\tif( message.getSentDate() != null ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"sent\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\tbuilder.characters( formatDate( message.getSentDate() ) );\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t\t// Received Date\n\t\t\t\t\tif( message.getReceivedDate() != null ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"received\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\tbuilder.characters( formatDate( message.getReceivedDate() ) );\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t\t// From\n\t\t\t\t\tif( message.getFrom() != null ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"from\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\tbuilder.characters( message.getFrom()[0].toString() );\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Recipients\n\t\t\t\t\tbuilder.startElement( new QName( \"recipients\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t// To Recipients\n\t\t\t\t\t\tAddress[] to = message.getRecipients( Message.RecipientType.TO );\n\t\t\t\t\t\tif( to != null ) {\n\t\t\t\t\t\t\tfor( int j = 0; j < to.length; j++ ) {\n\t\t\t\t\t\t\t\tbuilder.startElement( new QName( \"recipient\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\t\tbuilder.addAttribute( new QName( \"type\", null, null ), \"to\" );\n\t\t\t\t\t\t\t\tbuilder.characters( to[j].toString() );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// cc Recipients\n\t\t\t\t\t\tAddress[] cc = message.getRecipients( Message.RecipientType.CC );\n\t\t\t\t\t\tif( cc != null ) {\n\t\t\t\t\t\t\tfor( int j = 0; j < cc.length; j++ ) {\n\t\t\t\t\t\t\t\tbuilder.startElement( new QName( \"recipient\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\t\tbuilder.addAttribute( new QName( \"type\", null, null ), \"cc\" );\n\t\t\t\t\t\t\t\tbuilder.characters( cc[j].toString() );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// bcc Recipients\n\t\t\t\t\t\tAddress[] bccAddresses = message.getRecipients( Message.RecipientType.BCC );\n\t\t\t\t\t\tif( bccAddresses != null ) {\n                        for (Address bccAddress : bccAddresses) {\n\t\t\t\t\t\t\t\tbuilder.startElement( new QName( \"recipient\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\t\tbuilder.addAttribute( new QName( \"type\", null, null ), \"bcc\" );\n                            builder.characters(bccAddress.toString());\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\n\t\t\t\t\t// Flags\n\t\t\t\t\t\n\t\t\t\t\tFlags \t\t\tflags \t= message.getFlags();\n\t\t\t\t\tFlags.Flag[] \tsf\t\t= flags.getSystemFlags();\n\t\t\t\t\tString[] \t\tuf \t\t= flags.getUserFlags();\n\t\t\t\t\t\n\t\t\t\t\tif( sf.length > 0 || uf.length > 0 ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"flags\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\n\t\t\t\t\t\t// System Flags\n\t\t\t\t\t\tfor( int f = 0; f < sf.length; f++ ) {\n\t\t\t\t\t        if( sf[f] == Flags.Flag.ANSWERED ) {\n\t\t\t\t\t\t\t\tbuilder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"answered\" );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t} else if( sf[f] == Flags.Flag.DELETED ) {\n\t\t\t\t\t           \tbuilder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"deleted\" );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t} else if( sf[f] == Flags.Flag.DRAFT ) {\n\t\t\t\t\t           \tbuilder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"draft\" );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t} else if( sf[f] == Flags.Flag.FLAGGED ) {\n\t\t\t\t\t           \tbuilder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"flagged\" );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t} else if( sf[f] == Flags.Flag.RECENT ) {\n\t\t\t\t\t           builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"recent\" );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t} else if( sf[f] == Flags.Flag.SEEN ) {\n\t\t\t\t\t           \tbuilder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"seen\" );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// User Flags\n\t\t\t\t\t\tfor( int f = 0; f < uf.length; f++ ) {\n\t\t\t\t\t\t\tbuilder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t          \tbuilder.addAttribute( new QName( \"type\", null, null ), \"user\" );\n\t\t\t\t\t\t\tbuilder.addAttribute( new QName( \"value\", null, null ), uf[ f ] );\n\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Headers\n\t\t\t\t\t\n\t\t\t\t\tif( includeHeaders ) {\n\t\t\t\t\t\tEnumeration headers = message.getAllHeaders();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( headers.hasMoreElements() ) {\n\t\t\t\t\t\t\tbuilder.startElement( new QName( \"headers\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twhile( headers.hasMoreElements() ) {\n\t\t\t\t\t\t\t\tHeader header = (Header)headers.nextElement();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbuilder.startElement( new QName( \"header\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"name\", null, null ), header.getName() );\n\t\t\t\t\t\t\t\tbuilder.addAttribute( new QName( \"value\", null, null ), header.getValue() );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Subject\n\t\t\t\t\tbuilder.startElement( new QName( \"subject\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\tbuilder.characters( message.getSubject() );\n\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\n\t\t\t\t\tbuilder.endElement();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch( MessagingException me ) {\n\t\t\t\tthrow( new XPathException(this, \"Failed to retrieve messages from list\", me ) );\n\t\t\t}\n\t\t\t\n\t\t\tbuilder.endElement();\n        \n        \tret = (NodeValue)builder.getDocument().getDocumentElement();\n\t\t}\n\t\t\n\t\treturn( ret );\n\t}","id":22877,"modified_method":"private Sequence getMessageListAsXML( Sequence[] args, Sequence contextSequence ) throws XPathException\n\t{\n\t\tMessage[] \t\t msgList;\n\t\tSequence \t\t ret\t\t= Sequence.EMPTY_SEQUENCE;\n\t\t\n\t\t// was a msgList handle specified?\n\t\tif( args[0].isEmpty() ) {\n\t\t\tthrow( new XPathException(this, \"Message List handle not specified\" ) );\n\t\t}\n\n\t\t// get the MessageList\n\t\tlong msgListHandle = ((IntegerValue)args[0].itemAt(0)).getLong();\n\t\tmsgList = MailModule.retrieveMessageList( context, msgListHandle );\n\t\tif( msgList == null ) {\n\t\t\tthrow( new XPathException(this, \"Invalid Message List handle specified\" ) );\n\t\t}\n\t\t\n\t\tif( msgList.length > 0 ) {\n\t\t\t\n\t\t\tboolean includeHeaders = args[1].effectiveBooleanValue();\n\t\t\t\n\t\t\tMemTreeBuilder builder = context.getDocumentBuilder();\n        \n\t        builder.startDocument();\n\t        builder.startElement( new QName( \"messages\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t        builder.addAttribute( new QName( \"count\", null, null ), String.valueOf( msgList.length ) );\n\t\t\t\n\t\t\ttry {\n\t\t\t\tfor( int i = 0; i < msgList.length; i++ ) {\n\t\t\t\t\tMessage message = msgList[ i ];\n\t\t\t\t\t\n\t\t\t\t\tbuilder.startElement( new QName( \"message\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\n\t\t\t\t\tbuilder.addAttribute( new QName( \"number\", null, null ), String.valueOf( i ) );\n\t\t\t\t\t\n\t\t\t\t\t// Sent Date\n\t\t\t\t\tif( message.getSentDate() != null ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"sent\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\tbuilder.characters( formatDate( message.getSentDate() ) );\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t\t// Received Date\n\t\t\t\t\tif( message.getReceivedDate() != null ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"received\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\tbuilder.characters( formatDate( message.getReceivedDate() ) );\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t\t// From\n\t\t\t\t\tif( message.getFrom() != null ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"from\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\tbuilder.characters( message.getFrom()[0].toString() );\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Recipients\n\t\t\t\t\tbuilder.startElement( new QName( \"recipients\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t// To Recipients\n\t\t\t\t\t\tAddress[] toAddresses = message.getRecipients( Message.RecipientType.TO );\n\t\t\t\t\t\tif( toAddresses != null ) {\n                        for (Address to : toAddresses) {\n                            builder.startElement( new QName( \"recipient\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                            builder.addAttribute( new QName( \"type\", null, null ), \"to\" );\n                            builder.characters(to.toString());\n                            builder.endElement();\n                        }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// cc Recipients\n\t\t\t\t\t\tAddress[] ccAddresses = message.getRecipients( Message.RecipientType.CC );\n\t\t\t\t\t\tif( ccAddresses != null ) {\n                        for (Address ccAddress : ccAddresses) {\n                            builder.startElement( new QName( \"recipient\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                            builder.addAttribute( new QName( \"type\", null, null ), \"cc\" );\n                            builder.characters(ccAddress.toString());\n                            builder.endElement();\n                        }\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// bcc Recipients\n\t\t\t\t\t\tAddress[] bccAddresses = message.getRecipients( Message.RecipientType.BCC );\n\t\t\t\t\t\tif( bccAddresses != null ) {\n                        for (Address bccAddress : bccAddresses) {\n                            builder.startElement( new QName( \"recipient\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                            builder.addAttribute( new QName( \"type\", null, null ), \"bcc\" );\n                            builder.characters(bccAddress.toString());\n                            builder.endElement();\n                        }\n\t\t\t\t\t\t}\n\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\n\t\t\t\t\t// Flags\n\t\t\t\t\t\n\t\t\t\t\tFlags \t\t\tflags \t= message.getFlags();\n\t\t\t\t\tFlags.Flag[] \tsystemFlags\t\t= flags.getSystemFlags();\n\t\t\t\t\tString[] \t\tuserFlags \t\t= flags.getUserFlags();\n\t\t\t\t\t\n\t\t\t\t\tif( systemFlags.length > 0 || userFlags.length > 0 ) {\n\t\t\t\t\t\tbuilder.startElement( new QName( \"flags\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\n                        for (Flags.Flag systemFlag : systemFlags) {\n                            if (systemFlag == Flags.Flag.ANSWERED) {\n                                builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                                builder.addAttribute( new QName( \"type\", null, null ), \"answered\" );\n                                builder.endElement();\n                            } else if (systemFlag == Flags.Flag.DELETED) {\n                                builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                                builder.addAttribute( new QName( \"type\", null, null ), \"deleted\" );\n                                builder.endElement();\n                            } else if (systemFlag == Flags.Flag.DRAFT) {\n                                builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                                builder.addAttribute( new QName( \"type\", null, null ), \"draft\" );\n                                builder.endElement();\n                            } else if (systemFlag == Flags.Flag.FLAGGED) {\n                                builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                                builder.addAttribute( new QName( \"type\", null, null ), \"flagged\" );\n                                builder.endElement();\n                            } else if (systemFlag == Flags.Flag.RECENT) {\n                                builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                                builder.addAttribute( new QName( \"type\", null, null ), \"recent\" );\n                                builder.endElement();\n                            } else if (systemFlag == Flags.Flag.SEEN) {\n                                builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                                builder.addAttribute( new QName( \"type\", null, null ), \"seen\" );\n                                builder.endElement();\n                            }\n                        }\n\t\t\t\t\t\t\n                        for (String userFlag : userFlags) {\n                            builder.startElement( new QName( \"flag\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n                            builder.addAttribute( new QName( \"type\", null, null ), \"user\" );\n                            builder.addAttribute(new QName( \"value\", null, null ), userFlag);\n                            builder.endElement();\n                        }\n\n\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Headers\n\t\t\t\t\t\n\t\t\t\t\tif( includeHeaders ) {\n\t\t\t\t\t\tEnumeration headers = message.getAllHeaders();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( headers.hasMoreElements() ) {\n\t\t\t\t\t\t\tbuilder.startElement( new QName( \"headers\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twhile( headers.hasMoreElements() ) {\n\t\t\t\t\t\t\t\tHeader header = (Header)headers.nextElement();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tbuilder.startElement( new QName( \"header\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\t          \tbuilder.addAttribute( new QName( \"name\", null, null ), header.getName() );\n\t\t\t\t\t\t\t\tbuilder.addAttribute( new QName( \"value\", null, null ), header.getValue() );\n\t\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Subject\n\t\t\t\t\tbuilder.startElement( new QName( \"subject\", MailModule.NAMESPACE_URI, MailModule.PREFIX ), null );\n\t\t\t\t\tbuilder.characters( message.getSubject() );\n\t\t\t\t\tbuilder.endElement();\n\t\t\t\t\t\n\t\t\t\t\tbuilder.endElement();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch( MessagingException me ) {\n\t\t\t\tthrow( new XPathException(this, \"Failed to retrieve messages from list\", me ) );\n\t\t\t}\n\t\t\t\n\t\t\tbuilder.endElement();\n        \n        \tret = (NodeValue)builder.getDocument().getDocumentElement();\n\t\t}\n\t\t\n\t\treturn( ret );\n\t}","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Sends an email using SMTP\n     *\n     * @param mail\t\tA mail object representing the email to send\n     * @param SMTPServer\tThe SMTP Server to send the email through\n     * @return\t\tboolean value of true of false indicating success or failure to send email\n     */\n    private List<Boolean> sendBySMTP(List<Mail> mails, String SMTPServer) throws SMTPException\n    {\n        final int TCP_PROTOCOL_SMTP = 25;   //SMTP Protocol\n        String smtpResult = \"\";             //Holds the server Result code when an SMTP Command is executed\n\n        Socket smtpSock = null;\n        BufferedReader smtpIn = null;\n        PrintWriter smtpOut = null;\n\n        List<Boolean> sendMailResults = new ArrayList<Boolean>();\n\n        try\n        {\n            //Create a Socket and connect to the SMTP Server\n            smtpSock = new Socket(SMTPServer, TCP_PROTOCOL_SMTP);\n\n            //Create a Buffered Reader for the Socket\n            smtpIn = new BufferedReader(new InputStreamReader(smtpSock.getInputStream()));\n\n            //Create an Output Writer for the Socket\n            smtpOut = new PrintWriter(new OutputStreamWriter(smtpSock.getOutputStream(),charset));\n\n            //First line sent to us from the SMTP server should be \"220 blah blah\", 220 indicates okay\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).toString().equals(\"220\"))\n            {\n                String errMsg = \"Error - SMTP Server not ready: '\" + smtpResult + \"'\";\n                LOG.error(errMsg);\n                throw new SMTPException(errMsg);\n            }\n\n            //Say \"HELO\"\n            smtpOut.println(\"HELO \" + InetAddress.getLocalHost().getHostName());\n            smtpOut.flush();\n\n            //get \"HELLO\" response, should be \"250 blah blah\"\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).toString().equals(\"250\"))\n            {\n                String errMsg = \"Error - SMTP HELO Failed: '\" + smtpResult + \"'\";\n                LOG.error(errMsg);\n                throw new SMTPException(errMsg);\n            }\n\n            //write SMTP message(s)\n            for(Mail mail : mails)\n            {\n                boolean mailResult = writeSMTPMessage(mail, smtpOut, smtpIn);\n\n                sendMailResults.add(mailResult);\n            }\n        }\n        catch(IOException ioe)\n        {\n            LOG.error(ioe.getMessage(), ioe);\n            throw new SMTPException(ioe);\n        }\n        finally\n        {\n            try {\n                if(smtpOut != null)\n                    smtpOut.close();\n\n                if(smtpIn != null)\n                    smtpIn.close();\n\n                if(smtpSock != null)\n                    smtpSock.close();\n                \n            } catch (IOException ioe) {\n                LOG.warn(ioe.getMessage(), ioe);\n            }\n        }\n\n        //Message(s) Sent Succesfully\n        LOG.info(\"send-email() message(s) sent using SMTP \" + new Date());\n\n        return sendMailResults;\n    }","id":22878,"modified_method":"/**\n     * Sends an email using SMTP\n     *\n     * @param mail\t\tA mail object representing the email to send\n     * @param SMTPServer\tThe SMTP Server to send the email through\n     * @return\t\tboolean value of true of false indicating success or failure to send email\n     */\n    private List<Boolean> sendBySMTP(List<Mail> mails, String SMTPServer) throws SMTPException\n    {\n        final int TCP_PROTOCOL_SMTP = 25;   //SMTP Protocol\n        String smtpResult = \"\";             //Holds the server Result code when an SMTP Command is executed\n\n        Socket smtpSock = null;\n        BufferedReader smtpIn = null;\n        PrintWriter smtpOut = null;\n\n        List<Boolean> sendMailResults = new ArrayList<Boolean>();\n\n        try\n        {\n            //Create a Socket and connect to the SMTP Server\n            smtpSock = new Socket(SMTPServer, TCP_PROTOCOL_SMTP);\n\n            //Create a Buffered Reader for the Socket\n            smtpIn = new BufferedReader(new InputStreamReader(smtpSock.getInputStream()));\n\n            //Create an Output Writer for the Socket\n            smtpOut = new PrintWriter(new OutputStreamWriter(smtpSock.getOutputStream(),charset));\n\n            //First line sent to us from the SMTP server should be \"220 blah blah\", 220 indicates okay\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).equals(\"220\"))\n            {\n                String errMsg = \"Error - SMTP Server not ready: '\" + smtpResult + \"'\";\n                LOG.error(errMsg);\n                throw new SMTPException(errMsg);\n            }\n\n            //Say \"HELO\"\n            smtpOut.println(\"HELO \" + InetAddress.getLocalHost().getHostName());\n            smtpOut.flush();\n\n            //get \"HELLO\" response, should be \"250 blah blah\"\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).equals(\"250\"))\n            {\n                String errMsg = \"Error - SMTP HELO Failed: '\" + smtpResult + \"'\";\n                LOG.error(errMsg);\n                throw new SMTPException(errMsg);\n            }\n\n            //write SMTP message(s)\n            for(Mail mail : mails)\n            {\n                boolean mailResult = writeSMTPMessage(mail, smtpOut, smtpIn);\n\n                sendMailResults.add(mailResult);\n            }\n        }\n        catch(IOException ioe)\n        {\n            LOG.error(ioe.getMessage(), ioe);\n            throw new SMTPException(ioe);\n        }\n        finally\n        {\n            try {\n                if(smtpOut != null)\n                    smtpOut.close();\n\n                if(smtpIn != null)\n                    smtpIn.close();\n\n                if(smtpSock != null)\n                    smtpSock.close();\n                \n            } catch (IOException ioe) {\n                LOG.warn(ioe.getMessage(), ioe);\n            }\n        }\n\n        //Message(s) Sent Succesfully\n        LOG.info(\"send-email() message(s) sent using SMTP \" + new Date());\n\n        return sendMailResults;\n    }","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Constructs a mail Object from an XML representation of an email\n     *\n     * The XML email Representation is expected to look something like this\n     *\n     * <mail>\n     * \t<from><\/from>\n     * \t<reply-to><\/reply-to>\n     * \t<to><\/to>\n     * \t<cc><\/cc>\n     * \t<bcc><\/bcc>\n     * \t<subject><\/subject>\n     * \t<message>\n     * \t\t<text charset=\"\" encoding=\"\"><\/text>\n     * \t\t<xhtml charset=\"\" encoding=\"\"><\/xhtml>\n     * \t\t<generic charset=\"\" type=\"\" encoding=\"\"><\/generic>\n     * \t<\/message>\n     * \t<attachment mimetype=\"\" filename=\"\"><\/attachment>\n     * <\/mail>\n     *\n     * @param mailElements\tThe XML mail Node\n     * @return\t\tA mail Object representing the XML mail Node\n     */\n    private List<Message> parseMessageElement(Session session, List<Element> mailElements)\n            throws IOException, MessagingException, TransformerException {\n        List<Message> mails = new ArrayList<Message>();\n\n        for (Element mailElement : mailElements) {\n            //Make sure that message has a Mail node\n            if (mailElement.getLocalName().equals(\"mail\")) {\n                //New message Object\n                // create a message\n                MimeMessage msg = new MimeMessage(session);\n\n                ArrayList<InternetAddress> replyTo = new ArrayList<InternetAddress>();\n                boolean fromWasSet = false;\n                MimeBodyPart body = null;\n                Multipart multibody = null;\n                ArrayList<MimeBodyPart> attachments = new ArrayList<MimeBodyPart>();\n                String firstContent = null;\n                String firstContentType = null;\n                String firstCharset = null;\n                String firstEncoding = null;\n\n                //Get the First Child\n                Node child = mailElement.getFirstChild();\n                while (child != null) {\n                    //Parse each of the child nodes\n                    if (child.getNodeType() == Node.ELEMENT_NODE && child.hasChildNodes()) {\n                        if (child.getLocalName().equals(\"from\")) {\n                            // set the from and to address\n                            InternetAddress[] addressFrom = {new InternetAddress(child.getFirstChild().getNodeValue())};\n                            msg.addFrom(addressFrom);\n\n                            fromWasSet = true;\n                        } else if (child.getLocalName().equals(\"reply-to\")) {\n                            // As we can only set the reply-to, not add them, let's keep\n                            // all of them in a list\n                            replyTo.add(new InternetAddress(child.getFirstChild().getNodeValue()));\n                            msg.setReplyTo(replyTo.toArray(new InternetAddress[0]));\n                        } else if (child.getLocalName().equals(\"to\")) {\n                            msg.addRecipient(Message.RecipientType.TO, new InternetAddress(child.getFirstChild().getNodeValue()));\n                        } else if (child.getLocalName().equals(\"cc\")) {\n                            msg.addRecipient(Message.RecipientType.CC, new InternetAddress(child.getFirstChild().getNodeValue()));\n                        } else if (child.getLocalName().equals(\"bcc\")) {\n                            msg.addRecipient(Message.RecipientType.BCC, new InternetAddress(child.getFirstChild().getNodeValue()));\n                        } else if (child.getLocalName().equals(\"subject\")) {\n                            msg.setSubject(child.getFirstChild().getNodeValue());\n                        } else if (child.getLocalName().equals(\"header\")) {\n                            // Optional : You can also set your custom headers in the Email if you Want\n                            msg.addHeader(((Element) child).getAttribute(\"name\"), child.getFirstChild().getNodeValue());\n                        } else if (child.getLocalName().equals(\"message\")) {\n                            //If the message node, then parse the child text and xhtml nodes\n                            Node bodyPart = child.getFirstChild();\n                            while (bodyPart != null) {\n                                if (bodyPart.getNodeType() != Node.ELEMENT_NODE)\n                                    continue;\n\n                                Element elementBodyPart = (Element) bodyPart;\n                                String content = null;\n                                String contentType = null;\n\n                                if (bodyPart.getLocalName().equals(\"text\")) {\n                                    // Setting the Subject and Content Type\n                                    content = bodyPart.getFirstChild().getNodeValue();\n                                    contentType = \"plain\";\n                                } else if (bodyPart.getLocalName().equals(\"xhtml\")) {\n                                    //Convert everything inside <xhtml><\/xhtml> to text\n                                    TransformerFactory transFactory = TransformerFactory.newInstance();\n                                    Transformer transformer = transFactory.newTransformer();\n                                    DOMSource source = new DOMSource(bodyPart.getFirstChild());\n                                    StringWriter strWriter = new StringWriter();\n                                    StreamResult result = new StreamResult(strWriter);\n                                    transformer.transform(source, result);\n\n                                    content = strWriter.toString();\n                                    contentType = \"html\";\n                                } else if (bodyPart.getLocalName().equals(\"generic\")) {\n                                    // Setting the Subject and Content Type\n                                    content = elementBodyPart.getFirstChild().getNodeValue();\n                                    contentType = elementBodyPart.getAttribute(\"type\");\n                                }\n\n                                // Now, time to store it\n                                if (content != null && contentType != null && contentType.length() > 0) {\n                                    String charset = elementBodyPart.getAttribute(\"charset\");\n                                    String encoding = elementBodyPart.getAttribute(\"encoding\");\n\n                                    if (body != null && multibody == null) {\n                                        multibody = new MimeMultipart(\"alternative\");\n                                        multibody.addBodyPart(body);\n                                    }\n\n                                    if (charset == null || charset.length() == 0) {\n                                        charset = \"UTF-8\";\n                                    }\n\n                                    if (encoding == null || encoding.length() == 0) {\n                                        encoding = \"quoted-printable\";\n                                    }\n\n                                    if (body == null) {\n                                        firstContent = content;\n                                        firstCharset = charset;\n                                        firstContentType = contentType;\n                                        firstEncoding = encoding;\n                                    }\n                                    body = new MimeBodyPart();\n                                    body.setText(content, charset, contentType);\n                                    if (encoding != null) {\n                                        body.setHeader(\"Content-Transfer-Encoding\", encoding);\n                                    }\n                                    if (multibody != null)\n                                        multibody.addBodyPart(body);\n                                }\n\n                                //next body part\n                                bodyPart = bodyPart.getNextSibling();\n                            }\n\n                        } else if (child.getLocalName().equals(\"attachment\")) {\n                            Element attachment = (Element) child;\n                            MimeBodyPart part;\n                            // if mimetype indicates a binary resource, assume the content is base64 encoded\n                            if (MimeTable.getInstance().isTextContent(attachment.getAttribute(\"mimetype\"))) {\n                                part = new MimeBodyPart();\n                            } else {\n                                part = new PreencodedMimeBodyPart(\"base64\");\n                            }\n\n                            StringBuilder content = new StringBuilder();\n                            Node attachChild = attachment.getFirstChild();\n                            while (attachChild != null) {\n                                if (attachChild.getNodeType() == Node.ELEMENT_NODE) {\n                                    TransformerFactory transFactory = TransformerFactory.newInstance();\n                                    Transformer transformer = transFactory.newTransformer();\n                                    DOMSource source = new DOMSource(attachChild);\n                                    StringWriter strWriter = new StringWriter();\n                                    StreamResult result = new StreamResult(strWriter);\n                                    transformer.transform(source, result);\n\n                                    content.append(strWriter.toString());\n                                } else {\n                                    content.append(attachChild.getNodeValue());\n                                }\n                                attachChild = attachChild.getNextSibling();\n                            }\n                            part.setDataHandler(new DataHandler(new ByteArrayDataSource(content.toString(), attachment.getAttribute(\"mimetype\"))));\n                            part.setFileName(attachment.getAttribute(\"filename\"));\n//                            part.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n                            attachments.add(part);\n                        }\n                    }\n\n                    //next node\n                    child = child.getNextSibling();\n\n                }\n                // Lost from\n                if (!fromWasSet)\n                    msg.setFrom();\n\n                // Preparing content and attachments\n                if (attachments.size() > 0) {\n                    if (multibody == null) {\n                        multibody = new MimeMultipart(\"mixed\");\n                        if (body != null) {\n                            multibody.addBodyPart(body);\n                        }\n                    } else {\n                        MimeMultipart container = new MimeMultipart(\"mixed\");\n                        MimeBodyPart containerBody = new MimeBodyPart();\n                        containerBody.setContent(multibody);\n                        container.addBodyPart(containerBody);\n                        multibody = container;\n                    }\n                    for (MimeBodyPart part : attachments) {\n                        multibody.addBodyPart(part);\n                    }\n                }\n\n                // And now setting-up content\n                if (multibody != null) {\n                    msg.setContent(multibody);\n                } else if (body != null) {\n                    msg.setText(firstContent, firstCharset, firstContentType);\n                    if (firstEncoding != null) {\n                        msg.setHeader(\"Content-Transfer-Encoding\", firstEncoding);\n                    }\n                }\n\n                msg.saveChanges();\n                mails.add(msg);\n            }\n        }\n\n        return mails;\n    }","id":22879,"modified_method":"/**\n     * Constructs a mail Object from an XML representation of an email\n     *\n     * The XML email Representation is expected to look something like this\n     *\n     * <mail>\n     * \t<from><\/from>\n     * \t<reply-to><\/reply-to>\n     * \t<to><\/to>\n     * \t<cc><\/cc>\n     * \t<bcc><\/bcc>\n     * \t<subject><\/subject>\n     * \t<message>\n     * \t\t<text charset=\"\" encoding=\"\"><\/text>\n     * \t\t<xhtml charset=\"\" encoding=\"\"><\/xhtml>\n     * \t\t<generic charset=\"\" type=\"\" encoding=\"\"><\/generic>\n     * \t<\/message>\n     * \t<attachment mimetype=\"\" filename=\"\"><\/attachment>\n     * <\/mail>\n     *\n     * @param mailElements\tThe XML mail Node\n     * @return\t\tA mail Object representing the XML mail Node\n     */\n    private List<Message> parseMessageElement(Session session, List<Element> mailElements)\n            throws IOException, MessagingException, TransformerException {\n        List<Message> mails = new ArrayList<>();\n\n        for (Element mailElement : mailElements) {\n            //Make sure that message has a Mail node\n            if (mailElement.getLocalName().equals(\"mail\")) {\n                //New message Object\n                // create a message\n                MimeMessage msg = new MimeMessage(session);\n\n                ArrayList<InternetAddress> replyTo = new ArrayList<>();\n                boolean fromWasSet = false;\n                MimeBodyPart body = null;\n                Multipart multibody = null;\n                ArrayList<MimeBodyPart> attachments = new ArrayList<>();\n                String firstContent = null;\n                String firstContentType = null;\n                String firstCharset = null;\n                String firstEncoding = null;\n\n                //Get the First Child\n                Node child = mailElement.getFirstChild();\n                while (child != null) {\n                    //Parse each of the child nodes\n                    if (child.getNodeType() == Node.ELEMENT_NODE && child.hasChildNodes()) {\n                        switch (child.getLocalName()) {\n                            case \"from\":\n                                // set the from and to address\n                                InternetAddress[] addressFrom = {new InternetAddress(child.getFirstChild().getNodeValue())};\n                                msg.addFrom(addressFrom);\n                                fromWasSet = true;\n                                break;\n                            case \"reply-to\":\n                                // As we can only set the reply-to, not add them, let's keep\n                                // all of them in a list\n                                replyTo.add(new InternetAddress(child.getFirstChild().getNodeValue()));\n                                msg.setReplyTo(replyTo.toArray(new InternetAddress[0]));\n                                break;\n                            case \"to\":\n                                msg.addRecipient(Message.RecipientType.TO, new InternetAddress(child.getFirstChild().getNodeValue()));\n                                break;\n                            case \"cc\":\n                                msg.addRecipient(Message.RecipientType.CC, new InternetAddress(child.getFirstChild().getNodeValue()));\n                                break;\n                            case \"bcc\":\n                                msg.addRecipient(Message.RecipientType.BCC, new InternetAddress(child.getFirstChild().getNodeValue()));\n                                break;\n                            case \"subject\":\n                                msg.setSubject(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"header\":\n                                // Optional : You can also set your custom headers in the Email if you Want\n                                msg.addHeader(((Element) child).getAttribute(\"name\"), child.getFirstChild().getNodeValue());\n                                break;\n                            case \"message\":\n                                //If the message node, then parse the child text and xhtml nodes\n                                Node bodyPart = child.getFirstChild();\n                                while (bodyPart != null) {\n                                    if (bodyPart.getNodeType() != Node.ELEMENT_NODE)\n                                        continue;\n                                    \n                                    Element elementBodyPart = (Element) bodyPart;\n                                    String content = null;\n                                    String contentType = null;\n                                    \n                                    if (bodyPart.getLocalName().equals(\"text\")) {\n                                        // Setting the Subject and Content Type\n                                        content = bodyPart.getFirstChild().getNodeValue();\n                                        contentType = \"plain\";\n                                    } else if (bodyPart.getLocalName().equals(\"xhtml\")) {\n                                        //Convert everything inside <xhtml><\/xhtml> to text\n                                        TransformerFactory transFactory = TransformerFactory.newInstance();\n                                        Transformer transformer = transFactory.newTransformer();\n                                        DOMSource source = new DOMSource(bodyPart.getFirstChild());\n                                        StringWriter strWriter = new StringWriter();\n                                        StreamResult result = new StreamResult(strWriter);\n                                        transformer.transform(source, result);\n                                        \n                                        content = strWriter.toString();\n                                        contentType = \"html\";\n                                    } else if (bodyPart.getLocalName().equals(\"generic\")) {\n                                        // Setting the Subject and Content Type\n                                        content = elementBodyPart.getFirstChild().getNodeValue();\n                                        contentType = elementBodyPart.getAttribute(\"type\");\n                                    }\n                                    \n                                    // Now, time to store it\n                                    if (content != null && contentType != null && contentType.length() > 0) {\n                                        String charset = elementBodyPart.getAttribute(\"charset\");\n                                        String encoding = elementBodyPart.getAttribute(\"encoding\");\n                                        \n                                        if (body != null && multibody == null) {\n                                            multibody = new MimeMultipart(\"alternative\");\n                                            multibody.addBodyPart(body);\n                                        }\n                                        \n                                        if (charset == null || charset.length() == 0) {\n                                            charset = \"UTF-8\";\n                                        }\n                                        \n                                        if (encoding == null || encoding.length() == 0) {\n                                            encoding = \"quoted-printable\";\n                                        }\n                                        \n                                        if (body == null) {\n                                            firstContent = content;\n                                            firstCharset = charset;\n                                            firstContentType = contentType;\n                                            firstEncoding = encoding;\n                                        }\n                                        body = new MimeBodyPart();\n                                        body.setText(content, charset, contentType);\n                                        if (encoding != null) {\n                                            body.setHeader(\"Content-Transfer-Encoding\", encoding);\n                                        }\n                                        if (multibody != null)\n                                            multibody.addBodyPart(body);\n                                    }\n                                    \n                                    //next body part\n                                    bodyPart = bodyPart.getNextSibling();\n                                }   break;\n                            case \"attachment\":\n                                Element attachment = (Element) child;\n                                MimeBodyPart part;\n                                // if mimetype indicates a binary resource, assume the content is base64 encoded\n                                if (MimeTable.getInstance().isTextContent(attachment.getAttribute(\"mimetype\"))) {\n                                    part = new MimeBodyPart();\n                                } else {\n                                    part = new PreencodedMimeBodyPart(\"base64\");\n                                }   StringBuilder content = new StringBuilder();\n                            Node attachChild = attachment.getFirstChild();\n                                while (attachChild != null) {\n                                    if (attachChild.getNodeType() == Node.ELEMENT_NODE) {\n                                        TransformerFactory transFactory = TransformerFactory.newInstance();\n                                        Transformer transformer = transFactory.newTransformer();\n                                        DOMSource source = new DOMSource(attachChild);\n                                        StringWriter strWriter = new StringWriter();\n                                        StreamResult result = new StreamResult(strWriter);\n                                        transformer.transform(source, result);\n                                        \n                                        content.append(strWriter.toString());\n                                    } else {\n                                        content.append(attachChild.getNodeValue());\n                                    }\n                                    attachChild = attachChild.getNextSibling();\n                                }   part.setDataHandler(new DataHandler(new ByteArrayDataSource(content.toString(), attachment.getAttribute(\"mimetype\"))));\n                            part.setFileName(attachment.getAttribute(\"filename\"));\n//                            part.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n                                attachments.add(part);\n                                break;\n                        }\n                    }\n\n                    //next node\n                    child = child.getNextSibling();\n\n                }\n                // Lost from\n                if (!fromWasSet)\n                    msg.setFrom();\n\n                // Preparing content and attachments\n                if (attachments.size() > 0) {\n                    if (multibody == null) {\n                        multibody = new MimeMultipart(\"mixed\");\n                        if (body != null) {\n                            multibody.addBodyPart(body);\n                        }\n                    } else {\n                        MimeMultipart container = new MimeMultipart(\"mixed\");\n                        MimeBodyPart containerBody = new MimeBodyPart();\n                        containerBody.setContent(multibody);\n                        container.addBodyPart(containerBody);\n                        multibody = container;\n                    }\n                    for (MimeBodyPart part : attachments) {\n                        multibody.addBodyPart(part);\n                    }\n                }\n\n                // And now setting-up content\n                if (multibody != null) {\n                    msg.setContent(multibody);\n                } else if (body != null) {\n                    msg.setText(firstContent, firstCharset, firstContentType);\n                    if (firstEncoding != null) {\n                        msg.setHeader(\"Content-Transfer-Encoding\", firstEncoding);\n                    }\n                }\n\n                msg.saveChanges();\n                mails.add(msg);\n            }\n        }\n\n        return mails;\n    }","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Writes an email payload (Headers + Body) from a mail object\n     *\n     * @param smtpOut\t\tA PrintWriter to receive the email\n     * @param mail\t\tA mail object representing the email to write out\n     */\n    private void writeMessage(PrintWriter out, Mail aMail) throws IOException\n    {\n        String Version = eXistVersion();\t\t\t\t//Version of eXist\n        String MultipartBoundary = \"eXist.multipart.\" + Version;\t//Multipart Boundary\n\n        //write the message headers\n\n        out.println(\"From: \" + encode64Address(aMail.getFrom()));\n\n        if(aMail.getReplyTo() != null)\n        {\n            out.println(\"Reply-To: \" + encode64Address(aMail.getReplyTo()));\n        }\n\n        for(int x = 0; x < aMail.countTo(); x++)\n        {\n            out.println(\"To: \" + encode64Address(aMail.getTo(x)));\n        }\n\n        for(int x = 0; x < aMail.countCC(); x++)\n        {\n            out.println(\"CC: \" + encode64Address(aMail.getCC(x)));\n        }\n        \n        for(int x = 0; x < aMail.countBCC(); x++)\n        {\n            out.println(\"BCC: \" + encode64Address(aMail.getBCC(x)));\n        }\n        \n        out.println(\"Date: \" + getDateRFC822());\n        out.println(\"Subject: \" + encode64(aMail.getSubject()));\n        out.println(\"X-Mailer: eXist \" + Version + \" mail:send-email()\");\n        out.println(\"MIME-Version: 1.0\");\n\n\n        boolean multipartAlternative = false;\n        String multipartBoundary = null;\n\n        if(aMail.attachmentIterator().hasNext())\n        {\n            // we have an attachment as well as text and/or html so we need a multipart/mixed message\n            multipartBoundary =  MultipartBoundary;\n        }\n        else if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\"))\n        {\n            // we have text and html so we need a multipart/alternative message and no attachment\n            multipartAlternative = true;\n            multipartBoundary = MultipartBoundary + \"_alt\";\n        }\n        else\n        {\n            // we have either text or html and no attachment this message is not multipart\n        }\n\n        //content type\n        if(multipartBoundary != null)\n        {\n            //multipart message\n\n            out.println(\"Content-Type: \" + (multipartAlternative ? \"multipart/alternative\" : \"multipart/mixed\") + \"; boundary=\\\"\" + multipartBoundary + \"\\\";\");\n\n            //Mime warning\n            out.println();\n            out.println(\"Error your mail client is not MIME Compatible\");\n\n            out.println(\"--\" + multipartBoundary);\n        }\n\n        // TODO - need to put out a multipart/mixed boundary here when HTML, text and attachment present\n        if(!aMail.getText().toString().equals(\"\") && !aMail.getXHTML().toString().equals(\"\") && aMail.attachmentIterator().hasNext())\n        {\n            out.println(\"Content-Type: multipart/alternative; boundary=\\\"\" + MultipartBoundary + \"_alt\\\";\");\n            out.println(\"--\" + MultipartBoundary + \"_alt\");\n        }\n\n        //text email\n        if(!aMail.getText().toString().equals(\"\"))\n        {\n            out.println(\"Content-Type: text/plain; charset=\" + charset);\n            out.println(\"Content-Transfer-Encoding: 8bit\");\n\n            //now send the txt message\n            out.println();\n            out.println(aMail.getText());\n\n            if(multipartBoundary != null)\n            {\n                if(!aMail.getXHTML().toString().equals(\"\") || aMail.attachmentIterator().hasNext())\n                {\n                    if(!aMail.getText().toString().equals(\"\") && !aMail.getXHTML().toString().equals(\"\") && aMail.attachmentIterator().hasNext())\n                    {\n                        out.println(\"--\" + MultipartBoundary + \"_alt\");\n                    }\n                    else\n                    {\n                        out.println(\"--\" + multipartBoundary);\n                    }\n                }\n                else\n                {\n                    if(!aMail.getText().toString().equals(\"\") && !aMail.getXHTML().toString().equals(\"\") && aMail.attachmentIterator().hasNext())\n                    {\n                        out.println(\"--\" + MultipartBoundary + \"_alt--\");\n                    }\n                    else\n                    {\n                        out.println(\"--\" + multipartBoundary + \"--\");\n                    }\n                }\n            }\n        }\n\n        //HTML email\n        if(!aMail.getXHTML().toString().equals(\"\"))\n        {\n                out.println(\"Content-Type: text/html; charset=\" + charset);\n                out.println(\"Content-Transfer-Encoding: 8bit\");\n\n                //now send the html message\n                out.println();\n                out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\");\n                out.println(aMail.getXHTML());\n\n                if(multipartBoundary != null)\n                {\n                    if(aMail.attachmentIterator().hasNext())\n                    {\n                        if(!aMail.getText().toString().equals(\"\") && !aMail.getXHTML().toString().equals(\"\") && aMail.attachmentIterator().hasNext())\n                        {\n                            out.println(\"--\" + MultipartBoundary + \"_alt--\");\n                            out.println(\"--\" + multipartBoundary);\n                        }\n                        else\n                        {\n                            out.println(\"--\" + multipartBoundary);\n                        }\n                    }\n                    else\n                    {\n                        if(!aMail.getText().toString().equals(\"\") && !aMail.getXHTML().toString().equals(\"\") && aMail.attachmentIterator().hasNext())\n                        {\n                            out.println(\"--\" + MultipartBoundary + \"_alt--\");\n                        }\n                        else\n                        {\n                            out.println(\"--\" + multipartBoundary + \"--\");\n                        }\n                    }\n                }\n        }\n\n        //attachments\n        if(aMail.attachmentIterator().hasNext())\n        {\n            for(Iterator<MailAttachment> itAttachment = aMail.attachmentIterator(); itAttachment.hasNext(); )\n            {\n                MailAttachment ma = itAttachment.next();\n\n                out.println(\"Content-Type: \" + ma.getMimeType() + \"; name=\\\"\" + ma.getFilename() + \"\\\"\");\n                out.println(\"Content-Transfer-Encoding: base64\");\n                out.println(\"Content-Description: \" + ma.getFilename());\n                out.println(\"Content-Disposition: attachment; filename=\\\"\" + ma.getFilename() + \"\\\"\");\n                out.println();\n                \n                \n                //write out the attachment encoded data in fixed width lines\n                final char buf[] = new char[MIME_BASE64_MAX_LINE_LENGTH];\n                int read = -1;\n                final Reader attachmentDataReader = new StringReader(ma.getData());\n                while((read = attachmentDataReader.read(buf, 0, MIME_BASE64_MAX_LINE_LENGTH)) > -1) {\n                    out.println(String.valueOf(buf, 0, read));\n                }\n\n                if(itAttachment.hasNext())\n                {\n                    out.println(\"--\" + multipartBoundary);\n                }\n            }\n\n            //Emd multipart message\n            out.println(\"--\" + multipartBoundary + \"--\");\n        }\n\n        //end the message, <cr><lf>.<cr><lf>\n        out.println();\n        out.println(\".\");\n        out.flush();\n    }","id":22880,"modified_method":"/**\n     * Writes an email payload (Headers + Body) from a mail object\n     *\n     * @param smtpOut\t\tA PrintWriter to receive the email\n     * @param mail\t\tA mail object representing the email to write out\n     */\n    private void writeMessage(PrintWriter out, Mail aMail) throws IOException\n    {\n        String Version = eXistVersion();\t\t\t\t//Version of eXist\n        String MultipartBoundary = \"eXist.multipart.\" + Version;\t//Multipart Boundary\n\n        //write the message headers\n\n        out.println(\"From: \" + encode64Address(aMail.getFrom()));\n\n        if(aMail.getReplyTo() != null)\n        {\n            out.println(\"Reply-To: \" + encode64Address(aMail.getReplyTo()));\n        }\n\n        for(int x = 0; x < aMail.countTo(); x++)\n        {\n            out.println(\"To: \" + encode64Address(aMail.getTo(x)));\n        }\n\n        for(int x = 0; x < aMail.countCC(); x++)\n        {\n            out.println(\"CC: \" + encode64Address(aMail.getCC(x)));\n        }\n        \n        for(int x = 0; x < aMail.countBCC(); x++)\n        {\n            out.println(\"BCC: \" + encode64Address(aMail.getBCC(x)));\n        }\n        \n        out.println(\"Date: \" + getDateRFC822());\n        out.println(\"Subject: \" + encode64(aMail.getSubject()));\n        out.println(\"X-Mailer: eXist \" + Version + \" mail:send-email()\");\n        out.println(\"MIME-Version: 1.0\");\n\n\n        boolean multipartAlternative = false;\n        String multipartBoundary = null;\n\n        if(aMail.attachmentIterator().hasNext())\n        {\n            // we have an attachment as well as text and/or html so we need a multipart/mixed message\n            multipartBoundary =  MultipartBoundary;\n        }\n        else if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\"))\n        {\n            // we have text and html so we need a multipart/alternative message and no attachment\n            multipartAlternative = true;\n            multipartBoundary = MultipartBoundary + \"_alt\";\n        }\n        else\n        {\n            // we have either text or html and no attachment this message is not multipart\n        }\n\n        //content type\n        if(multipartBoundary != null)\n        {\n            //multipart message\n\n            out.println(\"Content-Type: \" + (multipartAlternative ? \"multipart/alternative\" : \"multipart/mixed\") + \"; boundary=\\\"\" + multipartBoundary + \"\\\";\");\n\n            //Mime warning\n            out.println();\n            out.println(\"Error your mail client is not MIME Compatible\");\n\n            out.println(\"--\" + multipartBoundary);\n        }\n\n        // TODO - need to put out a multipart/mixed boundary here when HTML, text and attachment present\n        if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\") && aMail.attachmentIterator().hasNext())\n        {\n            out.println(\"Content-Type: multipart/alternative; boundary=\\\"\" + MultipartBoundary + \"_alt\\\";\");\n            out.println(\"--\" + MultipartBoundary + \"_alt\");\n        }\n\n        //text email\n        if(!aMail.getText().equals(\"\"))\n        {\n            out.println(\"Content-Type: text/plain; charset=\" + charset);\n            out.println(\"Content-Transfer-Encoding: 8bit\");\n\n            //now send the txt message\n            out.println();\n            out.println(aMail.getText());\n\n            if(multipartBoundary != null)\n            {\n                if(!aMail.getXHTML().equals(\"\") || aMail.attachmentIterator().hasNext())\n                {\n                    if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\") && aMail.attachmentIterator().hasNext())\n                    {\n                        out.println(\"--\" + MultipartBoundary + \"_alt\");\n                    }\n                    else\n                    {\n                        out.println(\"--\" + multipartBoundary);\n                    }\n                }\n                else\n                {\n                    if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\") && aMail.attachmentIterator().hasNext())\n                    {\n                        out.println(\"--\" + MultipartBoundary + \"_alt--\");\n                    }\n                    else\n                    {\n                        out.println(\"--\" + multipartBoundary + \"--\");\n                    }\n                }\n            }\n        }\n\n        //HTML email\n        if(!aMail.getXHTML().equals(\"\"))\n        {\n                out.println(\"Content-Type: text/html; charset=\" + charset);\n                out.println(\"Content-Transfer-Encoding: 8bit\");\n\n                //now send the html message\n                out.println();\n                out.println(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\");\n                out.println(aMail.getXHTML());\n\n                if(multipartBoundary != null)\n                {\n                    if(aMail.attachmentIterator().hasNext())\n                    {\n                        if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\") && aMail.attachmentIterator().hasNext())\n                        {\n                            out.println(\"--\" + MultipartBoundary + \"_alt--\");\n                            out.println(\"--\" + multipartBoundary);\n                        }\n                        else\n                        {\n                            out.println(\"--\" + multipartBoundary);\n                        }\n                    }\n                    else\n                    {\n                        if(!aMail.getText().equals(\"\") && !aMail.getXHTML().equals(\"\") && aMail.attachmentIterator().hasNext())\n                        {\n                            out.println(\"--\" + MultipartBoundary + \"_alt--\");\n                        }\n                        else\n                        {\n                            out.println(\"--\" + multipartBoundary + \"--\");\n                        }\n                    }\n                }\n        }\n\n        //attachments\n        if(aMail.attachmentIterator().hasNext())\n        {\n            for(Iterator<MailAttachment> itAttachment = aMail.attachmentIterator(); itAttachment.hasNext(); )\n            {\n                MailAttachment ma = itAttachment.next();\n\n                out.println(\"Content-Type: \" + ma.getMimeType() + \"; name=\\\"\" + ma.getFilename() + \"\\\"\");\n                out.println(\"Content-Transfer-Encoding: base64\");\n                out.println(\"Content-Description: \" + ma.getFilename());\n                out.println(\"Content-Disposition: attachment; filename=\\\"\" + ma.getFilename() + \"\\\"\");\n                out.println();\n                \n                \n                //write out the attachment encoded data in fixed width lines\n                final char buf[] = new char[MIME_BASE64_MAX_LINE_LENGTH];\n                int read = -1;\n                final Reader attachmentDataReader = new StringReader(ma.getData());\n                while((read = attachmentDataReader.read(buf, 0, MIME_BASE64_MAX_LINE_LENGTH)) > -1) {\n                    out.println(String.valueOf(buf, 0, read));\n                }\n\n                if(itAttachment.hasNext())\n                {\n                    out.println(\"--\" + multipartBoundary);\n                }\n            }\n\n            //Emd multipart message\n            out.println(\"--\" + multipartBoundary + \"--\");\n        }\n\n        //end the message, <cr><lf>.<cr><lf>\n        out.println();\n        out.println(\".\");\n        out.flush();\n    }","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"private boolean writeSMTPMessage(Mail mail, PrintWriter smtpOut, BufferedReader smtpIn)\n    {\n        try\n        {\n            String smtpResult = \"\";\n\n            //Send \"MAIL FROM:\"\n            //Check format of from address does it include a name as well as the email address?\n            if(mail.getFrom().indexOf(\"<\") != -1)\n            {\n                //yes, just send the email address\n                smtpOut.println(\"MAIL FROM:<\" + mail.getFrom().substring(mail.getFrom().indexOf(\"<\") + 1, mail.getFrom().indexOf(\">\")) + \">\");\n            }\n            else\n            {\n                //no, doesnt include a name so send the email address\n                smtpOut.println(\"MAIL FROM:<\" + mail.getFrom() + \">\");\n            }\n            smtpOut.flush();\n\n            //Get \"MAIL FROM:\" response\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).toString().equals(\"250\"))\n            {\n                LOG.error(\"Error - SMTP MAIL FROM failed: \" + smtpResult);\n                return false;\n            }\n\n            //RCPT TO should be issued for each to, cc and bcc recipient\n            List<String> allrecipients = new ArrayList<String>();\n            allrecipients.addAll(mail.getTo());\n            allrecipients.addAll(mail.getCC());\n            allrecipients.addAll(mail.getBCC());\n\n            for(int x = 0; x < allrecipients.size(); x++)\n            {\n                //Send \"RCPT TO:\"\n                //Check format of to address does it include a name as well as the email address?\n                if(((String)allrecipients.get(x)).indexOf(\"<\") != -1)\n                {\n                    //yes, just send the email address\n                    smtpOut.println(\"RCPT TO:<\" + ((String)allrecipients.get(x)).substring(((String)allrecipients.get(x)).indexOf(\"<\") + 1, ((String)allrecipients.get(x)).indexOf(\">\")) + \">\");\n                }\n                else\n                {\n                    smtpOut.println(\"RCPT TO:<\" + ((String)allrecipients.get(x)) + \">\");\n                }\n                smtpOut.flush();\n\n                //Get \"RCPT TO:\" response\n                smtpResult = smtpIn.readLine();\n                if(!smtpResult.substring(0, 3).toString().equals(\"250\"))\n                {\n                    LOG.error(\"Error - SMTP RCPT TO failed: \" + smtpResult);\n                }\n            }\n\n\n            //SEND \"DATA\"\n            smtpOut.println(\"DATA\");\n            smtpOut.flush();\n\n            //Get \"DATA\" response, should be \"354 blah blah\"\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).toString().equals(\"354\"))\n            {\n                LOG.error(\"Error - SMTP DATA failed: \" + smtpResult);\n                return false;\n            }\n\n            //Send the Message\n            writeMessage(smtpOut, mail);\n\n            //Get end message response, should be \"250 blah blah\"\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).toString().equals(\"250\"))\n            {\n                LOG.error(\"Error - Message not accepted: \" + smtpResult);\n                return false;\n            }\n        }\n        catch(IOException ioe)\n        {\n            LOG.error(ioe.getMessage(), ioe);\n            return false;\n        }\n\n        return true;\n    }","id":22881,"modified_method":"private boolean writeSMTPMessage(Mail mail, PrintWriter smtpOut, BufferedReader smtpIn)\n    {\n        try\n        {\n            String smtpResult = \"\";\n\n            //Send \"MAIL FROM:\"\n            //Check format of from address does it include a name as well as the email address?\n            if(mail.getFrom().indexOf(\"<\") != -1)\n            {\n                //yes, just send the email address\n                smtpOut.println(\"MAIL FROM:<\" + mail.getFrom().substring(mail.getFrom().indexOf(\"<\") + 1, mail.getFrom().indexOf(\">\")) + \">\");\n            }\n            else\n            {\n                //no, doesnt include a name so send the email address\n                smtpOut.println(\"MAIL FROM:<\" + mail.getFrom() + \">\");\n            }\n            smtpOut.flush();\n\n            //Get \"MAIL FROM:\" response\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).equals(\"250\"))\n            {\n                LOG.error(\"Error - SMTP MAIL FROM failed: \" + smtpResult);\n                return false;\n            }\n\n            //RCPT TO should be issued for each to, cc and bcc recipient\n            List<String> allrecipients = new ArrayList<>();\n            allrecipients.addAll(mail.getTo());\n            allrecipients.addAll(mail.getCC());\n            allrecipients.addAll(mail.getBCC());\n\n            for (String recipient : allrecipients) {\n                //Send \"RCPT TO:\"\n                //Check format of to address does it include a name as well as the email address?\n                if (((String) recipient).contains(\"<\")) {\n                    //yes, just send the email address\n                    smtpOut.println(\"RCPT TO:<\" + ((String) recipient).substring(((String) recipient).indexOf(\"<\") + 1, ((String) recipient).indexOf(\">\")) + \">\");\n                } else {\n                    smtpOut.println(\"RCPT TO:<\" + ((String) recipient) + \">\");\n                }\n                smtpOut.flush();\n                //Get \"RCPT TO:\" response\n                smtpResult = smtpIn.readLine();\n                if(!smtpResult.substring(0, 3).equals(\"250\"))\n                {\n                    LOG.error(\"Error - SMTP RCPT TO failed: \" + smtpResult);\n                }\n            }\n\n\n            //SEND \"DATA\"\n            smtpOut.println(\"DATA\");\n            smtpOut.flush();\n\n            //Get \"DATA\" response, should be \"354 blah blah\"\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).equals(\"354\"))\n            {\n                LOG.error(\"Error - SMTP DATA failed: \" + smtpResult);\n                return false;\n            }\n\n            //Send the Message\n            writeMessage(smtpOut, mail);\n\n            //Get end message response, should be \"250 blah blah\"\n            smtpResult = smtpIn.readLine();\n            if(!smtpResult.substring(0, 3).equals(\"250\"))\n            {\n                LOG.error(\"Error - Message not accepted: \" + smtpResult);\n                return false;\n            }\n        }\n        catch(IOException ioe)\n        {\n            LOG.error(ioe.getMessage(), ioe);\n            return false;\n        }\n\n        return true;\n    }","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Constructs a mail Object from an XML representation of an email\n     *\n     * The XML email Representation is expected to look something like this\n     *\n     * <mail>\n     * \t<from><\/from>\n     * \t<reply-to><\/reply-to>\n     * \t<to><\/to>\n     * \t<cc><\/cc>\n     * \t<bcc><\/bcc>\n     * \t<subject><\/subject>\n     * \t<message>\n     * \t\t<text><\/text>\n     * \t\t<xhtml><\/xhtml>\n     * \t<\/message>\n     * <\/mail>\n     *\n     * @param mailElements\tThe XML mail Node\n     * @return\t\tA mail Object representing the XML mail Node\n     */\n    private List<Mail> parseMailElement(List<Element> mailElements) throws TransformerException\n    {\n        List<Mail> mails = new ArrayList<Mail>();\n\n        for(Element mailElement : mailElements)\n        {\n            //Make sure that message has a Mail node\n            if(mailElement.getLocalName().equals(\"mail\"))\n            {\n                //New mail Object\n                Mail mail = new Mail();\n\n                //Get the First Child\n                Node child = mailElement.getFirstChild();\n                while(child != null)\n                {\n                    //Parse each of the child nodes\n                    if(child.getNodeType() == Node.ELEMENT_NODE && child.hasChildNodes())\n                    {\n                        if(child.getLocalName().equals(\"from\"))\n                        {\n                                mail.setFrom(child.getFirstChild().getNodeValue());\n                        }\n                        if(child.getLocalName().equals(\"reply-to\"))\n                        {\n                                mail.setReplyTo(child.getFirstChild().getNodeValue());\n                        }\n                        else if(child.getLocalName().equals(\"to\"))\n                        {\n                                mail.addTo(child.getFirstChild().getNodeValue());\n                        }\n                        else if(child.getLocalName().equals(\"cc\"))\n                        {\n                                mail.addCC(child.getFirstChild().getNodeValue());\n                        }\n                        else if(child.getLocalName().equals(\"bcc\"))\n                        {\n                                mail.addBCC(child.getFirstChild().getNodeValue());\n                        }\n                        else if(child.getLocalName().equals(\"subject\"))\n                        {\n                                mail.setSubject(child.getFirstChild().getNodeValue());\n                        }\n                        else if(child.getLocalName().equals(\"message\"))\n                        {\n                            //If the message node, then parse the child text and xhtml nodes\n                            Node bodyPart = child.getFirstChild();\n                            while(bodyPart != null)\n                            {\n                                if(bodyPart.getLocalName().equals(\"text\"))\n                                {\n                                        mail.setText(bodyPart.getFirstChild().getNodeValue());\n                                }\n                                else if(bodyPart.getLocalName().equals(\"xhtml\"))\n                                {\n                                    //Convert everything inside <xhtml><\/xhtml> to text\n                                    TransformerFactory transFactory = TransformerFactory.newInstance();\n                                    Transformer transformer = transFactory.newTransformer();\n                                    DOMSource source = new DOMSource(bodyPart.getFirstChild());\n                                    StringWriter strWriter = new StringWriter();\n                                    StreamResult result = new StreamResult(strWriter);\n                                    transformer.transform(source, result);\n\n                                    mail.setXHTML(strWriter.toString());\n                                }\n\n                                //next body part\n                                bodyPart = bodyPart.getNextSibling();\n                            }\n\n                        }\n                        else if(child.getLocalName().equals(\"attachment\"))\n                        {\n                            Element attachment = (Element)child;\n                            MailAttachment ma = new MailAttachment(attachment.getAttribute(\"filename\"), attachment.getAttribute(\"mimetype\"), attachment.getFirstChild().getNodeValue());\n                            mail.addAttachment(ma);\n                        }\n                    }\n\n                    //next node\n                    child = child.getNextSibling();\n\n                }\n                mails.add(mail);\n            }\n        }\n\n        return mails;\n    }","id":22882,"modified_method":"/**\n     * Constructs a mail Object from an XML representation of an email\n     *\n     * The XML email Representation is expected to look something like this\n     *\n     * <mail>\n     * \t<from><\/from>\n     * \t<reply-to><\/reply-to>\n     * \t<to><\/to>\n     * \t<cc><\/cc>\n     * \t<bcc><\/bcc>\n     * \t<subject><\/subject>\n     * \t<message>\n     * \t\t<text><\/text>\n     * \t\t<xhtml><\/xhtml>\n     * \t<\/message>\n     * <\/mail>\n     *\n     * @param mailElements\tThe XML mail Node\n     * @return\t\tA mail Object representing the XML mail Node\n     */\n    private List<Mail> parseMailElement(List<Element> mailElements) throws TransformerException\n    {\n        List<Mail> mails = new ArrayList<>();\n\n        for(Element mailElement : mailElements)\n        {\n            //Make sure that message has a Mail node\n            if(mailElement.getLocalName().equals(\"mail\"))\n            {\n                //New mail Object\n                Mail mail = new Mail();\n\n                //Get the First Child\n                Node child = mailElement.getFirstChild();\n                while(child != null)\n                {\n                    //Parse each of the child nodes\n                    if(child.getNodeType() == Node.ELEMENT_NODE && child.hasChildNodes())\n                    {\n                        switch (child.getLocalName()) {\n                            case \"from\":\n                                mail.setFrom(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"reply-to\":\n                                mail.setReplyTo(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"to\":\n                                mail.addTo(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"cc\":\n                                mail.addCC(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"bcc\":\n                                mail.addBCC(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"subject\":\n                                mail.setSubject(child.getFirstChild().getNodeValue());\n                                break;\n                            case \"message\":\n                                //If the message node, then parse the child text and xhtml nodes\n                                Node bodyPart = child.getFirstChild();\n                                while(bodyPart != null)\n                                {\n                                    if(bodyPart.getLocalName().equals(\"text\"))\n                                    {\n                                        mail.setText(bodyPart.getFirstChild().getNodeValue());\n                                    }\n                                    else if(bodyPart.getLocalName().equals(\"xhtml\"))\n                                    {\n                                        //Convert everything inside <xhtml><\/xhtml> to text\n                                        TransformerFactory transFactory = TransformerFactory.newInstance();\n                                        Transformer transformer = transFactory.newTransformer();\n                                        DOMSource source = new DOMSource(bodyPart.getFirstChild());\n                                        StringWriter strWriter = new StringWriter();\n                                        StreamResult result = new StreamResult(strWriter);\n                                        transformer.transform(source, result);\n                                        \n                                        mail.setXHTML(strWriter.toString());\n                                    }\n                                    \n                                    //next body part\n                                    bodyPart = bodyPart.getNextSibling();\n                                }   break;\n                            case \"attachment\":\n                                Element attachment = (Element)child;\n                                MailAttachment ma = new MailAttachment(attachment.getAttribute(\"filename\"), attachment.getAttribute(\"mimetype\"), attachment.getFirstChild().getNodeValue());\n                                mail.addAttachment(ma);\n                                break;\n                        }\n                    }\n\n                    //next node\n                    child = child.getNextSibling();\n\n                }\n                mails.add(mail);\n            }\n        }\n\n        return mails;\n    }","commit_id":"93e9e8f7cbc4426b3a9a79c0f5a20144b481325e","url":"https://github.com/eXist-db/exist"},{"original_method":"/******\n\t * Performs installation on a remote machine with a known IP.\n\t * \n\t * @param details the installation details.\n\t * @param timeout the timeout duration.\n\t * @param unit the timeout unit.\n\t * @throws InterruptedException .\n\t * @throws TimeoutException .\n\t * @throws InstallerException .\n\t */\n\tpublic void installOnMachineWithIP(final InstallationDetails details, final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, InterruptedException, InstallerException {\n\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tif (details.getLocator() == null) {\n\t\t\t// We are installing the lus now\n\t\t\tdetails.setLocator(details.getPrivateIp());\n\t\t}\n\n\t\tlogger.fine(\"Executing agentless installer with the following details:\\n\" + details.toString());\n\n\t\tfinal String targetHost = details.isConnectedToPrivateIp() ? details.getPrivateIp() : details.getPublicIp();\n\n\t\tpublishEvent(\"attempting_to_access_vm_with_ssh\", targetHost);\n\t\tint port = 0;\n\t\tswitch (details.getFileTransferMode()) {\n\t\tcase CIFS:\n\t\t\tport = CIFS_PORT;\n\t\t\tbreak;\n\t\tcase SCP:\n\t\t\tport = SSH_PORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new UnsupportedOperationException(\"File Transfer Mode: \" + details.getFileTransferMode()\n\t\t\t\t\t+ \" not supported\");\n\t\t}\n\n\t\tcheckConnection(targetHost, port, Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\n\t\t// upload bootstrap files\n\t\tuploadFilesToServer(details, end, targetHost);\n\n\t\t// launch the cloudify agent\n\t\tremoteExecuteAgentOnServer(details, end, targetHost);\n\n\t\tpublishEvent(\"access_vm_with_ssh_success\", details.getPublicIp());\n\n\t}","id":22883,"modified_method":"/******\n\t * Performs installation on a remote machine with a known IP.\n\t * \n\t * @param details the installation details.\n\t * @param timeout the timeout duration.\n\t * @param unit the timeout unit.\n\t * @throws InterruptedException .\n\t * @throws TimeoutException .\n\t * @throws InstallerException .\n\t */\n\tpublic void installOnMachineWithIP(final InstallationDetails details, final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, InterruptedException, InstallerException {\n\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tif (details.getLocator() == null) {\n\t\t\t// We are installing the lus now\n\t\t\tdetails.setLocator(details.getPrivateIp());\n\t\t}\n\n\t\tlogger.fine(\"Executing agentless installer with the following details:\\n\" + details.toString());\n\n\t\tfinal String targetHost = details.isConnectedToPrivateIp() ? details.getPrivateIp() : details.getPublicIp();\n\n\n\t\tint port = 0;\n\t\tswitch (details.getFileTransferMode()) {\n\t\tcase CIFS:\n\t\t\tport = CIFS_PORT;\n\t\t\tbreak;\n\t\tcase SCP:\n\t\t\tport = SSH_PORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new UnsupportedOperationException(\"File Transfer Mode: \" + details.getFileTransferMode()\n\t\t\t\t\t+ \" not supported\");\n\t\t}\n\t\t\n\t\tpublishEvent(\"attempting_to_access_vm\", targetHost);\t\t\n\t\tcheckConnection(targetHost, port, Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\n\t\t// upload bootstrap files\n\t\tpublishEvent(\"uploading_files_to_node\", targetHost);\n\t\tuploadFilesToServer(details, end, targetHost);\n\n\t\t// launch the cloudify agent\n\t\tpublishEvent(\"launching_agent_on_node\", targetHost);\n\t\tremoteExecuteAgentOnServer(details, end, targetHost);\n\n\t\tpublishEvent(\"install_completed_on_node\", targetHost);\n\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private String getScriptFileName(final InstallationDetails details) {\n\t\tfinal String scriptFileName;\n\n\t\tswitch (details.getRemoteExecutionMode()) {\n\t\tcase WINRM:\n\t\t\tscriptFileName = POWERSHELL_STARTUP_SCRIPT_NAME;\n\t\t\tbreak;\n\t\tcase SSH:\n\t\t\tscriptFileName = LINUX_STARTUP_SCRIPT_NAME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new UnsupportedOperationException(\"Remote Execution Mode: \" + details.getRemoteExecutionMode()\n\t\t\t\t\t+ \" not supported\");\n\t\t}\n\t\treturn scriptFileName;\n\t}","id":22884,"modified_method":"private String getScriptFileName(final InstallationDetails details) {\n\t\tfinal String scriptFileName;\n\n\t\tswitch (details.getRemoteExecutionMode()) {\n\t\tcase WINRM:\n\t\t\tscriptFileName = POWERSHELL_STARTUP_SCRIPT_NAME + \"\";\n\t\t\t// scriptFileName = \"bootstrap-management.ps1\";\n\t\t\tbreak;\n\t\tcase SSH:\n\t\t\tscriptFileName = LINUX_STARTUP_SCRIPT_NAME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new UnsupportedOperationException(\"Remote Execution Mode: \" + details.getRemoteExecutionMode()\n\t\t\t\t\t+ \" not supported\");\n\t\t}\n\t\treturn scriptFileName;\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void sshCommand(final String host, final String command, final String username, final String password,\n\t\t\tfinal String keyFile, final long timeout, final TimeUnit unit)\n\t\t\tthrows InstallerException, TimeoutException {\n\n\t\ttry {\n\t\t\tUtils.executeSSHCommand(host, command, username, password, keyFile, timeout, unit);\n\t\t} catch (final BuildException e) {\n\t\t\t// There really should be a better way to check that this is a\n\t\t\t// timeout\n\t\t\tif (e instanceof BuildTimeoutException) {\n\t\t\t\tfinal TimeoutException ex =\n\t\t\t\t\t\tnew TimeoutException(\"Command \" + command + \" failed to execute: \" + e.getMessage());\n\t\t\t\tex.initCause(e);\n\t\t\t\tthrow ex;\n\t\t\t} else if (e instanceof ExitStatusException) {\n\t\t\t\tfinal ExitStatusException ex = (ExitStatusException) e;\n\t\t\t\tfinal int ec = ex.getStatus();\n\t\t\t\tthrow new InstallerException(\"Command \" + command + \" failed with exit code: \" + ec, e);\n\t\t\t} else {\n\t\t\t\tthrow new InstallerException(\"Command \" + command + \" failed to execute.\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublishEvent(\"access_vm_with_ssh_success\", host);\n\n\t}","id":22885,"modified_method":"private void sshCommand(final String host, final String command, final String username, final String password,\n\t\t\tfinal String keyFile, final long timeout, final TimeUnit unit)\n\t\t\tthrows InstallerException, TimeoutException {\n\n\t\ttry {\n\t\t\tUtils.executeSSHCommand(host, command, username, password, keyFile, timeout, unit);\n\t\t} catch (final BuildException e) {\n\t\t\t// There really should be a better way to check that this is a\n\t\t\t// timeout\n\t\t\tif (e instanceof BuildTimeoutException) {\n\t\t\t\tfinal TimeoutException ex =\n\t\t\t\t\t\tnew TimeoutException(\"Command \" + command + \" failed to execute: \" + e.getMessage());\n\t\t\t\tex.initCause(e);\n\t\t\t\tthrow ex;\n\t\t\t} else if (e instanceof ExitStatusException) {\n\t\t\t\tfinal ExitStatusException ex = (ExitStatusException) e;\n\t\t\t\tfinal int ec = ex.getStatus();\n\t\t\t\tthrow new InstallerException(\"Command \" + command + \" failed with exit code: \" + ec, e);\n\t\t\t} else {\n\t\t\t\tthrow new InstallerException(\"Command \" + command + \" failed to execute.\", e);\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void checkPowershellInstalled()\n\t\t\tthrows IOException, InterruptedException, InstallerException {\n\t\tfinal ProcessBuilder pb = new ProcessBuilder(\"powershell.exe\", \"-?\");\n\t\tpb.redirectErrorStream(true);\n\n\t\tfinal Process p = pb.start();\n\n\t\tfinal String output = readProcessOutput(p);\n\n\t\tfinal int retval = p.waitFor();\n\t\tif (retval != 0) {\n\t\t\tthrow new InstallerException(\"powershell.exe is not on installed, or is not available on the system path. \"\n\t\t\t\t\t+ \"Powershell is required on both client and server for Cloudify to work on Windows. \"\n\t\t\t\t\t+ \"Execution result: \" + output);\n\t\t}\n\t}","id":22886,"modified_method":"private void checkPowershellInstalled()\n\t\t\tthrows IOException, InterruptedException, InstallerException {\n\t\tif (powerShellInstalled != null) {\n\t\t\tif (powerShellInstalled.booleanValue()) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthrow new InstallerException(\n\t\t\t\t\t\t\"powershell.exe is not on installed, or is not available on the system path. \"\n\t\t\t\t\t\t\t\t+ \"Powershell is required on both client and server for Cloudify to work on Windows. \");\n\t\t\t}\n\t\t}\n\n\t\tlogger.fine(\"Checking if powershell is installed using: \" + Arrays.toString(POWERSHELL_INSTALLED_COMMAND));\n\t\tfinal ProcessBuilder pb = new ProcessBuilder(Arrays.asList(POWERSHELL_INSTALLED_COMMAND));\n\t\tpb.redirectErrorStream(true);\n\n\t\tfinal Process p = pb.start();\n\n\t\tfinal String output = readProcessOutput(p);\n\n\t\tlogger.fine(\"Finished reading output\");\n\t\tfinal int retval = p.waitFor();\n\t\tlogger.fine(\"Powershell installed command exit value: \" + retval);\n\t\tif (retval != 0) {\n\t\t\tthrow new InstallerException(\"powershell.exe is not on installed, or is not available on the system path. \"\n\t\t\t\t\t+ \"Powershell is required on both client and server for Cloudify to work on Windows. \"\n\t\t\t\t\t+ \"Execution result: \" + output);\n\t\t}\n\n\t\tpowerShellInstalled = Boolean.TRUE;\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void remoteExecuteAgentOnServer(final InstallationDetails details, final long end, final String targetHost)\n\t\t\tthrows InstallerException, TimeoutException, InterruptedException {\n\n\t\t// get script for execution mode\n\t\tfinal String scriptFileName = getScriptFileName(details);\n\n\t\tString remoteDirectory = details.getRemoteDir();\n\t\tif (remoteDirectory.endsWith(\"/\")) {\n\t\t\tremoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);\n\t\t}\n\t\tfinal String scriptPath = remoteDirectory + \"/\" + scriptFileName;\n\n\t\tfinal ShellCommandBuilder scb =\n\t\t\t\tnew ShellCommandBuilder(details.getRemoteExecutionMode())\n\t\t\t\t\t\t.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())\n\t\t\t\t\t\t.exportVar(GSA_MODE_ENV, details.isLus() ? \"lus\" : \"agent\")\n\t\t\t\t\t\t.exportVar(NO_WEB_SERVICES_ENV, details.isNoWebServices() ? \"true\" : \"false\")\n\t\t\t\t\t\t.exportVar(MACHINE_IP_ADDRESS_ENV,\n\t\t\t\t\t\t\t\tdetails.isBindToPrivateIp() ? details.getPrivateIp() : details.getPublicIp())\n\t\t\t\t\t\t.exportVar(MACHINE_ZONES_ENV, details.getZones())\n\t\t\t\t\t\t.exportVar(CLOUDIFY_LINK_ENV,\n\t\t\t\t\t\t\t\tdetails.getCloudifyUrl() != null ? \"\\\"\" + details.getCloudifyUrl() + \"\\\"\" : \"\")\n\t\t\t\t\t\t.exportVar(CLOUDIFY_OVERRIDES_LINK_ENV,\n\t\t\t\t\t\t\t\tdetails.getOverridesUrl() != null ? \"\\\"\" + details.getOverridesUrl() + \"\\\"\" : \"\")\n\t\t\t\t\t\t.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)\n\t\t\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\n\t\t\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());\n\n\t\tif (details.isLus()) {\n\t\t\tString remotePath = details.getRemoteDir();\n\t\t\tif (!remotePath.endsWith(\"/\")) {\n\t\t\t\tremotePath += \"/\";\n\t\t\t}\n\t\t\tscb.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());\n\t\t}\n\t\tscb.chmodExecutable(scriptPath).call(scriptPath);\n\n\t\tfinal String command = scb.toString();\n\n\t\tlogger.fine(\"Calling startup script on target: \" + targetHost + \" with LOCATOR=\" + details.getLocator()\n\t\t\t\t+ \"\\nThis may take a few minutes\");\n\n\t\tswitch (details.getRemoteExecutionMode()) {\n\t\tcase SSH:\n\t\t\tsshCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\n\n\t\t\tbreak;\n\t\tcase WINRM:\n\t\t\tpowershellCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}","id":22887,"modified_method":"private void remoteExecuteAgentOnServer(final InstallationDetails details, final long end, final String targetHost)\n\t\t\tthrows InstallerException, TimeoutException, InterruptedException {\n\n\t\t// get script for execution mode\n\t\tfinal String scriptFileName = getScriptFileName(details);\n\n\t\tString remoteDirectory = details.getRemoteDir();\n\t\tif (remoteDirectory.endsWith(\"/\")) {\n\t\t\tremoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);\n\t\t}\n\t\tfinal String scriptPath = remoteDirectory + \"/\" + scriptFileName;\n\n\t\tfinal ShellCommandBuilder scb =\n\t\t\t\tnew ShellCommandBuilder(details.getRemoteExecutionMode())\n\t\t\t\t\t\t.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())\n\t\t\t\t\t\t.exportVar(GSA_MODE_ENV, details.isLus() ? \"lus\" : \"agent\")\n\t\t\t\t\t\t.exportVar(NO_WEB_SERVICES_ENV, details.isNoWebServices() ? \"true\" : \"false\")\n\t\t\t\t\t\t.exportVar(MACHINE_IP_ADDRESS_ENV,\n\t\t\t\t\t\t\t\tdetails.isBindToPrivateIp() ? details.getPrivateIp() : details.getPublicIp())\n\t\t\t\t\t\t.exportVar(MACHINE_ZONES_ENV, details.getZones())\n\t\t\t\t\t\t.exportVar(CLOUDIFY_LINK_ENV,\n\t\t\t\t\t\t\t\tdetails.getCloudifyUrl() != null ? \"\\\"\" + details.getCloudifyUrl() + \"\\\"\" : \"\")\n\t\t\t\t\t\t.exportVar(CLOUDIFY_OVERRIDES_LINK_ENV,\n\t\t\t\t\t\t\t\tdetails.getOverridesUrl() != null ? \"\\\"\" + details.getOverridesUrl() + \"\\\"\" : \"\")\n\t\t\t\t\t\t.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)\n\t\t\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\n\t\t\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());\n\n\t\tif (details.isLus()) {\n\t\t\tString remotePath = details.getRemoteDir();\n\t\t\tif (!remotePath.endsWith(\"/\")) {\n\t\t\t\tremotePath += \"/\";\n\t\t\t}\n\t\t\tscb.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName());\n\t\t}\n\n\t\tif (details.getUsername() != null) {\n\t\t\tscb.exportVar(\"USERNAME\", details.getUsername());\n\t\t}\n\t\tif (details.getPassword() != null) {\n\t\t\tscb.exportVar(\"PASSWORD\", details.getPassword());\n\t\t}\n\n\t\tscb.chmodExecutable(scriptPath).call(scriptPath);\n\n\t\tfinal String command = scb.toString();\n\n\t\tlogger.fine(\"Calling startup script on target: \" + targetHost + \" with LOCATOR=\" + details.getLocator()\n\t\t\t\t+ \"\\nThis may take a few minutes\");\n\n\t\tswitch (details.getRemoteExecutionMode()) {\n\t\tcase SSH:\n\t\t\tsshCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\n\n\t\t\tbreak;\n\t\tcase WINRM:\n\t\t\tpowershellCommand(targetHost, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS, details.getLocalDir());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void uploadFilesToServer(final InstallationDetails details, final long end, final String targetHost)\n\t\t\tthrows TimeoutException, InstallerException, InterruptedException {\n\t\ttry {\n\t\t\tfinal Set<String> excludedFiles = new HashSet<String>();\n\t\t\tif (!details.isLus() && details.getManagementOnlyFiles() != null) {\n\t\t\t\texcludedFiles.addAll(Arrays.asList(details.getManagementOnlyFiles()));\n\t\t\t}\n\t\t\tcopyFiles(targetHost, details.getUsername(), details.getPassword(), details.getLocalDir(),\n\t\t\t\t\tdetails.getRemoteDir(), details.getKeyFile(), excludedFiles, details.getCloudFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS, details.getFileTransferMode());\n\t\t} catch (final FileSystemException e) {\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t} catch (final IOException e) {\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t} catch (final URISyntaxException e) {\n\t\t\tlogger.info(Arrays.toString(e.getStackTrace()));\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t}\n\t}","id":22888,"modified_method":"private void uploadFilesToServer(final InstallationDetails details, final long end, final String targetHost)\n\t\t\tthrows TimeoutException, InstallerException, InterruptedException {\n\t\ttry {\n\t\t\tfinal Set<String> excludedFiles = new HashSet<String>();\n\t\t\tif (!details.isLus() && details.getManagementOnlyFiles() != null) {\n\t\t\t\texcludedFiles.addAll(Arrays.asList(details.getManagementOnlyFiles()));\n\t\t\t}\n\t\t\tcopyFiles(targetHost, details.getUsername(), details.getPassword(), details.getLocalDir(),\n\t\t\t\t\tdetails.getRemoteDir(), details.getKeyFile(), excludedFiles, details.getCloudFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS, details.getFileTransferMode());\n\t\t} catch (final FileSystemException e) {\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t} catch (final IOException e) {\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t} catch (final URISyntaxException e) {\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t}\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void powershellCommand(final String targetHost, final String command, final String username,\n\t\t\tfinal String password, final String keyFile, final long millisUntil, final TimeUnit milliseconds)\n\t\t\tthrows InstallerException, InterruptedException, TimeoutException {\n\t\ttry {\n\t\t\tcheckPowershellInstalled();\n\t\t} catch (final IOException e) {\n\t\t\tthrow new InstallerException(\"Error while trying to find powershell.exe\", e);\n\t\t}\n\n\t\tfinal String formattedCommand =\n\t\t\t\tString.format(POWER_SHELL_COMMAND_TEMPLATE, password, username, targetHost, command);\n\n\t\tFile tempScriptFile = null;\n\t\ttry {\n\t\t\ttempScriptFile = createTempScriptFile(formattedCommand);\n\t\t} catch (final IOException e) {\n\t\t\tthrow new InstallerException(\"Failed to create script file\", e);\n\t\t}\n\n\t\tfinal List<String> fullCommand = new LinkedList<String>();\n\t\tfullCommand.addAll(Arrays.asList(POWER_SHELL_PREFIX));\n\t\tfullCommand.add(tempScriptFile.getAbsolutePath());\n\n\t\tcheckConnection(targetHost, POWERSHELL_PORT, millisUntil, milliseconds);\n\t\tfinal ProcessBuilder pb = new ProcessBuilder(fullCommand);\n\t\tpb.redirectErrorStream(true);\n\n\t\ttry {\n\t\t\tfinal Process p = pb.start();\n\n\t\t\tfinal String output = readProcessOutput(p);\n\t\t\tfinal int exitCode = p.waitFor();\n\t\t\tif (exitCode != 0) {\n\t\t\t\tthrow new InstallerException(\"Remote installation failed with exit code: \" + exitCode\n\t\t\t\t\t\t+ \". Execution output: \" + output);\n\t\t\t}\n\t\t} catch (final IOException e) {\n\t\t\tthrow new InstallerException(\"Failed to invoke remote installation: \" + e.getMessage(), e);\n\t\t} finally {\n\t\t\t// delete the temp script\n\t\t\t// TODO - instead of writing the password to the file, pass it as an argument to the script.\n\t\t\ttempScriptFile.delete();\n\t\t}\n\n\t}","id":22889,"modified_method":"private void powershellCommand(final String targetHost, final String command, final String username,\n\t\t\tfinal String password, final String keyFile, final long millisUntil, final TimeUnit milliseconds,\n\t\t\tfinal String localDir)\n\t\t\tthrows InstallerException, InterruptedException, TimeoutException {\n\t\tlogger.fine(\"Executing: \" + command + \" on: \" + targetHost);\n\n\t\tlogger.fine(\"Checking if powershell is installed\");\n\t\ttry {\n\t\t\tcheckPowershellInstalled();\n\t\t} catch (final IOException e) {\n\t\t\tthrow new InstallerException(\"Error while trying to find powershell.exe\", e);\n\t\t}\n\n\t\tlogger.fine(\"Checking WinRM Connection\");\n\t\tcheckConnection(targetHost, POWERSHELL_PORT, millisUntil, milliseconds);\n\n\t\tlogger.fine(\"Executing remote command\");\n\t\ttry {\n\t\t\tinvokeRemotePowershellCommand(targetHost, command, username, password, localDir);\n\t\t} catch (final FileNotFoundException e) {\n\t\t\tthrow new InstallerException(\"Failed to invoke remote powershell command\", e);\n\t\t}\n\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tprotected void initDeployer(final Cloud cloud) {\n\t\tif (this.deployer != null) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// TODO - jcloudsUniqueId should be unique per cloud configuration.\n\t\t\t// TODO - The deployer object should be reusable across templates. The current API is not appropriate.\n\t\t\t// TODO - key should be based on entire cloud configuraion!\n\t\t\tthis.deployer =\n\t\t\t\t\t(JCloudsDeployer) context.getOrCreate(\"UNIQUE_JCLOUDS_DEPLOYER_ID_\" + this.cloudTemplateName,\n\t\t\t\t\t\t\tnew Callable<Object>() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object call()\n\t\t\t\t\t\t\t\t\t\tthrows Exception {\n\t\t\t\t\t\t\t\t\tlogger.fine(\"Creating JClouds context deployer with user: \"\n\t\t\t\t\t\t\t\t\t\t\t+ cloud.getUser().getUser());\n\t\t\t\t\t\t\t\t\tfinal CloudTemplate cloudTemplate = cloud.getTemplates().get(cloudTemplateName);\n\n\t\t\t\t\t\t\t\t\tlogger.fine(\"Cloud Template: \" + cloudTemplateName + \". Details: \" + cloudTemplate);\n\t\t\t\t\t\t\t\t\tfinal Properties props = new Properties();\n\t\t\t\t\t\t\t\t\tprops.putAll(cloudTemplate.getOverrides());\n\n\t\t\t\t\t\t\t\t\tdeployer =\n\t\t\t\t\t\t\t\t\t\t\tnew JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser()\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getUser(), cloud.getUser().getApiKey(), props);\n\n\t\t\t\t\t\t\t\t\tdeployer.setImageId(cloudTemplate.getImageId());\n\t\t\t\t\t\t\t\t\tdeployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());\n\t\t\t\t\t\t\t\t\tdeployer.setHardwareId(cloudTemplate.getHardwareId());\n\t\t\t\t\t\t\t\t\tdeployer.setLocationId(cloudTemplate.getLocationId());\n\t\t\t\t\t\t\t\t\tdeployer.setExtraOptions(cloudTemplate.getOptions());\n\t\t\t\t\t\t\t\t\treturn deployer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t} catch (final Exception e) {\n\t\t\tpublishEvent(\"connection_to_cloud_api_failed\", cloud.getProvider().getProvider());\n\t\t\tthrow new IllegalStateException(\"Failed to create cloud Deployer\", e);\n\t\t}\n\t}","id":22890,"modified_method":"@Override\n\tprotected void initDeployer(final Cloud cloud) {\n\t\tif (this.deployer != null) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\t// TODO - jcloudsUniqueId should be unique per cloud configuration.\n\t\t\t// TODO - The deployer object should be reusable across templates. The current API is not appropriate.\n\t\t\t// TODO - key should be based on entire cloud configuraion!\n\t\t\t// TODO - this shared context only works if we have reference counting, to check when this item is \n\t\t\t// no longer there. Otherwise, either this context will leak, or it will be shutdown by the first\n\t\t\t// service to by undeployed.\n\t\t\tthis.deployer = createDeployer(cloud);\n//\t\t\t\t\t(JCloudsDeployer) context.getOrCreate(\"UNIQUE_JCLOUDS_DEPLOYER_ID_\" + this.cloudTemplateName,\n//\t\t\t\t\t\t\tnew Callable<Object>() {\n//\n//\t\t\t\t\t\t\t\t@Override\n//\t\t\t\t\t\t\t\tpublic Object call()\n//\t\t\t\t\t\t\t\t\t\tthrows Exception {\n//\t\t\t\t\t\t\t\t\treturn createDeplyer(cloud);\n//\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t});\n\t\t} catch (final Exception e) {\n\t\t\tpublishEvent(\"connection_to_cloud_api_failed\", cloud.getProvider().getProvider());\n\t\t\tthrow new IllegalStateException(\"Failed to create cloud Deployer\", e);\n\t\t}\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void handleEC2WindowsCredentials(final long end, final NodeMetadata node,\n\t\t\tfinal MachineDetails machineDetails, final CloudTemplate cloudTemplate)\n\t\t\tthrows FileNotFoundException, InterruptedException, TimeoutException, CloudProvisioningException {\n\t\tFile pemFile = null;\n\t\tlogger.info(\"Gigaspaces base is: \" + Environment.getHomeDirectory());\n\t\tlogger.info(\"Local directory is: \" + this.cloud.getProvider().getLocalDirectory());\n\t\tif (this.management) {\n\t\t\tfinal String baseDirectory = Environment.getHomeDirectory();\n\t\t\tfinal File localDirectory = new File(baseDirectory, this.cloud.getProvider().getLocalDirectory());\n\n\t\t\tpemFile = new File(localDirectory, this.cloud.getUser().getKeyFile());\n\t\t} else {\n\t\t\tString localDirectoryName = this.cloud.getProvider().getLocalDirectory();\n\t\t\tlogger.info(\"local dir name is: \" + localDirectoryName);\n\t\t\tfinal File localDirectory = new File(localDirectoryName);\n\n\t\t\tpemFile = new File(localDirectory, this.cloud.getUser().getKeyFile());\n\t\t}\n\t\t// final String baseDirectory = this.management ? Environment.getHomeDirectory() :\n\t\t// this.cloud.getProvider().getRemoteDirectory();\n\t\t// final File localDirectory = new File(baseDirectory, this.cloud.getProvider().getLocalDirectory());\n\t\t//\n\t\t// final File pemFile = new File(this.cloud.getUser().getKeyFile());\n\n\t\tlogger.info(\"PEM file is located at: \" + pemFile);\n\t\tif (!pemFile.exists()) {\n\t\t\tlogger.severe(\"Could not find pem file: \" + pemFile);\n\t\t\tthrow new FileNotFoundException(\"Could not find key file: \" + pemFile);\n\t\t}\n\t\tlogger.info(\"PEM file exists!\");\n\t\tString password;\n\t\tif (cloudTemplate.getPassword() == null) {\n\t\t\t// get the password using Amazon API\n\t\t\tfinal LoginCredentials credentials =\n\t\t\t\t\tnew EC2WindowsPasswordHandler().getPassword(node, this.deployer.getContext(), end, pemFile);\n\t\t\tpassword = credentials.getPassword();\n\t\t} else {\n\t\t\tpassword = cloudTemplate.getPassword();\n\t\t}\n\n\t\tString username = cloudTemplate.getUsername();\n\t\tif (username == null) {\n\t\t\tusername = cloud.getConfiguration().getRemoteUsername();\n\t\t}\n\n\t\tif (username == null) {\n\t\t\tusername = DEFAULT_EC2_WINDOWS_USERNAME;\n\t\t}\n\t\tmachineDetails.setRemoteUsername(username);\n\t\tmachineDetails.setRemotePassword(password);\n\t\tmachineDetails.setFileTransferMode(cloudTemplate.getFileTransfer());\n\t\tmachineDetails.setRemoteExecutionMode(cloudTemplate.getRemoteExecution());\n\t}","id":22891,"modified_method":"private void handleEC2WindowsCredentials(final long end, final NodeMetadata node,\n\t\t\tfinal MachineDetails machineDetails, final CloudTemplate cloudTemplate)\n\t\t\tthrows FileNotFoundException, InterruptedException, TimeoutException, CloudProvisioningException {\n\t\tFile pemFile = null;\n\t\t\n\t\tif (this.management) {\n\t\t\tfinal String baseDirectory = Environment.getHomeDirectory();\n\t\t\tfinal File localDirectory = new File(baseDirectory, this.cloud.getProvider().getLocalDirectory());\n\n\t\t\tpemFile = new File(localDirectory, this.cloud.getUser().getKeyFile());\n\t\t} else {\n\t\t\tString localDirectoryName = this.cloud.getProvider().getLocalDirectory();\n\t\t\tlogger.fine(\"local dir name is: \" + localDirectoryName);\n\t\t\tfinal File localDirectory = new File(localDirectoryName);\n\n\t\t\tpemFile = new File(localDirectory, this.cloud.getUser().getKeyFile());\n\t\t}\n\n\t\tif (!pemFile.exists()) {\n\t\t\tlogger.severe(\"Could not find pem file: \" + pemFile);\n\t\t\tthrow new FileNotFoundException(\"Could not find key file: \" + pemFile);\n\t\t}\n\t\tlogger.info(\"PEM file exists!\");\n\t\tString password;\n\t\tif (cloudTemplate.getPassword() == null) {\n\t\t\t// get the password using Amazon API\n\t\t\tlogger.info(\"Waiting for Windows Password to become available\");\n\t\t\tfinal LoginCredentials credentials =\n\t\t\t\t\tnew EC2WindowsPasswordHandler().getPassword(node, this.deployer.getContext(), end, pemFile);\n\t\t\tpassword = credentials.getPassword();\n\t\t\tlogger.info(\"Windows Password retrieved\");\n\n\t\t} else {\n\t\t\tpassword = cloudTemplate.getPassword();\n\t\t}\n\n\t\tString username = cloudTemplate.getUsername();\n\t\tif (username == null) {\n\t\t\tusername = cloud.getConfiguration().getRemoteUsername();\n\t\t}\n\n\t\tif (username == null) {\n\t\t\tusername = DEFAULT_EC2_WINDOWS_USERNAME;\n\t\t}\n\t\tmachineDetails.setRemoteUsername(username);\n\t\tmachineDetails.setRemotePassword(password);\n\t\tmachineDetails.setFileTransferMode(cloudTemplate.getFileTransfer());\n\t\tmachineDetails.setRemoteExecutionMode(cloudTemplate.getRemoteExecution());\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails doStartMachine(final long end)\n\t\t\tthrows Exception {\n\n\t\tfinal String groupName = createNewServerName();\n\t\tlogger.info(\"Starting a new cloud server with group: \" + groupName);\n\t\treturn createServer(end, groupName);\n\t}","id":22892,"modified_method":"private MachineDetails doStartMachine(final long end)\n\t\t\tthrows Exception {\n\n\t\tfinal String groupName = createNewServerName();\n\t\tlogger.fine(\"Starting a new cloud server with group: \" + groupName);\n\t\treturn createServer(end, groupName);\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic MachineDetails startMachine(final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, CloudProvisioningException {\n\n\t\tlogger.info(this.getClass().getName() + \": startMachine, management mode: \" + management);\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tif (System.currentTimeMillis() > end) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\n\t\tfinal ComputeServiceContext currentContext = this.deployer.getContext();\n\t\ttry {\n\t\t\tfinal MachineDetails md = doStartMachine(end);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\n\t\t\t// Special handling for cloudstack on ALU - for unknown reason, the context throws rejected exception.\n\t\t\t// Looks like the thread pool is exhausted, though not clear why. Does not repro outside their cloud.\n\t\t\tif (e instanceof RejectedExecutionException\n\t\t\t\t\t&& this.cloud.getProvider().getProvider().equalsIgnoreCase(\"cloudstack\")) {\n\t\t\t\tlogger.warning(\"Detected Jclouds execution problem. Reseting Jclouds context\");\n\t\t\t\ttry {\n\t\t\t\t\tthis.deployer.reset(currentContext);\n\t\t\t\t} catch (final Exception e2) {\n\t\t\t\t\tlogger.log(Level.WARNING, \"Failed to reset jclouds context\", e2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine\", e);\n\t\t}\n\t}","id":22893,"modified_method":"@Override\n\tpublic MachineDetails startMachine(final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, CloudProvisioningException {\n\n\t\tlogger.fine(this.getClass().getName() + \": startMachine, management mode: \" + management);\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tif (System.currentTimeMillis() > end) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\n\t\tfinal ComputeServiceContext currentContext = this.deployer.getContext();\n\t\ttry {\n\t\t\tfinal MachineDetails md = doStartMachine(end);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\n\t\t\t// Special handling for cloudstack on ALU - for unknown reason, the context throws rejected exception.\n\t\t\t// Looks like the thread pool is exhausted, though not clear why. Does not repro outside their cloud.\n\t\t\tif (e instanceof RejectedExecutionException\n\t\t\t\t\t&& this.cloud.getProvider().getProvider().equalsIgnoreCase(\"cloudstack\")) {\n\t\t\t\tlogger.warning(\"Detected Jclouds execution problem. Reseting Jclouds context\");\n\t\t\t\ttry {\n\t\t\t\t\tthis.deployer.reset(currentContext);\n\t\t\t\t} catch (final Exception e2) {\n\t\t\t\t\tlogger.log(Level.WARNING, \"Failed to reset jclouds context\", e2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine\", e);\n\t\t}\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private GridServiceAgent waitForGsa(final String machineIp, final long end)\n\t\t\tthrows InterruptedException, TimeoutException {\n\n\t\twhile (Utils.millisUntil(end) > 0) {\n\t\t\tGridServiceAgent gsa = admin.getGridServiceAgents().getHostAddress().get(machineIp);\n\t\t\tif (gsa != null) {\n\t\t\t\treturn gsa;\n\t\t\t}\n\n\t\t\tgsa = admin.getGridServiceAgents().getHostNames().get(machineIp);\n\t\t\tif (gsa != null) {\n\t\t\t\treturn gsa;\n\t\t\t}\n\n\t\t\tThread.sleep(MILLISECONDS_IN_SECOND);\n\n\t\t}\n\t\treturn null;\n\n\t}","id":22894,"modified_method":"private GridServiceAgent waitForGsa(final String machineIp, final long end)\n\t\t\tthrows InterruptedException, TimeoutException {\n\n\t\twhile (Utils.millisUntil(end) > 0) {\n\t\t\tGridServiceAgent gsa = getGSAByIpOrHost(machineIp);\n\t\t\tif (gsa != null) {\n\t\t\t\treturn gsa;\n\t\t\t}\n\n\t\t\tThread.sleep(MILLISECONDS_IN_SECOND);\n\n\t\t}\n\t\treturn null;\n\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void handleExceptionAfterMachineCreated(final MachineDetails machineDetails, final long end) {\n\t\ttry {\n\t\t\t// if an agent is found (not supposed to, we got here after it wasn't found earlier) - shut it down\n\t\t\tString machineIp = null;\n\t\t\tif (machineDetails.isUsePrivateAddress()) {\n\t\t\t\tmachineIp = machineDetails.getPrivateAddress();\n\t\t\t} else {\n\t\t\t\tmachineIp = machineDetails.getPublicAddress();\n\t\t\t}\n\n\t\t\tif (machineIp != null && machineIp.trim().length() > 0) {\n\t\t\t\tfinal GridServiceAgent agent = waitForGsa(machineIp, end);\n\t\t\t\tif (agent != null) {\n\t\t\t\t\tlogger.info(\"handleExceptionAfterMachineCreated is shutting down agent: \" + agent + \" on host: \"\n\t\t\t\t\t\t\t+ machineIp);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tagent.shutdown();\n\t\t\t\t\t\tlogger.fine(\"Agent on host: \" + machineIp + \" successfully shut down\");\n\t\t\t\t\t} catch (final Exception e) {\n\t\t\t\t\t\tlogger.log(Level.WARNING, \"Failed to shutdown agent on host: \" + machineIp\n\t\t\t\t\t\t\t\t+ \". Continuing with shutdown of \" + \"machine.\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info(\"Stopping machine \" + machineDetails.getPrivateAddress()\n\t\t\t\t\t+ \", DEFAULT_SHUTDOWN_TIMEOUT_AFTER_PROVISION_FAILURE\");\n\t\t\tthis.cloudifyProvisioning.stopMachine(machineDetails.getPrivateAddress(),\n\t\t\t\t\tDEFAULT_SHUTDOWN_TIMEOUT_AFTER_PROVISION_FAILURE, TimeUnit.MINUTES);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(\n\t\t\t\t\tLevel.SEVERE,\n\t\t\t\t\t\"Machine Provisioning failed. \"\n\t\t\t\t\t\t\t+ \"An error was encountered while trying to shutdown the new machine ( \"\n\t\t\t\t\t\t\t+ machineDetails.toString() + \"). Error was: \" + e.getMessage(), e);\n\t\t}\n\t}","id":22895,"modified_method":"private void handleExceptionAfterMachineCreated(final MachineDetails machineDetails, final long end) {\n\t\ttry {\n\t\t\t// if an agent is found (not supposed to, we got here after it wasn't found earlier) - shut it down\n\t\t\tString machineIp = null;\n\t\t\tif (machineDetails.isUsePrivateAddress()) {\n\t\t\t\tmachineIp = machineDetails.getPrivateAddress();\n\t\t\t} else {\n\t\t\t\tmachineIp = machineDetails.getPublicAddress();\n\t\t\t}\n\n\t\t\tif (machineIp != null && machineIp.trim().length() > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tfinal GridServiceAgent agent = getGSAByIpOrHost(machineIp);\n\t\t\t\t\tif (agent != null) {\n\t\t\t\t\t\tlogger.info(\"handleExceptionAfterMachineCreated is shutting down agent: \" + agent\n\t\t\t\t\t\t\t\t+ \" on host: \" + machineIp);\n\n\t\t\t\t\t\tagent.shutdown();\n\t\t\t\t\t\tlogger.fine(\"Agent on host: \" + machineIp + \" successfully shut down\");\n\n\t\t\t\t\t}\n\t\t\t\t} catch (final Exception e) {\n\t\t\t\t\t// even if shutting down the agent failed, this node will be shut down later\n\t\t\t\t\tlogger.log(Level.WARNING, \"Failed to shutdown agent on host: \" + machineIp\n\t\t\t\t\t\t\t+ \". Continuing with shutdown of \" + \"machine.\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogger.info(\"Stopping machine \" + machineDetails.getPrivateAddress()\n\t\t\t\t\t+ \", DEFAULT_SHUTDOWN_TIMEOUT_AFTER_PROVISION_FAILURE\");\n\t\t\tthis.cloudifyProvisioning.stopMachine(machineDetails.getPrivateAddress(),\n\t\t\t\t\tDEFAULT_SHUTDOWN_TIMEOUT_AFTER_PROVISION_FAILURE, TimeUnit.MINUTES);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(\n\t\t\t\t\tLevel.SEVERE,\n\t\t\t\t\t\"Machine Provisioning failed. \"\n\t\t\t\t\t\t\t+ \"An error was encountered while trying to shutdown the new machine ( \"\n\t\t\t\t\t\t\t+ machineDetails.toString() + \"). Error was: \" + e.getMessage(), e);\n\t\t}\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/*********\n\t * Adds an environment variable to the command line.\n\t * \n\t * @param name\n\t *            variable name.\n\t * @param value\n\t *            variable value.\n\t * @return this.\n\t */\n\tpublic ShellCommandBuilder exportVar(final String name, final String value) {\n\n\t\tString actualValue = value;\n\t\tif (value == null) {\n\t\t\tactualValue = \"\";\n\t\t}\n\n\t\tswitch (this.mode) {\n\t\tcase SSH:\n\t\t\tsb.append(\"export \").append(name).append(\"=\").append(actualValue);\n\t\t\tbreak;\n\t\tcase WINRM:\n\t\t\tString normalizedValue = normalizeCifsPath(value);\n\t\t\tif (!(value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\"))) {\n\t\t\t\tnormalizedValue = \"\\\"\" + normalizedValue + \"\\\"\";\n\t\t\t}\n\n\t\t\tsb.append(\"$ENV:\").append(name).append(\"=\").append(normalizedValue);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// not possible.\n\t\t\tbreak;\n\t\t}\n\n\t\tseparate();\n\t\treturn this;\n\t}","id":22896,"modified_method":"/*********\n\t * Adds an environment variable to the command line.\n\t * \n\t * @param name variable name.\n\t * @param value variable value.\n\t * @return this.\n\t */\n\tpublic ShellCommandBuilder exportVar(final String name, final String value) {\n\n\t\tString actualValue = value;\n\t\tif (value == null) {\n\t\t\tactualValue = \"\";\n\t\t}\n\n\t\tswitch (this.mode) {\n\t\tcase SSH:\n\t\t\tsb.append(\"export \").append(name).append(\"=\").append(actualValue);\n\t\t\tbreak;\n\t\tcase WINRM:\n\t\t\tString normalizedValue = normalizeCifsPath(value);\n\t\t\tif (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n\t\t\t\tnormalizedValue = value.replace(\"\\\"\", \"'\");\n\t\t\t} else {\n\t\t\t\tif (!(value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\"))) {\n\t\t\t\t\tnormalizedValue = \"'\" + normalizedValue + \"'\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.append(\"$ENV:\").append(name).append(\"=\").append(normalizedValue);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// not possible.\n\t\t\tbreak;\n\t\t}\n\n\t\tseparate();\n\t\treturn this;\n\t}","commit_id":"d9ffc6622fc257dffc74db9b58b47f94b0680566","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/******\n\t * Performs installation on a remote machine with a known IP.\n\t * \n\t * @param details\n\t *            the installation details.\n\t * @param timeout the timeout duration.\n\t * @param unit the timeout unit.\n\t * @throws InterruptedException .\n\t * @throws TimeoutException .\n\t * @throws InstallerException .\n\t */\n\tpublic void installOnMachineWithIP(final InstallationDetails details, final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, InterruptedException, InstallerException {\n\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tif (details.getLocator() == null) {\n\t\t\t// We are installing the lus now\n\t\t\tdetails.setLocator(details.getPrivateIp());\n\t\t}\n\n\t\tlogger.fine(\"Executing agentless installer with the following details:\\n\" + details.toString());\n\n\t\tfinal String sshIpAddress = details.isConnectedToPrivateIp() ? details.getPrivateIp() : details.getPublicIp();\n\n\t\tpublishEvent(\"attempting_to_access_vm_with_ssh\", details.getPublicIp());\n\t\t// checking for SSH connection\n\t\tcheckConnection(sshIpAddress, SSH_PORT, Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\n\t\t// upload bootstrap files\n\t\ttry {\n\t\t\tfinal Set<String> excludedFiles = new HashSet<String>();\n\t\t\tif (!details.isLus() && details.getManagementOnlyFiles() != null) {\n\t\t\t\texcludedFiles.addAll(Arrays.asList(details.getManagementOnlyFiles()));\n\t\t\t}\n\t\t\tcopyFiles(sshIpAddress, details.getUsername(), details.getPassword(), details.getLocalDir(),\n\t\t\t\t\tdetails.getRemoteDir(), details.getKeyFile(), excludedFiles, details.getCloudFile(),\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\t} catch (final FileSystemException e) {\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t} catch (final IOException e) {\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\n\t\t}\n\n\t\t// SSH is ready, call startup script.\n\n\t\tString remoteDirectory = details.getRemoteDir();\n\t\tif (remoteDirectory.endsWith(\"/\")) {\n\t\t\tremoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);\n\t\t}\n\t\tfinal String scriptPath = remoteDirectory + \"/\" + STARTUP_SCRIPT_NAME;\n\n\t\tfinal ShellCommandBuilder scb = new ShellCommandBuilder()\n\t\t\t\t.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())\n\t\t\t\t.exportVar(GSA_MODE_ENV, details.isLus() ? \"lus\" : \"agent\")\n\t\t\t\t.exportVar(NO_WEB_SERVICES_ENV, details.isNoWebServices() ? \"true\" : \"false\")\n\t\t\t\t.exportVar(MACHINE_IP_ADDRESS_ENV, details.getPrivateIp())\n\t\t\t\t.exportVar(MACHINE_ZONES_ENV, details.getZones())\n\t\t\t\t.exportVar(CLOUDIFY_LINK_ENV,\n\t\t\t\t\t\tdetails.getCloudifyUrl() != null ? \"\\\"\" + details.getCloudifyUrl() + \"\\\"\" : \"\")\n\t\t\t\t.exportVar(CLOUDIFY_OVERRIDES_LINK_ENV,\n\t\t\t\t\t\tdetails.getOverridesUrl() != null ? \"\\\"\" + details.getOverridesUrl() + \"\\\"\" : \"\")\n\t\t\t\t.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());\n\n\t\tif (details.isLus()) {\n\t\t\tscb.exportVar(CLOUD_FILE, details.getRemoteDir() + \"/\" + details.getCloudFile().getName());\n\t\t}\n\t\tscb.chmodExecutable(scriptPath).call(scriptPath);\n\n\t\tfinal String command = scb.toString();\n\n\t\tlogger.fine(\"Calling startup script on target: \" + sshIpAddress + \" with LOCATOR=\" + details.getLocator()\n\t\t\t\t+ \"\\nThis may take a few minutes\");\n\n\t\tsshCommand(sshIpAddress, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\n\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\tpublishEvent(\"access_vm_with_ssh_success\", details.getPublicIp());\n\n\t}","id":22897,"modified_method":"/******\r\n\t * Performs installation on a remote machine with a known IP.\r\n\t * \r\n\t * @param details\r\n\t *            the installation details.\r\n\t * @param timeout the timeout duration.\n\t * @param unit the timeout unit.\n\t * @throws InterruptedException .\n\t * @throws TimeoutException .\n\t * @throws InstallerException .\n\t */\r\n\tpublic void installOnMachineWithIP(final InstallationDetails details, final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, InterruptedException, InstallerException {\r\n\r\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\r\n\t\tif (details.getLocator() == null) {\r\n\t\t\t// We are installing the lus now\r\n\t\t\tdetails.setLocator(details.getPrivateIp());\r\n\t\t}\r\n\r\n\t\tlogger.fine(\"Executing agentless installer with the following details:\\n\" + details.toString());\r\n\r\n\t\tfinal String sshIpAddress = details.isConnectedToPrivateIp() ? details.getPrivateIp() : details.getPublicIp();\n\n\t\tpublishEvent(\"attempting_to_access_vm_with_ssh\", sshIpAddress);\r\n\t\t// checking for SSH connection\r\n\t\tcheckConnection(sshIpAddress, SSH_PORT, Utils.millisUntil(end), TimeUnit.MILLISECONDS);\r\n\r\n\t\t// upload bootstrap files\r\n\t\ttry {\r\n\t\t\tfinal Set<String> excludedFiles = new HashSet<String>();\n\t\t\tif (!details.isLus() && details.getManagementOnlyFiles() != null) {\r\n\t\t\t\texcludedFiles.addAll(Arrays.asList(details.getManagementOnlyFiles()));\r\n\t\t\t}\r\n\t\t\tcopyFiles(sshIpAddress, details.getUsername(), details.getPassword(), details.getLocalDir(),\r\n\t\t\t\t\tdetails.getRemoteDir(), details.getKeyFile(), excludedFiles, details.getCloudFile(),\r\n\t\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\r\n\t\t} catch (final FileSystemException e) {\r\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\r\n\t\t} catch (final IOException e) {\r\n\t\t\tthrow new InstallerException(\"Uploading files to remote server failed.\", e);\r\n\t\t}\r\n\r\n\t\t// SSH is ready, call startup script.\r\n\r\n\t\tString remoteDirectory = details.getRemoteDir();\r\n\t\tif (remoteDirectory.endsWith(\"/\")) {\r\n\t\t\tremoteDirectory = remoteDirectory.substring(0, remoteDirectory.length() - 1);\r\n\t\t}\r\n\t\tfinal String scriptPath = remoteDirectory + \"/\" + STARTUP_SCRIPT_NAME;\n\r\n\t\tfinal ShellCommandBuilder scb = new ShellCommandBuilder()\n\t\t\t\t.exportVar(LUS_IP_ADDRESS_ENV, details.getLocator())\r\n\t\t\t\t.exportVar(GSA_MODE_ENV, details.isLus() ? \"lus\" : \"agent\")\r\n\t\t\t\t.exportVar(NO_WEB_SERVICES_ENV, details.isNoWebServices() ? \"true\" : \"false\")\r\n\t\t\t\t.exportVar(MACHINE_IP_ADDRESS_ENV, details.getPrivateIp())\r\n\t\t\t\t.exportVar(MACHINE_ZONES_ENV, details.getZones())\r\n\t\t\t\t.exportVar(CLOUDIFY_LINK_ENV,\r\n\t\t\t\t\t\tdetails.getCloudifyUrl() != null ? \"\\\"\" + details.getCloudifyUrl() + \"\\\"\" : \"\")\n\t\t\t\t.exportVar(CLOUDIFY_OVERRIDES_LINK_ENV,\n\t\t\t\t\t\tdetails.getOverridesUrl() != null ? \"\\\"\" + details.getOverridesUrl() + \"\\\"\" : \"\")\n\t\t\t\t.exportVar(WORKING_HOME_DIRECTORY_ENV, remoteDirectory)\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVATE_IP, details.getPrivateIp())\r\n\t\t\t\t.exportVar(CloudifyConstants.CLOUDIFY_AGENT_ENV_PUBLIC_IP, details.getPublicIp());\r\n\t\t\n\t\tif(details.isLus()) {\n\t\t\tString remotePath = details.getRemoteDir();\n\t\t\tif (!remotePath.endsWith(\"/\"))\n\t\t\t\tremotePath += \"/\";\n\t\t\tscb.exportVar(CLOUD_FILE, remotePath + details.getCloudFile().getName() );\n\t\t}\r\n\t\tscb.chmodExecutable(scriptPath).call(scriptPath);\r\n\r\n\t\tfinal String command = scb.toString();\n\n\t\tlogger.fine(\"Calling startup script on target: \" + sshIpAddress + \" with LOCATOR=\" + details.getLocator()\r\n\t\t\t\t+ \"\\nThis may take a few minutes\");\r\n\r\n\t\tsshCommand(sshIpAddress, command, details.getUsername(), details.getPassword(), details.getKeyFile(),\r\n\t\t\t\tUtils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\tpublishEvent(\"access_vm_with_ssh_success\", details.getPublicIp());\n\r\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * load the provisioning class and set it up\n\t * @throws CLIException\n\t */\n\tprivate void createProvisioningDriver() throws CLIException {\n\t\ttry {\n\t\t\tthis.provisioning = (ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new CLIException(\"Failed to load provisioning class for cloud: \" + this.cloud.getName() + \". Class not found: \" + this.cloud.getConfiguration().getClassName(), e);\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new CLIException(\"Failed to load provisioning class for cloud: \" + this.cloud.getName(), e);\r\n\t\t}\n\t\tprovisioning.setConfig(cloud, cloud.getConfiguration()\n\t\t\t\t.getManagementMachineTemplate(), true);\n\t\tif (provisioning instanceof ProvisioningDriverClassContextAware) {\n\t\t\tProvisioningDriverClassContextAware contextAware = (ProvisioningDriverClassContextAware)provisioning;\n\t\t\tcontextAware.setProvisioningDriverClassContext(new DefaultProvisioningDriverClassContext());\n        }\n\t}","id":22898,"modified_method":"/**\n\t * load the provisioning class and set it up\n\t * @throws CLIException\n\t */\n\tprivate void createProvisioningDriver() throws CLIException {\n\t\ttry {\n\t\t\tthis.provisioning = (ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new CLIException(\"Failed to load provisioning class for cloud: \" + this.cloud.getName() + \". Class not found: \" + this.cloud.getConfiguration().getClassName(), e);\n\t\t} catch (Exception e) {\r\n\t\t\tthrow new CLIException(\"Failed to load provisioning class for cloud: \" + this.cloud.getName(), e);\r\n\t\t}\n\t\tif (provisioning instanceof ProvisioningDriverClassContextAware) {\n\t\t\tProvisioningDriverClassContextAware contextAware = (ProvisioningDriverClassContextAware)provisioning;\n\t\t\tcontextAware.setProvisioningDriverClassContext(new DefaultProvisioningDriverClassContext());\n        }\n\t\tprovisioning.setConfig(cloud, cloud.getConfiguration().getManagementMachineTemplate(), true);\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic MachineDetails[] startManagementMachines(final long duration, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\t\tif (duration < 0) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\t\tfinal long endTime = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\tlogger.fine(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\n\t\tpublishEvent(\"try_to_connect_to_cloud_api\", cloud.getProvider().getProvider());\n\t\tinitDeployer(cloud);\n\t\tpublishEvent(\"connection_to_cloud_api_succeeded\", cloud.getProvider().getProvider());\n\n\t\t// force the creation of the jclouds template - otherwise, it may be\n\t\t// created multiple times, once for each management machine\n\t\tthis.deployer.getTemplate();\n\n\t\tfinal String managementMachinePrefix = this.machineNamePrefix;\n\n\t\t// first check if management already exists\n\t\tfinal MachineDetails[] existingManagementServers = getExistingManagementServers(managementMachinePrefix);\n\t\tif (existingManagementServers.length > 0) {\n\t\t\tlogger.fine(\"Found existing servers matching the name: \" + managementMachinePrefix);\n\t\t\treturn existingManagementServers;\n\t\t}\n\n\t\t// launch the management machines\n\t\tpublishEvent(\"attempting_to_create_management_vms\");\n\t\tfinal int numberOfManagementMachines = this.cloud.getProvider().getNumberOfManagementMachines();\n\t\tfinal MachineDetails[] createdMachines = doStartManagementMachines(endTime, numberOfManagementMachines);\n\t\tpublishEvent(\"management_started_successfully\");\n\t\treturn createdMachines;\n\n\t}","id":22899,"modified_method":"@Override\n\tpublic MachineDetails[] startManagementMachines(final long duration, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\t\tif (duration < 0) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\t\tfinal long endTime = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\tlogger.info(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\n\t\tfinal String managementMachinePrefix = this.serverNamePrefix;\n\n\t\t// first check if management already exists\n\t\tfinal MachineDetails[] existingManagementServers = getExistingManagementServers(managementMachinePrefix);\n\t\tif (existingManagementServers.length > 0) {\n\t\t\tlogger.info(\"Found existing servers matching the name: \" + managementMachinePrefix);\n\t\t\treturn existingManagementServers;\n\t\t}\n\n\t\t// launch the management machines\n\t\tpublishEvent(EVENT_ATTEMPT_START_MGMT_VMS);\n\t\tfinal int numberOfManagementMachines = this.cloud.getProvider().getNumberOfManagementMachines();\n\t\tfinal MachineDetails[] createdMachines = doStartManagementMachines(endTime, numberOfManagementMachines);\n\t\tpublishEvent(EVENT_MGMT_VMS_STARTED);\n\t\treturn createdMachines;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic MachineDetails startMachine(final long timeout, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\n\t\tlogger.fine(\"DefaultCloudProvisioning: startMachine - management == \" + management);\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\n\t\tinitDeployer(cloud);\n\n\t\t// initializing the jclouds context can take a while on some clouds, so\n\t\t// check for timeout\n\t\tif (System.currentTimeMillis() > end) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\n\t\ttry {\n\t\t\tfinal MachineDetails md = doStartMachine(end);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine\", e);\n\t\t}\n\n\t}","id":22900,"modified_method":"@Override\n\tpublic MachineDetails startMachine(final long timeout, final TimeUnit unit) throws TimeoutException,\n\t\t\tCloudProvisioningException {\n\n\t\tlogger.info(this.getClass().getName() + \": startMachine, management mode: \" + management);\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\t// TO DO : is this really necessary? maybe we can remove this method?\n\t\tinitDeployer(cloud);\n\n\t\t// initDeployed can take a while on some clouds, so checking the timeout\n\t\tif (System.currentTimeMillis() > end) {\n\t\t\tthrow new TimeoutException(\"Starting a new machine timed out\");\n\t\t}\n\n\t\ttry {\n\t\t\tfinal MachineDetails md = doStartMachine(end);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to start cloud machine\", e);\n\t\t}\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails[] doStartManagementMachines(final long endTime, final int numberOfManagementMachines)\n\t\t\tthrows TimeoutException, CloudProvisioningException {\n\t\tfinal ExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal Future<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];\n\n\t\ttry {\n\t\t\t// Call startMachine asynchronously once for each management\n\t\t\t// machine\n\t\t\tfor (int i = 0; i < numberOfManagementMachines; i++) {\n\t\t\t\tfinal int index = i + 1;\n\t\t\t\tfutures[i] = executors.submit(new Callable<MachineDetails>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic MachineDetails call() throws Exception {\n\t\t\t\t\t\treturn createServer(endTime, machineNamePrefix + index);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\t// Wait for each of the async calls to terminate.\n\t\t\tint numberOfErrors = 0;\n\t\t\tException firstCreationException = null;\n\t\t\tfinal MachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];\n\t\t\tfor (int i = 0; i < createdManagementMachines.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcreatedManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),\n\t\t\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t\t\t} catch (final InterruptedException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t} catch (final ExecutionException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In case of a partial error, shutdown all servers that did start\n\t\t\t// up\n\t\t\tif (numberOfErrors > 0) {\n\t\t\t\thandleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,\n\t\t\t\t\t\tcreatedManagementMachines);\n\t\t\t}\n\n\t\t\treturn createdManagementMachines;\n\t\t} finally {\n\t\t\tif (executors != null) {\n\t\t\t\texecutors.shutdownNow();\n\t\t\t}\n\t\t}\n\t}","id":22901,"modified_method":"private MachineDetails[] doStartManagementMachines(final long endTime, final int numberOfManagementMachines)\n\t\t\tthrows TimeoutException, CloudProvisioningException {\n\t\tfinal ExecutorService executors = Executors.newFixedThreadPool(numberOfManagementMachines);\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal Future<MachineDetails>[] futures = (Future<MachineDetails>[]) new Future<?>[numberOfManagementMachines];\n\n\t\ttry {\n\t\t\t// Call startMachine asynchronously once for each management\n\t\t\t// machine\n\t\t\tfor (int i = 0; i < numberOfManagementMachines; i++) {\n\t\t\t\tfinal int index = i + 1;\n\t\t\t\tfutures[i] = executors.submit(new Callable<MachineDetails>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic MachineDetails call() throws Exception {\n\t\t\t\t\t\treturn createServer(endTime, serverNamePrefix + index);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t\t// Wait for each of the async calls to terminate.\n\t\t\tint numberOfErrors = 0;\n\t\t\tException firstCreationException = null;\n\t\t\tfinal MachineDetails[] createdManagementMachines = new MachineDetails[numberOfManagementMachines];\n\t\t\tfor (int i = 0; i < createdManagementMachines.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcreatedManagementMachines[i] = futures[i].get(endTime - System.currentTimeMillis(),\n\t\t\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t\t\t} catch (final InterruptedException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t} catch (final ExecutionException e) {\n\t\t\t\t\t++numberOfErrors;\n\t\t\t\t\tpublishEvent(\"failed_to_create_management_vm\", e.getMessage());\n\t\t\t\t\tlogger.log(Level.SEVERE, \"Failed to start a management machine\", e);\n\t\t\t\t\tif (firstCreationException == null) {\n\t\t\t\t\t\tfirstCreationException = e;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In case of a partial error, shutdown all servers that did start up\n\t\t\tif (numberOfErrors > 0) {\n\t\t\t\thandleProvisioningFailure(numberOfManagementMachines, numberOfErrors, firstCreationException,\n\t\t\t\t\t\tcreatedManagementMachines);\n\t\t\t}\n\n\t\t\treturn createdManagementMachines;\n\t\t} finally {\n\t\t\tif (executors != null) {\n\t\t\t\texecutors.shutdownNow();\n\t\t\t}\n\t\t}\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/*********\n\t * Looks for a free machine name by appending a counter to the precalculated machine name prefix. If the max counter\n\t * value is reached, code will loop back to 0, so that previously used machine names will be reused.\n\t * \n\t * @return the machine name.\n\t * @throws CloudProvisioningException\n\t *             if no free machine name could be found.\n\t */\n\tprivate String createNewMachineName() throws CloudProvisioningException {\n\t\tint attempts = 0;\n\t\twhile (attempts < MAX_MACHINE_LIMIT) {\n\t\t\tcounter = (counter + 1) % MAX_MACHINE_LIMIT;\n\t\t\t++attempts;\n\t\t\tfinal String machineName = this.machineNamePrefix + this.counter;\n\t\t\tfinal NodeMetadata existingNode = deployer.getServerByID(machineName);\n\t\t\tif (existingNode == null) {\n\t\t\t\treturn machineName;\n\t\t\t}\n\t\t}\n\t\tthrow new CloudProvisioningException(\"Number of machines has exceeded allowed machine limit (\"\n\t\t\t\t+ MAX_MACHINE_LIMIT + \")\");\n\n\t}","id":22902,"modified_method":"/*********\n\t * Looks for a free server name by appending a counter to the pre-calculated server name prefix. If the\n\t * max counter value is reached, code will loop back to 0, so that previously used server names will be\n\t * reused.\n\t * \n\t * @return the server name.\n\t * @throws CloudProvisioningException\n\t *             if no free server name could be found.\n\t */\n\tprivate String createNewServerName() throws CloudProvisioningException {\n\n\t\tString serverName = null;\n\t\tint attempts = 0;\n\t\tboolean foundFreeName = false;\n\n\t\twhile (attempts < MAX_SERVERS_LIMIT) {\n\t\t\tcounter = (counter + 1) % MAX_SERVERS_LIMIT;\n\t\t\t++attempts;\n\t\t\tserverName = serverNamePrefix + this.counter;\n\t\t\t// verifying this server name is not already used\n\t\t\tfinal NodeMetadata existingNode = deployer.getServerByID(serverName);\n\t\t\tif (existingNode == null) {\n\t\t\t\tfoundFreeName = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!foundFreeName) {\n\t\t\tthrow new CloudProvisioningException(\"Number of servers has exceeded allowed server limit (\"\n\t\t\t\t\t+ MAX_SERVERS_LIMIT + \")\");\n\t\t}\n\n\t\treturn serverName;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void initDeployer(final Cloud cloud) {\n\t\ttry {\n\t\t\t// TODO - jcloudsUniqueId should be unique per cloud configuration.\n\t\t\tString jcloudsUniqueId = \"UNIQUE_JCLOUDS_DEPLOYER_ID\";\n\t\t\tthis.deployer = (JCloudsDeployer) context.getOrCreate(jcloudsUniqueId, new Callable<Object>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\tlogger.fine(\"Creating jclouds context deployer with user: \" + cloud.getUser().getUser());\n\t\t\t\t\tCloudTemplate cloudTemplate = cloud.getTemplates().get(cloudTemplateName);\n\n\t\t\t\t\tProperties props = new Properties();\n\t\t\t\t\tprops.putAll(cloudTemplate.getOverrides());\n\n\t\t\t\t\tdeployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser().getUser(), cloud\n\t\t\t\t\t\t\t.getUser().getApiKey(), props);\n\n\t\t\t\t\tdeployer.setImageId(cloudTemplate.getImageId());\n\t\t\t\t\tdeployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());\n\t\t\t\t\tdeployer.setHardwareId(cloudTemplate.getHardwareId());\n\t\t\t\t\tdeployer.setLocationId(cloudTemplate.getLocationId());\n\t\t\t\t\tdeployer.setExtraOptions(cloudTemplate.getOptions());\n\t\t\t\t\treturn deployer;\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (final Exception e) {\n\t\t\tpublishEvent(\"connection_to_cloud_api_failed\", cloud.getProvider().getProvider());\n\t\t\tthrow new IllegalStateException(\"Failed to create cloud Deployer\", e);\n\t\t}\n\t}","id":22903,"modified_method":"@Override\n\tprotected void initDeployer(final Cloud cloud) {\n\t\ttry {\n\t\t\t// TODO - jcloudsUniqueId should be unique per cloud configuration.\n\t\t\tthis.deployer = (JCloudsDeployer) context.getOrCreate(\"UNIQUE_JCLOUDS_DEPLOYER_ID\",\n\t\t\t\t\tnew Callable<Object>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\t\t\tlogger.info(\"Creating JClouds context deployer with user: \" + cloud.getUser().getUser());\n\t\t\t\t\t\t\tfinal CloudTemplate cloudTemplate = cloud.getTemplates().get(cloudTemplateName);\n\n\t\t\t\t\t\t\tfinal Properties props = new Properties();\n\t\t\t\t\t\t\tprops.putAll(cloudTemplate.getOverrides());\n\n\t\t\t\t\t\t\tdeployer = new JCloudsDeployer(cloud.getProvider().getProvider(), cloud.getUser()\n\t\t\t\t\t\t\t\t\t.getUser(), cloud.getUser().getApiKey(), props);\n\n\t\t\t\t\t\t\tdeployer.setImageId(cloudTemplate.getImageId());\n\t\t\t\t\t\t\tdeployer.setMinRamMegabytes(cloudTemplate.getMachineMemoryMB());\n\t\t\t\t\t\t\tdeployer.setHardwareId(cloudTemplate.getHardwareId());\n\t\t\t\t\t\t\tdeployer.setLocationId(cloudTemplate.getLocationId());\n\t\t\t\t\t\t\tdeployer.setExtraOptions(cloudTemplate.getOptions());\n\t\t\t\t\t\t\treturn deployer;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t} catch (final Exception e) {\n\t\t\tpublishEvent(\"connection_to_cloud_api_failed\", cloud.getProvider().getProvider());\n\t\t\tthrow new IllegalStateException(\"Failed to create cloud Deployer\", e);\n\t\t}\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails createServer(final long end, final String machineName) throws CloudProvisioningException,\n\t\t\tException {\n\t\tNodeMetadata node;\n\t\ttry {\n\t\t\tnode = deployer.createServer(machineName);\n\t\t} catch (final InstallerException e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to create cloud machine\", e);\n\t\t}\n\n\t\tlogger.fine(\"New machine is starting\");\n\n\t\t// At this point the machine is starting. Any error beyond this point\n\t\t// must clean up the machine\n\t\ttry {\n\t\t\tfinal MachineDetails md = createMachineDetailsFromNode(node);\n\n\t\t\thandleServerCredentials(node, md);\n\n\t\t\twaitUntilServerIsActive(node.getId(), Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\t\treturn md;\n\t\t} catch (final Exception e) {\n\t\t\t// catch any exception - to prevent a cloud machine leaking.\n\t\t\tlogger.log(Level.SEVERE,\n\t\t\t\t\t\"Cloud machine was started but an error occured during initialization. Shutting down machine\", e);\n\t\t\tthis.deployer.shutdownMachine(node.getId());\n\t\t\tthrow e;\n\t\t}\n\t}","id":22904,"modified_method":"private MachineDetails createServer(final long end, final String groupName) throws CloudProvisioningException\n\t\t\t{\n\n\t\tfinal NodeMetadata node;\n\t\tfinal MachineDetails machineDetails;\n\t\ttry {\n\t\t\tlogger.info(\"Cloudify Deployer is creating a new server with tag: \" + groupName\n\t\t\t\t\t+ \". This may take a few minutes\");\n\t\t\tnode = deployer.createServer(groupName);\n\t\t} catch (final InstallerException e) {\n\t\t\tthrow new CloudProvisioningException(\"Failed to create cloud server\", e);\n\t\t}\n\t\tlogger.info(\"New node is allocated, group name: \" + groupName);\n\n\t\tmachineDetails = createMachineDetailsFromNode(node);\n\n\t\t// At this point the machine is starting. Any error beyond this point\n\t\t// must clean up the machine\n\t\ttry {\n\t\t\thandleServerCredentials(machineDetails);\n\t\t\twaitUntilServerIsActive(machineDetails.getMachineId(), Utils.millisUntil(end), TimeUnit.MILLISECONDS);\n\t\t} catch (final Exception e) {\n\t\t\t// catch any exception - to prevent a cloud machine leaking.\n\t\t\tlogger.log(Level.SEVERE,\n\t\t\t\t\t\"Cloud machine was started but an error occured during initialization. Shutting down machine\", e);\n\t\t\tdeployer.shutdownMachine(node.getId());\n\t\t\tthrow new CloudProvisioningException(e);\n\t\t}\n\n\t\treturn machineDetails;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails createMachineDetailsFromNode(final NodeMetadata node) {\n\t\tfinal MachineDetails md = new MachineDetails();\n\t\tmd.setAgentRunning(false);\n\t\tmd.setCloudifyInstalled(false);\n\t\tmd.setInstallationDirectory(null);\n\t\tmd.setMachineId(node.getId());\n\t\tif (node.getPrivateAddresses().size() > 0) {\n\t\t\tmd.setPrivateAddress(node.getPrivateAddresses().iterator().next());\n\t\t}\n\t\tif (node.getPublicAddresses().size() > 0) {\n\t\t\tmd.setPublicAddress(node.getPublicAddresses().iterator().next());\n\t\t}\n\n\t\tif (node.getCredentials() == null) {\n\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t} else {\n\t\t\tfinal String serverIdentity = node.getCredentials().identity;\n\t\t\tif (serverIdentity != null) {\n\t\t\t\tmd.setRemoteUsername(serverIdentity);\n\t\t\t} else {\n\t\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t\t}\n\t\t}\n\n\t\tmd.setUsePrivateAddress(this.cloud.getConfiguration().isConnectToPrivateIp());\n\n\t\treturn md;\n\t}","id":22905,"modified_method":"private MachineDetails createMachineDetailsFromNode(final NodeMetadata node) {\n\t\tfinal MachineDetails md = new MachineDetails();\n\t\tmd.setAgentRunning(false);\n\t\tmd.setCloudifyInstalled(false);\n\t\tmd.setInstallationDirectory(null);\n\t\tmd.setMachineId(node.getId());\n\t\tif (node.getPrivateAddresses().size() > 0) {\n\t\t\tmd.setPrivateAddress(node.getPrivateAddresses().iterator().next());\n\t\t}\n\t\tif (node.getPublicAddresses().size() > 0) {\n\t\t\tmd.setPublicAddress(node.getPublicAddresses().iterator().next());\n\t\t}\n\n\t\tif (node.getCredentials() == null) {\n\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t} else {\n\t\t\tfinal String serverIdentity = node.getCredentials().identity;\n\t\t\tif (serverIdentity != null) {\n\t\t\t\tmd.setRemoteUsername(serverIdentity);\n\t\t\t} else {\n\t\t\t\tmd.setRemoteUsername(cloud.getConfiguration().getRemoteUsername());\n\t\t\t}\n\t\t}\n\n\t\t// By default, cloud nodes connect to each other using their private\n\t\t// address.\n\t\tmd.setUsePrivateAddress(true);\n\t\treturn md;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic boolean stopMachine(final String machineIp, final long duration, final TimeUnit unit)\n\t\t\tthrows CloudProvisioningException, TimeoutException, InterruptedException {\n\t\tlogger.fine(\"Stop Machine - machineIp: \" + machineIp);\n\n\t\t// TODO - move this to the adapter!\n\t\tfinal Long previousRequest = stoppingMachines.get(machineIp);\n\t\tif (previousRequest != null\n\t\t\t\t&& System.currentTimeMillis() - previousRequest < MULTIPLE_SHUTDOWN_REQUEST_IGNORE_TIMEOUT) {\n\t\t\tlogger.fine(\"Machine \" + machineIp + \" is already stopping. Ignoring this shutdown request\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// TODO - add a task that cleans up this map\n\t\tstoppingMachines.put(machineIp, System.currentTimeMillis());\n\t\tlogger.fine(\"Scale IN -- \" + machineIp + \" --\");\n\n\t\tlogger.fine(\"Looking Up Cloud server with IP: \" + machineIp);\n\t\tfinal NodeMetadata server = getServerWithIP(machineIp);\n\t\tif (server != null) {\n\t\t\tlogger.fine(\"Found server: \" + server.getId() + \". Shutting it down and waiting for shutdown to completes\");\n\t\t\tdeployer.shutdownMachineAndWait(server.getId(), unit, duration);\n\t\t\tlogger.fine(\"Server: \" + server.getId() + \" shutdown has finished.\");\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tlogger.log(Level.SEVERE, \"Recieved scale in request for machine with ip \" + machineIp\n\t\t\t\t\t+ \" but this IP could not be found in the Cloud server list\");\n\t\t\treturn false;\n\t\t}\n\n\t}","id":22906,"modified_method":"@Override\n\tpublic boolean stopMachine(final String serverIp, final long duration, final TimeUnit unit)\n\t\t\tthrows CloudProvisioningException, TimeoutException, InterruptedException {\n\n\t\tboolean stopResult = false;\n\n\t\tlogger.info(\"Stop Machine - machineIp: \" + serverIp);\n\t\tfinal Long previousRequest = stoppingMachines.get(serverIp);\n\t\tif (previousRequest != null\n\t\t\t\t&& System.currentTimeMillis() - previousRequest < MULTIPLE_SHUTDOWN_REQUEST_IGNORE_TIMEOUT) {\n\t\t\tlogger.fine(\"Machine \" + serverIp + \" is already stopping. Ignoring this shutdown request\");\n\t\t\tstopResult = false;\n\t\t} else {\n\t\t\t// TODO - add a task that cleans up this map\n\t\t\tstoppingMachines.put(serverIp, System.currentTimeMillis());\n\t\t\tlogger.info(\"Scale IN -- \" + serverIp + \" --\");\n\t\t\tlogger.info(\"Looking up cloud server with IP: \" + serverIp);\n\t\t\tfinal NodeMetadata server = deployer.getServerWithIP(serverIp);\n\t\t\tif (server != null) {\n\t\t\t\tlogger.info(\"Found server: \" + server.getId()\n\t\t\t\t\t\t+ \". Shutting it down and waiting for shutdown to complete\");\n\t\t\t\tdeployer.shutdownMachineAndWait(server.getId(), unit, duration);\n\t\t\t\tlogger.info(\"Server: \" + server.getId() + \" shutdown has finished.\");\n\t\t\t\tstopResult = true;\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.SEVERE, \"Recieved scale in request for machine with ip \" + serverIp\n\t\t\t\t\t\t+ \" but this IP could not be found in the Cloud server list\");\n\t\t\t\tstopResult = false;\n\t\t\t}\n\t\t}\n\n\t\treturn stopResult;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/*********\n\t * Periodically gets the server status from Rackspace, until the server's status changes to ACTIVE, or a timeout\n\t * expires.\n\t * \n\t * @param serverId\n\t *            The server ID.\n\t * @param milliseconds\n\t * @param l\n\t * @return The server status - should always be ACTIVE.\n\t */\n\tprotected void waitUntilServerIsActive(final String serverId, final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, InterruptedException {\n\t\tfinal long endTime = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\tNodeMetadata server;\n\t\twhile (true) {\n\t\t\tserver = deployer.getServerByID(serverId);\n\t\t\tif (server != null && server.getState() == NodeState.RUNNING) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (System.currentTimeMillis() > endTime) {\n\t\t\t\tthrow new TimeoutException(\"Server [ \" + serverId + \" ] has been starting up for more more than \"\n\t\t\t\t\t\t+ TimeUnit.MINUTES.convert(WAIT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS) + \" minutes!\");\n\t\t\t}\n\n\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\tfinal String serverName = server != null ? server.getState().name() : serverId;\n\t\t\t\tlogger.fine(\"Server Status (\" + serverName + \") still not active, please wait...\");\n\t\t\t}\n\t\t\tThread.sleep(WAIT_THREAD_SLEEP_MILLIS);\n\t\t}\n\t}","id":22907,"modified_method":"/*********\n\t * Periodically gets the server status from the cloud, until the server's status changes to ACTIVE, or a\n\t * timeout expires.\n\t * \n\t * @param serverId\n\t *            The server ID.\n\t * @param milliseconds\n\t * @param l\n\t * @return The server status - should always be ACTIVE.\n\t */\n\tprivate void waitUntilServerIsActive(final String serverId, final long timeout, final TimeUnit unit)\n\t\t\tthrows TimeoutException, InterruptedException {\n\t\tfinal long endTime = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\tNodeMetadata server;\n\t\twhile (true) {\n\t\t\tserver = deployer.getServerByID(serverId);\n\t\t\tif (server != null && server.getState() == NodeState.RUNNING) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (System.currentTimeMillis() > endTime) {\n\t\t\t\tthrow new TimeoutException(\"Server [ \" + serverId + \" ] has been starting up for more more than \"\n\t\t\t\t\t\t+ TimeUnit.MINUTES.convert(WAIT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS) + \" minutes!\");\n\t\t\t}\n\n\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\tfinal String serverName = server != null ? server.getState().name() : serverId;\n\t\t\t\tlogger.fine(\"Server Status (\" + serverName + \") still not active, please wait...\");\n\t\t\t}\n\t\t\tThread.sleep(WAIT_THREAD_SLEEP_MILLIS);\n\t\t}\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void close() {\n\t\tthis.deployer.close();\n\t}","id":22908,"modified_method":"@Override\n\tpublic void close() {\n\t\tdeployer.close();\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails doStartMachine(final long end) throws Exception {\n\n\t\tfinal String machineName = createNewMachineName();\n\t\tlogger.fine(\"Starting a new cloud machines with group: \" + machineName);\n\n\t\treturn createServer(end, machineName);\n\n\t}","id":22909,"modified_method":"private MachineDetails doStartMachine(final long end) throws Exception {\n\n\t\tfinal String groupName = createNewServerName();\n\t\tlogger.info(\"Starting a new cloud server with group: \" + groupName);\n\t\treturn createServer(end, groupName);\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void stopManagementMachines() throws TimeoutException, CloudProvisioningException {\n\n\t\tinitDeployer(this.cloud);\n\t\tfinal MachineDetails[] managementServers = getExistingManagementServers(this.machineNamePrefix);\n\n\t\tif (managementServers.length == 0) {\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Could not find any management machines for this cloud (management machine prefix is: \"\n\t\t\t\t\t\t\t+ this.machineNamePrefix + \")\");\n\t\t}\n\n\t\tfinal Set<String> machineIps = new HashSet<String>();\n\t\tfor (final MachineDetails machineDetails : managementServers) {\n\t\t\tmachineIps.add(machineDetails.getPrivateAddress());\n\t\t}\n\n\t\tthis.deployer.shutdownMachinesWithIPs(machineIps);\n\n\t}","id":22910,"modified_method":"@Override\n\tpublic void stopManagementMachines() throws TimeoutException, CloudProvisioningException {\n\n\t\tinitDeployer(this.cloud);\n\t\tfinal MachineDetails[] managementServers = getExistingManagementServers(this.serverNamePrefix);\n\n\t\tif (managementServers.length == 0) {\n\t\t\tthrow new CloudProvisioningException(\n\t\t\t\t\t\"Could not find any management machines for this cloud (management machine prefix is: \"\n\t\t\t\t\t\t\t+ this.serverNamePrefix + \")\");\n\t\t}\n\n\t\tfinal Set<String> machineIps = new HashSet<String>();\n\t\tfor (final MachineDetails machineDetails : managementServers) {\n\t\t\tmachineIps.add(machineDetails.getPrivateAddress());\n\t\t}\n\n\t\tthis.deployer.shutdownMachinesWithIPs(machineIps);\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private MachineDetails provisionMachine(final long duration, final TimeUnit unit) throws TimeoutException,\n\t\t\tElasticMachineProvisioningException {\n\t\tMachineDetails machineDetails;\n\t\ttry {\n\t\t\t// delegate provisioning to the cloud driver implementation\n\t\t\tmachineDetails = cloudifyProvisioning.startMachine(duration, unit);\n\t\t} catch (final CloudProvisioningException e) {\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to start machine: \" + e.getMessage());\n\t\t}\n\t\tif (machineDetails == null) {\n\t\t\tthrow new IllegalStateException(\"Provisioning provider: \" + cloudifyProvisioning.getClass().getName()\n\t\t\t\t\t+ \" returned a null when calling startMachine\");\n\t\t}\n\n\t\tlogger.info(\"New machine was provisioned. Machine details: \" + machineDetails);\n\t\treturn machineDetails;\n\t}","id":22911,"modified_method":"private MachineDetails provisionMachine(final long duration, final TimeUnit unit) throws TimeoutException,\n\t\t\tElasticMachineProvisioningException {\n\t\tMachineDetails machineDetails;\n\t\ttry {\n\t\t\t// delegate provisioning to the cloud driver implementation\n\t\t\tcloudifyProvisioning.setAdmin(admin);\n\t\t\tmachineDetails = cloudifyProvisioning.startMachine(duration, unit);\n\t\t} catch (final CloudProvisioningException e) {\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to start machine: \" + e.getMessage());\n\t\t}\n\t\tif (machineDetails == null) {\n\t\t\tthrow new IllegalStateException(\"Provisioning provider: \" + cloudifyProvisioning.getClass().getName()\n\t\t\t\t\t+ \" returned a null when calling startMachine\");\n\t\t}\n\n\t\tlogger.info(\"New machine was provisioned. Machine details: \" + machineDetails);\n\t\treturn machineDetails;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"protected InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md)\n\t\t\tthrows FileNotFoundException {\n\t\tfinal InstallationDetails details = new InstallationDetails();\n\n\t\tdetails.setLocalDir(cloud.getProvider().getLocalDirectory());\n\t\tdetails.setRemoteDir(cloud.getProvider().getRemoteDirectory());\n\t\tdetails.setManagementOnlyFiles(cloud.getProvider().getManagementOnlyFiles());\n\t\tdetails.setZones(StringUtils.join(cloud.getProvider().getZones().toArray(new String[0]), \",\", 0, cloud\n\t\t\t\t.getProvider().getZones().size()));\n\n\t\tif (cloud.getUser().getKeyFile() != null) {\n\t\t\tlogger.info(\"Key file has been specified in cloud configuration: \" + cloud.getUser().getKeyFile());\n\t\t\tfinal File keyFile = new File(cloud.getProvider().getLocalDirectory(), cloud.getUser().getKeyFile());\n\t\t\tif (keyFile.exists()) {\n\t\t\t\tdetails.setKeyFile(keyFile.getAbsolutePath());\n\t\t\t\tlogger.info(\"Using key file: \" + keyFile);\n\t\t\t} else {\n\t\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\t\"Could not find key file matching specified cloud configuration key file: \"\n\t\t\t\t\t\t\t\t+ cloud.getUser().getKeyFile() + \". Tried: \" + keyFile + \" but file does not exist\");\n\t\t\t}\n\n\t\t}\n\n\t\tdetails.setPrivateIp(md.getPrivateAddress());\n\t\tdetails.setPublicIp(md.getPublicAddress());\n\n\t\tdetails.setLocator(this.lookupLocatorsString);\n\t\tdetails.setLus(false);\n\t\tdetails.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());\n\t\tdetails.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());\n\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\tdetails.setAdmin(this.admin);\n\n\t\tdetails.setUsername(md.getRemoteUsername());\n\t\tdetails.setPassword(md.getRemotePassword());\n\t\tlogger.info(\"Created new Installation Details: \" + details);\n\t\treturn details;\n\n\t}","id":22912,"modified_method":"protected InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md)\n\t\t\tthrows FileNotFoundException {\n\t\tfinal InstallationDetails details = new InstallationDetails();\n\n\t\tdetails.setLocalDir(cloud.getProvider().getLocalDirectory());\n\t\tdetails.setRemoteDir(cloud.getProvider().getRemoteDirectory());\n\t\tdetails.setManagementOnlyFiles(cloud.getProvider().getManagementOnlyFiles());\n\t\tdetails.setZones(StringUtils.join(cloud.getProvider().getZones().toArray(new String[0]), \",\", 0, cloud\n\t\t\t\t.getProvider().getZones().size()));\n\n\t\tif (org.apache.commons.lang.StringUtils.isNotBlank(cloud.getUser().getKeyFile())) {\n\t\t\tlogger.info(\"Key file has been specified in cloud configuration: \" + cloud.getUser().getKeyFile());\n\t\t\tfinal File keyFile = new File(cloud.getProvider().getLocalDirectory(), cloud.getUser().getKeyFile());\n\t\t\tif (keyFile.exists()) {\n\t\t\t\tdetails.setKeyFile(keyFile.getAbsolutePath());\n\t\t\t\tlogger.info(\"Using key file: \" + keyFile);\n\t\t\t} else {\n\t\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\t\"Could not find key file matching specified cloud configuration key file: \"\n\t\t\t\t\t\t\t\t+ cloud.getUser().getKeyFile() + \". Tried: \" + keyFile + \" but file does not exist\");\n\t\t\t}\n\n\t\t}\n\n\t\tdetails.setPrivateIp(md.getPrivateAddress());\n\t\tdetails.setPublicIp(md.getPublicAddress());\n\n\t\tdetails.setLocator(this.lookupLocatorsString);\n\t\tdetails.setLus(false);\n\t\tdetails.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());\n\t\tdetails.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());\n\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\tdetails.setAdmin(this.admin);\n\n\t\tdetails.setUsername(md.getRemoteUsername());\n\t\tdetails.setPassword(md.getRemotePassword());\n\t\tlogger.info(\"Created new Installation Details: \" + details);\n\t\treturn details;\n\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public static long millisUntil(long end)\r\n            throws TimeoutException {\r\n        long millisUntilEnd = end - System.currentTimeMillis();\r\n        if (millisUntilEnd < 0) {\r\n            throw new TimeoutException(\"Cloud operation timed out\");\r\n        }\r\n        return millisUntilEnd;\r\n    }","id":22913,"modified_method":"/**\n\t * Calculates the milliseconds remaining until the given end time.\n\t * \n\t * @param end\n\t *            The end time, in milliseconds\n\t * @return Number of milliseconds remaining until the given end time\n\t * @throws TimeoutException\n\t *             Thrown when the end time is in the past\n\t */\n\tpublic static long millisUntil(final long end) throws TimeoutException {\n\t\tfinal long millisUntilEnd = end - System.currentTimeMillis();\n\t\tif (millisUntilEnd < 0) {\n\t\t\tthrow new TimeoutException(\"Cloud operation timed out\");\n\t\t}\n\t\treturn millisUntilEnd;\n\t}","commit_id":"d2edde3d2c6a0269021838497c8f863f46dd19b8","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * Return a Collection of ApplicationListeners matching the given\n\t * event type. Non-matching listeners get excluded early.\n\t * @param event the event to be propagated. Allows for excluding\n\t * non-matching listeners early, based on cached matching information.\n\t * @return a Collection of ApplicationListeners\n\t * @see org.springframework.context.ApplicationListener\n\t */\n\tprotected Collection<ApplicationListener<?>> getApplicationListeners(ApplicationEvent event) {\n\t\tClass<? extends ApplicationEvent> eventType = event.getClass();\n\t\tObject source = event.getSource();\n\t\tClass<?> sourceType = (source != null ? source.getClass() : null);\n\t\tListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);\n\t\tListenerRetriever retriever = this.retrieverCache.get(cacheKey);\n\t\tif (retriever != null) {\n\t\t\treturn retriever.getApplicationListeners();\n\t\t}\n\t\telse {\n\t\t\tretriever = new ListenerRetriever(true);\n\t\t\tLinkedList<ApplicationListener<?>> allListeners = new LinkedList<ApplicationListener<?>>();\n\t\t\tSet<ApplicationListener<?>> listeners;\n\t\t\tSet<String> listenerBeans;\n\t\t\tsynchronized (this.defaultRetriever) {\n\t\t\t\tlisteners = new LinkedHashSet<ApplicationListener<?>>(this.defaultRetriever.applicationListeners);\n\t\t\t\tlistenerBeans = new LinkedHashSet<String>(this.defaultRetriever.applicationListenerBeans);\n\t\t\t}\n\t\t\tfor (ApplicationListener<?> listener : listeners) {\n\t\t\t\tif (supportsEvent(listener, eventType, sourceType)) {\n\t\t\t\t\tretriever.applicationListeners.add(listener);\n\t\t\t\t\tallListeners.add(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!listenerBeans.isEmpty()) {\n\t\t\t\tBeanFactory beanFactory = getBeanFactory();\n\t\t\t\tfor (String listenerBeanName : listenerBeans) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tApplicationListener<?> listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class);\n\t\t\t\t\t\tif (!allListeners.contains(listener) && supportsEvent(listener, eventType, sourceType)) {\n\t\t\t\t\t\t\tretriever.applicationListenerBeans.add(listenerBeanName);\n\t\t\t\t\t\t\tallListeners.add(listener);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t// Singleton listener instance (without backing bean definition) disappeared -\n\t\t\t\t\t\t// probably in the middle of the destruction phase\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tOrderComparator.sort(allListeners);\n\t\t\tthis.retrieverCache.put(cacheKey, retriever);\n\t\t\treturn allListeners;\n\t\t}\n\t}","id":22914,"modified_method":"/**\n\t * Return a Collection of ApplicationListeners matching the given\n\t * event type. Non-matching listeners get excluded early.\n\t * @param event the event to be propagated. Allows for excluding\n\t * non-matching listeners early, based on cached matching information.\n\t * @return a Collection of ApplicationListeners\n\t * @see org.springframework.context.ApplicationListener\n\t */\n\tprotected Collection<ApplicationListener<?>> getApplicationListeners(ApplicationEvent event) {\n\t\tClass<? extends ApplicationEvent> eventType = event.getClass();\n\t\tObject source = event.getSource();\n\t\tClass<?> sourceType = (source != null ? source.getClass() : null);\n\t\tListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);\n\t\tListenerRetriever retriever = this.retrieverCache.get(cacheKey);\n\t\tif (retriever != null) {\n\t\t\treturn retriever.getApplicationListeners();\n\t\t}\n\t\telse {\n\t\t\tretriever = new ListenerRetriever(true);\n\t\t\tLinkedList<ApplicationListener<?>> allListeners = new LinkedList<ApplicationListener<?>>();\n\t\t\tSet<ApplicationListener<?>> listeners;\n\t\t\tSet<String> listenerBeans;\n\t\t\tsynchronized (this.defaultRetriever) {\n\t\t\t\tlisteners = new LinkedHashSet<ApplicationListener<?>>(this.defaultRetriever.applicationListeners);\n\t\t\t\tlistenerBeans = new LinkedHashSet<String>(this.defaultRetriever.applicationListenerBeans);\n\t\t\t}\n\t\t\tfor (ApplicationListener<?> listener : listeners) {\n\t\t\t\tif (supportsEvent(listener, eventType, sourceType)) {\n\t\t\t\t\tretriever.applicationListeners.add(listener);\n\t\t\t\t\tallListeners.add(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!listenerBeans.isEmpty()) {\n\t\t\t\tBeanFactory beanFactory = getBeanFactory();\n\t\t\t\tfor (String listenerBeanName : listenerBeans) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> listenerType = beanFactory.getType(listenerBeanName);\n\t\t\t\t\t\tif (listenerType == null || supportsEvent(listenerType, event)) {\n\t\t\t\t\t\t\tApplicationListener<?> listener =\n\t\t\t\t\t\t\t\t\tbeanFactory.getBean(listenerBeanName, ApplicationListener.class);\n\t\t\t\t\t\t\tif (!allListeners.contains(listener) && supportsEvent(listener, eventType, sourceType)) {\n\t\t\t\t\t\t\t\tretriever.applicationListenerBeans.add(listenerBeanName);\n\t\t\t\t\t\t\t\tallListeners.add(listener);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t// Singleton listener instance (without backing bean definition) disappeared -\n\t\t\t\t\t\t// probably in the middle of the destruction phase\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tOrderComparator.sort(allListeners);\n\t\t\tthis.retrieverCache.put(cacheKey, retriever);\n\t\t\treturn allListeners;\n\t\t}\n\t}","commit_id":"cb41f42791acfa634d0bd3ccfa753eff50865563","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void listenersInApplicationContext() {\n\t\tStaticApplicationContext context = new StaticApplicationContext();\n\t\tcontext.registerBeanDefinition(\"listener1\", new RootBeanDefinition(MyOrderedListener1.class));\n\t\tRootBeanDefinition listener2 = new RootBeanDefinition(MyOrderedListener2.class);\n\t\tlistener2.getConstructorArgumentValues().addGenericArgumentValue(new RuntimeBeanReference(\"listener1\"));\n\t\tcontext.registerBeanDefinition(\"listener2\", listener2);\n\t\tcontext.refresh();\n\n\t\tMyOrderedListener1 listener1 = context.getBean(\"listener1\", MyOrderedListener1.class);\n\t\tMyEvent event1 = new MyEvent(context);\n\t\tcontext.publishEvent(event1);\n\t\tMyOtherEvent event2 = new MyOtherEvent(context);\n\t\tcontext.publishEvent(event2);\n\t\tMyEvent event3 = new MyEvent(context);\n\t\tcontext.publishEvent(event3);\n\t\tMyOtherEvent event4 = new MyOtherEvent(context);\n\t\tcontext.publishEvent(event4);\n\t\tassertTrue(listener1.seenEvents.contains(event1));\n\t\tassertTrue(listener1.seenEvents.contains(event2));\n\t\tassertTrue(listener1.seenEvents.contains(event3));\n\t\tassertTrue(listener1.seenEvents.contains(event4));\n\n\t\tlistener1.seenEvents.clear();\n\t\tcontext.publishEvent(event1);\n\t\tcontext.publishEvent(event2);\n\t\tcontext.publishEvent(event3);\n\t\tcontext.publishEvent(event4);\n\t\tassertTrue(listener1.seenEvents.contains(event1));\n\t\tassertTrue(listener1.seenEvents.contains(event2));\n\t\tassertTrue(listener1.seenEvents.contains(event3));\n\t\tassertTrue(listener1.seenEvents.contains(event4));\n\n\t\tcontext.close();\n\t}","id":22915,"modified_method":"@Test\n\tpublic void listenersInApplicationContext() {\n\t\tStaticApplicationContext context = new StaticApplicationContext();\n\t\tcontext.registerBeanDefinition(\"listener1\", new RootBeanDefinition(MyOrderedListener1.class));\n\t\tRootBeanDefinition listener2 = new RootBeanDefinition(MyOrderedListener2.class);\n\t\tlistener2.getConstructorArgumentValues().addGenericArgumentValue(new RuntimeBeanReference(\"listener1\"));\n\t\tlistener2.setLazyInit(true);\n\t\tcontext.registerBeanDefinition(\"listener2\", listener2);\n\t\tcontext.refresh();\n\t\tassertFalse(context.getDefaultListableBeanFactory().containsSingleton(\"listener2\"));\n\n\t\tMyOrderedListener1 listener1 = context.getBean(\"listener1\", MyOrderedListener1.class);\n\t\tMyOtherEvent event1 = new MyOtherEvent(context);\n\t\tcontext.publishEvent(event1);\n\t\tassertFalse(context.getDefaultListableBeanFactory().containsSingleton(\"listener2\"));\n\t\tMyEvent event2 = new MyEvent(context);\n\t\tcontext.publishEvent(event2);\n\t\tassertTrue(context.getDefaultListableBeanFactory().containsSingleton(\"listener2\"));\n\t\tMyEvent event3 = new MyEvent(context);\n\t\tcontext.publishEvent(event3);\n\t\tMyOtherEvent event4 = new MyOtherEvent(context);\n\t\tcontext.publishEvent(event4);\n\t\tassertTrue(listener1.seenEvents.contains(event1));\n\t\tassertTrue(listener1.seenEvents.contains(event2));\n\t\tassertTrue(listener1.seenEvents.contains(event3));\n\t\tassertTrue(listener1.seenEvents.contains(event4));\n\n\t\tlistener1.seenEvents.clear();\n\t\tcontext.publishEvent(event1);\n\t\tcontext.publishEvent(event2);\n\t\tcontext.publishEvent(event3);\n\t\tcontext.publishEvent(event4);\n\t\tassertTrue(listener1.seenEvents.contains(event1));\n\t\tassertTrue(listener1.seenEvents.contains(event2));\n\t\tassertTrue(listener1.seenEvents.contains(event3));\n\t\tassertTrue(listener1.seenEvents.contains(event4));\n\n\t\tcontext.close();\n\t}","commit_id":"cb41f42791acfa634d0bd3ccfa753eff50865563","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {\n\t\tClass<?> typeArg = GenericTypeResolver.resolveTypeArgument(this.delegate.getClass(), ApplicationListener.class);\n\t\tif (typeArg == null || typeArg.equals(ApplicationEvent.class)) {\n\t\t\tClass<?> targetClass = AopUtils.getTargetClass(this.delegate);\n\t\t\tif (targetClass != this.delegate.getClass()) {\n\t\t\t\ttypeArg = GenericTypeResolver.resolveTypeArgument(targetClass, ApplicationListener.class);\n\t\t\t}\n\t\t}\n\t\treturn (typeArg == null || typeArg.isAssignableFrom(eventType));\n\t}","id":22916,"modified_method":"@Override\n\tpublic boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {\n\t\tClass<?> declaredEventType = resolveDeclaredEventType(this.delegate.getClass());\n\t\tif (declaredEventType == null || declaredEventType.equals(ApplicationEvent.class)) {\n\t\t\tClass<?> targetClass = AopUtils.getTargetClass(this.delegate);\n\t\t\tif (targetClass != this.delegate.getClass()) {\n\t\t\t\tdeclaredEventType = resolveDeclaredEventType(targetClass);\n\t\t\t}\n\t\t}\n\t\treturn (declaredEventType == null || declaredEventType.isAssignableFrom(eventType));\n\t}","commit_id":"cb41f42791acfa634d0bd3ccfa753eff50865563","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void writeInternal(Message message, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tCharset charset = getCharset(contentType);\n\n\t\tif (MediaType.TEXT_HTML.isCompatibleWith(contentType)) {\n\t\t\tfinal OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tHtmlFormat.print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t}\n\t\telse if (MediaType.APPLICATION_JSON.isCompatibleWith(contentType)) {\n\t\t\tfinal OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tJsonFormat.print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t}\n\t\telse if (MediaType.TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tfinal OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tTextFormat.print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t}\n\t\telse if (MediaType.APPLICATION_XML.isCompatibleWith(contentType)) {\n\t\t\tfinal OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tXmlFormat.print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t}\n\t\telse if (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tsetProtoHeader(outputMessage, message);\n\t\t\tFileCopyUtils.copy(message.toByteArray(), outputMessage.getBody());\n\t\t}\n\t}","id":22917,"modified_method":"@Override\n\tprotected void writeInternal(Message message, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = getDefaultContentType(message);\n\t\t}\n\t\tCharset charset = contentType.getCharSet();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\tif (MediaType.TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\tOutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\t\tTextFormat.print(message, outputStreamWriter);\n\t\t\toutputStreamWriter.flush();\n\t\t}\n\t\telse if (MediaType.APPLICATION_JSON.isCompatibleWith(contentType)) {\n\t\t\tJSON_FORMAT.print(message, outputMessage.getBody(), charset);\n\t\t}\n\t\telse if (MediaType.APPLICATION_XML.isCompatibleWith(contentType)) {\n\t\t\tXML_FORMAT.print(message, outputMessage.getBody(), charset);\n\t\t}\n\t\telse if (MediaType.TEXT_HTML.isCompatibleWith(contentType)) {\n\t\t\tHTML_FORMAT.print(message, outputMessage.getBody(), charset);\n\t\t}\n\t\telse if (PROTOBUF.isCompatibleWith(contentType)) {\n\t\t\tsetProtoHeader(outputMessage, message);\n\t\t\tFileCopyUtils.copy(message.toByteArray(), outputMessage.getBody());\n\t\t}\n\t}","commit_id":"977734cc5908d3d438f3d13c41e10424d06c83f8","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tcontentType = (contentType != null ? contentType : PROTOBUF);\n\n\t\tCharset charset = getCharset(inputMessage.getHeaders());\n\t\tInputStreamReader reader = new InputStreamReader(inputMessage.getBody(), charset);\n\n\t\ttry {\n\t\t\tMessage.Builder builder = getMessageBuilder(clazz);\n\n\t\t\tif (MediaType.APPLICATION_JSON.isCompatibleWith(contentType)) {\n\t\t\t\tJsonFormat.merge(reader, this.extensionRegistry, builder);\n\t\t\t}\n\t\t\telse if (MediaType.TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\t\tTextFormat.merge(reader, this.extensionRegistry, builder);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_XML.isCompatibleWith(contentType)) {\n\t\t\t\tXmlFormat.merge(reader, this.extensionRegistry, builder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.mergeFrom(inputMessage.getBody(), this.extensionRegistry);\n\t\t\t}\n\t\t\treturn builder.build();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Could not read Protobuf message: \" + e.getMessage(), e);\n\t\t}\n\t}","id":22918,"modified_method":"@Override\n\tprotected Message readInternal(Class<? extends Message> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType = inputMessage.getHeaders().getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = PROTOBUF;\n\t\t}\n\t\tCharset charset = contentType.getCharSet();\n\t\tif (charset == null) {\n\t\t\tcharset = DEFAULT_CHARSET;\n\t\t}\n\n\t\ttry {\n\t\t\tMessage.Builder builder = getMessageBuilder(clazz);\n\t\t\tif (MediaType.TEXT_PLAIN.isCompatibleWith(contentType)) {\n\t\t\t\tInputStreamReader reader = new InputStreamReader(inputMessage.getBody(), charset);\n\t\t\t\tTextFormat.merge(reader, this.extensionRegistry, builder);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_JSON.isCompatibleWith(contentType)) {\n\t\t\t\tJSON_FORMAT.merge(inputMessage.getBody(), charset, this.extensionRegistry, builder);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_XML.isCompatibleWith(contentType)) {\n\t\t\t\tXML_FORMAT.merge(inputMessage.getBody(), charset, this.extensionRegistry, builder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.mergeFrom(inputMessage.getBody(), this.extensionRegistry);\n\t\t\t}\n\t\t\treturn builder.build();\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Could not read Protobuf message: \" + ex.getMessage(), ex);\n\t\t}\n\t}","commit_id":"977734cc5908d3d438f3d13c41e10424d06c83f8","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Construct a new instance with an {@link ExtensionRegistryInitializer}\n\t * that allows the registration of message extensions.\n\t */\n\tpublic ProtobufHttpMessageConverter(ExtensionRegistryInitializer registryInitializer) {\n\t\tsuper(PROTOBUF, MediaType.TEXT_PLAIN, MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON);\n\t\tif (registryInitializer != null) {\n\t\t\tregistryInitializer.initializeExtensionRegistry(this.extensionRegistry);\n\t\t}\n\t}","id":22919,"modified_method":"/**\n\t * Construct a new instance with an {@link ExtensionRegistryInitializer}\n\t * that allows the registration of message extensions.\n\t */\n\tpublic ProtobufHttpMessageConverter(ExtensionRegistryInitializer registryInitializer) {\n\t\tsuper(PROTOBUF, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML);\n\t\tif (registryInitializer != null) {\n\t\t\tregistryInitializer.initializeExtensionRegistry(this.extensionRegistry);\n\t\t}\n\t}","commit_id":"977734cc5908d3d438f3d13c41e10424d06c83f8","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Method getFinder(Class<?> entityClass) {\n\t\tString finderMethod = \"find\" + getEntityName(entityClass);\n\t\tMethod[] methods = entityClass.getDeclaredMethods();\n\t\tfor (Method method : methods) {\n\t\t\tif (Modifier.isStatic(method.getModifiers()) && method.getParameterTypes().length == 1 && method.getReturnType().equals(entityClass)) {\n\t\t\t\tif (method.getName().equals(finderMethod)) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":22920,"modified_method":"private Method getFinder(Class<?> entityClass) {\n\t\tString finderMethod = \"find\" + getEntityName(entityClass);\n\t\tMethod[] methods;\n\t\tboolean localOnlyFiltered;\n\t\ttry {\n\t\t\tmethods = entityClass.getDeclaredMethods();\n\t\t\tlocalOnlyFiltered = true;\n\t\t}\n\t\tcatch (SecurityException ex) {\n\t\t\t// Not allowed to access non-public methods...\n\t\t\t// Fallback: check locally declared public methods only.\n\t\t\tmethods = entityClass.getMethods();\n\t\t\tlocalOnlyFiltered = false;\n\t\t}\n\t\tfor (Method method : methods) {\n\t\t\tif (Modifier.isStatic(method.getModifiers()) && method.getName().equals(finderMethod) &&\n\t\t\t\t\tmethod.getParameterTypes().length == 1 && method.getReturnType().equals(entityClass) &&\n\t\t\t\t\t(localOnlyFiltered || method.getDeclaringClass().equals(entityClass))) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"381ccde48d11ef82c371789898e563233141b7ee","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Call postConstruct method on the specified instance recursively from deepest superclass to actual class.\n     *\n     * @param instance object to call postconstruct methods on\n     * @param clazz    (super) class to examine for postConstruct annotation.\n     * @throws IllegalAccessException if postConstruct method is inaccessible.\n     * @throws java.lang.reflect.InvocationTargetException\n     *                                if call fails\n     */\n    protected void postConstruct(Object instance, Class<?> clazz)\n            throws IllegalAccessException, InvocationTargetException {\n        Class<?> superClass = clazz.getSuperclass();\n        if (superClass != Object.class) {\n            postConstruct(instance, superClass);\n        }\n\n        Method[] methods = clazz.getDeclaredMethods();\n        Method postConstruct = null;\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(PostConstruct.class)) {\n                if ((postConstruct != null)\n                        || (method.getParameterTypes().length != 0)\n                        || (Modifier.isStatic(method.getModifiers()))\n                        || (method.getExceptionTypes().length > 0)\n                        || (!method.getReturnType().getName().equals(\"void\"))) {\n                    throw new IllegalArgumentException(\"Invalid PostConstruct annotation\");\n                }\n                postConstruct = method;\n            }\n        }\n\n        // At the end the postconstruct annotated\n        // method is invoked\n        if (postConstruct != null) {\n            boolean accessibility = postConstruct.isAccessible();\n            postConstruct.setAccessible(true);\n            postConstruct.invoke(instance);\n            postConstruct.setAccessible(accessibility);\n        }\n\n    }","id":22921,"modified_method":"/**\n     * Call postConstruct method on the specified instance recursively from deepest superclass to actual class.\n     *\n     * @param instance object to call postconstruct methods on\n     * @param clazz    (super) class to examine for postConstruct annotation.\n     * @throws IllegalAccessException if postConstruct method is inaccessible.\n     * @throws java.lang.reflect.InvocationTargetException\n     *                                if call fails\n     */\n    protected void postConstruct(Object instance, final Class<?> clazz)\n            throws IllegalAccessException, InvocationTargetException {\n        Class<?> superClass = clazz.getSuperclass();\n        if (superClass != Object.class) {\n            postConstruct(instance, superClass);\n        }\n\n        Method[] methods = null;\n        if (Globals.IS_SECURITY_ENABLED) {\n            methods = AccessController.doPrivileged(\n                    new PrivilegedAction<Method[]>(){\n                public Method[] run(){\n                    return clazz.getDeclaredMethods();\n                }\n            });\n        } else {\n            methods = clazz.getDeclaredMethods();\n        }\n        Method postConstruct = null;\n        for (Method method : methods) {\n            if (method.isAnnotationPresent(PostConstruct.class)) {\n                if ((postConstruct != null)\n                        || (method.getParameterTypes().length != 0)\n                        || (Modifier.isStatic(method.getModifiers()))\n                        || (method.getExceptionTypes().length > 0)\n                        || (!method.getReturnType().getName().equals(\"void\"))) {\n                    throw new IllegalArgumentException(\"Invalid PostConstruct annotation\");\n                }\n                postConstruct = method;\n            }\n        }\n\n        // At the end the postconstruct annotated\n        // method is invoked\n        if (postConstruct != null) {\n            boolean accessibility = postConstruct.isAccessible();\n            postConstruct.setAccessible(true);\n            postConstruct.invoke(instance);\n            postConstruct.setAccessible(accessibility);\n        }\n\n    }","commit_id":"428c03bd89e4603cf726a67881f5da81617013c9","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Inject resources in specified instance.\n     *\n     * @param instance   instance to inject into\n     * @param injections map of injections for this class from xml deployment descriptor\n     * @throws IllegalAccessException       if injection target is inaccessible\n     * @throws javax.naming.NamingException if value cannot be looked up in jndi\n     * @throws java.lang.reflect.InvocationTargetException\n     *                                      if injection fails\n     */\n    protected void processAnnotations(Object instance, Map<String, String> injections)\n            throws IllegalAccessException, InvocationTargetException, NamingException {\n\n        if (context == null) {\n            // No resource injection\n            return;\n        }\n\n        Class<?> clazz = instance.getClass();\n        \n        while (clazz != null) {\n            // Initialize fields annotations\n            Field[] fields = clazz.getDeclaredFields();\n            for (Field field : fields) {\n                if (injections != null && injections.containsKey(field.getName())) {\n                    lookupFieldResource(context, instance, field,\n                            injections.get(field.getName()), clazz);\n                } else if (field.isAnnotationPresent(Resource.class)) {\n                    Resource annotation = field.getAnnotation(Resource.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(EJB.class)) {\n                    EJB annotation = field.getAnnotation(EJB.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(WebServiceRef.class)) {\n                    WebServiceRef annotation =\n                            field.getAnnotation(WebServiceRef.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(PersistenceContext.class)) {\n                    PersistenceContext annotation =\n                            field.getAnnotation(PersistenceContext.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(PersistenceUnit.class)) {\n                    PersistenceUnit annotation =\n                            field.getAnnotation(PersistenceUnit.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                }\n            }\n    \n            // Initialize methods annotations\n            Method[] methods = clazz.getDeclaredMethods();\n            for (Method method : methods) {\n                String methodName = method.getName();\n                if (injections != null && methodName.startsWith(\"set\") && methodName.length() > 3) {\n                    String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n                    if (injections.containsKey(fieldName)) {\n                        lookupMethodResource(context, instance, method,\n                                injections.get(fieldName), clazz);\n                        break;\n                    }\n                }\n                if (method.isAnnotationPresent(Resource.class)) {\n                    Resource annotation = method.getAnnotation(Resource.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(EJB.class)) {\n                    EJB annotation = method.getAnnotation(EJB.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(WebServiceRef.class)) {\n                    WebServiceRef annotation =\n                            method.getAnnotation(WebServiceRef.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(PersistenceContext.class)) {\n                    PersistenceContext annotation =\n                            method.getAnnotation(PersistenceContext.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(PersistenceUnit.class)) {\n                    PersistenceUnit annotation =\n                            method.getAnnotation(PersistenceUnit.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                }\n            }\n            clazz = clazz.getSuperclass();\n        }\n\n    }","id":22922,"modified_method":"/**\n     * Inject resources in specified instance.\n     *\n     * @param instance   instance to inject into\n     * @param injections map of injections for this class from xml deployment descriptor\n     * @throws IllegalAccessException       if injection target is inaccessible\n     * @throws javax.naming.NamingException if value cannot be looked up in jndi\n     * @throws java.lang.reflect.InvocationTargetException\n     *                                      if injection fails\n     */\n    protected void processAnnotations(Object instance, Map<String, String> injections)\n            throws IllegalAccessException, InvocationTargetException, NamingException {\n\n        if (context == null) {\n            // No resource injection\n            return;\n        }\n\n        Class<?> clazz = instance.getClass();\n        \n        while (clazz != null) {\n            // Initialize fields annotations\n            Field[] fields = null;\n            if (Globals.IS_SECURITY_ENABLED) {\n                final Class<?> clazz2 = clazz;\n                fields = AccessController.doPrivileged(\n                        new PrivilegedAction<Field[]>(){\n                    public Field[] run(){\n                        return clazz2.getDeclaredFields();\n                    }\n                });\n            } else {\n                fields = clazz.getDeclaredFields();\n            }\n            for (Field field : fields) {\n                if (injections != null && injections.containsKey(field.getName())) {\n                    lookupFieldResource(context, instance, field,\n                            injections.get(field.getName()), clazz);\n                } else if (field.isAnnotationPresent(Resource.class)) {\n                    Resource annotation = field.getAnnotation(Resource.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(EJB.class)) {\n                    EJB annotation = field.getAnnotation(EJB.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(WebServiceRef.class)) {\n                    WebServiceRef annotation =\n                            field.getAnnotation(WebServiceRef.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(PersistenceContext.class)) {\n                    PersistenceContext annotation =\n                            field.getAnnotation(PersistenceContext.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                } else if (field.isAnnotationPresent(PersistenceUnit.class)) {\n                    PersistenceUnit annotation =\n                            field.getAnnotation(PersistenceUnit.class);\n                    lookupFieldResource(context, instance, field,\n                            annotation.name(), clazz);\n                }\n            }\n    \n            // Initialize methods annotations\n            Method[] methods = null;\n            if (Globals.IS_SECURITY_ENABLED) {\n                final Class<?> clazz2 = clazz;\n                methods = AccessController.doPrivileged(\n                        new PrivilegedAction<Method[]>(){\n                    public Method[] run(){\n                        return clazz2.getDeclaredMethods();\n                    }\n                });\n            } else {\n                methods = clazz.getDeclaredMethods();\n            }\n            for (Method method : methods) {\n                String methodName = method.getName();\n                if (injections != null && methodName.startsWith(\"set\") && methodName.length() > 3) {\n                    String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n                    if (injections.containsKey(fieldName)) {\n                        lookupMethodResource(context, instance, method,\n                                injections.get(fieldName), clazz);\n                        break;\n                    }\n                }\n                if (method.isAnnotationPresent(Resource.class)) {\n                    Resource annotation = method.getAnnotation(Resource.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(EJB.class)) {\n                    EJB annotation = method.getAnnotation(EJB.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(WebServiceRef.class)) {\n                    WebServiceRef annotation =\n                            method.getAnnotation(WebServiceRef.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(PersistenceContext.class)) {\n                    PersistenceContext annotation =\n                            method.getAnnotation(PersistenceContext.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                } else if (method.isAnnotationPresent(PersistenceUnit.class)) {\n                    PersistenceUnit annotation =\n                            method.getAnnotation(PersistenceUnit.class);\n                    lookupMethodResource(context, instance, method,\n                            annotation.name(), clazz);\n                }\n            }\n            clazz = clazz.getSuperclass();\n        }\n\n    }","commit_id":"428c03bd89e4603cf726a67881f5da81617013c9","url":"https://github.com/apache/tomcat"},{"original_method":"private <T> RuleSourceSchema<T> doExtract(final Class<T> source) {\n        final ModelType<T> type = ModelType.of(source);\n        DefaultMethodModelRuleExtractionContext context = new DefaultMethodModelRuleExtractionContext(type, this);\n\n        // TODO - exceptions thrown here should point to some extensive documentation on the concept of class rule sources\n\n        validateClass(source, context);\n\n        Factory<T> factory = Modifier.isAbstract(source.getModifiers()) ? new AbstractRuleSourceFactory<T>(new RuleSourceSchema<T>(type, Collections.<ExtractedModelRule>emptyList(), null), proxyFactory) : new ConcreteRuleSourceFactory<T>(type);\n        final Method[] methods = source.getDeclaredMethods();\n\n        // sort for determinism\n        Arrays.sort(methods, Ordering.usingToString());\n\n        ImmutableList.Builder<ExtractedModelRule> registrations = ImmutableList.builder();\n\n        for (Method method : methods) {\n            MethodRuleDefinition<?, ?> ruleDefinition = DefaultMethodRuleDefinition.create(source, method, factory);\n            ExtractedModelRule registration = getMethodHandler(ruleDefinition, method, context);\n            if (registration != null) {\n                registrations.add(registration);\n            }\n        }\n\n        if (context.hasProblems()) {\n            throw new InvalidModelRuleDeclarationException(context.problems.format());\n        }\n\n        return new RuleSourceSchema<T>(type, registrations.build(), factory);\n    }","id":22923,"modified_method":"private <T> RuleSourceSchema<T> doExtract(final Class<T> source) {\n        final ModelType<T> type = ModelType.of(source);\n        DefaultMethodModelRuleExtractionContext context = new DefaultMethodModelRuleExtractionContext(type, this);\n\n        // TODO - exceptions thrown here should point to some extensive documentation on the concept of class rule sources\n\n        validateClass(source, context);\n\n        StructSchema<T> schema = (StructSchema<T>) schemaStore.getSchema(source);\n        Factory<T> factory = Modifier.isAbstract(source.getModifiers()) ? new AbstractRuleSourceFactory<T>(new RuleSourceSchema<T>(type, Collections.<ExtractedModelRule>emptyList(), null), proxyFactory) : new ConcreteRuleSourceFactory<T>(type);\n\n        // sort for determinism\n        Set<Method> methods = new TreeSet<Method>(Ordering.usingToString());\n        methods.addAll(Arrays.asList(source.getDeclaredMethods()));\n\n        for (ModelProperty<?> property : schema.getProperties()) {\n            for (WeaklyTypeReferencingMethod<?, ?> method : property.getGetters()) {\n                methods.remove(method.getMethod());\n            }\n            if (property.getSetter() != null) {\n                methods.remove(property.getSetter().getMethod());\n            }\n        }\n\n        ImmutableList.Builder<ExtractedModelRule> registrations = ImmutableList.builder();\n        for (Method method : methods) {\n            MethodRuleDefinition<?, ?> ruleDefinition = DefaultMethodRuleDefinition.create(source, method, factory);\n            ExtractedModelRule registration = getMethodHandler(ruleDefinition, method, context);\n            if (registration != null) {\n                registrations.add(registration);\n            }\n        }\n\n        if (context.hasProblems()) {\n            throw new InvalidModelRuleDeclarationException(context.problems.format());\n        }\n\n        return new RuleSourceSchema<T>(type, registrations.build(), factory);\n    }","commit_id":"bb250218233cc0d02b10f73d2e51441d2a08bbc2","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelRuleExtractor(Iterable<MethodModelRuleExtractor> handlers, ManagedProxyFactory proxyFactory) {\n        this.handlers = handlers;\n        this.proxyFactory = proxyFactory;\n    }","id":22924,"modified_method":"public ModelRuleExtractor(Iterable<MethodModelRuleExtractor> handlers, ManagedProxyFactory proxyFactory) {\n        this.handlers = handlers;\n        this.proxyFactory = proxyFactory;\n        this.schemaStore = new DefaultModelSchemaStore(new DefaultModelSchemaExtractor(Collections.singletonList(new UnmanagedImplStructStrategy(new ModelSchemaAspectExtractor()))));\n    }","commit_id":"bb250218233cc0d02b10f73d2e51441d2a08bbc2","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Gets the list of methods sorted by A..Z method name.\n     *\n     * @return the methods.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public List<MethodInfo> getMethods() {\n        if (operations.isEmpty()) {\n            return Collections.EMPTY_LIST;\n        }\n\n        List<MethodInfo> methods = new ArrayList<MethodInfo>();\n        for (Collection<MethodInfo> col : operations.values()) {\n            methods.addAll(col);\n        }\n\n        // sort the methods by name A..Z\n        Collections.sort(methods, new Comparator<MethodInfo>() {\n            public int compare(MethodInfo o1, MethodInfo o2) {\n                return o1.getMethod().getName().compareTo(o2.getMethod().getName());\n            }\n        });\n        return methods;\n    }","id":22925,"modified_method":"/**\n     * Gets the list of methods sorted by A..Z method name.\n     *\n     * @return the methods.\n     */\n    public List<MethodInfo> getMethods() {\n        if (operations.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        List<MethodInfo> methods = new ArrayList<MethodInfo>();\n        for (Collection<MethodInfo> col : operations.values()) {\n            methods.addAll(col);\n        }\n\n        // sort the methods by name A..Z\n        Collections.sort(methods, new Comparator<MethodInfo>() {\n            public int compare(MethodInfo o1, MethodInfo o2) {\n                return o1.getMethod().getName().compareTo(o2.getMethod().getName());\n            }\n        });\n        return methods;\n    }","commit_id":"0789318c9c58e608af5773501af181b858f138af","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected MethodInfo createMethodInfo(Class clazz, Method method) {\n        Class[] parameterTypes = method.getParameterTypes();\n        List<Annotation>[] parametersAnnotations = collectParameterAnnotations(clazz, method);\n\n        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();\n        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();\n\n        boolean hasCustomAnnotation = false;\n        boolean hasHandlerAnnotation = ObjectHelper.hasAnnotation(method.getAnnotations(), Handler.class);\n\n        int size = parameterTypes.length;\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new Object[]{clazz, method, size});\n        }\n\n        for (int i = 0; i < size; i++) {\n            Class parameterType = parameterTypes[i];\n            Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new Annotation[parametersAnnotations[i].size()]);\n            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);\n            hasCustomAnnotation |= expression != null;\n\n            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations, expression);\n            LOG.trace(\"Parameter #{}: {}\", i, parameterInfo);\n            parameters.add(parameterInfo);\n            if (expression == null) {\n                boolean bodyAnnotation = ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);\n                LOG.trace(\"Parameter #{} has @Body annotation\", i);\n                hasCustomAnnotation |= bodyAnnotation;\n                if (bodyParameters.isEmpty()) {\n                    // okay we have not yet set the body parameter and we have found\n                    // the candidate now to use as body parameter\n                    if (Exchange.class.isAssignableFrom(parameterType)) {\n                        // use exchange\n                        expression = ExpressionBuilder.exchangeExpression();\n                    } else {\n                        // lets assume its the body and it must be mandatory convertable to the parameter type\n                        // but we allow null bodies in case the message really contains a null body\n                        expression = ExpressionBuilder.mandatoryBodyExpression(parameterType, true);\n                    }\n                    LOG.trace(\"Parameter #{} is the body parameter using expression {}\", i, expression);\n                    parameterInfo.setExpression(expression);\n                    bodyParameters.add(parameterInfo);\n                } else {\n                    // will ignore the expression for parameter evaluation\n                }\n            }\n            LOG.trace(\"Parameter #{} has parameter info: \", i, parameterInfo);\n        }\n\n        // now lets add the method to the repository\n        return new MethodInfo(camelContext, clazz, method, parameters, bodyParameters, hasCustomAnnotation, hasHandlerAnnotation);\n    }","id":22926,"modified_method":"protected MethodInfo createMethodInfo(Class<?> clazz, Method method) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        List<Annotation>[] parametersAnnotations = collectParameterAnnotations(clazz, method);\n\n        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();\n        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();\n\n        boolean hasCustomAnnotation = false;\n        boolean hasHandlerAnnotation = ObjectHelper.hasAnnotation(method.getAnnotations(), Handler.class);\n\n        int size = parameterTypes.length;\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new Object[]{clazz, method, size});\n        }\n\n        for (int i = 0; i < size; i++) {\n            Class<?> parameterType = parameterTypes[i];\n            Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new Annotation[parametersAnnotations[i].size()]);\n            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);\n            hasCustomAnnotation |= expression != null;\n\n            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations, expression);\n            LOG.trace(\"Parameter #{}: {}\", i, parameterInfo);\n            parameters.add(parameterInfo);\n            if (expression == null) {\n                boolean bodyAnnotation = ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);\n                LOG.trace(\"Parameter #{} has @Body annotation\", i);\n                hasCustomAnnotation |= bodyAnnotation;\n                if (bodyParameters.isEmpty()) {\n                    // okay we have not yet set the body parameter and we have found\n                    // the candidate now to use as body parameter\n                    if (Exchange.class.isAssignableFrom(parameterType)) {\n                        // use exchange\n                        expression = ExpressionBuilder.exchangeExpression();\n                    } else {\n                        // lets assume its the body and it must be mandatory convertable to the parameter type\n                        // but we allow null bodies in case the message really contains a null body\n                        expression = ExpressionBuilder.mandatoryBodyExpression(parameterType, true);\n                    }\n                    LOG.trace(\"Parameter #{} is the body parameter using expression {}\", i, expression);\n                    parameterInfo.setExpression(expression);\n                    bodyParameters.add(parameterInfo);\n                } else {\n                    // will ignore the expression for parameter evaluation\n                }\n            }\n            LOG.trace(\"Parameter #{} has parameter info: \", i, parameterInfo);\n        }\n\n        // now lets add the method to the repository\n        return new MethodInfo(camelContext, clazz, method, parameters, bodyParameters, hasCustomAnnotation, hasHandlerAnnotation);\n    }","commit_id":"0789318c9c58e608af5773501af181b858f138af","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Introspects the given class\n     *\n     * @param clazz the class\n     */\n    protected void introspect(Class<?> clazz) {\n        // get the target clazz as it could potentially have been enhanced by CGLIB etc.\n        clazz = getTargetClass(clazz);\n        ObjectHelper.notNull(clazz, \"clazz\", this);\n\n        LOG.trace(\"Introspecting class: {}\", clazz);\n\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            boolean valid = isValidMethod(clazz, method);\n            LOG.trace(\"Method: {} is valid: {}\", method, valid);\n            if (valid) {\n                introspect(clazz, method);\n            }\n        }\n\n        Class<?> superclass = clazz.getSuperclass();\n        if (superclass != null && !superclass.equals(Object.class)) {\n            introspect(superclass);\n        }\n    }","id":22927,"modified_method":"/**\n     * Introspects the given class\n     *\n     * @param clazz the class\n     */\n    protected void introspect(Class<?> clazz) {\n        // get the target clazz as it could potentially have been enhanced by CGLIB etc.\n        clazz = getTargetClass(clazz);\n        ObjectHelper.notNull(clazz, \"clazz\", this);\n\n        LOG.trace(\"Introspecting class: {}\", clazz);\n\n        // if the class is not public then fallback and use interface methods if possible\n        // this allow Camel to invoke private beans which implements interfaces\n        List<Method> methods = Arrays.asList(clazz.getDeclaredMethods());\n        if (!Modifier.isPublic(clazz.getModifiers())) {\n            LOG.trace(\"Preferring interface methods as class: {} is not public accessible\", clazz);\n            List<Method> interfaceMethods = getInterfaceMethods(clazz);\n            \n            // still keep non-accessible class methods to provide more specific Exception if method is non-accessible\n            interfaceMethods.addAll(methods);\n            methods = interfaceMethods;\n        }\n        \n        for (Method method : methods) {\n            boolean valid = isValidMethod(clazz, method);\n            LOG.trace(\"Method: {} is valid: {}\", method, valid);\n            if (valid) {\n                introspect(clazz, method);\n            }\n        }\n\n        Class<?> superclass = clazz.getSuperclass();\n        if (superclass != null && !superclass.equals(Object.class)) {\n            introspect(superclass);\n        }\n    }","commit_id":"0789318c9c58e608af5773501af181b858f138af","url":"https://github.com/apache/camel"},{"original_method":"private boolean matchMethod(Method method, String methodName) {\n        if (methodName == null) {\n            return true;\n        }\n\n        if (methodName.contains(\"(\") && !methodName.endsWith(\")\")) {\n            throw new IllegalArgumentException(\"Name must have both starting and ending parenthesis, was: \" + methodName);\n        }\n\n        // do not use qualifier for name matching\n        String name = methodName;\n        if (name.contains(\"(\")) {\n            name = ObjectHelper.before(name, \"(\");\n        }\n\n        // must match name\n        if (!name.equals(method.getName())) {\n            return false;\n        }\n\n        // match qualifier types which is used to select among overloaded methods\n        String types = ObjectHelper.between(methodName, \"(\", \")\");\n        if (types != null) {\n            // we must qualify based on types to match method\n            Iterator it = ObjectHelper.createIterator(types);\n            for (int i = 0; i < method.getParameterTypes().length; i++) {\n                if (it.hasNext()) {\n                    Class<?> parameterType = method.getParameterTypes()[i];\n\n                    String qualifyType = (String) it.next();\n                    if (ObjectHelper.isEmpty(qualifyType)) {\n                        continue;\n                    }\n                    // trim the type\n                    qualifyType = qualifyType.trim();\n\n                    if (\"*\".equals(qualifyType)) {\n                        // * is a wildcard so we accept and match that parameter type\n                        continue;\n                    }\n\n                    if (BeanHelper.isValidParameterValue(qualifyType)) {\n                        // its a parameter value, so continue to next parameter\n                        // as we should only check for FQN/type parameters\n                        continue;\n                    }\n\n                    // if qualify type indeed is a class, then it must be assignable with the parameter type\n                    Boolean assignable = BeanHelper.isAssignableToExpectedType(getCamelContext().getClassResolver(), qualifyType, parameterType);\n                    // the method will return null if the qualifyType is not a class\n                    if (assignable != null && !assignable) {\n                        return false;\n                    }\n\n                } else {\n                    // there method has more parameters than was specified in the method name qualifiers\n                    return false;\n                }\n            }\n\n            // if the method has no more types then we can only regard it as matched\n            // if there are no more qualifiers\n            if (it.hasNext()) {\n                return false;\n            }\n        }\n\n        // the method matched\n        return true;\n    }","id":22928,"modified_method":"private boolean matchMethod(Method method, String methodName) {\n        if (methodName == null) {\n            return true;\n        }\n\n        if (methodName.contains(\"(\") && !methodName.endsWith(\")\")) {\n            throw new IllegalArgumentException(\"Name must have both starting and ending parenthesis, was: \" + methodName);\n        }\n\n        // do not use qualifier for name matching\n        String name = methodName;\n        if (name.contains(\"(\")) {\n            name = ObjectHelper.before(name, \"(\");\n        }\n\n        // must match name\n        if (!name.equals(method.getName())) {\n            return false;\n        }\n\n        // match qualifier types which is used to select among overloaded methods\n        String types = ObjectHelper.between(methodName, \"(\", \")\");\n        if (types != null) {\n            // we must qualify based on types to match method\n            Iterator<?> it = ObjectHelper.createIterator(types);\n            for (int i = 0; i < method.getParameterTypes().length; i++) {\n                if (it.hasNext()) {\n                    Class<?> parameterType = method.getParameterTypes()[i];\n\n                    String qualifyType = (String) it.next();\n                    if (ObjectHelper.isEmpty(qualifyType)) {\n                        continue;\n                    }\n                    // trim the type\n                    qualifyType = qualifyType.trim();\n\n                    if (\"*\".equals(qualifyType)) {\n                        // * is a wildcard so we accept and match that parameter type\n                        continue;\n                    }\n\n                    if (BeanHelper.isValidParameterValue(qualifyType)) {\n                        // its a parameter value, so continue to next parameter\n                        // as we should only check for FQN/type parameters\n                        continue;\n                    }\n\n                    // if qualify type indeed is a class, then it must be assignable with the parameter type\n                    Boolean assignable = BeanHelper.isAssignableToExpectedType(getCamelContext().getClassResolver(), qualifyType, parameterType);\n                    // the method will return null if the qualifyType is not a class\n                    if (assignable != null && !assignable) {\n                        return false;\n                    }\n\n                } else {\n                    // there method has more parameters than was specified in the method name qualifiers\n                    return false;\n                }\n            }\n\n            // if the method has no more types then we can only regard it as matched\n            // if there are no more qualifiers\n            if (it.hasNext()) {\n                return false;\n            }\n        }\n\n        // the method matched\n        return true;\n    }","commit_id":"0789318c9c58e608af5773501af181b858f138af","url":"https://github.com/apache/camel"},{"original_method":"private MethodInfo chooseMethodWithMatchingBody(Exchange exchange, Collection<MethodInfo> operationList,\n                                                    List<MethodInfo> operationsWithCustomAnnotation)\n        throws AmbiguousMethodCallException {\n        // lets see if we can find a method who's body param type matches the message body\n        Message in = exchange.getIn();\n        Object body = in.getBody();\n        if (body != null) {\n            Class bodyType = body.getClass();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Matching for method with a single parameter that matches type: {}\", bodyType.getCanonicalName());\n            }\n\n            List<MethodInfo> possibles = new ArrayList<MethodInfo>();\n            List<MethodInfo> possiblesWithException = new ArrayList<MethodInfo>();\n            for (MethodInfo methodInfo : operationList) {\n                // test for MEP pattern matching\n                boolean out = exchange.getPattern().isOutCapable();\n                if (out && methodInfo.isReturnTypeVoid()) {\n                    // skip this method as the MEP is Out so the method must return something\n                    continue;\n                }\n\n                // try to match the arguments\n                if (methodInfo.bodyParameterMatches(bodyType)) {\n                    LOG.trace(\"Found a possible method: {}\", methodInfo);\n                    if (methodInfo.hasExceptionParameter()) {\n                        // methods with accepts exceptions\n                        possiblesWithException.add(methodInfo);\n                    } else {\n                        // regular methods with no exceptions\n                        possibles.add(methodInfo);\n                    }\n                }\n            }\n\n            // find best suited method to use\n            return chooseBestPossibleMethodInfo(exchange, operationList, body, possibles, possiblesWithException, operationsWithCustomAnnotation);\n        }\n\n        // no match so return null\n        return null;\n    }","id":22929,"modified_method":"private MethodInfo chooseMethodWithMatchingBody(Exchange exchange, Collection<MethodInfo> operationList,\n                                                    List<MethodInfo> operationsWithCustomAnnotation)\n        throws AmbiguousMethodCallException {\n        // lets see if we can find a method who's body param type matches the message body\n        Message in = exchange.getIn();\n        Object body = in.getBody();\n        if (body != null) {\n            Class<?> bodyType = body.getClass();\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Matching for method with a single parameter that matches type: {}\", bodyType.getCanonicalName());\n            }\n\n            List<MethodInfo> possibles = new ArrayList<MethodInfo>();\n            List<MethodInfo> possiblesWithException = new ArrayList<MethodInfo>();\n            for (MethodInfo methodInfo : operationList) {\n                // test for MEP pattern matching\n                boolean out = exchange.getPattern().isOutCapable();\n                if (out && methodInfo.isReturnTypeVoid()) {\n                    // skip this method as the MEP is Out so the method must return something\n                    continue;\n                }\n\n                // try to match the arguments\n                if (methodInfo.bodyParameterMatches(bodyType)) {\n                    LOG.trace(\"Found a possible method: {}\", methodInfo);\n                    if (methodInfo.hasExceptionParameter()) {\n                        // methods with accepts exceptions\n                        possiblesWithException.add(methodInfo);\n                    } else {\n                        // regular methods with no exceptions\n                        possibles.add(methodInfo);\n                    }\n                }\n            }\n\n            // find best suited method to use\n            return chooseBestPossibleMethodInfo(exchange, operationList, body, possibles, possiblesWithException, operationsWithCustomAnnotation);\n        }\n\n        // no match so return null\n        return null;\n    }","commit_id":"0789318c9c58e608af5773501af181b858f138af","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void remove(String id) {\n        V value = this.factory.tryValue(id);\n        if (value != null) {\n            Session<L> session = this.factory.createSession(id, value);\n            if (session.isValid() && session.getMetaData().isExpired()) {\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s has expired.\", id);\n                session.invalidate();\n            }\n        }\n    }","id":22930,"modified_method":"@Override\n    public void remove(String id) {\n        V value = this.factory.tryValue(id);\n        if (value != null) {\n            ImmutableSessionMetaData metaData = this.factory.createImmutableSessionMetaData(id, value);\n            if (metaData.isExpired()) {\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s has expired.\", id);\n                this.remover.remove(id);\n            }\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ExpiredSessionRemover(SessionFactory<V, L> factory) {\n        this.factory = factory;\n    }","id":22931,"modified_method":"public ExpiredSessionRemover(SessionMetaDataFactory<V, L> factory, Remover<String> remover) {\n        this.factory = factory;\n        this.remover = remover;\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void test() {\n        SessionFactory<Object, Object> factory = mock(SessionFactory.class);\n        Remover<String> remover = new ExpiredSessionRemover<>(factory);\n        Session<Object> validSession = mock(Session.class);\n        Session<Object> expiredSession = mock(Session.class);\n        Session<Object> invalidSession = mock(Session.class);\n        SessionMetaData validMetaData = mock(SessionMetaData.class);\n        SessionMetaData expiredMetaData = mock(SessionMetaData.class);\n        String missingSessionId = \"missing\";\n        String expiredSessionId = \"expired\";\n        String validSessionId = \"valid\";\n        String invalidSessionId = \"invalid\";\n        Object expiredValue = new Object();\n        Object validValue = new Object();\n        Object invalidValue = new Object();\n        \n        when(factory.tryValue(missingSessionId)).thenReturn(null);\n        when(factory.tryValue(expiredSessionId)).thenReturn(expiredValue);\n        when(factory.tryValue(validSessionId)).thenReturn(validValue);\n        when(factory.tryValue(invalidSessionId)).thenReturn(invalidValue);\n        \n        when(factory.createSession(expiredSessionId, expiredValue)).thenReturn(expiredSession);\n        when(factory.createSession(validSessionId, validValue)).thenReturn(validSession);\n        when(factory.createSession(invalidSessionId, invalidValue)).thenReturn(invalidSession);\n        \n        when(expiredSession.isValid()).thenReturn(true);\n        when(validSession.isValid()).thenReturn(true);\n        when(invalidSession.isValid()).thenReturn(false);\n        \n        when(expiredSession.getMetaData()).thenReturn(expiredMetaData);\n        when(validSession.getMetaData()).thenReturn(validMetaData);\n        when(invalidSession.getMetaData()).thenReturn(validMetaData);\n        \n        when(expiredMetaData.isExpired()).thenReturn(true);\n        when(validMetaData.isExpired()).thenReturn(false);\n        \n        remover.remove(missingSessionId);\n        remover.remove(expiredSessionId);\n        remover.remove(validSessionId);\n        \n        verify(expiredSession).invalidate();\n        verify(validSession, never()).invalidate();\n    }","id":22932,"modified_method":"@Test\n    public void test() {\n        SessionMetaDataFactory<Object, Object> factory = mock(SessionMetaDataFactory.class);\n        Remover<String> remover = mock(Remover.class);\n        ImmutableSessionMetaData validMetaData = mock(ImmutableSessionMetaData.class);\n        ImmutableSessionMetaData expiredMetaData = mock(ImmutableSessionMetaData.class);\n        String missingSessionId = \"missing\";\n        String expiredSessionId = \"expired\";\n        String validSessionId = \"valid\";\n        Object expiredValue = new Object();\n        Object validValue = new Object();\n\n        Remover<String> subject = new ExpiredSessionRemover<>(factory, remover);\n\n        when(factory.tryValue(missingSessionId)).thenReturn(null);\n        when(factory.tryValue(expiredSessionId)).thenReturn(expiredValue);\n        when(factory.tryValue(validSessionId)).thenReturn(validValue);\n        \n        when(factory.createImmutableSessionMetaData(expiredSessionId, expiredValue)).thenReturn(expiredMetaData);\n        when(factory.createImmutableSessionMetaData(validSessionId, validValue)).thenReturn(validMetaData);\n\n        when(expiredMetaData.isExpired()).thenReturn(true);\n        when(validMetaData.isExpired()).thenReturn(false);\n\n        subject.remove(missingSessionId);\n        subject.remove(expiredSessionId);\n        subject.remove(validSessionId);\n\n        verify(remover).remove(expiredSessionId);\n        verify(remover, never()).remove(validSessionId);\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@CacheEntryActivated\n    public void activated(CacheEntryActivatedEvent<SessionCreationMetaDataKey, ?> event) {\n        if (!event.isPre() && !this.persistent) {\n            this.executor.execute(() -> {\n                String id = event.getKey().getValue();\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s was activated\", id);\n                V value = this.factory.findValue(id);\n                if (value != null) {\n                    ImmutableSession session = this.factory.createImmutableSession(id, value);\n                    triggerPostActivationEvents(session);\n                }\n            });\n        }\n    }","id":22933,"modified_method":"@CacheEntryActivated\n    public void activated(CacheEntryActivatedEvent<SessionCreationMetaDataKey, ?> event) {\n        if (!event.isPre() && !this.persistent) {\n            this.executor.execute(() -> {\n                String id = event.getKey().getValue();\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s was activated\", id);\n                Map.Entry<MV, AV> value = this.factory.findValue(id);\n                if (value != null) {\n                    ImmutableSession session = this.factory.createImmutableSession(id, value);\n                    triggerPostActivationEvents(session);\n                }\n            });\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void schedule(Cache<? extends Key<String>, ?> cache, Locality oldLocality, Locality newLocality) {\n        // Iterate over sessions in memory\n        try (Stream<? extends Key<String>> keys = cache.getAdvancedCache().withFlags(Flag.CACHE_MODE_LOCAL, Flag.SKIP_CACHE_LOAD).keySet().stream()) {\n            // If we are the new primary owner of this session then schedule expiration of this session locally\n            keys.filter(this.filter).filter(key -> !oldLocality.isLocal(key) && newLocality.isLocal(key)).map(key -> key.getValue()).forEach(id -> {\n                Batch batch = this.batcher.createBatch();\n                try {\n                    // We need to lookup the session to obtain its meta data\n                    V value = this.factory.tryValue(id);\n                    if (value != null) {\n                        this.scheduler.schedule(this.factory.createImmutableSession(id, value));\n                    }\n                } finally {\n                    batch.discard();\n                }\n            });\n        }\n    }","id":22934,"modified_method":"private void schedule(Cache<? extends Key<String>, ?> cache, Locality oldLocality, Locality newLocality) {\n        SessionMetaDataFactory<MV, L> metaDataFactory = this.factory.getMetaDataFactory();\n        // Iterate over sessions in memory\n        try (Stream<? extends Key<String>> keys = cache.getAdvancedCache().withFlags(Flag.CACHE_MODE_LOCAL, Flag.SKIP_CACHE_LOAD).keySet().stream()) {\n            // If we are the new primary owner of this session then schedule expiration of this session locally\n            keys.filter(this.filter).filter(key -> !oldLocality.isLocal(key) && newLocality.isLocal(key)).map(key -> key.getValue()).forEach(id -> {\n                Batch batch = this.batcher.createBatch();\n                try {\n                    // We need to lookup the session to obtain its meta data\n                    MV value = metaDataFactory.tryValue(id);\n                    if (value != null) {\n                        this.scheduler.schedule(id, metaDataFactory.createImmutableSessionMetaData(id, value));\n                    }\n                } finally {\n                    batch.discard();\n                }\n            });\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Session<L> findSession(String id) {\n        V value = this.factory.findValue(id);\n        if (value == null) {\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s not found\", id);\n            return null;\n        }\n        Session<L> session = this.factory.createSession(id, value);\n        if (session.getMetaData().isExpired()) {\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s was found, but has expired\", id);\n            session.invalidate();\n            return null;\n        }\n        ImmutableSession immutableSession = this.persistent ? this.factory.createImmutableSession(id, value) : session;\n        this.cancel(immutableSession);\n        if (this.persistent) {\n            triggerPostActivationEvents(immutableSession);\n        }\n        return new SchedulableSession(session, immutableSession);\n    }","id":22935,"modified_method":"@Override\n    public Session<L> findSession(String id) {\n        Map.Entry<MV, AV> value = this.factory.findValue(id);\n        if (value == null) {\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s not found\", id);\n            return null;\n        }\n        ImmutableSession session = this.factory.createImmutableSession(id, value);\n        if (session.getMetaData().isExpired()) {\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s was found, but has expired\", id);\n            this.factory.remove(id);\n            return null;\n        }\n        this.cancel(id);\n        if (this.persistent) {\n            triggerPostActivationEvents(session);\n        }\n        return new SchedulableSession(this.factory.createSession(id, value), session);\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@CacheEntryRemoved\n    public void removed(CacheEntryRemovedEvent<SessionCreationMetaDataKey, ?> event) {\n        if (event.isPre()) {\n            this.executor.execute(() -> {\n                String id = event.getKey().getValue();\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be removed\", id);\n                V value = this.factory.findValue(id);\n                if (value != null) {\n                    ImmutableSession session = this.factory.createImmutableSession(id, value);\n                    ImmutableSessionAttributes attributes = session.getAttributes();\n\n                    HttpSession httpSession = new ImmutableHttpSessionAdapter(session);\n                    HttpSessionEvent sessionEvent = new HttpSessionEvent(httpSession);\n                    for (HttpSessionListener listener: this.context.getSessionListeners()) {\n                        listener.sessionDestroyed(sessionEvent);\n                    }\n\n                    for (String name: attributes.getAttributeNames()) {\n                        Object attribute = attributes.getAttribute(name);\n                        if (attribute instanceof HttpSessionBindingListener) {\n                            HttpSessionBindingListener listener = (HttpSessionBindingListener) attribute;\n                            listener.valueUnbound(new HttpSessionBindingEvent(httpSession, name, attribute));\n                        }\n                    }\n\n                    if (this.recorder != null) {\n                        this.recorder.record(session);\n                    }\n                }\n            });\n        }\n    }","id":22936,"modified_method":"@CacheEntryRemoved\n    public void removed(CacheEntryRemovedEvent<SessionCreationMetaDataKey, ?> event) {\n        if (event.isPre()) {\n            this.executor.execute(() -> {\n                String id = event.getKey().getValue();\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be removed\", id);\n                Map.Entry<MV, AV> value = this.factory.findValue(id);\n                if (value != null) {\n                    ImmutableSession session = this.factory.createImmutableSession(id, value);\n                    ImmutableSessionAttributes attributes = session.getAttributes();\n\n                    HttpSession httpSession = new ImmutableHttpSessionAdapter(session);\n                    HttpSessionEvent sessionEvent = new HttpSessionEvent(httpSession);\n                    for (HttpSessionListener listener: this.context.getSessionListeners()) {\n                        listener.sessionDestroyed(sessionEvent);\n                    }\n\n                    for (String name: attributes.getAttributeNames()) {\n                        Object attribute = attributes.getAttribute(name);\n                        if (attribute instanceof HttpSessionBindingListener) {\n                            HttpSessionBindingListener listener = (HttpSessionBindingListener) attribute;\n                            listener.valueUnbound(new HttpSessionBindingEvent(httpSession, name, attribute));\n                        }\n                    }\n\n                    if (this.recorder != null) {\n                        this.recorder.record(session);\n                    }\n                }\n            });\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"public InfinispanSessionManager(SessionFactory<V, L> factory, InfinispanSessionManagerConfiguration configuration) {\n        this.factory = factory;\n        this.cache = configuration.getCache();\n        this.context = configuration.getSessionContext();\n        this.identifierFactory = configuration.getIdentifierFactory();\n        this.batcher = configuration.getBatcher();\n        this.dispatcherFactory = configuration.getCommandDispatcherFactory();\n        this.nodeFactory = configuration.getNodeFactory();\n        this.maxActiveSessions = configuration.getMaxActiveSessions();\n        this.recorder = configuration.getInactiveSessionRecorder();\n        Configuration config = this.cache.getCacheConfiguration();\n        // If cache is clustered or configured with a write-through cache store\n        // then we need to trigger any HttpSessionActivationListeners per request\n        // See SRV.7.7.2 Distributed Environments\n        this.persistent = config.clustering().cacheMode().needsStateTransfer() || (config.persistence().usingStores() && !config.persistence().passivation());\n    }","id":22937,"modified_method":"public InfinispanSessionManager(SessionFactory<MV, AV, L> factory, InfinispanSessionManagerConfiguration configuration) {\n        this.factory = factory;\n        this.cache = configuration.getCache();\n        this.context = configuration.getSessionContext();\n        this.identifierFactory = configuration.getIdentifierFactory();\n        this.batcher = configuration.getBatcher();\n        this.dispatcherFactory = configuration.getCommandDispatcherFactory();\n        this.nodeFactory = configuration.getNodeFactory();\n        this.maxActiveSessions = configuration.getMaxActiveSessions();\n        this.recorder = configuration.getInactiveSessionRecorder();\n        Configuration config = this.cache.getCacheConfiguration();\n        // If cache is clustered or configured with a write-through cache store\n        // then we need to trigger any HttpSessionActivationListeners per request\n        // See SRV.7.7.2 Distributed Environments\n        this.persistent = config.clustering().cacheMode().needsStateTransfer() || (config.persistence().usingStores() && !config.persistence().passivation());\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start() {\n        this.executor = new StampedLockServiceExecutor();\n        if (this.recorder != null) {\n            this.recorder.reset();\n        }\n        this.identifierFactory.start();\n        final List<Scheduler> schedulers = new ArrayList<>(2);\n        schedulers.add(new SessionExpirationScheduler(this.batcher, new ExpiredSessionRemover<>(this.factory)));\n        if (this.maxActiveSessions >= 0) {\n            schedulers.add(new SessionEvictionScheduler(this.cache.getName() + \".eviction\", this.factory, this.dispatcherFactory, this.maxActiveSessions));\n        }\n        this.scheduler = new Scheduler() {\n            @Override\n            public void schedule(ImmutableSession session) {\n                schedulers.forEach(scheduler -> scheduler.schedule(session));\n            }\n\n            @Override\n            public void cancel(String sessionId) {\n                schedulers.forEach(scheduler -> scheduler.cancel(sessionId));\n            }\n\n            @Override\n            public void cancel(Locality locality) {\n                schedulers.forEach(scheduler -> scheduler.cancel(locality));\n            }\n\n            @Override\n            public void close() {\n                schedulers.forEach(scheduler -> scheduler.close());\n            }\n        };\n        this.dispatcher = this.dispatcherFactory.createCommandDispatcher(this.cache.getName() + \".schedulers\", this.scheduler);\n        this.cache.addListener(this, this.filter);\n        this.schedule(this.cache, new SimpleLocality(false), new ConsistentHashLocality(this.cache));\n    }","id":22938,"modified_method":"@Override\n    public void start() {\n        this.executor = new StampedLockServiceExecutor();\n        if (this.recorder != null) {\n            this.recorder.reset();\n        }\n        this.identifierFactory.start();\n        final List<Scheduler> schedulers = new ArrayList<>(2);\n        schedulers.add(new SessionExpirationScheduler(this.batcher, new ExpiredSessionRemover<>(this.factory.getMetaDataFactory(), this.factory)));\n        if (this.maxActiveSessions >= 0) {\n            schedulers.add(new SessionEvictionScheduler(this.cache.getName() + \".eviction\", this.factory, this.dispatcherFactory, this.maxActiveSessions));\n        }\n        this.scheduler = new Scheduler() {\n            @Override\n            public void schedule(String sessionId, ImmutableSessionMetaData metaData) {\n                schedulers.forEach(scheduler -> scheduler.schedule(sessionId, metaData));\n            }\n\n            @Override\n            public void cancel(String sessionId) {\n                schedulers.forEach(scheduler -> scheduler.cancel(sessionId));\n            }\n\n            @Override\n            public void cancel(Locality locality) {\n                schedulers.forEach(scheduler -> scheduler.cancel(locality));\n            }\n\n            @Override\n            public void close() {\n                schedulers.forEach(scheduler -> scheduler.close());\n            }\n        };\n        this.dispatcher = this.dispatcherFactory.createCommandDispatcher(this.cache.getName() + \".schedulers\", this.scheduler);\n        this.cache.addListener(this, this.filter);\n        this.schedule(this.cache, new SimpleLocality(false), new ConsistentHashLocality(this.cache));\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"void schedule(ImmutableSession session) {\n        try {\n            this.executeOnPrimaryOwner(session, new ScheduleSchedulerCommand(session));\n        } catch (Exception e) {\n            InfinispanWebLogger.ROOT_LOGGER.failedToScheduleSession(e, session.getId());\n        }\n    }","id":22939,"modified_method":"void schedule(String sessionId, ImmutableSessionMetaData metaData) {\n        try {\n            this.executeOnPrimaryOwner(sessionId, new ScheduleSchedulerCommand(sessionId, metaData));\n        } catch (Exception e) {\n            InfinispanWebLogger.ROOT_LOGGER.failedToScheduleSession(e, sessionId);\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@CacheEntryPassivated\n    public void passivated(CacheEntryPassivatedEvent<SessionCreationMetaDataKey, ?> event) {\n        if (event.isPre() && !this.persistent) {\n            this.executor.execute(() -> {\n                String id = event.getKey().getValue();\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be passivated\", id);\n                V value = this.factory.findValue(id);\n                if (value != null) {\n                    ImmutableSession session = this.factory.createImmutableSession(id, value);\n                    triggerPrePassivationEvents(session);\n                }\n            });\n        }\n    }","id":22940,"modified_method":"@CacheEntryPassivated\n    public void passivated(CacheEntryPassivatedEvent<SessionCreationMetaDataKey, ?> event) {\n        if (event.isPre() && !this.persistent) {\n            this.executor.execute(() -> {\n                String id = event.getKey().getValue();\n                InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be passivated\", id);\n                Map.Entry<MV, AV> value = this.factory.findValue(id);\n                if (value != null) {\n                    ImmutableSession session = this.factory.createImmutableSession(id, value);\n                    triggerPrePassivationEvents(session);\n                }\n            });\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void executeOnPrimaryOwner(final ImmutableSession session, final Command<Void, Scheduler> command) throws Exception {\n        this.invoker.invoke(() -> {\n            // This should only go remote following a failover\n            Node node = this.locatePrimaryOwner(session);\n            return this.dispatcher.executeOnNode(command, node);\n        }).get();\n    }","id":22941,"modified_method":"private void executeOnPrimaryOwner(final String sessionId, final Command<Void, Scheduler> command) throws Exception {\n        this.invoker.invoke(() -> {\n            // This should only go remote following a failover\n            Node node = this.locatePrimaryOwner(sessionId);\n            return this.dispatcher.executeOnNode(command, node);\n        }).get();\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void close() {\n            if (InfinispanSessionManager.this.isPersistent()) {\n                triggerPrePassivationEvents(this.immutableSession);\n            }\n            this.session.close();\n            InfinispanSessionManager.this.schedule(this.immutableSession);\n        }","id":22942,"modified_method":"@Override\n        public void close() {\n            if (InfinispanSessionManager.this.isPersistent()) {\n                triggerPrePassivationEvents(this.immutableSession);\n            }\n            this.session.close();\n            InfinispanSessionManager.this.schedule(this.immutableSession.getId(), this.immutableSession.getMetaData());\n        }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ImmutableSession viewSession(String id) {\n        V value = this.factory.findValue(id);\n        return (value != null) ? new SimpleImmutableSession(this.factory.createImmutableSession(id, value)) : null;\n    }","id":22943,"modified_method":"@Override\n    public ImmutableSession viewSession(String id) {\n        Map.Entry<MV, AV> value = this.factory.findValue(id);\n        return (value != null) ? new SimpleImmutableSession(this.factory.createImmutableSession(id, value)) : null;\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Node locatePrimaryOwner(ImmutableSession session) {\n        DistributionManager dist = this.cache.getAdvancedCache().getDistributionManager();\n        Address address = (dist != null) ? dist.getPrimaryLocation(new Key<>(session.getId())) : null;\n        return (address != null) ? this.nodeFactory.createNode(address) : this.dispatcherFactory.getGroup().getLocalNode();\n    }","id":22944,"modified_method":"private Node locatePrimaryOwner(String sessionId) {\n        DistributionManager dist = this.cache.getAdvancedCache().getDistributionManager();\n        Address address = (dist != null) ? dist.getPrimaryLocation(new Key<>(sessionId)) : null;\n        return (address != null) ? this.nodeFactory.createNode(address) : this.dispatcherFactory.getGroup().getLocalNode();\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private <L> SessionFactory<?, L> getSessionFactory(SessionContext context, LocalContextFactory<L> localContextFactory) {\n        SessionManagerConfiguration config = this.config.getSessionManagerConfiguration();\n        Module module = config.getModule();\n        MarshallingContext marshallingContext = new SimpleMarshallingContextFactory().createMarshallingContext(new SimpleMarshallingConfigurationRepository(MarshallingVersion.class, MarshallingVersion.CURRENT, module), module.getClassLoader());\n        MarshalledValueFactory<MarshallingContext> factory = new SimpleMarshalledValueFactory(marshallingContext);\n        Cache<Key<String>, ?> cache = this.config.getCache();\n        Configuration cacheConfig = cache.getCacheConfiguration();\n        boolean lockOnRead = cacheConfig.transaction().transactionMode().isTransactional() && (cacheConfig.transaction().lockingMode() == LockingMode.PESSIMISTIC) && cacheConfig.locking().isolationLevel() == IsolationLevel.REPEATABLE_READ;\n        boolean requireMarshallable = cacheConfig.clustering().cacheMode().needsStateTransfer() || cacheConfig.persistence().usingStores();\n\n        switch (config.getAttributePersistenceStrategy()) {\n            case FINE: {\n                Marshaller<Object, MarshalledValue<Object, MarshallingContext>, MarshallingContext> marshaller = new MarshalledValueMarshaller<>(factory, marshallingContext);\n                return new FineSessionFactory<>(cache, context, marshaller, localContextFactory, lockOnRead, requireMarshallable);\n            }\n            case COARSE: {\n                Marshaller<Map<String, Object>, MarshalledValue<Map<String, Object>, MarshallingContext>, MarshallingContext> marshaller = new MarshalledValueMarshaller<>(factory, marshallingContext);\n                return new CoarseSessionFactory<>(cache, context, marshaller, localContextFactory, lockOnRead, requireMarshallable);\n            }\n            default: {\n                // Impossible\n                throw new IllegalStateException();\n            }\n        }\n    }","id":22945,"modified_method":"private <L> SessionFactory<?, ?, L> createSessionFactory(SessionContext context, LocalContextFactory<L> localContextFactory) {\n        Configuration config = this.config.getCache().getCacheConfiguration();\n        boolean lockOnRead = config.transaction().transactionMode().isTransactional() && (config.transaction().lockingMode() == LockingMode.PESSIMISTIC) && config.locking().isolationLevel() == IsolationLevel.REPEATABLE_READ;\n        boolean requireMarshallable = config.clustering().cacheMode().needsStateTransfer() || config.persistence().usingStores();\n        SessionMetaDataFactory<InfinispanSessionMetaData<L>, L> metaDataFactory = new InfinispanSessionMetaDataFactory<>(this.config.getCache(), lockOnRead);\n        return new InfinispanSessionFactory<>(metaDataFactory, this.createSessionAttributesFactory(lockOnRead, requireMarshallable), context, localContextFactory);\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public <L> SessionManager<L, TransactionBatch> createSessionManager(final SessionContext context, IdentifierFactory<String> identifierFactory, LocalContextFactory<L> localContextFactory, final Recordable<ImmutableSession> inactiveSessionRecorder) {\n        final Batcher<TransactionBatch> batcher = new InfinispanBatcher(this.config.getCache());\n        final Cache<Key<String>, ?> cache = this.config.getCache();\n        final IdentifierFactory<String> factory = new AffinityIdentifierFactory<>(identifierFactory, cache, this.config.getKeyAffinityServiceFactory());\n        final CommandDispatcherFactory dispatcherFactory = this.config.getCommandDispatcherFactory();\n        final NodeFactory<Address> nodeFactory = this.config.getNodeFactory();\n        final int maxActiveSessions = this.config.getSessionManagerConfiguration().getMaxActiveSessions();\n        InfinispanSessionManagerConfiguration config = new InfinispanSessionManagerConfiguration() {\n            @Override\n            public SessionContext getSessionContext() {\n                return context;\n            }\n\n            @Override\n            public Cache<Key<String>, ?> getCache() {\n                return cache;\n            }\n\n            @Override\n            public IdentifierFactory<String> getIdentifierFactory() {\n                return factory;\n            }\n\n            @Override\n            public Batcher<TransactionBatch> getBatcher() {\n                return batcher;\n            }\n\n            @Override\n            public CommandDispatcherFactory getCommandDispatcherFactory() {\n                return dispatcherFactory;\n            }\n\n            @Override\n            public NodeFactory<Address> getNodeFactory() {\n                return nodeFactory;\n            }\n\n            @Override\n            public int getMaxActiveSessions() {\n                return maxActiveSessions;\n            }\n\n            @Override\n            public Recordable<ImmutableSession> getInactiveSessionRecorder() {\n                return inactiveSessionRecorder;\n            }\n        };\n        return new InfinispanSessionManager<>(this.getSessionFactory(context, localContextFactory), config);\n    }","id":22946,"modified_method":"@Override\n    public <L> SessionManager<L, TransactionBatch> createSessionManager(final SessionContext context, IdentifierFactory<String> identifierFactory, LocalContextFactory<L> localContextFactory, final Recordable<ImmutableSession> inactiveSessionRecorder) {\n        final Batcher<TransactionBatch> batcher = new InfinispanBatcher(this.config.getCache());\n        final Cache<Key<String>, ?> cache = this.config.getCache();\n        final IdentifierFactory<String> factory = new AffinityIdentifierFactory<>(identifierFactory, cache, this.config.getKeyAffinityServiceFactory());\n        final CommandDispatcherFactory dispatcherFactory = this.config.getCommandDispatcherFactory();\n        final NodeFactory<Address> nodeFactory = this.config.getNodeFactory();\n        final int maxActiveSessions = this.config.getSessionManagerConfiguration().getMaxActiveSessions();\n        InfinispanSessionManagerConfiguration config = new InfinispanSessionManagerConfiguration() {\n            @Override\n            public SessionContext getSessionContext() {\n                return context;\n            }\n\n            @Override\n            public Cache<Key<String>, ?> getCache() {\n                return cache;\n            }\n\n            @Override\n            public IdentifierFactory<String> getIdentifierFactory() {\n                return factory;\n            }\n\n            @Override\n            public Batcher<TransactionBatch> getBatcher() {\n                return batcher;\n            }\n\n            @Override\n            public CommandDispatcherFactory getCommandDispatcherFactory() {\n                return dispatcherFactory;\n            }\n\n            @Override\n            public NodeFactory<Address> getNodeFactory() {\n                return nodeFactory;\n            }\n\n            @Override\n            public int getMaxActiveSessions() {\n                return maxActiveSessions;\n            }\n\n            @Override\n            public Recordable<ImmutableSession> getInactiveSessionRecorder() {\n                return inactiveSessionRecorder;\n            }\n        };\n        return new InfinispanSessionManager<>(this.createSessionFactory(context, localContextFactory), config);\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ScheduleSchedulerCommand(ImmutableSession session) {\n        this.session = session;\n        this.id = session.getId();\n        ImmutableSessionMetaData metaData = session.getMetaData();\n        this.creationTime = metaData.getCreationTime();\n        this.maxInactiveInterval = metaData.getMaxInactiveInterval();\n        this.lastAccessedDuration = Duration.between(this.creationTime, metaData.getLastAccessedTime());\n    }","id":22947,"modified_method":"public ScheduleSchedulerCommand(String sessionId, ImmutableSessionMetaData metaData) {\n        this.sessionId = sessionId;\n        this.metaData = metaData;\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Void execute(Scheduler scheduler) {\n        ImmutableSession session = this.session;\n        if (session == null) {\n            SessionCreationMetaData creationMetaData = new SimpleSessionCreationMetaData(this.creationTime);\n            creationMetaData.setMaxInactiveInterval(this.maxInactiveInterval);\n            SessionAccessMetaData accessMetaData = new SimpleSessionAccessMetaData();\n            accessMetaData.setLastAccessedDuration(this.lastAccessedDuration);\n            SessionMetaData metaData = new SimpleSessionMetaData(creationMetaData, accessMetaData);\n            session = new MockImmutableSession(this.id, metaData);\n        }\n        scheduler.schedule(session);\n        return null;\n    }","id":22948,"modified_method":"@Override\n    public Void execute(Scheduler scheduler) {\n        scheduler.schedule(this.sessionId, this.metaData);\n        return null;\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SessionCreationMetaDataEntry(SessionCreationMetaData metaData) {\n        this.metaData = metaData;\n    }","id":22949,"modified_method":"public SessionCreationMetaDataEntry(SessionCreationMetaData metaData) {\n        this(metaData, new AtomicReference<>());\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void schedule(ImmutableSession session) {\n        synchronized (this.evictionQueue) {\n            this.evictionQueue.add(session.getId());\n            // Trigger eviction of oldest session if necessary\n            if (this.evictionQueue.size() > this.maxSize) {\n                Iterator<String> sessions = this.evictionQueue.iterator();\n                try {\n                    this.dispatcher.submitOnCluster(new SessionEvictionCommand(sessions.next()));\n                    sessions.remove();\n                } catch (Exception e) {\n                    InfinispanWebLogger.ROOT_LOGGER.failedToPassivateSession(e, session.getId());\n                }\n            }\n        }\n    }","id":22950,"modified_method":"@Override\n    public void schedule(String sessionId, ImmutableSessionMetaData metaData) {\n        synchronized (this.evictionQueue) {\n            this.evictionQueue.add(sessionId);\n            // Trigger eviction of oldest session if necessary\n            if (this.evictionQueue.size() > this.maxSize) {\n                Iterator<String> sessions = this.evictionQueue.iterator();\n                try {\n                    this.dispatcher.submitOnCluster(new SessionEvictionCommand(sessions.next()));\n                    sessions.remove();\n                } catch (Exception e) {\n                    InfinispanWebLogger.ROOT_LOGGER.failedToPassivateSession(e, sessionId);\n                }\n            }\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Test\n    public void test() throws Exception {\n        String name = \"cache\";\n        String evictedSessionId = \"evicted\";\n        String activeSessionId = \"active\";\n        ImmutableSession evictedSession = mock(ImmutableSession.class);\n        ImmutableSession activeSession = mock(ImmutableSession.class);\n        CommandDispatcherFactory dispatcherFactory = mock(CommandDispatcherFactory.class);\n        CommandDispatcher<SessionEvictionContext> dispatcher = mock(CommandDispatcher.class);\n        Evictor<String> evictor = mock(Evictor.class);\n        ArgumentCaptor<Command> capturedCommand = ArgumentCaptor.forClass(Command.class);\n        ArgumentCaptor<SessionEvictionContext> capturedContext = ArgumentCaptor.forClass(SessionEvictionContext.class);\n\n        when(dispatcherFactory.createCommandDispatcher(same(name), capturedContext.capture())).thenReturn(dispatcher);\n\n        try (Scheduler scheduler = new SessionEvictionScheduler(name, evictor, dispatcherFactory, 1)) {\n            SessionEvictionContext context = capturedContext.getValue();\n            \n            assertSame(scheduler, context);\n            \n            when(evictedSession.getId()).thenReturn(evictedSessionId);\n            when(activeSession.getId()).thenReturn(activeSessionId);\n            \n            scheduler.schedule(evictedSession);\n\n            verifyZeroInteractions(dispatcher);\n\n            scheduler.schedule(activeSession);\n\n            verify(dispatcher).submitOnCluster(capturedCommand.capture());\n            \n            capturedCommand.getValue().execute(context);\n            \n            verify(evictor).evict(evictedSessionId);\n            verify(evictor, never()).evict(activeSessionId);\n        }\n\n        verify(dispatcher).close();\n    }","id":22951,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Test\n    public void test() throws Exception {\n        String name = \"cache\";\n        String evictedSessionId = \"evicted\";\n        String activeSessionId = \"active\";\n        ImmutableSessionMetaData evictedSessionMetaData = mock(ImmutableSessionMetaData.class);\n        ImmutableSessionMetaData activeSessionMetaData = mock(ImmutableSessionMetaData.class);\n        CommandDispatcherFactory dispatcherFactory = mock(CommandDispatcherFactory.class);\n        CommandDispatcher<SessionEvictionContext> dispatcher = mock(CommandDispatcher.class);\n        Evictor<String> evictor = mock(Evictor.class);\n        ArgumentCaptor<Command> capturedCommand = ArgumentCaptor.forClass(Command.class);\n        ArgumentCaptor<SessionEvictionContext> capturedContext = ArgumentCaptor.forClass(SessionEvictionContext.class);\n\n        when(dispatcherFactory.createCommandDispatcher(same(name), capturedContext.capture())).thenReturn(dispatcher);\n\n        try (Scheduler scheduler = new SessionEvictionScheduler(name, evictor, dispatcherFactory, 1)) {\n            SessionEvictionContext context = capturedContext.getValue();\n            \n            assertSame(scheduler, context);\n            \n            scheduler.schedule(evictedSessionId, evictedSessionMetaData);\n\n            verifyZeroInteractions(dispatcher);\n\n            scheduler.schedule(activeSessionId, activeSessionMetaData);\n\n            verify(dispatcher).submitOnCluster(capturedCommand.capture());\n            \n            capturedCommand.getValue().execute(context);\n            \n            verify(evictor).evict(evictedSessionId);\n            verify(evictor, never()).evict(activeSessionId);\n        }\n\n        verify(dispatcher).close();\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void schedule(ImmutableSession session) {\n        Duration maxInactiveInterval = session.getMetaData().getMaxInactiveInterval();\n        if (!maxInactiveInterval.isZero()) {\n            Instant lastAccessed = session.getMetaData().getLastAccessedTime();\n            Duration delay = Duration.between(Instant.now(), lastAccessed.plus(maxInactiveInterval));\n            String id = session.getId();\n            Runnable task = new ExpirationTask(id);\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will expire in %d sec\", id, maxInactiveInterval.getSeconds());\n            synchronized (task) {\n                this.expirationFutures.put(id, this.executor.schedule(task, !delay.isNegative() ? delay.getSeconds() : 0, TimeUnit.SECONDS));\n            }\n        }\n    }","id":22952,"modified_method":"@Override\n    public void schedule(String sessionId, ImmutableSessionMetaData metaData) {\n        Duration maxInactiveInterval = metaData.getMaxInactiveInterval();\n        if (!maxInactiveInterval.isZero()) {\n            Instant lastAccessed = metaData.getLastAccessedTime();\n            Duration delay = Duration.between(Instant.now(), lastAccessed.plus(maxInactiveInterval));\n            Runnable task = new ExpirationTask(sessionId);\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will expire in %d sec\", sessionId, maxInactiveInterval.getSeconds());\n            synchronized (task) {\n                this.expirationFutures.put(sessionId, this.executor.schedule(task, !delay.isNegative() ? delay.getSeconds() : 0, TimeUnit.SECONDS));\n            }\n        }\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void test() throws InterruptedException {\n        Batcher<TransactionBatch> batcher = mock(Batcher.class);\n        TransactionBatch batch = mock(TransactionBatch.class);\n        Remover<String> remover = mock(Remover.class);\n        ImmutableSession immortalSession = mock(ImmutableSession.class);\n        ImmutableSession expiringSession = mock(ImmutableSession.class);\n        ImmutableSession canceledSession = mock(ImmutableSession.class);\n        SessionMetaData immortalMetaData = mock(SessionMetaData.class);\n        SessionMetaData shortTimeoutMetaData = mock(SessionMetaData.class);\n        SessionMetaData longTimeoutMetaData = mock(SessionMetaData.class);\n        String immortalSessionId = \"immortal\";\n        String expiringSessionId = \"expiring\";\n        String canceledSessionId = \"canceled\";\n\n        when(batcher.createBatch()).thenReturn(batch);\n\n        when(immortalSession.isValid()).thenReturn(true);\n        when(expiringSession.isValid()).thenReturn(true);\n        when(canceledSession.isValid()).thenReturn(true);\n\n        when(immortalSession.getMetaData()).thenReturn(immortalMetaData);\n        when(expiringSession.getMetaData()).thenReturn(shortTimeoutMetaData);\n        when(canceledSession.getMetaData()).thenReturn(longTimeoutMetaData);\n        \n        when(immortalMetaData.getMaxInactiveInterval()).thenReturn(Duration.ZERO);\n        when(shortTimeoutMetaData.getMaxInactiveInterval()).thenReturn(Duration.ofMillis(1L));\n        when(longTimeoutMetaData.getMaxInactiveInterval()).thenReturn(Duration.ofSeconds(100L));\n\n        Instant now = Instant.now();\n        when(shortTimeoutMetaData.getLastAccessedTime()).thenReturn(now);\n        when(longTimeoutMetaData.getLastAccessedTime()).thenReturn(now);\n        \n        when(immortalSession.getId()).thenReturn(immortalSessionId);\n        when(expiringSession.getId()).thenReturn(expiringSessionId);\n        when(canceledSession.getId()).thenReturn(canceledSessionId);\n        \n        try (Scheduler scheduler = new SessionExpirationScheduler(batcher, remover)) {\n            scheduler.schedule(immortalSession);\n            scheduler.schedule(canceledSession);\n            scheduler.schedule(expiringSession);\n\n            TimeUnit.SECONDS.sleep(1L);\n\n            scheduler.cancel(canceledSessionId);\n            scheduler.schedule(canceledSession);\n        }\n\n        verify(remover, never()).remove(immortalSessionId);\n        verify(remover).remove(expiringSessionId);\n        verify(remover, never()).remove(canceledSessionId);\n        verify(batch).close();\n    }","id":22953,"modified_method":"@Test\n    public void test() throws InterruptedException {\n        Batcher<TransactionBatch> batcher = mock(Batcher.class);\n        TransactionBatch batch = mock(TransactionBatch.class);\n        Remover<String> remover = mock(Remover.class);\n        ImmutableSessionMetaData immortalSessionMetaData = mock(ImmutableSessionMetaData.class);\n        ImmutableSessionMetaData expiringSessionMetaData = mock(ImmutableSessionMetaData.class);\n        ImmutableSessionMetaData canceledSessionMetaData = mock(ImmutableSessionMetaData.class);\n        String immortalSessionId = \"immortal\";\n        String expiringSessionId = \"expiring\";\n        String canceledSessionId = \"canceled\";\n\n        when(batcher.createBatch()).thenReturn(batch);\n\n        when(immortalSessionMetaData.getMaxInactiveInterval()).thenReturn(Duration.ZERO);\n        when(expiringSessionMetaData.getMaxInactiveInterval()).thenReturn(Duration.ofMillis(1L));\n        when(canceledSessionMetaData.getMaxInactiveInterval()).thenReturn(Duration.ofSeconds(100L));\n\n        Instant now = Instant.now();\n        when(expiringSessionMetaData.getLastAccessedTime()).thenReturn(now);\n        when(canceledSessionMetaData.getLastAccessedTime()).thenReturn(now);\n        \n        try (Scheduler scheduler = new SessionExpirationScheduler(batcher, remover)) {\n            scheduler.schedule(immortalSessionId, immortalSessionMetaData);\n            scheduler.schedule(canceledSessionId, canceledSessionMetaData);\n            scheduler.schedule(expiringSessionId, expiringSessionMetaData);\n\n            TimeUnit.SECONDS.sleep(1L);\n\n            scheduler.cancel(canceledSessionId);\n            scheduler.schedule(canceledSessionId, canceledSessionMetaData);\n        }\n\n        verify(remover, never()).remove(immortalSessionId);\n        verify(remover).remove(expiringSessionId);\n        verify(remover, never()).remove(canceledSessionId);\n        verify(batch).close();\n    }","commit_id":"bcbc924a62e2543adf1c486946274c96e0702bb6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public CoarseSessionEntry<L> findValue(String id) {\n        TransactionConfiguration transaction = this.sessionCache.getCacheConfiguration().transaction();\n        boolean pessimistic = transaction.transactionMode().isTransactional() && (transaction.lockingMode() == LockingMode.PESSIMISTIC);\n        Cache<String, CoarseSessionCacheEntry<L>> cache = pessimistic ? this.sessionCache.getAdvancedCache().withFlags(Flag.FORCE_WRITE_LOCK) : this.sessionCache;\n        CoarseSessionCacheEntry<L> entry = cache.get(id);\n        if (entry == null) return null;\n        MarshalledValue<Map<String, Object>, MarshallingContext> value = this.attributesCache.get(new SessionAttributesCacheKey(id));\n        return new CoarseSessionEntry<>(entry, value);\n    }","id":22954,"modified_method":"@Override\n    public CoarseSessionEntry<L> findValue(String id) {\n        TransactionConfiguration transaction = this.sessionCache.getCacheConfiguration().transaction();\n        boolean pessimistic = transaction.transactionMode().isTransactional() && (transaction.lockingMode() == LockingMode.PESSIMISTIC);\n        Cache<String, CoarseSessionCacheEntry<L>> cache = pessimistic ? this.sessionCache.getAdvancedCache().withFlags(Flag.FORCE_WRITE_LOCK) : this.sessionCache;\n        CoarseSessionCacheEntry<L> entry = cache.get(id);\n        if (entry == null) return null;\n        MarshalledValue<Map<String, Object>, MarshallingContext> value = this.attributesCache.get(new SessionAttributesCacheKey(id));\n        return (value != null) ? new CoarseSessionEntry<>(entry, value) : null;\n    }","commit_id":"126d96fef6e6402e688cc679392d5aa2986ed6eb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@CacheEntryRemoved\n    public void removed(CacheEntryRemovedEvent<String, ?> event) {\n        if (event.isPre()) {\n            String id = event.getKey();\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be removed\", id);\n            ImmutableSession session = this.factory.createImmutableSession(id, this.factory.findValue(id));\n            ImmutableSessionAttributes attributes = session.getAttributes();\n\n            HttpSession httpSession = new ImmutableHttpSessionAdapter(session);\n            HttpSessionEvent sessionEvent = new HttpSessionEvent(httpSession);\n            for (HttpSessionListener listener: this.context.getSessionListeners()) {\n                listener.sessionDestroyed(sessionEvent);\n            }\n\n            for (String attribute: attributes.getAttributeNames()) {\n                Object value = attributes.getAttribute(attribute);\n                if (value instanceof HttpSessionBindingListener) {\n                    HttpSessionBindingListener listener = (HttpSessionBindingListener) value;\n                    listener.valueUnbound(new HttpSessionBindingEvent(httpSession, attribute, value));\n                }\n            }\n        }\n    }","id":22955,"modified_method":"@CacheEntryRemoved\n    public void removed(CacheEntryRemovedEvent<String, ?> event) {\n        if (event.isPre()) {\n            String id = event.getKey();\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be removed\", id);\n            V value = this.factory.findValue(id);\n            if (value != null) {\n                ImmutableSession session = this.factory.createImmutableSession(id, value);\n                ImmutableSessionAttributes attributes = session.getAttributes();\n\n                HttpSession httpSession = new ImmutableHttpSessionAdapter(session);\n                HttpSessionEvent sessionEvent = new HttpSessionEvent(httpSession);\n                for (HttpSessionListener listener: this.context.getSessionListeners()) {\n                    listener.sessionDestroyed(sessionEvent);\n                }\n\n                for (String name: attributes.getAttributeNames()) {\n                    Object attribute = attributes.getAttribute(name);\n                    if (attribute instanceof HttpSessionBindingListener) {\n                        HttpSessionBindingListener listener = (HttpSessionBindingListener) attribute;\n                        listener.valueUnbound(new HttpSessionBindingEvent(httpSession, name, attribute));\n                    }\n                }\n            }\n        }\n    }","commit_id":"126d96fef6e6402e688cc679392d5aa2986ed6eb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@CacheEntryPassivated\n    public void passivated(CacheEntryPassivatedEvent<String, ?> event) {\n        if (event.isPre() && !this.persistent) {\n            String id = event.getKey();\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be passivated\", id);\n            ImmutableSession session = this.factory.createSession(id, this.factory.findValue(id));\n            triggerPrePassivationEvents(session);\n        }\n    }","id":22956,"modified_method":"@CacheEntryPassivated\n    public void passivated(CacheEntryPassivatedEvent<String, ?> event) {\n        if (event.isPre() && !this.persistent) {\n            String id = event.getKey();\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s will be passivated\", id);\n            V value = this.factory.findValue(id);\n            if (value != null) {\n                ImmutableSession session = this.factory.createImmutableSession(id, value);\n                triggerPrePassivationEvents(session);\n            }\n        }\n    }","commit_id":"126d96fef6e6402e688cc679392d5aa2986ed6eb","url":"https://github.com/wildfly/wildfly"},{"original_method":"@CacheEntryActivated\n    public void activated(CacheEntryActivatedEvent<String, ?> event) {\n        if (!event.isPre() && !this.persistent) {\n            String id = event.getKey();\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s was activated\", id);\n            ImmutableSession session = this.factory.createImmutableSession(id, this.factory.findValue(id));\n            triggerPostActivationEvents(session);\n        }\n    }","id":22957,"modified_method":"@CacheEntryActivated\n    public void activated(CacheEntryActivatedEvent<String, ?> event) {\n        if (!event.isPre() && !this.persistent) {\n            String id = event.getKey();\n            InfinispanWebLogger.ROOT_LOGGER.tracef(\"Session %s was activated\", id);\n            V value = this.factory.findValue(id);\n            if (value != null) {\n                ImmutableSession session = this.factory.createImmutableSession(id, value);\n                triggerPostActivationEvents(session);\n            }\n        }\n    }","commit_id":"126d96fef6e6402e688cc679392d5aa2986ed6eb","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void mapLastIssues(Collection<DefaultIssue> newIssues, Collection<IssueDto> lastIssues, IssueTrackingResult result) {\n    for (IssueDto lastIssue : lastIssues) {\n      result.addUnmatched(lastIssue);\n    }\n\n    // Match the key of the issue. (For manual issues)\n    for (DefaultIssue newIssue : newIssues) {\n      mapIssue(newIssue, findLastIssueWithSameKey(newIssue, result.unmatchedForRule(newIssue.ruleKey())), result);\n    }\n\n    // Try first to match issues on same rule with same line and with same checksum (but not necessarily with same message)\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameLineAndChecksum(newIssue, result.unmatchedForRule(newIssue.ruleKey())),\n          result);\n      }\n    }\n  }","id":22958,"modified_method":"private void mapLastIssues(Collection<DefaultIssue> newIssues, Collection<IssueDto> lastIssues, IssueTrackingResult result) {\n    for (IssueDto lastIssue : lastIssues) {\n      result.addUnmatched(lastIssue);\n    }\n\n    // Match the key of the issue. (For manual issues)\n    for (DefaultIssue newIssue : newIssues) {\n      mapIssue(newIssue, result.unmatchedByKeyForRule(newIssue.ruleKey()).get(newIssue.key()), result);\n    }\n\n    // Try first to match issues on same rule with same line and with same checksum (but not necessarily with same message)\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameLineAndChecksum(newIssue, result),\n          result);\n      }\n    }\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void mapIssuesOnSameRule(Collection<DefaultIssue> newIssues, IssueTrackingResult result) {\n    // Try then to match issues on same rule with same message and with same checksum\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameChecksumAndMessage(newIssue, result.unmatchedForRule(newIssue.ruleKey())),\n          result);\n      }\n    }\n\n    // Try then to match issues on same rule with same line and with same message\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameLineAndMessage(newIssue, result.unmatchedForRule(newIssue.ruleKey())),\n          result);\n      }\n    }\n\n    // Last check: match issue if same rule and same checksum but different line and different message\n    // See SONAR-2812\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameChecksum(newIssue, result.unmatchedForRule(newIssue.ruleKey())),\n          result);\n      }\n    }\n  }","id":22959,"modified_method":"private void mapIssuesOnSameRule(Collection<DefaultIssue> newIssues, IssueTrackingResult result) {\n    // Try then to match issues on same rule with same message and with same checksum\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameChecksumAndMessage(newIssue, result.unmatchedByKeyForRule(newIssue.ruleKey()).values()),\n          result);\n      }\n    }\n\n    // Try then to match issues on same rule with same line and with same message\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameLineAndMessage(newIssue, result.unmatchedByKeyForRule(newIssue.ruleKey()).values()),\n          result);\n      }\n    }\n\n    // Last check: match issue if same rule and same checksum but different line and different message\n    // See SONAR-2812\n    for (DefaultIssue newIssue : newIssues) {\n      if (isNotAlreadyMapped(newIssue, result)) {\n        mapIssue(\n          newIssue,\n          findLastIssueWithSameChecksum(newIssue, result.unmatchedByKeyForRule(newIssue.ruleKey()).values()),\n          result);\n      }\n    }\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private IssueDto findLastIssueWithSameLineAndChecksum(DefaultIssue newIssue, Collection<IssueDto> lastIssues) {\n    for (IssueDto pastIssue : lastIssues) {\n      if (isSameLine(newIssue, pastIssue) && isSameChecksum(newIssue, pastIssue)) {\n        return pastIssue;\n      }\n    }\n    return null;\n  }","id":22960,"modified_method":"private IssueDto findLastIssueWithSameLineAndChecksum(DefaultIssue newIssue, IssueTrackingResult result) {\n    Collection<IssueDto> sameRuleAndSameLineAndSameChecksum = result.unmatchedForRuleAndForLineAndForChecksum(newIssue.ruleKey(), newIssue.line(), newIssue.checksum());\n    if (!sameRuleAndSameLineAndSameChecksum.isEmpty()) {\n      return sameRuleAndSameLineAndSameChecksum.iterator().next();\n    }\n    return null;\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"Collection<IssueDto> unmatchedForRule(RuleKey ruleKey) {\n    return unmatchedByRule.get(ruleKey);\n  }","id":22961,"modified_method":"Map<String, IssueDto> unmatchedByKeyForRule(RuleKey ruleKey) {\n    return unmatchedByRuleAndKey.containsKey(ruleKey) ? unmatchedByRuleAndKey.get(ruleKey) : Collections.<String, IssueDto>emptyMap();\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void addUnmatched(IssueDto i) {\n    unmatched.add(i);\n    unmatchedByRule.put(RuleKey.of(i.getRuleRepo(), i.getRule()), i);\n  }","id":22962,"modified_method":"void addUnmatched(IssueDto i) {\n    unmatchedByKey.put(i.getKee(), i);\n    RuleKey ruleKey = RuleKey.of(i.getRuleRepo(), i.getRule());\n    if (!unmatchedByRuleAndKey.containsKey(ruleKey)) {\n      unmatchedByRuleAndKey.put(ruleKey, new HashMap<String, IssueDto>());\n      unmatchedByRuleAndLineAndChecksum.put(ruleKey, new HashMap<Integer, Multimap<String, IssueDto>>());\n    }\n    unmatchedByRuleAndKey.get(ruleKey).put(i.getKee(), i);\n    Map<Integer, Multimap<String, IssueDto>> unmatchedForRule = unmatchedByRuleAndLineAndChecksum.get(ruleKey);\n    Integer lineNotNull = i.getLine() != null ? i.getLine() : 0;\n    if (!unmatchedForRule.containsKey(lineNotNull)) {\n      unmatchedForRule.put(lineNotNull, HashMultimap.<String, IssueDto>create());\n    }\n    Multimap<String, IssueDto> unmatchedForRuleAndLine = unmatchedForRule.get(lineNotNull);\n    String checksumNotNull = StringUtils.defaultString(i.getChecksum(), \"\");\n    unmatchedForRuleAndLine.put(checksumNotNull, i);\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"Collection<IssueDto> unmatched() {\n    return unmatched;\n  }","id":22963,"modified_method":"Collection<IssueDto> unmatched() {\n    return unmatchedByKey.values();\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void setMatch(DefaultIssue issue, IssueDto matching) {\n    matched.put(issue, matching);\n    unmatchedByRule.remove(RuleKey.of(matching.getRuleRepo(), matching.getRule()), matching);\n    unmatched.remove(matching);\n  }","id":22964,"modified_method":"void setMatch(DefaultIssue issue, IssueDto matching) {\n    matched.put(issue, matching);\n    RuleKey ruleKey = RuleKey.of(matching.getRuleRepo(), matching.getRule());\n    unmatchedByRuleAndKey.get(ruleKey).remove(matching.getKee());\n    unmatchedByKey.remove(matching.getKee());\n    Integer lineNotNull = matching.getLine() != null ? matching.getLine() : 0;\n    String checksumNotNull = StringUtils.defaultString(matching.getChecksum(), \"\");\n    unmatchedByRuleAndLineAndChecksum.get(ruleKey).get(lineNotNull).get(checksumNotNull).remove(matching);\n  }","commit_id":"bbac6378c0ae04b5c2906858c4799989276883e6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static TransformerHandler getIdentityTransformerHandler() {\n        try {\n            return getFactory(IDENTITY_TYPE).newTransformerHandler();\n        } catch (TransformerException e) {\n            throw new OXFException(e);\n        }\n    }","id":22965,"modified_method":"/**\n     * Return a new identity TransformerHandler object.\n     *\n     * @return  a new identity TransformerHandler object\n     */\n    public static TransformerHandler getIdentityTransformerHandler() {\n        try {\n            TransformerHandler transformerHandler = getFactory(IDENTITY_TYPE).newTransformerHandler();\n            // Wrap TransformerHandler for properties\n            return new TransformerHandlerWrapper(transformerHandler, INDENT_AMOUNT_PROPERTY, SAXON_INDENT_AMOUNT_PROPERTY);\n        } catch (TransformerException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"b92f591eb187fdfb7927c041736014bb2d60a5a8","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Transformer getXMLIdentityTransformer() {\n        try {\n            Transformer transformer = getFactory(IDENTITY_TYPE).newTransformer();\n            transformer.setOutputProperty(OutputKeys.ENCODING, DEFAULT_OUTPUT_ENCODING);\n            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            transformer.setOutputProperty(OutputKeys.VERSION, \"1.0\");\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            transformer.setOutputProperty(INDENT_AMOUNT, \"1\");\n            return transformer;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":22966,"modified_method":"public static Transformer getXMLIdentityTransformer() {\n        try {\n            Transformer transformer = getIdentityTransformer();\n            transformer.setOutputProperty(OutputKeys.ENCODING, DEFAULT_OUTPUT_ENCODING);\n            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            transformer.setOutputProperty(OutputKeys.VERSION, \"1.0\");\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            transformer.setOutputProperty(INDENT_AMOUNT_PROPERTY, \"1\");\n            return transformer;\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"b92f591eb187fdfb7927c041736014bb2d60a5a8","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Transformer getIdentityTransformer() throws TransformerConfigurationException {\n        Transformer transformer = getFactory(IDENTITY_TYPE).newTransformer();\n        return transformer;\n    }","id":22967,"modified_method":"/**\n     * Return a new identity transformer object.\n     *\n     * @return  a new identity Transformer object\n     * @throws TransformerConfigurationException\n     */\n    public static Transformer getIdentityTransformer() throws TransformerConfigurationException {\n        Transformer transformer = getFactory(IDENTITY_TYPE).newTransformer();\n        // Wrap Transformer for properties\n        return new TransformerWrapper(transformer, INDENT_AMOUNT_PROPERTY, SAXON_INDENT_AMOUNT_PROPERTY);\n    }","commit_id":"b92f591eb187fdfb7927c041736014bb2d60a5a8","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static void applyOutputProperties(Transformer transformer,\n                                             String method,\n                                             String version,\n                                             String publicDoctype,\n                                             String systemDoctype,\n                                             String encoding,\n                                             boolean omitXMLDeclaration,\n                                             Boolean standalone,\n                                             boolean indent,\n                                             int indentAmount) {\n        if (method != null && !\"\".equals(method))\n            transformer.setOutputProperty(OutputKeys.METHOD, method);\n        if (version != null && !\"\".equals(version))\n            transformer.setOutputProperty(OutputKeys.VERSION, version);\n        if (publicDoctype != null && !\"\".equals(publicDoctype))\n            transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, publicDoctype);\n        if (systemDoctype != null && !\"\".equals(systemDoctype))\n            transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemDoctype);\n        if (encoding != null && !\"\".equals(encoding))\n            transformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        if (indent)\n            transformer.setOutputProperty(INDENT_AMOUNT, String.valueOf(indentAmount));\n        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, omitXMLDeclaration ? \"yes\" : \"no\");\n        if (standalone != null)\n            transformer.setOutputProperty(OutputKeys.STANDALONE, standalone.booleanValue() ? \"yes\" : \"no\");\n    }","id":22968,"modified_method":"/**\n     * Apply output properties on a Transformer.\n     *\n     * @param transformer           transformer to apply properties on\n     * @param method                output method\n     * @param version               HTML or XML version\n     * @param publicDoctype         public doctype\n     * @param systemDoctype         system doctype\n     * @param encoding              character encoding\n     * @param omitXMLDeclaration    whether XML declaration must be omitted\n     * @param standalone            wether a standalone declartion must be set and to what value\n     * @param indent                whether the HTML or XML must be indented\n     * @param indentAmount          amount of indenting for the markup\n     */\n    public static void applyOutputProperties(Transformer transformer,\n                                             String method,\n                                             String version,\n                                             String publicDoctype,\n                                             String systemDoctype,\n                                             String encoding,\n                                             boolean omitXMLDeclaration,\n                                             Boolean standalone,\n                                             boolean indent,\n                                             int indentAmount) {\n        if (method != null && !\"\".equals(method))\n            transformer.setOutputProperty(OutputKeys.METHOD, method);\n        if (version != null && !\"\".equals(version))\n            transformer.setOutputProperty(OutputKeys.VERSION, version);\n        if (publicDoctype != null && !\"\".equals(publicDoctype))\n            transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, publicDoctype);\n        if (systemDoctype != null && !\"\".equals(systemDoctype))\n            transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemDoctype);\n        if (encoding != null && !\"\".equals(encoding))\n            transformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        if (indent)\n            transformer.setOutputProperty(INDENT_AMOUNT_PROPERTY, String.valueOf(indentAmount));\n        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, omitXMLDeclaration ? \"yes\" : \"no\");\n        if (standalone != null)\n            transformer.setOutputProperty(OutputKeys.STANDALONE, standalone.booleanValue() ? \"yes\" : \"no\");\n    }","commit_id":"b92f591eb187fdfb7927c041736014bb2d60a5a8","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static TestSuite suite() {\n        TestSuite suite = new TestSuite();\n\n        suite.addTest(new UtilsTest(\"testNumberUtils\"));\n        suite.addTest(new UtilsTest(\"testLocationDocumentSourceResult\"));\n\n        return suite;\n    }","id":22969,"modified_method":"public static TestSuite suite() {\n        TestSuite suite = new TestSuite();\n\n        suite.addTest(new UtilsTest(\"testNumberUtils\"));\n        suite.addTest(new UtilsTest(\"testLocationDocumentSourceResult\"));\n        suite.addTest(new UtilsTest(\"testTransformerWrapper\"));\n\n        return suite;\n    }","commit_id":"b92f591eb187fdfb7927c041736014bb2d60a5a8","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Parameter(String name, T value) {\n        this.name = name;\n        this.value = value;\n    }","id":22970,"modified_method":"public Parameter(String name, T value) {\n        this(\"*\", name, value);\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public FilterDirector handleRequest(final MutableHttpServletRequest request, MutableHttpServletResponse response) throws IOException {\n        FilterDirector filterDirector = new FilterDirectorImpl();\n\n        \n        List<Source> nodes = requestPipelinePool.use(new ResourceContext<Pipeline, List<Source>>() {\n            @Override\n            public List<Source> perform(Pipeline pipe) throws ResourceContextException {\n               // Send HTTPx as the source port.  The input stream will already\n               // contain the request body if requested via \"fidelity\" options\n               List<PipelineInput> inputs = new ArrayList<PipelineInput>();\n               inputs.add(PipelineInput.port(SOURCE_PORT, new InputSource(getHttpxStream(request))));\n\n               pipe.run(inputs);\n\n               return pipe.getResultPort(PRIMARY_RESULT);\n            }\n        });\n        \n\n        final InputStream httpxStream;\n        if (!nodes.isEmpty()) {\n           // Use the first document returned on the result port\n           httpxStream = postProcessor.process(nodes.get(0));\n        } else {\n           httpxStream = null;\n        }\n        \n        // TODO use stream to create new HTTPx request.\n        \n        filterDirector.setFilterAction(FilterAction.PASS);\n        \n        return filterDirector;\n    }","id":22971,"modified_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest httpRequest, ReadableHttpServletResponse response) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        FilterDirector filterDirector = new FilterDirectorImpl();\n\n        String contentType = request.getContentType();\n        List<HeaderValue> acceptValues = request.getPreferredHeaderValues(\"Accept\");\n        XsltHandlerChainPool pool = getHandlerChainPool(contentType, acceptValues, requestProcessors);\n\n        if (pool != null) {\n            try {\n                final InputStream in = request.getInputStream();\n                final ByteBuffer internalBuffer = new CyclicByteBuffer(DEFAULT_BUFFER_SIZE, true);\n                final ByteBufferServletOutputStream out = new ByteBufferServletOutputStream(internalBuffer);\n                pool.getPool().use(new SimpleResourceContext<XsltHandlerChain>() {\n                    @Override\n                    public void perform(XsltHandlerChain chain) throws ResourceContextException {\n                        chain.executeChain(in, out, null, null);\n                    }\n                });\n                request.setInputStream(new ByteBufferServletInputStream(internalBuffer));\n                filterDirector.requestHeaderManager().putHeader(\"content-type\", pool.getResultContentType());\n            } catch (IOException ex) {\n                Logger.getLogger(TranslationHandler.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n\n        filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n\n        return filterDirector;\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public TranslationHandler(TranslationConfig translationConfig, Pool<Pipeline> requestPipelinePool, Pool<Pipeline> responsePipelinePool) {\n        this.config = translationConfig;\n        postProcessor = new RequestStreamPostProcessor();\n    }","id":22972,"modified_method":"public TranslationHandler(TranslationConfig translationConfig, ArrayList<XsltHandlerChainPool> requestProcessors, ArrayList<XsltHandlerChainPool> responseProcessors) {\n        this.config = translationConfig;\n        this.requestProcessors = requestProcessors;\n        this.responseProcessors = responseProcessors;\n        //postProcessor = new RequestStreamPostProcessor();\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   protected TranslationHandler buildHandler() {\n      return new TranslationHandler(config, requestPipelinePool, responsePipelinePool);\n   }","id":22973,"modified_method":"@Override\n    protected TranslationHandler buildHandler() {\n        return new TranslationHandler(config, requestProcessors, responseProcessors);\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n       public void configurationUpdated(TranslationConfig configurationObject) {\n           config = configurationObject;\n            requestPipelinePool = new GenericBlockingResourcePool<Pipeline>(new ConstructionStrategy<Pipeline>() {\n\n               @Override\n               public Pipeline construct() throws ResourceConstructionException {\n                  try {\n                   return new CalabashPipelineBuilder(false).build(config.getRequestTranslationProcess().getHref());\n\n                  } catch (PipelineException ex) {\n                     throw new ResourceConstructionException(\"Unable to build request pipeline.  Reason: \" + ex.getMessage(), ex);\n                  }\n               }\n            });\n            responsePipelinePool = new GenericBlockingResourcePool<Pipeline>(new ConstructionStrategy<Pipeline>() {\n\n               @Override\n               public Pipeline construct() throws ResourceConstructionException {\n                  try {\n                   return new CalabashPipelineBuilder(false).build(config.getResponseTranslationProcess().getHref());\n\n                  } catch (PipelineException ex) {\n                     throw new ResourceConstructionException(\"Unable to build request pipeline. Reason: \" + ex.getMessage(), ex);\n                  }\n               }\n            });\n       }","id":22974,"modified_method":"@Override\n        public void configurationUpdated(TranslationConfig config) {\n            requestProcessors.clear();\n            responseProcessors.clear();\n\n            for (final ResponseTranslation translation : config.getResponseTranslations().getResponseTranslation()) {\n\n                Pool<XsltHandlerChain> pool = new GenericBlockingResourcePool<XsltHandlerChain>(\n                        new ConstructionStrategy<XsltHandlerChain>() {\n                            @Override\n                            public XsltHandlerChain construct() throws ResourceConstructionException {\n                                List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                    stylesheets.add(new StyleSheetInfo(sheet.getId(), sheet.getHref()));\n                                }\n\n                                return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                            }\n                        });\n                \n                responseProcessors.add(new XsltHandlerChainPool(translation.getContentType(), translation.getAccept(), translation.getTranslatedContentType(), pool));\n            }\n\n        }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public TranslationHandlerFactory() {\n    }","id":22975,"modified_method":"public TranslationHandlerFactory() {\n        transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();\n        xsltChainBuilder = new XsltHandlerChainBuilder(transformerFactory);\n        requestProcessors = new ArrayList<XsltHandlerChainPool>();\n        responseProcessors = new ArrayList<XsltHandlerChainPool>();\n        \n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public XsltHandlerChain(SAXTransformerFactory factory) {\n      this(factory, new ArrayList<TransformerHandler>());\n   }","id":22976,"modified_method":"public XsltHandlerChain(SAXTransformerFactory factory) {\n      this(factory, new ArrayList<XslTransformer>());\n   }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public XsltHandlerChain(SAXTransformerFactory factory, List<TransformerHandler> handlers) {\n      this.factory = factory;\n      this.handlers = handlers;\n   }","id":22977,"modified_method":"public XsltHandlerChain(SAXTransformerFactory factory, List<XslTransformer> handlers) {\n      this.factory = factory;\n      this.handlers = handlers;\n   }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public List<TransformerHandler> getHandlers() {\n      return handlers;\n   }","id":22978,"modified_method":"public List<XslTransformer> getHandlers() {\n      return handlers;\n   }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Test\n        public void shouldUseInputOutputStreams() {\n            List<Parameter> inputs = new ArrayList<Parameter>();\n\n            inputs.add(new Parameter(\"headers\", headersInput));\n            inputs.add(new Parameter(\"query\", queryInput));\n\n            List<Parameter<? extends OutputStream>> outputs = new ArrayList<Parameter<? extends OutputStream>>();\n            outputs.add(new Parameter<OutputStream>(\"headers.html\", headersOutput));\n            outputs.add(new Parameter<OutputStream>(\"query.html\", queryOutput));\n            \n            XsltHandlerChain chain = builder.build(\"classpath:/style.xsl\");\n            chain.executeChain(body, output, inputs, outputs);\n            \n            String headersResult = headersOutput.toString();\n            String queryResult = queryOutput.toString();\n            String outResult = output.toString();\n            \n            assertTrue(\"Should have header output\", headersResult.length() > 0);\n            assertTrue(\"Should have query output\", queryResult.length() > 0);\n            assertTrue(\"Shoudl have main output\", outResult.length() > 0);\n            \n        }","id":22979,"modified_method":"@Test\n        public void shouldUseInputOutputStreams() {\n            List<Parameter> inputs = new ArrayList<Parameter>();\n\n            inputs.add(new Parameter(\"headers\", headersInput));\n            inputs.add(new Parameter(\"query\", queryInput));\n\n            List<Parameter<? extends OutputStream>> outputs = new ArrayList<Parameter<? extends OutputStream>>();\n            outputs.add(new Parameter<OutputStream>(\"headers.html\", headersOutput));\n            outputs.add(new Parameter<OutputStream>(\"query.html\", queryOutput));\n            \n            XsltHandlerChain chain = builder.build(new StyleSheetInfo(\"\", \"classpath:/style.xsl\"));\n            chain.executeChain(body, output, inputs, outputs);\n            \n            String headersResult = headersOutput.toString();\n            String queryResult = queryOutput.toString();\n            String outResult = output.toString();\n            \n            assertTrue(\"Should have header output\", headersResult.length() > 0);\n            assertTrue(\"Should have query output\", queryResult.length() > 0);\n            assertTrue(\"Shoudl have main output\", outResult.length() > 0);\n            \n        }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Test\n        public void shouldHandleStyleSheetList() {\n            XsltHandlerChain chain = builder.build(\"classpath:/style.xsl\");\n\n            assertNotNull(\"Should build a filter chain\", chain);\n            assertEquals(\"Should have 1 handler\", 1, chain.getHandlers().size());\n        }","id":22980,"modified_method":"@Test\n        public void shouldHandleStyleSheetList() {\n            XsltHandlerChain chain = builder.build(new StyleSheetInfo(\"\", \"classpath:/style.xsl\"));\n\n            assertNotNull(\"Should build a filter chain\", chain);\n            assertEquals(\"Should have 1 handler\", 1, chain.getHandlers().size());\n        }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void executeChain(InputStream in, OutputStream out, List<Parameter> inputs, List<Parameter<? extends OutputStream>> outputs) throws XsltHandlerException {\n        try {\n            XMLReader reader = getSaxReader();\n            // TODO: Make validation optional\n            reader.setFeature(\"http://xml.org/sax/features/validation\", false);\n\n            if (!chain.getHandlers().isEmpty()) {\n\n                // Set the content handler of the reader to be the first handler\n                TransformerHandler firstHandler = chain.getHandlers().get(0);\n                reader.setContentHandler(firstHandler);\n\n                for (TransformerHandler handler : chain.getHandlers()) {\n                    Transformer transformer = handler.getTransformer();\n                    transformer.clearParameters();\n\n                    //transformer.setURIResolver(new ClassPathUriResolver(transformer.getURIResolver()));\n                    setInputParameters(transformer, inputs);\n                    setAlternateOutputs(transformer, outputs);\n                }\n\n                // Set the result of the last handler to be the output stream\n                chain.getHandlers().get(chain.getHandlers().size() - 1).setResult(new StreamResult(out));\n            }\n\n            reader.parse(new InputSource(in));\n            in.close();\n        } catch (IOException ex) {\n            throw new XsltHandlerException(ex);\n        } catch (ParserConfigurationException ex) {\n            throw new XsltHandlerException(ex);\n        } catch (SAXException ex) {\n            throw new XsltHandlerException(ex);\n        }\n    }","id":22981,"modified_method":"public void executeChain(InputStream in, OutputStream out, List<Parameter> inputs, List<Parameter<? extends OutputStream>> outputs) throws XsltHandlerException {\n        try {\n            XMLReader reader = getSaxReader();\n            // TODO: Make validation optional\n            reader.setFeature(\"http://xml.org/sax/features/validation\", false);\n\n            if (!chain.getHandlers().isEmpty()) {\n\n                // Set the content handler of the reader to be the first handler\n                XslTransformer firstHandler = chain.getHandlers().get(0);\n                reader.setContentHandler(firstHandler.getHandler());\n\n                for (XslTransformer handler : chain.getHandlers()) {\n                    Transformer transformer = handler.getHandler().getTransformer();\n                    transformer.clearParameters();\n\n                    //transformer.setURIResolver(new ClassPathUriResolver(transformer.getURIResolver()));\n                    setInputParameters(handler.getId(), transformer, inputs);\n                    setAlternateOutputs(handler.getId(), transformer, outputs);\n                }\n\n                // Set the result of the last handler to be the output stream\n                chain.getHandlers().get(chain.getHandlers().size() - 1).getHandler().setResult(new StreamResult(out));\n            }\n\n            reader.parse(new InputSource(in));\n            //in.close();\n        } catch (IOException ex) {\n            throw new XsltHandlerException(ex);\n        } catch (ParserConfigurationException ex) {\n            throw new XsltHandlerException(ex);\n        } catch (SAXException ex) {\n            throw new XsltHandlerException(ex);\n        }\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"private void setAlternateOutputs(Transformer transformer, List<Parameter<? extends OutputStream>> outputs) {\n        if (outputs.size() > 0) {\n            if (transformer instanceof Controller) {\n                OutputStreamUriParameterResolver outputResolver = getOutputResolver((Controller) transformer);\n\n                for (Parameter<? extends OutputStream> output : outputs) {\n                    outputResolver.addStream(output.getValue(), output.getName());\n                }\n            }\n        }\n    }","id":22982,"modified_method":"private void setAlternateOutputs(String id, Transformer transformer, List<Parameter<? extends OutputStream>> outputs) {\n        if (outputs != null && outputs.size() > 0) {\n            if (transformer instanceof Controller) {\n                OutputStreamUriParameterResolver outputResolver = getOutputResolver((Controller) transformer);\n\n                for (Parameter<? extends OutputStream> output : outputs) {\n                    outputResolver.addStream(output.getValue(), output.getName());\n                }\n            }\n        }\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"private void setInputParameters(Transformer transformer, List<Parameter> inputs) {\n\n        if (inputs.size() > 0) {\n            InputStreamUriParameterResolver resolver = getResolver(transformer);\n            for (Parameter input : inputs) {\n                String param;\n                if (input.getValue() instanceof InputStream) {\n                    param = resolver.addStream((InputStream) input.getValue());\n                } else {\n                    param = input.getValue().toString();\n                }\n                transformer.setParameter(input.getName(), param);\n            }\n        }\n\n    }","id":22983,"modified_method":"private void setInputParameters(String id, Transformer transformer, List<Parameter> inputs) {\n\n        if (inputs != null && inputs.size() > 0) {\n            InputStreamUriParameterResolver resolver = getResolver(transformer);\n            for (Parameter input : inputs) {\n                if (!\"*\".equals(input.getStyleId()) && !id.equals(input.getStyleId())) {\n                    continue;\n                }\n                \n                String param;\n                if (input.getValue() instanceof InputStream) {\n                    param = resolver.addStream((InputStream) input.getValue());\n                } else {\n                    param = input.getValue().toString();\n                }\n                transformer.setParameter(input.getName(), param);\n            }\n        }\n\n    }","commit_id":"a2ef75b8e7c4cde4ef013659c552481d5d2398ba","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Before\n    public void init() throws Exception\n    {\n        _handler=new RewriteHandler();\n        _server.setHandler(_handler);\n        _handler.setHandler(new AbstractHandler(){\n\n            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                response.setStatus(201);\n                request.setAttribute(\"target\",target);\n                request.setAttribute(\"URI\",request.getRequestURI());\n                request.setAttribute(\"info\",request.getPathInfo());\n            }\n\n        });\n\n        _rule1 = new RewritePatternRule();\n        _rule1.setPattern(\"/aaa/*\");\n        _rule1.setReplacement(\"/bbb\");\n        _rule2 = new RewritePatternRule();\n        _rule2.setPattern(\"/bbb/*\");\n        _rule2.setReplacement(\"/ccc\");\n        _rule3 = new RewritePatternRule();\n        _rule3.setPattern(\"/ccc/*\");\n        _rule3.setReplacement(\"/ddd\");\n\n        _handler.setRules(new Rule[]{_rule1,_rule2,_rule3});\n\n        start(false);\n    }","id":22984,"modified_method":"@Before\n    public void init() throws Exception\n    {\n        _handler=new RewriteHandler();\n        _server.setHandler(_handler);\n        _handler.setHandler(new AbstractHandler(){\n\n            public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n            {\n                response.setStatus(201);\n                request.setAttribute(\"target\",target);\n                request.setAttribute(\"URI\",request.getRequestURI());\n                request.setAttribute(\"info\",request.getPathInfo());\n            }\n\n        });\n\n        _rule1 = new RewritePatternRule();\n        _rule1.setPattern(\"/aaa/*\");\n        _rule1.setReplacement(\"/bbb\");\n        _rule2 = new RewritePatternRule();\n        _rule2.setPattern(\"/bbb/*\");\n        _rule2.setReplacement(\"/ccc\");\n        _rule3 = new RewritePatternRule();\n        _rule3.setPattern(\"/ccc/*\");\n        _rule3.setReplacement(\"/ddd\");\n        _rule4 = new RewriteRegexRule();\n        _rule4.setRegex(\"/xxx/(.*)\");\n        _rule4.setReplacement(\"/$1/zzz\");\n\n        _handler.setRules(new Rule[]{_rule1,_rule2,_rule3,_rule4});\n\n        start(false);\n    }","commit_id":"97291cc28af41891583f295f7fe89c0aa07e0bb6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Process the contained rules (called by matchAndApply) \n     * @param target target field to pass on to the contained rules\n     * @param request request object to pass on to the contained rules\n     * @param response response object to pass on to the contained rules\n     */\n    protected String apply(String target, HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        boolean original_set=_originalPathAttribute==null;\n                \n        for (Rule rule : _rules)\n        {\n            String applied=rule.matchAndApply(target,request, response);\n            if (applied!=null)\n            {       \n                Log.debug(\"applied {}\",rule);\n                if (!target.equals(applied))\n                { \n                    Log.debug(\"rewrote {} to {}\",target,applied);\n                    if (!original_set)\n                    {\n                        original_set=true;\n                        request.setAttribute(_originalPathAttribute, target);\n                    }     \n                    \n                    if (_rewriteRequestURI)\n                        ((Request)request).setRequestURI(applied);\n\n                    if (_rewritePathInfo)\n                        ((Request)request).setPathInfo(applied);\n\n                    target=applied;\n                }\n                \n                if (rule.isHandling())\n                {\n                    Log.debug(\"handling {}\",rule);\n                    (request instanceof Request?(Request)request:HttpConnection.getCurrentConnection().getRequest()).setHandled(true);\n                }\n\n                if (rule.isTerminating())\n                {\n                    Log.debug(\"terminating {}\",rule);\n                    break;\n                }\n            }\n        }\n\n        return target;\n    }","id":22985,"modified_method":"/**\n     * Process the contained rules (called by matchAndApply) \n     * @param target target field to pass on to the contained rules\n     * @param request request object to pass on to the contained rules\n     * @param response response object to pass on to the contained rules\n     */\n    protected String apply(String target, HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        boolean original_set=_originalPathAttribute==null;\n                \n        for (Rule rule : _rules)\n        {\n            String applied=rule.matchAndApply(target,request, response);\n            if (applied!=null)\n            {       \n                Log.debug(\"applied {}\",rule);\n                if (!target.equals(applied))\n                { \n                    Log.debug(\"rewrote {} to {}\",target,applied);\n                    if (!original_set)\n                    {\n                        original_set=true;\n                        request.setAttribute(_originalPathAttribute, target);\n                    }     \n\n                    if (_rewriteRequestURI)\n                    {\n                        if (rule instanceof Rule.ApplyURI && !target.equals(request.getRequestURI()))\n                            ((Rule.ApplyURI)rule).applyURI((Request)request, target, applied);\n                        else\n                            ((Request)request).setRequestURI(applied);\n                    }\n\n                    if (_rewritePathInfo)\n                        ((Request)request).setPathInfo(applied);\n\n                    target=applied;\n                }\n                \n                if (rule.isHandling())\n                {\n                    Log.debug(\"handling {}\",rule);\n                    (request instanceof Request?(Request)request:HttpConnection.getCurrentConnection().getRequest()).setHandled(true);\n                }\n\n                if (rule.isTerminating())\n                {\n                    Log.debug(\"terminating {}\",rule);\n                    break;\n                }\n            }\n        }\n\n        return target;\n    }","commit_id":"97291cc28af41891583f295f7fe89c0aa07e0bb6","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** \n     * @return Map of String arrays\n     */\n    public Map<K,String[]> toStringArrayMap()\n    {\n        HashMap<K,String[]> map = new HashMap<K,String[]>(_map.size()*3/2);\n        \n        for(Map.Entry<K,Object> entry: _map.entrySet())\n        {\n            String[] a = LazyList.toStringArray(entry.getValue());\n            map.put(entry.getKey(),a);\n        }\n        return map;\n    }","id":22986,"modified_method":"/** \n     * @return Map of String arrays\n     */\n    public Map<K,String[]> toStringArrayMap()\n    {\n        HashMap<K,String[]> map = new HashMap<K,String[]>(_map.size()*3/2)\n        {\n            public String toString()\n            {\n                StringBuilder b=new StringBuilder();\n                b.append('{');\n                for (K k:keySet())\n                {\n                    if(b.length()>1)\n                        b.append(',');\n                    b.append(k);\n                    b.append('=');\n                    b.append(Arrays.asList(get(k)));\n                }\n\n                b.append('}');\n                return b.toString();\n            }\n        };\n        \n        for(Map.Entry<K,Object> entry: _map.entrySet())\n        {\n            String[] a = LazyList.toStringArray(entry.getValue());\n            map.put(entry.getKey(),a);\n        }\n        return map;\n    }","commit_id":"9dfa9f9937baa85c26f475b60b554f1ba6398679","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void applyURI(Request request, String oldTarget, String newTarget) throws IOException\n    {\n        request.setRequestURI(newTarget);\n        if (_query!=null)\n        {\n            String query=(String)request.getAttribute(\"org.eclipse.jetty.rewrite.handler.RewriteRegexRule.Q\");\n            if (_queryGroup||request.getQueryString()==null)\n                request.setQueryString(query);\n            else\n                request.setQueryString(request.getQueryString()+\"&\"+query);\n        }\n    }","id":22987,"modified_method":"public void applyURI(Request request, String oldTarget, String newTarget) throws IOException\n    {\n        if (_query==null)\n        {\n            request.setRequestURI(newTarget);\n        }\n        else\n        {\n            String query=(String)request.getAttribute(\"org.eclipse.jetty.rewrite.handler.RewriteRegexRule.Q\");\n            \n            if (!_queryGroup && request.getQueryString()!=null)\n                query=request.getQueryString()+\"&\"+query;\n            HttpURI uri=new HttpURI(newTarget+\"?\"+query);\n            request.setUri(uri);\n            request.setRequestURI(newTarget);\n            request.setQueryString(query);\n        }\n    }","commit_id":"9dfa9f9937baa85c26f475b60b554f1ba6398679","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testRequestUriEnabled() throws IOException\n    {\n        for (String[] test : _tests)\n        {\n            String t=test[0]+\"?\"+test[1]+\">\"+test[2]+\"|\"+test[3];\n            _rule.setRegex(test[2]);\n            _rule.setReplacement(test[3]);\n\n            _request.setRequestURI(test[0]);\n            _request.setQueryString(test[1]);\n            _request.getAttributes().clearAttributes();\n            \n            String result = _rule.matchAndApply(test[0], _request, _response);\n            assertEquals(t, test[4], result);\n            _rule.applyURI(_request,test[0],result);\n\n            assertEquals(t,test[4], _request.getRequestURI());\n            assertEquals(t,test[5], _request.getQueryString());\n        }\n    }","id":22988,"modified_method":"@Test\n    public void testRequestUriEnabled() throws IOException\n    {\n        for (String[] test : _tests)\n        {\n            reset();\n            _request.setRequestURI(null);\n            \n            String t=test[0]+\"?\"+test[1]+\">\"+test[2]+\"|\"+test[3];\n            _rule.setRegex(test[2]);\n            _rule.setReplacement(test[3]);\n\n            _request.setUri(new HttpURI(test[0]+(test[1]==null?\"\":(\"?\"+test[1]))));\n            _request.getRequestURI();\n\n            \n            String result = _rule.matchAndApply(test[0], _request, _response);\n            assertEquals(t, test[4], result);\n            _rule.applyURI(_request,test[0],result);\n\n            if (result!=null)\n            {\n                assertEquals(t,test[4], _request.getRequestURI());\n                assertEquals(t,test[5], _request.getQueryString());\n            }\n            \n            if (test[5]!=null)\n            {\n                MultiMap<String> params=new MultiMap<String>();\n                UrlEncoded.decodeTo(test[5],params,StringUtil.__UTF8);\n                               \n                for (String n:params.keySet())\n                    assertEquals(params.getString(n),_request.getParameter(n));\n            }\n        }\n    }","commit_id":"9dfa9f9937baa85c26f475b60b554f1ba6398679","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void handleSnacPacket(SnacPacketEvent e) {\n        SnacPacket packet = e.getSnacPacket();\n        System.out.println(\"got snac packet type \"\n                + Integer.toHexString(packet.getFamily()) + \"/\"\n                + Integer.toHexString(packet.getCommand()) + \": \"\n                + e.getSnacCommand());\n\n        SnacCommand cmd = e.getSnacCommand();\n        if (cmd instanceof ServerReadyCmd) {\n            ServerReadyCmd src = (ServerReadyCmd) cmd;\n\n            setSnacFamilies(src.getSnacFamilies());\n\n            SnacFamilyInfo[] familyInfos = SnacFamilyInfoFactory\n                    .getDefaultFamilyInfos(src.getSnacFamilies());\n\n            setSnacFamilyInfos(familyInfos);\n\n            tester.registerSnacFamilies(this);\n\n            request(new ClientVersionsCmd(familyInfos));\n            request(new RateInfoRequest());\n\n        } else if (cmd instanceof RecvImIcbm) {\n            RecvImIcbm icbm = (RecvImIcbm) cmd;\n\n            String sn = icbm.getSenderInfo().getScreenname();\n            InstantMessage message = icbm.getMessage();\n            String msg = null;\n            if (message.isEncrypted()) {\n                ByteBlock encData = message.getEncryptedData();\n                System.out.println(\"got [\" + encData.getLength() + \"]\");\n\n                SecureSession secureSession = tester.getSecureSession();\n                if (secureSession.hasCert(sn)) {\n                    try {\n                        msg = secureSession.decodeEncryptedIM(sn, encData);\n                    } catch (SecureSessionException e1) {\n                        e1.printStackTrace();\n                    }\n                } else {\n                    System.out.println(sn + \" tried sending an encrypted \"\n                            + \"message, but I don't have his/her certificate \"\n                            + \" - try typing 'getcertinfo \" + sn + \"'\");\n                }\n\n            } else {\n                msg = OscarTools.stripHtml(message.getMessage());\n\n//                OldIconHashInfo iconInfo = icbm.getIconInfo();\n//\n//                if (iconInfo != null) {\n//                    System.out.println(\"(\" + sn\n//                            + \" has a buddy icon: \" + iconInfo + \")\");\n//                }\n\n              //  sendRequest(new SnacRequest(new SendImIcbm(sn, msg), null));\n            }\n            String str = dateFormat.format(new Date()) + \" IM from \"\n                    + sn + \": \" + msg;\n            if (imLogger != null) {\n                imLogger.println(str);\n            }\n           \n            if (msg != null) {\n                String encFlag = (message.isEncrypted() ? \"**ENCRYPTED** \" : \"\");\n                System.out.println(encFlag + \"*\" + sn + \"* \" + msg);\n            }\n            \n            if (tester.requireApproval)\n            {\n            \tBoolean b = this.approvedSenders.get(sn);\n            \t\n            \t\n            \tif (b == null)\n            \t{\n            \t\t//get approval\n            \t\tint value = tufts.vue.VueUtil.confirm(VUE.getApplicationFrame(), \n            \t\t\t\tVueResources.getMessageString(\"im.approve.message\",new Object[]{sn}), \n            \t\t\t\tVueResources.getString(\"im.approve.title\"));\n            \t\t\n            \t\t\n            \t\n            \t\tif (value == JOptionPane.YES_OPTION) {\n            \t\t\tapprovedSenders.put(sn, new Boolean(true));\n            \t\t} else if (value == JOptionPane.NO_OPTION) {\n            \t\t   approvedSenders.put(sn, new Boolean(false));\n            \t\t   return;\n            \t\t}\n\n            \t\t\n            \t}\n            \telse if (b.booleanValue() == false)\n            \t\treturn;\n            \t//else do nothing.\n            }\n            \n            if (!tester.ignoreIMs)\n            {\n\n            \tLWNode newNode = NodeModeTool.createNewNode(VueUtil.formatLines(OscarTools.stripHtml(msg), 30));\n            \tMetadataList mlist = new MetadataList();\n            \tmlist.add(\"submitted by\", sn);\n            \tmlist.add(\"timestamp\",now().toString());\n            \tnewNode.setMetadataList(mlist);\n           \n            \tString c = senders.getProperty(sn);\n            \tColor color = null;\n            \tif (c == null)\n            \t{\n            \t\tcolor = randomColor();\n            \t\tsenders.setProperty(sn, color.getRed() +\",\"+color.getGreen()+\",\"+color.getBlue());\n            \t}\n            \telse\n            \t{\n            \t\tStringTokenizer tokens = new StringTokenizer(c,\",\");\n                \n            \t\tcolor = new Color(Integer.parseInt((String)tokens.nextElement()),Integer.parseInt((String)tokens.nextElement()),Integer.parseInt((String)tokens.nextElement()));\n             \n            \t}\n            \tif (tester.assignColors)\n            \t\tnewNode.setFillColor(color);\n            \t\n            \tif (tester.forceNodeWidth)\n            \t{\n            \t\t\tnewNode.setAutoSized(false);                    \n                \t\tnewNode.setFrame(newNode.getX(),newNode.getY(),200,newNode.getHeight());\n                }\t\t\n            \t\n//            \tVUE.getActiveMap().add(newNode);//\n            \tVUE.getActiveViewer().getFocal().dropChild(newNode);\n              \tif (!tester.makeTables)\n              \t{\n\t            \tList<LWComponent> compList = new ArrayList<LWComponent>();\n\t              \tcompList.add(newNode);\n\t              \tVUE.getActiveViewer().getSelection().clear();\n\t              \tVUE.getActiveViewer().getSelection().add(newNode);\n\t\n\t            \tLayoutAction.search.act(new LWSelection(compList));\n\t            \tMapDropTarget.makeRoomFor(newNode);\n\t            \tMapDropTarget.makeRoomFor(newNode);\n              \t}\n              \telse\n              \t{\n              \t\tList<LWComponent> compList = new ArrayList<LWComponent>();\n              \t\tVUE.getActiveViewer().getSelection().clear();\n              \t\tVUE.getActiveViewer().getSelection().add(newNode);\n//\t              \tVUE.getActiveViewer().getSelection().add(VUE.getActiveMap().getAllDescendents());\n\t              \tcompList.addAll(VUE.getActiveMap().getAllDescendents());\n\t              \tLayoutAction.table.act(new LWSelection(compList));\n\n              \t}\n            }\n\n        } else if (cmd instanceof WarningNotification) {\n            WarningNotification wn = (WarningNotification) cmd;\n            MiniUserInfo warner = wn.getWarner();\n            if (warner == null) {\n                System.out.println(\"*** You were warned anonymously to \"\n                        + wn.getNewLevel() + \"%\");\n            } else {\n                System.out.println(\"*** \" + warner.getScreenname()\n                        + \" warned you up to \" + wn.getNewLevel() + \"%\");\n            }\n        } else if (cmd instanceof BuddyStatusCmd) {\n            BuddyStatusCmd bsc = (BuddyStatusCmd) cmd;\n\n            FullUserInfo info = bsc.getUserInfo();\n\n            String sn = info.getScreenname();\n\n            ExtraInfoBlock[] extraInfos = info.getExtraInfoBlocks();\n\n            if (extraInfos != null) {\n                for (int i = 0; i < extraInfos.length; i++) {\n                    ExtraInfoBlock extraInfo = extraInfos[i];\n                    ExtraInfoData data = extraInfo.getExtraData();\n\n//                    if ((hashInfo.getFlags() & ExtraInfoData.FLAG_ICON_PRESENT)\n//                            != 0) {\n//                        System.out.println(sn +\n//                                \" has an icon! requesting it.. (excode=\"\n//                                + iconInfos[i].getExtraCode() + \")\");\n\n//                        request(new IconRequest(sn, iconInfos[i]));\n//\n//                        break;\n//                    }\n\n                    if (extraInfo.getType() == ExtraInfoBlock.TYPE_AVAILMSG) {\n                        ByteBlock msgBlock = data.getData();\n                        int len = BinaryTools.getUShort(msgBlock, 0);\n                        byte[] msgBytes = msgBlock.subBlock(2, len).toByteArray();\n\n                        String msg;\n                        try {\n                            msg = new String(msgBytes, \"UTF-8\");\n                        } catch (UnsupportedEncodingException e1) {\n                            e1.printStackTrace();\n                            return;\n                        }\n                        if (msg.length() > 0) {\n                            System.out.println(info.getScreenname()\n                                    + \" availability: \" + msg);\n                        }\n                    }\n                }\n            }\n\n            if (info.getCapabilityBlocks() != null) {\n                List known = Arrays.asList(new CapabilityBlock[] {\n                    CapabilityBlock.BLOCK_CHAT,\n                    CapabilityBlock.BLOCK_DIRECTIM,\n                    CapabilityBlock.BLOCK_FILE_GET,\n                    CapabilityBlock.BLOCK_FILE_SEND,\n                    CapabilityBlock.BLOCK_GAMES,\n                    CapabilityBlock.BLOCK_GAMES2,\n                    CapabilityBlock.BLOCK_ICON,\n                    CapabilityBlock.BLOCK_SENDBUDDYLIST,\n                    CapabilityBlock.BLOCK_TRILLIANCRYPT,\n                    CapabilityBlock.BLOCK_VOICE,\n                    CapabilityBlock.BLOCK_ADDINS,\n                    CapabilityBlock.BLOCK_ICQCOMPATIBLE,\n                    CapabilityBlock.BLOCK_SOMETHING,\n                });\n\n                List caps = new ArrayList(Arrays.asList(\n                        info.getCapabilityBlocks()));\n                caps.removeAll(known);\n                if (!caps.isEmpty()) {\n                    System.out.println(sn + \" has \" + caps.size()\n                            + \" unknown caps:\");\n                    for (Iterator it = caps.iterator(); it.hasNext();) {\n                        System.out.println(\"- \" + it.next());\n                    }\n                }\n/*\n                caps = new ArrayList(known);\n                caps.removeAll(Arrays.asList(info.getCapabilityBlocks()));\n                if (!caps.isEmpty()) {\n                    System.out.println(sn + \" is missing \" + caps.size()\n                            + \" caps:\");\n                    for (Iterator it = caps.iterator(); it.hasNext();) {\n                        System.out.println(\"- \" + it.next());\n                    }\n                }\n*/\n            }\n        } else if (cmd instanceof BuddyOfflineCmd) {\n            BuddyOfflineCmd boc = (BuddyOfflineCmd) cmd;\n\n        } else if (cmd instanceof RateChange) {\n            RateChange rc = (RateChange) cmd;\n\n            System.out.println(\"rate change: current avg is \"\n                    + rc.getRateInfo().getCurrentAvg());\n        }\n    }","id":22989,"modified_method":"protected synchronized void handleSnacPacket(SnacPacketEvent e) {\n        SnacPacket packet = e.getSnacPacket();\n        System.out.println(\"got snac packet type \"\n                + Integer.toHexString(packet.getFamily()) + \"/\"\n                + Integer.toHexString(packet.getCommand()) + \": \"\n                + e.getSnacCommand());\n\n        SnacCommand cmd = e.getSnacCommand();\n        if (cmd instanceof ServerReadyCmd) {\n            ServerReadyCmd src = (ServerReadyCmd) cmd;\n\n            setSnacFamilies(src.getSnacFamilies());\n\n            SnacFamilyInfo[] familyInfos = SnacFamilyInfoFactory\n                    .getDefaultFamilyInfos(src.getSnacFamilies());\n\n            setSnacFamilyInfos(familyInfos);\n\n            tester.registerSnacFamilies(this);\n\n            request(new ClientVersionsCmd(familyInfos));\n            request(new RateInfoRequest());\n\n        } else if (cmd instanceof RecvImIcbm) {\n            RecvImIcbm icbm = (RecvImIcbm) cmd;\n\n            String sn = icbm.getSenderInfo().getScreenname();\n            InstantMessage message = icbm.getMessage();\n            String msg = null;\n            if (message.isEncrypted()) {\n                ByteBlock encData = message.getEncryptedData();\n                System.out.println(\"got [\" + encData.getLength() + \"]\");\n\n                SecureSession secureSession = tester.getSecureSession();\n                if (secureSession.hasCert(sn)) {\n                    try {\n                        msg = secureSession.decodeEncryptedIM(sn, encData);\n                    } catch (SecureSessionException e1) {\n                        e1.printStackTrace();\n                    }\n                } else {\n                    System.out.println(sn + \" tried sending an encrypted \"\n                            + \"message, but I don't have his/her certificate \"\n                            + \" - try typing 'getcertinfo \" + sn + \"'\");\n                }\n\n            } else {\n                msg = OscarTools.stripHtml(message.getMessage());\n\n//                OldIconHashInfo iconInfo = icbm.getIconInfo();\n//\n//                if (iconInfo != null) {\n//                    System.out.println(\"(\" + sn\n//                            + \" has a buddy icon: \" + iconInfo + \")\");\n//                }\n\n              //  sendRequest(new SnacRequest(new SendImIcbm(sn, msg), null));\n            }\n            String str = dateFormat.format(new Date()) + \" IM from \"\n                    + sn + \": \" + msg;\n            if (imLogger != null) {\n                imLogger.println(str);\n            }\n           \n            if (msg != null) {\n                String encFlag = (message.isEncrypted() ? \"**ENCRYPTED** \" : \"\");\n                System.out.println(encFlag + \"*\" + sn + \"* \" + msg);\n            }\n            \n            if (tester.requireApproval)\n            {\n            \tBoolean b = this.approvedSenders.get(sn);\n            \t\n            \t\n            \tif (b == null)\n            \t{\n            \t\t//get approval\n            \t\tint value = tufts.vue.VueUtil.confirm(VUE.getApplicationFrame(), \n            \t\t\t\tVueResources.getMessageString(\"im.approve.message\",new Object[]{sn}), \n            \t\t\t\tVueResources.getString(\"im.approve.title\"));\n            \t\t\n            \t\t\n            \t\n            \t\tif (value == JOptionPane.YES_OPTION) {\n            \t\t\tapprovedSenders.put(sn, new Boolean(true));\n            \t\t} else if (value == JOptionPane.NO_OPTION) {\n            \t\t   approvedSenders.put(sn, new Boolean(false));\n            \t\t   return;\n            \t\t}\n\n            \t\t\n            \t}\n            \telse if (b.booleanValue() == false)\n            \t\treturn;\n            \t//else do nothing.\n            }\n            \n            if (!tester.ignoreIMs)\n            {\n\n            \tLWNode newNode = NodeModeTool.createNewNode(VueUtil.formatLines(OscarTools.stripHtml(msg), 30));\n            \tMetadataList mlist = new MetadataList();\n            \tmlist.add(\"submitted by\", sn);\n            \tmlist.add(\"timestamp\",now().toString());\n            \tnewNode.setMetadataList(mlist);\n           \n            \tString c = senders.getProperty(sn);\n            \tColor color = null;\n            \tif (c == null)\n            \t{\n            \t\tcolor = randomColor();\n            \t\tsenders.setProperty(sn, color.getRed() +\",\"+color.getGreen()+\",\"+color.getBlue());\n            \t}\n            \telse\n            \t{\n            \t\tStringTokenizer tokens = new StringTokenizer(c,\",\");\n                \n            \t\tcolor = new Color(Integer.parseInt((String)tokens.nextElement()),Integer.parseInt((String)tokens.nextElement()),Integer.parseInt((String)tokens.nextElement()));\n             \n            \t}\n            \tif (tester.assignColors)\n            \t\tnewNode.setFillColor(color);\n            \t\n            \tif (tester.forceNodeWidth)\n            \t{\n            \t\t\tnewNode.setAutoSized(false);                    \n                \t\tnewNode.setFrame(newNode.getX(),newNode.getY(),200,newNode.getHeight());\n                }\t\t\n            \t\n//            \tVUE.getActiveMap().add(newNode);//\n            \t//getFocal().dropChild(newNode);\n\n            \t\n            \tList<LWComponent> compList = new ArrayList<LWComponent>();\n\t          \n\t          //  VUE.getActiveViewer().getSelection().clear();\n\t           // VUE.getActiveViewer().getSelection().add(newNode);\n\t            Collection<LWComponent> collection = VUE.getActiveMap().getActiveLayer().getAllDescendents();\n\t            compList.addAll(collection);\n\t            compList.add(newNode);\n\t            if (collection.size() <= 1)\n\t            {\n\t            \t//if its a fresh map try not to let it go all the way off the creen\n\t            \tif (!(VUE.getActiveMap().getAllDescendents().size() < 1 && VUE.getActiveViewer().getLastMousePressMapPoint().getX()+200 > VUE.getActiveViewer().getWidth()))\n\t            \t\tnewNode.setLocation(VUE.getActiveViewer().getLastMousePressMapPoint());\n\t            \tVUE.getActiveMap().addChild(newNode);\n\t            }\n\t            else\n\t            \tVUE.getActiveMap().dropChild(newNode);\n\t            \n            \t//VUE.getActiveViewer().getSelection().setTo(compList);\n\t            if (!tester.makeTables)\n              \t{\t            \t\t              \t\n\t              \tif (compList.size() > 1)              \t\t\n\t              \t\tLayoutAction.search.act(new LWSelection(compList),!tester.keepAt100);\n              \t\t\n\t            \tMapDropTarget.makeRoomFor(newNode);\n\t            \tMapDropTarget.makeRoomFor(newNode);\n              \t}\n              \telse\n              \t{   \n\n              \t\tif (compList.size() > 1)              \t\t              \t\t\n              \t\t{   \n              \t\t\tTabularLayout.setIMLayout(true);\n              \t\t\tLayoutAction.table.act(new LWSelection(compList),!tester.keepAt100);              \t\t\n                  \t\tTabularLayout.setIMLayout(false);\n              \t\t}\n              \t}\n            }\n\n        } else if (cmd instanceof WarningNotification) {\n            WarningNotification wn = (WarningNotification) cmd;\n            MiniUserInfo warner = wn.getWarner();\n            if (warner == null) {\n                System.out.println(\"*** You were warned anonymously to \"\n                        + wn.getNewLevel() + \"%\");\n            } else {\n                System.out.println(\"*** \" + warner.getScreenname()\n                        + \" warned you up to \" + wn.getNewLevel() + \"%\");\n            }\n        } else if (cmd instanceof BuddyStatusCmd) {\n            BuddyStatusCmd bsc = (BuddyStatusCmd) cmd;\n\n            FullUserInfo info = bsc.getUserInfo();\n\n            String sn = info.getScreenname();\n\n            ExtraInfoBlock[] extraInfos = info.getExtraInfoBlocks();\n\n            if (extraInfos != null) {\n                for (int i = 0; i < extraInfos.length; i++) {\n                    ExtraInfoBlock extraInfo = extraInfos[i];\n                    ExtraInfoData data = extraInfo.getExtraData();\n\n//                    if ((hashInfo.getFlags() & ExtraInfoData.FLAG_ICON_PRESENT)\n//                            != 0) {\n//                        System.out.println(sn +\n//                                \" has an icon! requesting it.. (excode=\"\n//                                + iconInfos[i].getExtraCode() + \")\");\n\n//                        request(new IconRequest(sn, iconInfos[i]));\n//\n//                        break;\n//                    }\n\n                    if (extraInfo.getType() == ExtraInfoBlock.TYPE_AVAILMSG) {\n                        ByteBlock msgBlock = data.getData();\n                        int len = BinaryTools.getUShort(msgBlock, 0);\n                        byte[] msgBytes = msgBlock.subBlock(2, len).toByteArray();\n\n                        String msg;\n                        try {\n                            msg = new String(msgBytes, \"UTF-8\");\n                        } catch (UnsupportedEncodingException e1) {\n                            e1.printStackTrace();\n                            return;\n                        }\n                        if (msg.length() > 0) {\n                            System.out.println(info.getScreenname()\n                                    + \" availability: \" + msg);\n                        }\n                    }\n                }\n            }\n\n            if (info.getCapabilityBlocks() != null) {\n                List known = Arrays.asList(new CapabilityBlock[] {\n                    CapabilityBlock.BLOCK_CHAT,\n                    CapabilityBlock.BLOCK_DIRECTIM,\n                    CapabilityBlock.BLOCK_FILE_GET,\n                    CapabilityBlock.BLOCK_FILE_SEND,\n                    CapabilityBlock.BLOCK_GAMES,\n                    CapabilityBlock.BLOCK_GAMES2,\n                    CapabilityBlock.BLOCK_ICON,\n                    CapabilityBlock.BLOCK_SENDBUDDYLIST,\n                    CapabilityBlock.BLOCK_TRILLIANCRYPT,\n                    CapabilityBlock.BLOCK_VOICE,\n                    CapabilityBlock.BLOCK_ADDINS,\n                    CapabilityBlock.BLOCK_ICQCOMPATIBLE,\n                    CapabilityBlock.BLOCK_SOMETHING,\n                });\n\n                List caps = new ArrayList(Arrays.asList(\n                        info.getCapabilityBlocks()));\n                caps.removeAll(known);\n                if (!caps.isEmpty()) {\n                    System.out.println(sn + \" has \" + caps.size()\n                            + \" unknown caps:\");\n                    for (Iterator it = caps.iterator(); it.hasNext();) {\n                        System.out.println(\"- \" + it.next());\n                    }\n                }\n/*\n                caps = new ArrayList(known);\n                caps.removeAll(Arrays.asList(info.getCapabilityBlocks()));\n                if (!caps.isEmpty()) {\n                    System.out.println(sn + \" is missing \" + caps.size()\n                            + \" caps:\");\n                    for (Iterator it = caps.iterator(); it.hasNext();) {\n                        System.out.println(\"- \" + it.next());\n                    }\n                }\n*/\n            }\n        } else if (cmd instanceof BuddyOfflineCmd) {\n            BuddyOfflineCmd boc = (BuddyOfflineCmd) cmd;\n\n        } else if (cmd instanceof RateChange) {\n            RateChange rc = (RateChange) cmd;\n\n            System.out.println(\"rate change: current avg is \"\n                    + rc.getRateInfo().getCurrentAvg());\n        }\n    }","commit_id":"a183bf57d933dbbaf10a88819356ae33f1a151ef","url":"https://github.com/VUE/VUE"},{"original_method":"public void itemStateChanged(ItemEvent e) {\n\t\tif (e.getSource().equals(ignoreCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.ignoreIMs(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.ignoreIMs(false);\n\t\t}\n\t\telse if (e.getSource().equals(approveCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.requireApprovalToCollaborate(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.requireApprovalToCollaborate(false);\n\t\t}\n\t\telse if (e.getSource().equals(assignColorCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.assignColorsToContributors(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.assignColorsToContributors(false);\n\t\t}\n\t\telse if (e.getSource().equals(nodeWidthCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceUniformNodeWidth(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceUniformNodeWidth(false);\n\t\t}\n\t\telse if (e.getSource().equals(makeTableCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceNodesIntoTable(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceNodesIntoTable(false);\n\t\t}\n\t\t\t\n\t\t\n\t}","id":22990,"modified_method":"public void itemStateChanged(ItemEvent e) {\n\t\tif (e.getSource().equals(ignoreCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.ignoreIMs(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.ignoreIMs(false);\n\t\t}\n\t\telse if (e.getSource().equals(approveCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.requireApprovalToCollaborate(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.requireApprovalToCollaborate(false);\n\t\t}\n\t\telse if (e.getSource().equals(assignColorCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.assignColorsToContributors(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.assignColorsToContributors(false);\n\t\t}\n\t\telse if (e.getSource().equals(nodeWidthCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceUniformNodeWidth(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceUniformNodeWidth(false);\n\t\t}\n\t\telse if (e.getSource().equals(makeTableCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceNodesIntoTable(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.forceNodesIntoTable(false);\n\t\t}\n\t\telse if (e.getSource().equals(zoomCheckbox))\n\t\t{\n\t\t\tif (((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.keepMapAtOneToOne(true);\n\t\t\telse if (!((JCheckBox)e.getSource()).isSelected() && aim !=null)\n\t\t\t\taim.keepMapAtOneToOne(false);\n\t\t}\n\t\t\t\n\t\t\n\t}","commit_id":"a183bf57d933dbbaf10a88819356ae33f1a151ef","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e) {\n\tif (e.getSource().equals(loginButton))\n\t{\n\t\tif (aim == null)\n\t\t{\n\t\t\taim = new VUEAim(mUsernameEditor.getText(),mPasswordEditor.getText());\n\t\t\taim.addConnectionListener(this);\n\t\t\n\t\t}\n\t\tif (aim.isConnected())\n\t\t\taim.disconnect();\n\t\t\n\t\telse\n\t\t{\n\t\t\taim.connect();\t\t\t\t\t\t\n\t\t\taim.ignoreIMs(ignoreCheckbox.isSelected());\n\t\t\taim.requireApprovalToCollaborate(approveCheckbox.isSelected());\n\t\t\taim.assignColorsToContributors(assignColorCheckbox.isSelected());\n\t\t\taim.forceUniformNodeWidth(nodeWidthCheckbox.isSelected());\n\t\t\taim.forceNodesIntoTable(makeTableCheckbox.isSelected());\n\t\t}\n\t}\n\telse if (e.getSource().equals(resetApproveButton))\n\t{\n\t\tif (aim !=null)\n\t\t\taim.resetApprovalList();\n\t}\n\t\t\n\t}","id":22991,"modified_method":"public void actionPerformed(ActionEvent e) {\n\tif (e.getSource().equals(loginButton))\n\t{\n\t\tif (aim == null)\n\t\t{\n\t\t\taim = new VUEAim(mUsernameEditor.getText(),mPasswordEditor.getText());\n\t\t\taim.addConnectionListener(this);\n\t\t\n\t\t}\n\t\tif (aim.isConnected())\n\t\t\taim.disconnect();\n\t\t\n\t\telse\n\t\t{\n\t\t\taim.connect();\t\t\t\t\t\t\n\t\t\taim.ignoreIMs(ignoreCheckbox.isSelected());\n\t\t\taim.requireApprovalToCollaborate(approveCheckbox.isSelected());\n\t\t\taim.assignColorsToContributors(assignColorCheckbox.isSelected());\n\t\t\taim.forceUniformNodeWidth(nodeWidthCheckbox.isSelected());\n\t\t\taim.forceNodesIntoTable(makeTableCheckbox.isSelected());\n\t\t\taim.keepMapAtOneToOne(zoomCheckbox.isSelected());\n\t\t}\n\t}\n\telse if (e.getSource().equals(resetApproveButton))\n\t{\n\t\tif (aim !=null)\n\t\t\taim.resetApprovalList();\n\t}\n\t\t\n\t}","commit_id":"a183bf57d933dbbaf10a88819356ae33f1a151ef","url":"https://github.com/VUE/VUE"},{"original_method":"public VueAimPanel() {                    \n        \n        JPanel innerPanel = new JPanel();\n        GridBagLayout gridbag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n    \n        //BoxLayout boxLayout = new BoxLayout(innerPanel,BoxLayout.Y_AXIS);\n        innerPanel.setLayout(gridbag);\n        //mTitleEditor = new JTextField();\n        mUsernameEditor = new JTextField();\n        \n        mPasswordEditor = new JPasswordField();\n        assignColorCheckbox = new JCheckBox(VueResources.getString(\"im.button.assigncolor\")); \n        ignoreCheckbox = new JCheckBox(VueResources.getString(\"im.button.ignore\")); \n        approveCheckbox = new JCheckBox(VueResources.getString(\"im.button.approve\"),true);\n        nodeWidthCheckbox = new JCheckBox(VueResources.getString(\"im.button.nodewidth\"),true); \n        makeTableCheckbox = new JCheckBox(VueResources.getString(\"im.button.maketable\"),true); \n\n        resetApproveButton = new JButton(VueResources.getString(\"im.approve.reset\"));\n        resetApproveButton.addActionListener(this);\n        ignoreCheckbox.addItemListener(this);\n        approveCheckbox.addItemListener(this);\n        nodeWidthCheckbox.addItemListener(this);\n        makeTableCheckbox.addItemListener(this);\n        assignColorCheckbox.addItemListener(this);\n        \n        mPropPanel  = new PropertyPanel();\n        //mPropPanel.addProperty( \"Label:\", mTitleEditor); // initially Label was title\n        mPropPanel.addProperty(VueResources.getString(\"im.username\"), mUsernameEditor); //added through metadata\n        mPropPanel.addProperty(VueResources.getString(\"im.password\"), mPasswordEditor);\n\n        JLabel titleLabel = new JLabel(VueResources.getString(\"im.title\"));\n        loginButton = new JButton(VueResources.getString(\"im.button.login\"));\n        loginButton.addActionListener(this);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(titleLabel,c);\n        innerPanel.add(titleLabel);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(mPropPanel,c);\n        innerPanel.add(mPropPanel);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(ignoreCheckbox,c);\n        innerPanel.add(ignoreCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(approveCheckbox,c);\n        innerPanel.add(approveCheckbox);\n\n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(assignColorCheckbox,c);\n        innerPanel.add(assignColorCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(nodeWidthCheckbox,c);\n        innerPanel.add(nodeWidthCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(makeTableCheckbox,c);\n        innerPanel.add(makeTableCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(resetApproveButton,c);\n        innerPanel.add(resetApproveButton);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.NONE;\n        gridbag.setConstraints(loginButton,c);\n        innerPanel.add(loginButton);\n        \n        /**\n         * JPanel metaDataLabelPanel  = new JPanel(new FlowLayout(FlowLayout.LEFT,0,0));\n         * metaDataLabelPanel.add(new JLabel(\"Metadata\"));\n         *\n         * innerPanel.add(metaDataLabelPanel);\n         */\n        \n        \n        JPanel linePanel = new JPanel() {\n            protected void paintComponent(Graphics g) {\n                g.setColor(Color.DARK_GRAY);\n                g.drawLine(0,15, this.getSize().width, 15);\n            }\n        };\n        \n        //c.gridwidth = GridBagConstraints.REMAINDER;\n        //c.fill = GridBagConstraints.HORIZONTAL;\n        //gridbag.setConstraints(linePanel,c);\n        //innerPanel.add(linePanel);\n        //linePanel.setBorder(BorderFactory.createEmptyBorder(10,0,0,0));\n        propertiesEditor = new PropertiesEditor(true);\n        JPanel metadataPanel = new JPanel(new BorderLayout());\n//         if(tufts.vue.ui.InspectorPane.META_VERSION == tufts.vue.ui.InspectorPane.OLD)\n//         {\n//           metadataPanel.add(propertiesEditor,BorderLayout.CENTER);\n//         }\n        //metadataPanel.setBorder(BorderFactory.createEmptyBorder(0,9,0,6));\n        \n        \n         mUsernameEditor.setFont(GUI.LabelFace);\n        \n         // VUE 1001\n         //mLocation.setFont(GUI.LabelFace);\n         mPasswordEditor.setFont(GUI.LabelFace);\n         \n       \n        \n        \n        c.weighty = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.fill = GridBagConstraints.BOTH;\n        gridbag.setConstraints(metadataPanel,c);\n        innerPanel.add(metadataPanel);\n        //innerPanel.add(mInfoScrollPane,BorderLayout.CENTER);\n        //mInfoScrollPane.setSize( new Dimension( 200, 400));\n        //mInfoScrollPane.getViewport().setLayout(new BorderLayout());\n        //mInfoScrollPane.getViewport().add( innerPanel,BorderLayout.CENTER);\n        //mInfoScrollPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));\n        setLayout(new BorderLayout());\n        //setLayout(new BorderLayout());\n        //setBorder( new EmptyBorder(4,4,4,4) );\n        //add(mInfoScrollPane,BorderLayout.NORTH);\n        add(innerPanel,BorderLayout.CENTER);\n        setBorder(BorderFactory.createEmptyBorder(10,10,0,6));\n       \n    }","id":22992,"modified_method":"public VueAimPanel() {                    \n        \n        JPanel innerPanel = new JPanel();\n        GridBagLayout gridbag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n    \n        //BoxLayout boxLayout = new BoxLayout(innerPanel,BoxLayout.Y_AXIS);\n        innerPanel.setLayout(gridbag);\n        //mTitleEditor = new JTextField();\n        mUsernameEditor = new JTextField();\n        \n        mPasswordEditor = new JPasswordField();\n        assignColorCheckbox = new JCheckBox(VueResources.getString(\"im.button.assigncolor\")); \n        ignoreCheckbox = new JCheckBox(VueResources.getString(\"im.button.ignore\")); \n        approveCheckbox = new JCheckBox(VueResources.getString(\"im.button.approve\"),true);\n        nodeWidthCheckbox = new JCheckBox(VueResources.getString(\"im.button.nodewidth\"),true); \n        makeTableCheckbox = new JCheckBox(VueResources.getString(\"im.button.maketable\"),true); \n        zoomCheckbox = new JCheckBox(VueResources.getString(\"im.button.zoom\"),true); \n\n        resetApproveButton = new JButton(VueResources.getString(\"im.approve.reset\"));\n        resetApproveButton.addActionListener(this);\n        ignoreCheckbox.addItemListener(this);\n        approveCheckbox.addItemListener(this);\n        nodeWidthCheckbox.addItemListener(this);\n        makeTableCheckbox.addItemListener(this);\n        assignColorCheckbox.addItemListener(this);\n        zoomCheckbox.addItemListener(this);\n        \n        mPropPanel  = new PropertyPanel();\n        //mPropPanel.addProperty( \"Label:\", mTitleEditor); // initially Label was title\n        mPropPanel.addProperty(VueResources.getString(\"im.username\"), mUsernameEditor); //added through metadata\n        mPropPanel.addProperty(VueResources.getString(\"im.password\"), mPasswordEditor);\n\n        JLabel titleLabel = new JLabel(VueResources.getString(\"im.title\"));\n        loginButton = new JButton(VueResources.getString(\"im.button.login\"));\n        loginButton.addActionListener(this);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(titleLabel,c);\n        innerPanel.add(titleLabel);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(mPropPanel,c);\n        innerPanel.add(mPropPanel);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(ignoreCheckbox,c);\n        innerPanel.add(ignoreCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(approveCheckbox,c);\n        innerPanel.add(approveCheckbox);\n\n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(assignColorCheckbox,c);\n        innerPanel.add(assignColorCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(nodeWidthCheckbox,c);\n        innerPanel.add(nodeWidthCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(makeTableCheckbox,c);\n        innerPanel.add(makeTableCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(zoomCheckbox,c);\n        innerPanel.add(zoomCheckbox);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(resetApproveButton,c);\n        innerPanel.add(resetApproveButton);\n        \n        c.weightx = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.NORTHWEST;\n        c.fill = GridBagConstraints.NONE;\n        gridbag.setConstraints(loginButton,c);\n        innerPanel.add(loginButton);\n        \n        /**\n         * JPanel metaDataLabelPanel  = new JPanel(new FlowLayout(FlowLayout.LEFT,0,0));\n         * metaDataLabelPanel.add(new JLabel(\"Metadata\"));\n         *\n         * innerPanel.add(metaDataLabelPanel);\n         */\n        \n        \n        JPanel linePanel = new JPanel() {\n            protected void paintComponent(Graphics g) {\n                g.setColor(Color.DARK_GRAY);\n                g.drawLine(0,15, this.getSize().width, 15);\n            }\n        };\n        \n        //c.gridwidth = GridBagConstraints.REMAINDER;\n        //c.fill = GridBagConstraints.HORIZONTAL;\n        //gridbag.setConstraints(linePanel,c);\n        //innerPanel.add(linePanel);\n        //linePanel.setBorder(BorderFactory.createEmptyBorder(10,0,0,0));\n        propertiesEditor = new PropertiesEditor(true);\n        JPanel metadataPanel = new JPanel(new BorderLayout());\n//         if(tufts.vue.ui.InspectorPane.META_VERSION == tufts.vue.ui.InspectorPane.OLD)\n//         {\n//           metadataPanel.add(propertiesEditor,BorderLayout.CENTER);\n//         }\n        //metadataPanel.setBorder(BorderFactory.createEmptyBorder(0,9,0,6));\n        \n        \n         mUsernameEditor.setFont(GUI.LabelFace);\n        \n         // VUE 1001\n         //mLocation.setFont(GUI.LabelFace);\n         mPasswordEditor.setFont(GUI.LabelFace);\n         \n       \n        \n        \n        c.weighty = 1.0;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.fill = GridBagConstraints.BOTH;\n        gridbag.setConstraints(metadataPanel,c);\n        innerPanel.add(metadataPanel);\n        //innerPanel.add(mInfoScrollPane,BorderLayout.CENTER);\n        //mInfoScrollPane.setSize( new Dimension( 200, 400));\n        //mInfoScrollPane.getViewport().setLayout(new BorderLayout());\n        //mInfoScrollPane.getViewport().add( innerPanel,BorderLayout.CENTER);\n        //mInfoScrollPane.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));\n        setLayout(new BorderLayout());\n        //setLayout(new BorderLayout());\n        //setBorder( new EmptyBorder(4,4,4,4) );\n        //add(mInfoScrollPane,BorderLayout.NORTH);\n        add(innerPanel,BorderLayout.CENTER);\n        setBorder(BorderFactory.createEmptyBorder(10,10,0,6));\n       \n    }","commit_id":"a183bf57d933dbbaf10a88819356ae33f1a151ef","url":"https://github.com/VUE/VUE"},{"original_method":"private void runSaveAction(ActionEvent e) {\n        if(searchTermsTbl.isEditing())\n            searchTermsTbl.getCellEditor().stopCellEditing();\n        final SearchData data = new SearchData();\n        final List<SearchData> searchDataList = new ArrayList<SearchData>();\n        //searchDataList = new ArrayList<SearchData>();                    \n        final String searchName = getSearchName(searchResultModel.getRowCount());\n\n        if (searchName != null) {\n            // data.setSearchType(searchTypeCmbBox.getSelectedItem().toString().trim());\n            // data.setMapType(mapCmbBox.getSelectedItem().toString().trim());\n            // data.setResultType(resultCmbBox.getSelectedItem().toString().trim());                    \n            //data.setAndOrType(selectedOp.key);\n            //data.setAndOrType(strAndOrType);\n            \n            data.setSearchSaveName(searchName);\n            data.setSearchType(getChosenString(choiceFields));\n            data.setMapType(getChosenString(choiceDomain));\n            data.putResultOp((SearchAction.ResultOp) getChosen(choiceResult));\n            data.putLogicalOp(selectedOp);\n            data.setDataList(searchTerms);\n            \n            searchDataList.add(data);                    \n            searchResultModel.addRow(data);\n            \n            searchTerms = new ArrayList<VueMetadataElement>();\n            ((SearchTermsTableModel) searchTermsTbl.getModel()).refresh();\n            VUE.getActiveMap().markAsModified();\n\n            if (searchResultModel.getData() != null && VUE.getActiveMap() != null) {\n                VUE.getActiveMap().setSearchArrLst(searchResultModel.getData());\n            }\n        }\n    }","id":22993,"modified_method":"private void runSaveAction(ActionEvent e) {\n        if(searchTermsTbl.isEditing())\n            searchTermsTbl.getCellEditor().stopCellEditing();\n        final SearchData data = new SearchData();\n        final List<SearchData> searchDataList = new ArrayList<SearchData>();\n        //searchDataList = new ArrayList<SearchData>();                    \n        final String searchName = getSearchName(searchResultModel.getRowCount());\n\n        if (searchName != null) {\n            // data.setSearchType(searchTypeCmbBox.getSelectedItem().toString().trim());\n            // data.setMapType(mapCmbBox.getSelectedItem().toString().trim());\n            // data.setResultType(resultCmbBox.getSelectedItem().toString().trim());                    \n            //data.setAndOrType(selectedOp.key);\n            //data.setAndOrType(strAndOrType);\n            \n            data.setSearchSaveName(searchName);\n            data.setMapType(getChosenString(choiceScope)); // todo: use locale-independent string, tho I've a hard time imagining anyone saving an all-maps search...\n            data.setSearchType(getChosenString(choiceDomain));\n            data.putResultOp((SearchAction.ResultOp) getChosen(choiceResult));\n            data.putLogicalOp(selectedOp);\n            data.setDataList(searchTerms);\n            \n            searchDataList.add(data);                    \n            searchResultModel.addRow(data);\n            \n            searchTerms = new ArrayList<VueMetadataElement>();\n            ((SearchTermsTableModel) searchTermsTbl.getModel()).refresh();\n            VUE.getActiveMap().markAsModified();\n\n            if (searchResultModel.getData() != null && VUE.getActiveMap() != null) {\n                VUE.getActiveMap().setSearchArrLst(searchResultModel.getData());\n            }\n        }\n    }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public void activeChanged(ActiveEvent<LWMap> e) {\n    \tfillSavedSearch();\n    }","id":22994,"modified_method":"public void activeChanged(ActiveEvent<LWMap> e) {\n    \tloadActiveMapState(e.active);\n    }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public MetadataPanel() {\n            searchResultTbl = new JTable(searchResultModel);    \n            searchResultModel.setEditableFlag(false);\n            //searchResultTbl.setOpaque(true);            \n            searchResultTbl\n                    .setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n            searchResultTbl.setDefaultRenderer(java.lang.Object.class,\n                    new SavedSearchTableRenderer(searchResultModel));\n            //searchResultTbl.setCellEditor( new SearchResultTableEditor(new JCheckBox()));\n            \n            ((DefaultCellEditor) searchResultTbl\n                    .getDefaultEditor(java.lang.Object.class))\n                    .setClickCountToStart(1);\n            JMenuItem resetMenuItem = new JMenuItem(RESET_STR);\n            popupMenu.add(resetMenuItem);\n            popupMenu.addSeparator();\n            resetMenuItem.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent event) {\n                \tSearchAction.revertGlobalSearchSelectionFromMSGUI();\n                    VUE.getActiveViewer().repaint();\n                }\n            });\n            JMenuItem renameMenuItem = new JMenuItem(RENAME_STR);\n            popupMenu.add(renameMenuItem);\n            popupMenu.addSeparator();\n            JMenuItem deleteMenuItem = new JMenuItem(DELETE_STR);\n            popupMenu.add(deleteMenuItem);            \n            deleteMenuItem.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent event) {\n                    int selectedIndex = searchResultTbl.getSelectedRow();\n                    if (selectedIndex != -1){\n                        searchResultModel.removeRow(selectedIndex);\n                    }\n                }\n            });\n            renameMenuItem.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent event) {\n                    searchResultModel.setEditableFlag(true);\n                    int selectedIndex = searchResultTbl.getSelectedRow();\n                    if (selectedIndex != -1){\n                        searchResultTbl.editCellAt(selectedIndex, 0);\n                        searchResultModel.setEditableFlag(false);\n                    }\n                }\n            });\n            // add the listener to the jtable\n            MouseListener popupListener = new PopupListener();\n            // add the listener specifically to the header\n            searchResultTbl.addMouseListener(popupListener);\n            searchResultTbl.setIntercellSpacing(new Dimension(0,1));\n            searchResultTbl.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n            searchResultTbl.setShowGrid(true); \n            searchResultTbl.setGridColor(Color.LIGHT_GRAY);\n            searchResultTbl.setRowHeight(23);           \n            //searchResultTbl.setBackground(this.getBackground());\n\n            //searchResultTbl.getColumnModel().getColumn(1).setMaxWidth(30);\n            //searchResultTbl.getColumnModel().getColumn(1).setMinWidth(30);\n            searchResultTbl.getColumnModel().getColumn(1).setPreferredWidth(100);\n            \n            //searchResultTbl.setOpaque(true);\n            \n            // searchResultTbl.setMinimumSize(new Dimension(300,80));\n\n            GridBagLayout gridBag = new GridBagLayout();\n            GridBagConstraints gBC = new GridBagConstraints();\n            gBC.fill = GridBagConstraints.HORIZONTAL;\n            JPanel panel = new JPanel(); \n            panel.setLayout(new BorderLayout());\n           \n            gBC.gridx = 0;\n    \t    gBC.gridy = 0;\n    \t    gBC.weightx = 1.0;\t    \n            gridBag.setConstraints(searchResultTbl, gBC);\n            panel.add(searchResultTbl,BorderLayout.NORTH);\n            panel.add(new JLabel(DEBUG.BOXES ? \"x\" : \" \"), BorderLayout.SOUTH);\n            setLayout(new BorderLayout());\n            add(panel);\n\n            // add(searchResultTbl);\n            setName(VueResources.getString(\"searchgui.keywords\"));\n        }","id":22995,"modified_method":"public MetadataPanel() {\n            searchResultTbl = new JTable(searchResultModel);    \n            searchResultModel.setEditableFlag(false);\n            //searchResultTbl.setOpaque(true);            \n            searchResultTbl\n                    .setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n            searchResultTbl.setDefaultRenderer(java.lang.Object.class,\n                    new SavedSearchTableRenderer(searchResultModel));\n            //searchResultTbl.setCellEditor( new SearchResultTableEditor(new JCheckBox()));\n            \n            ((DefaultCellEditor) searchResultTbl\n                    .getDefaultEditor(java.lang.Object.class))\n                    .setClickCountToStart(1);\n            JMenuItem resetMenuItem = new JMenuItem(RESET_STR);\n            popupMenu.add(resetMenuItem);\n            popupMenu.addSeparator();\n            resetMenuItem.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent event) {\n                \tSearchAction.revertGlobalSearchSelectionFromMSGUI();\n                    VUE.getActiveViewer().repaint();\n                }\n            });\n            JMenuItem renameMenuItem = new JMenuItem(RENAME_STR);\n            popupMenu.add(renameMenuItem);\n            popupMenu.addSeparator();\n            JMenuItem deleteMenuItem = new JMenuItem(DELETE_STR);\n            popupMenu.add(deleteMenuItem);            \n            deleteMenuItem.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent event) {\n                    int selectedIndex = searchResultTbl.getSelectedRow();\n                    if (selectedIndex != -1){\n                        searchResultModel.removeRow(selectedIndex);\n                    }\n                }\n            });\n            renameMenuItem.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent event) {\n                    searchResultModel.setEditableFlag(true);\n                    int selectedIndex = searchResultTbl.getSelectedRow();\n                    if (selectedIndex != -1){\n                        searchResultTbl.editCellAt(selectedIndex, 0);\n                        searchResultModel.setEditableFlag(false);\n                    }\n                }\n            });\n            // add the listener to the jtable\n            MouseListener popupListener = new PopupListener();\n            // add the listener specifically to the header\n            searchResultTbl.addMouseListener(popupListener);\n            searchResultTbl.setIntercellSpacing(new Dimension(0,1));\n            searchResultTbl.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n            searchResultTbl.setShowGrid(true); \n            searchResultTbl.setGridColor(Color.LIGHT_GRAY);\n            searchResultTbl.setRowHeight(23);           \n            //searchResultTbl.setBackground(this.getBackground());\n\n            //searchResultTbl.getColumnModel().getColumn(1).setMaxWidth(30);\n            //searchResultTbl.getColumnModel().getColumn(1).setMinWidth(30);\n            searchResultTbl.getColumnModel().getColumn(1).setPreferredWidth(100);\n            \n            //searchResultTbl.setOpaque(true);\n            \n            // searchResultTbl.setMinimumSize(new Dimension(300,80));\n\n            GridBagLayout gridBag = new GridBagLayout();\n            GridBagConstraints gBC = new GridBagConstraints();\n            gBC.fill = GridBagConstraints.HORIZONTAL;\n            JPanel panel = new JPanel(); \n            panel.setLayout(new BorderLayout());\n           \n            gBC.gridx = 0;\n    \t    gBC.gridy = 0;\n    \t    gBC.weightx = 1.0;\t    \n            gridBag.setConstraints(searchResultTbl, gBC);\n            panel.add(searchResultTbl,BorderLayout.NORTH);\n            panel.add(new JLabel(DEBUG.BOXES ? \"x\" : \" \"), BorderLayout.SOUTH);\n            setLayout(new BorderLayout());\n            add(panel);\n\n            // add(searchResultTbl);\n            setName(VueResources.local(\"searchgui.keywords\"));\n        }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public MetadataSearchMainGUI(DockWindow w) {\n        super();\n\n        if (Util.isMacLeopard() && DEBUG.TEST) {\n            macLeopardAndOr = getButtonBox(LogicOps);\n            andOrCmbBox = new JComboBox(LogicOps);\n            //andOrCmbBox = null;\n        } else {\n            andOrCmbBox = new JComboBox(LogicOps);\n            macLeopardAndOr = null;\n        }\n        \n        JPopupMenu popup = new JPopupMenu();\n        mapInfoStack = new WidgetStack(SEARCH_STR);        \n        VUE.addActiveListener(LWMap.class, this);\n        setMinimumSize(new Dimension(300, 250));\n        setLayout(new BorderLayout());\n        mInfoPanel = new MetaSearchPanel();\n        mInfoPanel.setName(SEARCH_STR);\n        metadataPanel = new MetadataPanel();\n        metadataPanel.setName(SAVED_SEARCH_STR);\n        //Widget.setWantsScroller(mapInfoStack, true);        \n        adjustHeaderTableColumnModel();\n        // mTabbedPane.addTab(metadataPanel.getName(),metadataPanel);\n        // mapInfoStack.addPane(mInfoPanel, 1f);\n        // mapInfoStack.addPane(metadataPanel, 2f);  \n        mapInfoStack.addPane(SEARCH_STR,mInfoPanel);\n        mapInfoStack.addPane(metadataPanel, 2f);\n        // Widget.setWantsScroller(mapInfoStack, true);\n\n        // SearchTextField.editSettingsMenuItem should have a WindowDisplayAction linked to the DockWindow\n        // so that it will be properly and automatically checked, but it was created before this DockWindow\n        // existed;  now that the DockWindow exists, change the menu item's action to be a WindowDisplayAction.\n        if (SearchTextField.editSettingsMenuItem != null) {\n        \tWindowDisplayAction wda = new WindowDisplayAction(w);\n            \n        \twda.setTitle(VueResources.getString(\"search.popup.edit.search.settings\"));\n        \twda.setLinkedButton(SearchTextField.editSettingsMenuItem);\n        \n        \tSearchTextField.editSettingsMenuItem.setAction(wda);\n        }\n\n        saveSearchAction = new AbstractAction(SAVE_SEARCH_STR) {\n            public void actionPerformed(ActionEvent e) {\n                if (DEBUG.Enabled) Log.debug(\"saveSearchAction: \" + e);\n                runSaveAction(e);\n            }\n        };\n\n        runSearchAction = new AbstractAction(RUN_SEARCH_STR)\n                { public void actionPerformed(ActionEvent e) { runSavedSearch(); }};\n\n        renameAction = new AbstractAction(RENAME_STR) {\n            public void actionPerformed(ActionEvent e) {\n                searchResultModel.setEditableFlag(true);\n                int selectedIndex = searchResultTbl.getSelectedRow();\n                if (selectedIndex != -1){\n                    searchResultTbl.editCellAt(selectedIndex, 0);\n                    searchResultModel.setEditableFlag(false);\n                }\n            }\n        };\n\n        deleteAction = new AbstractAction(DELETE_STR) {\n            public void actionPerformed(ActionEvent e) {\n                int selectedIndex = searchResultTbl.getSelectedRow();\n                if (selectedIndex != -1){\n                    searchResultModel.removeRow(selectedIndex);\n                }\n            }\n        };\n\n        Widget.setMenuActions(metadataPanel, new Action[] { saveSearchAction,\n                runSearchAction, renameAction, deleteAction });        \n        Widget.setWantsScroller(mapInfoStack, true);\n        Widget.setWantsScrollerAlways(mapInfoStack, true);\n        w.setContent(mapInfoStack);       \n        w.setHeight(350);\n        w.setWidth(300);\n        validate();\n        setVisible(true);\n    }","id":22996,"modified_method":"public MetadataSearchMainGUI(DockWindow w) {\n        super();\n\n        if (Util.isMacLeopard() && DEBUG.TEST) {\n            macLeopardAndOr = getButtonBox(LogicOps);\n            andOrCmbBox = new JComboBox(LogicOps);\n            //andOrCmbBox = null;\n        } else {\n            andOrCmbBox = new JComboBox(LogicOps);\n            macLeopardAndOr = null;\n        }\n        \n        JPopupMenu popup = new JPopupMenu();\n        mapInfoStack = new WidgetStack(SEARCH_STR);        \n        VUE.addActiveListener(LWMap.class, this);\n        setMinimumSize(new Dimension(300, 250));\n        setLayout(new BorderLayout());\n        mInfoPanel = new MetaSearchPanel();\n        mInfoPanel.setName(SEARCH_STR);\n        metadataPanel = new MetadataPanel();\n        metadataPanel.setName(SAVED_SEARCH_STR);\n        //Widget.setWantsScroller(mapInfoStack, true);        \n        adjustHeaderTableColumnModel();\n        // mTabbedPane.addTab(metadataPanel.getName(),metadataPanel);\n        // mapInfoStack.addPane(mInfoPanel, 1f);\n        // mapInfoStack.addPane(metadataPanel, 2f);  \n        mapInfoStack.addPane(SEARCH_STR,mInfoPanel);\n        mapInfoStack.addPane(metadataPanel, 2f);\n        // Widget.setWantsScroller(mapInfoStack, true);\n\n        // SearchTextField.editSettingsMenuItem should have a WindowDisplayAction linked to the DockWindow\n        // so that it will be properly and automatically checked, but it was created before this DockWindow\n        // existed;  now that the DockWindow exists, change the menu item's action to be a WindowDisplayAction.\n        if (SearchTextField.editSettingsMenuItem != null) {\n        \tWindowDisplayAction wda = new WindowDisplayAction(w);\n            \n        \twda.setTitle(VueResources.local(\"search.popup.edit.search.settings\"));\n        \twda.setLinkedButton(SearchTextField.editSettingsMenuItem);\n        \n        \tSearchTextField.editSettingsMenuItem.setAction(wda);\n        }\n\n        saveSearchAction = new AbstractAction(SAVE_SEARCH_STR) {\n            public void actionPerformed(ActionEvent e) {\n                if (DEBUG.Enabled) Log.debug(\"saveSearchAction: \" + e);\n                runSaveAction(e);\n            }\n        };\n\n        runSearchAction = new AbstractAction(RUN_SEARCH_STR)\n                { public void actionPerformed(ActionEvent e) { runSavedSearch(); }};\n\n        renameAction = new AbstractAction(RENAME_STR) {\n            public void actionPerformed(ActionEvent e) {\n                searchResultModel.setEditableFlag(true);\n                int selectedIndex = searchResultTbl.getSelectedRow();\n                if (selectedIndex != -1){\n                    searchResultTbl.editCellAt(selectedIndex, 0);\n                    searchResultModel.setEditableFlag(false);\n                }\n            }\n        };\n\n        deleteAction = new AbstractAction(DELETE_STR) {\n            public void actionPerformed(ActionEvent e) {\n                int selectedIndex = searchResultTbl.getSelectedRow();\n                if (selectedIndex != -1){\n                    searchResultModel.removeRow(selectedIndex);\n                }\n            }\n        };\n\n        Widget.setMenuActions(metadataPanel, new Action[] { saveSearchAction,\n                runSearchAction, renameAction, deleteAction });        \n        Widget.setWantsScroller(mapInfoStack, true);\n        Widget.setWantsScrollerAlways(mapInfoStack, true);\n        w.setContent(mapInfoStack);       \n        w.setHeight(350);\n        w.setWidth(300);\n        validate();\n        setVisible(true);\n    }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public void fillSavedSearch() {     \n    \t\n    \tList savedList =null;\n    \tif (VUE.getActiveMap() !=null) {\n            savedList = VUE.getActiveMap().getSearchArrLst();\n            if (DEBUG.SEARCH && DEBUG.RDF) {\n                Log.debug(\"saved searches:\", new Throwable(\"HERE\"));\n                Util.dump(savedList);\n            }\n        }\n        if(savedList!=null){\n            searchResultModel.setData((ArrayList)savedList);\n        }else{\t\t\t\n            searchResultModel.setData(null);\n        }\n    }","id":22997,"modified_method":"public void fillSavedSearch() { // called only by VUE.java (init I presume)\n        loadActiveMapState(VUE.getActiveMap());\n    }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public String getName() {\n            return VueResources.getString(\"searchgui.search\");\n        }","id":22998,"modified_method":"public String getName() {\n            return VueResources.local(\"searchgui.search\");\n        }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public java.awt.Component getTableCellRendererComponent(JTable table,\n                Object value, boolean isSelected, boolean hasFocus, int row,\n                int col) {\n            JLabel comp = new JLabel();\n            comp.setFont(tufts.vue.gui.GUI.LabelFace);            \n            if (col == headerButtonColumn) {\n                comp.setIcon(tufts.vue.VueResources.getIcon(\"metadata.editor.add.up\"));\n            } else if (table.getModel().getColumnCount() == 3\n                    && col == headerValueColumn) {\n                if (searchType == SEARCH_EVERYTHING) {\n                    comp.setText(VueResources.getString(\"advancedSearch.searcheverything\"));\n                }\n\n                if (searchType == SEARCH_ONLY_LABELS) {\n                    comp.setText(VueResources.getString(\"advancedSearch.label\"));\n                }\n\n                if (searchType == SEARCH_ONLY_KEYWORDS) {\n                    comp.setText(VueResources.getString(\"advancedSearch.keywords\"));\n                }\n                if(searchType == SEARCH_WITH_CATEGORIES){                    \n                    comp.setText(VueResources.getString(\"advancedSearch.category\"));    \n                }                \n\n            } else if ((table.getModel().getColumnCount() == 4)\n                    && col == headerCategoryColumn) {                \n                comp.setText(VueResources.getString(\"advancedSearch.category\"));\n            } else if ((table.getModel().getColumnCount() == 4 )\n                    && col == headerValueColumn){\n                comp.setText(VueResources.getString(\"advancedSearch.keywords\"));\n            }\n\n            comp.setOpaque(true);\n            comp.setBackground(MetadataSearchMainGUI.this.getBackground());\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n            \tcomp.setBackground(Color.YELLOW);\n            }\n\n            return comp;\n        }","id":22999,"modified_method":"public java.awt.Component getTableCellRendererComponent(JTable table,\n                Object value, boolean isSelected, boolean hasFocus, int row,\n                int col) {\n            JLabel comp = new JLabel();\n            comp.setFont(tufts.vue.gui.GUI.LabelFace);            \n            if (col == headerButtonColumn) {\n                comp.setIcon(tufts.vue.VueResources.getIcon(\"metadata.editor.add.up\"));\n            } else if (table.getModel().getColumnCount() == 3\n                    && col == headerValueColumn) {\n                if (searchType == SEARCH_EVERYTHING) {\n                    comp.setText(VueResources.local(\"advancedSearch.searcheverything\"));\n                }\n\n                if (searchType == SEARCH_ONLY_LABELS) {\n                    comp.setText(VueResources.local(\"advancedSearch.label\"));\n                }\n\n                if (searchType == SEARCH_ONLY_KEYWORDS) {\n                    comp.setText(VueResources.local(\"advancedSearch.keywords\"));\n                }\n                if(searchType == SEARCH_WITH_CATEGORIES){                    \n                    comp.setText(VueResources.local(\"advancedSearch.category\"));    \n                }                \n\n            } else if ((table.getModel().getColumnCount() == 4)\n                    && col == headerCategoryColumn) {                \n                comp.setText(VueResources.local(\"advancedSearch.category\"));\n            } else if ((table.getModel().getColumnCount() == 4 )\n                    && col == headerValueColumn){\n                comp.setText(VueResources.local(\"advancedSearch.keywords\"));\n            }\n\n            comp.setOpaque(true);\n            comp.setBackground(MetadataSearchMainGUI.this.getBackground());\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n            \tcomp.setBackground(Color.YELLOW);\n            }\n\n            return comp;\n        }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"}]