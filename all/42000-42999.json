[{"original_method":"@Override\r\n  void analyze(final TokenList tl) {\r\n    final Data data = ctx.data;\r\n    // file size\r\n    tl.add(format(data.meta.filesize));\r\n    // number of nodes\r\n    tl.add(data.meta.size);\r\n    // maximum number of attributes per element\r\n    //add(tl, \"max(for $d in //* return count($d/@*))\");\r\n    tl.add(\"xxx\");\r\n    // total number of element names\r\n    tl.add(data.tagindex.size());\r\n    //add(tl, \"count(distinct-values(for $d in //* return name($d)))\");\r\n    // total number of attribute names\r\n    tl.add(data.atnindex.size());\r\n    //add(tl, \"count(distinct-values(for $d in //@* return name($d)))\");\r\n    // total number of namespace URIs\r\n    tl.add(data.ns.size());\r\n    // total string length of text nodes\r\n    tl.add(ctx.data.meta.file(DATATXT).length());\r\n    //add(tl, \"sum(for $d in //text() return string-length($d) + 1)\");\r\n    // total string length of attribute values\r\n    tl.add(ctx.data.meta.file(DATAATV).length());\r\n    //add(tl, \"sum(for $d in //@* return string-length($d) + 1)\");\r\n    // database size\r\n    tl.add(format(data.meta.dbsize()));\r\n    // number of documents\r\n    tl.add(data.doc().length);\r\n  }","id":42000,"modified_method":"@Override\r\n  void analyze(final TokenList tl) {\r\n    final Data data = ctx.data;\r\n    // file size\r\n    tl.add(format(data.meta.filesize));\r\n    // number of nodes\r\n    tl.add(data.meta.size);\r\n    // maximum number of attributes per element\r\n    //add(tl, \"max(for $d in //* return count($d/@*))\");\r\n    tl.add(\"xxx\");\r\n    // total number of element names\r\n    tl.add(data.tagindex.size());\r\n    //add(tl, \"count(distinct-values(for $d in //* return name($d)))\");\r\n    // total number of attribute names\r\n    tl.add(data.atnindex.size());\r\n    //add(tl, \"count(distinct-values(for $d in //@* return name($d)))\");\r\n    // total number of namespace URIs\r\n    tl.add(data.ns.size());\r\n    // total string length of text nodes\r\n    tl.add(ctx.data.meta.file(DATATXT).length());\r\n    //add(tl, \"sum(for $d in //text() return string-length($d) + 1)\");\r\n    // total string length of attribute values\r\n    tl.add(ctx.data.meta.file(DATAATV).length());\r\n    //add(tl, \"sum(for $d in //@* return string-length($d) + 1)\");\r\n    // database size\r\n    tl.add(format(data.meta.dbsize()));\r\n    // number of documents\r\n    tl.add(data.doc().size());\r\n  }","commit_id":"ce98591b3b4d664783fa014cd42f89f9acb7e35e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses the specified test case.\n   * @param root root node\n   * @throws Exception exception\n   * @return true if the query, specified by {@link #single}, was evaluated\n   */\n  private boolean parse(final Nodes root) throws Exception {\n    final String pth = text(\"@FilePath\", root);\n    final String outname = text(\"@name\", root);\n    if(single != null && !outname.startsWith(single)) return true;\n\n    final Performance perf = new Performance();\n    if(verbose) Util.out(\"- \" + outname);\n\n    boolean inspect = false;\n    boolean correct = true;\n\n    final Nodes nodes = states(root);\n    for(int n = 0; n < nodes.size(); ++n) {\n      final Nodes state = new Nodes(nodes.list[n], nodes.data);\n\n      final String inname = text(\"*:query/@name\", state);\n      context.query = new IOFile(queries + pth + inname + IO.XQSUFFIX);\n      final String in = read(context.query);\n      String er = null;\n      ItemCache iter = null;\n      boolean doc = true;\n\n      final Nodes cont = nodes(\"*:contextItem\", state);\n      Nodes curr = null;\n      if(cont.size() != 0) {\n        final Data d = Check.check(context,\n            srcs.get(string(data.atom(cont.list[0]))));\n        curr = new Nodes(d.doc(), d);\n        curr.root = true;\n      }\n\n      context.prop.set(Prop.QUERYINFO, compile);\n      final QueryProcessor xq = new QueryProcessor(in, curr, context);\n      context.prop.set(Prop.QUERYINFO, false);\n\n      // limit result sizes to 1MB\n      final ArrayOutput ao = new ArrayOutput();\n      final TokenBuilder files = new TokenBuilder();\n\n      try {\n        files.add(file(nodes(\"*:input-file\", state),\n            nodes(\"*:input-file/@variable\", state), xq, n == 0));\n        files.add(file(nodes(\"*:defaultCollection\", state),\n            null, xq, n == 0));\n\n        var(nodes(\"*:input-URI\", state),\n            nodes(\"*:input-URI/@variable\", state), xq);\n        eval(nodes(\"*:input-query/@name\", state),\n            nodes(\"*:input-query/@variable\", state), pth, xq);\n\n        parse(xq, state);\n\n        for(final int p : nodes(\"*:module\", root).list) {\n          final String uri = text(\"@namespace\", new Nodes(p, data));\n          final String file = mods.get(string(data.atom(p))) + IO.XQSUFFIX;\n          xq.module(file, uri);\n        }\n\n        // evaluate and serialize query\n        final SerializerProp sp = new SerializerProp();\n        sp.set(SerializerProp.S_INDENT, context.prop.is(Prop.CHOP) ?\n            DataText.YES : DataText.NO);\n        final XMLSerializer xml = new XMLSerializer(ao, sp);\n\n        iter = xq.value().cache();\n        for(Item it; (it = iter.next()) != null;) {\n          doc &= it.type == NodeType.DOC;\n          it.serialize(xml);\n        }\n        xml.close();\n      } catch(final Exception ex) {\n        if(!(ex instanceof QueryException || ex instanceof IOException)) {\n          System.err.println(\"\\n*** \" + outname + \" ***\");\n          System.err.println(in + \"\\n\");\n          ex.printStackTrace();\n        }\n        er = ex.getMessage();\n        if(er.startsWith(STOPPED)) er = er.substring(er.indexOf('\\n') + 1);\n        if(er.startsWith(\"[\")) er = er.replaceAll(\"\\\\[(.*?)\\\\] (.*)\", \"$1 $2\");\n        // unexpected error - dump stack trace\n      }\n\n      // print compilation steps\n      if(compile) {\n        Util.errln(\"---------------------------------------------------------\");\n        Util.err(xq.info());\n        Util.errln(in);\n      }\n\n      final Nodes expOut = nodes(\"*:output-file/text()\", state);\n      final TokenList result = new TokenList();\n      for(int o = 0; o < expOut.size(); ++o) {\n        final String resFile = string(data.atom(expOut.list[o]));\n        final IOFile exp = new IOFile(expected + pth + resFile);\n        result.add(read(exp));\n      }\n\n      final Nodes cmpFiles = nodes(\"*:output-file/@compare\", state);\n      boolean xml = false;\n      boolean frag = false;\n      boolean ignore = false;\n      for(int o = 0; o < cmpFiles.size(); ++o) {\n        final byte[] type = data.atom(cmpFiles.list[o]);\n        xml |= eq(type, XML);\n        frag |= eq(type, FRAGMENT);\n        ignore |= eq(type, IGNORE);\n      }\n\n      String expError = text(\"*:expected-error/text()\", state);\n\n      final StringBuilder log = new StringBuilder(pth + inname + IO.XQSUFFIX);\n      if(files.size() != 0) {\n        log.append(\" [\");\n        log.append(files);\n        log.append(\"]\");\n      }\n      log.append(NL);\n\n      /** Remove comments. */\n      log.append(norm(in));\n      log.append(NL);\n      final String logStr = log.toString();\n      // skip queries with variable results\n      final boolean print = currTime || !logStr.contains(\"current-\");\n\n      boolean correctError = false;\n      if(er != null && (expOut.size() == 0 || !expError.isEmpty())) {\n        expError = error(pth + outname, expError);\n        final String code = er.substring(0, Math.min(8, er.length()));\n        for(final String e : SLASH.split(expError)) {\n          if(code.equals(e)) {\n            correctError = true;\n            break;\n          }\n        }\n      }\n\n      if(correctError) {\n        if(print) {\n          logOK.append(logStr);\n          logOK.append(\"[Right] \");\n          logOK.append(norm(er));\n          logOK.append(NL);\n          logOK.append(NL);\n          addLog(pth, outname + \".log\", er);\n        }\n        ++ok;\n      } else if(er == null) {\n        int s = -1;\n        final int rs = result.size();\n\n        while(!ignore && ++s < rs) {\n          inspect |= s < cmpFiles.list.length &&\n            eq(data.atom(cmpFiles.list[s]), INSPECT);\n\n          final byte[] res = result.get(s), actual = ao.toArray();\n          if(res.length == ao.size() && eq(res, actual)) break;\n\n          if(xml || frag) {\n            iter.reset();\n\n            try {\n              final ItemCache ic = toIter(string(res).replaceAll(\n                  \"^<\\\\?xml.*?\\\\?>\", \"\").trim(), frag);\n              if(FNSimple.deep(null, iter, ic)) break;\n\n              ic.reset();\n              final ItemCache ia = toIter(string(actual), frag);\n              if(FNSimple.deep(null, ia, ic)) break;\n            } catch(final Throwable ex) {\n              System.err.println(\"\\n\" + outname + \":\");\n              ex.printStackTrace();\n            }\n          }\n        }\n        if((rs > 0 || !expError.isEmpty()) && s == rs && !inspect) {\n          if(print) {\n            if(expOut.size() == 0) result.add(error(pth + outname, expError));\n            logErr.append(logStr);\n            logErr.append(\"[\" + testid + \" ] \");\n            logErr.append(norm(string(result.get(0))));\n            logErr.append(NL);\n            logErr.append(\"[Wrong] \");\n            logErr.append(norm(ao.toString()));\n            logErr.append(NL);\n            logErr.append(NL);\n            addLog(pth, outname + (xml ? IO.XMLSUFFIX : \".txt\"),\n                ao.toString());\n          }\n          correct = false;\n          ++err;\n        } else {\n          if(print) {\n            logOK.append(logStr);\n            logOK.append(\"[Right] \");\n            logOK.append(norm(ao.toString()));\n            logOK.append(NL);\n            logOK.append(NL);\n            addLog(pth, outname + (xml ? IO.XMLSUFFIX : \".txt\"),\n                ao.toString());\n          }\n          ++ok;\n        }\n      } else {\n        if(expOut.size() == 0 || !expError.isEmpty()) {\n          if(print) {\n            logOK2.append(logStr);\n            logOK2.append(\"[\" + testid + \" ] \");\n            logOK2.append(norm(expError));\n            logOK2.append(NL);\n            logOK2.append(\"[Rght?] \");\n            logOK2.append(norm(er));\n            logOK2.append(NL);\n            logOK2.append(NL);\n            addLog(pth, outname + \".log\", er);\n          }\n          ++ok2;\n        } else {\n          if(print) {\n            logErr2.append(logStr);\n            logErr2.append(\"[\" + testid + \" ] \");\n            logErr2.append(norm(string(result.get(0))));\n            logErr2.append(NL);\n            logErr2.append(\"[Wrong] \");\n            logErr2.append(norm(er));\n            logErr2.append(NL);\n            logErr2.append(NL);\n            addLog(pth, outname + \".log\", er);\n          }\n          correct = false;\n          ++err2;\n        }\n      }\n      if(curr != null) Close.close(curr.data, context);\n      xq.close();\n    }\n\n    if(reporting) {\n      logReport.append(\"    <test-case name=\\\"\");\n      logReport.append(outname);\n      logReport.append(\"\\\" result='\");\n      logReport.append(correct ? \"pass\" : \"fail\");\n      if(inspect) logReport.append(\"' todo='inspect\");\n      logReport.append(\"'/>\");\n      logReport.append(NL);\n    }\n\n    // print verbose/timing information\n    final long nano = perf.getTime();\n    final boolean slow = nano / 1000000 > timer;\n    if(verbose) {\n      if(slow) Util.out(\": \" + Performance.getTimer(nano, 1));\n      Util.outln();\n    } else if(slow) {\n      Util.out(NL + \"- \" + outname + \": \" + Performance.getTimer(nano, 1));\n    }\n\n    return single == null || !outname.equals(single);\n  }","id":42001,"modified_method":"/**\n   * Parses the specified test case.\n   * @param root root node\n   * @throws Exception exception\n   * @return true if the query, specified by {@link #single}, was evaluated\n   */\n  private boolean parse(final Nodes root) throws Exception {\n    final String pth = text(\"@FilePath\", root);\n    final String outname = text(\"@name\", root);\n    if(single != null && !outname.startsWith(single)) return true;\n\n    final Performance perf = new Performance();\n    if(verbose) Util.out(\"- \" + outname);\n\n    boolean inspect = false;\n    boolean correct = true;\n\n    final Nodes nodes = states(root);\n    for(int n = 0; n < nodes.size(); ++n) {\n      final Nodes state = new Nodes(nodes.list[n], nodes.data);\n\n      final String inname = text(\"*:query/@name\", state);\n      context.query = new IOFile(queries + pth + inname + IO.XQSUFFIX);\n      final String in = read(context.query);\n      String er = null;\n      ItemCache iter = null;\n      boolean doc = true;\n\n      final Nodes cont = nodes(\"*:contextItem\", state);\n      Nodes curr = null;\n      if(cont.size() != 0) {\n        final Data d = Check.check(context,\n            srcs.get(string(data.atom(cont.list[0]))));\n        curr = new Nodes(d.doc().toArray(), d);\n        curr.root = true;\n      }\n\n      context.prop.set(Prop.QUERYINFO, compile);\n      final QueryProcessor xq = new QueryProcessor(in, curr, context);\n      context.prop.set(Prop.QUERYINFO, false);\n\n      // limit result sizes to 1MB\n      final ArrayOutput ao = new ArrayOutput();\n      final TokenBuilder files = new TokenBuilder();\n\n      try {\n        files.add(file(nodes(\"*:input-file\", state),\n            nodes(\"*:input-file/@variable\", state), xq, n == 0));\n        files.add(file(nodes(\"*:defaultCollection\", state),\n            null, xq, n == 0));\n\n        var(nodes(\"*:input-URI\", state),\n            nodes(\"*:input-URI/@variable\", state), xq);\n        eval(nodes(\"*:input-query/@name\", state),\n            nodes(\"*:input-query/@variable\", state), pth, xq);\n\n        parse(xq, state);\n\n        for(final int p : nodes(\"*:module\", root).list) {\n          final String uri = text(\"@namespace\", new Nodes(p, data));\n          final String file = mods.get(string(data.atom(p))) + IO.XQSUFFIX;\n          xq.module(file, uri);\n        }\n\n        // evaluate and serialize query\n        final SerializerProp sp = new SerializerProp();\n        sp.set(SerializerProp.S_INDENT, context.prop.is(Prop.CHOP) ?\n            DataText.YES : DataText.NO);\n        final XMLSerializer xml = new XMLSerializer(ao, sp);\n\n        iter = xq.value().cache();\n        for(Item it; (it = iter.next()) != null;) {\n          doc &= it.type == NodeType.DOC;\n          it.serialize(xml);\n        }\n        xml.close();\n      } catch(final Exception ex) {\n        if(!(ex instanceof QueryException || ex instanceof IOException)) {\n          System.err.println(\"\\n*** \" + outname + \" ***\");\n          System.err.println(in + \"\\n\");\n          ex.printStackTrace();\n        }\n        er = ex.getMessage();\n        if(er.startsWith(STOPPED)) er = er.substring(er.indexOf('\\n') + 1);\n        if(er.startsWith(\"[\")) er = er.replaceAll(\"\\\\[(.*?)\\\\] (.*)\", \"$1 $2\");\n        // unexpected error - dump stack trace\n      }\n\n      // print compilation steps\n      if(compile) {\n        Util.errln(\"---------------------------------------------------------\");\n        Util.err(xq.info());\n        Util.errln(in);\n      }\n\n      final Nodes expOut = nodes(\"*:output-file/text()\", state);\n      final TokenList result = new TokenList();\n      for(int o = 0; o < expOut.size(); ++o) {\n        final String resFile = string(data.atom(expOut.list[o]));\n        final IOFile exp = new IOFile(expected + pth + resFile);\n        result.add(read(exp));\n      }\n\n      final Nodes cmpFiles = nodes(\"*:output-file/@compare\", state);\n      boolean xml = false;\n      boolean frag = false;\n      boolean ignore = false;\n      for(int o = 0; o < cmpFiles.size(); ++o) {\n        final byte[] type = data.atom(cmpFiles.list[o]);\n        xml |= eq(type, XML);\n        frag |= eq(type, FRAGMENT);\n        ignore |= eq(type, IGNORE);\n      }\n\n      String expError = text(\"*:expected-error/text()\", state);\n\n      final StringBuilder log = new StringBuilder(pth + inname + IO.XQSUFFIX);\n      if(files.size() != 0) {\n        log.append(\" [\");\n        log.append(files);\n        log.append(\"]\");\n      }\n      log.append(NL);\n\n      /** Remove comments. */\n      log.append(norm(in));\n      log.append(NL);\n      final String logStr = log.toString();\n      // skip queries with variable results\n      final boolean print = currTime || !logStr.contains(\"current-\");\n\n      boolean correctError = false;\n      if(er != null && (expOut.size() == 0 || !expError.isEmpty())) {\n        expError = error(pth + outname, expError);\n        final String code = er.substring(0, Math.min(8, er.length()));\n        for(final String e : SLASH.split(expError)) {\n          if(code.equals(e)) {\n            correctError = true;\n            break;\n          }\n        }\n      }\n\n      if(correctError) {\n        if(print) {\n          logOK.append(logStr);\n          logOK.append(\"[Right] \");\n          logOK.append(norm(er));\n          logOK.append(NL);\n          logOK.append(NL);\n          addLog(pth, outname + \".log\", er);\n        }\n        ++ok;\n      } else if(er == null) {\n        int s = -1;\n        final int rs = result.size();\n\n        while(!ignore && ++s < rs) {\n          inspect |= s < cmpFiles.list.length &&\n            eq(data.atom(cmpFiles.list[s]), INSPECT);\n\n          final byte[] res = result.get(s), actual = ao.toArray();\n          if(res.length == ao.size() && eq(res, actual)) break;\n\n          if(xml || frag) {\n            iter.reset();\n\n            try {\n              final ItemCache ic = toIter(string(res).replaceAll(\n                  \"^<\\\\?xml.*?\\\\?>\", \"\").trim(), frag);\n              if(FNSimple.deep(null, iter, ic)) break;\n\n              ic.reset();\n              final ItemCache ia = toIter(string(actual), frag);\n              if(FNSimple.deep(null, ia, ic)) break;\n            } catch(final Throwable ex) {\n              System.err.println(\"\\n\" + outname + \":\");\n              ex.printStackTrace();\n            }\n          }\n        }\n        if((rs > 0 || !expError.isEmpty()) && s == rs && !inspect) {\n          if(print) {\n            if(expOut.size() == 0) result.add(error(pth + outname, expError));\n            logErr.append(logStr);\n            logErr.append(\"[\" + testid + \" ] \");\n            logErr.append(norm(string(result.get(0))));\n            logErr.append(NL);\n            logErr.append(\"[Wrong] \");\n            logErr.append(norm(ao.toString()));\n            logErr.append(NL);\n            logErr.append(NL);\n            addLog(pth, outname + (xml ? IO.XMLSUFFIX : \".txt\"),\n                ao.toString());\n          }\n          correct = false;\n          ++err;\n        } else {\n          if(print) {\n            logOK.append(logStr);\n            logOK.append(\"[Right] \");\n            logOK.append(norm(ao.toString()));\n            logOK.append(NL);\n            logOK.append(NL);\n            addLog(pth, outname + (xml ? IO.XMLSUFFIX : \".txt\"),\n                ao.toString());\n          }\n          ++ok;\n        }\n      } else {\n        if(expOut.size() == 0 || !expError.isEmpty()) {\n          if(print) {\n            logOK2.append(logStr);\n            logOK2.append(\"[\" + testid + \" ] \");\n            logOK2.append(norm(expError));\n            logOK2.append(NL);\n            logOK2.append(\"[Rght?] \");\n            logOK2.append(norm(er));\n            logOK2.append(NL);\n            logOK2.append(NL);\n            addLog(pth, outname + \".log\", er);\n          }\n          ++ok2;\n        } else {\n          if(print) {\n            logErr2.append(logStr);\n            logErr2.append(\"[\" + testid + \" ] \");\n            logErr2.append(norm(string(result.get(0))));\n            logErr2.append(NL);\n            logErr2.append(\"[Wrong] \");\n            logErr2.append(norm(er));\n            logErr2.append(NL);\n            logErr2.append(NL);\n            addLog(pth, outname + \".log\", er);\n          }\n          correct = false;\n          ++err2;\n        }\n      }\n      if(curr != null) Close.close(curr.data, context);\n      xq.close();\n    }\n\n    if(reporting) {\n      logReport.append(\"    <test-case name=\\\"\");\n      logReport.append(outname);\n      logReport.append(\"\\\" result='\");\n      logReport.append(correct ? \"pass\" : \"fail\");\n      if(inspect) logReport.append(\"' todo='inspect\");\n      logReport.append(\"'/>\");\n      logReport.append(NL);\n    }\n\n    // print verbose/timing information\n    final long nano = perf.getTime();\n    final boolean slow = nano / 1000000 > timer;\n    if(verbose) {\n      if(slow) Util.out(\": \" + Performance.getTimer(nano, 1));\n      Util.outln();\n    } else if(slow) {\n      Util.out(NL + \"- \" + outname + \": \" + Performance.getTimer(nano, 1));\n    }\n\n    return single == null || !outname.equals(single);\n  }","commit_id":"ce98591b3b4d664783fa014cd42f89f9acb7e35e","url":"https://github.com/BaseXdb/basex"},{"original_method":"public int deleteRowsDescribedByQualifier(EOQualifier qualifier, EOEntity entity) {\n    try {\n      int count = 0;\n      Iterator<NSMutableDictionary<String, Object>> i = iterator();\n      while (i.hasNext()) {\n        NSMutableDictionary<String, Object> row = i.next();\n        if (qualifier == null || qualifier.evaluateWithObject(row)) {\n          i.remove();\n          count++;\n        }\n      }\n      return count;\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to delete '\" + entity.name() + \"' with qualifier \" + qualifier + \": \" + e.getMessage());\n    }\n  }","id":42002,"modified_method":"public int deleteRowsDescribedByQualifier(EOQualifier qualifier, EOEntity entity) {\n    try {\n      int count = 0;\n      Iterator<NSMutableDictionary<String, Object>> i = iterator();\n      while (i.hasNext()) {\n        NSMutableDictionary<String, Object> rawRow = i.next();\n        NSMutableDictionary<String, Object> row = rowFromStoredValues(rawRow, entity);\n        if (qualifier == null || qualifier.evaluateWithObject(row)) {\n          i.remove();\n          count++;\n        }\n      }\n      return count;\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to delete '\" + entity.name() + \"' with qualifier \" + qualifier + \": \" + e.getMessage());\n    }\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"private NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : (NSArray<EOAttribute>)entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived()) {\n        if (!attribute.isFlattened()) {\n          // Evaluate derived attribute expression\n\n          //This is a hack to support SQL string concatenation in derived attributes\n          String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n          try {\n            value = Ognl.getValue(expression, rawRow);\n          } catch (Throwable t) {\n            t.printStackTrace();\n          }\n        } else {\n          String dstKey = entity._attributeForPath(attribute.definition()).columnName();\n          value = rawRow.objectForKey(dstKey);\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","id":42003,"modified_method":"protected NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : (NSArray<EOAttribute>)entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived()) {\n        if (!attribute.isFlattened()) {\n          // Evaluate derived attribute expression\n\n          //This is a hack to support SQL string concatenation in derived attributes\n          String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n          try {\n            value = Ognl.getValue(expression, rawRow);\n          } catch (Throwable t) {\n            t.printStackTrace();\n          }\n        } else {\n          String dstKey = attribute.definition();\n          value = rawRow.objectForKey(dstKey);\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void insertRow(NSDictionary<String, Object> row, EOEntity entity) {\n    try {\n      NSMutableDictionary<String, Object> mutableRow = new NSMutableDictionary<String, Object>(row.size());\n      for (Enumeration e = entity.attributes().objectEnumerator(); e.hasMoreElements();) {\n        EOAttribute attribute = (EOAttribute) e.nextElement();\n        Object value = row.objectForKey(attribute.name());\n        if (value != null && !attribute.isDerived())\n          mutableRow.setObjectForKey(value, attribute.columnName());\n      }\n      _insertRow(mutableRow, entity);\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to insert '\" + entity.name() + \"' with row \" + row + \": \" + e.getMessage());\n    }\n  }","id":42004,"modified_method":"public void insertRow(NSDictionary<String, Object> row, EOEntity entity) {\n    try {\n      NSMutableDictionary<String, Object> mutableRow = new NSMutableDictionary<String, Object>(row.size());\n      for (Enumeration e = entity.attributes().objectEnumerator(); e.hasMoreElements();) {\n        EOAttribute attribute = (EOAttribute) e.nextElement();\n        Object value = row.objectForKey(attribute.name());\n        if (!attribute.isDerived())\n          mutableRow.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.columnName());\n      }\n      _insertRow(mutableRow, entity);\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to insert '\" + entity.name() + \"' with row \" + row + \": \" + e.getMessage());\n    }\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"private NSSet<EOEntity> _relatedEntities(EOEntity entity) {\n    NSMutableSet<EOEntity> entities = new NSMutableSet<EOEntity>();\n    Enumeration<EOAttribute> e = entity.attributesToFetch().objectEnumerator();\n    while (e.hasMoreElements()) {\n      EOAttribute attrib = e.nextElement();\n      if (attrib.isDerived()) {\n        attrib = entity._attributeForPath(attrib.definition());\n        if (attrib != null)\n          entities.add(attrib.entity());\n      }\n    }\n    return entities;\n  }","id":42005,"modified_method":"private NSSet<EOEntity> _relatedEntities(EOEntity entity) {\n    NSMutableSet<EOEntity> entities = new NSMutableSet<EOEntity>();\n    for (EOAttribute attrib : (NSArray<EOAttribute>) entity.attributesToFetch()) {\n      if (attrib.isDerived()) {\n        attrib = entity._attributeForPath(attrib.definition());\n        if (attrib != null)\n          entities.add(attrib.entity());\n      }\n    }\n//    for (EORelationship rel : (NSArray<EORelationship>) entity._hiddenRelationships()) {\n//      entities.add(rel.destinationEntity());\n//    }\n    return entities;\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean hasNext() {\n        if (_hasNext != null) {\n          return _hasNext.booleanValue();\n        }\n        while (_hasNext == null) {\n          if (destIterator.hasNext()) {\n            dst = destIterator.next();\n          } else {\n            if (srcIterator.hasNext()) {\n              src = srcIterator.next();\n              destIterator = destStore.iterator();\n              continue;\n            }\n            _hasNext = Boolean.FALSE;\n            break;\n          }\n          if (src == null) {\n            _hasNext = Boolean.FALSE;\n            break;\n          }\n          for (Entry<EOAttribute, EOAttribute> entry : attributeMap.entrySet()) {\n            String srcKey = entry.getKey().name();\n            String dstKey = entry.getValue().name();\n            Object srcValue = src.objectForKey(srcKey);\n            Object dstValue = dst.objectForKey(dstKey);\n            if (srcValue == dstValue || srcValue != null && srcValue.equals(dstValue)) {\n              _hasNext = Boolean.TRUE;\n              break;\n            }\n          }\n        }\n        return _hasNext.booleanValue();\n      }","id":42006,"modified_method":"public boolean hasNext() {\n        if (_hasNext != null) {\n          return _hasNext.booleanValue();\n        }\n        while (_hasNext == null) {\n          if (destIterator.hasNext()) {\n            dst = destIterator.next();\n          } else {\n            if (srcIterator.hasNext()) {\n              src = srcIterator.next();\n              destIterator = destStore.iterator();\n              continue;\n            }\n            _hasNext = Boolean.FALSE;\n            break;\n          }\n          if (src == null) {\n            _hasNext = Boolean.FALSE;\n            break;\n          }\n          for (Entry<EOAttribute, EOAttribute> entry : attributeMap.entrySet()) {\n            String srcKey = entry.getKey().columnName();\n            String dstKey = entry.getValue().columnName();\n            Object srcValue = src.objectForKey(srcKey);\n            Object dstValue = dst.objectForKey(dstKey);\n            if (srcValue == dstValue || srcValue != null && srcValue.equals(dstValue)) {\n              _hasNext = Boolean.TRUE;\n              break;\n            }\n          }\n        }\n        return _hasNext.booleanValue();\n      }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"@SuppressWarnings(\"cast\")\n      public NSMutableDictionary<String, Object> next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException(\"No more rows are available\");\n        }\n        _hasNext = null;\n        NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(src);\n        EOEntity entity = relationship.entity();\n        for (EOAttribute attrib : (NSArray<EOAttribute>) entity.attributesToFetch()) {\n          EORelationship rel = entity._relationshipForPath(attrib.relationshipPath());\n          if (attrib.isFlattened() && relationship.equals(rel)) {\n            String dstKey = entity._attributeForPath(attrib.definition()).columnName();\n            Object value = dst.objectForKey(dstKey);\n            if (value != null)\n              row.setObjectForKey(value, dstKey);\n          }\n        }\n        return row;\n      }","id":42007,"modified_method":"@SuppressWarnings(\"cast\")\n      public NSMutableDictionary<String, Object> next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException(\"No more rows are available\");\n        }\n        _hasNext = null;\n        NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(src);\n        EOEntity entity = relationship.entity();\n        for (EOAttribute attrib : (NSArray<EOAttribute>) entity.attributesToFetch()) {\n          EORelationship rel = entity._relationshipForPath(attrib.relationshipPath());\n          if (attrib.isFlattened() && relationship.equals(rel)) {\n            String dstKey = entity._attributeForPath(attrib.definition()).columnName();\n            Object value = dst.objectForKey(dstKey);\n            row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attrib.definition());\n          }\n        }\n        //row.takeValueForKeyPath(rowFromStoredValues(dst, relationship.entity()), relationship.name());\n        return row;\n      }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n  public NSMutableArray<NSMutableDictionary<String, Object>> fetch(NSArray<EOAttribute> attributesToFetch, EOFetchSpecification fetchSpecification,\n      boolean shouldLock, EOEntity entity) {\n    EREntityStore store = joinedStore(attributesToFetch, entity);\n    return store.fetch(attributesToFetch, fetchSpecification, shouldLock, entity);\n  }","id":42008,"modified_method":"@Override\n  public NSMutableArray<NSMutableDictionary<String, Object>> fetch(NSArray<EOAttribute> attributesToFetch, EOFetchSpecification fetchSpecification,\n      boolean shouldLock, EOEntity entity) {\n    EREntityStore store = joinedStore(attributesToFetch, fetchSpecification, entity);\n    return store.fetch(attributesToFetch, fetchSpecification, shouldLock, entity);\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n  public Iterator<NSMutableDictionary<String, Object>> iterator() {\n    return joinedStore(_entity.attributesToFetch(), _entity).iterator();\n  }","id":42009,"modified_method":"@Override\n  public Iterator<NSMutableDictionary<String, Object>> iterator() {\n    return joinedStore(_entity.attributesToFetch(), null, _entity).iterator();\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"private EREntityStore joinedStore(NSArray<EOAttribute> attributesToFetch, EOEntity entity) {\n    EREntityStore store = _stores.objectForKey(entity);\n    for (EOAttribute attrib : attributesToFetch) {\n      if (attrib.isFlattened()) {\n        EOAttribute _attrib = entity._attributeForPath(attrib.definition());\n        EORelationship _rel = entity._relationshipForPath(attrib.relationshipPath());\n        store = join(_rel, store, _stores.objectForKey(_attrib.entity()));\n      }\n    }\n    return store;\n  }","id":42010,"modified_method":"private EREntityStore joinedStore(NSArray<EOAttribute> attributesToFetch, EOFetchSpecification fetchSpecification, EOEntity entity) {\n    EREntityStore store = _stores.objectForKey(entity);\n    for (EOAttribute attrib : attributesToFetch) {\n      if (attrib.isFlattened()) {\n        EOAttribute _attrib = entity._attributeForPath(attrib.definition());\n        EORelationship _rel = entity._relationshipForPath(attrib.relationshipPath());\n        store = join(_rel, store, _stores.objectForKey(_attrib.entity()));\n      }\n    }\n    // We need to check the qualifier for _hiddenRelationships and include them if referenced\n//    for (EORelationship rel : (NSArray<EORelationship>) entity._hiddenRelationships()) {\n//      if (rel.isFlattened()) {\n//        for (EORelationship compRel : (NSArray<EORelationship>) rel.componentRelationships()) {\n//          store = join(compRel, store, _stores.objectForKey(compRel.destinationEntity()));\n//        }\n//      } else {\n//        store = join(rel, store, _stores.objectForKey(rel.destinationEntity()));\n//      }\n//    }\n    return store;\n  }","commit_id":"3dfded8bd162260c729a9d102c88f6ded4107cdf","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSMutableArray<NSMutableDictionary<String, Object>> fetch(NSArray<EOAttribute> attributesToFetch,\n\t\t\tEOFetchSpecification fetchSpecification, boolean shouldLock, EOEntity entity, ERMemoryAdaptorContext context) {\n\t\tEOQualifier qualifier = null;\n\t\tint fetchLimit = 0;\n\t\tNSArray<EOSortOrdering> sortOrderings = null;\n\t\tif (fetchSpecification != null) {\n\t\t\tqualifier = fetchSpecification.qualifier();\n\t\t\tfetchLimit = fetchSpecification.fetchLimit();\n\t\t\tsortOrderings = fetchSpecification.sortOrderings();\n\t\t}\n\n\t\tif (entity.restrictingQualifier() != null) {\n\t\t\tif (qualifier != null) {\n\t\t\t\tqualifier = new EOAndQualifier(new NSArray(new EOQualifier[] { qualifier, entity.restrictingQualifier() }));\n\t\t\t} else {\n\t\t\t\tqualifier = entity.restrictingQualifier();\n\t\t\t}\n\t\t}\n\n\t\tNSMutableArray<EORelationship> mergeRelationships = new NSMutableArray<EORelationship>();\n\t\tif (qualifier != null && context != null) {\n\t\t\tNSArray<EOKeyValueQualifier> keyValueQualifiers = ERXQ.extractKeyValueQualifiers(qualifier);\n\t\t\tfor (EOKeyValueQualifier keyValueQualifier : keyValueQualifiers) {\n\t\t\t\tString qualifierKey = keyValueQualifier.key();\n\t\t\t\tString relationshipName = qualifierKey;\n\t\t\t\tif (relationshipName.contains(\".\")) {\n\t\t\t\t\trelationshipName = ERXStringUtilities.firstPropertyKeyInKeyPath(relationshipName);\n\t\t\t\t}\n\t\t\t\tEORelationship mergeRelationship = entity.relationshipNamed(relationshipName);\n\t\t\t\tif (mergeRelationship != null) {\n\t\t\t\t\tmergeRelationships.add(mergeRelationship);\n\t\t\t\t\tqualifier = ERXQ.replaceQualifierWithQualifier(qualifier, keyValueQualifier,\n\t\t\t\t\t\t\tERXQ.has(qualifierKey, new NSArray(keyValueQualifier.value())));\n\t\t\t\t} else if (qualifierKey.equals(entity.primaryKeyAttributeNames().get(0))\n\t\t\t\t\t\t&& keyValueQualifier.selector().name().equals(\"doesContain\") && !(keyValueQualifier.value() instanceof NSArray)) {\n\t\t\t\t\t// fix wrong schemaBasedQualifier\n\t\t\t\t\tqualifier= ERXQ.replaceQualifierWithQualifier(qualifier, keyValueQualifier,\n\t\t\t\t\t\t\tERXQ.is(qualifierKey, keyValueQualifier.value()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// int count = 0;\n\t\tNSMutableArray<NSMutableDictionary<String, Object>> fetchedRows = new NSMutableArray<NSMutableDictionary<String, Object>>();\n\t\tIterator<NSMutableDictionary<String, Object>> i = iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tNSMutableDictionary<String, Object> rawRow = i.next();\n\t\t\tNSMutableDictionary<String, Object> row = rowFromStoredValues(rawRow, entity);\n\t\t\tfor (EORelationship mergeRelationship : mergeRelationships) {\n\t\t\t\tNSArray<NSMutableDictionary<String, Object>> found = null;\n\t\t\t\tif (mergeRelationship.isFlattened() && mergeRelationship.isToMany()) {\n\t\t\t\t\tfound = fetchRelatedManyToManyRows(entity, row, mergeRelationship, context);\n\t\t\t\t} else {\n\t\t\t\t\tfound = fetchRelatedRows(entity, row, mergeRelationship, context);\n\t\t\t\t}\n\t\t\t\tif (found != null && !found.isEmpty()) {\n\t\t\t\t\trow.setObjectForKey(found, mergeRelationship.name());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (qualifier == null || qualifier.evaluateWithObject(row)) {\n\t\t\t\tfor (EORelationship mergeRelationship : mergeRelationships) {\n\t\t\t\t\trow.removeObjectForKey(mergeRelationship.name());\n\t\t\t\t}\n\t\t\t\tfetchedRows.addObject(row);\n\t\t\t\t// count++;\n\t\t\t}\n\t\t\t// if (fetchLimit > 0 && count == fetchLimit) {\n\t\t\t// \t   break;\n\t\t\t// }\n\t\t}\n\n\t\tif (sortOrderings != null) {\n\t\t\tEOSortOrdering.sortArrayUsingKeyOrderArray(fetchedRows, sortOrderings);\n\t\t}\n\n\t\tif (fetchLimit > 0 && fetchedRows.count() > fetchLimit) {\n\t\t\tfetchedRows.removeObjectsInRange(new NSRange(fetchLimit, fetchedRows.count() - fetchLimit));\n\t\t}\n\t\treturn fetchedRows;\n\t}","id":42011,"modified_method":"public NSMutableArray<FetchedRow> fetch(NSArray<EOAttribute> attributesToFetch, EOFetchSpecification fetchSpecification, boolean shouldLock, EOEntity entity) {\n    EOQualifier qualifier = null;\n    int fetchLimit = 0;\n    NSArray sortOrderings = null;\n    if (fetchSpecification != null) {\n      qualifier = fetchSpecification.qualifier();\n      fetchLimit = fetchSpecification.fetchLimit();\n      sortOrderings = fetchSpecification.sortOrderings();\n    }\n\n\t\tif (entity.restrictingQualifier() != null) {\n\t\t\tif (qualifier != null) {\n\t\t\t\tqualifier = new EOAndQualifier(new NSArray(new EOQualifier[] { qualifier, entity.restrictingQualifier() }));\n\t\t\t} else {\n\t\t\t\tqualifier = entity.restrictingQualifier();\n\t\t\t}\n\t\t}\n    \n    int count = 0;\n    NSMutableArray<FetchedRow> fetchedRows = new NSMutableArray<FetchedRow>();\n    Iterator<NSMutableDictionary<String, Object>> i = iterator();\n    while (i.hasNext()) {\n      NSMutableDictionary<String, Object> rawRow = i.next();\n      FetchedRow row = new FetchedRow(rawRow, entity);\n      if (qualifier == null || qualifier.evaluateWithObject(row)) {\n        fetchedRows.addObject(row);\n        count++;\n      }\n      if (sortOrderings == null && fetchLimit > 0 && count == fetchLimit) {\n        break;\n      }\n    }\n\n    if (sortOrderings != null) {\n      EOSortOrdering.sortArrayUsingKeyOrderArray(fetchedRows, sortOrderings);\n    }\n    \n    if (fetchLimit > 0 && fetchedRows.count() > fetchLimit) {\n    \tfetchedRows.removeObjectsInRange(new NSRange(fetchLimit, fetchedRows.count() - fetchLimit));\n    }\n    return fetchedRows;\n  }","commit_id":"950cf5557e549566419f3f094143e3f4e9f73230","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int deleteRowsDescribedByQualifier(EOQualifier qualifier, EOEntity entity) {\n    try {\n      int count = 0;\n      Iterator<NSMutableDictionary<String, Object>> i = iterator();\n      while (i.hasNext()) {\n        NSMutableDictionary<String, Object> rawRow = i.next();\n        NSMutableDictionary<String, Object> row = rowFromStoredValues(rawRow, entity);\n        if (qualifier == null || qualifier.evaluateWithObject(row)) {\n          i.remove();\n          count++;\n        }\n      }\n      return count;\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to delete '\" + entity.name() + \"' with qualifier \" + qualifier + \": \" + e.getMessage());\n    }\n  }","id":42012,"modified_method":"public int deleteRowsDescribedByQualifier(EOQualifier qualifier, EOEntity entity) {\n    try {\n      int count = 0;\n      Iterator<NSMutableDictionary<String, Object>> i = iterator();\n      while (i.hasNext()) {\n        NSMutableDictionary<String, Object> rawRow = i.next();\n        FetchedRow row = new FetchedRow(rawRow, entity);\n        if (qualifier == null || qualifier.evaluateWithObject(row)) {\n          i.remove();\n          count++;\n        }\n      }\n      return count;\n    }\n    catch (EOGeneralAdaptorException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to delete '\" + entity.name() + \"' with qualifier \" + qualifier + \": \" + e.getMessage());\n    }\n  }","commit_id":"950cf5557e549566419f3f094143e3f4e9f73230","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int updateValuesInRowsDescribedByQualifier(NSDictionary<String, Object> updatedRow, EOQualifier qualifier, EOEntity entity) {\n    try {\n      int count = 0;\n      Iterator<NSMutableDictionary<String, Object>> i = iterator();\n      while (i.hasNext()) {\n        NSMutableDictionary<String, Object> rawRow = i.next();\n        NSMutableDictionary<String, Object> row = rowFromStoredValues(rawRow, entity);\n        \n        if (qualifier == null || qualifier.evaluateWithObject(row)) {\n          for (Map.Entry<String, Object> entry : updatedRow.entrySet()) {\n            EOAttribute attribute = entity.attributeNamed(entry.getKey());\n            rawRow.setObjectForKey(entry.getValue(), attribute.columnName());\n          }\n          count++;\n        }\n      }\n\n      return count;\n    }\n    catch (EOGeneralAdaptorException e) {\n      e.printStackTrace();\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to update '\" + entity.name() + \"' row \" + updatedRow + \" with qualifier \" + qualifier + \": \" + e.getMessage());\n    }\n  }","id":42013,"modified_method":"public int updateValuesInRowsDescribedByQualifier(NSDictionary<String, Object> updatedRow, EOQualifier qualifier, EOEntity entity) {\n    try {\n      int count = 0;\n      Iterator<NSMutableDictionary<String, Object>> i = iterator();\n      while (i.hasNext()) {\n        NSMutableDictionary<String, Object> rawRow = i.next();\n        FetchedRow row = new FetchedRow(rawRow, entity);\n        \n        if (qualifier == null || qualifier.evaluateWithObject(row)) {\n          for (Map.Entry<String, Object> entry : updatedRow.entrySet()) {\n            EOAttribute attribute = entity.attributeNamed(entry.getKey());\n            rawRow.setObjectForKey(entry.getValue(), attribute.columnName());\n          }\n          count++;\n        }\n      }\n\n      return count;\n    }\n    catch (EOGeneralAdaptorException e) {\n      e.printStackTrace();\n      throw e;\n    }\n    catch (Throwable e) {\n      e.printStackTrace();\n      throw new EOGeneralAdaptorException(\"Failed to update '\" + entity.name() + \"' row \" + updatedRow + \" with qualifier \" + qualifier + \": \" + e.getMessage());\n    }\n  }","commit_id":"950cf5557e549566419f3f094143e3f4e9f73230","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n  public NSMutableArray<NSMutableDictionary<String, Object>> fetch(NSArray<EOAttribute> attributesToFetch, EOFetchSpecification fetchSpecification,\n      boolean shouldLock, EOEntity entity, ERMemoryAdaptorContext context) {\n    EREntityStore store = joinedStore(attributesToFetch, fetchSpecification, entity);\n    return store.fetch(attributesToFetch, fetchSpecification, shouldLock, entity, context);\n  }","id":42014,"modified_method":"@Override\n  public NSMutableArray<FetchedRow> fetch(NSArray<EOAttribute> attributesToFetch, EOFetchSpecification fetchSpecification,\n      boolean shouldLock, EOEntity entity) {\n    EREntityStore store = joinedStore(attributesToFetch, fetchSpecification, entity);\n    return store.fetch(attributesToFetch, fetchSpecification, shouldLock, entity);\n  }","commit_id":"950cf5557e549566419f3f094143e3f4e9f73230","url":"https://github.com/wocommunity/wonder"},{"original_method":"@SuppressWarnings(\"cast\")\n    public InnerJoinEntityStore(EORelationship rel, EREntityStore store1, EREntityStore store2) {\n      srcStore = store1;\n      destStore = store2;\n      relationship = rel;\n      for (EOJoin join : (NSArray<EOJoin>)rel.joins()) {\n        attributeMap.setObjectForKey(join.destinationAttribute(), join.sourceAttribute());\n      }\n    }","id":42015,"modified_method":"@SuppressWarnings(\"cast\")\n    public InnerJoinEntityStore(EORelationship rel, EREntityStore store1, EREntityStore store2) {\n      super(null);\n      srcStore = store1;\n      destStore = store2;\n      relationship = rel;\n      for (EOJoin join : (NSArray<EOJoin>)rel.joins()) {\n        attributeMap.setObjectForKey(join.destinationAttribute(), join.sourceAttribute());\n      }\n    }","commit_id":"950cf5557e549566419f3f094143e3f4e9f73230","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERJoinEntityStore(NSDictionary<EOEntity, EREntityStore> stores, EOEntity entity) {\n    _stores = stores;\n    _entity = entity;\n  }","id":42016,"modified_method":"public ERJoinEntityStore(NSDictionary<EOEntity, EREntityStore> stores, EOEntity entity) {\n    super(null);\n    _stores = stores;\n    _entity = entity;\n  }","commit_id":"950cf5557e549566419f3f094143e3f4e9f73230","url":"https://github.com/wocommunity/wonder"},{"original_method":"private NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived() && !attribute.isFlattened()) {\n        // Evaluate derived attribute expression\n        \n        //This is a hack to support SQL string concatenation in derived attributes\n        String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n        try {\n          value = Ognl.getValue(expression, rawRow);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","id":42017,"modified_method":"private NSMutableDictionary<String, Object> rowFromStoredValues(NSMutableDictionary<String, Object> rawRow, EOEntity entity) {\n    NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(rawRow.count()); \n    for (EOAttribute attribute : (NSArray<EOAttribute>)entity.attributesToFetch()) {\n      Object value = rawRow.objectForKey(attribute.columnName());\n      if (attribute.isDerived() && !attribute.isFlattened()) {\n        // Evaluate derived attribute expression\n        \n        //This is a hack to support SQL string concatenation in derived attributes\n        String expression = attribute.definition().replaceAll(\"\\\\|\\\\|\", \"+ '' +\");\n        try {\n          value = Ognl.getValue(expression, rawRow);\n        } catch (Throwable t) {\n          t.printStackTrace();\n        }\n      }\n      row.setObjectForKey(value != null ? value : NSKeyValueCoding.NullValue, attribute.name());\n    }\n    return row;\n  }","commit_id":"0a22ae54ef78046881021332a81de2413ea9e4e1","url":"https://github.com/wocommunity/wonder"},{"original_method":"public InnerJoinEntityStore(EORelationship rel, EREntityStore store1, EREntityStore store2) {\n      srcStore = store1;\n      destStore = store2;\n      relationship = rel;\n      for (EOJoin join : rel.joins()) {\n        attributeMap.setObjectForKey(join.destinationAttribute(), join.sourceAttribute());\n      }\n    }","id":42018,"modified_method":"@SuppressWarnings(\"cast\")\n    public InnerJoinEntityStore(EORelationship rel, EREntityStore store1, EREntityStore store2) {\n      srcStore = store1;\n      destStore = store2;\n      relationship = rel;\n      for (EOJoin join : (NSArray<EOJoin>)rel.joins()) {\n        attributeMap.setObjectForKey(join.destinationAttribute(), join.sourceAttribute());\n      }\n    }","commit_id":"a582cf9937d8a9d47d0dbf57d835f81efe81defe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSMutableDictionary<String, Object> next() {\n        hasNext();\n        _hasNext = null;\n        NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(src);\n        EOEntity entity = relationship.entity();\n        for (EOAttribute attrib : entity.attributesToFetch()) {\n          EORelationship rel = entity._relationshipForPath(attrib.relationshipPath());\n          if (attrib.isFlattened() && relationship.equals(rel)) {\n            String dstKey = entity._attributeForPath(attrib.definition()).name();\n            Object value = dst.objectForKey(dstKey);\n            if (value != null)\n              row.setObjectForKey(value, attrib.name());\n          }\n        }\n        return row;\n      }","id":42019,"modified_method":"@SuppressWarnings(\"cast\")\n      public NSMutableDictionary<String, Object> next() {\n        hasNext();\n        _hasNext = null;\n        NSMutableDictionary<String, Object> row = new NSMutableDictionary<String, Object>(src);\n        EOEntity entity = relationship.entity();\n        for (EOAttribute attrib : (NSArray<EOAttribute>) entity.attributesToFetch()) {\n          EORelationship rel = entity._relationshipForPath(attrib.relationshipPath());\n          if (attrib.isFlattened() && relationship.equals(rel)) {\n            String dstKey = entity._attributeForPath(attrib.definition()).name();\n            Object value = dst.objectForKey(dstKey);\n            if (value != null)\n              row.setObjectForKey(value, attrib.name());\n          }\n        }\n        return row;\n      }","commit_id":"a582cf9937d8a9d47d0dbf57d835f81efe81defe","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static String getChecksum(Path filePath) throws IOException {\n\t\tif (!Files.exists(filePath) ||\n\t\t\t(Files.size(filePath) >\n\t\t\t\tPropsValues.SYNC_FILE_CHECKSUM_THRESHOLD_SIZE)) {\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\tInputStream fileInputStream = null;\n\n\t\ttry {\n\t\t\tfileInputStream = Files.newInputStream(filePath);\n\n\t\t\tbyte[] bytes = DigestUtils.sha1(fileInputStream);\n\n\t\t\treturn Base64.encodeBase64String(bytes);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\t\t}\n\t}","id":42020,"modified_method":"public static String getChecksum(Path filePath) throws IOException {\n\t\tif (isSizeOverChecksumThreshold(filePath)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tInputStream fileInputStream = null;\n\n\t\ttry {\n\t\t\tfileInputStream = Files.newInputStream(filePath);\n\n\t\t\tbyte[] bytes = DigestUtils.sha1(fileInputStream);\n\n\t\t\treturn Base64.encodeBase64String(bytes);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\t\t}\n\t}","commit_id":"3ce280f443ab8695733ad9f74fecc1f9afcbb897","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doRun() throws Exception {\n\t\tSyncWatchEvent lastSyncWatchEvent =\n\t\t\tSyncWatchEventService.fetchLastSyncWatchEvent(_syncAccountId);\n\n\t\tif (lastSyncWatchEvent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong delta =\n\t\t\tSystem.currentTimeMillis() - lastSyncWatchEvent.getTimestamp();\n\n\t\tif (delta <= 500) {\n\t\t\t_inProgress = true;\n\n\t\t\tSyncEngineUtil.fireSyncEngineStateChanged(\n\t\t\t\t_syncAccountId, SyncEngineUtil.SYNC_ENGINE_STATE_PROCESSING);\n\n\t\t\treturn;\n\t\t}\n\n\t\tWatcher watcher = WatcherRegistry.getWatcher(_syncAccountId);\n\n\t\tif (watcher != null) {\n\t\t\tList<String> createdFilePathNames =\n\t\t\t\twatcher.getCreatedFilePathNames();\n\n\t\t\tcreatedFilePathNames.clear();\n\t\t}\n\n\t\tif (_logger.isTraceEnabled()) {\n\t\t\t_logger.trace(\"Processing sync watch events\");\n\t\t}\n\n\t\tList<SyncWatchEvent> syncWatchEvents =\n\t\t\tSyncWatchEventService.findBySyncAccountId(\n\t\t\t\t_syncAccountId, \"eventType\", true);\n\n\t\tfor (SyncWatchEvent syncWatchEvent : syncWatchEvents) {\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\t_syncAccountId);\n\n\t\t\tif (syncAccount.getState() != SyncAccount.STATE_CONNECTED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_processedSyncWatchEventIds.contains(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId())) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Event type {} file path {} file type {} timestamp {}\",\n\t\t\t\t\tsyncWatchEvent.getEventType(),\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getFileType(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\t\t\t}\n\n\t\t\tboolean syncWatchEventProcessed = true;\n\n\t\t\tString fileType = syncWatchEvent.getFileType();\n\n\t\t\tString eventType = syncWatchEvent.getEventType();\n\n\t\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\tsyncWatchEventProcessed = addFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsyncWatchEventProcessed = addFolder(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\tdeleteFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeleteFolder(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\tmodifyFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsyncAccount = SyncAccountService.fetchSyncAccount(_syncAccountId);\n\n\t\t\tif (syncWatchEventProcessed &&\n\t\t\t\t(syncAccount.getState() == SyncAccount.STATE_CONNECTED)) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\t_inProgress = false;\n\n\t\tSyncEngineUtil.fireSyncEngineStateChanged(\n\t\t\t_syncAccountId, SyncEngineUtil.SYNC_ENGINE_STATE_PROCESSED);\n\n\t\t_processedSyncWatchEventIds.clear();\n\t}","id":42021,"modified_method":"protected void doRun() throws Exception {\n\t\tSyncWatchEvent lastSyncWatchEvent =\n\t\t\tSyncWatchEventService.fetchLastSyncWatchEvent(_syncAccountId);\n\n\t\tif (lastSyncWatchEvent == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong delta =\n\t\t\tSystem.currentTimeMillis() - lastSyncWatchEvent.getTimestamp();\n\n\t\tif (delta <= 500) {\n\t\t\t_inProgress = true;\n\n\t\t\tSyncEngineUtil.fireSyncEngineStateChanged(\n\t\t\t\t_syncAccountId, SyncEngineUtil.SYNC_ENGINE_STATE_PROCESSING);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (_logger.isTraceEnabled()) {\n\t\t\t_logger.trace(\"Processing sync watch events\");\n\t\t}\n\n\t\tList<SyncWatchEvent> syncWatchEvents =\n\t\t\tSyncWatchEventService.findBySyncAccountId(\n\t\t\t\t_syncAccountId, \"eventType\", true);\n\n\t\tfor (SyncWatchEvent syncWatchEvent : syncWatchEvents) {\n\t\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t\t_syncAccountId);\n\n\t\t\tif (syncAccount.getState() != SyncAccount.STATE_CONNECTED) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_processedSyncWatchEventIds.contains(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId())) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(\n\t\t\t\t\t\"Event type {} file path {} file type {} timestamp {}\",\n\t\t\t\t\tsyncWatchEvent.getEventType(),\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getFileType(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\t\t\t}\n\n\t\t\tboolean syncWatchEventProcessed = true;\n\n\t\t\tString fileType = syncWatchEvent.getFileType();\n\n\t\t\tString eventType = syncWatchEvent.getEventType();\n\n\t\t\tif (eventType.equals(SyncWatchEvent.EVENT_TYPE_CREATE)) {\n\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\tsyncWatchEventProcessed = addFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsyncWatchEventProcessed = addFolder(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_DELETE)) {\n\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\tdeleteFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdeleteFolder(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (eventType.equals(SyncWatchEvent.EVENT_TYPE_MODIFY)) {\n\t\t\t\tif (fileType.equals(SyncFile.TYPE_FILE)) {\n\t\t\t\t\tmodifyFile(syncWatchEvent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsyncAccount = SyncAccountService.fetchSyncAccount(_syncAccountId);\n\n\t\t\tif (syncWatchEventProcessed &&\n\t\t\t\t(syncAccount.getState() == SyncAccount.STATE_CONNECTED)) {\n\n\t\t\t\tSyncWatchEventService.deleteSyncWatchEvent(\n\t\t\t\t\tsyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\t_inProgress = false;\n\n\t\tSyncEngineUtil.fireSyncEngineStateChanged(\n\t\t\t_syncAccountId, SyncEngineUtil.SYNC_ENGINE_STATE_PROCESSED);\n\n\t\t_processedSyncWatchEventIds.clear();\n\t}","commit_id":"3ce280f443ab8695733ad9f74fecc1f9afcbb897","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(parentSyncFile.getState() == SyncFile.STATE_ERROR)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\t\tFileUtil.getFileKey(targetFilePath), _syncAccountId);\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath) &&\n\t\t\t!FileUtil.hasFileChanged(syncFile)) {\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","id":42022,"modified_method":"protected boolean addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(parentSyncFile.getState() == SyncFile.STATE_ERROR)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\t\tFileUtil.getFileKey(targetFilePath), _syncAccountId);\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (FileUtil.hasFileChanged(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"3ce280f443ab8695733ad9f74fecc1f9afcbb897","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tif (_watchService == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tWatchKey watchKey = null;\n\n\t\t\t\ttry {\n\t\t\t\t\twatchKey = _watchService.take();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPath parentFilePath = _filePaths.get(watchKey);\n\n\t\t\t\tif (parentFilePath == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tList<WatchEvent<?>> watchEvents = watchKey.pollEvents();\n\n\t\t\t\tfor (int i = 0; i < watchEvents.size(); i++) {\n\t\t\t\t\tWatchEvent<Path> watchEvent =\n\t\t\t\t\t\t(WatchEvent<Path>)watchEvents.get(i);\n\n\t\t\t\t\tPathImpl pathImpl = (PathImpl)watchEvent.context();\n\n\t\t\t\t\tif (pathImpl == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tWatchEvent.Kind<?> kind = watchEvent.kind();\n\n\t\t\t\t\tPath childFilePath = parentFilePath.resolve(\n\t\t\t\t\t\tpathImpl.toString());\n\n\t\t\t\t\tif (kind == StandardWatchEventKind.ENTRY_CREATE) {\n\t\t\t\t\t\tif (isIgnoredFilePath(childFilePath)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_createdFilePathNames.add(childFilePath.toString());\n\n\t\t\t\t\t\tif (_downloadedFilePathNames.remove(\n\t\t\t\t\t\t\t\tchildFilePath.toString())) {\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\n\t\t\t\t\t\tif (_recursive &&\n\t\t\t\t\t\t\tFiles.isDirectory(\n\t\t\t\t\t\t\t\tchildFilePath, LinkOption.NOFOLLOW_LINKS)) {\n\n\t\t\t\t\t\t\tregisterFilePath(childFilePath, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (kind == StandardWatchEventKind.ENTRY_DELETE) {\n\t\t\t\t\t\tprocessMissingFilePath(childFilePath);\n\n\t\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (kind == StandardWatchEventKind.ENTRY_MODIFY) {\n\t\t\t\t\t\tif (_createdFilePathNames.remove(\n\t\t\t\t\t\t\t\tchildFilePath.toString()) ||\n\t\t\t\t\t\t\tFiles.isDirectory(childFilePath)) {\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (Path failedFilePath : _failedFilePaths) {\n\t\t\t\t\tif (Files.notExists(failedFilePath)) {\n\t\t\t\t\t\t_failedFilePaths.remove(failedFilePath);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Files.isReadable(failedFilePath)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t_failedFilePaths.remove(failedFilePath);\n\n\t\t\t\t\tif (Files.isDirectory(failedFilePath)) {\n\t\t\t\t\t\tregisterFilePath(failedFilePath, true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\t\t\tfailedFilePath.toString());\n\n\t\t\t\t\t\tif (syncFile == null) {\n\t\t\t\t\t\t\tfireWatchEventListener(\n\t\t\t\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_CREATE,\n\t\t\t\t\t\t\t\tfailedFilePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (FileUtil.hasFileChanged(\n\t\t\t\t\t\t\t\t\tsyncFile, failedFilePath)) {\n\n\t\t\t\t\t\t\tfireWatchEventListener(\n\t\t\t\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_MODIFY,\n\t\t\t\t\t\t\t\tfailedFilePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!watchKey.reset()) {\n\t\t\t\t\tPath filePath = _filePaths.remove(watchKey);\n\n\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t_logger.trace(\"Unregistered file path {}\", filePath);\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessMissingFilePath(filePath);\n\n\t\t\t\t\tif (_filePaths.isEmpty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","id":42023,"modified_method":"@Override\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tif (_watchService == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tWatchKey watchKey = null;\n\n\t\t\t\ttry {\n\t\t\t\t\twatchKey = _watchService.take();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPath parentFilePath = _filePaths.get(watchKey);\n\n\t\t\t\tif (parentFilePath == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tList<WatchEvent<?>> watchEvents = watchKey.pollEvents();\n\n\t\t\t\tfor (int i = 0; i < watchEvents.size(); i++) {\n\t\t\t\t\tWatchEvent<Path> watchEvent =\n\t\t\t\t\t\t(WatchEvent<Path>)watchEvents.get(i);\n\n\t\t\t\t\tPathImpl pathImpl = (PathImpl)watchEvent.context();\n\n\t\t\t\t\tif (pathImpl == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tWatchEvent.Kind<?> kind = watchEvent.kind();\n\n\t\t\t\t\tPath childFilePath = parentFilePath.resolve(\n\t\t\t\t\t\tpathImpl.toString());\n\n\t\t\t\t\tif (kind == StandardWatchEventKind.ENTRY_CREATE) {\n\t\t\t\t\t\tif (isIgnoredFilePath(childFilePath)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddCreatedFilePathName(childFilePath.toString());\n\n\t\t\t\t\t\tif (_downloadedFilePathNames.remove(\n\t\t\t\t\t\t\t\tchildFilePath.toString())) {\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\n\t\t\t\t\t\tif (_recursive &&\n\t\t\t\t\t\t\tFiles.isDirectory(\n\t\t\t\t\t\t\t\tchildFilePath, LinkOption.NOFOLLOW_LINKS)) {\n\n\t\t\t\t\t\t\tregisterFilePath(childFilePath, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (kind == StandardWatchEventKind.ENTRY_DELETE) {\n\t\t\t\t\t\tprocessMissingFilePath(childFilePath);\n\n\t\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\t\t\t\t\t}\n\t\t\t\t\telse if (kind == StandardWatchEventKind.ENTRY_MODIFY) {\n\t\t\t\t\t\tif ((removeCreatedFilePathName(\n\t\t\t\t\t\t\t\tchildFilePath.toString()) &&\n\t\t\t\t\t\t\t FileUtil.isSizeOverChecksumThreshold(\n\t\t\t\t\t\t\t\t childFilePath)) ||\n\t\t\t\t\t\t\tFiles.isDirectory(childFilePath)) {\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfireWatchEventListener(childFilePath, watchEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (Path failedFilePath : _failedFilePaths) {\n\t\t\t\t\tif (Files.notExists(failedFilePath)) {\n\t\t\t\t\t\t_failedFilePaths.remove(failedFilePath);\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Files.isReadable(failedFilePath)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t_failedFilePaths.remove(failedFilePath);\n\n\t\t\t\t\tif (Files.isDirectory(failedFilePath)) {\n\t\t\t\t\t\tregisterFilePath(failedFilePath, true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\t\t\t\t\tfailedFilePath.toString());\n\n\t\t\t\t\t\tif (syncFile == null) {\n\t\t\t\t\t\t\tfireWatchEventListener(\n\t\t\t\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_CREATE,\n\t\t\t\t\t\t\t\tfailedFilePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (FileUtil.hasFileChanged(\n\t\t\t\t\t\t\t\t\tsyncFile, failedFilePath)) {\n\n\t\t\t\t\t\t\tfireWatchEventListener(\n\t\t\t\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_MODIFY,\n\t\t\t\t\t\t\t\tfailedFilePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!watchKey.reset()) {\n\t\t\t\t\tPath filePath = _filePaths.remove(watchKey);\n\n\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t_logger.trace(\"Unregistered file path {}\", filePath);\n\t\t\t\t\t}\n\n\t\t\t\t\tprocessMissingFilePath(filePath);\n\n\t\t\t\t\tif (_filePaths.isEmpty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"3ce280f443ab8695733ad9f74fecc1f9afcbb897","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getCreatedFilePathNames() {\n\t\treturn _createdFilePathNames;\n\t}","id":42024,"modified_method":"protected void clearCreatedFilePathNames() {\n\t\tSortedMap<Long, String> headMap = _createdFilePathNames.headMap(\n\t\t\tSystem.currentTimeMillis() - 5000);\n\n\t\theadMap.clear();\n\t}","commit_id":"3ce280f443ab8695733ad9f74fecc1f9afcbb897","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateFile(SyncFile targetSyncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (sourceSyncFile == null) {\n\t\t\taddFile(targetSyncFile, filePathName);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (filePathChanged && !Files.exists(sourceFilePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tSyncFileService.updateFileKeySyncFile(sourceSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, false);\n\t\t\t}\n\t\t}\n\t\telse if (FileUtil.hasFileChanged(targetSyncFile, sourceFilePath)) {\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t}","id":42025,"modified_method":"protected void updateFile(SyncFile targetSyncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (sourceSyncFile == null) {\n\t\t\taddFile(targetSyncFile, filePathName);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tboolean filePathChanged = processFilePathChange(\n\t\t\tsourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (filePathChanged && !Files.exists(sourceFilePath)) {\n\t\t\tif (targetSyncFile.isFolder()) {\n\t\t\t\tPath targetFilePath = Paths.get(filePathName);\n\n\t\t\t\tFiles.createDirectories(targetFilePath);\n\n\t\t\t\tSyncFileService.update(sourceSyncFile);\n\n\t\t\t\tSyncFileService.updateFileKeySyncFile(sourceSyncFile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdownloadFile(sourceSyncFile, null, false);\n\t\t\t}\n\t\t}\n\t\telse if (targetSyncFile.isFile() &&\n\t\t\t\t FileUtil.hasFileChanged(targetSyncFile, sourceFilePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t}","commit_id":"2b1f4e1ea074afff2b0c4af4c28a9f14ea60ffdc","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addFile(SyncFile syncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tif (Files.exists(filePath)) {\n\t\t\tif (syncFile.isFolder()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!FileUtil.hasFileChanged(syncFile)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_ADDED_REMOTE);\n\n\t\tif (syncFile.isFolder()) {\n\t\t\tFiles.createDirectories(filePath);\n\n\t\t\tsyncFile.setFileKey(FileUtil.getFileKey(filePath));\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tdownloadFile(syncFile, null, false);\n\t\t}\n\t}","id":42026,"modified_method":"protected void addFile(SyncFile syncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tPath filePath = Paths.get(filePathName);\n\n\t\tif (Files.exists(filePath) &&\n\t\t\t(syncFile.isFolder() ||\n\t\t\t !FileUtil.hasFileChanged(syncFile, filePath))) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tsyncFile.setFilePathName(filePathName);\n\t\tsyncFile.setSyncAccountId(getSyncAccountId());\n\t\tsyncFile.setUiEvent(SyncFile.UI_EVENT_ADDED_REMOTE);\n\n\t\tif (syncFile.isFolder()) {\n\t\t\tFiles.createDirectories(filePath);\n\n\t\t\tsyncFile.setFileKey(FileUtil.getFileKey(filePath));\n\n\t\t\tSyncFileService.update(syncFile);\n\t\t}\n\t\telse {\n\t\t\tSyncFileService.update(syncFile);\n\n\t\t\tdownloadFile(syncFile, null, false);\n\t\t}\n\t}","commit_id":"9a37e22171bfee7ab7bfebfbb0ab3e51e8fcc012","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updateFile(SyncFile targetSyncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (sourceSyncFile == null) {\n\t\t\taddFile(targetSyncFile, filePathName);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tif (Files.notExists(sourceFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tprocessFilePathChange(sourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (Files.exists(sourceFilePath) && !targetSyncFile.isFolder()) {\n\t\t\tif (!FileUtil.hasFileChanged(targetSyncFile)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t}","id":42027,"modified_method":"protected void updateFile(SyncFile targetSyncFile, String filePathName)\n\t\tthrows Exception {\n\n\t\tSyncFile sourceSyncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetSyncFile.getRepositoryId(), getSyncAccountId(),\n\t\t\ttargetSyncFile.getTypePK());\n\n\t\tif (sourceSyncFile == null) {\n\t\t\taddFile(targetSyncFile, filePathName);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString sourceVersion = sourceSyncFile.getVersion();\n\n\t\tPath sourceFilePath = Paths.get(sourceSyncFile.getFilePathName());\n\n\t\tif (Files.notExists(sourceFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tprocessFilePathChange(sourceSyncFile, targetSyncFile);\n\n\t\tsourceSyncFile.setChangeLog(targetSyncFile.getChangeLog());\n\t\tsourceSyncFile.setChecksum(targetSyncFile.getChecksum());\n\t\tsourceSyncFile.setDescription(targetSyncFile.getDescription());\n\t\tsourceSyncFile.setExtension(targetSyncFile.getExtension());\n\t\tsourceSyncFile.setExtraSettings(targetSyncFile.getExtraSettings());\n\t\tsourceSyncFile.setLockExpirationDate(\n\t\t\ttargetSyncFile.getLockExpirationDate());\n\t\tsourceSyncFile.setLockUserId(targetSyncFile.getLockUserId());\n\t\tsourceSyncFile.setLockUserName(targetSyncFile.getLockUserName());\n\t\tsourceSyncFile.setModifiedTime(targetSyncFile.getModifiedTime());\n\t\tsourceSyncFile.setSize(targetSyncFile.getSize());\n\t\tsourceSyncFile.setUiEvent(SyncFile.UI_EVENT_UPDATED_REMOTE);\n\t\tsourceSyncFile.setVersion(targetSyncFile.getVersion());\n\n\t\tSyncFileService.update(sourceSyncFile);\n\n\t\tif (Files.exists(sourceFilePath) && !targetSyncFile.isFolder() &&\n\t\t\tFileUtil.hasFileChanged(targetSyncFile, sourceFilePath)) {\n\n\t\t\tdownloadFile(\n\t\t\t\tsourceSyncFile, sourceVersion,\n\t\t\t\t!IODeltaUtil.isIgnoredFilePatchingExtension(targetSyncFile));\n\t\t}\n\t}","commit_id":"9a37e22171bfee7ab7bfebfbb0ab3e51e8fcc012","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@DB\n    protected long recalculateAccountResourceCount(long accountId, ResourceType type) {\n        Long newCount = null;\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n\n        // this lock guards against the updates to user_vm, volume, snapshot, public _ip and template table\n        // as any resource creation precedes with the resourceLimitExceeded check which needs this lock too\n        SearchCriteria<ResourceCountVO> sc = ResourceCountSearch.create();\n        sc.setParameters(\"accountId\", accountId);\n        _resourceCountDao.lockRows(sc, null, true);\n\n        ResourceCountVO accountRC = _resourceCountDao.findByOwnerAndType(accountId, ResourceOwnerType.Account, type);\n        long oldCount = accountRC.getCount();\n\n        if (type == Resource.ResourceType.user_vm) {\n            newCount = _userVmDao.countAllocatedVMsForAccount(accountId);\n        } else if (type == Resource.ResourceType.volume) {\n            newCount = _volumeDao.countAllocatedVolumesForAccount(accountId);\n            long virtualRouterCount = _vmDao.countAllocatedVirtualRoutersForAccount(accountId);\n            newCount = newCount - virtualRouterCount; // don't count the volumes of virtual router\n        } else if (type == Resource.ResourceType.snapshot) {\n            newCount = _snapshotDao.countSnapshotsForAccount(accountId);\n        } else if (type == Resource.ResourceType.public_ip) {\n            newCount = calculatePublicIpForAccount(accountId);\n        } else if (type == Resource.ResourceType.template) {\n            newCount = _vmTemplateDao.countTemplatesForAccount(accountId);\n        } else if (type == Resource.ResourceType.project) {\n            newCount = _projectAccountDao.countByAccountIdAndRole(accountId, Role.Admin);\n        } else if (type == Resource.ResourceType.network) {\n            newCount = _networkDao.countNetworksUserCanCreate(accountId);\n        } else if (type == Resource.ResourceType.vpc) {\n            newCount = _vpcDao.countByAccountId(accountId);\n        } else if (type == Resource.ResourceType.cpu) {\n            newCount = countCpusForAccount(accountId);\n        } else if (type == Resource.ResourceType.memory) {\n            newCount = calculateMemoryForAccount(accountId);\n        } else if (type == Resource.ResourceType.primary_storage) {\n            newCount = _volumeDao.primaryStorageUsedForAccount(accountId);\n        } else if (type == Resource.ResourceType.secondary_storage) {\n            newCount = calculateSecondaryStorageForAccount(accountId);\n        } else {\n            throw new InvalidParameterValueException(\"Unsupported resource type \" + type);\n        }\n        _resourceCountDao.setResourceCount(accountId, ResourceOwnerType.Account, type, (newCount == null) ? 0 : newCount.longValue());\n\n        if (oldCount != newCount) {\n            s_logger.info(\"Discrepency in the resource count \" + \"(original count=\" + oldCount + \" correct count = \" +\n                    newCount + \") for type \" + type + \" for account ID \" + accountId + \" is fixed during resource count recalculation.\");\n        }\n        txn.commit();\n\n        return (newCount == null) ? 0 : newCount.longValue();\n    }","id":42028,"modified_method":"@DB\n    protected long recalculateAccountResourceCount(long accountId, ResourceType type) {\n        Long newCount = null;\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n\n        // this lock guards against the updates to user_vm, volume, snapshot, public _ip and template table\n        // as any resource creation precedes with the resourceLimitExceeded check which needs this lock too\n        SearchCriteria<ResourceCountVO> sc = ResourceCountSearch.create();\n        sc.setParameters(\"accountId\", accountId);\n        _resourceCountDao.lockRows(sc, null, true);\n\n        ResourceCountVO accountRC = _resourceCountDao.findByOwnerAndType(accountId, ResourceOwnerType.Account, type);\n        long oldCount = 0;\n        if (accountRC != null)\n            oldCount = accountRC.getCount();\n\n        if (type == Resource.ResourceType.user_vm) {\n            newCount = _userVmDao.countAllocatedVMsForAccount(accountId);\n        } else if (type == Resource.ResourceType.volume) {\n            newCount = _volumeDao.countAllocatedVolumesForAccount(accountId);\n            long virtualRouterCount = _vmDao.countAllocatedVirtualRoutersForAccount(accountId);\n            newCount = newCount - virtualRouterCount; // don't count the volumes of virtual router\n        } else if (type == Resource.ResourceType.snapshot) {\n            newCount = _snapshotDao.countSnapshotsForAccount(accountId);\n        } else if (type == Resource.ResourceType.public_ip) {\n            newCount = calculatePublicIpForAccount(accountId);\n        } else if (type == Resource.ResourceType.template) {\n            newCount = _vmTemplateDao.countTemplatesForAccount(accountId);\n        } else if (type == Resource.ResourceType.project) {\n            newCount = _projectAccountDao.countByAccountIdAndRole(accountId, Role.Admin);\n        } else if (type == Resource.ResourceType.network) {\n            newCount = _networkDao.countNetworksUserCanCreate(accountId);\n        } else if (type == Resource.ResourceType.vpc) {\n            newCount = _vpcDao.countByAccountId(accountId);\n        } else if (type == Resource.ResourceType.cpu) {\n            newCount = countCpusForAccount(accountId);\n        } else if (type == Resource.ResourceType.memory) {\n            newCount = calculateMemoryForAccount(accountId);\n        } else if (type == Resource.ResourceType.primary_storage) {\n            newCount = _volumeDao.primaryStorageUsedForAccount(accountId);\n        } else if (type == Resource.ResourceType.secondary_storage) {\n            newCount = calculateSecondaryStorageForAccount(accountId);\n        } else {\n            throw new InvalidParameterValueException(\"Unsupported resource type \" + type);\n        }\n        _resourceCountDao.setResourceCount(accountId, ResourceOwnerType.Account, type, (newCount == null) ? 0 : newCount.longValue());\n\n        if (oldCount != newCount) {\n            s_logger.info(\"Discrepency in the resource count \" + \"(original count=\" + oldCount + \" correct count = \" +\n                    newCount + \") for type \" + type + \" for account ID \" + accountId + \" is fixed during resource count recalculation.\");\n        }\n        txn.commit();\n\n        return (newCount == null) ? 0 : newCount.longValue();\n    }","commit_id":"fff763ef81be0478d48bf826434fc15ae9df1032","url":"https://github.com/apache/cloudstack"},{"original_method":"private void appendCount(final ChangesBrowserNode node) {\n    append(\" \" + VcsBundle.message(\"changes.nodetitle.changecount\", node.getCount()), SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES);\n  }","id":42029,"modified_method":"private void appendCount(final ChangesBrowserNode node) {\n    int count = node.getCount();\n    int dirCount = node.getDirectoryCount();\n    if (count > 0 && dirCount == 0) {\n      append(\" \" + VcsBundle.message(\"changes.nodetitle.changecount\", count), SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES);\n    }\n    else if (count == 0 && dirCount > 1) {\n      append(\" \" + VcsBundle.message(\"changes.nodetitle.directory.changecount\", dirCount), SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES);\n    }\n    else {\n      append(\" \" + VcsBundle.message(\"changes.nodetitle.directory.file.changecount\", dirCount, count), SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES);\n    }\n  }","commit_id":"18e8b5433fcfb917df97c65e8377683e1e352d23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void customizeCellRenderer(JTree tree,\n                                    Object value,\n                                    boolean selected,\n                                    boolean expanded,\n                                    boolean leaf,\n                                    int row,\n                                    boolean hasFocus) {\n    ChangesBrowserNode node = (ChangesBrowserNode)value;\n    Object object = node.getUserObject();\n    if (object instanceof ChangeList) {\n      if (object instanceof LocalChangeList) {\n        final LocalChangeList list = ((LocalChangeList)object);\n        append(list.getName(),\n               list.isDefault() ? SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES : SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n        for(ChangeListDecorator decorator: myDecorators) {\n          decorator.decorateChangeList(list, this, selected, expanded, hasFocus);\n        }\n        if (list.isInUpdate()) {\n          append(\" \" + VcsBundle.message(\"changes.nodetitle.updating\"), SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n      }\n      else {\n        final ChangeList list = ((ChangeList)object);\n        append(list.getName(), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n      }\n    }\n    else if (object instanceof Change) {\n      final Change change = (Change)object;\n      final FilePath filePath = ChangesUtil.getFilePath(change);\n      append(filePath.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, getColor(change), null));\n      if (myShowFlatten) {\n        append(\" (\" + filePath.getIOFile().getParentFile().getPath() + \", \" + getChangeStatus(change).getText() + \")\",\n               SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n\n      if (filePath.isDirectory()) {\n        setIcon(Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        setIcon(filePath.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof VirtualFile) {\n      final VirtualFile file = (VirtualFile)object;\n      append(file.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, FileStatus.COLOR_UNKNOWN));\n      if (myShowFlatten && file.isValid()) {\n        final VirtualFile parentFile = file.getParent();\n        assert parentFile != null;\n        append(\" (\" + parentFile.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      setIcon(file.getFileType().getIcon());\n    }\n    else if (object instanceof FilePath) {\n      final FilePath path = (FilePath)object;\n      if (path.isDirectory() || !node.isLeaf()) {\n        append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n               SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        appendCount(node);\n        setIcon(expanded ? Icons.DIRECTORY_OPEN_ICON : Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        if (myShowFlatten) {\n          append(path.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          final FilePath parent = TreeModelBuilder.getParentPath(path);\n          append(\" (\" + parent.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        else {\n          append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n                 SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n        setIcon(path.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof Module) {\n      final Module module = (Module)object;\n\n      append(module.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n      setIcon(module.getModuleType().getNodeIcon(expanded));\n    }\n    else {\n      append(object.toString(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n    }\n  }","id":42030,"modified_method":"public void customizeCellRenderer(JTree tree,\n                                    Object value,\n                                    boolean selected,\n                                    boolean expanded,\n                                    boolean leaf,\n                                    int row,\n                                    boolean hasFocus) {\n    ChangesBrowserNode node = (ChangesBrowserNode)value;\n    Object object = node.getUserObject();\n    if (object instanceof ChangeList) {\n      if (object instanceof LocalChangeList) {\n        final LocalChangeList list = ((LocalChangeList)object);\n        append(list.getName(),\n               list.isDefault() ? SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES : SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n        for(ChangeListDecorator decorator: myDecorators) {\n          decorator.decorateChangeList(list, this, selected, expanded, hasFocus);\n        }\n        if (list.isInUpdate()) {\n          append(\" \" + VcsBundle.message(\"changes.nodetitle.updating\"), SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n      }\n      else {\n        final ChangeList list = ((ChangeList)object);\n        append(list.getName(), SimpleTextAttributes.SIMPLE_CELL_ATTRIBUTES);\n        appendCount(node);\n      }\n    }\n    else if (object instanceof Change) {\n      final Change change = (Change)object;\n      final FilePath filePath = ChangesUtil.getFilePath(change);\n      append(filePath.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, getColor(change), null));\n      if (myShowFlatten) {\n        append(\" (\" + filePath.getIOFile().getParentFile().getPath() + \", \" + getChangeStatus(change).getText() + \")\",\n               SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      else if (node.getCount() != 0) {\n        appendCount(node);\n      }\n\n      if (filePath.isDirectory()) {\n        setIcon(Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        setIcon(filePath.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof VirtualFile) {\n      final VirtualFile file = (VirtualFile)object;\n      append(file.getName(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, FileStatus.COLOR_UNKNOWN));\n      if (myShowFlatten && file.isValid()) {\n        final VirtualFile parentFile = file.getParent();\n        assert parentFile != null;\n        append(\" (\" + parentFile.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      setIcon(file.getFileType().getIcon());\n    }\n    else if (object instanceof FilePath) {\n      final FilePath path = (FilePath)object;\n      if (path.isDirectory() || !node.isLeaf()) {\n        append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n               SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        appendCount(node);\n        setIcon(expanded ? Icons.DIRECTORY_OPEN_ICON : Icons.DIRECTORY_CLOSED_ICON);\n      }\n      else {\n        if (myShowFlatten) {\n          append(path.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          final FilePath parent = TreeModelBuilder.getParentPath(path);\n          append(\" (\" + parent.getPresentableUrl() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        else {\n          append(ChangesListView.getRelativePath(ChangesListView.safeCastToFilePath(((ChangesBrowserNode)node.getParent()).getUserObject()), path),\n                 SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n        setIcon(path.getFileType().getIcon());\n      }\n    }\n    else if (object instanceof Module) {\n      final Module module = (Module)object;\n\n      append(module.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n      setIcon(module.getModuleType().getNodeIcon(expanded));\n    }\n    else {\n      append(object.toString(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      appendCount(node);\n    }\n  }","commit_id":"18e8b5433fcfb917df97c65e8377683e1e352d23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void insert(MutableTreeNode newChild, int childIndex) {\n    super.insert(newChild, childIndex);\n    count = -1;\n  }","id":42031,"modified_method":"public void insert(MutableTreeNode newChild, int childIndex) {\n    super.insert(newChild, childIndex);\n    count = -1;\n    myDirectoryCount = -1;\n  }","commit_id":"18e8b5433fcfb917df97c65e8377683e1e352d23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DefaultTreeModel buildModel(final List<Change> changes) {\n    final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n    final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n    for (Change change : changes) {\n      final ChangesBrowserNode node = new ChangesBrowserNode(change);\n      ChangesUtil.getFilePath(change).refresh();\n      model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, root), 0);\n    }\n\n    collapseDirectories(model, root);\n    sortNodes();\n\n    return model;\n  }","id":42032,"modified_method":"public DefaultTreeModel buildModel(final List<Change> changes) {\n    final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n    final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n    for (Change change : changes) {\n      insertChangeNode(change, foldersCache, moduleCache, root);\n    }\n\n    collapseDirectories(model, root);\n    sortNodes();\n\n    return model;\n  }","commit_id":"18e8b5433fcfb917df97c65e8377683e1e352d23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DefaultTreeModel buildModel(final List<? extends ChangeList> changeLists,\n                                     final List<VirtualFile> unversionedFiles,\n                                     final List<File> locallyDeletedFiles) {\n\n    for (ChangeList list : changeLists) {\n      ChangesBrowserNode listNode = new ChangesBrowserNode(list);\n      model.insertNodeInto(listNode, root, 0);\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (Change change : list.getChanges()) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(change);\n        ChangesUtil.getFilePath(change).refresh();\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, listNode), 0);\n      }\n    }\n\n    if (!unversionedFiles.isEmpty()) {\n      ChangesBrowserNode unversionedNode = new ChangesBrowserNode(VcsBundle.message(\"changes.nodetitle.unversioned.files\"));\n      model.insertNodeInto(unversionedNode, root, root.getChildCount());\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (VirtualFile file : unversionedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(file);\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, unversionedNode), 0);\n      }\n    }\n\n    if (!locallyDeletedFiles.isEmpty()) {\n      ChangesBrowserNode locallyDeletedNode = new ChangesBrowserNode(VcsBundle.message(\"changes.nodetitle.locally.deleted.files\"));\n      model.insertNodeInto(locallyDeletedNode, root, root.getChildCount());\n      final VcsContextFactory factory = PeerFactory.getInstance().getVcsContextFactory();\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (File file : locallyDeletedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(factory.createFilePathOn(file));\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, locallyDeletedNode), 0);\n      }\n    }\n\n    collapseDirectories(model, root);\n    sortNodes();\n\n    return model;\n  }","id":42033,"modified_method":"public DefaultTreeModel buildModel(final List<? extends ChangeList> changeLists,\n                                     final List<VirtualFile> unversionedFiles,\n                                     final List<File> locallyDeletedFiles) {\n\n    for (ChangeList list : changeLists) {\n      ChangesBrowserNode listNode = new ChangesBrowserNode(list);\n      model.insertNodeInto(listNode, root, 0);\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (Change change : list.getChanges()) {\n        insertChangeNode(change, foldersCache, moduleCache, listNode);\n      }\n    }\n\n    if (!unversionedFiles.isEmpty()) {\n      ChangesBrowserNode unversionedNode = new ChangesBrowserNode(VcsBundle.message(\"changes.nodetitle.unversioned.files\"));\n      model.insertNodeInto(unversionedNode, root, root.getChildCount());\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (VirtualFile file : unversionedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(file);\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, unversionedNode), 0);\n      }\n    }\n\n    if (!locallyDeletedFiles.isEmpty()) {\n      ChangesBrowserNode locallyDeletedNode = new ChangesBrowserNode(VcsBundle.message(\"changes.nodetitle.locally.deleted.files\"));\n      model.insertNodeInto(locallyDeletedNode, root, root.getChildCount());\n      final VcsContextFactory factory = PeerFactory.getInstance().getVcsContextFactory();\n      final HashMap<FilePath, ChangesBrowserNode> foldersCache = new HashMap<FilePath, ChangesBrowserNode>();\n      final HashMap<Module, ChangesBrowserNode> moduleCache = new HashMap<Module, ChangesBrowserNode>();\n      for (File file : locallyDeletedFiles) {\n        final ChangesBrowserNode node = new ChangesBrowserNode(factory.createFilePathOn(file));\n        model.insertNodeInto(node, getParentNodeFor(node, foldersCache, moduleCache, locallyDeletedNode), 0);\n      }\n    }\n\n    collapseDirectories(model, root);\n    sortNodes();\n\n    return model;\n  }","commit_id":"18e8b5433fcfb917df97c65e8377683e1e352d23","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** paging */\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.sakaiproject.cheftool.PagedResourceActionII#sizeResources(org.sakaiproject.service.framework.session.SessionState)\n\t */\n\tprotected int sizeResources(SessionState state)\n\t{\n\t\tString search = (String) state.getAttribute(STATE_SEARCH);\n\n\t\t// We cache the count at the tool level because it is not done perfectly\n\t\t// at the lower layer\n\t\tInteger lastCount = (Integer) state.getAttribute(STATE_COUNT);\n\t\tString countSearch = (String) state.getAttribute(STATE_COUNT_SEARCH);\n\t\n\t\tif ( search == null && countSearch == null && lastCount != null )\n\t\t{\n\t\t\treturn lastCount.intValue();\n\t\t}\n\t\tif ( countSearch != null && countSearch.equals(search))\n\t\t{\n\t\t\treturn lastCount.intValue();\n\t\t}\n\t\n\t\t// We must talk to the Storage to count the messages\n        \ttry\n\t\t{\n\t\t\tMailArchiveChannel channel = MailArchiveService.getMailArchiveChannel((String) state.getAttribute(STATE_CHANNEL_REF));\n\t\t\tint cCount = channel.getCount((Filter) getSearchFilter(search, 0, 0));\n\n\t\t\tlastCount = Integer.valueOf(cCount);\n\t\t\tstate.setAttribute(STATE_COUNT, lastCount);\n\t\t\tstate.setAttribute(STATE_COUNT_SEARCH, search);\n\t\t\treturn cCount;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tLog.warn(\"sakai\", \"sizeResources failed search=\"+search+\" exeption=\"+e);\n\t\t}\n        \treturn 0;\n\t}","id":42034,"modified_method":"/** paging */\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.sakaiproject.cheftool.PagedResourceActionII#sizeResources(org.sakaiproject.service.framework.session.SessionState)\n\t */\n\tprotected int sizeResources(SessionState state)\n\t{\n\t\tString search = (String) state.getAttribute(STATE_SEARCH);\n\n\t\t// We cache the count at the tool level because it is not done perfectly\n\t\t// at the lower layer\n\t\tInteger lastCount = (Integer) state.getAttribute(STATE_COUNT);\n\t\tString countSearch = (String) state.getAttribute(STATE_COUNT_SEARCH);\n\t\n\t\tif ( search == null && countSearch == null && lastCount != null )\n\t\t{\n\t\t\treturn lastCount.intValue();\n\t\t}\n\t\tif ( countSearch != null && countSearch.equals(search))\n\t\t{\n\t\t\treturn lastCount.intValue();\n\t\t}\n\t\n\t\t// We must talk to the Storage to count the messages\n        \ttry\n\t\t{\n\t\t\tMailArchiveChannel channel = MailArchiveService.getMailArchiveChannel((String) state.getAttribute(STATE_CHANNEL_REF));\n\n\t\t\tint cCount = 0;\n\t\t\tif(search == null) {\n\t\t\t    cCount = channel.getCount();\n\t\t\t} else {\n                cCount = channel.getCount((Filter) getSearchFilter(search, 0, 0));\n\t\t\t}\n\n\t\t\tlastCount = new Integer(cCount);\n\t\t\tstate.setAttribute(STATE_COUNT, lastCount);\n\t\t\tstate.setAttribute(STATE_COUNT_SEARCH, search);\n\t\t\treturn cCount;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tLog.warn(\"sakai\", \"sizeResources failed search=\"+search+\" exeption=\"+e);\n\t\t}\n        \treturn 0;\n\t}","commit_id":"bde5c3c9855648b630bb84904fa9810f2875082f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static double getGoogleNgramScore(CandidatePhrase g) {\n    double count = GoogleNGramsSQLBacked.getCount(g.getPhrase());\n    if (count != -1) {\n      if(!Data.rawFreq.containsKey(g))\n        //returning 1 because usually lower this tf-idf score the better. if we don't have raw freq info, give it a bad score\n        return 1;\n      else\n        return (1 + Data.rawFreq.getCount(g)\n          * Math.sqrt(Data.ratioGoogleNgramFreqWithDataFreq))\n          / count;\n    }\n    return 0;\n  }","id":42035,"modified_method":"public static double getGoogleNgramScore(CandidatePhrase g) {\n    double count = GoogleNGramsSQLBacked.getCount(g.getPhrase().toLowerCase()) + GoogleNGramsSQLBacked.getCount(g.getPhrase());\n    if (count != -1) {\n      if(!Data.rawFreq.containsKey(g))\n        //returning 1 because usually lower this tf-idf score the better. if we don't have raw freq info, give it a bad score\n        return 1;\n      else\n        return (1 + Data.rawFreq.getCount(g)\n          * Math.sqrt(Data.ratioGoogleNgramFreqWithDataFreq))\n          / count;\n    }\n    return 0;\n  }","commit_id":"a647637631cbe56898d735c348e530de2094c1b3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * Appends the Mail headers from the Camel {@link MailMessage}\n     */\n    protected void appendHeadersFromCamel(MimeMessage mimeMessage, Exchange exchange,\n                                          org.apache.camel.Message camelMessage) throws MessagingException {\n        Set<Map.Entry<String, Object>> entries = camelMessage.getHeaders().entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            String headerName = entry.getKey();\n            Object headerValue = entry.getValue();\n            if (headerValue != null) {\n                if (shouldOutputHeader(camelMessage, headerName, headerValue)) {\n\n                    // Mail messages can repeat the same header...\n                    if (ObjectConverter.isCollection(headerValue)) {\n                        Iterator iter = ObjectConverter.iterator(headerValue);\n                        while (iter.hasNext()) {\n                            Object value = iter.next();\n                            mimeMessage.addHeader(headerName, asString(exchange, value));\n                        }\n                    } else {\n                        mimeMessage.setHeader(headerName, asString(exchange, headerValue));\n                    }\n                }\n            }\n        }\n    }","id":42036,"modified_method":"/**\n     * Appends the Mail headers from the Camel {@link MailMessage}\n     */\n    protected void appendHeadersFromCamel(MimeMessage mimeMessage, Exchange exchange,\n                                          org.apache.camel.Message camelMessage)\n        throws MessagingException {\n\n        for (Map.Entry<String, Object> entry : camelMessage.getHeaders().entrySet()) {\n            String headerName = entry.getKey();\n            Object headerValue = entry.getValue();\n            if (headerValue != null) {\n                if (shouldOutputHeader(camelMessage, headerName, headerValue)) {\n\n                    // Mail messages can repeat the same header...\n                    if (ObjectConverter.isCollection(headerValue)) {\n                        Iterator iter = ObjectConverter.iterator(headerValue);\n                        while (iter.hasNext()) {\n                            Object value = iter.next();\n                            mimeMessage.addHeader(headerName, asString(exchange, value));\n                        }\n                    } else {\n                        mimeMessage.setHeader(headerName, asString(exchange, headerValue));\n                    }\n                }\n            }\n        }\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Strategy to allow filtering of attachments which are put on the Mail message\n     */\n    protected boolean shouldOutputAttachment(org.apache.camel.Message camelMessage, String headerName,\n                                             DataHandler headerValue) {\n        return true;\n    }","id":42037,"modified_method":"/**\n     * Strategy to allow filtering of attachments which are put on the Mail message\n     */\n    protected boolean shouldOutputAttachment(org.apache.camel.Message camelMessage, String attachmentFilename, DataHandler handler) {\n        return true;\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Appends the Mail attachments from the Camel {@link MailMessage}\n     */\n    protected void appendAttachmentsFromCamel(MimeMessage mimeMessage, Exchange exchange,\n                                              org.apache.camel.Message camelMessage)\n        throws MessagingException {\n\n        // TODO: Use spring mail support to add the attachment\n\n        // Create a Multipart\n        MimeMultipart multipart = new MimeMultipart();\n\n        // fill the body with text\n        multipart.setSubType(\"mixed\");\n        MimeBodyPart textBodyPart = new MimeBodyPart();\n        textBodyPart.setContent(exchange.getIn().getBody(String.class), \"text/plain\");\n        multipart.addBodyPart(textBodyPart);\n\n        BodyPart messageBodyPart;\n\n        Set<Map.Entry<String, DataHandler>> entries = camelMessage.getAttachments().entrySet();\n        for (Map.Entry<String, DataHandler> entry : entries) {\n            String attName = entry.getKey();\n            DataHandler attValue = entry.getValue();\n            if (attValue != null) {\n                if (shouldOutputAttachment(camelMessage, attName, attValue)) {\n                    // Create another body part\n                    messageBodyPart = new MimeBodyPart();\n                    // Set the data handler to the attachment\n                    messageBodyPart.setDataHandler(attValue);\n                    // Set the filename\n                    messageBodyPart.setFileName(attName);\n                    // Set Disposition\n                    messageBodyPart.setDisposition(Part.ATTACHMENT);\n                    // Add part to multipart\n                    multipart.addBodyPart(messageBodyPart);\n                }\n            }\n        }\n        // Put parts in message\n        mimeMessage.setContent(multipart);\n    }","id":42038,"modified_method":"/**\n     * Appends the Mail attachments from the Camel {@link MailMessage}\n     */\n    protected void appendAttachmentsFromCamel(MimeMessage mimeMessage, Exchange exchange,\n                                              org.apache.camel.Message camelMessage)\n        throws MessagingException {\n\n        // Create a Multipart\n        MimeMultipart multipart = new MimeMultipart();\n\n        // fill the body with text\n        multipart.setSubType(\"mixed\");\n        MimeBodyPart textBodyPart = new MimeBodyPart();\n        textBodyPart.setContent(exchange.getIn().getBody(String.class), \"text/plain\");\n        multipart.addBodyPart(textBodyPart);\n\n        for (Map.Entry<String, DataHandler> entry : camelMessage.getAttachments().entrySet()) {\n            String attachmentFilename = entry.getKey();\n            DataHandler handler = entry.getValue();\n            if (handler != null) {\n                if (shouldOutputAttachment(camelMessage, attachmentFilename, handler)) {\n                    // Create another body part\n                    BodyPart messageBodyPart = new MimeBodyPart();\n                    // Set the data handler to the attachment\n                    messageBodyPart.setDataHandler(handler);\n                    // Set the filename\n                    messageBodyPart.setFileName(attachmentFilename);\n                    // Set Disposition\n                    messageBodyPart.setDisposition(Part.ATTACHMENT);\n                    // Add part to multipart\n                    multipart.addBodyPart(messageBodyPart);\n                }\n            }\n        }\n\n        // Put parts in message\n        mimeMessage.setContent(multipart);\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"public void populateMailMessage(MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange) {\n        try {\n            appendHeadersFromCamel(mimeMessage, exchange, exchange.getIn());\n\n            // set the recipients (receives) of the mail\n            Map<Message.RecipientType, String> recipients = endpoint.getConfiguration().getRecipients();\n            if (recipients.containsKey(Message.RecipientType.TO)) {\n                mimeMessage.setRecipients(Message.RecipientType.TO, recipients.get(Message.RecipientType.TO));\n            }\n            if (recipients.containsKey(Message.RecipientType.CC)) {\n                mimeMessage.setRecipients(Message.RecipientType.CC, recipients.get(Message.RecipientType.CC));\n            }\n            if (recipients.containsKey(Message.RecipientType.BCC)) {\n                mimeMessage.setRecipients(Message.RecipientType.BCC, recipients.get(Message.RecipientType.BCC));\n            }\n\n            // must have at least one recipients otherwise we do not know where to send the mail\n            if (mimeMessage.getAllRecipients() == null) {\n                throw new IllegalArgumentException(\"The mail message does not have any recipients set.\");\n            }\n\n            if (empty(mimeMessage.getFrom())) {\n                // lets default the address to the endpoint destination\n                String from = endpoint.getConfiguration().getFrom();\n                mimeMessage.setFrom(new InternetAddress(from));\n            }\n\n            if (exchange.getIn().getAttachments() != null && exchange.getIn().getAttachments().size() > 0) {\n                appendAttachmentsFromCamel(mimeMessage, exchange, exchange.getIn());\n            } else {\n                mimeMessage.setText(exchange.getIn().getBody(String.class));\n            }\n        } catch (Exception e) {\n            throw new RuntimeMailException(\"Failed to populate body due to: \" + e.getMessage()\n                                           + \". Exchange: \" + exchange, e);\n        }\n    }","id":42039,"modified_method":"public void populateMailMessage(MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange)\n        throws MessagingException {\n\n        appendHeadersFromCamel(mimeMessage, exchange, exchange.getIn());\n\n        // set the recipients (receivers) of the mail\n        Map<Message.RecipientType, String> recipients = endpoint.getConfiguration().getRecipients();\n        if (recipients.containsKey(Message.RecipientType.TO)) {\n            mimeMessage.setRecipients(Message.RecipientType.TO, recipients.get(Message.RecipientType.TO));\n        }\n        if (recipients.containsKey(Message.RecipientType.CC)) {\n            mimeMessage.setRecipients(Message.RecipientType.CC, recipients.get(Message.RecipientType.CC));\n        }\n        if (recipients.containsKey(Message.RecipientType.BCC)) {\n            mimeMessage.setRecipients(Message.RecipientType.BCC, recipients.get(Message.RecipientType.BCC));\n        }\n\n        // must have at least one recipients otherwise we do not know where to send the mail\n        if (mimeMessage.getAllRecipients() == null) {\n            throw new IllegalArgumentException(\"The mail message does not have any recipients set.\");\n        }\n\n        if (empty(mimeMessage.getFrom())) {\n            // lets default the address to the endpoint destination\n            String from = endpoint.getConfiguration().getFrom();\n            mimeMessage.setFrom(new InternetAddress(from));\n        }\n\n        if (exchange.getIn().hasAttachments()) {\n            appendAttachmentsFromCamel(mimeMessage, exchange, exchange.getIn());\n        } else {\n            mimeMessage.setText(exchange.getIn().getBody(String.class));\n        }\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"protected boolean empty(Address[] addresses) {\n        return addresses == null || addresses.length == 0;\n    }","id":42040,"modified_method":"private static boolean empty(Address[] addresses) {\n        return addresses == null || addresses.length == 0;\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Extracts the body from the Mail message\n     */\n    public Object extractBodyFromMail(MailExchange exchange, Message message) {\n        try {\n            return message.getContent();\n        } catch (Exception e) {\n            throw new RuntimeMailException(\"Failed to extract body due to: \" + e.getMessage()\n                                           + \". Exchange: \" + exchange + \". Message: \" + message, e);\n        }\n    }","id":42041,"modified_method":"/**\n     * Extracts the body from the Mail message\n     */\n    public Object extractBodyFromMail(MailExchange exchange, Message message) {\n        try {\n            return message.getContent();\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Failed to extract body due to: \" + e.getMessage()\n                + \". Exchange: \" + exchange + \". Message: \" + message, e);\n        }\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Converts the given object value to a String\n     */\n    protected String asString(Exchange exchange, Object value) {\n        return exchange.getContext().getTypeConverter().convertTo(String.class, value);\n    }","id":42042,"modified_method":"private static String asString(Exchange exchange, Object value) {\n        return exchange.getContext().getTypeConverter().convertTo(String.class, value);\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        if (mailMessage != null) {\n            Enumeration names;\n            try {\n                names = mailMessage.getAllHeaders();\n            } catch (MessagingException e) {\n                throw new MessageHeaderNamesAccessException(e);\n            }\n            try {\n                while (names.hasMoreElements()) {\n                    Header header = (Header)names.nextElement();\n                    String value = header.getValue();\n                    String name = header.getName();\n                    CollectionHelper.appendValue(map, name, value);\n                }\n            } catch (Exception e) {\n                throw new MessageHeaderNamesAccessException(e);\n            }\n        }\n    }","id":42043,"modified_method":"@Override\n    protected void populateInitialHeaders(Map<String, Object> map) {\n        if (mailMessage != null) {\n            try {\n                Enumeration names = mailMessage.getAllHeaders();\n                while (names.hasMoreElements()) {\n                    Header header = (Header)names.nextElement();\n                    String value = header.getValue();\n                    String name = header.getName();\n                    CollectionHelper.appendValue(map, name, value);\n                }\n            } catch (MessagingException e) {\n                throw new RuntimeCamelException(\"Error accessing headers due to: \" + e.getMessage(), e);\n            }\n        }\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void populateInitialAttachments(Map<String, DataHandler> map) {\n        if (mailMessage != null) {\n            try {\n                extractAttachments(map);\n            } catch (MessagingException ex) {\n                throw new RuntimeMailException(\"Error populating the initial mail message attachments\", ex);\n            }\n        }\n    }","id":42044,"modified_method":"@Override\n    protected void populateInitialAttachments(Map<String, DataHandler> map) {\n        if (mailMessage != null) {\n            try {\n                extractAttachments(mailMessage, map);\n            } catch (Exception e) {\n                throw new RuntimeCamelException(\"Error populating the initial mail message attachments\", e);\n            }\n        }\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Parses the attachments of the mail message and puts them to the message\n     *\n     * @param map       the attachments map\n     * @throws javax.mail.MessagingException\n     */\n    protected void extractAttachments(Map<String, DataHandler> map) throws javax.mail.MessagingException {\n        // TODO: Reuse spring mail support to handle the attachment\n        // now convert the mail attachments and put it to the msg\n        Multipart mp;\n        Object content;\n\n        try {\n            content = this.mailMessage.getContent();\n\n            if (content instanceof Multipart) {\n                // mail with attachment\n                mp = (Multipart)content;\n                int nbMP = mp.getCount();\n                for (int i = 0; i < nbMP; i++) {\n                    Part part = mp.getBodyPart(i);\n                    String disposition = part.getDisposition();\n\n                    if (disposition != null\n                        && (disposition.equalsIgnoreCase(Part.ATTACHMENT) || disposition\n                            .equalsIgnoreCase(Part.INLINE))) {\n                        // only add named attachments\n                        if (part.getFileName() != null) {\n                            // Parts marked with a disposition of\n                            // Part.ATTACHMENT\n                            // from part.getDisposition() are clearly\n                            // attachments\n                            DataHandler att = part.getDataHandler();\n                            // this is clearly a attachment\n                            CollectionHelper.appendValue(map, part.getFileName(), att);\n                        }\n                    }\n                }\n            }\n        } catch (MessagingException e) {\n            throw new javax.mail.MessagingException(\"Error while setting content on normalized message\", e);\n        } catch (IOException e) {\n            throw new javax.mail.MessagingException(\"Error while fetching content\", e);\n        }\n    }","id":42045,"modified_method":"/**\n     * Parses the attachments of the given mail message and adds them to the map\n     *\n     * @param  message  the mail message with attachments\n     * @param  map      the map to add found attachments (attachmentFilename is the key)\n     */\n    protected static void extractAttachments(Message message, Map<String, DataHandler> map)\n        throws javax.mail.MessagingException, IOException {\n        \n        Object content = message.getContent();\n        if (content instanceof Multipart) {\n            // mail with attachment\n            Multipart mp = (Multipart)content;\n            for (int i = 0; i < mp.getCount(); i++) {\n                Part part = mp.getBodyPart(i);\n                String disposition = part.getDisposition();\n                if (disposition != null) {\n                    if (disposition.equalsIgnoreCase(Part.ATTACHMENT) || disposition.equalsIgnoreCase(Part.INLINE)) {\n                        // only add named attachments\n                        if (part.getFileName() != null) {\n                            // Parts marked with a disposition of Part.ATTACHMENT are clearly attachments\n                            CollectionHelper.appendValue(map, part.getFileName(), part.getDataHandler());\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"public Object getHeader(String name) {\n        String[] answer = null;\n        if (mailMessage != null) {\n            try {\n                answer = mailMessage.getHeader(name);\n            } catch (MessagingException e) {\n                throw new MessageHeaderAccessException(name, e);\n            }\n        }\n        if (answer == null) {\n            return super.getHeader(name);\n        }\n        if (answer.length == 1) {\n            return answer[0];\n        }\n        return answer;\n    }","id":42046,"modified_method":"public Object getHeader(String name) {\n        String[] answer = null;\n        if (mailMessage != null) {\n            try {\n                answer = mailMessage.getHeader(name);\n            } catch (MessagingException e) {\n                throw new RuntimeCamelException(\"Error accessing header: \" + name, e);\n            }\n        }\n        if (answer == null) {\n            return super.getHeader(name);\n        }\n        if (answer.length == 1) {\n            return answer[0];\n        }\n        return answer;\n    }","commit_id":"9a9e8041610ec05e9a35987ed6b748c4de341901","url":"https://github.com/apache/camel"},{"original_method":"@Inject\r\n\tpublic CachedWebTransTableModel(WebTransTableModel tableModel) {\r\n\t\tsuper(tableModel);\r\n\t\tsetPreCachedRowCount(200);\r\n\t\tsetPostCachedRowCount(200);\r\n\t\tsetRowCount(1000);\r\n\t}","id":42047,"modified_method":"@Inject\r\n\tpublic CachedWebTransTableModel(WebTransTableModel tableModel) {\r\n\t\tsuper(tableModel);\r\n\t\tsetPreCachedRowCount(200);\r\n\t\tsetPostCachedRowCount(200);\r\n\t\ttableModel.addRowCountChangeHandler(new RowCountChangeHandler() {\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void onRowCountChange(RowCountChangeEvent event) {\r\n\t\t\t\tsetRowCount(event.getNewRowCount());\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"private ArrayList<TransUnit> generateSampleData(int numRows, int start) {\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(int i=0;i<numRows; i++) {\n\t\t\tTransUnit unit = new TransUnit(\"<hellow num=\\\"\" + (i+start) + \"\\\" />\", \"<world> \\\"\" + (i+start) +\"\\\"<\/world>\");\n\t\t\tunit.setFuzzy(Math.random() > 0.7);\n\t\t\tunits.add(unit);\n\t\t}\n\t\treturn units;\n\t}","id":42048,"modified_method":"private ArrayList<TransUnit> generateSampleData(int numRows, int start) {\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(int i=start;i<start+numRows; i++) {\n\t\t\tTransUnit unit = new TransUnit(\"<hellow num=\\\"\" + (i+1) + \"\\\" />\", \"<world> \\\"\" + (i+1) +\"\\\"<\/world>\");\n\t\t\tunit.setFuzzy(Math.random() > 0.7);\n\t\t\tunits.add(unit);\n\t\t}\n\t\treturn units;\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic GotTransUnits execute(GetTransUnits action, ExecutionContext context)\n\t\t\tthrows ActionException {\n\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\treturn new GotTransUnits( generateSampleData(action.getCount(), action.getOffset()) );\n\t}","id":42049,"modified_method":"@Override\n\tpublic GotTransUnits execute(GetTransUnits action, ExecutionContext context)\n\t\t\tthrows ActionException {\n\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\tint rows = action.getCount() + action.getOffset() > TOTAL ? action.getCount() : TOTAL-action.getOffset();\n\t\tArrayList<TransUnit> units = generateSampleData(rows, action.getOffset()); \n\t\treturn new GotTransUnits( units, TOTAL );\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"public GotTransUnits(ArrayList<TransUnit> units) {\n\t\tthis.units = units;\n\t}","id":42050,"modified_method":"public GotTransUnits(ArrayList<TransUnit> units, int totalCount) {\n\t\tthis.units = units;\n\t\tthis.totalCount = totalCount;\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void refresh(){\r\n\t\tpageCountLabel.setText(\"of \"+ pageCount);\r\n\t\tfirstPage.setEnabled( currentPage != 1);\r\n\t\tpreviousPage.setEnabled( currentPage != 1);\r\n\t\tnextPage.setEnabled( currentPage != pageCount );\r\n\t\tlastPage.setEnabled( currentPage != pageCount);\r\n\t\tgotoPage.setText( String.valueOf(currentPage) );\r\n\t}","id":42051,"modified_method":"private void refresh(){\r\n\t\tString page = pageCount == PAGECOUNT_UNKNOWN ? \"\" : \"of \" + pageCount;\r\n\t\tpageCountLabel.setText(page);\r\n\t\tfirstPage.setEnabled( currentPage != 1);\r\n\t\tpreviousPage.setEnabled( currentPage != 1);\r\n\t\tnextPage.setEnabled( currentPage != pageCount );\r\n\t\tlastPage.setEnabled( currentPage != pageCount && pageCount != PAGECOUNT_UNKNOWN );\r\n\t\tlastPage.setVisible(pageCount != PAGECOUNT_UNKNOWN);\r\n\t\tgotoPage.setText( String.valueOf(currentPage) );\r\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tprotected void onBind() {\n\t\tfinal Pager pager = new Pager();\n\t\t\n\t\tpager.addValueChangeHandler(new ValueChangeHandler<Integer>() {\n\t\t\t@Override\n\t\t\tpublic void onValueChange(ValueChangeEvent<Integer> event) {\n\t\t\t\tdisplay.getPageNavigation().gotoPage(event.getValue(), false);\n\t\t\t}\n\t\t});\n\t\t\n\t\tdisplay.getPageCountChangeHandlers().addPageCountChangeHandler(new PageCountChangeHandler() {\n\t\t\t@Override\n\t\t\tpublic void onPageCountChange(PageCountChangeEvent event) {\n\t\t\t\tpager.setPageCount(event.getNewPageCount());\n\t\t\t}\n\t\t});\n\t\t\n\t\tdisplay.getPageChangeHandlers().addPageChangeHandler(new PageChangeHandler() {\n\t\t\t@Override\n\t\t\tpublic void onPageChange(PageChangeEvent event) {\n\t\t\t\tpager.setValue(event.getNewPage());\n\t\t\t}\n\t\t});\n\t\t\n\t\t//display.getToolbar().add(pager);\n\t\t\n\t\tdisplay.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(event.getSelectedItem() != currentSelection) {\n\t\t\t\t\tcurrentSelection = event.getSelectedItem();\n\t\t\t\t\teventBus.fireEvent(event);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t}","id":42052,"modified_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tdisplay.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(event.getSelectedItem() != currentSelection) {\n\t\t\t\t\tcurrentSelection = event.getSelectedItem();\n\t\t\t\t\teventBus.fireEvent(event);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tdisplay.getPageNavigation().gotoFirstPage();\n\t\t\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tdisplay.getPager().setPageCount(display.getScrollTable().getPageCount());\n\t\tdisplay.getPager().setValue( display.getScrollTable().getCurrentPage()+1);\n\n\t\tdisplay.getPager().addValueChangeHandler( new ValueChangeHandler<Integer>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onValueChange(ValueChangeEvent<Integer> event) {\n\t\t\t\tdisplay.getScrollTable().gotoPage(event.getValue()-1, false);\n\t\t\t}\n\t\t});\n\t\t\n\t\tdisplay.getScrollTable().addPageChangeHandler( new PageChangeHandler() {\n\t\t\t@Override\n\t\t\tpublic void onPageChange(PageChangeEvent event) {\n\t\t\t\tdisplay.getPager().setValue(event.getNewPage()+1);\n\t\t\t}\n\t\t});\n\t\tdisplay.getScrollTable().addPageCountChangeHandler(new PageCountChangeHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onPageCountChange(PageCountChangeEvent event) {\n\t\t\t\tdisplay.getPager().setPageCount(event.getNewPageCount());\n\t\t\t}\n\t\t});\n\t}","id":42053,"modified_method":"@Override\n\tprotected void onBind() {\n\t\t\n\t\tdisplay.getPager().addValueChangeHandler( new ValueChangeHandler<Integer>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onValueChange(ValueChangeEvent<Integer> event) {\n\t\t\t\tdisplay.getScrollTable().gotoPage(event.getValue()-1, false);\n\t\t\t}\n\t\t});\n\t\t\n\t\tdisplay.getScrollTable().addPageChangeHandler( new PageChangeHandler() {\n\t\t\t@Override\n\t\t\tpublic void onPageChange(PageChangeEvent event) {\n\t\t\t\tdisplay.getPager().setValue(event.getNewPage()+1);\n\t\t\t}\n\t\t});\n\t\tdisplay.getScrollTable().addPageCountChangeHandler(new PageCountChangeHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onPageCountChange(PageCountChangeEvent event) {\n\t\t\t\tdisplay.getPager().setPageCount(event.getNewPageCount());\n\t\t\t}\n\t\t});\n\t\t\n\t\tdisplay.getScrollTable().gotoFirstPage();\n\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic void requestRows(\n\t\t\tfinal Request request,\n\t\t\tfinal Callback<TransUnit> callback) {\n\t\tint numRows = request.getNumRows();\n\t\tint startRow = request.getStartRow();\n\t\t\n\t\tLog.info(\"Requesting \" + numRows + \" rows\");\n\t\t\n\t\tdispatcher.execute(new GetTransUnits(1, startRow, numRows), new AsyncCallback<GotTransUnits>() {\n\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GotTransUnits result) {\n\t\t\t\tSerializableResponse<TransUnit> response = new SerializableResponse<TransUnit>(\n\t\t\t\t\t\tresult.getUnits());\n\t\t\t\tcallback.onRowsReady(request, response);\n\t\t\t\tLog.info(\"got rows\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\tcallback.onFailure(caught);\n\t\t\t\tLog.info(\"got failure: \",caught);\n\t\t\t}\n\n\t\t\t\n\t\t});\n\t}","id":42054,"modified_method":"@Override\n\tpublic void requestRows(\n\t\t\tfinal Request request,\n\t\t\tfinal Callback<TransUnit> callback) {\n\t\tint numRows = request.getNumRows();\n\t\tint startRow = request.getStartRow();\n\t\t\n\t\tLog.info(\"Requesting \" + numRows + \" rows\");\n\t\t\n\t\tdispatcher.execute(new GetTransUnits(1, startRow, numRows), new AsyncCallback<GotTransUnits>() {\n\n\t\t\t@Override\n\t\t\tpublic void onSuccess(GotTransUnits result) {\n\t\t\t\tSerializableResponse<TransUnit> response = new SerializableResponse<TransUnit>(\n\t\t\t\t\t\tresult.getUnits());\n\t\t\t\tcallback.onRowsReady(request, response);\n\t\t\t\tsetRowCount(result.getTotalCount());\n\t\t\t\tLog.info(\"got rows\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\tcallback.onFailure(caught);\n\t\t\t\tLog.info(\"got failure: \",caught);\n\t\t\t}\n\n\t\t\t\n\t\t});\n\t}","commit_id":"9c125f797e79d357e6b83143b68cfec6a7d154c1","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<VCFFormatHeaderLine> getDescriptions() { return Arrays.asList(new VCFFormatHeaderLine(getKeyNames().get(0), VCFCompoundHeaderLine.UNBOUNDED, VCFHeaderLineType.Integer, \"Allelic depths for the ref and alt alleles in the order listed\")); }","id":42055,"modified_method":"public List<VCFFormatHeaderLine> getDescriptions() { return Arrays.asList(new VCFFormatHeaderLine(getKeyNames().get(0), VCFHeaderLineCount.UNBOUNDED, VCFHeaderLineType.Integer, \"Allelic depths for the ref and alt alleles in the order listed\")); }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"public List<VCFFormatHeaderLine> getDescriptions() {\r\n            return Arrays.asList(new VCFFormatHeaderLine(getKeyNames().get(0),\r\n                            1,\r\n                            VCFHeaderLineType.Integer,\r\n                            \"Total read depth per sample, including MQ0\"),\r\n                    new VCFFormatHeaderLine(getKeyNames().get(1),\r\n                            VCFCompoundHeaderLine.UNBOUNDED,\r\n                            VCFHeaderLineType.Float,\r\n                            \"Fractions of reads (excluding MQ0 from both ref and alt) supporting each reported alternative allele, per sample\"));\r\n        }","id":42056,"modified_method":"public List<VCFFormatHeaderLine> getDescriptions() {\r\n            return Arrays.asList(new VCFFormatHeaderLine(getKeyNames().get(0),\r\n                            1,\r\n                            VCFHeaderLineType.Integer,\r\n                            \"Total read depth per sample, including MQ0\"),\r\n                            new VCFFormatHeaderLine(getKeyNames().get(1),\r\n                            VCFHeaderLineCount.UNBOUNDED,\r\n                            VCFHeaderLineType.Float,\r\n                            \"Fractions of reads (excluding MQ0 from both ref and alt) supporting each reported alternative allele, per sample\"));\r\n        }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"public List<VCFInfoHeaderLine> getDescriptions() { return Arrays.asList(new VCFInfoHeaderLine(\"Samples\", VCFInfoHeaderLine.UNBOUNDED, VCFHeaderLineType.String, \"List of polymorphic samples\")); }","id":42057,"modified_method":"public List<VCFInfoHeaderLine> getDescriptions() { return Arrays.asList(new VCFInfoHeaderLine(\"Samples\", VCFHeaderLineCount.UNBOUNDED, VCFHeaderLineType.String, \"List of polymorphic samples\")); }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create the info string; assumes that no values are null\n     *\n     * @param infoFields a map of info fields\n     * @throws IOException for writer\n     */\n    private void writeInfoString(Map<String, String> infoFields) throws IOException {\n        if ( infoFields.isEmpty() ) {\n            mWriter.write(VCFConstants.EMPTY_INFO_FIELD);\n            return;\n        }\n\n        boolean isFirst = true;\n        for ( Map.Entry<String, String> entry : infoFields.entrySet() ) {\n            if ( isFirst )\n                isFirst = false;\n            else\n                mWriter.write(VCFConstants.INFO_FIELD_SEPARATOR);\n\n            String key = entry.getKey();\n            mWriter.write(key);\n\n            if ( !entry.getValue().equals(\"\") ) {\n                int numVals = 1;\n                VCFInfoHeaderLine metaData = mHeader.getInfoHeaderLine(key);\n                if ( metaData != null )\n                    numVals = metaData.getCount();\n\n                // take care of unbounded encoding\n                if ( numVals == VCFInfoHeaderLine.UNBOUNDED )\n                    numVals = 1;\n\n                if ( numVals > 0 ) {\n                    mWriter.write(\"=\");\n                    mWriter.write(entry.getValue());\n                }\n            }\n        }\n    }","id":42058,"modified_method":"/**\n     * create the info string; assumes that no values are null\n     *\n     * @param infoFields a map of info fields\n     * @throws IOException for writer\n     */\n    private void writeInfoString(Map<String, String> infoFields) throws IOException {\n        if ( infoFields.isEmpty() ) {\n            mWriter.write(VCFConstants.EMPTY_INFO_FIELD);\n            return;\n        }\n\n        boolean isFirst = true;\n        for ( Map.Entry<String, String> entry : infoFields.entrySet() ) {\n            if ( isFirst )\n                isFirst = false;\n            else\n                mWriter.write(VCFConstants.INFO_FIELD_SEPARATOR);\n\n            String key = entry.getKey();\n            mWriter.write(key);\n\n            if ( !entry.getValue().equals(\"\") ) {\n                int numVals = 1;\n                VCFInfoHeaderLine metaData = mHeader.getInfoHeaderLine(key);\n                if ( metaData != null && (metaData.getCountType() != VCFHeaderLineCount.INTEGER || metaData.getCount() > 0) ) {\n                    mWriter.write(\"=\");\n                    mWriter.write(entry.getValue());\n                }\n            }\n        }\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * add the genotype data\n     *\n     * @param vc                     the variant context\n     * @param genotypeFormatKeys  Genotype formatting string\n     * @param alleleMap              alleles for this context\n     * @throws IOException for writer\n     */\n    private void addGenotypeData(VariantContext vc, Map<Allele, String> alleleMap, List<String> genotypeFormatKeys)\n    throws IOException {\n\n        for ( String sample : mHeader.getGenotypeSamples() ) {\n            mWriter.write(VCFConstants.FIELD_SEPARATOR);\n\n            Genotype g = vc.getGenotype(sample);\n            if ( g == null ) {\n                // TODO -- The VariantContext needs to know what the general ploidy is of the samples\n                // TODO -- We shouldn't be assuming diploid genotypes here!\n                mWriter.write(VCFConstants.EMPTY_GENOTYPE);\n                continue;\n            }\n\n            writeAllele(g.getAllele(0), alleleMap);\n            for (int i = 1; i < g.getPloidy(); i++) {\n                mWriter.write(g.isPhased() ? VCFConstants.PHASED : VCFConstants.UNPHASED);\n                writeAllele(g.getAllele(i), alleleMap);\n            }\n\n            List<String> attrs = new ArrayList<String>(genotypeFormatKeys.size());\n            for ( String key : genotypeFormatKeys ) {\n                if ( key.equals(VCFConstants.GENOTYPE_KEY) )\n                    continue;\n\n                Object val = g.hasAttribute(key) ? g.getAttribute(key) : VCFConstants.MISSING_VALUE_v4;\n\n                // some exceptions\n                if ( key.equals(VCFConstants.GENOTYPE_QUALITY_KEY) ) {\n                    if ( Math.abs(g.getNegLog10PError() - Genotype.NO_NEG_LOG_10PERROR) < 1e-6)\n                        val = VCFConstants.MISSING_VALUE_v4;\n                    else {\n                        val = getQualValue(Math.min(g.getPhredScaledQual(), VCFConstants.MAX_GENOTYPE_QUAL));\n                    }\n                } else if ( key.equals(VCFConstants.GENOTYPE_FILTER_KEY) ) {\n                    val = g.isFiltered() ? ParsingUtils.join(\";\", ParsingUtils.sortList(g.getFilters())) : (g.filtersWereApplied() ? VCFConstants.PASSES_FILTERS_v4 : VCFConstants.UNFILTERED);\n                }\n\n                VCFFormatHeaderLine metaData = mHeader.getFormatHeaderLine(key);\n                if ( metaData != null ) {\n                    int numInFormatField = metaData.getCount();\n                    if ( numInFormatField > 1 && val.equals(VCFConstants.MISSING_VALUE_v4) ) {\n                        // If we have a missing field but multiple values are expected, we need to construct a new string with all fields.\n                        // For example, if Number=2, the string has to be \".,.\"\n                        StringBuilder sb = new StringBuilder(VCFConstants.MISSING_VALUE_v4);\n                        for ( int i = 1; i < numInFormatField; i++ ) {\n                            sb.append(\",\");\n                            sb.append(VCFConstants.MISSING_VALUE_v4);\n                        }\n                        val = sb.toString();\n                    }\n                }\n\n                // assume that if key is absent, then the given string encoding suffices\n                String outputValue = formatVCFField(val);\n                if ( outputValue != null )\n                    attrs.add(outputValue);\n            }\n\n            // strip off trailing missing values\n            for (int i = attrs.size()-1; i >= 0; i--) {\n                if ( isMissingValue(attrs.get(i)) )\n                    attrs.remove(i);\n                else\n                    break;\n            }\n\n            for (String s : attrs ) {\n                mWriter.write(VCFConstants.GENOTYPE_FIELD_SEPARATOR);\n                mWriter.write(s);\n            }\n        }\n    }","id":42059,"modified_method":"/**\n     * add the genotype data\n     *\n     * @param vc                     the variant context\n     * @param genotypeFormatKeys  Genotype formatting string\n     * @param alleleMap              alleles for this context\n     * @throws IOException for writer\n     */\n    private void addGenotypeData(VariantContext vc, Map<Allele, String> alleleMap, List<String> genotypeFormatKeys)\n    throws IOException {\n\n        for ( String sample : mHeader.getGenotypeSamples() ) {\n            mWriter.write(VCFConstants.FIELD_SEPARATOR);\n\n            Genotype g = vc.getGenotype(sample);\n            if ( g == null ) {\n                // TODO -- The VariantContext needs to know what the general ploidy is of the samples\n                // TODO -- We shouldn't be assuming diploid genotypes here!\n                mWriter.write(VCFConstants.EMPTY_GENOTYPE);\n                continue;\n            }\n\n            writeAllele(g.getAllele(0), alleleMap);\n            for (int i = 1; i < g.getPloidy(); i++) {\n                mWriter.write(g.isPhased() ? VCFConstants.PHASED : VCFConstants.UNPHASED);\n                writeAllele(g.getAllele(i), alleleMap);\n            }\n\n            List<String> attrs = new ArrayList<String>(genotypeFormatKeys.size());\n            for ( String key : genotypeFormatKeys ) {\n                if ( key.equals(VCFConstants.GENOTYPE_KEY) )\n                    continue;\n\n                Object val = g.hasAttribute(key) ? g.getAttribute(key) : VCFConstants.MISSING_VALUE_v4;\n\n                // some exceptions\n                if ( key.equals(VCFConstants.GENOTYPE_QUALITY_KEY) ) {\n                    if ( Math.abs(g.getNegLog10PError() - Genotype.NO_NEG_LOG_10PERROR) < 1e-6)\n                        val = VCFConstants.MISSING_VALUE_v4;\n                    else {\n                        val = getQualValue(Math.min(g.getPhredScaledQual(), VCFConstants.MAX_GENOTYPE_QUAL));\n                    }\n                } else if ( key.equals(VCFConstants.GENOTYPE_FILTER_KEY) ) {\n                    val = g.isFiltered() ? ParsingUtils.join(\";\", ParsingUtils.sortList(g.getFilters())) : (g.filtersWereApplied() ? VCFConstants.PASSES_FILTERS_v4 : VCFConstants.UNFILTERED);\n                }\n\n                VCFFormatHeaderLine metaData = mHeader.getFormatHeaderLine(key);\n                if ( metaData != null ) {\n                    int numInFormatField = metaData.getCount(vc.getAlternateAlleles().size());\n                    if ( numInFormatField > 1 && val.equals(VCFConstants.MISSING_VALUE_v4) ) {\n                        // If we have a missing field but multiple values are expected, we need to construct a new string with all fields.\n                        // For example, if Number=2, the string has to be \".,.\"\n                        StringBuilder sb = new StringBuilder(VCFConstants.MISSING_VALUE_v4);\n                        for ( int i = 1; i < numInFormatField; i++ ) {\n                            sb.append(\",\");\n                            sb.append(VCFConstants.MISSING_VALUE_v4);\n                        }\n                        val = sb.toString();\n                    }\n                }\n\n                // assume that if key is absent, then the given string encoding suffices\n                String outputValue = formatVCFField(val);\n                if ( outputValue != null )\n                    attrs.add(outputValue);\n            }\n\n            // strip off trailing missing values\n            for (int i = attrs.size()-1; i >= 0; i--) {\n                if ( isMissingValue(attrs.get(i)) )\n                    attrs.remove(i);\n                else\n                    break;\n            }\n\n            for (String s : attrs ) {\n                mWriter.write(VCFConstants.GENOTYPE_FIELD_SEPARATOR);\n                mWriter.write(s);\n            }\n        }\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void setNumberToUnbounded() { this.count = UNBOUNDED; }","id":42060,"modified_method":"public void setNumberToUnbounded() {\n        countType = VCFHeaderLineCount.UNBOUNDED;\n        count = -1;\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean equalsExcludingDescription(VCFCompoundHeaderLine other) {\n        return count == other.count &&\n                type == other.type &&\n                lineType == other.lineType &&\n                name.equals(other.name);\n    }","id":42061,"modified_method":"public boolean equalsExcludingDescription(VCFCompoundHeaderLine other) {\n        return count == other.count &&\n                countType == other.countType &&\n                type == other.type &&\n                lineType == other.lineType &&\n                name.equals(other.name);\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * returns true if we're equal to another compounder header line\n     * @param o a compound header line\n     * @return true if equal\n     */\n    public boolean equals(Object o) {\n        if ( !(o instanceof VCFCompoundHeaderLine) )\n            return false;\n        VCFCompoundHeaderLine other = (VCFCompoundHeaderLine)o;\n        return name.equals(other.name) &&\n                count == other.count &&\n                description.equals(other.description) &&\n                type == other.type &&\n                lineType == other.lineType;\n    }","id":42062,"modified_method":"/**\n     * returns true if we're equal to another compounder header line\n     * @param o a compound header line\n     * @return true if equal\n     */\n    public boolean equals(Object o) {\n        if ( !(o instanceof VCFCompoundHeaderLine) )\n            return false;\n        VCFCompoundHeaderLine other = (VCFCompoundHeaderLine)o;\n        return equalsExcludingDescription(other) &&\n                description.equals(other.description);\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create a VCF format header line\n     *\n     * @param name         the name for this header line\n     * @param count        the count for this header line\n     * @param type         the type for this header line\n     * @param description  the description for this header line\n     */\n    protected VCFCompoundHeaderLine(String name, int count, VCFHeaderLineType type, String description, SupportedHeaderLineType lineType) {\n        super(lineType.toString(), \"\");\n        this.name = name;\n        this.count = count;\n        this.type = type;\n        this.description = description;\n        this.lineType = lineType;\n        validate();\n    }","id":42063,"modified_method":"/**\n     * create a VCF format header line\n     *\n     * @param name         the name for this header line\n     * @param count        the count for this header line\n     * @param type         the type for this header line\n     * @param description  the description for this header line\n     */\n    protected VCFCompoundHeaderLine(String name, int count, VCFHeaderLineType type, String description, SupportedHeaderLineType lineType) {\n        super(lineType.toString(), \"\");\n        this.name = name;\n        this.countType = VCFHeaderLineCount.INTEGER;\n        this.count = count;\n        this.type = type;\n        this.description = description;\n        this.lineType = lineType;\n        validate();\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * make a string representation of this header line\n     * @return a string representation\n     */\n    protected String toStringEncoding() {\n        Map<String,Object> map = new LinkedHashMap<String,Object>();\n        map.put(\"ID\", name);\n        map.put(\"Number\", count == UNBOUNDED ? VCFConstants.UNBOUNDED_ENCODING_v4 : count);\n        map.put(\"Type\", type);\n        map.put(\"Description\", description);\n        return lineType.toString() + \"=\" + VCFHeaderLine.toStringEncoding(map);\n    }","id":42064,"modified_method":"/**\n     * make a string representation of this header line\n     * @return a string representation\n     */\n    protected String toStringEncoding() {\n        Map<String,Object> map = new LinkedHashMap<String,Object>();\n        map.put(\"ID\", name);\n        Object number;\n        switch ( countType ) {\n            case A: number = VCFConstants.PER_ALLELE_COUNT; break;\n            case G: number = VCFConstants.PER_GENOTYPE_COUNT; break;\n            case UNBOUNDED: number = VCFConstants.UNBOUNDED_ENCODING_v4; break;\n            case INTEGER:\n            default: number = count;\n        }\n        map.put(\"Number\", number);\n        map.put(\"Type\", type);\n        map.put(\"Description\", description);\n        return lineType.toString() + \"=\" + VCFHeaderLine.toStringEncoding(map);\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getCount() { return count; }","id":42065,"modified_method":"public int getCount() {\n        if ( countType != VCFHeaderLineCount.INTEGER )\n            throw new ReviewedStingException(\"Asking for header line count when type is not an integer\");\n        return count;\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create a VCF format header line\n     *\n     * @param line   the header line\n     * @param version      the VCF header version\n     *\n     */\n    protected VCFCompoundHeaderLine(String line, VCFHeaderVersion version, SupportedHeaderLineType lineType) {\n        super(lineType.toString(), \"\");\n        Map<String,String> mapping = VCFHeaderLineTranslator.parseLine(version,line, Arrays.asList(\"ID\",\"Number\",\"Type\",\"Description\"));\n        name = mapping.get(\"ID\");\n        count = (version == VCFHeaderVersion.VCF4_0 || version == VCFHeaderVersion.VCF4_1) ?\n                        mapping.get(\"Number\").equals(VCFConstants.UNBOUNDED_ENCODING_v4) ? UNBOUNDED : Integer.valueOf(mapping.get(\"Number\")) :\n                        mapping.get(\"Number\").equals(VCFConstants.UNBOUNDED_ENCODING_v3) ? UNBOUNDED : Integer.valueOf(mapping.get(\"Number\"));\n        type = VCFHeaderLineType.valueOf(mapping.get(\"Type\"));\n        if (type == VCFHeaderLineType.Flag && !allowFlagValues())\n            throw new IllegalArgumentException(\"Flag is an unsupported type for this kind of field\");\n\n        description = mapping.get(\"Description\");\n        if ( description == null && ALLOW_UNBOUND_DESCRIPTIONS ) // handle the case where there's no description provided\n            description = UNBOUND_DESCRIPTION;\n        \n        this.lineType = lineType;\n\n        validate();\n    }","id":42066,"modified_method":"/**\n     * create a VCF format header line\n     *\n     * @param line   the header line\n     * @param version      the VCF header version\n     *\n     */\n    protected VCFCompoundHeaderLine(String line, VCFHeaderVersion version, SupportedHeaderLineType lineType) {\n        super(lineType.toString(), \"\");\n        Map<String,String> mapping = VCFHeaderLineTranslator.parseLine(version,line, Arrays.asList(\"ID\",\"Number\",\"Type\",\"Description\"));\n        name = mapping.get(\"ID\");\n        count = -1;\n        final String numberStr = mapping.get(\"Number\");\n        if ( numberStr.equals(VCFConstants.PER_ALLELE_COUNT) ) {\n            countType = VCFHeaderLineCount.A;\n        } else if ( numberStr.equals(VCFConstants.PER_GENOTYPE_COUNT) ) {\n            countType = VCFHeaderLineCount.G;\n        } else if ( ((version == VCFHeaderVersion.VCF4_0 || version == VCFHeaderVersion.VCF4_1) &&\n                     numberStr.equals(VCFConstants.UNBOUNDED_ENCODING_v4)) ||\n                    ((version == VCFHeaderVersion.VCF3_2 || version == VCFHeaderVersion.VCF3_3) &&\n                     numberStr.equals(VCFConstants.UNBOUNDED_ENCODING_v3)) ) {\n            countType = VCFHeaderLineCount.UNBOUNDED;\n        } else {\n            countType = VCFHeaderLineCount.INTEGER;\n            count = Integer.valueOf(numberStr);\n\n        }\n        type = VCFHeaderLineType.valueOf(mapping.get(\"Type\"));\n        if (type == VCFHeaderLineType.Flag && !allowFlagValues())\n            throw new IllegalArgumentException(\"Flag is an unsupported type for this kind of field\");\n\n        description = mapping.get(\"Description\");\n        if ( description == null && ALLOW_UNBOUND_DESCRIPTIONS ) // handle the case where there's no description provided\n            description = UNBOUND_DESCRIPTION;\n        \n        this.lineType = lineType;\n\n        validate();\n    }","commit_id":"e3748675dbd518042ad67cfc653c7f1a5f89b327","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void visitKeyword(PsiKeyword keyword) {\n      super.visitKeyword(keyword);\n      if (isOnTheFly() && isAcceptable(keyword)) {\n        registerError(keyword);\n      }\n    }","id":42067,"modified_method":"@Override\n    public void visitKeyword(PsiKeyword keyword) {\n      super.visitKeyword(keyword);\n      if (isOnTheFly() && keyword.getTokenType() == JavaTokenType.TRY_KEYWORD && isAcceptable(keyword)) {\n        registerError(keyword);\n      }\n    }","commit_id":"25d0004b85491a78f7c46295fa486cafc88c23ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitKeyword(PsiKeyword keyword) {\n      super.visitKeyword(keyword);\n      if (isOnTheFly() && isAcceptable(keyword)) {\n        registerError(keyword);\n      }\n    }","id":42068,"modified_method":"@Override\n    public void visitKeyword(PsiKeyword keyword) {\n      super.visitKeyword(keyword);\n      if (isOnTheFly() && keyword.getTokenType() == JavaTokenType.CATCH_KEYWORD && isAcceptable(keyword)) {\n        registerError(keyword);\n      }\n    }","commit_id":"9d0ff8ca2c2cd2e9291a4026f5b7f2f1a948ee30","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletions(CompletionParameters parameters, final CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    if (PsiTreeUtil.getParentOfType(position, PsiComment.class, false) != null) {\n      return;\n    }\n\n    PsiStatement statement = PsiTreeUtil.getParentOfType(position, PsiExpressionStatement.class);\n    if (statement == null) {\n      statement = PsiTreeUtil.getParentOfType(position, PsiDeclarationStatement.class);\n    }\n    if (statement != null && statement.getTextRange().getStartOffset() == position.getTextRange().getStartOffset()) {\n      if (!psiElement().withSuperParent(2, PsiSwitchStatement.class).accepts(statement)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n      }\n    }\n\n    if (isStatementPosition(position)) {\n      if (INSIDE_SWITCH.isAcceptable(position, position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.CASE), TailType.SPACE));\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.DEFAULT), TailType.CASE_COLON));\n        return;\n      }\n\n      addBreakContinue(result, position);\n      addStatementKeywords(result, position);\n    }\n\n    if (SUPER_OR_THIS_PATTERN.accepts(position)) {\n      if (!AFTER_DOT.accepts(position) || isInsideQualifierClass(position)) {\n        result.addElement(createKeyword(position, PsiKeyword.THIS));\n\n        final LookupItem superItem = (LookupItem)createKeyword(position, PsiKeyword.SUPER);\n        if (psiElement().afterLeaf(psiElement().withText(\"{\").withSuperParent(2, psiMethod().constructor(true))).accepts(position)) {\n          final PsiMethod method = PsiTreeUtil.getParentOfType(position, PsiMethod.class, false, PsiClass.class);\n          assert method != null;\n          final boolean hasParams = superConstructorHasParameters(method);\n          superItem.setInsertHandler(new ParenthesesInsertHandler<LookupElement>() {\n            @Override\n            protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {\n              return hasParams;\n            }\n\n            @Override\n            public void handleInsert(InsertionContext context, LookupElement item) {\n              super.handleInsert(context, item);\n              TailType.insertChar(context.getEditor(), context.getTailOffset(), ';');\n            }\n          });\n        }\n\n        result.addElement(superItem);\n      }\n    }\n\n    if (EXPR_KEYWORDS.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.NEW), TailType.SPACE));\n      result.addElement(createKeyword(position, PsiKeyword.NULL));\n      result.addElement(createKeyword(position, PsiKeyword.TRUE));\n      result.addElement(createKeyword(position, PsiKeyword.FALSE));\n    }\n\n    if (INSIDE_PARAMETER_LIST.accepts(position) && !psiElement().afterLeaf(PsiKeyword.FINAL).accepts(position) && !AFTER_DOT.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n    }\n\n    if (CLASS_START.isAcceptable(position, position)) {\n      for (String s : ModifierChooser.getKeywords(position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, s), TailType.SPACE));\n      }\n    }\n\n    addPrimitiveTypes(result, position);\n\n    if (isAfterTypeDot(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n\n    addUnfinishedMethodTypeParameters(position, result);\n\n    if (JavaSmartCompletionContributor.INSIDE_EXPRESSION.accepts(position) &&\n        !BasicExpressionCompletionContributor.AFTER_DOT.accepts(position) &&\n        !(position.getParent() instanceof PsiLiteralExpression) &&\n        !(position.getParent().getParent() instanceof PsiSwitchLabelStatement)) {\n      for (final ExpectedTypeInfo info : JavaSmartCompletionContributor.getExpectedTypes(parameters)) {\n        new JavaMembersGetter(info.getDefaultType()).addMembers(position, parameters.getInvocationCount() > 0, new Consumer<LookupElement>() {\n          @Override\n          public void consume(LookupElement element) {\n            result.addElement(element);\n          }\n        });\n      }\n    }\n  }","id":42069,"modified_method":"@Override\n  public void fillCompletions(CompletionParameters parameters, final CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    if (PsiTreeUtil.getParentOfType(position, PsiComment.class, false) != null) {\n      return;\n    }\n\n    PsiStatement statement = PsiTreeUtil.getParentOfType(position, PsiExpressionStatement.class);\n    if (statement == null) {\n      statement = PsiTreeUtil.getParentOfType(position, PsiDeclarationStatement.class);\n    }\n    if (statement != null && statement.getTextRange().getStartOffset() == position.getTextRange().getStartOffset()) {\n      if (!psiElement().withSuperParent(2, PsiSwitchStatement.class).accepts(statement)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n      }\n    }\n\n    if (isStatementPosition(position)) {\n      if (INSIDE_SWITCH.isAcceptable(position, position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.CASE), TailType.SPACE));\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.DEFAULT), TailType.CASE_COLON));\n        return;\n      }\n\n      addBreakContinue(result, position);\n      addStatementKeywords(result, position);\n    }\n\n    if (SUPER_OR_THIS_PATTERN.accepts(position)) {\n      if (!AFTER_DOT.accepts(position) || isInsideQualifierClass(position)) {\n        result.addElement(createKeyword(position, PsiKeyword.THIS));\n\n        final LookupItem superItem = (LookupItem)createKeyword(position, PsiKeyword.SUPER);\n        if (psiElement().afterLeaf(psiElement().withText(\"{\").withSuperParent(2, psiMethod().constructor(true))).accepts(position)) {\n          final PsiMethod method = PsiTreeUtil.getParentOfType(position, PsiMethod.class, false, PsiClass.class);\n          assert method != null;\n          final boolean hasParams = superConstructorHasParameters(method);\n          superItem.setInsertHandler(new ParenthesesInsertHandler<LookupElement>() {\n            @Override\n            protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {\n              return hasParams;\n            }\n\n            @Override\n            public void handleInsert(InsertionContext context, LookupElement item) {\n              super.handleInsert(context, item);\n              TailType.insertChar(context.getEditor(), context.getTailOffset(), ';');\n            }\n          });\n        }\n\n        result.addElement(superItem);\n      }\n    }\n\n    if (EXPR_KEYWORDS.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.NEW), TailType.SPACE));\n      result.addElement(createKeyword(position, PsiKeyword.NULL));\n      result.addElement(createKeyword(position, PsiKeyword.TRUE));\n      result.addElement(createKeyword(position, PsiKeyword.FALSE));\n    }\n\n    if (INSIDE_PARAMETER_LIST.accepts(position) && !psiElement().afterLeaf(PsiKeyword.FINAL).accepts(position) && !AFTER_DOT.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n    }\n\n    if (CLASS_START.isAcceptable(position, position) &&\n        PsiTreeUtil.getNonStrictParentOfType(position, PsiLiteralExpression.class, PsiComment.class) == null) {\n      for (String s : ModifierChooser.getKeywords(position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, s), TailType.SPACE));\n      }\n    }\n\n    addPrimitiveTypes(result, position);\n\n    if (isAfterTypeDot(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n\n    addUnfinishedMethodTypeParameters(position, result);\n\n    if (JavaSmartCompletionContributor.INSIDE_EXPRESSION.accepts(position) &&\n        !BasicExpressionCompletionContributor.AFTER_DOT.accepts(position) &&\n        !(position.getParent() instanceof PsiLiteralExpression) &&\n        !(position.getParent().getParent() instanceof PsiSwitchLabelStatement)) {\n      for (final ExpectedTypeInfo info : JavaSmartCompletionContributor.getExpectedTypes(parameters)) {\n        new JavaMembersGetter(info.getDefaultType()).addMembers(position, parameters.getInvocationCount() > 0, new Consumer<LookupElement>() {\n          @Override\n          public void consume(LookupElement element) {\n            result.addElement(element);\n          }\n        });\n      }\n    }\n  }","commit_id":"2e53f7484b07f97eb0588bfb53ab3a4564cbbe79","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addLookupItem(Set<LookupElement> set, final TailType tailType, @NotNull Object completion, final PsiFile file, final CompletionVariant variant) {\n    if (completion instanceof LookupElement && !(completion instanceof LookupItem)) {\n      set.add((LookupElement)completion);\n      return;\n    }\n\n    LookupElement _ret = LookupItemUtil.objectToLookupItem(completion);\n    if(_ret == null || !(_ret instanceof LookupItem)) return;\n\n    LookupItem ret = (LookupItem)_ret;\n    final InsertHandler insertHandler = variant.getInsertHandler();\n    if(insertHandler != null && ret.getInsertHandler() == null) {\n    }\n    ret.setInsertHandler(new InsertHandler<LookupElement>() {\n      @Override\n      public void handleInsert(InsertionContext context, LookupElement item) {\n        if (context.shouldAddCompletionChar()) {\n          return;\n        }\n        TailType type = analyzeItem(item.getObject(), context.getFile().findElementAt(context.getStartOffset()));\n        if (type == TailType.NONE) {\n          type = tailType;\n        }\n        //new DefaultInsertHandler().handleInsert(context, item);\n        if (type != TailType.NONE) {\n          type.processTail(context.getEditor(), context.getTailOffset());\n        }\n      }\n    });\n\n    final Map<Object, Object> itemProperties = variant.getItemProperties();\n    for (final Object key : itemProperties.keySet()) {\n      ret.setAttribute(key, itemProperties.get(key));\n    }\n\n    set.add(ret);\n  }","id":42070,"modified_method":"protected void addLookupItem(Set<LookupElement> set, final TailType tailType, @NotNull Object completion, final PsiFile file, final CompletionVariant variant) {\n    if (completion instanceof LookupElement && !(completion instanceof LookupItem)) {\n      set.add((LookupElement)completion);\n      return;\n    }\n\n    LookupElement _ret = LookupItemUtil.objectToLookupItem(completion);\n    if(_ret == null || !(_ret instanceof LookupItem)) return;\n\n    LookupItem ret = (LookupItem)_ret;\n    final InsertHandler insertHandler = variant.getInsertHandler();\n    if(insertHandler != null && ret.getInsertHandler() == null) {\n    }\n    ret.setInsertHandler(new InsertHandler<LookupElement>() {\n      @Override\n      public void handleInsert(InsertionContext context, LookupElement item) {\n        if (context.shouldAddCompletionChar()) {\n          return;\n        }\n        if (tailType != TailType.NONE) {\n          tailType.processTail(context.getEditor(), context.getTailOffset());\n        }\n      }\n    });\n\n    final Map<Object, Object> itemProperties = variant.getItemProperties();\n    for (final Object key : itemProperties.keySet()) {\n      ret.setAttribute(key, itemProperties.get(key));\n    }\n\n    set.add(ret);\n  }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initVariantsInMethodScope() {\n// Completion for classes in method throws section\n// position\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\")\"),\n        new ParentElementFilter(new ClassFilter(PsiParameterList.class))));\n\n// completion\n      CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiClass.class); // for throws on separate line\n      variant.addCompletion(PsiKeyword.THROWS);\n\n      registerVariant(variant);\n\n//in annotation methods\n      variant = new CompletionVariant(PsiAnnotationMethod.class, position);\n      variant.addCompletion(PsiKeyword.DEFAULT);\n      registerVariant(variant);\n    }\n\n    {\n// completion for declarations\n      final CompletionVariant variant = new CompletionVariant(new OrFilter(END_OF_BLOCK, new LeftNeighbour(new TextFilter(PsiKeyword.FINAL))));\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      addPrimitiveTypes(variant, CompletionVariant.DEFAULT_TAIL_TYPE);\n      variant.addCompletion(PsiKeyword.CLASS);\n      registerVariant(variant);\n    }\n\n    {\n// instanceof keyword\n      final ElementFilter position = INSTANCEOF_PLACE;\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.includeScopeClass(PsiMethod.class);\n      variant.addCompletion(PsiKeyword.INSTANCEOF);\n\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in start of declaration\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, END_OF_BLOCK);\n      addKeywords(variant);\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in returns  !!!!\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new TextFilter(PsiKeyword.RETURN)));\n      variant.addCompletion(PsiKeyword.TRUE, TailType.NONE);\n      variant.addCompletion(PsiKeyword.FALSE, TailType.NONE);\n      registerVariant(variant);\n    }\n\n\n// Catch/Finally completion\n    {\n      final ElementFilter position = AFTER_TRY_BLOCK;\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, true);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      registerVariant(variant);\n    }\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new NotFilter(new TextFilter(PsiKeyword.TRY))),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n            new ParentElementFilter(new ClassFilter(PsiCatchSection.class)))\n          ))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      registerVariant(variant);\n    }\n\n// Completion for else expression\n// completion\n    {\n      final ElementFilter position = new LeftNeighbour(\n        new OrFilter(\n          new AndFilter(new TextFilter(\"}\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 3)),\n          new AndFilter(new TextFilter(\";\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 2))\n        ));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.addCompletion(PsiKeyword.ELSE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(INSIDE_SWITCH);\n      variant.includeScopeClass(PsiElement.class, true);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, TailType.CASE_COLON);\n      registerVariant(variant);\n    }\n  }","id":42071,"modified_method":"private void initVariantsInMethodScope() {\n// Completion for classes in method throws section\n// position\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\")\"),\n        new ParentElementFilter(new ClassFilter(PsiParameterList.class))));\n\n// completion\n      CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiClass.class); // for throws on separate line\n      variant.addCompletion(PsiKeyword.THROWS);\n\n      registerVariant(variant);\n\n//in annotation methods\n      variant = new CompletionVariant(PsiAnnotationMethod.class, position);\n      variant.addCompletion(PsiKeyword.DEFAULT);\n      registerVariant(variant);\n    }\n\n    {\n// instanceof keyword\n      final ElementFilter position = INSTANCEOF_PLACE;\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.includeScopeClass(PsiMethod.class);\n      variant.addCompletion(PsiKeyword.INSTANCEOF);\n\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in returns  !!!!\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new TextFilter(PsiKeyword.RETURN)));\n      variant.addCompletion(PsiKeyword.TRUE, TailType.NONE);\n      variant.addCompletion(PsiKeyword.FALSE, TailType.NONE);\n      registerVariant(variant);\n    }\n\n\n// Catch/Finally completion\n    {\n      final ElementFilter position = AFTER_TRY_BLOCK;\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, true);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      registerVariant(variant);\n    }\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new NotFilter(new TextFilter(PsiKeyword.TRY))),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n            new ParentElementFilter(new ClassFilter(PsiCatchSection.class)))\n          ))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      variant.addCompletion(PsiKeyword.CATCH, TailTypes.CATCH_LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, TailTypes.FINALLY_LBRACE);\n      registerVariant(variant);\n    }\n\n// Completion for else expression\n// completion\n    {\n      final ElementFilter position = new LeftNeighbour(\n        new OrFilter(\n          new AndFilter(new TextFilter(\"}\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 3)),\n          new AndFilter(new TextFilter(\";\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 2))\n        ));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.addCompletion(PsiKeyword.ELSE);\n\n      registerVariant(variant);\n    }\n\n  }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected TailType computeTailType(InsertionContext context) {\n      return context.shouldAddCompletionChar() ? TailType.NONE : TailType.SPACE;\n    }","id":42072,"modified_method":"@Override\n    protected TailType computeTailType(InsertionContext context) {\n      return context.shouldAddCompletionChar() ? TailType.NONE : myTail;\n    }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletions(CompletionParameters parameters, final CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    if (PsiTreeUtil.getParentOfType(position, PsiComment.class, false) != null) {\n      return;\n    }\n\n    PsiStatement statement = PsiTreeUtil.getParentOfType(position, PsiExpressionStatement.class);\n    if (statement == null) {\n      statement = PsiTreeUtil.getParentOfType(position, PsiDeclarationStatement.class);\n    }\n    if (statement != null && statement.getTextRange().getStartOffset() == position.getTextRange().getStartOffset()) {\n      if (!psiElement().withSuperParent(2, PsiSwitchStatement.class).accepts(statement)) {\n        result.addElement(createKeyword(position, PsiKeyword.FINAL));\n      }\n    }\n    \n    if (isStatementPosition(position) && !INSIDE_SWITCH.isAcceptable(position, position)) {\n      addBreakContinue(result, position);\n    }\n\n    if (SUPER_OR_THIS_PATTERN.accepts(position)) {\n      if (!AFTER_DOT.accepts(position) || isInsideQualifierClass(position)) {\n        result.addElement(createKeyword(position, PsiKeyword.THIS));\n\n        final LookupItem superItem = (LookupItem)createKeyword(position, PsiKeyword.SUPER);\n        if (psiElement().afterLeaf(psiElement().withText(\"{\").withSuperParent(2, psiMethod().constructor(true))).accepts(position)) {\n          final PsiMethod method = PsiTreeUtil.getParentOfType(position, PsiMethod.class, false, PsiClass.class);\n          assert method != null;\n          final boolean hasParams = superConstructorHasParameters(method);\n          superItem.setInsertHandler(new ParenthesesInsertHandler<LookupElement>() {\n            @Override\n            protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {\n              return hasParams;\n            }\n\n            @Override\n            public void handleInsert(InsertionContext context, LookupElement item) {\n              super.handleInsert(context, item);\n              TailType.insertChar(context.getEditor(), context.getTailOffset(), ';');\n            }\n          });\n        }\n\n        result.addElement(superItem);\n      }\n    }\n\n    final ElementPattern<PsiElement> exprKeywords = and(\n      psiElement().withParent(psiElement(PsiReferenceExpression.class).withParent(\n        not(\n          or(psiElement(PsiTypeCastExpression.class),\n             psiElement(PsiSwitchLabelStatement.class),\n             psiElement(PsiExpressionStatement.class)\n          )\n        )\n      )),\n      not(psiElement().afterLeaf(\".\"))\n    );\n    if (exprKeywords.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.NEW), TailType.SPACE));\n      result.addElement(createKeyword(position, PsiKeyword.NULL));\n      result.addElement(createKeyword(position, PsiKeyword.TRUE));\n      result.addElement(createKeyword(position, PsiKeyword.FALSE));\n    }\n\n    addPrimitiveTypes(result, position);\n\n    if (isAfterTypeDot(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n\n    addUnfinishedMethodTypeParameters(position, result);\n\n    if (JavaSmartCompletionContributor.INSIDE_EXPRESSION.accepts(position) &&\n        !BasicExpressionCompletionContributor.AFTER_DOT.accepts(position) &&\n        !(position.getParent() instanceof PsiLiteralExpression) &&\n        !(position.getParent().getParent() instanceof PsiSwitchLabelStatement)) {\n      for (final ExpectedTypeInfo info : JavaSmartCompletionContributor.getExpectedTypes(parameters)) {\n        new JavaMembersGetter(info.getDefaultType()).addMembers(position, new Consumer<LookupElement>() {\n          @Override\n          public void consume(LookupElement element) {\n            result.addElement(element);\n          }\n        });\n      }\n    }\n  }","id":42073,"modified_method":"@Override\n  public void fillCompletions(CompletionParameters parameters, final CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    if (PsiTreeUtil.getParentOfType(position, PsiComment.class, false) != null) {\n      return;\n    }\n\n    PsiStatement statement = PsiTreeUtil.getParentOfType(position, PsiExpressionStatement.class);\n    if (statement == null) {\n      statement = PsiTreeUtil.getParentOfType(position, PsiDeclarationStatement.class);\n    }\n    if (statement != null && statement.getTextRange().getStartOffset() == position.getTextRange().getStartOffset()) {\n      if (!psiElement().withSuperParent(2, PsiSwitchStatement.class).accepts(statement)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n      }\n    }\n    \n    if (isStatementPosition(position)) {\n      if (INSIDE_SWITCH.isAcceptable(position, position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.CASE), TailType.SPACE));\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.DEFAULT), TailType.CASE_COLON));\n        return;\n      }\n\n      addBreakContinue(result, position);\n      addStatementKeywords(result, position);\n    }\n\n    if (SUPER_OR_THIS_PATTERN.accepts(position)) {\n      if (!AFTER_DOT.accepts(position) || isInsideQualifierClass(position)) {\n        result.addElement(createKeyword(position, PsiKeyword.THIS));\n\n        final LookupItem superItem = (LookupItem)createKeyword(position, PsiKeyword.SUPER);\n        if (psiElement().afterLeaf(psiElement().withText(\"{\").withSuperParent(2, psiMethod().constructor(true))).accepts(position)) {\n          final PsiMethod method = PsiTreeUtil.getParentOfType(position, PsiMethod.class, false, PsiClass.class);\n          assert method != null;\n          final boolean hasParams = superConstructorHasParameters(method);\n          superItem.setInsertHandler(new ParenthesesInsertHandler<LookupElement>() {\n            @Override\n            protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {\n              return hasParams;\n            }\n\n            @Override\n            public void handleInsert(InsertionContext context, LookupElement item) {\n              super.handleInsert(context, item);\n              TailType.insertChar(context.getEditor(), context.getTailOffset(), ';');\n            }\n          });\n        }\n\n        result.addElement(superItem);\n      }\n    }\n\n    final ElementPattern<PsiElement> exprKeywords = and(\n      psiElement().withParent(psiElement(PsiReferenceExpression.class).withParent(\n        not(\n          or(psiElement(PsiTypeCastExpression.class),\n             psiElement(PsiSwitchLabelStatement.class),\n             psiElement(PsiExpressionStatement.class)\n          )\n        )\n      )),\n      not(psiElement().afterLeaf(\".\"))\n    );\n    if (exprKeywords.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.NEW), TailType.SPACE));\n      result.addElement(createKeyword(position, PsiKeyword.NULL));\n      result.addElement(createKeyword(position, PsiKeyword.TRUE));\n      result.addElement(createKeyword(position, PsiKeyword.FALSE));\n    }\n\n    addPrimitiveTypes(result, position);\n\n    if (isAfterTypeDot(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n\n    addUnfinishedMethodTypeParameters(position, result);\n\n    if (JavaSmartCompletionContributor.INSIDE_EXPRESSION.accepts(position) &&\n        !BasicExpressionCompletionContributor.AFTER_DOT.accepts(position) &&\n        !(position.getParent() instanceof PsiLiteralExpression) &&\n        !(position.getParent().getParent() instanceof PsiSwitchLabelStatement)) {\n      for (final ExpectedTypeInfo info : JavaSmartCompletionContributor.getExpectedTypes(parameters)) {\n        new JavaMembersGetter(info.getDefaultType()).addMembers(position, new Consumer<LookupElement>() {\n          @Override\n          public void consume(LookupElement element) {\n            result.addElement(element);\n          }\n        });\n      }\n    }\n  }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isStatementPosition(PsiElement position) {\n    if (END_OF_BLOCK.isAcceptable(position, position)) {\n      return true;\n    }\n\n    if (psiElement().withParents(PsiReferenceExpression.class, PsiExpressionStatement.class, PsiIfStatement.class).accepts(position)) {\n      PsiElement stmt = position.getParent().getParent();\n      PsiIfStatement ifStatement = (PsiIfStatement)stmt.getParent();\n      if (ifStatement.getElseBranch() == stmt || ifStatement.getThenBranch() == stmt) {\n        return true;\n      }\n    }\n    \n    return false;\n  }","id":42074,"modified_method":"private static boolean isStatementPosition(PsiElement position) {\n    if (PsiTreeUtil.getNonStrictParentOfType(position, PsiLiteralExpression.class, PsiComment.class) != null) {\n      return false;\n    }\n\n    if (psiElement().withSuperParent(2, PsiConditionalExpression.class).accepts(position)) {\n      return false;\n    }\n\n    if (END_OF_BLOCK.isAcceptable(position, position) &&\n        PsiTreeUtil.getParentOfType(position, PsiCodeBlock.class, true, PsiMember.class) != null) {\n      return true;\n    }\n\n    if (psiElement().withParents(PsiReferenceExpression.class, PsiExpressionStatement.class, PsiIfStatement.class).accepts(position)) {\n      PsiElement stmt = position.getParent().getParent();\n      PsiIfStatement ifStatement = (PsiIfStatement)stmt.getParent();\n      if (ifStatement.getElseBranch() == stmt || ifStatement.getThenBranch() == stmt) {\n        return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addPrimitiveTypes(CompletionResultSet result, PsiElement position) {\n    new LeftNeighbour(new AndFilter(\n            new TextFilter(\"(\"),\n            new ParentElementFilter(new OrFilter(\n              new ClassFilter(PsiParenthesizedExpression.class),\n              new ClassFilter(PsiTypeCastExpression.class)))));\n\n    boolean inCast = psiElement()\n      .afterLeaf(psiElement().withText(\"(\").withParent(psiElement(PsiParenthesizedExpression.class, PsiTypeCastExpression.class)))\n      .accepts(position);\n\n    boolean declaration = DECLARATION_START.isAcceptable(position, position) ||\n                          psiElement().withParents(PsiJavaCodeReferenceElement.class, PsiTypeElement.class, PsiMember.class).accepts(position) ||\n                          psiElement().withParents(PsiJavaCodeReferenceElement.class, PsiTypeElement.class, PsiClassLevelDeclarationStatement.class).accepts(position);\n    if (START_FOR.accepts(position) ||\n        INSIDE_PARAMETER_LIST.accepts(position) && !AFTER_DOT.accepts(position) ||\n        VARIABLE_AFTER_FINAL.accepts(position) ||\n        inCast ||\n        declaration) {\n      for (String primitiveType : PRIMITIVE_TYPES) {\n        LookupElement keyword = createKeyword(position, primitiveType);\n        result.addElement(inCast ? keyword : new OverrideableSpace(keyword));\n      }\n    }\n    if (declaration) {\n      result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.VOID)));\n    }\n  }","id":42075,"modified_method":"private static void addPrimitiveTypes(CompletionResultSet result, PsiElement position) {\n    boolean inCast = psiElement()\n      .afterLeaf(psiElement().withText(\"(\").withParent(psiElement(PsiParenthesizedExpression.class, PsiTypeCastExpression.class)))\n      .accepts(position);\n\n    boolean declaration = DECLARATION_START.isAcceptable(position, position) ||\n                          psiElement().withParents(PsiJavaCodeReferenceElement.class, PsiTypeElement.class, PsiMember.class).accepts(position) ||\n                          psiElement().withParents(PsiJavaCodeReferenceElement.class, PsiTypeElement.class, PsiClassLevelDeclarationStatement.class).accepts(position);\n    if (START_FOR.accepts(position) ||\n        INSIDE_PARAMETER_LIST.accepts(position) && !AFTER_DOT.accepts(position) ||\n        VARIABLE_AFTER_FINAL.accepts(position) ||\n        inCast ||\n        declaration ||\n        isStatementPosition(position)) {\n      for (String primitiveType : PRIMITIVE_TYPES) {\n        LookupElement keyword = createKeyword(position, primitiveType);\n        result.addElement(inCast ? keyword : new OverrideableSpace(keyword, TailType.SPACE));\n      }\n    }\n    if (declaration) {\n      result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.VOID), TailType.SPACE));\n    }\n  }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OverrideableSpace(LookupElement keyword) {\n      super(keyword);\n    }","id":42076,"modified_method":"public OverrideableSpace(LookupElement keyword, TailType tail) {\n      super(keyword);\n      myTail = tail;\n    }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String[] getKeywords(CompletionContext context, PsiElement position){\n    final List<String> ret = new ArrayList<String>();\n    try{\n      PsiElement scope;\n\n      if(position == null)\n        scope = context.file;\n      else\n        scope = position.getParent();\n\n      final PsiModifierList list = getModifierList(position);\n\nscopes:\n      while (scope != null) {\n        for (final Object o : myMap.keySet()) {\n          final ElementFilter filter = (ElementFilter)o;\n          if (filter.isClassAcceptable(scope.getClass()) && filter.isAcceptable(scope, scope.getParent())) {\n            final String[][] keywordSets = myMap.get(filter);\n            for (int i = 0; i < keywordSets.length; i++) {\n              final String[] keywords = keywordSets[keywordSets.length - i - 1];\n              boolean containModifierFlag = false;\n              if (list != null) {\n                for (@Modifier String keyword : keywords) {\n                  if (list.hasExplicitModifier(keyword)) {\n                    containModifierFlag = true;\n                    break;\n                  }\n                }\n              }\n              if (!containModifierFlag) {\n                ContainerUtil.addAll(ret, keywords);\n              }\n            }\n            break scopes;\n          }\n        }\n        scope = scope.getParent();\n        if (scope instanceof JspClassLevelDeclarationStatement) {\n          scope = scope.getContext();\n        }\n        if (scope instanceof PsiDirectory) break;\n      }\n    }\n    catch(Exception e){}\n    return ArrayUtil.toStringArray(ret);\n  }","id":42077,"modified_method":"public String[] getKeywords(CompletionContext context, PsiElement position) {\n    if (JavaCompletionData.INSIDE_SWITCH.isAcceptable(position, position)) {\n      return ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    final List<String> ret = new ArrayList<String>();\n    try {\n      PsiElement scope;\n\n      if (position == null) {\n        scope = context.file;\n      }\n      else {\n        scope = position.getParent();\n      }\n\n      final PsiModifierList list = getModifierList(position);\n\n      scopes:\n      while (scope != null) {\n        for (final Object o : myMap.keySet()) {\n          final ElementFilter filter = (ElementFilter)o;\n          if (filter.isClassAcceptable(scope.getClass()) && filter.isAcceptable(scope, scope.getParent())) {\n            final String[][] keywordSets = myMap.get(filter);\n            for (int i = 0; i < keywordSets.length; i++) {\n              final String[] keywords = keywordSets[keywordSets.length - i - 1];\n              boolean containModifierFlag = false;\n              if (list != null) {\n                for (@Modifier String keyword : keywords) {\n                  if (list.hasExplicitModifier(keyword)) {\n                    containModifierFlag = true;\n                    break;\n                  }\n                }\n              }\n              if (!containModifierFlag) {\n                ContainerUtil.addAll(ret, keywords);\n              }\n            }\n            break scopes;\n          }\n        }\n        scope = scope.getParent();\n        if (scope instanceof JspClassLevelDeclarationStatement) {\n          scope = scope.getContext();\n        }\n        if (scope instanceof PsiDirectory) break;\n      }\n    }\n    catch (Exception e) {\n    }\n    return ArrayUtil.toStringArray(ret);\n  }","commit_id":"5f4f51af4849901ed0851bd868ffed888d31c9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletions(CompletionParameters parameters, final CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    if (PsiTreeUtil.getParentOfType(position, PsiComment.class, false) != null) {\n      return;\n    }\n\n    PsiStatement statement = PsiTreeUtil.getParentOfType(position, PsiExpressionStatement.class);\n    if (statement == null) {\n      statement = PsiTreeUtil.getParentOfType(position, PsiDeclarationStatement.class);\n    }\n    if (statement != null && statement.getTextRange().getStartOffset() == position.getTextRange().getStartOffset()) {\n      if (!psiElement().withSuperParent(2, PsiSwitchStatement.class).accepts(statement)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n      }\n    }\n\n    if (isStatementPosition(position)) {\n      if (INSIDE_SWITCH.isAcceptable(position, position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.CASE), TailType.SPACE));\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.DEFAULT), TailType.CASE_COLON));\n        return;\n      }\n\n      addBreakContinue(result, position);\n      addStatementKeywords(result, position);\n    }\n\n    if (SUPER_OR_THIS_PATTERN.accepts(position)) {\n      if (!AFTER_DOT.accepts(position) || isInsideQualifierClass(position)) {\n        result.addElement(createKeyword(position, PsiKeyword.THIS));\n\n        final LookupItem superItem = (LookupItem)createKeyword(position, PsiKeyword.SUPER);\n        if (psiElement().afterLeaf(psiElement().withText(\"{\").withSuperParent(2, psiMethod().constructor(true))).accepts(position)) {\n          final PsiMethod method = PsiTreeUtil.getParentOfType(position, PsiMethod.class, false, PsiClass.class);\n          assert method != null;\n          final boolean hasParams = superConstructorHasParameters(method);\n          superItem.setInsertHandler(new ParenthesesInsertHandler<LookupElement>() {\n            @Override\n            protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {\n              return hasParams;\n            }\n\n            @Override\n            public void handleInsert(InsertionContext context, LookupElement item) {\n              super.handleInsert(context, item);\n              TailType.insertChar(context.getEditor(), context.getTailOffset(), ';');\n            }\n          });\n        }\n\n        result.addElement(superItem);\n      }\n    }\n\n    if (EXPR_KEYWORDS.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.NEW), TailType.SPACE));\n      result.addElement(createKeyword(position, PsiKeyword.NULL));\n      result.addElement(createKeyword(position, PsiKeyword.TRUE));\n      result.addElement(createKeyword(position, PsiKeyword.FALSE));\n    }\n\n    if (CLASS_START.isAcceptable(position, position) || INSIDE_PARAMETER_LIST.accepts(position)) {\n      for (String s : ModifierChooser.getKeywords(position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, s), TailType.SPACE));\n      }\n    }\n\n    addPrimitiveTypes(result, position);\n\n    if (isAfterTypeDot(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n\n    addUnfinishedMethodTypeParameters(position, result);\n\n    if (JavaSmartCompletionContributor.INSIDE_EXPRESSION.accepts(position) &&\n        !BasicExpressionCompletionContributor.AFTER_DOT.accepts(position) &&\n        !(position.getParent() instanceof PsiLiteralExpression) &&\n        !(position.getParent().getParent() instanceof PsiSwitchLabelStatement)) {\n      for (final ExpectedTypeInfo info : JavaSmartCompletionContributor.getExpectedTypes(parameters)) {\n        new JavaMembersGetter(info.getDefaultType()).addMembers(position, parameters.getInvocationCount() > 0, new Consumer<LookupElement>() {\n          @Override\n          public void consume(LookupElement element) {\n            result.addElement(element);\n          }\n        });\n      }\n    }\n  }","id":42078,"modified_method":"@Override\n  public void fillCompletions(CompletionParameters parameters, final CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    if (PsiTreeUtil.getParentOfType(position, PsiComment.class, false) != null) {\n      return;\n    }\n\n    PsiStatement statement = PsiTreeUtil.getParentOfType(position, PsiExpressionStatement.class);\n    if (statement == null) {\n      statement = PsiTreeUtil.getParentOfType(position, PsiDeclarationStatement.class);\n    }\n    if (statement != null && statement.getTextRange().getStartOffset() == position.getTextRange().getStartOffset()) {\n      if (!psiElement().withSuperParent(2, PsiSwitchStatement.class).accepts(statement)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n      }\n    }\n\n    if (isStatementPosition(position)) {\n      if (INSIDE_SWITCH.isAcceptable(position, position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.CASE), TailType.SPACE));\n        result.addElement(new OverrideableSpace(createKeyword(position, PsiKeyword.DEFAULT), TailType.CASE_COLON));\n        return;\n      }\n\n      addBreakContinue(result, position);\n      addStatementKeywords(result, position);\n    }\n\n    if (SUPER_OR_THIS_PATTERN.accepts(position)) {\n      if (!AFTER_DOT.accepts(position) || isInsideQualifierClass(position)) {\n        result.addElement(createKeyword(position, PsiKeyword.THIS));\n\n        final LookupItem superItem = (LookupItem)createKeyword(position, PsiKeyword.SUPER);\n        if (psiElement().afterLeaf(psiElement().withText(\"{\").withSuperParent(2, psiMethod().constructor(true))).accepts(position)) {\n          final PsiMethod method = PsiTreeUtil.getParentOfType(position, PsiMethod.class, false, PsiClass.class);\n          assert method != null;\n          final boolean hasParams = superConstructorHasParameters(method);\n          superItem.setInsertHandler(new ParenthesesInsertHandler<LookupElement>() {\n            @Override\n            protected boolean placeCaretInsideParentheses(InsertionContext context, LookupElement item) {\n              return hasParams;\n            }\n\n            @Override\n            public void handleInsert(InsertionContext context, LookupElement item) {\n              super.handleInsert(context, item);\n              TailType.insertChar(context.getEditor(), context.getTailOffset(), ';');\n            }\n          });\n        }\n\n        result.addElement(superItem);\n      }\n    }\n\n    if (EXPR_KEYWORDS.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.NEW), TailType.SPACE));\n      result.addElement(createKeyword(position, PsiKeyword.NULL));\n      result.addElement(createKeyword(position, PsiKeyword.TRUE));\n      result.addElement(createKeyword(position, PsiKeyword.FALSE));\n    }\n\n    if (INSIDE_PARAMETER_LIST.accepts(position) && !psiElement().afterLeaf(PsiKeyword.FINAL).accepts(position) && !AFTER_DOT.accepts(position)) {\n      result.addElement(TailTypeDecorator.withTail(createKeyword(position, PsiKeyword.FINAL), TailType.SPACE));\n    }\n\n    if (CLASS_START.isAcceptable(position, position)) {\n      for (String s : ModifierChooser.getKeywords(position)) {\n        result.addElement(new OverrideableSpace(createKeyword(position, s), TailType.SPACE));\n      }\n    }\n\n    addPrimitiveTypes(result, position);\n\n    if (isAfterTypeDot(position)) {\n      result.addElement(createKeyword(position, PsiKeyword.CLASS));\n    }\n\n    addUnfinishedMethodTypeParameters(position, result);\n\n    if (JavaSmartCompletionContributor.INSIDE_EXPRESSION.accepts(position) &&\n        !BasicExpressionCompletionContributor.AFTER_DOT.accepts(position) &&\n        !(position.getParent() instanceof PsiLiteralExpression) &&\n        !(position.getParent().getParent() instanceof PsiSwitchLabelStatement)) {\n      for (final ExpectedTypeInfo info : JavaSmartCompletionContributor.getExpectedTypes(parameters)) {\n        new JavaMembersGetter(info.getDefaultType()).addMembers(position, parameters.getInvocationCount() > 0, new Consumer<LookupElement>() {\n          @Override\n          public void consume(LookupElement element) {\n            result.addElement(element);\n          }\n        });\n      }\n    }\n  }","commit_id":"c9fb775804ece8a87b385cde4b7f179f2d97a5a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiModifierList getModifierList(PsiElement element) throws Exception{\n    if(element == null){\n      return null;\n    }\n    if(element.getParent() instanceof PsiModifierList)\n      return (PsiModifierList)element.getParent();\n\n    final PsiElement prev = FilterPositionUtil.searchNonSpaceNonCommentBack(element);\n\n    if(prev != null) {\n      final PsiModifierList modifierList = PsiTreeUtil.getParentOfType(prev, PsiModifierList.class);\n      if(modifierList != null){\n        return modifierList;\n      }\n    }\n\n    PsiElement parent = element.getParent();\n    while(parent != null && (parent instanceof PsiJavaCodeReferenceElement\n      || parent instanceof PsiErrorElement || parent instanceof PsiTypeElement\n      || parent instanceof PsiMethod || parent instanceof PsiVariable\n      || parent instanceof PsiDeclarationStatement || parent instanceof PsiImportList\n      || parent instanceof PsiDocComment\n      || element.getText().equals(parent.getText()))){\n      parent = parent.getParent();\n      if (parent instanceof JspClassLevelDeclarationStatement) {\n        parent = parent.getContext();\n      }\n    }\n\n    if(parent == null) throw new Exception();\n    for (final Object o : myMap.keySet()) {\n      final ElementFilter filter = (ElementFilter)o;\n      if (filter.isClassAcceptable(parent.getClass()) && filter.isAcceptable(parent, parent.getParent())) {\n        if (parent instanceof PsiParameterList) {\n          if (prev == null || Arrays.asList(new String[]{\"(\", \",\"}).contains(prev.getText())\n              || Arrays.asList(new String[]{\"(\", \",\"}).contains(element.getText())) {\n            return null;\n          }\n        }\n        else if (prev == null || JavaCompletionData.END_OF_BLOCK.isAcceptable(element, prev.getParent())) {\n          return null;\n        }\n      }\n    }\n\n    throw new Exception(\"Can't find modifier list\");\n  }","id":42079,"modified_method":"private static PsiModifierList getModifierList(PsiElement element) throws Exception{\n    if(element == null){\n      return null;\n    }\n    if(element.getParent() instanceof PsiModifierList)\n      return (PsiModifierList)element.getParent();\n\n    final PsiElement prev = FilterPositionUtil.searchNonSpaceNonCommentBack(element);\n\n    if(prev != null) {\n      final PsiModifierList modifierList = PsiTreeUtil.getParentOfType(prev, PsiModifierList.class);\n      if(modifierList != null){\n        return modifierList;\n      }\n    }\n\n    PsiElement parent = element.getParent();\n    while(parent != null && (parent instanceof PsiJavaCodeReferenceElement\n      || parent instanceof PsiErrorElement || parent instanceof PsiTypeElement\n      || parent instanceof PsiMethod || parent instanceof PsiVariable\n      || parent instanceof PsiDeclarationStatement || parent instanceof PsiImportList\n      || parent instanceof PsiDocComment\n      || element.getText().equals(parent.getText()))){\n      parent = parent.getParent();\n      if (parent instanceof JspClassLevelDeclarationStatement) {\n        parent = parent.getContext();\n      }\n    }\n\n    if(parent == null) throw new Exception();\n    for (final Object o : myMap.keySet()) {\n      final ElementFilter filter = (ElementFilter)o;\n      if (filter.isClassAcceptable(parent.getClass()) && filter.isAcceptable(parent, parent.getParent())) {\n        if (prev == null || JavaCompletionData.END_OF_BLOCK.isAcceptable(element, prev.getParent())) {\n          return null;\n        }\n      }\n    }\n\n    throw new Exception(\"Can't find modifier list\");\n  }","commit_id":"c9fb775804ece8a87b385cde4b7f179f2d97a5a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String[] getKeywords(@NotNull PsiElement position) {\n    if (JavaCompletionData.INSIDE_SWITCH.isAcceptable(position, position)) {\n      return ArrayUtil.EMPTY_STRING_ARRAY;\n    }\n\n    final List<String> ret = new ArrayList<String>();\n    try {\n      PsiElement scope;\n\n      scope = position.getParent();\n\n      final PsiModifierList list = getModifierList(position);\n\n      scopes:\n      while (scope != null) {\n        for (final Object o : myMap.keySet()) {\n          final ElementFilter filter = (ElementFilter)o;\n          if (filter.isClassAcceptable(scope.getClass()) && filter.isAcceptable(scope, scope.getParent())) {\n            final String[][] keywordSets = myMap.get(filter);\n            for (int i = 0; i < keywordSets.length; i++) {\n              final String[] keywords = keywordSets[keywordSets.length - i - 1];\n              boolean containModifierFlag = false;\n              if (list != null) {\n                for (@Modifier String keyword : keywords) {\n                  if (list.hasExplicitModifier(keyword)) {\n                    containModifierFlag = true;\n                    break;\n                  }\n                }\n              }\n              if (!containModifierFlag) {\n                ContainerUtil.addAll(ret, keywords);\n              }\n            }\n            break scopes;\n          }\n        }\n        scope = scope.getParent();\n        if (scope instanceof JspClassLevelDeclarationStatement) {\n          scope = scope.getContext();\n        }\n        if (scope instanceof PsiDirectory) break;\n      }\n    }\n    catch (Exception e) {\n    }\n    return ArrayUtil.toStringArray(ret);\n  }","id":42080,"modified_method":"public static String[] getKeywords(@NotNull PsiElement position) {\n    final List<String> ret = new ArrayList<String>();\n    try {\n      PsiElement scope;\n\n      scope = position.getParent();\n\n      final PsiModifierList list = getModifierList(position);\n\n      scopes:\n      while (scope != null) {\n        for (final Object o : myMap.keySet()) {\n          final ElementFilter filter = (ElementFilter)o;\n          if (filter.isClassAcceptable(scope.getClass()) && filter.isAcceptable(scope, scope.getParent())) {\n            final String[][] keywordSets = myMap.get(filter);\n            for (int i = 0; i < keywordSets.length; i++) {\n              final String[] keywords = keywordSets[keywordSets.length - i - 1];\n              boolean containModifierFlag = false;\n              if (list != null) {\n                for (@Modifier String keyword : keywords) {\n                  if (list.hasExplicitModifier(keyword)) {\n                    containModifierFlag = true;\n                    break;\n                  }\n                }\n              }\n              if (!containModifierFlag) {\n                ContainerUtil.addAll(ret, keywords);\n              }\n            }\n            break scopes;\n          }\n        }\n        scope = scope.getParent();\n        if (scope instanceof JspClassLevelDeclarationStatement) {\n          scope = scope.getContext();\n        }\n        if (scope instanceof PsiDirectory) break;\n      }\n    }\n    catch (Exception e) {\n    }\n    return ArrayUtil.toStringArray(ret);\n  }","commit_id":"c9fb775804ece8a87b385cde4b7f179f2d97a5a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Get the PresenceStatus for a particular contact. This method is not meant\n     * to be used by the user interface (which would simply register as a\n     * presence listener and always follow contact status) but rather by other\n     * plugins that may for some reason need to know the status of a particular\n     * contact.\n     * <p>\n     * @param contactIdentifier the identifier of the contact whose status we're\n     * interested in.\n     * @return PresenceStatus the <tt>PresenceStatus<\/tt> of the specified\n     * <tt>contact<\/tt>\n     *\n     * @throws OperationFailedException with code NETWORK_FAILURE if retrieving\n     * the status fails due to errors experienced during network communication\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     * known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is not\n     * registered/signed on a public service.\n     */\n    public PresenceStatus queryContactStatus(String contactIdentifier)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        return resolveContactID(contactIdentifier).getPresenceStatus();\n    }","id":42081,"modified_method":"/**\n     * Get the PresenceStatus for a particular contact.\n     *\n     * @param contactIdentifier the identifier of the contact whose status\n     *   we're interested in.\n     * @return PresenceStatus the <tt>PresenceStatus<\/tt> of the specified\n     *   <tt>contact<\/tt>\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     *   known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is\n     *   not registered/signed on a public service.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   retrieving the status fails due to errors experienced during\n     *   network communication\n     */\n    public PresenceStatus queryContactStatus(String contactIdentifier)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        return resolveContactID(contactIdentifier).getPresenceStatus();\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n          * The method is called by a ProtocolProvider implementation whenver\n          * a change in the registration state of the corresponding provider had\n          * occurred. The method is particularly interested in events stating\n          * that the SIP provider has unregistered so that it would fire\n          * status change events for all contacts in our buddy list.\n          *\n          * @param evt ProviderStatusChangeEvent the event describing the status\n          * change.\n          */\n          public void registrationStateChanged(RegistrationStateChangeEvent evt)\n          {\n              if(evt.getNewState() == RegistrationState.UNREGISTERING)\n              {\n                  // stop any task associated with the timer\n                  timer.cancel();\n                  \n                  // this will not be called by anyone else, so call it\n                  // the method will terminate every active subscription\n                  try {\n                      publishPresenceStatus(SipStatusEnum.OFFLINE, \"\");\n                  } catch (OperationFailedException e) {\n                      logger.error(\"can't set the offline mode\", e);\n                  }\n\n                  // we wait for every SUBSCRIBE, NOTIFY and PUBLISH transaction\n                  // to finish before continuing the unsubscription\n                  for (byte i = 0; i < 20; i++) {   // wait 10 s. max\n                      synchronized (waitedCallIds) {\n                          if (waitedCallIds.size() == 0) {\n                              break;\n                          }\n                      }\n\n                      Object o = new Object(); // don't block the 'this' monitor\n                      synchronized (o) {\n                          try {\n                              o.wait(500);\n                          } catch (InterruptedException e) {\n                              logger.debug(\"abnormal behavior, may cause \" +\n                                    \"unnecessary CPU use\", e);\n                          }\n                      }\n                  }\n\n                  // since we are disconnected, we won't receive any further\n                  // status updates so we need to change by ourselves our own\n                  // status as well as set to offline all contacts in our\n                  // contact list that were online\n                  PresenceStatus oldStatus = presenceStatus;\n                  presenceStatus = SipStatusEnum.OFFLINE;\n\n                  fireProviderStatusChangeEvent(oldStatus);\n              } else if (evt.getNewState().equals(\n                      RegistrationState.REGISTERED))\n              {\n                 logger.debug(\"enter registered state\");\n\n                  // send a subscription for every contact\n                  Iterator groupsIter = getServerStoredContactListRoot()\n                      .subgroups();\n                  while (groupsIter.hasNext()) {\n                      ContactGroupSipImpl group = (ContactGroupSipImpl)\n                          groupsIter.next();\n\n                      Iterator contactsIter = group.contacts();\n\n                      while (contactsIter.hasNext()) {\n                          ContactSipImpl contact = (ContactSipImpl)\n                              contactsIter.next();\n\n                          if (contact.isResolved()) {\n                              logger.debug(\"contact \" + contact\n                                      + \" already resolved\");\n                              continue;\n                          }\n\n                          //create the subscription\n                          Request subscription;\n                          try\n                          {\n                              subscription = createSubscription(contact,\n                                      SUBSCRIBE_DEFAULT_EXPIRE);\n                          }\n                          catch (OperationFailedException ex)\n                          {\n                              logger.error(\n                                  \"Failed to create the subcription\"\n                                  , ex);\n\n                              return;\n                          }\n\n                          //Transaction\n                          ClientTransaction subscribeTransaction;\n                          SipProvider jainSipProvider\n                              = parentProvider.getDefaultJainSipProvider();\n                          try\n                          {\n                              subscribeTransaction = jainSipProvider\n                                  .getNewClientTransaction(subscription);\n                          }\n                          catch (TransactionUnavailableException ex)\n                          {\n                              logger.error(\n                                  \"Failed to create subscriptionTransaction.\\n\"\n                                  + \"This is most probably a network\"\n                                  + \" connection error.\"\n                                  , ex);\n\n                              return;\n                          }\n\n                          // we register the contact to find him when the OK\n                          // will arrive\n                          CallIdHeader idheader = (CallIdHeader)\n                              subscription.getHeader(CallIdHeader.NAME);\n                          subscribedContacts.put(idheader.getCallId(), contact);\n                          logger.debug(\"added a contact at :\"\n                                  + idheader.getCallId());\n\n                          // send the message\n                          try\n                          {\n                              subscribeTransaction.sendRequest();\n                          }\n                          catch (SipException ex)\n                          {\n                              logger.error(\n                                  \"Failed to send the message.\",\n                                  ex);\n\n                              // this contact will never been accepted or\n                              // rejected\n                              subscribedContacts.remove(idheader.getCallId());\n\n                              return;\n                          }\n                      }\n                  }\n\n                  // is this needed ?\n                  PresenceStatus oldStatus = getPresenceStatus();\n                  presenceStatus = SipStatusEnum.ONLINE;\n                  fireProviderStatusChangeEvent(oldStatus);\n                  \n                  // create a new Timer (the last has been cancelled)\n                  timer = new Timer();\n                  \n                  // create the new polling task (the last has been cancelled)\n                  pollingTask = new PollOfflineContactsTask();\n                  \n                  // start polling the offline contacts\n                  timer.schedule(pollingTask, POLLING_TASK_PERIOD,\n                          POLLING_TASK_PERIOD);\n              }\n         }","id":42082,"modified_method":"/**\n          * The method is called by a ProtocolProvider implementation whenver\n          * a change in the registration state of the corresponding provider had\n          * occurred. The method is particularly interested in events stating\n          * that the SIP provider has unregistered so that it would fire\n          * status change events for all contacts in our buddy list.\n          *\n          * @param evt ProviderStatusChangeEvent the event describing the status\n          * change.\n          */\n          public void registrationStateChanged(RegistrationStateChangeEvent evt)\n          {\n              if(evt.getNewState() == RegistrationState.UNREGISTERING)\n              {\n                  // stop any task associated with the timer\n                  timer.cancel();\n                  \n                  // this will not be called by anyone else, so call it\n                  // the method will terminate every active subscription\n                  try {\n                      publishPresenceStatus(SipStatusEnum.OFFLINE, \"\");\n                  } catch (OperationFailedException e) {\n                      logger.error(\"can't set the offline mode\", e);\n                  }\n\n                  // start a thread for waiting all the reponses\n                  Thread t = new Thread(new unregisteringThread());\n                  t.setDaemon(false);\n                  t.start();\n\n                  // since we are disconnected, we won't receive any further\n                  // status updates so we need to change by ourselves our own\n                  // status as well as set to offline all contacts in our\n                  // contact list that were online\n                  PresenceStatus oldStatus = presenceStatus;\n                  presenceStatus = SipStatusEnum.OFFLINE;\n\n                  fireProviderStatusChangeEvent(oldStatus);\n              } else if (evt.getNewState().equals(\n                      RegistrationState.REGISTERED))\n              {\n                 logger.debug(\"enter registered state\");\n\n                  // send a subscription for every contact\n                  Iterator groupsIter = getServerStoredContactListRoot()\n                      .subgroups();\n                  while (groupsIter.hasNext()) {\n                      ContactGroupSipImpl group = (ContactGroupSipImpl)\n                          groupsIter.next();\n\n                      Iterator contactsIter = group.contacts();\n\n                      while (contactsIter.hasNext()) {\n                          ContactSipImpl contact = (ContactSipImpl)\n                              contactsIter.next();\n\n                          if (contact.isResolved()) {\n                              logger.debug(\"contact \" + contact\n                                      + \" already resolved\");\n                              continue;\n                          }\n\n                          //create the subscription\n                          Request subscription;\n                          try\n                          {\n                              subscription = createSubscription(contact,\n                                      SUBSCRIBE_DEFAULT_EXPIRE);\n                          }\n                          catch (OperationFailedException ex)\n                          {\n                              logger.error(\n                                  \"Failed to create the subcription\"\n                                  , ex);\n\n                              return;\n                          }\n\n                          //Transaction\n                          ClientTransaction subscribeTransaction;\n                          SipProvider jainSipProvider\n                              = parentProvider.getDefaultJainSipProvider();\n                          try\n                          {\n                              subscribeTransaction = jainSipProvider\n                                  .getNewClientTransaction(subscription);\n                          }\n                          catch (TransactionUnavailableException ex)\n                          {\n                              logger.error(\n                                  \"Failed to create subscriptionTransaction.\\n\"\n                                  + \"This is most probably a network\"\n                                  + \" connection error.\"\n                                  , ex);\n\n                              return;\n                          }\n\n                          // we register the contact to find him when the OK\n                          // will arrive\n                          CallIdHeader idheader = (CallIdHeader)\n                              subscription.getHeader(CallIdHeader.NAME);\n                          subscribedContacts.put(idheader.getCallId(), contact);\n                          logger.debug(\"added a contact at :\"\n                                  + idheader.getCallId());\n\n                          // send the message\n                          try\n                          {\n                              subscribeTransaction.sendRequest();\n                          }\n                          catch (SipException ex)\n                          {\n                              logger.error(\n                                  \"Failed to send the message.\",\n                                  ex);\n\n                              // this contact will never been accepted or\n                              // rejected\n                              subscribedContacts.remove(idheader.getCallId());\n\n                              return;\n                          }\n                      }\n                  }\n\n                  PresenceStatus oldStatus = getPresenceStatus();\n                  presenceStatus = SipStatusEnum.ONLINE;\n                  fireProviderStatusChangeEvent(oldStatus);\n                  \n                  // create a new Timer (the last one has been cancelled)\n                  timer = new Timer(true);\n                  \n                  // create the new polling task\n                  pollingTask = new PollOfflineContactsTask();\n                  \n                  // start polling the offline contacts\n                  timer.schedule(pollingTask, POLLING_TASK_PERIOD,\n                          POLLING_TASK_PERIOD);\n              }\n         }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a subscription for the presence status of the contact corresponding\n     * to the specified contactIdentifier. Note that apart from an exception in\n     * the case of an immediate failure, the method won't return any indication\n     * of success or failure. That would happen later on through a\n     * SubscriptionEvent generated by one of the methods of the\n     * SubscriptionListener.\n     *\n     * @param contactIdentifier the identifier of the contact whose status\n     * updates we are subscribing for.\n     * @param parentGroup the group where we will be adding the parent.\n     *\n     * @throws OperationFailedException if subscribing fails due to errors\n     * experienced during the contact creation\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     * known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is not\n     * registered/signed on a public service.\n     */\n    public void subscribe(ContactGroup parentGroup, String contactIdentifier)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        logger.debug(\"let's subscribe \" + contactIdentifier);\n\n        //if the contact is already in the contact list\n        ContactSipImpl contact = (ContactSipImpl) \n            resolveContactID(contactIdentifier);\n\n        if (contact != null) {\n            logger.debug(\"Contact \" + contactIdentifier\n                    + \" already exists.\");\n            throw new OperationFailedException(\n                \"Contact \" + contactIdentifier + \" already exists.\",\n                OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);\n        }\n\n        assertConnected();\n\n        // create the contact\n        contact = new ContactSipImpl(contactIdentifier, this.parentProvider);\n\n        //create the subscription\n        Request subscription;\n        try\n        {\n            subscription = createSubscription(contact,\n                    SUBSCRIBE_DEFAULT_EXPIRE);\n        }\n        catch (OperationFailedException ex)\n        {\n            logger.error(\n                \"Failed to create the subcription\"\n                , ex);\n\n            throw new OperationFailedException(\n                    \"Failed to create the subscription\",\n                    OperationFailedException.INTERNAL_ERROR);\n        }\n\n        //Transaction\n        ClientTransaction subscribeTransaction;\n        SipProvider jainSipProvider\n            = this.parentProvider.getDefaultJainSipProvider();\n        try\n        {\n            subscribeTransaction = jainSipProvider\n                .getNewClientTransaction(subscription);\n        }\n        catch (TransactionUnavailableException ex)\n        {\n            logger.error(\n                \"Failed to create subscriptionTransaction.\\n\"\n                + \"This is most probably a network connection error.\"\n                , ex);\n\n            throw new OperationFailedException(\n                    \"Failed to create the subscription transaction\",\n                    OperationFailedException.NETWORK_FAILURE);\n        }\n\n        // we register the contact to find him when the OK will arrive\n        CallIdHeader idheader = (CallIdHeader)\n            subscription.getHeader(CallIdHeader.NAME);\n        this.subscribedContacts.put(idheader.getCallId(), contact);\n\n        // send the message\n        try\n        {\n            subscribeTransaction.sendRequest();\n        }\n        catch (SipException ex)\n        {\n            logger.error(\n                \"Failed to send the message.\"\n                , ex);\n\n            // this contact will never been accepted or rejected\n            this.subscribedContacts.remove(idheader.getCallId());\n\n            throw new OperationFailedException(\n                    \"Failed to send the subscription\",\n                    OperationFailedException.NETWORK_FAILURE);\n        }\n\n        ((ContactGroupSipImpl) parentGroup).addContact(contact);\n\n        // pretend that the contact is created\n        fireSubscriptionEvent(contact,\n                parentGroup,\n                SubscriptionEvent.SUBSCRIPTION_CREATED);\n    }","id":42083,"modified_method":"/**\n     * Persistently adds a subscription for the presence status of the\n     * contact corresponding to the specified contactIdentifier and indicates\n     * that it should be added to the specified group of the server stored\n     * contact list.\n     *\n     * @param parent the parent group of the server stored contact list\n     *   where the contact should be added. <p>\n     * @param contactIdentifier the contact whose status updates we are\n     *   subscribing for.\n     * @throws IllegalArgumentException if <tt>contact<\/tt> or\n     *   <tt>parent<\/tt> are not a contact known to the underlying protocol\n     *   provider.\n     * @throws IllegalStateException if the underlying protocol provider is\n     *   not registered/signed on a public service.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   subscribing fails due to errors experienced during network\n     *   communication\n     */\n    public void subscribe(ContactGroup parentGroup, String contactIdentifier)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        logger.debug(\"let's subscribe \" + contactIdentifier);\n\n        //if the contact is already in the contact list\n        ContactSipImpl contact = (ContactSipImpl) \n            resolveContactID(contactIdentifier);\n\n        if (contact != null) {\n            logger.debug(\"Contact \" + contactIdentifier\n                    + \" already exists.\");\n            throw new OperationFailedException(\n                \"Contact \" + contactIdentifier + \" already exists.\",\n                OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS);\n        }\n\n        assertConnected();\n\n        // create the contact\n        contact = new ContactSipImpl(contactIdentifier, this.parentProvider);\n\n        //create the subscription\n        Request subscription;\n        try\n        {\n            subscription = createSubscription(contact,\n                    SUBSCRIBE_DEFAULT_EXPIRE);\n        }\n        catch (OperationFailedException ex)\n        {\n            logger.error(\n                \"Failed to create the subcription\"\n                , ex);\n\n            throw new OperationFailedException(\n                    \"Failed to create the subscription\",\n                    OperationFailedException.INTERNAL_ERROR);\n        }\n\n        //Transaction\n        ClientTransaction subscribeTransaction;\n        SipProvider jainSipProvider\n            = this.parentProvider.getDefaultJainSipProvider();\n        try\n        {\n            subscribeTransaction = jainSipProvider\n                .getNewClientTransaction(subscription);\n        }\n        catch (TransactionUnavailableException ex)\n        {\n            logger.error(\n                \"Failed to create subscriptionTransaction.\\n\"\n                + \"This is most probably a network connection error.\"\n                , ex);\n\n            throw new OperationFailedException(\n                    \"Failed to create the subscription transaction\",\n                    OperationFailedException.NETWORK_FAILURE);\n        }\n\n        // we register the contact to find him when the OK will arrive\n        CallIdHeader idheader = (CallIdHeader)\n            subscription.getHeader(CallIdHeader.NAME);\n        this.subscribedContacts.put(idheader.getCallId(), contact);\n\n        // send the message\n        try\n        {\n            subscribeTransaction.sendRequest();\n        }\n        catch (SipException ex)\n        {\n            logger.error(\n                \"Failed to send the message.\"\n                , ex);\n\n            // this contact will never been accepted or rejected\n            this.subscribedContacts.remove(idheader.getCallId());\n\n            throw new OperationFailedException(\n                    \"Failed to send the subscription\",\n                    OperationFailedException.NETWORK_FAILURE);\n        }\n\n        ((ContactGroupSipImpl) parentGroup).addContact(contact);\n\n        // pretend that the contact is created\n        fireSubscriptionEvent(contact,\n                parentGroup,\n                SubscriptionEvent.SUBSCRIPTION_CREATED);\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Create a valid PUBLISH request corresponding to the current presence\n     * state. The request is forged to be send to the current distant presence\n     * agent.\n     *\n     * @param expires the expires value to send\n     * @param insertPresDoc if a presence document has to be added (typically\n     * = false when refreshing a publication)\n     *\n     * @return a valid <tt>Request<\/tt> containing the PUBLISH\n     *\n     * @throws OperationFailedException if something goes wrong\n     */\n    private Request createPublish(int expires, boolean insertPresDoc)\n        throws OperationFailedException\n    {\n        // Address\n        InetAddress destinationInetAddress = null;\n        try\n        {\n            destinationInetAddress = InetAddress.getByName(\n                ((SipURI) this.parentProvider.getOurSipAddress().getURI())\n                .getHost());\n        }\n        catch (UnknownHostException ex)\n        {\n            throw new OperationFailedException(\n                ((SipURI) this.parentProvider.getOurSipAddress().getURI())\n                        .getHost()\n                + \" is not a valid internet address \" + ex.getMessage(),\n                OperationFailedException.INTERNAL_ERROR);\n        }\n\n        // Call ID\n        CallIdHeader callIdHeader = this.parentProvider\n            .getDefaultJainSipProvider().getNewCallId();\n\n        //FromHeader and ToHeader\n        String localTag = ProtocolProviderServiceSipImpl.generateLocalTag();\n        FromHeader fromHeader = null;\n        ToHeader toHeader = null;\n        try\n        {\n            //FromHeader\n            fromHeader = this.parentProvider.getHeaderFactory()\n                .createFromHeader(this.parentProvider.getOurSipAddress()\n                                  , localTag);\n\n            //ToHeader (it's ourselves)\n            toHeader = this.parentProvider.getHeaderFactory()\n                .createToHeader(this.parentProvider.getOurSipAddress(), null);\n        }\n        catch (ParseException ex)\n        {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the FromHeader or ToHeader\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the FromHeader or ToHeader\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n\n        //ViaHeaders\n        ArrayList viaHeaders = this.parentProvider.getLocalViaHeaders(\n            destinationInetAddress,\n            this.parentProvider.getDefaultListeningPoint());\n\n        //MaxForwards\n        MaxForwardsHeader maxForwards = this.parentProvider\n            .getMaxForwardsHeader();\n\n        // Content params\n        byte[] doc = null;\n        \n        if (insertPresDoc) {\n            doc = getPidfPresenceStatus((ContactSipImpl)\n                    this.getLocalContact());\n        } else {\n            doc = new byte[0];\n        }\n        \n        ContentTypeHeader contTypeHeader;\n        ContentLengthHeader contLengthHeader;\n        try\n        {\n            contTypeHeader = this.parentProvider.getHeaderFactory()\n                .createContentTypeHeader(\"application\",\n                                         PIDF_XML);\n\n\n            // IS IT NEEDED ?\n            contLengthHeader = this.parentProvider.getHeaderFactory()\n                .createContentLengthHeader(doc.length);\n        }\n        catch (ParseException ex)\n        {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the content headers\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the content headers\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n        catch (InvalidArgumentException exc)\n        {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the content length header\", exc);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the content length header\"\n                , OperationFailedException.INTERNAL_ERROR\n                , exc);\n        }\n\n        // eventually add the entity tag\n        SIPIfMatchHeader ifmHeader = null;\n        try {\n            if (this.distantPAET != null) {\n                ifmHeader = this.parentProvider.getHeaderFactory()\n                    .createSIPIfMatchHeader(this.distantPAET);\n            }\n        } catch (ParseException e) {\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the SIPIfMatch header\", e);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the SIPIfMatch header\",\n                OperationFailedException.INTERNAL_ERROR,\n                e);\n        }\n\n        //CSeq\n        CSeqHeader cSeqHeader = null;\n        try\n        {\n            cSeqHeader = this.parentProvider.getHeaderFactory()\n                .createCSeqHeader(1l, Request.PUBLISH);\n        }\n        catch (InvalidArgumentException ex)\n        {\n            //Shouldn't happen\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n        catch (ParseException ex)\n        {\n            //shouldn't happen\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n\n        // expires\n        ExpiresHeader expHeader = null;\n        try {\n            expHeader = this.parentProvider.getHeaderFactory()\n                .createExpiresHeader(expires);\n        } catch (InvalidArgumentException e) {\n            // will never happen\n            logger.error(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Expires header\", e);\n            throw new OperationFailedException(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Expires header\"\n                    , OperationFailedException.INTERNAL_ERROR\n                    , e);\n        }\n\n        // event\n        EventHeader evtHeader = null;\n        try {\n            evtHeader = this.parentProvider.getHeaderFactory()\n                .createEventHeader(\"presence\");\n        } catch (ParseException e) {\n            // will never happen\n            logger.error(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Event header\", e);\n            throw new OperationFailedException(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Event header\"\n                    , OperationFailedException.INTERNAL_ERROR\n                    , e);\n        }\n\n        Request req = null;\n        try\n        {\n            req = this.parentProvider.getMessageFactory().createRequest(\n                toHeader.getAddress().getURI(),\n                Request.PUBLISH,\n                callIdHeader,\n                cSeqHeader,\n                fromHeader,\n                toHeader,\n                viaHeaders,\n                maxForwards,\n                contTypeHeader,\n                doc);\n        }\n        catch (ParseException ex)\n        {\n            //shouldn't happen\n            logger.error(\n                \"Failed to create message Request!\", ex);\n            throw new OperationFailedException(\n                \"Failed to create message Request!\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n\n        req.setHeader(contLengthHeader);\n        req.setHeader(expHeader);\n        req.setHeader(evtHeader);\n\n        if (ifmHeader != null) {\n            req.setHeader(ifmHeader);\n        }\n\n        return req;\n    }","id":42084,"modified_method":"/**\n     * Create a valid PUBLISH request corresponding to the current presence\n     * state. The request is forged to be send to the current distant presence\n     * agent.\n     *\n     * @param expires the expires value to send\n     * @param insertPresDoc if a presence document has to be added (typically\n     * = false when refreshing a publication)\n     *\n     * @return a valid <tt>Request<\/tt> containing the PUBLISH\n     *\n     * @throws OperationFailedException if something goes wrong\n     */\n    private Request createPublish(int expires, boolean insertPresDoc)\n        throws OperationFailedException\n    {\n        // Address\n        InetAddress destinationInetAddress = null;\n        try\n        {\n            destinationInetAddress = InetAddress.getByName(\n                ((SipURI) this.parentProvider.getOurSipAddress().getURI())\n                .getHost());\n        }\n        catch (UnknownHostException ex)\n        {\n            throw new OperationFailedException(\n                ((SipURI) this.parentProvider.getOurSipAddress().getURI())\n                        .getHost()\n                + \" is not a valid internet address \" + ex.getMessage(),\n                OperationFailedException.INTERNAL_ERROR);\n        }\n\n        // Call ID\n        CallIdHeader callIdHeader = this.parentProvider\n            .getDefaultJainSipProvider().getNewCallId();\n\n        // FromHeader and ToHeader\n        String localTag = ProtocolProviderServiceSipImpl.generateLocalTag();\n        FromHeader fromHeader = null;\n        ToHeader toHeader = null;\n        try\n        {\n            //FromHeader\n            fromHeader = this.parentProvider.getHeaderFactory()\n                .createFromHeader(this.parentProvider.getOurSipAddress(),\n                                  localTag);\n\n            //ToHeader (it's ourselves)\n            toHeader = this.parentProvider.getHeaderFactory()\n                .createToHeader(this.parentProvider.getOurSipAddress(), null);\n        }\n        catch (ParseException ex)\n        {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the FromHeader or ToHeader\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the FromHeader or ToHeader\",\n                OperationFailedException.INTERNAL_ERROR,\n                ex);\n        }\n\n        //ViaHeaders\n        ArrayList viaHeaders = this.parentProvider.getLocalViaHeaders(\n            destinationInetAddress,\n            this.parentProvider.getDefaultListeningPoint());\n\n        //MaxForwards\n        MaxForwardsHeader maxForwards = this.parentProvider\n            .getMaxForwardsHeader();\n\n        // Content params\n        byte[] doc = null;\n        \n        if (insertPresDoc) {\n            doc = getPidfPresenceStatus((ContactSipImpl)\n                    this.getLocalContact());\n        } else {\n            doc = new byte[0];\n        }\n        \n        ContentTypeHeader contTypeHeader;\n        try\n        {\n            contTypeHeader = this.parentProvider.getHeaderFactory()\n                .createContentTypeHeader(\"application\",\n                                         PIDF_XML);\n        }\n        catch (ParseException ex)\n        {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the content headers\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the content headers\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n\n        // eventually add the entity tag\n        SIPIfMatchHeader ifmHeader = null;\n        try {\n            if (this.distantPAET != null) {\n                ifmHeader = this.parentProvider.getHeaderFactory()\n                    .createSIPIfMatchHeader(this.distantPAET);\n            }\n        } catch (ParseException e) {\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the SIPIfMatch header\", e);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the SIPIfMatch header\",\n                OperationFailedException.INTERNAL_ERROR,\n                e);\n        }\n\n        //CSeq\n        CSeqHeader cSeqHeader = null;\n        try\n        {\n            cSeqHeader = this.parentProvider.getHeaderFactory()\n                .createCSeqHeader(publish_cseq++, Request.PUBLISH);\n        }\n        catch (InvalidArgumentException ex)\n        {\n            //Shouldn't happen\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n        catch (ParseException ex)\n        {\n            //shouldn't happen\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\", ex);\n            throw new OperationFailedException(\n                \"An unexpected error occurred while\"\n                + \"constructing the CSeqHeader\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n\n        // expires\n        ExpiresHeader expHeader = null;\n        try {\n            expHeader = this.parentProvider.getHeaderFactory()\n                .createExpiresHeader(expires);\n        } catch (InvalidArgumentException e) {\n            // will never happen\n            logger.error(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Expires header\", e);\n            throw new OperationFailedException(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Expires header\"\n                    , OperationFailedException.INTERNAL_ERROR\n                    , e);\n        }\n\n        // event\n        EventHeader evtHeader = null;\n        try {\n            evtHeader = this.parentProvider.getHeaderFactory()\n                .createEventHeader(\"presence\");\n        } catch (ParseException e) {\n            // will never happen\n            logger.error(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Event header\", e);\n            throw new OperationFailedException(\n                    \"An unexpected error occurred while\"\n                    + \"constructing the Event header\"\n                    , OperationFailedException.INTERNAL_ERROR\n                    , e);\n        }\n\n        Request req = null;\n        try\n        {\n            req = this.parentProvider.getMessageFactory().createRequest(\n                toHeader.getAddress().getURI(),\n                Request.PUBLISH,\n                callIdHeader,\n                cSeqHeader,\n                fromHeader,\n                toHeader,\n                viaHeaders,\n                maxForwards,\n                contTypeHeader,\n                doc);\n        }\n        catch (ParseException ex)\n        {\n            //shouldn't happen\n            logger.error(\n                \"Failed to create message Request!\", ex);\n            throw new OperationFailedException(\n                \"Failed to create message Request!\"\n                , OperationFailedException.INTERNAL_ERROR\n                , ex);\n        }\n\n        req.setHeader(expHeader);\n        req.setHeader(evtHeader);\n\n        if (ifmHeader != null) {\n            req.setHeader(ifmHeader);\n        }\n\n        return req;\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a non persistent contact for the specified address. This would\n     * also create (if necessary) a group for volatile contacts that would not\n     * be added to the server stored contact list. This method would have no\n     * effect on the server stored contact list.\n     *\n     * @param contactAddress the address of the volatile contact we'd like to\n     * create.\n     * @return the newly created volatile contact.\n     */\n    public ContactSipImpl createVolatileContact(String contactAddress)\n    {\n        // First create the new volatile contact;\n        ContactSipImpl newVolatileContact\n            = new ContactSipImpl(contactAddress, this.parentProvider);\n        newVolatileContact.setPersistent(false);\n\n        // Check whether a volatile group already exists and if not create one\n        ContactGroupSipImpl theVolatileGroup = getNonPersistentGroup();\n\n        // if the parent volatile group is null then we create it\n        if (theVolatileGroup == null)\n        {\n            theVolatileGroup = new ContactGroupSipImpl(\n                \"NotInContactList\",\n                this.parentProvider);\n            theVolatileGroup.setResolved(false);\n            theVolatileGroup.setPersistent(false);\n\n            this.contactListRoot.addSubgroup(theVolatileGroup);\n\n            fireServerStoredGroupEvent(theVolatileGroup\n                           , ServerStoredGroupEvent.GROUP_CREATED_EVENT);\n        }\n\n        //now add the volatile contact instide it\n        theVolatileGroup.addContact(newVolatileContact);\n        fireSubscriptionEvent(newVolatileContact\n                         , theVolatileGroup\n                         , SubscriptionEvent.SUBSCRIPTION_CREATED);\n\n        return newVolatileContact;\n    }","id":42085,"modified_method":"/**\n     * Creates a non persistent contact for the specified address. This would\n     * also create (if necessary) a group for volatile contacts that would not\n     * be added to the server stored contact list. This method would have no\n     * effect on the server stored contact list.\n     *\n     * @param contactAddress the address of the volatile contact we'd like to\n     * create.\n     * @return the newly created volatile contact.\n     */\n    public ContactSipImpl createVolatileContact(String contactAddress)\n    {\n        // First create the new volatile contact;\n        ContactSipImpl newVolatileContact\n            = new ContactSipImpl(contactAddress, this.parentProvider);\n        newVolatileContact.setPersistent(false);\n        \n        // ensure that we won't try to subscribe to him\n        newVolatileContact.setResolvable(false);\n        newVolatileContact.setResolved(true);\n\n        // Check whether a volatile group already exists and if not create one\n        ContactGroupSipImpl theVolatileGroup = getNonPersistentGroup();\n\n        // if the parent volatile group is null then we create it\n        if (theVolatileGroup == null)\n        {\n            theVolatileGroup = new ContactGroupSipImpl(\n                \"NotInContactList\",\n                this.parentProvider);\n            theVolatileGroup.setResolved(false);\n            theVolatileGroup.setPersistent(false);\n\n            this.contactListRoot.addSubgroup(theVolatileGroup);\n\n            fireServerStoredGroupEvent(theVolatileGroup\n                           , ServerStoredGroupEvent.GROUP_CREATED_EVENT);\n        }\n\n        //now add the volatile contact inside it\n        theVolatileGroup.addContact(newVolatileContact);\n        fireSubscriptionEvent(newVolatileContact\n                         , theVolatileGroup\n                         , SubscriptionEvent.SUBSCRIPTION_CREATED);\n\n        return newVolatileContact;\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n          * Send a closing NOTIFY to the watcher\n          */\n         public void run() {\n             if (contact.getServerDialog() == null) {\n                 logger.warn(\"serverdialog null, we won't send the closing\"\n                         + \" NOTIFY\");\n                 return;\n             }\n             \n             ClientTransaction transac;\n             try {\n                 transac = createNotify(this.contact, \n                         getPidfPresenceStatus((ContactSipImpl)\n                                 getLocalContact()),\n                         SubscriptionStateHeader.TERMINATED,\n                         SubscriptionStateHeader.TIMEOUT);\n             } catch (OperationFailedException e) {\n                 logger.error(\"failed to create the new notify\", e);\n                 return;\n             }\n             \n             try {\n                 contact.getServerDialog().sendRequest(transac);\n             } catch (Exception e) {\n                 logger.error(\"Can't send the request\", e);\n                 return;\n             }\n             \n             synchronized (ourWatchers) {\n                 ourWatchers.remove(this.contact);\n             }\n         }","id":42086,"modified_method":"/**\n          * Send a closing NOTIFY to the watcher\n          */\n         public void run() {\n             if (contact.getServerDialog() == null) {\n                 logger.warn(\"serverdialog null, we won't send the closing\"\n                         + \" NOTIFY\");\n                 return;\n             }\n             \n             ClientTransaction transac;\n             try {\n                 transac = createNotify(this.contact, \n                         getPidfPresenceStatus((ContactSipImpl)\n                                 getLocalContact()),\n                         SubscriptionStateHeader.TERMINATED,\n                         SubscriptionStateHeader.TIMEOUT);\n             } catch (OperationFailedException e) {\n                 logger.error(\"failed to create the new notify\", e);\n                 return;\n             }\n             \n             try {\n                 contact.getServerDialog().sendRequest(transac);\n             } catch (Exception e) {\n                 logger.error(\"Can't send the request\", e);\n                 return;\n             }\n             \n             synchronized (ourWatchers) {\n                 ourWatchers.remove(this.contact);\n             }\n             this.contact.setServerDialog(null);\n         }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Analyzes the incoming <tt>responseEvent<\/tt> and then forwards it to the\n     * proper event handler.\n     *\n     * @param responseEvent the responseEvent that we received\n     * ProtocolProviderService.\n     */\n    public void processResponse(ResponseEvent responseEvent)\n    {\n        ClientTransaction clientTransaction = responseEvent\n            .getClientTransaction();\n        Response response = responseEvent.getResponse();\n\n        CSeqHeader cseq = ((CSeqHeader)response.getHeader(CSeqHeader.NAME));\n        if (cseq == null)\n        {\n            logger.error(\"An incoming response did not contain a CSeq header\");\n            return;\n        }\n        String method = cseq.getMethod();\n\n        SipProvider sourceProvider = (SipProvider)responseEvent.getSource();\n\n        // SUBSCRIBE\n        if (method.equals(Request.SUBSCRIBE)) {\n            // find the contact\n            CallIdHeader idheader = (CallIdHeader)\n                response.getHeader(CallIdHeader.NAME);\n            ContactSipImpl contact = (ContactSipImpl) this.subscribedContacts\n                .get(idheader.getCallId());\n\n            // if the response is a 423 response, just re-send the request\n            // with a valid expires value\n            if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {\n                MinExpiresHeader min = (MinExpiresHeader) \n                    response.getHeader(MinExpiresHeader.NAME);\n                \n                if (min == null) {\n                    logger.error(\"no minimal expires value in this 423 \" +\n                            \"response\");\n                    return;\n                }\n                \n                Request request = responseEvent.getClientTransaction()\n                    .getRequest();\n                \n                ExpiresHeader exp = request.getExpires();\n                \n                try {\n                    exp.setExpires(min.getExpires());\n                } catch (InvalidArgumentException e) {\n                    logger.error(\"can't set the new expires value\", e);\n                    return;\n                }\n                \n                ClientTransaction transac = null;\n                try {\n                    transac = this.parentProvider.getDefaultJainSipProvider()\n                        .getNewClientTransaction(request);\n                } catch (TransactionUnavailableException e) {\n                    logger.error(\"can't create the client transaction\", e);\n                    return;\n                }\n                \n                try {\n                    transac.sendRequest();\n                } catch (SipException e) {\n                    logger.error(\"can't send the new request\", e);\n                    return;\n                }\n                \n                return;\n            }\n            \n            // if it's the response to an unsubscribe message, we just ignore it\n            // whatever the response is however if we need to handle a \n            // challenge, we do it\n            ExpiresHeader expHeader = response.getExpires();\n            if ((expHeader != null && expHeader.getExpires() == 0)\n                    || contact == null) // this handle the unsubscription case\n                                        // where we removed the contact from\n                                        // subscribedContacts\n            {\n                if (response.getStatusCode() == Response.UNAUTHORIZED\n                        || response.getStatusCode() ==\n                            Response.PROXY_AUTHENTICATION_REQUIRED)\n                {\n                    try {\n                        processAuthenticationChallenge(clientTransaction,\n                                response, sourceProvider);\n                    } catch (OperationFailedException e) {\n                        logger.error(\"can't handle the challenge\");\n                    }\n                } else  if (response.getStatusCode() != Response.OK\n                        && response.getStatusCode() != Response.ACCEPTED)\n                {\n                    // this definitivly ends the subscription\n                    synchronized (this.waitedCallIds) {\n                        this.waitedCallIds.remove(idheader.getCallId());\n                    }\n                }\n                // any other cases (200/202) will imply a NOTIFY, so we will\n                // handle the end of a subscription there\n\n                return;\n            }\n\n            try {\n                if (!contact.isResolved()) {\n                    finalizeSubscription(contact,\n                            clientTransaction.getDialog());\n                }\n            } catch (NullPointerException e) {\n                // should not happen\n                logger.debug(\"failed to finalize the subscription of the\" +\n                        \"contact\", e);\n\n                return;\n            }\n\n            // OK (200/202)\n            if (response.getStatusCode() == Response.OK\n                || response.getStatusCode() == Response.ACCEPTED)\n            {\n                if (expHeader == null) {\n                    // not conform to rfc3265\n                    logger.error(\"no Expires header in this response\");\n                    return;\n                }\n                \n                RefreshSubscriptionTask refresh = \n                    new RefreshSubscriptionTask(contact);\n                contact.setResfreshTask(refresh);\n                \n                try {\n                    // keep one minute of margin\n                    this.timer.schedule(refresh,\n                            expHeader.getExpires() * 1000 - REFRESH_MARGIN);\n                } catch (IllegalArgumentException e) {\n                    logger.debug(\"the expires value seems to be less than a \" +\n                            \"minute, let's assume it\");\n                    \n                    this.timer.schedule(refresh, expHeader.getExpires() * 1000);\n                }\n                \n                // do it to remember the dialog in case of a polling\n                // subscription (which means no call to finalizeSubscription)\n                contact.setClientDialog(clientTransaction.getDialog());\n            // UNAUTHORIZED (401/407)\n            } else if (response.getStatusCode() == Response.UNAUTHORIZED\n                    || response.getStatusCode() == Response\n                        .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                try {\n                    processAuthenticationChallenge(clientTransaction,\n                            response, sourceProvider);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't handle the challenge\");\n\n                    // we probably won't be able to communicate with the contact\n                    changePresenceStatusForContact(contact,\n                            SipStatusEnum.UNKNOWN);\n                    this.subscribedContacts.remove(idheader.getCallId());\n                }\n            // 408 480 486 600 603 : non definitive reject\n            } else if (response.getStatusCode() == Response.REQUEST_TIMEOUT\n                    || response.getStatusCode() == Response\n                        .TEMPORARILY_UNAVAILABLE\n                    || response.getStatusCode() == Response.BUSY_HERE\n                    || response.getStatusCode() == Response.BUSY_EVERYWHERE\n                    || response.getStatusCode() == Response.DECLINE)\n            {\n                logger.debug(\"error received from the network\" + response);\n\n                if (response.getStatusCode() == Response\n                        .TEMPORARILY_UNAVAILABLE)\n                {\n                    changePresenceStatusForContact(contact,\n                            SipStatusEnum.OFFLINE);\n                } else {\n                    changePresenceStatusForContact(contact,\n                            SipStatusEnum.UNKNOWN);\n                }\n                \n                this.subscribedContacts.remove(idheader.getCallId());\n                contact.setClientDialog(null);\n            // definitive reject (or not implemented)\n            } else {\n                logger.debug(\"error received from the network\" + response);\n\n                // we'll never be able to resolve this contact\n                contact.setResolvable(false);\n                changePresenceStatusForContact(contact, SipStatusEnum.UNKNOWN);\n                this.subscribedContacts.remove(idheader.getCallId());\n                contact.setClientDialog(null);\n            }\n\n        // NOTIFY\n        } else if (method.equals(Request.NOTIFY)) {\n            // if it's a final response to a NOTIFY, we try to remove it from\n            // the list of waited NOTIFY end\n            if (response.getStatusCode() != Response.UNAUTHORIZED\n                && response.getStatusCode() != Response\n                    .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(((CallIdHeader) response\n                        .getHeader(CallIdHeader.NAME)).getCallId());\n                }\n            }\n\n            // OK (200)\n            if (response.getStatusCode() == Response.OK) {\n                // simply nothing to do here, the contact received our NOTIFY,\n                // everything is ok\n            // UNAUTHORIZED (401/407)\n            } else if (response.getStatusCode() == Response.UNAUTHORIZED\n                    || response.getStatusCode() == Response\n                        .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                try {\n                    processAuthenticationChallenge(clientTransaction,\n                            response, sourceProvider);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't handle the challenge\");\n\n                    // don't try to tell him anything more\n                    String contactAddress = ((FromHeader)\n                            response.getHeader(FromHeader.NAME)).getAddress()\n                            .getURI().toString();\n                    Contact watcher = getWatcher(contactAddress);\n\n                    if (watcher != null) {\n                        synchronized (this.ourWatchers) {\n                            this.ourWatchers.remove(watcher);\n                        }\n                    }\n                }\n            // every error cause the subscription to be removed\n            // as recommended in rfc3265\n            } else {\n                logger.debug(\"error received from the network\" + response);\n\n                String contactAddress = ((FromHeader)\n                        response.getHeader(FromHeader.NAME)).getAddress()\n                        .getURI().toString();\n                Contact watcher = getWatcher(contactAddress);\n\n                if (watcher != null) {\n                    synchronized (this.ourWatchers) {\n                        this.ourWatchers.remove(watcher);\n                    }\n                }\n            }\n\n        // PUBLISH\n        } else if (method.equals(Request.PUBLISH)) {\n            // if it's a final response to a PUBLISH, we try to remove it from\n            // the list of waited PUBLISH end\n            if (response.getStatusCode() != Response.UNAUTHORIZED\n                && response.getStatusCode() != Response\n                    .PROXY_AUTHENTICATION_REQUIRED\n                && response.getStatusCode() != Response.INTERVAL_TOO_BRIEF)\n            {\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(((CallIdHeader) response\n                        .getHeader(CallIdHeader.NAME)).getCallId());\n                }\n            }\n\n            // OK (200)\n            if (response.getStatusCode() == Response.OK) {\n                // remember the entity tag\n                SIPETagHeader etHeader = (SIPETagHeader)\n                    response.getHeader(SIPETagHeader.NAME);\n\n                // must be one (rfc3903)\n                if (etHeader == null) {\n                    logger.debug(\"can't find the ETag header\");\n                    return;\n                }\n\n                this.distantPAET = etHeader.getETag();\n\n                // schedule a re-publish task\n                ExpiresHeader expires = (ExpiresHeader)\n                    response.getHeader(ExpiresHeader.NAME);\n                \n                if (expires == null) {\n                    logger.error(\"no Expires header in the response\");\n                    return;\n                }\n                \n                try {\n                    // keep one minute of margin\n                    this.timer.schedule(new RePublishTask(),\n                            expires.getExpires() * 1000 - REFRESH_MARGIN);\n                } catch (IllegalArgumentException e) {\n                    logger.debug(\"the expires value seems to be less than a \" +\n                            \"minute, let's assume it\");\n                    \n                    this.timer.schedule(new RePublishTask(),\n                            expires.getExpires() * 1000);\n                }\n                \n            // UNAUTHORIZED (401/407)\n            } else if (response.getStatusCode() == Response.UNAUTHORIZED\n                    || response.getStatusCode() == Response\n                        .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                try {\n                    processAuthenticationChallenge(clientTransaction,\n                            response, sourceProvider);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't handle the challenge\");\n                    return;\n                }\n            // INTERVAL TOO BRIEF (423)\n            } else if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF)\n            {\n                // we get the Min expires and we use it as the interval\n                MinExpiresHeader min = (MinExpiresHeader) \n                    response.getHeader(MinExpiresHeader.NAME);\n                \n                if (min == null) {\n                    logger.error(\"can't find a min expires header in the 423\" +\n                            \" error message\");\n                    return;\n                }\n                \n                // send a new publish with the new expires value\n                Request req = null;\n                try {\n                    req = createPublish(min.getExpires(), true);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't create the new publish request\", e);\n                    return;\n                }\n                \n                ClientTransaction transac = null;\n                try {\n                    transac = this.parentProvider\n                        .getDefaultJainSipProvider().getNewClientTransaction(req);\n                } catch (TransactionUnavailableException e) {\n                    logger.error(\"can't create the client transaction\", e);\n                    return;\n                }\n                \n                try {\n                    transac.sendRequest();\n                } catch (SipException e) {\n                    logger.error(\"can't send the PUBLISH request\", e);\n                    return;\n                }\n                \n            // with every other error, we consider that we have to start a new\n            // communication\n            } else {\n                logger.debug(\"error received from the network\" + response);\n                this.distantPAET = null;\n            }\n        }\n    }","id":42087,"modified_method":"/**\n     * Analyzes the incoming <tt>responseEvent<\/tt> and then forwards it to the\n     * proper event handler.\n     *\n     * @param responseEvent the responseEvent that we received\n     * ProtocolProviderService.\n     */\n    public void processResponse(ResponseEvent responseEvent)\n    {\n        ClientTransaction clientTransaction = responseEvent\n            .getClientTransaction();\n        Response response = responseEvent.getResponse();\n\n        CSeqHeader cseq = ((CSeqHeader)response.getHeader(CSeqHeader.NAME));\n        if (cseq == null)\n        {\n            logger.error(\"An incoming response did not contain a CSeq header\");\n            return;\n        }\n        String method = cseq.getMethod();\n\n        SipProvider sourceProvider = (SipProvider)responseEvent.getSource();\n\n        // SUBSCRIBE\n        if (method.equals(Request.SUBSCRIBE)) {\n            // find the contact\n            CallIdHeader idheader = (CallIdHeader)\n                response.getHeader(CallIdHeader.NAME);\n            ContactSipImpl contact = (ContactSipImpl) this.subscribedContacts\n                .get(idheader.getCallId());\n\n            // if the response is a 423 response, just re-send the request\n            // with a valid expires value\n            if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF) {\n                MinExpiresHeader min = (MinExpiresHeader) \n                    response.getHeader(MinExpiresHeader.NAME);\n                \n                if (min == null) {\n                    logger.error(\"no minimal expires value in this 423 \" +\n                            \"response\");\n                    return;\n                }\n                \n                Request request = responseEvent.getClientTransaction()\n                    .getRequest();\n                \n                ExpiresHeader exp = request.getExpires();\n                \n                try {\n                    exp.setExpires(min.getExpires());\n                } catch (InvalidArgumentException e) {\n                    logger.error(\"can't set the new expires value\", e);\n                    return;\n                }\n                \n                ClientTransaction transac = null;\n                try {\n                    transac = this.parentProvider.getDefaultJainSipProvider()\n                        .getNewClientTransaction(request);\n                } catch (TransactionUnavailableException e) {\n                    logger.error(\"can't create the client transaction\", e);\n                    return;\n                }\n                \n                try {\n                    transac.sendRequest();\n                } catch (SipException e) {\n                    logger.error(\"can't send the new request\", e);\n                    return;\n                }\n                \n                return;\n            }\n            \n            // if it's the response to an unsubscribe message, we just ignore it\n            // whatever the response is however if we need to handle a \n            // challenge, we do it\n            ExpiresHeader expHeader = response.getExpires();\n            if ((expHeader != null && expHeader.getExpires() == 0)\n                    || contact == null) // this handle the unsubscription case\n                                        // where we removed the contact from\n                                        // subscribedContacts\n            {\n                if (response.getStatusCode() == Response.UNAUTHORIZED\n                        || response.getStatusCode() ==\n                            Response.PROXY_AUTHENTICATION_REQUIRED)\n                {\n                    try {\n                        processAuthenticationChallenge(clientTransaction,\n                                response, sourceProvider);\n                    } catch (OperationFailedException e) {\n                        logger.error(\"can't handle the challenge\");\n                    }\n                } else  if (response.getStatusCode() != Response.OK\n                        && response.getStatusCode() != Response.ACCEPTED)\n                {\n                    // this definitivly ends the subscription\n                    synchronized (this.waitedCallIds) {\n                        this.waitedCallIds.remove(idheader.getCallId());\n                    }\n                }\n                // any other cases (200/202) will imply a NOTIFY, so we will\n                // handle the end of a subscription there\n\n                return;\n            }\n\n            try {\n                if (!contact.isResolved()\n                        && response.getStatusCode() != Response.UNAUTHORIZED\n                        && response.getStatusCode() !=\n                            Response.PROXY_AUTHENTICATION_REQUIRED)\n                {\n                    finalizeSubscription(contact,\n                            clientTransaction.getDialog());\n                }\n            } catch (NullPointerException e) {\n                // should not happen\n                logger.debug(\"failed to finalize the subscription of the\" +\n                        \"contact\", e);\n\n                return;\n            }\n\n            // OK (200/202)\n            if (response.getStatusCode() == Response.OK\n                || response.getStatusCode() == Response.ACCEPTED)\n            {\n                if (expHeader == null) {\n                    // not conform to rfc3265\n                    logger.error(\"no Expires header in this response\");\n                    return;\n                }\n                \n                if (contact.getResfreshTask() != null) {\n                    contact.getResfreshTask().cancel();\n                }\n                \n                RefreshSubscriptionTask refresh = \n                    new RefreshSubscriptionTask(contact);\n                contact.setResfreshTask(refresh);\n                \n                try {\n                    // try to keep a margin\n                    this.timer.schedule(refresh,\n                            (expHeader.getExpires() - REFRESH_MARGIN) * 1000);\n                } catch (IllegalArgumentException e) {\n                    logger.debug(\"the expires value seems to be less than a \" +\n                            \"minute, let's assume it\");\n                    \n                    this.timer.schedule(refresh, expHeader.getExpires() * 1000);\n                }\n                \n                // do it to remember the dialog in case of a polling\n                // subscription (which means no call to finalizeSubscription)\n                contact.setClientDialog(clientTransaction.getDialog());\n            // UNAUTHORIZED (401/407)\n            } else if (response.getStatusCode() == Response.UNAUTHORIZED\n                    || response.getStatusCode() == Response\n                        .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                try {\n                    processAuthenticationChallenge(clientTransaction,\n                            response, sourceProvider);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't handle the challenge\");\n\n                    // we probably won't be able to communicate with the contact\n                    changePresenceStatusForContact(contact,\n                            SipStatusEnum.UNKNOWN);\n                    this.subscribedContacts.remove(idheader.getCallId());\n                    contact.setClientDialog(null);\n                }\n            // 408 480 486 600 603 : non definitive reject\n            } else if (response.getStatusCode() == Response.REQUEST_TIMEOUT\n                    || response.getStatusCode() == Response\n                        .TEMPORARILY_UNAVAILABLE\n                    || response.getStatusCode() == Response.BUSY_HERE\n                    || response.getStatusCode() == Response.BUSY_EVERYWHERE\n                    || response.getStatusCode() == Response.DECLINE)\n            {\n                logger.debug(\"error received from the network\" + response);\n\n                if (response.getStatusCode() == Response\n                        .TEMPORARILY_UNAVAILABLE)\n                {\n                    changePresenceStatusForContact(contact,\n                            SipStatusEnum.OFFLINE);\n                } else {\n                    changePresenceStatusForContact(contact,\n                            SipStatusEnum.UNKNOWN);\n                }\n                \n                this.subscribedContacts.remove(idheader.getCallId());\n                contact.setClientDialog(null);\n            // definitive reject (or not implemented)\n            } else {\n                logger.debug(\"error received from the network\" + response);\n\n                // we'll never be able to resolve this contact\n                contact.setResolvable(false);\n                changePresenceStatusForContact(contact, SipStatusEnum.UNKNOWN);\n                this.subscribedContacts.remove(idheader.getCallId());\n                contact.setClientDialog(null);\n            }\n\n        // NOTIFY\n        } else if (method.equals(Request.NOTIFY)) {\n            // if it's a final response to a NOTIFY, we try to remove it from\n            // the list of waited NOTIFY end\n            if (response.getStatusCode() != Response.UNAUTHORIZED\n                && response.getStatusCode() != Response\n                    .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(((CallIdHeader) response\n                        .getHeader(CallIdHeader.NAME)).getCallId());\n                }\n            }\n\n            // OK (200)\n            if (response.getStatusCode() == Response.OK) {\n                // simply nothing to do here, the contact received our NOTIFY,\n                // everything is ok\n            // UNAUTHORIZED (401/407)\n            } else if (response.getStatusCode() == Response.UNAUTHORIZED\n                    || response.getStatusCode() == Response\n                        .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                try {\n                    processAuthenticationChallenge(clientTransaction,\n                            response, sourceProvider);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't handle the challenge\");\n\n                    // don't try to tell him anything more\n                    String contactAddress = ((FromHeader)\n                            response.getHeader(FromHeader.NAME)).getAddress()\n                            .getURI().toString();\n                    Contact watcher = getWatcher(contactAddress);\n\n                    if (watcher != null) {\n                        synchronized (this.ourWatchers) {\n                            this.ourWatchers.remove(watcher);\n                        }\n                    }\n                }\n            // every error cause the subscription to be removed\n            // as recommended in rfc3265\n            } else {\n                logger.debug(\"error received from the network\" + response);\n\n                String contactAddress = ((FromHeader)\n                        response.getHeader(FromHeader.NAME)).getAddress()\n                        .getURI().toString();\n                Contact watcher = getWatcher(contactAddress);\n\n                if (watcher != null) {\n                    synchronized (this.ourWatchers) {\n                        this.ourWatchers.remove(watcher);\n                    }\n                }\n            }\n\n        // PUBLISH\n        } else if (method.equals(Request.PUBLISH)) {\n            // if it's a final response to a PUBLISH, we try to remove it from\n            // the list of waited PUBLISH end\n            if (response.getStatusCode() != Response.UNAUTHORIZED\n                && response.getStatusCode() != Response\n                    .PROXY_AUTHENTICATION_REQUIRED\n                && response.getStatusCode() != Response.INTERVAL_TOO_BRIEF)\n            {\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(((CallIdHeader) response\n                        .getHeader(CallIdHeader.NAME)).getCallId());\n                }\n            }\n\n            // OK (200)\n            if (response.getStatusCode() == Response.OK) {\n                // remember the entity tag\n                SIPETagHeader etHeader = (SIPETagHeader)\n                    response.getHeader(SIPETagHeader.NAME);\n\n                // must be one (rfc3903)\n                if (etHeader == null) {\n                    logger.debug(\"can't find the ETag header\");\n                    return;\n                }\n\n                this.distantPAET = etHeader.getETag();\n\n                // schedule a re-publish task\n                ExpiresHeader expires = (ExpiresHeader)\n                    response.getHeader(ExpiresHeader.NAME);\n                \n                if (expires == null) {\n                    logger.error(\"no Expires header in the response\");\n                    return;\n                }\n                \n                // just to be sure to not have two refreshing task\n                if (this.republishTask != null) {\n                    this.republishTask.cancel();\n                }\n                \n                this.republishTask = new RePublishTask();\n                \n                try {\n                    // keep a margin\n                    this.timer.schedule(this.republishTask,\n                            (expires.getExpires() - REFRESH_MARGIN) * 1000);\n                } catch (IllegalArgumentException e) {\n                    logger.debug(\"the expires value seems to be less than a \" +\n                            \"minute, let's assume it\");\n                    \n                    this.timer.schedule(this.republishTask,\n                            expires.getExpires() * 1000);\n                }\n                \n            // UNAUTHORIZED (401/407)\n            } else if (response.getStatusCode() == Response.UNAUTHORIZED\n                    || response.getStatusCode() == Response\n                        .PROXY_AUTHENTICATION_REQUIRED)\n            {\n                try {\n                    processAuthenticationChallenge(clientTransaction,\n                            response, sourceProvider);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't handle the challenge\");\n                    return;\n                }\n            // INTERVAL TOO BRIEF (423)\n            } else if (response.getStatusCode() == Response.INTERVAL_TOO_BRIEF)\n            {\n                // we get the Min expires and we use it as the interval\n                MinExpiresHeader min = (MinExpiresHeader) \n                    response.getHeader(MinExpiresHeader.NAME);\n                \n                if (min == null) {\n                    logger.error(\"can't find a min expires header in the 423\" +\n                            \" error message\");\n                    return;\n                }\n                \n                // send a new publish with the new expires value\n                Request req = null;\n                try {\n                    req = createPublish(min.getExpires(), true);\n                } catch (OperationFailedException e) {\n                    logger.error(\"can't create the new publish request\", e);\n                    return;\n                }\n                \n                ClientTransaction transac = null;\n                try {\n                    transac = this.parentProvider\n                        .getDefaultJainSipProvider().getNewClientTransaction(req);\n                } catch (TransactionUnavailableException e) {\n                    logger.error(\"can't create the client transaction\", e);\n                    return;\n                }\n                \n                try {\n                    transac.sendRequest();\n                } catch (SipException e) {\n                    logger.error(\"can't send the PUBLISH request\", e);\n                    return;\n                }\n                \n            // with every other error, we consider that we have to start a new\n            // communication\n            } else {\n                logger.debug(\"error received from the network\" + response);\n                this.distantPAET = null;\n            }\n        }\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies all registered listeners of the new event.\n     *\n     * @param source the contact that has caused the event.\n     * @param parentGroup the group that contains the source contact.\n     * @param eventID an identifier of the event to dispatch.\n     */\n    public void fireSubscriptionEvent(ContactSipImpl  source,\n                                      ContactGroup parentGroup,\n                                      int          eventID)\n    {\n        SubscriptionEvent evt  = new SubscriptionEvent(source\n            , this.parentProvider\n            , parentGroup\n            , eventID);\n\n        Iterator listeners = null;\n        synchronized (this.subscriptionListeners)\n        {\n            listeners = new ArrayList(this.subscriptionListeners).iterator();\n        }\n\n        while (listeners.hasNext())\n        {\n            SubscriptionListener listener\n                = (SubscriptionListener) listeners.next();\n\n            if(eventID == SubscriptionEvent.SUBSCRIPTION_CREATED)\n            {\n                listener.subscriptionCreated(evt);\n            }\n            else if (eventID == SubscriptionEvent.SUBSCRIPTION_FAILED)\n            {\n                listener.subscriptionFailed(evt);\n            }\n            else if (eventID == SubscriptionEvent.SUBSCRIPTION_REMOVED)\n            {\n                listener.subscriptionRemoved(evt);\n            }\n        }\n    }","id":42088,"modified_method":"/**\n     * Notifies all registered listeners of the new event.\n     *\n     * @param source the contact that has caused the event.\n     * @param parentGroup the group that contains the source contact.\n     * @param eventID an identifier of the event to dispatch.\n     */\n    public void fireSubscriptionEvent(ContactSipImpl  source,\n                                      ContactGroup parentGroup,\n                                      int          eventID)\n    {\n        SubscriptionEvent evt  = new SubscriptionEvent(source\n            , this.parentProvider\n            , parentGroup\n            , eventID);\n\n        Iterator listeners = null;\n        synchronized (this.subscriptionListeners)\n        {\n            listeners = new ArrayList(this.subscriptionListeners).iterator();\n        }\n\n        while (listeners.hasNext())\n        {\n            SubscriptionListener listener\n                = (SubscriptionListener) listeners.next();\n\n            if(eventID == SubscriptionEvent.SUBSCRIPTION_CREATED)\n            {\n                listener.subscriptionCreated(evt);\n            }\n            else if (eventID == SubscriptionEvent.SUBSCRIPTION_FAILED)\n            {\n                listener.subscriptionFailed(evt);\n            }\n            else if (eventID == SubscriptionEvent.SUBSCRIPTION_REMOVED)\n            {\n                listener.subscriptionRemoved(evt);\n            }\n            else if (eventID == SubscriptionEvent.SUBSCRIPTION_RESOLVED) \n            {\n                listener.subscriptionResolved(evt);\n            }\n        }\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies all registered listeners of the new event.\n     *\n     * @param oldValue the presence status we were in before the change.\n     */\n    private void fireProviderStatusChangeEvent(PresenceStatus oldValue)\n    {\n        ProviderPresenceStatusChangeEvent evt\n            = new ProviderPresenceStatusChangeEvent(this.parentProvider,\n                                        oldValue, this.getPresenceStatus());\n\n        logger.debug(\"Dispatching Provider Status Change. Listeners=\"\n                + this.providerPresenceStatusListeners.size()\n                + \" evt=\" + evt);\n\n        Iterator listeners = null;\n        synchronized (this.providerPresenceStatusListeners)\n        {\n            listeners = new ArrayList(this.providerPresenceStatusListeners)\n                .iterator();\n        }\n\n        while (listeners.hasNext())\n        {\n            ProviderPresenceStatusListener listener\n                = (ProviderPresenceStatusListener) listeners.next();\n\n            listener.providerStatusChanged(evt);\n            logger.debug(\"reglistener: \" + listener);\n        }\n        logger.debug(\"status dispatching done.\");\n    }","id":42089,"modified_method":"/**\n     * Notifies all registered listeners of the new event.\n     *\n     * @param oldValue the presence status we were in before the change.\n     */\n    private void fireProviderStatusChangeEvent(PresenceStatus oldValue)\n    {\n        ProviderPresenceStatusChangeEvent evt\n            = new ProviderPresenceStatusChangeEvent(this.parentProvider,\n                                        oldValue, this.getPresenceStatus());\n\n        logger.debug(\"Dispatching Provider Status Change. Listeners=\"\n                + this.providerPresenceStatusListeners.size()\n                + \" evt=\" + evt);\n\n        Iterator listeners = null;\n        synchronized (this.providerPresenceStatusListeners)\n        {\n            listeners = new ArrayList(this.providerPresenceStatusListeners)\n                .iterator();\n        }\n\n        while (listeners.hasNext())\n        {\n            ProviderPresenceStatusListener listener\n                = (ProviderPresenceStatusListener) listeners.next();\n\n            listener.providerStatusChanged(evt);\n        }\n        logger.debug(\"status dispatching done.\");\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Requests the provider to enter into a status corresponding to the\n     * specified paramters. Note that calling this method does not necessarily\n     * imply that the requested status would be entered. This method would\n     * return right after being called and the caller should add itself as\n     * a listener to this class in order to get notified when the state has\n     * actually changed.\n     *\n     * @param status the PresenceStatus as returned by getRequestableStatusSet\n     * @param statusMsg the message that should be set as the reason to\n     * enter that status\n     *\n     * @throws IllegalArgumentException if the status requested is not a valid\n     * PresenceStatus supported by this provider.\n     * @throws java.lang.IllegalStateException if the provider is not currently\n     * registered.\n     * @throws OperationFailedException with code NETWORK_FAILURE if publishing\n     * the status fails due to a network error.\n     */\n    public void publishPresenceStatus(PresenceStatus status,\n            String statusMsg)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        PresenceStatus oldStatus = this.presenceStatus;\n        this.presenceStatus = status;\n        this.statusMessage = statusMsg;\n\n        // inform the listener of our change in the status\n        fireProviderStatusChangeEvent(oldStatus);\n\n        // in the offline status, the protocol provider is already unregistered\n        if (!status.equals(SipStatusEnum.OFFLINE)) {\n            assertConnected();\n        }\n\n        if (status.equals(SipStatusEnum.OFFLINE) && !this.useDistantPA) {\n            unsubscribeToAllContact();\n        }\n\n        // now inform our distant presence agent if we have one\n        if (this.useDistantPA) {\n            Request req = createPublish(PUBLISH_DEFAULT_EXPIRE, true);\n\n            if (status.equals(SipStatusEnum.OFFLINE)) {\n                // remember the callid to be sure that the publish arrived\n                // before unregister\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.add(((CallIdHeader)\n                        req.getHeader(CallIdHeader.NAME)).getCallId());\n                }\n            }\n\n            ClientTransaction transac = null;\n            try {\n                transac = this.parentProvider\n                    .getDefaultJainSipProvider().getNewClientTransaction(req);\n            } catch (TransactionUnavailableException e) {\n                logger.debug(\"can't create the client transaction\", e);\n                throw new OperationFailedException(\n                        \"can't create the client transaction\",\n                        OperationFailedException.NETWORK_FAILURE);\n            }\n\n            try {\n                transac.sendRequest();\n            } catch (SipException e) {\n                logger.debug(\"can't send the PUBLISH request\");\n                throw new OperationFailedException(\n                        \"can't send the PUBLISH request\",\n                        OperationFailedException.NETWORK_FAILURE);\n            }\n\n        // no distant presence agent, send notify to every one\n        } else {\n            synchronized (this.ourWatchers) {   // avoid any modification during\n                                                // the parsing of ourWatchers\n                Iterator iter = this.ourWatchers.iterator();\n                ContactSipImpl me = (ContactSipImpl) getLocalContact();\n\n                while (iter.hasNext()) {\n                    ContactSipImpl contact = (ContactSipImpl) iter.next();\n\n                    // let the subscription end before sending him a new status\n                    if (!contact.isResolved()) {\n                        continue;\n                    }\n\n                    ClientTransaction transac = null;\n                    try {\n                        if (status.equals(SipStatusEnum.OFFLINE)) {\n                            transac = createNotify(contact,\n                                    getPidfPresenceStatus(me),\n                                    SubscriptionStateHeader.TERMINATED,\n                                    SubscriptionStateHeader.PROBATION);\n\n                            // register the callid to wait it before unregister\n                            synchronized (this.waitedCallIds) {\n                                this.waitedCallIds.add(transac.getDialog()\n                                    .getCallId().getCallId());\n                            }\n                        } else {\n                            transac = createNotify(contact,\n                                        getPidfPresenceStatus(me),\n                                        SubscriptionStateHeader.ACTIVE, null);\n                        }\n                    } catch (OperationFailedException e) {\n                        logger.debug(\"failed to create the new notify\", e);\n                        return;\n                    }\n\n                    try {\n                        contact.getServerDialog().sendRequest(transac);\n                    } catch (Exception e) {\n                        logger.debug(\"Can't send the request\");\n                        return;\n                    }\n                }\n\n                if (status.equals(SipStatusEnum.OFFLINE)) {\n                    synchronized (this.ourWatchers) {\n                        this.ourWatchers.removeAllElements();\n                    }\n                }\n            }\n        }\n    }","id":42090,"modified_method":"/**\n     * Requests the provider to enter into a status corresponding to the\n     * specified paramters.\n     *\n     * @param status the PresenceStatus as returned by\n     *   getRequestableStatusSet\n     * @param statusMessage the message that should be set as the reason to\n     *   enter that status\n     * @throws IllegalArgumentException if the status requested is not a\n     *   valid PresenceStatus supported by this provider.\n     * @throws IllegalStateException if the provider is not currently\n     *   registered.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   publishing the status fails due to a network error.\n     */\n    public void publishPresenceStatus(PresenceStatus status,\n            String statusMsg)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        PresenceStatus oldStatus = this.presenceStatus;\n        this.presenceStatus = status;\n        String oldMessage = this.statusMessage;\n        this.statusMessage = statusMsg;\n\n        // inform the listeners of these changes\n        this.fireProviderStatusChangeEvent(oldStatus);\n        this.fireProviderMsgStatusChangeEvent(oldMessage);\n\n        // in the offline status, the protocol provider is already unregistered\n        if (!status.equals(SipStatusEnum.OFFLINE)) {\n            assertConnected();\n        }\n\n        if (status.equals(SipStatusEnum.OFFLINE)) {\n            unsubscribeToAllContact();\n        }\n\n        // now inform our distant presence agent if we have one\n        if (this.useDistantPA) {\n            Request req = createPublish(PUBLISH_DEFAULT_EXPIRE, true);\n\n            if (status.equals(SipStatusEnum.OFFLINE)) {\n                // remember the callid to be sure that the publish arrived\n                // before unregister\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.add(((CallIdHeader)\n                        req.getHeader(CallIdHeader.NAME)).getCallId());\n                }\n            }\n\n            ClientTransaction transac = null;\n            try {\n                transac = this.parentProvider\n                    .getDefaultJainSipProvider().getNewClientTransaction(req);\n            } catch (TransactionUnavailableException e) {\n                logger.debug(\"can't create the client transaction\", e);\n                throw new OperationFailedException(\n                        \"can't create the client transaction\",\n                        OperationFailedException.NETWORK_FAILURE);\n            }\n\n            try {\n                transac.sendRequest();\n            } catch (SipException e) {\n                logger.debug(\"can't send the PUBLISH request\");\n                throw new OperationFailedException(\n                        \"can't send the PUBLISH request\",\n                        OperationFailedException.NETWORK_FAILURE);\n            }\n\n        // no distant presence agent, send notify to every one\n        } else {\n            synchronized (this.ourWatchers) {   // avoid any modification during\n                                                // the parsing of ourWatchers\n                Iterator iter = this.ourWatchers.iterator();\n                ContactSipImpl me = (ContactSipImpl) getLocalContact();\n\n                while (iter.hasNext()) {\n                    ContactSipImpl contact = (ContactSipImpl) iter.next();\n\n                    // let the subscription end before sending him a new status\n                    if (!contact.isResolved()) {\n                        continue;\n                    }\n\n                    ClientTransaction transac = null;\n                    try {\n                        if (status.equals(SipStatusEnum.OFFLINE)) {\n                            transac = createNotify(contact,\n                                    getPidfPresenceStatus(me),\n                                    SubscriptionStateHeader.TERMINATED,\n                                    SubscriptionStateHeader.PROBATION);\n\n                            // register the callid to wait it before unregister\n                            synchronized (this.waitedCallIds) {\n                                this.waitedCallIds.add(transac.getDialog()\n                                    .getCallId().getCallId());\n                            }\n                        } else {\n                            transac = createNotify(contact,\n                                        getPidfPresenceStatus(me),\n                                        SubscriptionStateHeader.ACTIVE, null);\n                        }\n                    } catch (OperationFailedException e) {\n                        logger.debug(\"failed to create the new notify\", e);\n                        return;\n                    }\n\n                    try {\n                        contact.getServerDialog().sendRequest(transac);\n                    } catch (Exception e) {\n                        logger.debug(\"Can't send the request\");\n                        return;\n                    }\n                }\n\n                if (status.equals(SipStatusEnum.OFFLINE)) {\n                    synchronized (this.ourWatchers) {\n                        this.ourWatchers.removeAllElements();\n                    }\n                }\n            }\n        }\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of this operation set keeping a reference to the\n     * specified parent <tt>provider<\/tt>.\n     * @param provider the ProtocolProviderServiceSipImpl instance that\n     * created us.\n     */\n    public OperationSetPresenceSipImpl(ProtocolProviderServiceSipImpl provider)\n    {\n        this.parentProvider = provider;\n        this.contactListRoot = new ContactGroupSipImpl(\"RootGroup\", provider);\n\n        //add our registration listener\n        this.parentProvider.addRegistrationStateChangeListener(\n            new RegistrationListener());\n\n        this.subscribedContacts = new Hashtable();\n        this.ourWatchers = new Vector();\n        this.waitedCallIds = new Vector();\n\n        this.parentProvider.registerMethodProcessor(Request.SUBSCRIBE, this);\n        this.parentProvider.registerMethodProcessor(Request.NOTIFY, this);\n        this.parentProvider.registerMethodProcessor(Request.PUBLISH, this);\n    }","id":42091,"modified_method":"/**\n     * Creates an instance of this operation set keeping a reference to the\n     * specified parent <tt>provider<\/tt>.\n     * @param provider the ProtocolProviderServiceSipImpl instance that\n     * created us.\n     */\n    public OperationSetPresenceSipImpl(ProtocolProviderServiceSipImpl provider)\n    {\n        this.parentProvider = provider;\n        this.contactListRoot = new ContactGroupSipImpl(\"RootGroup\", provider);\n\n        //add our registration listener\n        this.parentProvider.addRegistrationStateChangeListener(\n            new RegistrationListener());\n\n        this.parentProvider.registerMethodProcessor(Request.SUBSCRIBE, this);\n        this.parentProvider.registerMethodProcessor(Request.NOTIFY, this);\n        this.parentProvider.registerMethodProcessor(Request.PUBLISH, this);\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handler for incoming authorization requests. An authorization request\n     * notifies the user that someone is trying to add her to their contact list\n     * and requires her to approve or reject authorization for that action.\n     *\n     * @param handler an instance of an AuthorizationHandler for authorization\n     * requests coming from other users requesting permission add us to their\n     * contact list.\n     */\n    public void setAuthorizationHandler(AuthorizationHandler handler) {\n        this.authorizationHandler = handler;\n    }","id":42092,"modified_method":"/**\n     * Handler for incoming authorization requests.\n     *\n     * @param handler an instance of an AuthorizationHandler for\n     *   authorization requests coming from other users requesting\n     *   permission add us to their contact list.\n     */\n    public void setAuthorizationHandler(AuthorizationHandler handler) {\n        // authorizations aren't supported by this implementation\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a subscription for the presence status of the contact corresponding\n     * to the specified contactIdentifier. Note that apart from an exception in\n     * the case of an immediate failure, the method won't return any indication\n     * of success or failure. That would happen later on through a\n     * SubscriptionEvent generated by one of the methods of the\n     * SubscriptionListener.\n     * We assume here that the user didn't specify any alternative presence URI\n     * for this contact.\n     *\n     * This subscription is not going to be persistent (as opposed to\n     * subscriptions added from the OperationSetPersistentPresence.subscribe()\n     * method)\n     * @param contactIdentifier the identifier of the contact whose status\n     * updates we are subscribing for.\n     *\n     * @throws OperationFailedException with code NETWORK_FAILURE if subscribing\n     * fails due to errors experienced during network communication\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     * known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is not\n     * registered/signed on a public service.\n     */\n    public void subscribe(String contactIdentifier)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        subscribe(this.contactListRoot, contactIdentifier);\n    }","id":42093,"modified_method":"/**\n     * Adds a subscription for the presence status of the contact\n     * corresponding to the specified contactIdentifier.\n     *\n     * @param contactIdentifier the identifier of the contact whose status\n     *   updates we are subscribing for. <p>\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     *   known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is\n     *   not registered/signed on a public service.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   subscribing fails due to errors experienced during network\n     *   communication\n     */\n    public void subscribe(String contactIdentifier)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n    {\n        subscribe(this.contactListRoot, contactIdentifier);\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a NOTIFY request corresponding to the provided arguments.\n     * This request MUST be sent using <tt>dialog.sendRequest<\/tt>\n     *\n     * @param contact The contact to notify\n     * @param doc The presence document to send\n     * @param subscriptionState The current subscription state\n     * @param reason The reason of this subscription state (may be null)\n     *\n     * @return a valid <tt>ClientTransaction<\/tt> ready to send the request\n     *\n     * @throws OperationFailedException if something goes wrong during the\n     * creation of the request\n     */\n    private ClientTransaction createNotify(ContactSipImpl contact, byte[] doc,\n            String subscriptionState, String reason)\n    throws OperationFailedException\n    {\n        Dialog dialog = contact.getServerDialog();\n\n        if (dialog == null) {\n            throw new OperationFailedException(\"the server dialog of the \" +\n                    \"contact is null\", OperationFailedException.INTERNAL_ERROR);\n        }\n\n        Request req = null;\n        try {\n            req = dialog.createRequest(Request.NOTIFY);\n        } catch (SipException e) {\n            logger.debug(\"Can't create the NOTIFY message\");\n            throw new OperationFailedException(\"Can't create the NOTIFY\" +\n                    \" message\", OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        // Address\n        InetAddress destinationInetAddress = null;\n        Address toAddress = dialog.getRemoteTarget();\n\n        // no Contact field\n        if (toAddress == null) {\n            toAddress = dialog.getRemoteParty();\n        }\n\n        try\n        {\n           destinationInetAddress = InetAddress.getByName(\n                ((SipURI) toAddress.getURI()).getHost());\n        }\n        catch (UnknownHostException ex)\n        {\n            throw new OperationFailedException(\n                ((SipURI) toAddress.getURI()).getHost()\n                + \" is not a valid internet address \",\n                OperationFailedException.INTERNAL_ERROR, ex);\n        }\n\n        ArrayList viaHeaders = null;\n        MaxForwardsHeader maxForwards = null;\n\n        try {\n            //ViaHeaders\n            viaHeaders = this.parentProvider.getLocalViaHeaders(\n                destinationInetAddress\n                , this.parentProvider.getDefaultListeningPoint());\n\n            //MaxForwards\n            maxForwards = this.parentProvider\n                .getMaxForwardsHeader();\n        } catch (OperationFailedException e) {\n            logger.debug(\"cant retrive the via headers or the max forward\",\n                    e);\n            throw new OperationFailedException(\"Can't create the NOTIFY\" +\n                    \" message\", OperationFailedException.INTERNAL_ERROR);\n        }\n\n        EventHeader evHeader = null;\n        try {\n            evHeader = this.parentProvider.getHeaderFactory()\n                .createEventHeader(\"presence\");\n        } catch (ParseException e) {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the EventHeader\", e);\n            throw new OperationFailedException(\"Can't create the Event\" +\n                    \" header\", OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        // Contact\n        ContactHeader contactHeader = this.parentProvider\n            .getContactHeader();\n\n        // Subscription-State\n        SubscriptionStateHeader sStateHeader = null;\n        try {\n            sStateHeader = this.parentProvider\n                .getHeaderFactory().createSubscriptionStateHeader(\n                        subscriptionState);\n\n            if (reason != null && !reason.trim().equals(\"\")) {\n                sStateHeader.setReasonCode(reason);\n            }\n        } catch (ParseException e) {\n            // should never happen\n            logger.debug(\"can't create the Subscription-State header\", e);\n            throw new OperationFailedException(\"Can't create the \" +\n                    \"Subscription-State header\",\n                    OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        // Content-type\n        ContentTypeHeader cTypeHeader = null;\n        try {\n            cTypeHeader = this.parentProvider\n                .getHeaderFactory().createContentTypeHeader(\"application\",\n                    PIDF_XML);\n        } catch (ParseException e) {\n            // should never happen\n            logger.debug(\"can't create the Content-Type header\", e);\n            throw new OperationFailedException(\"Can't create the \" +\n                    \"Content-type header\",\n                    OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        req.setHeader(maxForwards);\n        req.setHeader(evHeader);\n        req.setHeader(sStateHeader);\n        req.setHeader(contactHeader);\n\n        // create the transaction (then add the via header as recommended\n        // by the jain-sip documentation at:\n        // http://snad.ncsl.nist.gov/proj/iptel/jain-sip-1.2\n        // /javadoc/javax/sip/Dialog.html#createRequest(java.lang.String)\n        ClientTransaction transac = null;\n        try\n        {\n            transac = this.parentProvider.getDefaultJainSipProvider()\n                .getNewClientTransaction(req);\n        }\n        catch (TransactionUnavailableException ex)\n        {\n            logger.error(\n                \"Failed to create subscriptionTransaction.\\n\"\n                + \"This is most probably a network connection error.\"\n                , ex);\n\n            throw new OperationFailedException(\"Can't create the \" +\n                    \"Content-length header\",\n                    OperationFailedException.NETWORK_FAILURE, ex);\n        }\n\n        req.addHeader((Header) viaHeaders.get(0));\n\n        // add the content\n        try {\n            req.setContent(doc, cTypeHeader);\n        } catch (ParseException e) {\n            logger.debug(\"Failed to add the presence document\", e);\n            throw new OperationFailedException(\"Can't add the presence \" +\n                    \"document to the request\",\n                    OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        return transac;\n    }","id":42094,"modified_method":"/**\n     * Creates a NOTIFY request corresponding to the provided arguments.\n     * This request MUST be sent using <tt>dialog.sendRequest<\/tt>\n     *\n     * @param contact The contact to notify\n     * @param doc The presence document to send\n     * @param subscriptionState The current subscription state\n     * @param reason The reason of this subscription state (may be null)\n     *\n     * @return a valid <tt>ClientTransaction<\/tt> ready to send the request\n     *\n     * @throws OperationFailedException if something goes wrong during the\n     * creation of the request\n     */\n    private ClientTransaction createNotify(ContactSipImpl contact, byte[] doc,\n            String subscriptionState, String reason)\n    throws OperationFailedException\n    {\n        Dialog dialog = contact.getServerDialog();\n\n        if (dialog == null) {\n            throw new OperationFailedException(\"the server dialog of the \" +\n                    \"contact is null\", OperationFailedException.INTERNAL_ERROR);\n        }\n\n        Request req = null;\n        try {\n            req = dialog.createRequest(Request.NOTIFY);\n        } catch (SipException e) {\n            logger.debug(\"Can't create the NOTIFY message\");\n            throw new OperationFailedException(\"Can't create the NOTIFY\" +\n                    \" message\", OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        // Address\n        InetAddress destinationInetAddress = null;\n        Address toAddress = dialog.getRemoteTarget();\n\n        // no Contact field\n        if (toAddress == null) {\n            toAddress = dialog.getRemoteParty();\n        }\n\n        try\n        {\n           destinationInetAddress = InetAddress.getByName(\n                ((SipURI) toAddress.getURI()).getHost());\n        }\n        catch (UnknownHostException ex)\n        {\n            throw new OperationFailedException(\n                ((SipURI) toAddress.getURI()).getHost()\n                + \" is not a valid internet address \",\n                OperationFailedException.INTERNAL_ERROR, ex);\n        }\n\n        ArrayList viaHeaders = null;\n        MaxForwardsHeader maxForwards = null;\n\n        try {\n            //ViaHeaders\n            viaHeaders = this.parentProvider.getLocalViaHeaders(\n                destinationInetAddress\n                , this.parentProvider.getDefaultListeningPoint());\n\n            //MaxForwards\n            maxForwards = this.parentProvider\n                .getMaxForwardsHeader();\n        } catch (OperationFailedException e) {\n            logger.debug(\"cant retrive the via headers or the max forward\",\n                    e);\n            throw new OperationFailedException(\"Can't create the NOTIFY\" +\n                    \" message\", OperationFailedException.INTERNAL_ERROR);\n        }\n\n        EventHeader evHeader = null;\n        try {\n            evHeader = this.parentProvider.getHeaderFactory()\n                .createEventHeader(\"presence\");\n        } catch (ParseException e) {\n            //these two should never happen.\n            logger.error(\n                \"An unexpected error occurred while\"\n                + \"constructing the EventHeader\", e);\n            throw new OperationFailedException(\"Can't create the Event\" +\n                    \" header\", OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        // Contact\n        ContactHeader contactHeader = this.parentProvider\n            .getContactHeader();\n\n        // Subscription-State\n        SubscriptionStateHeader sStateHeader = null;\n        try {\n            sStateHeader = this.parentProvider\n                .getHeaderFactory().createSubscriptionStateHeader(\n                        subscriptionState);\n\n            if (reason != null && reason.trim().length() != 0) {\n                sStateHeader.setReasonCode(reason);\n            }\n        } catch (ParseException e) {\n            // should never happen\n            logger.debug(\"can't create the Subscription-State header\", e);\n            throw new OperationFailedException(\"Can't create the \" +\n                    \"Subscription-State header\",\n                    OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        // Content-type\n        ContentTypeHeader cTypeHeader = null;\n        try {\n            cTypeHeader = this.parentProvider\n                .getHeaderFactory().createContentTypeHeader(\"application\",\n                    PIDF_XML);\n        } catch (ParseException e) {\n            // should never happen\n            logger.debug(\"can't create the Content-Type header\", e);\n            throw new OperationFailedException(\"Can't create the \" +\n                    \"Content-type header\",\n                    OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        req.setHeader(maxForwards);\n        req.setHeader(evHeader);\n        req.setHeader(sStateHeader);\n        req.setHeader(contactHeader);\n\n        // create the transaction (then add the via header as recommended\n        // by the jain-sip documentation at:\n        // http://snad.ncsl.nist.gov/proj/iptel/jain-sip-1.2\n        // /javadoc/javax/sip/Dialog.html#createRequest(java.lang.String))\n        ClientTransaction transac = null;\n        try\n        {\n            transac = this.parentProvider.getDefaultJainSipProvider()\n                .getNewClientTransaction(req);\n        }\n        catch (TransactionUnavailableException ex)\n        {\n            logger.error(\n                \"Failed to create subscriptionTransaction.\\n\"\n                + \"This is most probably a network connection error.\"\n                , ex);\n\n            throw new OperationFailedException(\"Can't create the \" +\n                    \"Content-length header\",\n                    OperationFailedException.NETWORK_FAILURE, ex);\n        }\n\n        req.addHeader((Header) viaHeaders.get(0));\n\n        // add the content\n        try {\n            req.setContent(doc, cTypeHeader);\n        } catch (ParseException e) {\n            logger.debug(\"Failed to add the presence document\", e);\n            throw new OperationFailedException(\"Can't add the presence \" +\n                    \"document to the request\",\n                    OperationFailedException.INTERNAL_ERROR, e);\n        }\n\n        return transac;\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Process a request from a distant contact\n     *\n     * @param requestEvent the <tt>RequestEvent<\/tt> containing the newly\n     * received request.\n     */\n    public void processRequest(RequestEvent requestEvent)\n    {\n        ServerTransaction serverTransaction = requestEvent\n            .getServerTransaction();\n        SipProvider jainSipProvider = (SipProvider) requestEvent.getSource();\n        Request request = requestEvent.getRequest();\n\n        if (serverTransaction == null)\n        {\n            try\n            {\n                serverTransaction = jainSipProvider.getNewServerTransaction(\n                    request);\n            }\n            catch (TransactionAlreadyExistsException ex)\n            {\n                //let's not scare the user and only log a message\n                logger.error(\"Failed to create a new server\"\n                    + \"transaction for an incoming request\\n\"\n                    + \"(Next message contains the request)\"\n                    , ex);\n                return;\n            }\n            catch (TransactionUnavailableException ex)\n            {\n                //let's not scare the user and only log a message\n                logger.error(\"Failed to create a new server\"\n                    + \"transaction for an incoming request\\n\"\n                    + \"(Next message contains the request)\"\n                    , ex);\n                    return;\n            }\n        }\n\n        EventHeader eventHeader = (EventHeader)\n            request.getHeader(EventHeader.NAME);\n\n        if (eventHeader == null || !eventHeader.getEventType()\n                .equalsIgnoreCase(\"presence\"))\n        {\n            // we are not concerned by this request, perhaps another\n            // listener is ?\n            \n            // don't send a 489 / Bad event answer here\n            return;\n        }\n\n\n        // NOTIFY\n        if (request.getMethod().equals(Request.NOTIFY)) {\n            Response response = null;\n\n            logger.debug(\"notify received\");\n\n            SubscriptionStateHeader sstateHeader = (SubscriptionStateHeader)\n                request.getHeader(SubscriptionStateHeader.NAME);\n\n            // notify must contain one (rfc3265)\n            if (sstateHeader == null) {\n                logger.error(\"no subscription state in this request\");\n                return;\n            }\n\n            // first try to accept the contact if the contact is pending\n            // it's possible if the NOTIFY arrives before the OK\n            CallIdHeader idheader = (CallIdHeader) request.getHeader(\n                    CallIdHeader.NAME);\n            ContactSipImpl contact = (ContactSipImpl) this.subscribedContacts\n                .get(idheader.getCallId());\n\n            if (contact != null && !sstateHeader.getState().equalsIgnoreCase(\n                    SubscriptionStateHeader.TERMINATED) && !contact\n                    .isResolved())\n            {\n                logger.debug(\"contact still pending while NOTIFY received\");\n                try {\n                    finalizeSubscription(contact,\n                            serverTransaction.getDialog());\n                } catch (NullPointerException e) {\n                    logger.debug(\"failed to finalize the subscription of the\" +\n                            \"contact\", e);\n                    return;\n                }\n            }\n\n            // see if the notify correspond to an existing subscription\n            if (contact == null && !sstateHeader.getState().equalsIgnoreCase(\n                    SubscriptionStateHeader.TERMINATED)) {\n                logger.debug(\"contact not found for callid : \" + \n                        idheader.getCallId());\n\n                // try to remove the callid from the list if we were excpeting\n                // this end (if it's the last notify of a subscription we just\n                // stopped\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(idheader.getCallId());\n                }\n\n                // send a 481 response (rfc3625)\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(\n                            Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,\n                            request);\n                } catch (ParseException e) {\n                    logger.debug(\"failed to create the 481 response\", e);\n                    return;\n                }\n\n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (SipException e) {\n                    logger.debug(\"failed to send the response\", e);\n                } catch (InvalidArgumentException e) {\n                    // should not happen\n                    logger.debug(\"invalid argument provided while trying\" +\n                            \" to send the response\", e);\n                }\n\n                return;\n            }\n\n            // if we don't understand the content\n            ContentTypeHeader ctheader = (ContentTypeHeader) request\n                .getHeader(ContentTypeHeader.NAME);\n\n            if (ctheader != null && !ctheader.getContentSubType()\n                    .equalsIgnoreCase(PIDF_XML))\n            {\n                // send a 415 response (rfc3261)\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.UNSUPPORTED_MEDIA_TYPE,\n                                request);\n                } catch (ParseException e) {\n                    logger.debug(\"failed to create the OK response\", e);\n                    return;\n                }\n\n                // we want PIDF\n                AcceptHeader acceptHeader = null;\n                try {\n                    acceptHeader = this.parentProvider\n                        .getHeaderFactory().createAcceptHeader(\n                            \"application\", PIDF_XML);\n                } catch (ParseException e) {\n                    // should not happen\n                    logger.debug(\"failed to create the accept header\", e);\n                    return;\n                }\n                response.setHeader(acceptHeader);\n\n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (SipException e) {\n                    logger.debug(\"failed to send the response\", e);\n                } catch (InvalidArgumentException e) {\n                    // should not happen\n                    logger.debug(\"invalid argument provided while trying\" +\n                            \" to send the response\", e);\n                }\n            }\n\n            // if the presentity doesn't want of us anymore\n            if (sstateHeader.getState().equalsIgnoreCase(\n                    SubscriptionStateHeader.TERMINATED))\n            {\n                // if we requested this end of subscription, contact == null\n                if (contact != null) {\n                    terminateSubscription(contact);\n                    this.subscribedContacts.remove(serverTransaction.getDialog()\n                        .getCallId().getCallId());\n                }\n                \n                // try to remove the callid from the list if we were excpeting\n                // this end (if it's the last notify of a subscription we just\n                // stopped\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(idheader.getCallId());\n                }\n            }\n            \n            // send an OK response\n            try {\n                response = this.parentProvider.getMessageFactory()\n                    .createResponse(Response.OK, request);\n            } catch (ParseException e) {\n                logger.debug(\"failed to create the OK response\", e);\n                return;\n            }\n\n            try {\n                serverTransaction.sendResponse(response);\n            } catch (SipException e) {\n                logger.debug(\"failed to send the response\", e);\n            } catch (InvalidArgumentException e) {\n                // should not happen\n                logger.debug(\"invalid argument provided while trying\" +\n                        \" to send the response\", e);\n            }\n\n            // transform the presence document in new presence status\n            if (request.getRawContent() != null\n                && !sstateHeader.getState().equalsIgnoreCase(\n                     SubscriptionStateHeader.TERMINATED))\n            {\n                setPidfPresenceStatus(new String(request.getRawContent()));\n            }\n\n        // SUBSCRIBE\n        } else if (request.getMethod().equals(Request.SUBSCRIBE)) {\n            FromHeader from = (FromHeader) request.getHeader(FromHeader.NAME);\n\n            // try to find which contact is concerned\n            ContactSipImpl contact = (ContactSipImpl) resolveContactID(from\n                    .getAddress().getURI().toString());\n\n            // if we don't know him, create him\n            if (contact == null) {\n                contact = new ContactSipImpl(from.getAddress().getURI()\n                        .toString(), this.parentProvider);\n\n                // <tricky time>\n                // this ensure that we will publish our status to this contact\n                // without trying to subscribe to him\n                contact.setResolved(true);\n                contact.setResolvable(false);\n                // <\/tricky time>\n            }\n\n            logger.debug(contact.toString() + \" wants to watch your presence \" +\n                    \"status\");\n\n            ExpiresHeader expHeader = request.getExpires();\n            int expires;\n            \n            if (expHeader == null) {\n                expires = SUBSCRIBE_DEFAULT_EXPIRE;\n            } else {\n                expires = expHeader.getExpires();\n            }\n            \n            // interval too brief\n            if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600)\n            {\n                // send him a 423\n                Response response = null;\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.INTERVAL_TOO_BRIEF, request);\n                } catch (Exception e) {\n                    logger.debug(\"Error while creating the response 423\", e);\n                    return;\n                }\n                MinExpiresHeader min = null;\n                \n                try {\n                    min = this.parentProvider.getHeaderFactory()\n                        .createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);\n                } catch (InvalidArgumentException e) {\n                    // should not happen\n                    logger.error(\"can't create the min expires header\", e);\n                    return;\n                }\n                response.setHeader(min);\n                \n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (Exception e) {\n                    logger.error(\"Error while sending the response 423\", e);\n                    return;\n                }\n                \n                return;\n            }\n            \n            // is it a subscription refresh ? (no need for synchronize the\n            // access to ourWatchers: read only operation)\n            if (this.ourWatchers.contains(contact)) {\n                contact.getTimeoutTask().cancel();\n                \n                // add the new timeout task\n                watcherTimeoutTask timeout = new watcherTimeoutTask(contact);\n                contact.setTimeoutTask(timeout);\n                this.timer.schedule(timeout, expires * 1000);\n                \n                // send a OK\n                Response response = null;\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.OK, request);\n                } catch (Exception e) {\n                    logger.debug(\"Error while creating the response 200\", e);\n                    return;\n                }\n                \n                // add the expire header\n                try {\n                    expHeader = this.parentProvider.getHeaderFactory()\n                        .createExpiresHeader(expires);\n                } catch (InvalidArgumentException e) {\n                    logger.error(\"Can't create the expires header\");\n                    return;\n                }\n                response.setHeader(expHeader);\n                \n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (Exception e) {\n                    logger.error(\"Error while sending the response 200\", e);\n                    return;\n                }\n                \n                return;\n            }\n            \n            // remember the dialog we will use to send the NOTIFYs\n            contact.setServerDialog(serverTransaction.getDialog());\n\n            Dialog dialog = contact.getServerDialog();\n\n            // is it a subscription end ?\n            if (expires == 0) {\n                logger.debug(\"contact \" + contact + \" isn't a watcher anymore\");\n\n                // remove the contact from our watcher\n                synchronized (this.ourWatchers) {\n                    this.ourWatchers.remove(contact);\n                }\n\n                contact.getTimeoutTask().cancel();\n\n                // send him a OK\n                Response response = null;\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.OK, request);\n                } catch (Exception e) {\n                    logger.debug(\"Error while creating the response 200\", e);\n                    return;\n                }\n\n                // add the expire header\n                try {\n                    expHeader = this.parentProvider.getHeaderFactory()\n                        .createExpiresHeader(expires);\n                } catch (InvalidArgumentException e) {\n                    logger.error(\"Can't create the expires header\");\n                    return;\n                }\n                response.setHeader(expHeader);\n                \n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (Exception e) {\n                    logger.error(\"Error while sending the response 200\", e);\n                    return;\n                }\n\n                // then terminate the subscription with an ultimate NOTIFY\n                ClientTransaction transac = null;\n                try {\n                    transac = createNotify(contact, \n                            getPidfPresenceStatus((ContactSipImpl) \n                                    getLocalContact()),\n                            SubscriptionStateHeader.TERMINATED,\n                            SubscriptionStateHeader.TIMEOUT);\n                } catch (OperationFailedException e) {\n                    logger.debug(\"failed to create the new notify\", e);\n                    return;\n                }\n\n                try {\n                    dialog.sendRequest(transac);\n                } catch (Exception e) {\n                    logger.debug(\"Can't send the request\");\n                    return;\n                }\n\n                return;\n            }\n\n            // immediately send a 202/ACCEPTED\n            Response response = null;\n            try {\n                response = this.parentProvider.getMessageFactory()\n                    .createResponse(Response.ACCEPTED, request);\n            } catch (Exception e) {\n                logger.debug(\"Error while creating the response 202\", e);\n                return;\n            }\n\n            // add the expire header\n            try {\n                expHeader = this.parentProvider.getHeaderFactory()\n                    .createExpiresHeader(expires);\n            } catch (InvalidArgumentException e) {\n                logger.error(\"Can't create the expires header\");\n                return;\n            }\n            response.setHeader(expHeader);\n\n            try {\n                serverTransaction.sendResponse(response);\n            } catch (Exception e) {\n                logger.error(\"Error while sending the response 202\", e);\n                return;\n            }\n\n            // send a first NOTIFY with an empty body (to not reveal our current\n            // presence status)\n            ClientTransaction transac = null;\n            try {\n                transac = createNotify(contact, new byte[0],\n                        SubscriptionStateHeader.PENDING, null);\n            } catch (OperationFailedException e) {\n                logger.debug(\"failed to create the first notify\", e);\n                return;\n            }\n\n            try {\n                dialog.sendRequest(transac);\n            } catch (Exception e) {\n                logger.debug(\"Can't send the request\");\n                return;\n            }\n\n            // ask the user authorization\n            AuthorizationResponse authResp = null;\n            if (this.authorizationHandler != null) {\n                AuthorizationRequest authReq = new AuthorizationRequest();\n                authResp = this.authorizationHandler\n                    .processAuthorisationRequest(authReq, contact);\n            }\n\n            // the user accepts\n            if (authResp == null || authResp.getResponseCode().equals(\n                    AuthorizationResponse.ACCEPT))\n            {\n                try {\n                    transac = createNotify(contact,\n                            getPidfPresenceStatus((ContactSipImpl)\n                                    getLocalContact()),\n                            SubscriptionStateHeader.ACTIVE,\n                            null);\n                } catch (OperationFailedException e) {\n                    logger.debug(\"failed to create the new notify\", e);\n                    return;\n                }\n\n                try {\n                    dialog.sendRequest(transac);\n                } catch (Exception e) {\n                    logger.debug(\"Can't send the request\");\n                    return;\n                }\n\n                // add him to our watcher list\n                synchronized (this.ourWatchers) {\n                    this.ourWatchers.add(contact);\n                }\n                \n                // add the timeout task\n                watcherTimeoutTask timeout = new watcherTimeoutTask(contact);\n                contact.setTimeoutTask(timeout);\n                this.timer.schedule(timeout, expires * 1000);\n                \n            } else {\n                // the user rejects\n                try {\n                    transac = createNotify(contact,\n                            new byte[0],\n                            SubscriptionStateHeader.TERMINATED,\n                            SubscriptionStateHeader.REJECTED);\n                } catch (OperationFailedException e) {\n                    logger.debug(\"failed to create the new notify\", e);\n                    return;\n                }\n\n                try {\n                    dialog.sendRequest(transac);\n                } catch (Exception e) {\n                    logger.debug(\"Can't send the request\");\n                    return;\n                }\n            }\n        }\n    }","id":42095,"modified_method":"/**\n     * Process a request from a distant contact\n     *\n     * @param requestEvent the <tt>RequestEvent<\/tt> containing the newly\n     * received request.\n     */\n    public void processRequest(RequestEvent requestEvent)\n    {\n        ServerTransaction serverTransaction = requestEvent\n            .getServerTransaction();\n        SipProvider jainSipProvider = (SipProvider) requestEvent.getSource();\n        Request request = requestEvent.getRequest();\n\n        if (serverTransaction == null)\n        {\n            try\n            {\n                serverTransaction = jainSipProvider.getNewServerTransaction(\n                    request);\n            }\n            catch (TransactionAlreadyExistsException ex)\n            {\n                //let's not scare the user and only log a message\n                logger.error(\"Failed to create a new server\"\n                    + \"transaction for an incoming request\\n\"\n                    + \"(Next message contains the request)\"\n                    , ex);\n                return;\n            }\n            catch (TransactionUnavailableException ex)\n            {\n                //let's not scare the user and only log a message\n                logger.error(\"Failed to create a new server\"\n                    + \"transaction for an incoming request\\n\"\n                    + \"(Next message contains the request)\"\n                    , ex);\n                    return;\n            }\n        }\n\n        EventHeader eventHeader = (EventHeader)\n            request.getHeader(EventHeader.NAME);\n\n        if (eventHeader == null || !eventHeader.getEventType()\n                .equalsIgnoreCase(\"presence\"))\n        {\n            // we are not concerned by this request, perhaps another\n            // listener is ?\n            \n            // don't send a 489 / Bad event answer here\n            return;\n        }\n\n\n        // NOTIFY\n        if (request.getMethod().equals(Request.NOTIFY)) {\n            Response response = null;\n\n            logger.debug(\"notify received\");\n\n            SubscriptionStateHeader sstateHeader = (SubscriptionStateHeader)\n                request.getHeader(SubscriptionStateHeader.NAME);\n\n            // notify must contain one (rfc3265)\n            if (sstateHeader == null) {\n                logger.error(\"no subscription state in this request\");\n                return;\n            }\n\n            // first handle the case of a contact still pending\n            // it's possible if the NOTIFY arrives before the OK\n            CallIdHeader idheader = (CallIdHeader) request.getHeader(\n                    CallIdHeader.NAME);\n            ContactSipImpl contact = (ContactSipImpl) this.subscribedContacts\n                .get(idheader.getCallId());\n\n            if (contact != null && !sstateHeader.getState().equalsIgnoreCase(\n                    SubscriptionStateHeader.TERMINATED) && !contact\n                    .isResolved())\n            {\n                logger.debug(\"contact still pending while NOTIFY received\");\n                \n                // simply ignore it and wait the OK, don't answer to force a\n                // timeout\n                // can't finalize the subscription here : the client dialog is\n                // null until the reception of a OK\n                return;\n            }\n\n            // see if the notify correspond to an existing subscription\n            if (contact == null && !sstateHeader.getState().equalsIgnoreCase(\n                    SubscriptionStateHeader.TERMINATED)) {\n                logger.debug(\"contact not found for callid : \" + \n                        idheader.getCallId());\n\n                // try to remove the callid from the list if we were excpeting\n                // this end (if it's the last notify of a subscription we just\n                // stopped\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(idheader.getCallId());\n                }\n\n                // send a 481 response (rfc3625)\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(\n                            Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST,\n                            request);\n                } catch (ParseException e) {\n                    logger.debug(\"failed to create the 481 response\", e);\n                    return;\n                }\n\n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (SipException e) {\n                    logger.debug(\"failed to send the response\", e);\n                } catch (InvalidArgumentException e) {\n                    // should not happen\n                    logger.debug(\"invalid argument provided while trying\" +\n                            \" to send the response\", e);\n                }\n\n                return;\n            }\n\n            // if we don't understand the content\n            ContentTypeHeader ctheader = (ContentTypeHeader) request\n                .getHeader(ContentTypeHeader.NAME);\n\n            if (ctheader != null && !ctheader.getContentSubType()\n                    .equalsIgnoreCase(PIDF_XML))\n            {\n                // send a 415 response (rfc3261)\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.UNSUPPORTED_MEDIA_TYPE,\n                                request);\n                } catch (ParseException e) {\n                    logger.debug(\"failed to create the OK response\", e);\n                    return;\n                }\n\n                // we want PIDF\n                AcceptHeader acceptHeader = null;\n                try {\n                    acceptHeader = this.parentProvider\n                        .getHeaderFactory().createAcceptHeader(\n                            \"application\", PIDF_XML);\n                } catch (ParseException e) {\n                    // should not happen\n                    logger.debug(\"failed to create the accept header\", e);\n                    return;\n                }\n                response.setHeader(acceptHeader);\n\n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (SipException e) {\n                    logger.debug(\"failed to send the response\", e);\n                } catch (InvalidArgumentException e) {\n                    // should not happen\n                    logger.debug(\"invalid argument provided while trying\" +\n                            \" to send the response\", e);\n                }\n            }\n\n            // if the presentity doesn't want of us anymore\n            if (sstateHeader.getState().equalsIgnoreCase(\n                    SubscriptionStateHeader.TERMINATED))\n            {\n                // if we requested this end of subscription, contact == null\n                if (contact != null) {\n                    terminateSubscription(contact);\n                    this.subscribedContacts.remove(serverTransaction.getDialog()\n                        .getCallId().getCallId());\n                }\n                \n                // try to remove the callid from the list if we were excpeting\n                // this end (if it's the last notify of a subscription we just\n                // stopped\n                synchronized (this.waitedCallIds) {\n                    this.waitedCallIds.remove(idheader.getCallId());\n                }\n            }\n            \n            // send an OK response\n            try {\n                response = this.parentProvider.getMessageFactory()\n                    .createResponse(Response.OK, request);\n            } catch (ParseException e) {\n                logger.debug(\"failed to create the OK response\", e);\n                return;\n            }\n\n            try {\n                serverTransaction.sendResponse(response);\n            } catch (SipException e) {\n                logger.debug(\"failed to send the response\", e);\n            } catch (InvalidArgumentException e) {\n                // should not happen\n                logger.debug(\"invalid argument provided while trying\" +\n                        \" to send the response\", e);\n            }\n\n            // transform the presence document in new presence status\n            if (request.getRawContent() != null\n                && !sstateHeader.getState().equalsIgnoreCase(\n                     SubscriptionStateHeader.TERMINATED))\n            {\n                setPidfPresenceStatus(new String(request.getRawContent()));\n            }\n\n        // SUBSCRIBE\n        } else if (request.getMethod().equals(Request.SUBSCRIBE)) {\n            FromHeader from = (FromHeader) request.getHeader(FromHeader.NAME);\n\n            // try to find which contact is concerned\n            ContactSipImpl contact = (ContactSipImpl) resolveContactID(from\n                    .getAddress().getURI().toString());\n\n            // if we don't know him, create him\n            if (contact == null) {\n                contact = new ContactSipImpl(from.getAddress().getURI()\n                        .toString(), this.parentProvider);\n\n                // <tricky time>\n                // this ensure that we will publish our status to this contact\n                // without trying to subscribe to him\n                contact.setResolved(true);\n                contact.setResolvable(false);\n                // <\/tricky time>\n            }\n\n            logger.debug(contact.toString() + \" wants to watch your presence \" +\n                    \"status\");\n\n            ExpiresHeader expHeader = request.getExpires();\n            int expires;\n            \n            if (expHeader == null) {\n                expires = SUBSCRIBE_DEFAULT_EXPIRE;\n            } else {\n                expires = expHeader.getExpires();\n            }\n            \n            // interval too brief\n            if (expires < SUBSCRIBE_MIN_EXPIRE && expires > 0 && expires < 3600)\n            {\n                // send him a 423\n                Response response = null;\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.INTERVAL_TOO_BRIEF, request);\n                } catch (Exception e) {\n                    logger.debug(\"Error while creating the response 423\", e);\n                    return;\n                }\n                MinExpiresHeader min = null;\n                \n                try {\n                    min = this.parentProvider.getHeaderFactory()\n                        .createMinExpiresHeader(SUBSCRIBE_MIN_EXPIRE);\n                } catch (InvalidArgumentException e) {\n                    // should not happen\n                    logger.error(\"can't create the min expires header\", e);\n                    return;\n                }\n                response.setHeader(min);\n                \n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (Exception e) {\n                    logger.error(\"Error while sending the response 423\", e);\n                    return;\n                }\n                \n                return;\n            }\n            \n            // is it a subscription refresh ? (no need for synchronize the\n            // access to ourWatchers: read only operation)\n            if (this.ourWatchers.contains(contact)) {\n                contact.getTimeoutTask().cancel();\n                \n                // add the new timeout task\n                watcherTimeoutTask timeout = new watcherTimeoutTask(contact);\n                contact.setTimeoutTask(timeout);\n                this.timer.schedule(timeout, expires * 1000);\n                \n                // send a OK\n                Response response = null;\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.OK, request);\n                } catch (Exception e) {\n                    logger.debug(\"Error while creating the response 200\", e);\n                    return;\n                }\n                \n                // add the expire header\n                try {\n                    expHeader = this.parentProvider.getHeaderFactory()\n                        .createExpiresHeader(expires);\n                } catch (InvalidArgumentException e) {\n                    logger.error(\"Can't create the expires header\");\n                    return;\n                }\n                response.setHeader(expHeader);\n                \n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (Exception e) {\n                    logger.error(\"Error while sending the response 200\", e);\n                    return;\n                }\n                \n                return;\n            }\n            \n            Dialog dialog = contact.getServerDialog();\n\n            // is it a subscription end ?\n            if (expires == 0) {\n                logger.debug(\"contact \" + contact + \" isn't a watcher anymore\");\n\n                // remove the contact from our watcher\n                synchronized (this.ourWatchers) {\n                    this.ourWatchers.remove(contact);\n                }\n\n                contact.getTimeoutTask().cancel();\n                contact.setServerDialog(null);\n\n                // send him a OK\n                Response response = null;\n                try {\n                    response = this.parentProvider.getMessageFactory()\n                        .createResponse(Response.OK, request);\n                } catch (Exception e) {\n                    logger.debug(\"Error while creating the response 200\", e);\n                    return;\n                }\n\n                // add the expire header\n                try {\n                    expHeader = this.parentProvider.getHeaderFactory()\n                        .createExpiresHeader(0);\n                } catch (InvalidArgumentException e) {\n                    logger.error(\"Can't create the expires header\");\n                    return;\n                }\n                response.setHeader(expHeader);\n                \n                try {\n                    serverTransaction.sendResponse(response);\n                } catch (Exception e) {\n                    logger.error(\"Error while sending the response 200\", e);\n                    return;\n                }\n\n                // then terminate the subscription with an ultimate NOTIFY\n                ClientTransaction transac = null;\n                try {\n                    transac = createNotify(contact, \n                            getPidfPresenceStatus((ContactSipImpl) \n                                    getLocalContact()),\n                            SubscriptionStateHeader.TERMINATED,\n                            SubscriptionStateHeader.TIMEOUT);\n                } catch (OperationFailedException e) {\n                    logger.debug(\"failed to create the new notify\", e);\n                    return;\n                }\n\n                try {\n                    dialog.sendRequest(transac);\n                } catch (Exception e) {\n                    logger.debug(\"Can't send the request\");\n                    return;\n                }\n\n                return;\n            }\n\n            // remember the dialog we will use to send the NOTIFYs\n            contact.setServerDialog(serverTransaction.getDialog());\n            dialog = contact.getServerDialog();\n            \n            // immediately send a 200 / OK\n            Response response = null;\n            try {\n                response = this.parentProvider.getMessageFactory()\n                    .createResponse(Response.OK, request);\n            } catch (Exception e) {\n                logger.debug(\"Error while creating the response 200\", e);\n                return;\n            }\n\n            // add the expire header\n            try {\n                expHeader = this.parentProvider.getHeaderFactory()\n                    .createExpiresHeader(expires);\n            } catch (InvalidArgumentException e) {\n                logger.error(\"Can't create the expires header\");\n                return;\n            }\n            response.setHeader(expHeader);\n\n            try {\n                serverTransaction.sendResponse(response);\n            } catch (Exception e) {\n                logger.error(\"Error while sending the response 200\", e);\n                return;\n            }\n\n            // send a NOTIFY\n            ClientTransaction transac = null;\n            try {\n                transac = createNotify(contact,\n                        getPidfPresenceStatus((ContactSipImpl)\n                                getLocalContact()),\n                        SubscriptionStateHeader.ACTIVE,\n                        null);\n            } catch (OperationFailedException e) {\n                logger.debug(\"failed to create the new notify\", e);\n                return;\n            }\n\n            try {\n                dialog.sendRequest(transac);\n            } catch (Exception e) {\n                logger.error(\"Can't send the request\", e);\n                return;\n            }\n\n            // add him to our watcher list\n            synchronized (this.ourWatchers) {\n                this.ourWatchers.add(contact);\n            }\n            \n            // add the timeout task\n            watcherTimeoutTask timeout = new watcherTimeoutTask(contact);\n            contact.setTimeoutTask(timeout);\n            this.timer.schedule(timeout, expires * 1000);\n        }\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes a subscription for the presence status of the specified contact.\n     * @param contact the contact whose status updates we are unsubscribing\n     * from.\n     *\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     * unsubscribing fails due to errors experienced during network\n     * communication\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     * known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is not\n     * registered/signed on a public service.\n     */\n    public void unsubscribe(Contact contact)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n   {\n        if (!(contact instanceof ContactSipImpl)) {\n            throw new IllegalArgumentException(\"the contact is not a SIP\" +\n                    \" contact\");\n        }\n\n        ContactSipImpl sipcontact = (ContactSipImpl) contact;\n        Dialog dialog = sipcontact.getClientDialog();\n\n        // handle the case of a distant presence agent is used\n        if (!this.useDistantPA) {\n            // check if we heard about this contact\n            if (this.subscribedContacts.get(dialog.getCallId().getCallId())\n                    == null)\n            {\n                throw new IllegalArgumentException(\"trying to unregister a not \" +\n                        \"registered contact\");\n            }\n\n            // we stop the subscribtion if we're subscribed to this contact\n            if (!contact.getPresenceStatus().equals(SipStatusEnum.OFFLINE)\n                    && !contact.getPresenceStatus().equals(SipStatusEnum.UNKNOWN)\n                    && sipcontact.isResolvable())\n            {\n                assertConnected();\n                \n                ClientTransaction transac = null;\n                try {\n                    transac = createSubscription(0, dialog);\n                } catch (OperationFailedException e) {\n                    logger.debug(\"failed to create the unsubscription\", e);\n                    throw e;\n                }\n                \n                // we are not anymore subscribed to this contact\n                // this ensure that the response of this request will be\n                // handled as an unsubscription response\n                this.subscribedContacts.remove(dialog.getCallId().getCallId());\n                \n                try {\n                    dialog.sendRequest(transac);\n                } catch (Exception e) {\n                    logger.debug(\"Can't send the request\");\n                    throw new OperationFailedException(\n                            \"Failed to send the subscription message\",\n                            OperationFailedException.NETWORK_FAILURE);\n                }\n            }\n        }\n\n        // remove any trace of this contact\n        terminateSubscription(sipcontact);\n        ((ContactGroupSipImpl) sipcontact.getParentContactGroup())\n            .removeContact(sipcontact);\n\n        // inform the listeners\n        fireSubscriptionEvent(sipcontact,\n              sipcontact.getParentContactGroup(),\n              SubscriptionEvent.SUBSCRIPTION_REMOVED);\n   }","id":42096,"modified_method":"/**\n     * Removes a subscription for the presence status of the specified contact.\n     * @param contact the contact whose status updates we are unsubscribing\n     * from.\n     *\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     * unsubscribing fails due to errors experienced during network\n     * communication\n     * @throws IllegalArgumentException if <tt>contact<\/tt> is not a contact\n     * known to the underlying protocol provider\n     * @throws IllegalStateException if the underlying protocol provider is not\n     * registered/signed on a public service.\n     */\n    public void unsubscribe(Contact contact)\n        throws IllegalArgumentException,\n               IllegalStateException,\n               OperationFailedException\n   {\n        if (!(contact instanceof ContactSipImpl)) {\n            throw new IllegalArgumentException(\"the contact is not a SIP\" +\n                    \" contact\");\n        }\n\n        ContactSipImpl sipcontact = (ContactSipImpl) contact;\n        Dialog dialog = sipcontact.getClientDialog();\n\n        \n        // handle the case of a distant presence agent is used\n        // and test if we are subscribed to this contact\n        if (!this.useDistantPA && dialog != null) {\n            // check if we heard about this contact\n            if (this.subscribedContacts.get(dialog.getCallId().getCallId())\n                    == null)\n            {\n                throw new IllegalArgumentException(\"trying to unregister a \" +\n                        \"not registered contact\");\n            }\n\n            // we stop the subscribtion if we're subscribed to this contact\n            if (sipcontact.isResolvable()) {\n                assertConnected();\n                \n                ClientTransaction transac = null;\n                try {\n                    transac = createSubscription(0, dialog);\n                } catch (OperationFailedException e) {\n                    logger.debug(\"failed to create the unsubscription\", e);\n                    throw e;\n                }\n                \n                // we are not anymore subscribed to this contact\n                // this ensure that the response of this request will be\n                // handled as an unsubscription response\n                this.subscribedContacts.remove(dialog.getCallId().getCallId());\n                \n                try {\n                    dialog.sendRequest(transac);\n                } catch (Exception e) {\n                    logger.debug(\"Can't send the request\");\n                    throw new OperationFailedException(\n                            \"Failed to send the subscription message\",\n                            OperationFailedException.NETWORK_FAILURE);\n                }\n            }\n        }\n\n        // remove any trace of this contact\n        terminateSubscription(sipcontact);\n        ((ContactGroupSipImpl) sipcontact.getParentContactGroup())\n            .removeContact(sipcontact);\n\n        // inform the listeners\n        fireSubscriptionEvent(sipcontact,\n              sipcontact.getParentContactGroup(),\n              SubscriptionEvent.SUBSCRIPTION_REMOVED);\n   }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the specified contact from its current parent and places it\n     * under <tt>newParent<\/tt>.\n     *\n     * @param contactToMove the <tt>Contact<\/tt> to move\n     * @param newParent the <tt>ContactGroup<\/tt> where <tt>Contact<\/tt>\n     *   would be placed.\n     */\n    public void moveContactToGroup(Contact contactToMove,\n                                   ContactGroup newParent)\n    {\n        if (!(contactToMove instanceof ContactSipImpl)) {\n            return;\n        }\n\n        ContactSipImpl sipContact\n            = (ContactSipImpl)contactToMove;\n\n        ContactGroupSipImpl parentSipGroup\n            = (ContactGroupSipImpl) sipContact.getParentContactGroup();\n\n        parentSipGroup.removeContact(sipContact);\n\n        // if this is a volatile contact then we haven't really subscribed to\n        // them so we'd need to do so here\n        if(!sipContact.isPersistent())\n        {\n            //first tell everyone that the volatile contact was removed\n            fireSubscriptionEvent(sipContact,\n                                  parentSipGroup,\n                                  SubscriptionEvent.SUBSCRIPTION_REMOVED);\n\n            try\n            {\n                //now subscribe\n                this.subscribe(newParent, contactToMove.getAddress());\n\n                //now tell everyone that we've added the contact\n                fireSubscriptionEvent(sipContact,\n                                      newParent,\n                                      SubscriptionEvent.SUBSCRIPTION_CREATED);\n            }\n            catch (Exception ex)\n            {\n                logger.error(\"Failed to move contact \"\n                             + sipContact.getAddress()\n                             , ex);\n            }\n        }\n        else\n        {\n            ((ContactGroupSipImpl) newParent).addContact(sipContact);\n\n            fireSubscriptionMovedEvent(contactToMove,\n                                       parentSipGroup,\n                                       newParent);\n        }\n    }","id":42097,"modified_method":"/**\n     * Removes the specified contact from its current parent and places it\n     * under <tt>newParent<\/tt>.\n     *\n     * @param contactToMove the <tt>Contact<\/tt> to move\n     * @param newParent the <tt>ContactGroup<\/tt> where <tt>Contact<\/tt>\n     *   would be placed.\n     */\n    public void moveContactToGroup(Contact contactToMove,\n                                   ContactGroup newParent)\n    {\n        if (!(contactToMove instanceof ContactSipImpl)) {\n            return;\n        }\n\n        ContactSipImpl sipContact\n            = (ContactSipImpl)contactToMove;\n\n        ContactGroupSipImpl parentSipGroup\n            = (ContactGroupSipImpl) sipContact.getParentContactGroup();\n\n        parentSipGroup.removeContact(sipContact);\n\n        // if this is a volatile contact then we haven't really subscribed to\n        // them so we'd need to do so here\n        if(!sipContact.isPersistent())\n        {\n            //first tell everyone that the volatile contact was removed\n            fireSubscriptionEvent(sipContact,\n                                  parentSipGroup,\n                                  SubscriptionEvent.SUBSCRIPTION_REMOVED);\n\n            try\n            {\n                // simply change the parent of the contact, don't resubscribe\n                ((ContactGroupSipImpl) newParent).addContact(sipContact);\n\n                //now tell everyone that we've added the contact\n                fireSubscriptionEvent(sipContact,\n                                      newParent,\n                                      SubscriptionEvent.SUBSCRIPTION_CREATED);\n            }\n            catch (Exception ex)\n            {\n                logger.error(\"Failed to move contact \"\n                             + sipContact.getAddress()\n                             , ex);\n            }\n        }\n        else\n        {\n            ((ContactGroupSipImpl) newParent).addContact(sipContact);\n\n            fireSubscriptionMovedEvent(contactToMove,\n                                       parentSipGroup,\n                                       newParent);\n        }\n    }","commit_id":"92a52037517a9b3e5b5ab9d4de290b002e449dd2","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        final String action = ((post == null) ? \"info\" : post.get(\"action\", \"info\"));\r\n        String pathString = ((post == null) ? \"\" : post.get(\"path\", \"/\"));\r\n//      String pathString = ((post == null) ? \"\" : post.get(\"path\", \"/\").replaceAll(\"//\", \"/\")); // where is the BUG ?\r\n\r\n        // don't left the htCachePath\r\n        File file = new File(switchboard.htCachePath, pathString);\r\n        try {\r\n            if (!file.getCanonicalPath().startsWith(switchboard.htCachePath.getCanonicalPath())) {\r\n                pathString = \"/\";\r\n                file = new File(switchboard.htCachePath, pathString);\r\n            }\r\n        } catch (Exception e) {\r\n            pathString = \"/\";\r\n            file = new File(switchboard.htCachePath, pathString);\r\n        }\r\n\r\n        final StringBuffer path = new StringBuffer(256);\r\n        final StringBuffer tree = new StringBuffer();\r\n        final StringBuffer info = new StringBuffer();\r\n\r\n        final URL  url  = switchboard.cacheManager.getURL(file);\r\n        \r\n        String urlstr = \"\";\r\n        if (action.equals(\"info\") && !file.isDirectory()) {\r\n            prop.put(\"info\", 0);\r\n            path.append((pathString.length() == 0) ? linkPathString(\"/\", true) : linkPathString(pathString, false));\r\n\r\n            urlstr = url.toNormalform();\r\n            prop.put(\"info_url\", urlstr);\r\n\r\n            info.ensureCapacity(40000);\r\n            try {\r\n                final IResourceInfo resInfo = switchboard.cacheManager.loadResourceInfo(url);\r\n                info.append(\"<b>HTTP Header:<\/b><br>\").append(formatHeader(resInfo.getMap())).append(\"<br>\");\r\n                final String ff = file.toString();\r\n                final int dotpos = ff.lastIndexOf('.');\r\n                final String ext = (dotpos >= 0) ? ff.substring(dotpos + 1).toLowerCase() : \"\";\r\n                if (ext.equals(\"gif\") || ext.equals(\"jpg\") ||\r\n                    ext.equals(\"png\") || ext.equals(\"jpeg\")) {\r\n                    info.append(\"<img src=\\\"\" + \"CacheResource_p.html?path=\").append(pathString).append(\"\\\">\");\r\n                } else {\r\n                    final htmlFilterContentScraper scraper = new htmlFilterContentScraper(url);\r\n                    //final OutputStream os = new htmlFilterOutputStream(null, scraper, null, false);\r\n                    Writer writer = new htmlFilterWriter(null,null,scraper,null,false);                    \r\n                    String sourceCharset = resInfo.getCharacterEncoding();\r\n                    if (sourceCharset == null) sourceCharset = \"UTF-8\";\r\n                    String mimeType = resInfo.getMimeType();                    \r\n                    serverFileUtils.copy(file, sourceCharset, writer);\r\n                    writer.close();\r\n                    final plasmaParserDocument document = switchboard.parser.transformScraper(url, mimeType, sourceCharset, scraper);\r\n                    info.append(\"<b>TITLE:<\/b><br>\").append(scraper.getTitle()).append(\"<br>\").append(\"<br>\")\r\n                        .append(\"<b>SECTION HEADLINES:<\/b><br>\").append(formatTitles(document.getSectionTitles())).append(\"<br>\")\r\n                        .append(\"<b>HREF:<\/b><br>\").append(formatAnchor(document.getHyperlinks())).append(\"<br>\")\r\n                        .append(\"<b>IMAGE:<\/b><br>\").append(formatImageAnchor(document.getImages())).append(\"<br>\")\r\n                        .append(\"<b>AUDIO:<\/b><br>\").append(formatAnchor(document.getAudiolinks())).append(\"<br>\")\r\n                        .append(\"<b>VIDEO:<\/b><br>\").append(formatAnchor(document.getVideolinks())).append(\"<br>\")\r\n                        .append(\"<b>APPS:<\/b><br>\").append(formatAnchor(document.getApplinks())).append(\"<br>\")\r\n                        .append(\"<b>EMAIL:<\/b><br>\").append(formatAnchor(document.getEmaillinks())).append(\"<br>\")\r\n                        .append(\"<b>TEXT:<\/b><br><span class=\\\"small\\\">\").append(new String(scraper.getText())).append(\"<\/span><br>\")\r\n                        .append(\"<b>LINES:<\/b><br><span class=\\\"small\\\">\");\r\n                    final Iterator sentences = document.getSentences(false);\r\n                    if (sentences != null) while (sentences.hasNext()) {\r\n                        info.append((String) sentences.next()).append(\"<br>\");\r\n                    }\r\n                    info.append(\"<\/span><br>\");\r\n                    if (document != null) document.close();\r\n                }\r\n            } catch (Exception e) {\r\n                info.append(\"- This file is not cached -<br><br>\");\r\n                info.append(e.toString());\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            prop.put(\"info\", 1);\r\n\r\n            File dir;\r\n            if (file.isDirectory()) {\r\n                dir = file;\r\n            } else {\r\n                dir = file.getParentFile();\r\n                pathString = (new File(pathString)).getParent().replace('\\\\','/');\r\n            }\r\n\r\n            // generate sorted dir/file listing\r\n            final String[] list = dir.list();\r\n            tree.ensureCapacity((list == null) ? 70 : (list.length + 1) * 256);\r\n            path.append((pathString.length() == 0) ? linkPathString(\"/\", true) : linkPathString(pathString, true));\r\n            if (list == null) {\r\n                tree.append(\"[empty]\");\r\n            } else {\r\n                final TreeSet dList = new TreeSet();\r\n                final TreeSet fList = new TreeSet();\r\n                File object;\r\n                int size = list.length - 1;\r\n                for (int i = size; i >= 0 ; i--) { // Rueckwaerts ist schneller\r\n                    object = new File(dir, list[i]);\r\n                    if (!object.getName().equalsIgnoreCase(\"responseHeader.db\")) {\r\n                        if (object.isDirectory()) {\r\n                            dList.add(list[i]);\r\n                        } else {\r\n                            fList.add(list[i]);\r\n                        }\r\n                    }\r\n                }\r\n                Iterator iter = dList.iterator();\r\n                String str;\r\n                while (iter.hasNext()) {\r\n                    str = iter.next().toString();\r\n                    tree.append(\"<img src=\\\"/env/grafics/folderIconSmall.gif\\\" align=\\\"top\\\" alt=\\\"Folder\\\">&nbsp;<a href=\\\"CacheAdmin_p.html?action=info&path=\").append(pathString).append(\"/\").append(str).append(\"\\\" class=\\\"tt\\\"><bobr>\").append(str).append(\"<\/bobr><\/a><br>\").append(serverCore.crlfString);\r\n                } \r\n                iter = fList.iterator();\r\n                while (iter.hasNext()) {\r\n                    str = iter.next().toString();\r\n                    tree.append(\"<img src=\\\"/env/grafics/fileIconSmall.gif\\\" align=\\\"top\\\" alt=\\\"File\\\">&nbsp;<a href=\\\"CacheAdmin_p.html?action=info&path=\").append(pathString).append(\"/\").append(str).append(\"\\\" class=\\\"tt\\\"><bobr>\").append(str).append(\"<\/bobr><\/a><br>\").append(serverCore.crlfString);\r\n                }\r\n            }\r\n        }\r\n\r\n        prop.put(\"cachesize\", Long.toString(switchboard.cacheManager.curCacheSize/1024));\r\n        prop.put(\"cachemax\", Long.toString(switchboard.cacheManager.maxCacheSize/1024));\r\n        prop.put(\"path\", path.toString());\r\n        prop.put(\"info_info\", info.toString());\r\n        prop.put(\"info_tree\", tree.toString());\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":42098,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard switchboard = (plasmaSwitchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n\r\n        final String action = ((post == null) ? \"info\" : post.get(\"action\", \"info\"));\r\n        String pathString = ((post == null) ? \"\" : post.get(\"path\", \"/\"));\r\n//      String pathString = ((post == null) ? \"\" : post.get(\"path\", \"/\").replaceAll(\"//\", \"/\")); // where is the BUG ?\r\n\r\n        // don't leave the htCachePath\r\n        File file = new File(switchboard.htCachePath, pathString);\r\n        try {\r\n            if (!file.getCanonicalPath().startsWith(switchboard.htCachePath.getCanonicalPath())) {\r\n                pathString = \"/\";\r\n                file = new File(switchboard.htCachePath, pathString);\r\n            }\r\n        } catch (Exception e) {\r\n            pathString = \"/\";\r\n            file = new File(switchboard.htCachePath, pathString);\r\n        }\r\n\r\n        final StringBuffer path = new StringBuffer(256);\r\n        final StringBuffer tree = new StringBuffer();\r\n        final StringBuffer info = new StringBuffer();\r\n\r\n        final URL  url  = switchboard.cacheManager.getURL(file);\r\n        \r\n        String urlstr = \"\";\r\n        \r\n        if (action.equals(\"info\") && !file.isDirectory()) {\t\t\t\t\t// normal file\r\n            prop.put(\"info\", TypeFILE);\r\n            // path.append((pathString.length() == 0) ? linkPathString(\"/\", true) : linkPathString(pathString, false));\r\n            linkPathString(prop, ((pathString.length() == 0) ? (\"/\") : (pathString)), true);\r\n\r\n            urlstr = url.toNormalform();\r\n            prop.put(\"info_url\", urlstr);\r\n\r\n            info.ensureCapacity(40000);\r\n            try {\r\n                final IResourceInfo resInfo = switchboard.cacheManager.loadResourceInfo(url);\r\n                formatHeader(prop, resInfo.getMap());\r\n                \r\n                final String ff = file.toString();\r\n                final int dotpos = ff.lastIndexOf('.');\r\n                final String ext = (dotpos >= 0) ? ff.substring(dotpos + 1).toLowerCase() : \"\";\r\n                if (ext.equals(\"gif\") || ext.equals(\"jpg\") ||\r\n                    ext.equals(\"png\") || ext.equals(\"jpeg\")) {\r\n                \tprop.put(\"info_type\", Image);\r\n                    prop.put(\"info_type_src\", pathString);\r\n                } else {\r\n                \tprop.put(\"info_type\", HtmlFile);\r\n                \t// fill the htmlFilerContentScraper object with the contents of the cached file\r\n                \t// to retrieve all needed information\r\n                    final htmlFilterContentScraper scraper = new htmlFilterContentScraper(url);\r\n                    //final OutputStream os = new htmlFilterOutputStream(null, scraper, null, false);\r\n                    Writer writer = new htmlFilterWriter(null,null,scraper,null,false);                    \r\n                    String sourceCharset = resInfo.getCharacterEncoding();\r\n                    if (sourceCharset == null) sourceCharset = \"UTF-8\";\r\n                    String mimeType = resInfo.getMimeType();                    \r\n                    serverFileUtils.copy(file, sourceCharset, writer);\r\n                    writer.close();\r\n                    \r\n                    final plasmaParserDocument document = switchboard.parser.transformScraper(url, mimeType, sourceCharset, scraper);\r\n                    \r\n                    prop.put(\"info_type_title\", scraper.getTitle());\r\n                    \r\n                    int i;\r\n                    String[] t = document.getSectionTitles();\r\n                    prop.put(\"info_type_headlines\", t.length);\r\n                    for (i = 0; i < t.length; i++)\r\n                    \tprop.put(\"info_type_headlines_\" + i + \"_headline\", t[i].replaceAll(\"\\n\", \"\").trim());\r\n                    \r\n                    formatAnchor(prop, document.getHyperlinks(), \"links\");\r\n                    formatImageAnchor(prop, document.getImages());\r\n                    formatAnchor(prop, document.getAudiolinks(), \"audio\");\r\n                    formatAnchor(prop, document.getVideolinks(), \"video\");\r\n                    formatAnchor(prop, document.getApplinks(), \"apps\");\r\n                    formatAnchor(prop, document.getEmaillinks(), \"email\");\r\n                    \r\n                    prop.put(\"info_type_text\", new String(scraper.getText()));\r\n                    \r\n                    i = 0;\r\n                    final Iterator sentences = document.getSentences(false);\r\n                    if (sentences != null)\r\n                    \twhile (sentences.hasNext()) {\r\n                    \t\tprop.put(\"info_type_lines_\" + i + \"_line\", sentences.next().toString().replaceAll(\"\\n\", \"\").trim());\r\n\t                        i++;\r\n\t                    }\r\n                    prop.put(\"info_type_lines\", i);\r\n                    if (document != null) document.close();\r\n                }\r\n            } catch (Exception e) {\r\n            \tprop.put(\"info_type\", NotCached);\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            prop.put(\"info\", TypeDIR);\r\n\r\n            File dir;\r\n            if (file.isDirectory()) {\r\n                dir = file;\r\n            } else {\r\n                dir = file.getParentFile();\r\n                pathString = (new File(pathString)).getParent().replace('\\\\','/');\r\n            }\r\n\r\n            // generate sorted dir/file listing\r\n            final String[] list = dir.list();\r\n            tree.ensureCapacity((list == null) ? 70 : (list.length + 1) * 256);\r\n            linkPathString(prop, ((pathString.length() == 0) ? (\"/\") : (pathString)), true); \r\n            if (list == null) {\r\n                prop.put(\"info_empty\", 1);\r\n            } else {\r\n            \tprop.put(\"info_empty\", 0);\r\n                final TreeSet dList = new TreeSet();\r\n                final TreeSet fList = new TreeSet();\r\n                File object;\r\n                int size = list.length - 1, i = size;\r\n                for (; i >= 0 ; i--) { // Rueckwaerts ist schneller\r\n                    object = new File(dir, list[i]);\r\n                    if (!object.getName().equalsIgnoreCase(\"responseHeader.db\")) {\r\n                        if (object.isDirectory())\r\n                            dList.add(list[i]);\r\n                        else\r\n                            fList.add(list[i]);\r\n                    }\r\n                }\r\n                \r\n                Iterator iter = dList.iterator();\r\n                i = 0;\r\n                prop.put(\"info_treeFolders\", dList.size());\r\n                while (iter.hasNext()) {\r\n                    prop.put(\"info_treeFolders_\" + i + \"_path\", pathString);\r\n                    prop.put(\"info_treeFolders_\" + i + \"_name\", iter.next().toString());\r\n                    i++;\r\n                } \r\n                \r\n                i = 0;\r\n                iter = fList.iterator();\r\n                prop.put(\"info_treeFiles\", fList.size());\r\n                while (iter.hasNext()) {\r\n                    prop.put(\"info_treeFiles_\" + i + \"_path\", pathString);\r\n                    prop.put(\"info_treeFiles_\" + i + \"_name\", iter.next().toString());\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        prop.put(\"cachesize\", Long.toString(switchboard.cacheManager.curCacheSize/1024));\r\n        prop.put(\"cachemax\", Long.toString(switchboard.cacheManager.maxCacheSize/1024));\r\n        prop.put(\"path\", path.toString());\r\n        prop.put(\"info_info\", info.toString());\r\n        /* prop.put(\"info_tree\", tree.toString()); */\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"41d7e86299ade140f95135751d6d2c7303e8a990","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static String linkPathString(String path, boolean dir){\r\n        final String[] elements = path.split(\"/\");\r\n        final StringBuffer tmpstr = new StringBuffer(256);\r\n        final StringBuffer result = new StringBuffer(elements.length + 1 * 128);\r\n        int i, e;\r\n        if (dir) { e = elements.length; } else { e = elements.length - 1; }\r\n        for(i = 0; i < e; i++) {\r\n            if (!elements[i].equals(\"\")) {\r\n                tmpstr.append(elements[i]).append(\"/\");\r\n                result.append(\"<a href=\\\"CacheAdmin_p.html?action=info&path=\").append(tmpstr).append(\"\\\" class=\\\"tt\\\">\").append(elements[i]).append(\"/<\/a>\");\r\n            }\r\n        }\r\n        return result.toString();\r\n    }","id":42099,"modified_method":"private static void linkPathString(serverObjects prop, String path, boolean dir) {\r\n        final String[] elements = path.split(\"/\");\r\n        String dirs = \"\";\r\n        int i, e, count = 0;\r\n        if (dir) { e = elements.length; } else { e = elements.length - 1; }\r\n        for(i = 0; i < e; i++) {\r\n            if (elements[i].length() == 0) continue;\r\n        \tprop.put(\"paths_\" + count + \"_path\", dirs);\r\n        \tprop.put(\"paths_\" + count + \"_name\", elements[i]);\r\n        \tdirs += \"/\" + elements[i];\r\n            count++;\r\n        }\r\n        prop.put(\"paths\", count);\r\n        return;\r\n    }","commit_id":"41d7e86299ade140f95135751d6d2c7303e8a990","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static String formatHeader(Map header) {\r\n        final StringBuffer result = new StringBuffer(2048);\r\n        if (header == null) {\r\n            result.append(\"- no header in header cache -<br>\");\r\n        } else {\r\n            result.append(\"<table border=\\\"0\\\" cellspacing=\\\"0\\\" cellpadding=\\\"0\\\">\");\r\n            final Iterator iter = header.entrySet().iterator();\r\n            Map.Entry entry;\r\n            while (iter.hasNext()) {\r\n                entry = (Map.Entry) iter.next();\r\n                result.append(\"<tr valign=\\\"top\\\"><td class=\\\"tt\\\">\").append(entry.getKey()).append(\"<\/td><td class=\\\"tt\\\">&nbsp;=&nbsp;<\/td><td class=\\\"tt\\\">\").append(entry.getValue()).append(\"<\/td><\/tr>\");\r\n            }\r\n            result.append(\"<\/table>\");\r\n        }\r\n        return result.toString();\r\n    }","id":42100,"modified_method":"private static void formatHeader(serverObjects prop, Map header) {\r\n        if (header == null) {\r\n            prop.put(\"info_header\", 0);\r\n        } else {\r\n        \tprop.put(\"info_header\", 1);\r\n        \tint i = 0;\r\n            final Iterator iter = header.entrySet().iterator();\r\n            Map.Entry entry;\r\n            while (iter.hasNext()) {\r\n            \tentry = (Map.Entry) iter.next();\r\n            \tprop.put(\"info_header_line_\" + i + \"_property\", entry.getKey());\r\n            \tprop.put(\"info_header_line_\" + i + \"_value\", entry.getValue());\r\n            \ti++;\r\n            }\r\n            prop.put(\"info_header_line\", i);\r\n        }\r\n    }","commit_id":"41d7e86299ade140f95135751d6d2c7303e8a990","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static String formatImageAnchor(TreeSet anchor) {\r\n        final StringBuffer result = new StringBuffer((anchor.size() + 1) * 256);\r\n        result.append(\"<table border=\\\"0\\\" cellspacing=\\\"0\\\" cellpadding=\\\"0\\\">\");\r\n        final Iterator iter = anchor.iterator();\r\n        htmlFilterImageEntry ie;\r\n        while (iter.hasNext()) {\r\n            ie = (htmlFilterImageEntry) iter.next();\r\n            result.append(\"<tr valign=\\\"top\\\"><td><span class=\\\"small\\\">\").append(ie.alt()).append(\"&nbsp;<\/span><\/td><td class=\\\"tt\\\">\").append(ie.url().toNormalform()).append(\"<\/td><\/tr>\");\r\n        }\r\n        return result.append(\"<\/table>\").toString();\r\n    }","id":42101,"modified_method":"private static void formatImageAnchor(serverObjects prop, TreeSet anchor) {\r\n        final Iterator iter = anchor.iterator();\r\n        htmlFilterImageEntry ie;\r\n        prop.put(\"info_type_images\", anchor.size());\r\n        int i = 0;\r\n        while (iter.hasNext()) {\r\n            ie = (htmlFilterImageEntry) iter.next();\r\n            prop.put(\"info_type_images_\" + i + \"_name\", ie.alt().replaceAll(\"\\n\", \"\").trim());\r\n            prop.put(\"info_type_images_\" + i + \"_link\", ie.url().toNormalform());\r\n            i++;\r\n        }\r\n    }","commit_id":"41d7e86299ade140f95135751d6d2c7303e8a990","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * This method takes a set of InetAddresses, represented by an inetAddressmap, and:\n     * - if the resulting set is non-empty, goes through to see if all InetAddress-related \n     * user settings have a consistent IP version: v4 or v6, and throws an exception if not\n     * - if the resulting set is empty, sets the default IP version based on available stacks \n     * and if a dual stack, stack preferences \n     * - sets the IP version to be used in the JGroups session\n     */\n    public static boolean getIPVersion(Map<String, Map<String,InetAddressInfo>> inetAddressMap) throws Exception {\n    \t\n    \t// for each InetAddressInfo with non-null value, add to sets\n    \t// sets which hold user those IP addresses specified by user (non-null)\n    \tSet<InetAddress> userSpecified = new HashSet<InetAddress>() ;\n    \tSet<InetAddress> userSpecifiedIPv4 = new HashSet<InetAddress>() ;\n    \tSet<InetAddress> userSpecifiedIPv6 = new HashSet<InetAddress>() ;\n\n\t\tfor (Map.Entry<String,Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n\t\t\tString protocol = inetAddressMapEntry.getKey() ;\n\t\t\tMap<String, InetAddressInfo> protocolInetAddressMap = inetAddressMapEntry.getValue() ; \n\t\t\tfor (Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n\t\t\t\tString propertyName = protocolInetAddressMapEntry.getKey() ;\n\t\t\t\tInetAddressInfo inetAddressInfo = protocolInetAddressMapEntry.getValue() ; \n\t\t\t\t// add InetAddressInfo to sets based on IP version\n\t\t\t\tList<InetAddress> addresses = inetAddressInfo.getInetAddresses();\n\t\t\t\tfor (InetAddress address: addresses) {\n\t\t\t\t\tif (address == null) \n\t\t\t\t\t\tthrow new RuntimeException(\"This address should not be null! - something is wrong\") ;\n\t\t\t\t\tuserSpecified.add(address) ;\n\t\t\t\t\tif (address instanceof Inet4Address)\n\t\t\t\t\t\tuserSpecifiedIPv4.add(address) ;\n\t\t\t\t\telse \n\t\t\t\t\t\tuserSpecifiedIPv6.add(address) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}    \t\n\t\t\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"userSpecified set contents:\") ;\n\t\t\tfor (Iterator<InetAddress> iter = userSpecified.iterator(); iter.hasNext();) {\n\t\t\t\tInetAddress address = iter.next() ;\n\t\t\t\tlog.debug(address.toString()) ;\n\t\t\t}\n\t\t\tlog.debug(\"userSpecifiedIPv4 set contents:\") ;\n\t\t\tfor (Iterator<InetAddress> iter = userSpecifiedIPv4.iterator(); iter.hasNext();) {\n\t\t\t\tInetAddress address = iter.next() ;\n\t\t\t\tlog.debug(address.toString()) ;\n\t\t\t}\n\t\t\tlog.debug(\"userSpecifiedIPv6 set contents:\") ;\n\t\t\tfor (Iterator<InetAddress> iter = userSpecifiedIPv6.iterator(); iter.hasNext();) {\n\t\t\t\tInetAddress address = iter.next() ;\n\t\t\t\tlog.debug(address.toString()) ;\n\t\t\t}\n\t\t}\n\t\t\n    \t// now use sets to compute IP version\n\t\tboolean isIPv4StackAvailable = Util.isIPv4StackAvailable() ;\n\t\tboolean isIPv6StackAvailable = Util.isIPv6StackAvailable() ;\n\t\tboolean assumeIPv4 = true ;\n\t\t\n    \tif (log.isDebugEnabled()) {\n    \t\tlog.debug(\"isIPv4StackAvailable = \" + isIPv4StackAvailable) ;\n    \t\tlog.debug(\"isIPv6StackAvailable = \" + isIPv6StackAvailable) ;\n    \t}\n\t\t\n\t\t\n\t\t// the user supplied 1 or more IP address inputs. Check if we have a consistent set\n    \t// which matches a stack on this host\n    \tif (userSpecified.size() > 0) {\n    \t\t// check for a consistent IP version for IP addresses specified\n    \t\tif (!((userSpecifiedIPv4.size() > 0 && userSpecifiedIPv6.size() == 0) || \n    \t\t\t\t(userSpecifiedIPv4.size() == 0 && userSpecifiedIPv6.size() > 0))) {\n    \t\t\tthrow new RuntimeException(\"No consistent IP version available (IPv4 or IPv6) for user-specified IP addresses\") ;\n    \t\t}\n    \t\t// set the consistent version - we don't reach here unless we have one\n    \t\tassumeIPv4 = (userSpecifiedIPv4.size() > 0 && userSpecifiedIPv6.size() == 0) ;\n    \t\t\n    \t\tif (assumeIPv4 && !isIPv4StackAvailable) {\n    \t\t\tthrow new RuntimeException(\"A consistent IP version (IPv4) is available for \" + \n    \t\t\t\t\t\"user-specified addresses but there is no stack to support it\") ;\n    \t\t}\n    \t\tif (!assumeIPv4 && !isIPv6StackAvailable) {\n    \t\t\tthrow new RuntimeException(\"A consistent IP version (IPv6) is available for \" + \n\t\t\t\t\" user-specified addresses but there is no stack to support it\") ;\n    \t\t}\t\n    \t}\n    \telse {\n    \t\t// the user supplied no default IP addresses, so just get the stack preference.\n    \t\t\n    \t\t// if only IPv4 stack available, set assumeIPv4 = true\n    \t\tif (isIPv4StackAvailable && !isIPv6StackAvailable) {\n    \t\t\tassumeIPv4 = true ;\n    \t\t}\n    \t\telse if (isIPv6StackAvailable && !isIPv4StackAvailable) {\n    \t\t\tassumeIPv4 = false ;\n    \t\t}\n    \t\telse if (isIPv4StackAvailable && isIPv6StackAvailable) {\n    \t\t\t// get the System property which records user preference for a stack on a dual stack machine\n    \t\t\t// Bela wanted to check for null and set to IPv4\n    \t\t\tboolean preferIPv4Stack = Boolean.getBoolean(\"java.net.preferIPv4Stack\") ;\n    \t\t\tassumeIPv4 = preferIPv4Stack ;\n    \t\t}\n    \t}\n    \t\n    \tif (log.isDebugEnabled()) {\n    \t\tlog.debug(\"assumeIPv4 = \" + assumeIPv4) ;\n    \t}\n    \t\n    \treturn assumeIPv4 ;\n    }","id":42102,"modified_method":"/**\n     * Returns all inet addresses found\n     */\n    public static Collection<InetAddress> getAddresses(Map<String, Map<String, InetAddressInfo>> inetAddressMap) throws Exception {\n        Set<InetAddress> addrs=new HashSet<InetAddress>();\n\n        for(Map.Entry<String, Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n            Map<String, InetAddressInfo> protocolInetAddressMap=inetAddressMapEntry.getValue();\n            for(Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n                InetAddressInfo inetAddressInfo=protocolInetAddressMapEntry.getValue();\n                // add InetAddressInfo to sets based on IP version\n                List<InetAddress> addresses=inetAddressInfo.getInetAddresses();\n                for(InetAddress address : addresses) {\n                    if(address == null)\n                        throw new RuntimeException(\"This address should not be null! - something is wrong\");\n                    addrs.add(address);\n                }\n            }\n        }\n        return addrs;\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This method creates a list of all properties (Field or Method) in dependency order, \n     * where dependencies are specified using the dependsUpon specifier of the Property annotation. \n     * In particular, it does the following:\n     * (i) creates a master list of properties \n     * (ii) checks that all dependency references are present\n     * (iii) creates a copy of the master list in dependency order\n     */\n    static AccessibleObject[] computePropertyDependencies(Object obj, Properties properties) {\n    \t\n    \t// List of Fields and Methods of the protocol annotated with @Property\n    \tList<AccessibleObject> unorderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \tList<AccessibleObject> orderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \t// Maps property name to property object\n    \tMap<String, AccessibleObject> propertiesInventory = new HashMap<String, AccessibleObject>() ;\n    \t\n    \t// get the methods for this class and add them to the list if annotated with @Property\n    \tMethod[] methods=obj.getClass().getMethods();\n    \tfor(int i = 0; i < methods.length; i++) {\n \n    \t\tif (methods[i].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[i])) {\n    \t\t\tString propertyName = PropertyHelper.getPropertyName(methods[i]) ;\n    \t\t\tunorderedFieldsAndMethods.add(methods[i]) ;\n    \t\t\tpropertiesInventory.put(propertyName, methods[i]) ;\n    \t\t}\n    \t}\n    \t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \tfor(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\tField[] fields=clazz.getDeclaredFields();\n    \t\tfor(int i = 0; i < fields.length; i++ ) {\n    \t\t\tif (fields[i].isAnnotationPresent(Property.class)) {\n         \t\t\tString propertyName = PropertyHelper.getPropertyName(fields[i], properties) ;\n    \t\t\t\tunorderedFieldsAndMethods.add(fields[i]) ;\n    \t\t\t\t// may need to change this based on name parameter of Property\n    \t\t\t\tpropertiesInventory.put(propertyName, fields[i]) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t    \t\n//    \tif (log.isDebugEnabled()) {\n//    \t\tlog.debug(\"Properties inventory keyset for protocol: \" + obj.getClass().getName());\n//    \t\tSet<String> keyset = propertiesInventory.keySet();\n//    \t\tfor (Iterator<String> i = keyset.iterator(); i.hasNext();) {\n//    \t\t\tString property = i.next() ;\n//    \t\t\tlog.debug(\"property = \" + property);\n//    \t\t}\n//    \t}    \t\n    \t\n    \t// at this stage, we have all Fields and Methods annotated with @Property\n    \tcheckDependencyReferencesPresent(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n    \t// order the fields and methods by dependency\n    \torderedFieldsAndMethods = orderFieldsAndMethodsByDependency(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n//    \tif (log.isDebugEnabled()) {\n//    \t\tlog.debug(\"Ordered Fields and Methods for protocol: \" + obj.getClass().getName());\n//    \t\tfor (int i = 0; i < orderedFieldsAndMethods.size(); i++) {\n//    \t\t\tAccessibleObject ao = orderedFieldsAndMethods.get(i) ;\n//    \t\t\tlog.debug(\"name = \" + ao.toString());\n//    \t\t}\n//    \t}\n    \t\n    \t// convert to array of Objects\n    \tAccessibleObject[] result = new AccessibleObject[orderedFieldsAndMethods.size()] ;\n    \tfor(int i = 0; i < orderedFieldsAndMethods.size(); i++) {\n    \t\tresult[i] = orderedFieldsAndMethods.get(i) ;\n    \t}\n    \t\n    \treturn result ;\n    }","id":42103,"modified_method":"/**\n     * This method creates a list of all properties (Field or Method) in dependency order, \n     * where dependencies are specified using the dependsUpon specifier of the Property annotation. \n     * In particular, it does the following:\n     * (i) creates a master list of properties \n     * (ii) checks that all dependency references are present\n     * (iii) creates a copy of the master list in dependency order\n     */\n    static AccessibleObject[] computePropertyDependencies(Object obj, Map<String,String> properties) {\n    \t\n    \t// List of Fields and Methods of the protocol annotated with @Property\n    \tList<AccessibleObject> unorderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \tList<AccessibleObject> orderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \t// Maps property name to property object\n    \tMap<String, AccessibleObject> propertiesInventory = new HashMap<String, AccessibleObject>() ;\n    \t\n    \t// get the methods for this class and add them to the list if annotated with @Property\n    \tMethod[] methods=obj.getClass().getMethods();\n    \tfor(int i = 0; i < methods.length; i++) {\n \n    \t\tif (methods[i].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[i])) {\n    \t\t\tString propertyName = PropertyHelper.getPropertyName(methods[i]) ;\n    \t\t\tunorderedFieldsAndMethods.add(methods[i]) ;\n    \t\t\tpropertiesInventory.put(propertyName, methods[i]) ;\n    \t\t}\n    \t}\n    \t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \tfor(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\tField[] fields=clazz.getDeclaredFields();\n    \t\tfor(int i = 0; i < fields.length; i++ ) {\n    \t\t\tif (fields[i].isAnnotationPresent(Property.class)) {\n         \t\t\tString propertyName = PropertyHelper.getPropertyName(fields[i], properties) ;\n    \t\t\t\tunorderedFieldsAndMethods.add(fields[i]) ;\n    \t\t\t\t// may need to change this based on name parameter of Property\n    \t\t\t\tpropertiesInventory.put(propertyName, fields[i]) ;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \t// at this stage, we have all Fields and Methods annotated with @Property\n    \tcheckDependencyReferencesPresent(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n    \t// order the fields and methods by dependency\n    \torderedFieldsAndMethods = orderFieldsAndMethodsByDependency(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n    \t// convert to array of Objects\n    \tAccessibleObject[] result = new AccessibleObject[orderedFieldsAndMethods.size()] ;\n    \tfor(int i = 0; i < orderedFieldsAndMethods.size(); i++) {\n    \t\tresult[i] = orderedFieldsAndMethods.get(i) ;\n    \t}\n    \t\n    \treturn result ;\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndAssignField(Object obj, Field field, Properties props) throws Exception {\n\n    \tif(field.isAnnotationPresent(Property.class)) {\n    \t\tString propertyName = PropertyHelper.getPropertyName(field, props) ;\n    \t\tString propertyValue=props.getProperty(propertyName);\n    \t\t\n    \t\tif(propertyValue != null || !PropertyHelper.usesDefaultConverter(field)){\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, field, props, propertyValue);\n    \t\t\t\tif(converted != null)\n    \t\t\t\t\tsetField(field, obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Property assignment of \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \" with original property value \" + propertyValue + \" and converted to \" + converted \n    \t\t\t\t\t\t+ \" could not be assigned. Exception is \" +e, e);\n    \t\t\t}\n    \t\t\tfinally {\n    \t\t\t\tprops.remove(propertyName);\n    \t\t\t}\n    \t\t}\n    \t}\n    }","id":42104,"modified_method":"public static void resolveAndAssignField(Object obj, Field field, Map<String,String> props) throws Exception {\n    \tif(field.isAnnotationPresent(Property.class)) {\n    \t\tString propertyName = PropertyHelper.getPropertyName(field, props) ;\n    \t\tString propertyValue=props.get(propertyName);\n\n            // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n            String tmp=grabSystemProp(field.getAnnotation(Property.class));\n            if(tmp != null)\n                propertyValue=tmp;\n            \n    \t\tif(propertyValue != null || !PropertyHelper.usesDefaultConverter(field)){\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, field, props, propertyValue);\n    \t\t\t\tif(converted != null)\n    \t\t\t\t\tsetField(field, obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Property assignment of \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \" with original property value \" + propertyValue + \" and converted to \" + converted \n    \t\t\t\t\t\t+ \" could not be assigned. Exception is \" +e, e);\n    \t\t\t}\n    \t\t}\n\n            props.remove(propertyName);\n    \t}\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public Properties getOriginalProperties() throws Exception {\n        \tProperties props = new Properties() ; \n        \t\n        \tparsePropertiesString(properties_str, props) ;\n        \treturn props ;\n        }","id":42105,"modified_method":"public Map<String, String> getOriginalProperties() throws Exception {\n        \tMap<String,String> props = new HashMap<String,String>();\n        \tparsePropertiesString(properties_str, props) ;\n        \treturn props ;\n        }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndInvokePropertyMethod(Object obj, Method method, Properties props) throws Exception {\n    \tString methodName=method.getName();\n    \tif(method.isAnnotationPresent(Property.class) && isSetPropertyMethod(method)) {\n    \t\tString propertyName=PropertyHelper.getPropertyName(method) ;\n    \t\tString propertyValue=props.getProperty(propertyName);\n    \t\tif(propertyValue != null) {\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, method, props, propertyValue);\n    \t\t\t\tmethod.invoke(obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Could not assign property \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \", method is \" + methodName + \", converted value is \" + converted, e);\n    \t\t\t}\n    \t\t\tfinally {\n    \t\t\t\tprops.remove(propertyName);\n    \t\t\t}\n    \t\t}\n    \t}\n    }","id":42106,"modified_method":"public static void resolveAndInvokePropertyMethod(Object obj, Method method, Map<String,String> props) throws Exception {\n    \tString methodName=method.getName();\n    \tif(method.isAnnotationPresent(Property.class) && isSetPropertyMethod(method)) {\n    \t\tString propertyName=PropertyHelper.getPropertyName(method) ;\n    \t\tString propertyValue=props.get(propertyName);\n\n            // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n            String tmp=grabSystemProp(method.getAnnotation(Property.class));\n            if(tmp != null)\n                propertyValue=tmp;\n\n    \t\tif(propertyValue != null) {\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, method, props, propertyValue);\n    \t\t\t\tmethod.invoke(obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Could not assign property \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \", method is \" + methodName + \", converted value is \" + converted, e);\n    \t\t\t}\n    \t\t}\n\n            props.remove(propertyName);\n    \t}\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static Map<String, Map<String,InetAddressInfo>> createInetAddressMap(Vector<ProtocolConfiguration> protocol_configs, \n    \t\tVector<Protocol> protocols) throws Exception {\n    \t// Map protocol -> Map<String, InetAddressInfo>, where the latter is protocol specific\n    \tMap<String, Map<String,InetAddressInfo>> inetAddressMap = new HashMap<String, Map<String, InetAddressInfo>>() ;\n\n    \t// collect InetAddressInfo\n    \tfor (int i = 0; i < protocol_configs.size(); i++) {    \t\t        \t\n    \t\tProtocolConfiguration protocol_config = protocol_configs.get(i) ;\n    \t\tProtocol protocol = protocols.get(i) ;\n    \t\tString protocolName = protocol.getName();\n\n    \t\t// maps property names to InetAddressInfo objects\n    \t\tMap<String, InetAddressInfo> protocolInetAddressMap = new HashMap<String,InetAddressInfo>() ;\n    \t\tinetAddressMap.put(protocolName, protocolInetAddressMap) ;\n\n    \t\tProperties properties = null ;\n    \t\t// regenerate the Properties which were destroyed during basic property processing\n    \t\tproperties = protocol_config.getOriginalProperties();\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Processing InetAddressInfo for protocol: \" + protocolName);\n\n    \t\t// check which InetAddress-related properties are ***non-null ***, and \n    \t\t// create an InetAddressInfo structure for them\n    \t\tMethod[] methods=protocol.getClass().getMethods();\n    \t\tfor(int j = 0; j < methods.length; j++) {\n    \t\t\tif (methods[j].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[j])) {\n    \t\t\t\tString propertyName = PropertyHelper.getPropertyName(methods[j]) ;\n    \t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n    \t\t\t\tif (log.isDebugEnabled())\n    \t\t\t\t\tlog.debug(\"Processing InetAddressInfo for property \"+ propertyName+\" with value \" +propertyValue );\n    \t\t\t\tif (propertyValue != null && InetAddressInfo.isInetAddressRelated(methods[j])) {\n    \t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, propertyValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t}\n\t    \t\t\t\tif (log.isDebugEnabled())\n\t    \t\t\t\t\tlog.debug(\"Adding InetAddressInfo for property \"+propertyName+\" with value \" +propertyValue );\n    \t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, methods[j], properties, propertyValue, converted) ;\n    \t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ; \n    \t\t\t\t} // recompute\n    \t\t\t}\n    \t\t}\n\n    \t\t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \t\tfor(Class<?> clazz=protocol.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\t\tField[] fields=clazz.getDeclaredFields();\n    \t\t\tfor(int j = 0; j < fields.length; j++ ) {\n    \t\t\t\tif (fields[j].isAnnotationPresent(Property.class)) {\n     \t\t\t\t\tString propertyName = PropertyHelper.getPropertyName(fields[j], properties) ;\n    \t\t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n        \t\t\t\tif (log.isDebugEnabled())\n        \t\t\t\t\tlog.debug(\"Processing InetAddressInfo for property \"+propertyName+\" with value \" +propertyValue );\n    \t\t\t\t\tif ((propertyValue != null || !PropertyHelper.usesDefaultConverter(fields[j])) \n    \t\t\t\t\t\t\t&& InetAddressInfo.isInetAddressRelated(fields[j])) {\n    \t\t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, propertyValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t\t}\n\t\t    \t\t\t\tif (log.isDebugEnabled())\n\t\t    \t\t\t\t\tlog.debug(\"Adding InetAddressInfo for property \"+propertyName+\" with value \" +propertyValue );\n    \t\t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, fields[j], properties, propertyValue, converted) ;\n    \t\t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ; \n    \t\t\t\t\t}// recompute\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\t\n    \t}\n\n    \t// print out maps for debugging\n    \tif (log.isDebugEnabled()) {\n    \t\tfor (Map.Entry<String,Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n    \t\t\tString protocol = inetAddressMapEntry.getKey() ;\n    \t\t\tMap<String, InetAddressInfo> protocolInetAddressMap = inetAddressMapEntry.getValue() ; \n\n    \t\t\tlog.debug(\"***InetAddressInfo for protocol: \" + protocol + \"***\") ;\n    \t\t\tfor (Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n    \t\t\t\tString propertyName = protocolInetAddressMapEntry.getKey() ;\n    \t\t\t\tInetAddressInfo inetAddressInfo = protocolInetAddressMapEntry.getValue() ; \n    \t\t\t\tlog.debug(\"propertyName=\" + propertyName + \", addrinfo=\" + inetAddressInfo.toString()) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn inetAddressMap ;\n    }","id":42107,"modified_method":"public static Map<String, Map<String,InetAddressInfo>> createInetAddressMap(Vector<ProtocolConfiguration> protocol_configs, \n    \t\tVector<Protocol> protocols) throws Exception {\n    \t// Map protocol -> Map<String, InetAddressInfo>, where the latter is protocol specific\n    \tMap<String, Map<String,InetAddressInfo>> inetAddressMap = new HashMap<String, Map<String, InetAddressInfo>>() ;\n\n    \t// collect InetAddressInfo\n    \tfor (int i = 0; i < protocol_configs.size(); i++) {    \t\t        \t\n    \t\tProtocolConfiguration protocol_config = protocol_configs.get(i) ;\n    \t\tProtocol protocol = protocols.get(i) ;\n    \t\tString protocolName = protocol.getName();\n\n    \t\t// regenerate the Properties which were destroyed during basic property processing\n    \t\tMap<String,String> properties = protocol_config.getOriginalProperties();\n\n    \t\t// check which InetAddress-related properties are ***non-null ***, and\n    \t\t// create an InetAddressInfo structure for them\n    \t\t// Method[] methods=protocol.getClass().getMethods();\n            Method[] methods=Util.getAllDeclaredMethodsWithAnnotations(protocol.getClass(), Property.class);\n    \t\tfor(int j = 0; j < methods.length; j++) {\n    \t\t\tif (methods[j].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[j])) {\n    \t\t\t\tString propertyName = PropertyHelper.getPropertyName(methods[j]) ;\n    \t\t\t\tString propertyValue = properties.get(propertyName);\n\n                    // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n                    String tmp=grabSystemProp(methods[j].getAnnotation(Property.class));\n                    if(tmp != null)\n                        propertyValue=tmp;\n\n    \t\t\t\tif (propertyValue != null && InetAddressInfo.isInetAddressRelated(methods[j])) {\n    \t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, propertyValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t}\n    \t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, methods[j], properties, propertyValue, converted) ;\n\n                        Map<String, InetAddressInfo> protocolInetAddressMap=inetAddressMap.get(protocolName);\n                        if(protocolInetAddressMap == null) {\n                            protocolInetAddressMap = new HashMap<String,InetAddressInfo>() ;\n                            inetAddressMap.put(protocolName, protocolInetAddressMap) ;\n                        }\n    \t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ; \n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n\n    \t\t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \t\tfor(Class<?> clazz=protocol.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\t\tField[] fields=clazz.getDeclaredFields();\n    \t\t\tfor(int j = 0; j < fields.length; j++ ) {\n    \t\t\t\tif (fields[j].isAnnotationPresent(Property.class)) {\n     \t\t\t\t\tString propertyName = PropertyHelper.getPropertyName(fields[j], properties) ;\n    \t\t\t\t\tString propertyValue = properties.get(propertyName) ;\n\n                        // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n                        String tmp=grabSystemProp(fields[j].getAnnotation(Property.class));\n                        if(tmp != null)\n                            propertyValue=tmp;\n                        \n    \t\t\t\t\tif ((propertyValue != null || !PropertyHelper.usesDefaultConverter(fields[j]))\n    \t\t\t\t\t\t\t&& InetAddressInfo.isInetAddressRelated(protocol, fields[j])) {\n    \t\t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, propertyValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t\t}\n    \t\t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, fields[j], properties, propertyValue, converted) ;\n\n                            Map<String, InetAddressInfo> protocolInetAddressMap=inetAddressMap.get(protocolName);\n                            if(protocolInetAddressMap == null) {\n                                protocolInetAddressMap = new HashMap<String,InetAddressInfo>() ;\n                                inetAddressMap.put(protocolName, protocolInetAddressMap) ;\n                            }\n    \t\t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ;\n    \t\t\t\t\t}// recompute\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\t\n    \t}\n    \treturn inetAddressMap ;\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"static boolean isInetAddressRelated(Method m) {\n    \t\tif (hasParameterizedType(m)) {\n    \t\t\tType[] types = m.getGenericParameterTypes();\n    \t\t\tParameterizedType methodParamType = (ParameterizedType)types[0] ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(methodParamType) ;\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\tif(log.isDebugEnabled()) {\n    \t\t\t\t\tlog.debug(\"Method \" + m.getName() + \" failed paramaterizedTypeSanityCheck()\") ;\n    \t\t\t\t}\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not \n    \t\t\t\t// an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) methodParamType.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;    \t\t\t\n    \t\t}\n    \t\telse {\n    \t\t\tClass<?> methodParamType = m.getParameterTypes()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(methodParamType) ;\n    \t\t}\n    \t}","id":42108,"modified_method":"static boolean isInetAddressRelated(Method m) {\n    \t\tif (hasParameterizedType(m)) {\n    \t\t\tType[] types = m.getGenericParameterTypes();\n    \t\t\tParameterizedType methodParamType = (ParameterizedType)types[0] ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(methodParamType) ;\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\tif(log.isErrorEnabled()) {\n    \t\t\t\t\tlog.error(\"Method \" + m.getName() + \" failed paramaterizedTypeSanityCheck()\") ;\n    \t\t\t\t}\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not \n    \t\t\t\t// an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) methodParamType.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;    \t\t\t\n    \t\t}\n    \t\telse {\n    \t\t\tClass<?> methodParamType = m.getParameterTypes()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(methodParamType) ;\n    \t\t}\n    \t}","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndInvokePropertyMethods(Object obj, Properties props) throws Exception {\n        Method[] methods=obj.getClass().getMethods();\n        for(Method method: methods) {\n        \tresolveAndInvokePropertyMethod(obj, method, props) ;\n        }\n    }","id":42109,"modified_method":"public static void resolveAndInvokePropertyMethods(Object obj, Map<String,String> props) throws Exception {\n        Method[] methods=obj.getClass().getMethods();\n        for(Method method: methods) {\n        \tresolveAndInvokePropertyMethod(obj, method, props) ;\n        }\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void removeDeprecatedProperties(Object obj, Properties props) throws Exception {\n        //traverse class hierarchy and find all deprecated properties\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            if(clazz.isAnnotationPresent(DeprecatedProperty.class)) {\n                DeprecatedProperty declaredAnnotation=clazz.getAnnotation(DeprecatedProperty.class);\n                String[] deprecatedProperties=declaredAnnotation.names();\n                for(String propertyName : deprecatedProperties) {\n                    String propertyValue=props.getProperty(propertyName);\n                    if(propertyValue != null) {\n                        if(log.isWarnEnabled()) {\n                            String name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n                            log.warn(name + \" property \" + propertyName + \" was deprecated and is ignored\");\n                        }\n                        props.remove(propertyName);\n                    }\n                }\n            }\n        }\n    }","id":42110,"modified_method":"public static void removeDeprecatedProperties(Object obj, Map<String,String> props) throws Exception {\n        //traverse class hierarchy and find all deprecated properties\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            if(clazz.isAnnotationPresent(DeprecatedProperty.class)) {\n                DeprecatedProperty declaredAnnotation=clazz.getAnnotation(DeprecatedProperty.class);\n                String[] deprecatedProperties=declaredAnnotation.names();\n                for(String propertyName : deprecatedProperties) {\n                    String propertyValue=props.get(propertyName);\n                    if(propertyValue != null) {\n                        if(log.isWarnEnabled()) {\n                            String name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n                            log.warn(name + \" property \" + propertyName + \" was deprecated and is ignored\");\n                        }\n                        props.remove(propertyName);\n                    }\n                }\n            }\n        }\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void processDefaultValues(Vector<ProtocolConfiguration> protocol_configs, Vector<Protocol> protocols, boolean assumeIPv4) throws Exception {\n\n    \tfor (int i = 0; i < protocol_configs.size(); i++) {    \t\t\n    \t\tProtocolConfiguration protocol_config = protocol_configs.get(i) ;\n    \t\tProtocol protocol = protocols.get(i) ;\n    \t\tString protocolName = protocol.getName();\n\n    \t\t// regenerate the Properties which were destroyed during basic property processing\n    \t\tProperties properties = null ;\n    \t\tproperties = protocol_config.getOriginalProperties(); \n\n    \t\t// check which properties are null\n    \t\tMethod[] methods=protocol.getClass().getMethods();\n    \t\tfor(int j = 0; j < methods.length; j++) {\n    \t\t\tif (methods[j].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[j])) {\n    \t\t\t\tString propertyName = PropertyHelper.getPropertyName(methods[j]) ;\n    \t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n    \t\t\t\t// if propertyValue is null, check if there is a default value we can assign\n    \t\t\t\tif (propertyValue == null) {\n    \t\t\t\t\tProperty annotation = methods[j].getAnnotation(Property.class) ;\n    \t\t\t\t\t\n    \t\t\t\t\t// get the default value for the method- check for InetAddress types\n    \t\t\t\t\tString defaultValue = null ;\n    \t\t\t\t\tif (InetAddressInfo.isInetAddressRelated(methods[j])) {\n    \t\t\t\t\t\tif (assumeIPv4)\n    \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv4() ;\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv6() ;\n    \t\t\t\t\t}\n    \t\t\t\t\telse {\n    \t\t\t\t\t\tdefaultValue = annotation.defaultValue() ;\n    \t\t\t\t\t} \n    \t\t\t\t\t// got the default value\n    \t\t\t\t\tif (defaultValue != null && defaultValue.length() > 0) {\n    \t\t\t\t\t\tif (log.isDebugEnabled()) \n    \t\t\t\t\t\t\tlog.debug(\"Setting default value for property \" + propertyName) ;\n    \t\t\t\t\t\tObject converted=null;\n    \t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, defaultValue);\n    \t\t\t\t\t\t\tmethods[j].invoke(protocol, converted);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tcatch(Exception e) {\n    \t\t\t\t\t\t\tthrow new Exception(\"Deafult could not be assined for method \" + propertyName + \" in \"\n    \t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + defaultValue + \".Exception is \" +e, e);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (log.isDebugEnabled()) {\n    \t\t\t\t\t\t\tif (converted != null)\n    \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value \" + converted.toString()) ;\n    \t\t\t\t\t\t\telse \n    \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value null\") ;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} // for methods\n\n    \t\t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \t\tfor(Class<?> clazz=protocol.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\t\tField[] fields=clazz.getDeclaredFields();\n    \t\t\tfor(int j = 0; j < fields.length; j++ ) {\n    \t\t\t\tif (fields[j].isAnnotationPresent(Property.class)) {\n    \t\t\t\t\tString propertyName = PropertyHelper.getPropertyName(fields[j], properties) ;\n    \t\t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n    \t\t\t\t\tif (propertyValue == null) {\n    \t\t\t\t\t\t// add to collection of @Properties with no user specified value\n    \t\t\t\t\t\tProperty annotation = fields[j].getAnnotation(Property.class) ;\n    \t\t\t\t\t\t\n        \t\t\t\t\t// get the default value for the field - check for InetAddress types\n        \t\t\t\t\tString defaultValue = null ;\n        \t\t\t\t\tif (InetAddressInfo.isInetAddressRelated(fields[j])) {\n        \t\t\t\t\t\tif (assumeIPv4)\n        \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv4() ;\n        \t\t\t\t\t\telse\n        \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv6() ;\n        \t\t\t\t\t}\n        \t\t\t\t\telse {\n        \t\t\t\t\t\tdefaultValue = annotation.defaultValue() ;\n        \t\t\t\t\t} \n        \t\t\t\t\t// got the default value    \n    \t\t\t\t\t\t\n        \t\t\t\t\t// set a default value for the field\n    \t\t\t\t\t\tif(defaultValue != null && defaultValue.length() > 0) {\n    \t\t\t\t\t\t\t// condition for invoking converter\n    \t\t\t\t\t\t\tif(defaultValue != null || !PropertyHelper.usesDefaultConverter(fields[j])) {\n    \t    \t\t\t\t\t\tif (log.isDebugEnabled()) \n    \t    \t\t\t\t\t\t\tlog.debug(\"Setting default value for property \" + propertyName) ;\n\n    \t\t\t\t\t\t\t\tObject converted=null;\n    \t\t\t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, defaultValue);\n    \t\t\t\t\t\t\t\t\tif(converted != null)\n    \t\t\t\t\t\t\t\t\t\tsetField(fields[j], protocol, converted);\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\tcatch(Exception e) {\n    \t\t\t\t\t\t\t\t\tthrow new Exception(\"Deafult could not be assined for field \" + propertyName + \" in \"\n    \t\t\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + defaultValue + \".Exception is \" +e, e);\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\n            \t\t\t\t\t\tif (log.isDebugEnabled()) {\n            \t\t\t\t\t\t\tif (converted != null)\n            \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value \" + converted.toString()) ;\n            \t\t\t\t\t\t\telse \n            \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value null\") ;\n            \t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} // for fields\n    \t}\n    }","id":42111,"modified_method":"public static void processDefaultValues(Vector<ProtocolConfiguration> protocol_configs, Vector<Protocol> protocols, int ip_version) throws Exception {\n        InetAddress default_ip_address=Util.getFirstNonLoopbackAddress(ip_version);\n        if(default_ip_address == null) {\n            log.warn(\"unable to find an address other than loopback for IP version \" + ip_version);\n            default_ip_address=Util.getLocalhost(ip_version);\n        }\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            ProtocolConfiguration protocol_config=protocol_configs.get(i);\n            Protocol protocol=protocols.get(i);\n            String protocolName=protocol.getName();\n\n            // regenerate the Properties which were destroyed during basic property processing\n            Map<String,String> properties=protocol_config.getOriginalProperties();\n\n            Method[] methods=Util.getAllDeclaredMethodsWithAnnotations(protocol.getClass(), Property.class);\n            for(int j=0; j < methods.length; j++) {\n                if(isSetPropertyMethod(methods[j])) {\n                    String propertyName=PropertyHelper.getPropertyName(methods[j]);\n\n                    Object propertyValue=getValueFromProtocol(protocol, propertyName);\n                    if(propertyValue == null) { // if propertyValue is null, check if there is a we can use\n                        Property annotation=methods[j].getAnnotation(Property.class);\n\n                        // get the default value for the method- check for InetAddress types\n                        String defaultValue=null;\n                        if(InetAddressInfo.isInetAddressRelated(methods[j])) {\n                            defaultValue=ip_version == 4? annotation.defaultValueIPv4() : annotation.defaultValueIPv6();\n                            if(defaultValue != null && defaultValue.length() > 0) {\n                                Object converted=null;\n                                try {\n                                    if(defaultValue.equalsIgnoreCase(Global.NON_LOOPBACK_ADDRESS))\n                                        converted=default_ip_address;\n                                    else\n                                        converted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, defaultValue);\n                                    methods[j].invoke(protocol, converted);\n                                }\n                                catch(Exception e) {\n                                    throw new Exception(\"default could not be assigned for method \" + propertyName + \" in \"\n                                            + protocolName + \" with default \" + defaultValue, e);\n                                }\n                                if(log.isDebugEnabled())\n                                    log.debug(\"set property \" + protocolName + \".\" + propertyName + \" to default value \" + converted);\n                            }\n                        }\n                    }\n                }\n            } \n\n            //traverse class hierarchy and find all annotated fields and add them to the list if annotated\n            Field[] fields=Util.getAllDeclaredFieldsWithAnnotations(protocol.getClass(), Property.class);\n            for(int j=0; j < fields.length; j++) {\n                String propertyName=PropertyHelper.getPropertyName(fields[j], properties);\n                Object propertyValue=getValueFromProtocol(protocol, fields[j]);\n                if(propertyValue == null) {\n                    // add to collection of @Properties with no user specified value\n                    Property annotation=fields[j].getAnnotation(Property.class);\n\n                    // get the default value for the field - check for InetAddress types\n                    String defaultValue=null;\n                    if(InetAddressInfo.isInetAddressRelated(protocol, fields[j])) {\n                        defaultValue=ip_version == 4? annotation.defaultValueIPv4() : annotation.defaultValueIPv6();\n                        if(defaultValue != null && defaultValue.length() > 0) {\n                            // condition for invoking converter\n                            if(defaultValue != null || !PropertyHelper.usesDefaultConverter(fields[j])) {\n                                Object converted=null;\n                                try {\n                                    if(defaultValue.equalsIgnoreCase(Global.NON_LOOPBACK_ADDRESS))\n                                        converted=default_ip_address;\n                                    else\n                                        converted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, defaultValue);\n                                    if(converted != null)\n                                        setField(fields[j], protocol, converted);\n                                }\n                                catch(Exception e) {\n                                    throw new Exception(\"default could not be assigned for field \" + propertyName + \" in \"\n                                            + protocolName + \" with default value \" + defaultValue, e);\n                                }\n\n                                if(log.isDebugEnabled())\n                                    log.debug(\"set property \" + protocolName + \".\" + propertyName + \" to default value \" + converted);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void checkIPv6Scopes(Map<String, Map<String,InetAddressInfo>> inetAddressMap) throws Exception {\n    \t\n    \t// for each IPv6 address specified, check that if a link-local address is used, it has a scope\n\t\tfor (Map.Entry<String,Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n\t\t\tString protocol = inetAddressMapEntry.getKey() ;\n\t\t\tMap<String, InetAddressInfo> protocolInetAddressMap = inetAddressMapEntry.getValue() ; \n\t\t\tfor (Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n\t\t\t\tString propertyName = protocolInetAddressMapEntry.getKey() ;\n\t\t\t\tInetAddressInfo inetAddressInfo = protocolInetAddressMapEntry.getValue() ; \n\t\t\t\tList<InetAddress> addresses = inetAddressInfo.getInetAddresses();\n\t\t\t\tfor (InetAddress address: addresses) {\n\t\t\t\t\tif (address == null) \n\t\t\t\t\t\tthrow new RuntimeException(\"This address should not be null! - something is wrong\") ;\n\t\t\t\t\t\n\t\t\t\t\t// check if each link-local address has a scope\n\t\t\t\t\tif (address instanceof Inet6Address && address.isLinkLocalAddress()) {\n\t\t\t\t\t\t// check scope is present\n\t\t\t\t\t\tString propertyValue = inetAddressInfo.getStringValue() ;\n\t\t\t\t\t\tif (propertyValue == null)\n\t\t\t\t\t\t\tthrow new RuntimeException(\"The string value for this address should not be null! - something is wrong\") ;\n\n\t\t\t\t\t\t//check for scope and scope value here!\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(\"Checking scope for Inet6 address \" + address.getHostName() + \n\t\t\t\t\t\t\t\t\t\" with user specified value \" + propertyValue) ;\n\t\t\t\t\t\t// TODO - implement the check\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}    \t\n    }","id":42112,"modified_method":"public static void checkIPv6Scopes(Map<String, Map<String, InetAddressInfo>> map) throws Exception {\n        // for each IPv6 address specified, check that if a link-local address is used, it has a scope\n        for(Map.Entry<String, Map<String, InetAddressInfo>> entry : map.entrySet()) {\n            Map<String, InetAddressInfo> addr_map=entry.getValue();\n            for(Map.Entry<String, InetAddressInfo> entry2 : addr_map.entrySet()) {\n                InetAddressInfo info=entry2.getValue();\n                List<InetAddress> addresses=info.getInetAddresses();\n                for(InetAddress address : addresses) {\n                    if(address == null)\n                        throw new RuntimeException(\"This address should not be null! - something is wrong\");\n\n                    // check if each link-local address has a scope\n                    if(address instanceof Inet6Address && address.isLinkLocalAddress()) {\n                        // check scope is present\n                        String propertyValue=info.getStringValue();\n                        if(propertyValue == null)\n                            throw new RuntimeException(\"The string value for this address should not be null! - something is wrong\");\n\n                        // throw an exception if no scope is present\n                        int scope=((Inet6Address)address).getScopeId();\n                        if(scope == 0) {\n                            throw new RuntimeException(\"Link-local IPv6 address \" + address.getHostName() +\n                                    \" has no scope (e.g. %eth0)\");\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"InetAddressInfo(Protocol protocol, AccessibleObject fieldOrMethod, Properties properties, String stringValue, \n    \t\t\tObject convertedValue) {\n    \t\t// check input values\n    \t\tif (protocol == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Protocol for Field/Method must be non-null\") ;\n    \t\t}\t\t\n    \t\tif (fieldOrMethod instanceof Field) {\n    \t\t\tisField = true ;\n    \t\t} else if (fieldOrMethod instanceof Method) {\n    \t\t\tisField = false ;\n    \t\t} else \n    \t\t\tthrow new IllegalArgumentException(\"AccesibleObject is neither Field nor Method\") ;\n    \t\tif (properties == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Properties for Field/Method must be non-null\") ;\n    \t\t}\t\t\n\n    \t\t// set the values passed by the user - need to check for null\n    \t\tthis.protocol = protocol ;\n    \t\tthis.fieldOrMethod = fieldOrMethod ;\n    \t\tthis.properties = properties ;\n    \t\tthis.stringValue = stringValue ;\n    \t\tthis.convertedValue = convertedValue ;\n    \t\t\n    \t\t// set the property name\n    \t\tProperty annotation=fieldOrMethod.getAnnotation(Property.class);    \t\t\n    \t\tif (isField())\n        \t\tpropertyName=PropertyHelper.getPropertyName((Field)fieldOrMethod, properties) ;\n    \t\telse \n        \t\tpropertyName=PropertyHelper.getPropertyName((Method)fieldOrMethod) ;\n    \t\t\n    \t\t// is variable type parameterized\n    \t\tthis.isParameterized = false ;\n    \t\tif (isField())\n    \t\t\tthis.isParameterized = hasParameterizedType((Field)fieldOrMethod) ;\n    \t\telse \n    \t\t\tthis.isParameterized = hasParameterizedType((Method)fieldOrMethod) ;\n\n    \t\t// if parameterized, what is the base type?\n    \t\tthis.baseType = null ;\n    \t\tif (isField() && isParameterized) {\n    \t\t\t// the Field has a single type\n    \t\t\tParameterizedType fpt = (ParameterizedType)((Field)fieldOrMethod).getGenericType() ;\n    \t\t\tthis.baseType = fpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t\telse if (!isField() && isParameterized) {\n    \t\t\t// the Method has several parameters (and so types)\n    \t\t\tType[] types = (Type[])((Method)fieldOrMethod).getGenericParameterTypes();\n    \t\t\tParameterizedType mpt = (ParameterizedType) types[0] ;\n    \t\t\tthis.baseType = mpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t}","id":42113,"modified_method":"InetAddressInfo(Protocol protocol, AccessibleObject fieldOrMethod, Map<String,String> properties, String stringValue,\n    \t\t\tObject convertedValue) {\n    \t\t// check input values\n    \t\tif (protocol == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Protocol for Field/Method must be non-null\") ;\n    \t\t}\t\t\n    \t\tif (fieldOrMethod instanceof Field) {\n    \t\t\tisField = true ;\n    \t\t} else if (fieldOrMethod instanceof Method) {\n    \t\t\tisField = false ;\n    \t\t} else \n    \t\t\tthrow new IllegalArgumentException(\"AccesibleObject is neither Field nor Method\") ;\n    \t\tif (properties == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Properties for Field/Method must be non-null\") ;\n    \t\t}\t\t\n\n    \t\t// set the values passed by the user - need to check for null\n    \t\tthis.protocol = protocol ;\n    \t\tthis.fieldOrMethod = fieldOrMethod ;\n    \t\tthis.properties = properties ;\n    \t\tthis.stringValue = stringValue ;\n    \t\tthis.convertedValue = convertedValue ;\n    \t\t\n    \t\t// set the property name\n    \t\tProperty annotation=fieldOrMethod.getAnnotation(Property.class);    \t\t\n    \t\tif (isField())\n        \t\tpropertyName=PropertyHelper.getPropertyName((Field)fieldOrMethod, properties) ;\n    \t\telse \n        \t\tpropertyName=PropertyHelper.getPropertyName((Method)fieldOrMethod) ;\n    \t\t\n    \t\t// is variable type parameterized\n    \t\tthis.isParameterized = false ;\n    \t\tif (isField())\n    \t\t\tthis.isParameterized = hasParameterizedType((Field)fieldOrMethod) ;\n    \t\telse \n    \t\t\tthis.isParameterized = hasParameterizedType((Method)fieldOrMethod) ;\n\n    \t\t// if parameterized, what is the base type?\n    \t\tthis.baseType = null ;\n    \t\tif (isField() && isParameterized) {\n    \t\t\t// the Field has a single type\n    \t\t\tParameterizedType fpt = (ParameterizedType)((Field)fieldOrMethod).getGenericType() ;\n    \t\t\tthis.baseType = fpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t\telse if (!isField() && isParameterized) {\n    \t\t\t// the Method has several parameters (and so types)\n    \t\t\tType[] types = (Type[])((Method)fieldOrMethod).getGenericParameterTypes();\n    \t\t\tParameterizedType mpt = (ParameterizedType) types[0] ;\n    \t\t\tthis.baseType = mpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t}","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"private void parsePropertiesString(String properties_str, Properties properties) throws Exception {\n        \tint index = 0 ;\n            \n        \t/* \"in_port=5555;out_port=6666\" */\n            if(properties_str.length() > 0) {\n                String[] components=properties_str.split(\";\");\n                for(String property : components) {\n                    String name, value;\n                    index=property.indexOf('=');\n                    if(index == -1) {\n                        throw new Exception(\"Configurator.ProtocolConfiguration(): '=' not found in \" + property\n                                + \" of \"\n                                + protocol_name);\n                    }\n                    name=property.substring(0, index);\n                    value=property.substring(index + 1, property.length());\n                    properties.put(name, value);\n                }\n            }\n        }","id":42114,"modified_method":"private void parsePropertiesString(String properties_str, Map<String, String> properties) throws Exception {\n        \tint index = 0 ;\n            \n        \t/* \"in_port=5555;out_port=6666\" */\n            if(properties_str.length() > 0) {\n                String[] components=properties_str.split(\";\");\n                for(String property : components) {\n                    String name, value;\n                    index=property.indexOf('=');\n                    if(index == -1) {\n                        throw new Exception(\"Configurator.ProtocolConfiguration(): '=' not found in \" + property\n                                + \" of \" + protocol_name);\n                    }\n                    name=property.substring(0, index);\n                    value=property.substring(index + 1, property.length());\n                    properties.put(name, value);\n                }\n            }\n        }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     *  DFS of dependency graph formed by Property annotations and dependsUpon parameter\n     *  This is used to create a list of Properties in dependency order\n     */\n    static void addPropertyToDependencyList(List<AccessibleObject> orderedList, Map<String, AccessibleObject> props, Stack<AccessibleObject> stack, AccessibleObject obj) {\n    \n    \tif (orderedList.contains(obj))\n    \t\treturn ;\n    \t\n    \tif (stack.search(obj) > 0) {\n    \t\tthrow new RuntimeException(\"Deadlock in @Property dependency processing\") ;\n    \t}\n    \t// record the fact that we are processing obj\n    \tstack.push(obj) ;\n    \t// process dependencies for this object before adding it to the list\n    \tProperty annotation = obj.getAnnotation(Property.class) ;\n    \tString dependsClause = annotation.dependsUpon() ;\n    \tif (log.isDebugEnabled()) { \n    \t\tlog.trace(\"processing: \" + obj.toString() + \" with dependsUpon: \" + dependsClause);\n    \t}\n    \tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \twhile (st.hasMoreTokens()) {\n    \t\tString token = st.nextToken().trim();\n    \t\tAccessibleObject dep = props.get(token) ;\n    \t\t// if null, throw exception \n    \t\taddPropertyToDependencyList(orderedList, props, stack, dep) ;\n    \t}\n    \t// indicate we're done with processing dependencies\n    \tstack.pop() ;\n    \t// we can now add in dependency order\n    \torderedList.add(obj) ;\n    }","id":42115,"modified_method":"/**\n     *  DFS of dependency graph formed by Property annotations and dependsUpon parameter\n     *  This is used to create a list of Properties in dependency order\n     */\n    static void addPropertyToDependencyList(List<AccessibleObject> orderedList, Map<String, AccessibleObject> props, Stack<AccessibleObject> stack, AccessibleObject obj) {\n    \n    \tif (orderedList.contains(obj))\n    \t\treturn ;\n    \t\n    \tif (stack.search(obj) > 0) {\n    \t\tthrow new RuntimeException(\"Deadlock in @Property dependency processing\") ;\n    \t}\n    \t// record the fact that we are processing obj\n    \tstack.push(obj) ;\n    \t// process dependencies for this object before adding it to the list\n    \tProperty annotation = obj.getAnnotation(Property.class) ;\n    \tString dependsClause = annotation.dependsUpon() ;\n    \tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \twhile (st.hasMoreTokens()) {\n    \t\tString token = st.nextToken().trim();\n    \t\tAccessibleObject dep = props.get(token) ;\n    \t\t// if null, throw exception \n    \t\taddPropertyToDependencyList(orderedList, props, stack, dep) ;\n    \t}\n    \t// indicate we're done with processing dependencies\n    \tstack.pop() ;\n    \t// we can now add in dependency order\n    \torderedList.add(obj) ;\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    private Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {       \n        Vector<ProtocolConfiguration> protocol_configs=parseConfigurations(configuration);\n        Vector<Protocol> protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        // basic protocol sanity check\n        sanityCheck(protocols);\n        \n        // check InetAddress related features of stack\n        Map<String, Map<String,InetAddressInfo>> inetAddressMap = null ;\n        boolean assumeIPv4 ;\n        inetAddressMap = createInetAddressMap(protocol_configs, protocols) ;\n        assumeIPv4 = getIPVersion(inetAddressMap) ;\n        if (!assumeIPv4) {\n        \tcheckIPv6Scopes(inetAddressMap) ;\n        }\n        // process default values\n        processDefaultValues(protocol_configs, protocols, assumeIPv4) ;\n        \n        return connectProtocols(protocols);        \n    }","id":42116,"modified_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    private static Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {\n        Vector<ProtocolConfiguration> protocol_configs=parseConfigurations(configuration);\n        Vector<Protocol> protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        // basic protocol sanity check\n        sanityCheck(protocols);\n        \n        // check InetAddress related features of stack\n        Map<String, Map<String,InetAddressInfo>> inetAddressMap = createInetAddressMap(protocol_configs, protocols) ;\n        Collection<InetAddress> addrs=getAddresses(inetAddressMap);\n\n        int ip_version=Util.getIpStackType(); // 0 = n/a, 4 = IPv4, 6 = IPv6, 10=both IPv4 and IPv6\n\n        if(!addrs.isEmpty()) {\n            // check that all user-supplied InetAddresses have a consistent version\n            int addr_versions=determineIpVersionFromAddresses(addrs);\n\n            if(ip_version == 10)\n                ip_version=addr_versions;\n            else {\n                if(addr_versions != ip_version) { // mismatch between user supplied addresses and type of stack\n\n\n                    throw new RuntimeException(\"the type of the stack (IPv\" + ip_version + \") and the user supplied \" +\n                            \"addresses (IPv\" + addr_versions + \") don't match: \" + addrs +\n                            \".\\nUse \" + Global.IPv4 + \" or \" + Global.IPv6 + \" to pick the correct stack\");\n                }\n            }\n        }\n\n        if(ip_version == 10) {\n            if(Util.checkForWindows())\n                ip_version=4;\n            else\n                ip_version=6;\n            log.info(\"found both an IPv4 and an IPv6 stack, and no addresses were found to pick a stack, \" +\n                    \"defaulting to IPv\" + ip_version);\n        }\n\n        // check that all IPv6 link-local addresses have a scope\n        if(ip_version == 6)\n            checkIPv6Scopes(inetAddressMap) ;\n\n        // process default values\n        processDefaultValues(protocol_configs, protocols, ip_version) ;\n        \n        return connectProtocols(protocols);        \n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndAssignFields(Object obj, Properties props) throws Exception {\n        //traverse class hierarchy and find all annotated fields\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            Field[] fields=clazz.getDeclaredFields();\n            for(Field field: fields) {\n            \tresolveAndAssignField(obj, field, props) ;\n            }\n        }\n    }","id":42117,"modified_method":"public static void resolveAndAssignFields(Object obj, Map<String,String> props) throws Exception {\n        //traverse class hierarchy and find all annotated fields\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            Field[] fields=clazz.getDeclaredFields();\n            for(Field field: fields) {\n            \tresolveAndAssignField(obj, field, props) ;\n            }\n        }\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"static void checkDependencyReferencesPresent(List<AccessibleObject> objects, Map<String, AccessibleObject> props) {\n    \t\n    \t// iterate overall properties marked by @Property\n    \tfor(int i = 0; i < objects.size(); i++) {\n    \t\t\n    \t\t// get the Property annotation\n    \t\tAccessibleObject ao = objects.get(i) ;\n    \t\tProperty annotation = ao.getAnnotation(Property.class) ;\n            if (annotation == null) {\n            \tthrow new IllegalArgumentException(\"@Property annotation is required for checking dependencies;\" + \n            \t\t\t\" annotation is missing for Field/Method \" + ao.toString()) ;\n            }\n    \t\t\n    \t\tString dependsClause = annotation.dependsUpon() ;\n    \t\tif (dependsClause.trim().equals(\"\"))\n    \t\t\tcontinue ;\n    \t\t\n    \t\t// split dependsUpon specifier into tokens; trim each token; search for token in list\n    \t\tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \t\twhile (st.hasMoreTokens()) {\n    \t\t\tString token = st.nextToken().trim() ;\n    \t\t\t\n    \t\t\t// check that the string representing a property name is in the list\n    \t\t\tboolean found = false ;\n    \t\t\tSet<String> keyset = props.keySet();\n    \t\t\tfor (Iterator<String> iter = keyset.iterator(); iter.hasNext();) {\n    \t\t\t\tif (iter.next().equals(token)) {\n    \t\t\t\t\tfound = true ;\n    \t\t\t\t\tbreak ;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (!found) {\n    \t\t\t\tthrow new IllegalArgumentException(\"@Property annotation \" + annotation.name() + \n    \t\t\t\t\t\t\" has an unresolved dependsUpon property: \" + token) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    }","id":42118,"modified_method":"static void checkDependencyReferencesPresent(List<AccessibleObject> objects, Map<String, AccessibleObject> props) {\n    \t\n    \t// iterate overall properties marked by @Property\n    \tfor(int i = 0; i < objects.size(); i++) {\n    \t\t\n    \t\t// get the Property annotation\n    \t\tAccessibleObject ao = objects.get(i) ;\n    \t\tProperty annotation = ao.getAnnotation(Property.class) ;\n            if (annotation == null) {\n            \tthrow new IllegalArgumentException(\"@Property annotation is required for checking dependencies;\" + \n            \t\t\t\" annotation is missing for Field/Method \" + ao.toString()) ;\n            }\n    \t\t\n    \t\tString dependsClause = annotation.dependsUpon() ;\n    \t\tif (dependsClause.trim().length() == 0)\n    \t\t\tcontinue ;\n    \t\t\n    \t\t// split dependsUpon specifier into tokens; trim each token; search for token in list\n    \t\tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \t\twhile (st.hasMoreTokens()) {\n    \t\t\tString token = st.nextToken().trim() ;\n    \t\t\t\n    \t\t\t// check that the string representing a property name is in the list\n    \t\t\tboolean found = false ;\n    \t\t\tSet<String> keyset = props.keySet();\n    \t\t\tfor (Iterator<String> iter = keyset.iterator(); iter.hasNext();) {\n    \t\t\t\tif (iter.next().equals(token)) {\n    \t\t\t\t\tfound = true ;\n    \t\t\t\t\tbreak ;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (!found) {\n    \t\t\t\tthrow new IllegalArgumentException(\"@Property annotation \" + annotation.name() + \n    \t\t\t\t\t\t\" has an unresolved dependsUpon property: \" + token) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"static void parameterizedTypeSanityCheck(ParameterizedType pt) throws IllegalArgumentException {\n\n    \t\tType rawType = pt.getRawType() ;\n    \t\tType[] actualTypes = pt.getActualTypeArguments() ;\n\n    \t\tif (log.isDebugEnabled()) {\n    \t\t\tlog.debug(\"sanity check: rawtype = \" + rawType.toString()) ;\n    \t\t\tlog.debug(\"sanity check: actualtypes = \" + actualTypes.length) ;\n    \t\t}\n    \t\t\t\n    \t\t// constraints on use of parameterized types with @Property\n    \t\tif (!(rawType instanceof Class<?> && rawType.equals(List.class))) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type definition - parameterized type must be a List\") ;\n    \t\t}\n    \t\t// check for non-parameterized type in List\n    \t\tif (!(actualTypes[0] instanceof Class<?>)) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type - List must not contain a parameterized type\") ;\n    \t\t}\n    \t}","id":42119,"modified_method":"static void parameterizedTypeSanityCheck(ParameterizedType pt) throws IllegalArgumentException {\n\n    \t\tType rawType = pt.getRawType() ;\n    \t\tType[] actualTypes = pt.getActualTypeArguments() ;\n    \t\t\t\n    \t\t// constraints on use of parameterized types with @Property\n    \t\tif (!(rawType instanceof Class<?> && rawType.equals(List.class))) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type definition - parameterized type must be a List\") ;\n    \t\t}\n    \t\t// check for non-parameterized type in List\n    \t\tif (!(actualTypes[0] instanceof Class<?>)) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type - List must not contain a parameterized type\") ;\n    \t\t}\n    \t}","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"private InetAddress getInetAddress(Object obj) throws IllegalArgumentException {\n    \t\tif (obj == null)\n    \t\t\tthrow new IllegalArgumentException(\"Input argument must represent a non-null IP address\") ;\n    \t\tif (obj instanceof InetAddress) \n    \t\t\treturn (InetAddress) obj ;\n    \t\telse if (obj instanceof IpAddress) \n    \t\t\treturn ((IpAddress) obj).getIpAddress() ;\n    \t\telse if (obj instanceof InetSocketAddress)\n    \t\t\treturn ((InetSocketAddress) obj).getAddress() ;\n    \t\telse {\n    \t\t\tif (log.isDebugEnabled()) \n    \t\t\t\tlog.debug(\"Input argument does not represent one of InetAddress...: class=\" + obj.getClass().getName()) ;\n       \t\t\tthrow new IllegalArgumentException(\"Input argument does not represent one of InetAddress. IpAddress not InetSocketAddress\") ;    \t\t\t\n    \t\t}\n     \t}","id":42120,"modified_method":"private static InetAddress getInetAddress(Object obj) throws IllegalArgumentException {\n    \t\tif (obj == null)\n    \t\t\tthrow new IllegalArgumentException(\"Input argument must represent a non-null IP address\") ;\n    \t\tif (obj instanceof InetAddress) \n    \t\t\treturn (InetAddress) obj ;\n    \t\telse if (obj instanceof IpAddress) \n    \t\t\treturn ((IpAddress) obj).getIpAddress() ;\n    \t\telse if (obj instanceof InetSocketAddress)\n    \t\t\treturn ((InetSocketAddress) obj).getAddress() ;\n    \t\telse {\n    \t\t\tif (log.isWarnEnabled())\n    \t\t\t\tlog.warn(\"Input argument does not represent one of InetAddress...: class=\" + obj.getClass().getName()) ;\n       \t\t\tthrow new IllegalArgumentException(\"Input argument does not represent one of InetAddress. IpAddress not InetSocketAddress\") ;    \t\t\t\n    \t\t}\n     \t}","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private Vector<Protocol> createProtocols(Vector<ProtocolConfiguration> protocol_configs, final ProtocolStack stack) throws Exception {\n        Vector<Protocol> retval=new Vector<Protocol>();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n        String singleton_name;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=protocol_configs.elementAt(i);\n            singleton_name=protocol_config.getProperties().getProperty(Global.SINGLETON_NAME);\n            if(singleton_name != null && singleton_name.trim().length() > 0) {\n               Map<String,Tuple<TP, ProtocolStack.RefCounter>> singleton_transports=ProtocolStack.getSingletonTransports();\n                synchronized(singleton_transports) {\n                    if(i > 0) { // crude way to check whether protocol is a transport\n                        throw new IllegalArgumentException(\"Property 'singleton_name' can only be used in a transport\" +\n                                \" protocol (was used in \" + protocol_config.getProtocolName() + \")\");\n                    }\n                    Tuple<TP, ProtocolStack.RefCounter> val=singleton_transports.get(singleton_name);\n                    layer=val != null? val.getVal1() : null;\n                    if(layer != null) {\n                        retval.add(layer);\n                    }\n                    else {\n                        layer=protocol_config.createLayer(stack);\n                        if(layer == null)\n                            return null;\n                        singleton_transports.put(singleton_name, new Tuple<TP, ProtocolStack.RefCounter>((TP)layer,new ProtocolStack.RefCounter((short)0,(short)0)));\n                        retval.addElement(layer);\n                    }\n                }\n                continue;\n            }\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        return retval;\n    }","id":42121,"modified_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private static Vector<Protocol> createProtocols(Vector<ProtocolConfiguration> protocol_configs, final ProtocolStack stack) throws Exception {\n        Vector<Protocol> retval=new Vector<Protocol>();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n        String singleton_name;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=protocol_configs.elementAt(i);\n            singleton_name=protocol_config.getProperties().get(Global.SINGLETON_NAME);\n            if(singleton_name != null && singleton_name.trim().length() > 0) {\n               Map<String,Tuple<TP, ProtocolStack.RefCounter>> singleton_transports=ProtocolStack.getSingletonTransports();\n                synchronized(singleton_transports) {\n                    if(i > 0) { // crude way to check whether protocol is a transport\n                        throw new IllegalArgumentException(\"Property 'singleton_name' can only be used in a transport\" +\n                                \" protocol (was used in \" + protocol_config.getProtocolName() + \")\");\n                    }\n                    Tuple<TP, ProtocolStack.RefCounter> val=singleton_transports.get(singleton_name);\n                    layer=val != null? val.getVal1() : null;\n                    if(layer != null) {\n                        retval.add(layer);\n                    }\n                    else {\n                        layer=protocol_config.createLayer(stack);\n                        if(layer == null)\n                            return null;\n                        singleton_transports.put(singleton_name, new Tuple<TP, ProtocolStack.RefCounter>((TP)layer,new ProtocolStack.RefCounter((short)0,(short)0)));\n                        retval.addElement(layer);\n                    }\n                }\n                continue;\n            }\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        return retval;\n    }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            StringBuilder retval=new StringBuilder();\n            retval.append(\"Protocol: \");\n            if(protocol_name == null)\n                retval.append(\"<unknown>\");\n            else\n                retval.append(protocol_name);\n            if(properties != null)\n                retval.append(\"(\" + properties + ')');\n            return retval.toString();\n        }","id":42122,"modified_method":"public String toString() {\n            StringBuilder retval=new StringBuilder();\n            if(protocol_name == null)\n                retval.append(\"<unknown>\");\n            else\n                retval.append(protocol_name);\n            if(properties != null)\n                retval.append(\"(\" + Util.print(properties) + ')');\n            return retval.toString();\n        }","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public List<InetAddress> getInetAddresses() {\n    \t\tList<InetAddress> addresses = new ArrayList<InetAddress>() ;\n    \t\tif (getConvertedValue() == null)\n    \t\t\treturn addresses ;\n    \t\t// if we take only an InetAddress argument\n    \t\tif (!isParameterized()) {\n    \t\t\taddresses.add(getInetAddress(getConvertedValue())) ;\n    \t\t\treturn addresses ;\n    \t\t}\n    \t\t// if we take a List<InetAddress> or similar\n    \t\telse {\n    \t\t\tList<?> values = (List<?>) getConvertedValue() ;\n    \t\t\tif (values.size() == 0)\n    \t\t\t\treturn addresses ;\n    \t\t\tfor (int i = 0; i < values.size(); i++) {\n    \t\t\t\taddresses.add(getInetAddress(values.get(i))) ;\n    \t\t\t}\n    \t\t\treturn addresses ;\n    \t\t}\n    \t}","id":42123,"modified_method":"public List<InetAddress> getInetAddresses() {\n    \t\tList<InetAddress> addresses = new ArrayList<InetAddress>() ;\n    \t\tif (getConvertedValue() == null)\n    \t\t\treturn addresses ;\n    \t\t// if we take only an InetAddress argument\n    \t\tif (!isParameterized()) {\n    \t\t\taddresses.add(getInetAddress(getConvertedValue())) ;\n    \t\t\treturn addresses ;\n    \t\t}\n    \t\t// if we take a List<InetAddress> or similar\n    \t\telse {\n    \t\t\tList<?> values = (List<?>) getConvertedValue() ;\n    \t\t\tif (values.isEmpty())\n    \t\t\t\treturn addresses ;\n    \t\t\tfor (int i = 0; i < values.size(); i++) {\n    \t\t\t\taddresses.add(getInetAddress(values.get(i))) ;\n    \t\t\t}\n    \t\t\treturn addresses ;\n    \t\t}\n    \t}","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"static boolean isInetAddressRelated(Field f) {\n    \t\tif (hasParameterizedType(f)) {\n    \t\t\t// check for List<InetAddress>, List<InetSocketAddress>, List<IpAddress>\n    \t\t\tParameterizedType fieldtype = (ParameterizedType) f.getGenericType() ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(fieldtype) ;\t\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\tif(log.isDebugEnabled()) {\n    \t\t\t\t\tlog.debug(\"Field \" + f.getName() + \" failed paramaterizedTypeSanityCheck()\") ;\n    \t\t\t\t}\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not \n    \t\t\t\t// an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) fieldtype.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;\n    \t\t}\t\t\n    \t\telse {\n    \t\t\t// check if the non-parameterized type is InetAddress, InetSocketAddress or IpAddress\n    \t\t\tClass<?> fieldtype = f.getType() ;\n    \t\t\treturn isInetAddressOrCompatibleType(fieldtype) ;\n    \t\t}\n    \t}","id":42124,"modified_method":"static boolean isInetAddressRelated(Protocol prot, Field f) {\n    \t\tif (hasParameterizedType(f)) {\n    \t\t\t// check for List<InetAddress>, List<InetSocketAddress>, List<IpAddress>\n    \t\t\tParameterizedType fieldtype = (ParameterizedType) f.getGenericType() ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(fieldtype) ;\t\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) fieldtype.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;\n    \t\t}\t\t\n    \t\telse {\n    \t\t\t// check if the non-parameterized type is InetAddress, InetSocketAddress or IpAddress\n    \t\t\tClass<?> fieldtype = f.getType() ;\n    \t\t\treturn isInetAddressOrCompatibleType(fieldtype) ;\n    \t\t}\n    \t}","commit_id":"c0607abe1052878c5f0d7c5a1e6029eaf848a363","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean isGroupContainsInPath(ActionGroup group){\n    for (Iterator<String> iterator = myGroupPath.iterator(); iterator.hasNext();) {\n      String s = iterator.next();\n      if (s.equals(group.getTemplatePresentation().getText())){\n        return true;\n      }\n    }\n    return false;\n  }","id":42125,"modified_method":"public boolean isGroupContainsInPath(ActionGroup group){\n    for (String s : myGroupPath) {\n      if (s.equals(group.getTemplatePresentation().getText())) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"604d395251aec0f682cb05a6bbf628dd7032cd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void movePathInActionsTree(JTree tree, ActionUrl url){\n    final TreePath treePath = CustomizationUtil.getTreePath(tree, url);\n    if (treePath != null){\n      if (treePath.getLastPathComponent() != null){\n        final DefaultMutableTreeNode parent = ((DefaultMutableTreeNode)treePath.getLastPathComponent());\n        if (parent.getChildCount() > url.getInitialPosition()) {\n          final DefaultMutableTreeNode child = (DefaultMutableTreeNode)parent.getChildAt(url.getInitialPosition());\n          if (child.getUserObject().equals(url.getComponent())){\n            parent.remove(child);\n            parent.insert(child, url.getAbsolutePosition());\n          }\n        }\n      }\n    }\n  }","id":42126,"modified_method":"private static void movePathInActionsTree(JTree tree, ActionUrl url){\n    final TreePath treePath = CustomizationUtil.getTreePath(tree, url);\n    if (treePath != null){\n      if (treePath.getLastPathComponent() != null){\n        final DefaultMutableTreeNode parent = ((DefaultMutableTreeNode)treePath.getLastPathComponent());\n        final int absolutePosition = url.getAbsolutePosition();\n        final int initialPosition = url.getInitialPosition();\n        if (parent.getChildCount() > absolutePosition && absolutePosition >= 0) {\n          if (parent.getChildCount() > initialPosition && initialPosition >= 0) {\n            final DefaultMutableTreeNode child = (DefaultMutableTreeNode)parent.getChildAt(initialPosition);\n            if (child.getUserObject().equals(url.getComponent())){\n              parent.remove(child);\n              parent.insert(child, absolutePosition);\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"604d395251aec0f682cb05a6bbf628dd7032cd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(Element element) throws WriteExternalException {\n    for (Iterator<String> iterator = myGroupPath.iterator(); iterator.hasNext();) {\n      String s = iterator.next();\n      Element path = new Element(PATH);\n      path.setAttribute(VALUE, s);\n      element.addContent(path);\n    }\n    if (myComponent instanceof String) {\n      element.setAttribute(VALUE, (String)myComponent);\n      element.setAttribute(IS_ACTION, Boolean.TRUE.toString());\n    }\n    else if (myComponent instanceof Separator) {\n      element.setAttribute(SEPARATOR, Boolean.TRUE.toString());\n    }\n    else if (myComponent instanceof Group) {\n      final String groupId = ((Group)myComponent).getId() != null && !((Group)myComponent).getId().equals(\"\") ? ((Group)myComponent).getId() : ((Group)myComponent).getName();\n      element.setAttribute(VALUE, groupId != null ? groupId : \"\");\n      element.setAttribute(IS_GROUP, Boolean.TRUE.toString());\n    }\n    element.setAttribute(ACTION_TYPE, Integer.toString(myActionType));\n    element.setAttribute(POSITION, Integer.toString(myAbsolutePosition));\n    DefaultJDOMExternalizer.writeExternal(this, element);\n  }","id":42127,"modified_method":"public void writeExternal(Element element) throws WriteExternalException {\n    for (String s : myGroupPath) {\n      Element path = new Element(PATH);\n      path.setAttribute(VALUE, s);\n      element.addContent(path);\n    }\n    if (myComponent instanceof String) {\n      element.setAttribute(VALUE, (String)myComponent);\n      element.setAttribute(IS_ACTION, Boolean.TRUE.toString());\n    }\n    else if (myComponent instanceof Separator) {\n      element.setAttribute(SEPARATOR, Boolean.TRUE.toString());\n    }\n    else if (myComponent instanceof Group) {\n      final String groupId = ((Group)myComponent).getId() != null && ((Group)myComponent).getId().length() != 0\n                             ? ((Group)myComponent).getId()\n                             : ((Group)myComponent).getName();\n      element.setAttribute(VALUE, groupId != null ? groupId : \"\");\n      element.setAttribute(IS_GROUP, Boolean.TRUE.toString());\n    }\n    element.setAttribute(ACTION_TYPE, Integer.toString(myActionType));\n    element.setAttribute(POSITION, Integer.toString(myAbsolutePosition));\n    DefaultJDOMExternalizer.writeExternal(this, element);\n  }","commit_id":"604d395251aec0f682cb05a6bbf628dd7032cd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    myGroupPath = new ArrayList<String>();\n    for (Iterator<Element> iterator = element.getChildren(PATH).iterator(); iterator.hasNext();) {\n      Element o = iterator.next();\n      myGroupPath.add(o.getAttributeValue(VALUE));\n    }\n    final String attributeValue = element.getAttributeValue(VALUE);\n    if (element.getAttributeValue(IS_ACTION) != null) {\n      myComponent = attributeValue;\n    }\n    else if (element.getAttributeValue(SEPARATOR) != null) {\n      myComponent = Separator.getInstance();\n    }\n    else if (element.getAttributeValue(IS_GROUP) != null) {\n      final AnAction action = ActionManager.getInstance().getAction(attributeValue);\n      myComponent = action instanceof ActionGroup\n                    ? ActionsTreeUtil.createGroup((ActionGroup)action, true, null)\n                    : new Group(attributeValue, attributeValue, null, null);\n    }\n    myActionType = Integer.parseInt(element.getAttributeValue(ACTION_TYPE));\n    myAbsolutePosition = Integer.parseInt(element.getAttributeValue(POSITION));\n    DefaultJDOMExternalizer.readExternal(this, element);\n  }","id":42128,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    myGroupPath = new ArrayList<String>();\n    for (Object o : element.getChildren(PATH)) {\n      myGroupPath.add(((Element)o).getAttributeValue(VALUE));\n    }\n    final String attributeValue = element.getAttributeValue(VALUE);\n    if (element.getAttributeValue(IS_ACTION) != null) {\n      myComponent = attributeValue;\n    }\n    else if (element.getAttributeValue(SEPARATOR) != null) {\n      myComponent = Separator.getInstance();\n    }\n    else if (element.getAttributeValue(IS_GROUP) != null) {\n      final AnAction action = ActionManager.getInstance().getAction(attributeValue);\n      myComponent = action instanceof ActionGroup\n                    ? ActionsTreeUtil.createGroup((ActionGroup)action, true, null)\n                    : new Group(attributeValue, attributeValue, null, null);\n    }\n    myActionType = Integer.parseInt(element.getAttributeValue(ACTION_TYPE));\n    myAbsolutePosition = Integer.parseInt(element.getAttributeValue(POSITION));\n    DefaultJDOMExternalizer.readExternal(this, element);\n  }","commit_id":"604d395251aec0f682cb05a6bbf628dd7032cd5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Reads a single statement from the command line.  Also identifies\n     * and processes command shell commands.  Returns the command text\n     * on success, or null when command processing is complete.\n     * <p/>\n     * NOTE: Changed, for now, to read until 'execute' is issued.  At\n     * 'execute', the statement must be complete.\n     */\n\n    protected String read() {\n        reset();\n        out.println(\"\");\n\n        boolean complete = false;\n        boolean done = false;\n\n        while (/* !complete && */ !done) {\n\n            // Read a line.  If IOException or null, or command \"exit\", terminate\n            // processing.\n\n            try {\n                pending = prompt.readLine();\n            }\n            catch (IOException e) {\n            }\n\n            if (pending == null || (COMMAND_MAPPINGS.containsKey(pending) && ((Integer) COMMAND_MAPPINGS.get(pending)).intValue() == COMMAND_ID_EXIT)) {\n                return null;                                  // <<<< FLOW CONTROL <<<<<<<<\n            }\n\n            // First up, try to process the line as a command and proceed accordingly.\n            if (COMMAND_MAPPINGS.containsKey(pending)) {\n                int code = ((Integer) COMMAND_MAPPINGS.get(pending)).intValue();\n                switch (code) {\n                    case COMMAND_ID_HELP:\n                        displayHelp();\n                        break;\n\n                    case COMMAND_ID_DISCARD:\n                        reset();\n                        done = true;\n                        break;\n\n                    case COMMAND_ID_DISPLAY:\n                        displayStatement();\n                        break;\n\n                    case COMMAND_ID_EXPLAIN:\n                        explainStatement();\n                        break;\n\n                    case COMMAND_ID_BINDING:\n                        displayBinding();\n                        break;\n\n                    case COMMAND_ID_EXECUTE:\n                        if (complete) {\n                            done = true;\n                        }\n                        else {\n                            err.println(\"statement not complete\");\n                        }\n                        break;\n                    case COMMAND_ID_DISCARD_LOADED_CLASSES:\n                        resetLoadedClasses();\n                        break;\n                    case COMMAND_ID_INSPECT:\n                        inspect();\n                        break;\n                }\n\n                continue;                                     // <<<< LOOP CONTROL <<<<<<<<\n            }\n\n            // Otherwise, it's part of a statement.  If it's just whitespace,\n            // we'll just accept it and move on.  Otherwise, parsing is attempted\n            // on the cumulated statement text, and errors are reported.  The\n            // pending input is accepted or rejected based on that parsing.\n\n            freshen();\n\n            if (pending.trim().equals(\"\")) {\n                accept();\n                continue;                                     // <<<< LOOP CONTROL <<<<<<<<\n            }\n\n            final String code = current();\n\n            if (parse(code, 1)) {\n                accept();\n                complete = true;\n            }\n            else if (error == null) {\n                accept();\n            }\n            else {\n                report();\n            }\n\n        }\n\n        // Get and return the statement.\n        return accepted(complete);\n    }","id":42129,"modified_method":"/**\n     * Reads a single statement from the command line.  Also identifies\n     * and processes command shell commands.  Returns the command text\n     * on success, or null when command processing is complete.\n     * <p/>\n     * NOTE: Changed, for now, to read until 'execute' is issued.  At\n     * 'execute', the statement must be complete.\n     */\n\n    protected String read() {\n        reset();\n        out.println(\"\");\n\n        boolean complete = false;\n        boolean done = false;\n\n        while (/* !complete && */ !done) {\n\n            // Read a line.  If IOException or null, or command \"exit\", terminate\n            // processing.\n\n            try {\n                pending = prompt.readLine();\n            }\n            catch (IOException e) {\n            }\n\n            if (pending == null || (COMMAND_MAPPINGS.containsKey(pending) && ((Integer) COMMAND_MAPPINGS.get(pending)).intValue() == COMMAND_ID_EXIT)) {\n                return null;                                  // <<<< FLOW CONTROL <<<<<<<<\n            }\n\n            // First up, try to process the line as a command and proceed accordingly.\n            if (COMMAND_MAPPINGS.containsKey(pending)) {\n                int code = ((Integer) COMMAND_MAPPINGS.get(pending)).intValue();\n                switch (code) {\n                    case COMMAND_ID_HELP:\n                        displayHelp();\n                        break;\n\n                    case COMMAND_ID_DISCARD:\n                        reset();\n                        done = true;\n                        break;\n\n                    case COMMAND_ID_DISPLAY:\n                        displayStatement();\n                        break;\n\n                    case COMMAND_ID_EXPLAIN:\n                        explainStatement();\n                        break;\n\n                    case COMMAND_ID_BINDING:\n                        displayBinding();\n                        break;\n\n                    case COMMAND_ID_EXECUTE:\n                        if (complete) {\n                            done = true;\n                        }\n                        else {\n                            err.println(\"statement not complete\");\n                        }\n                        break;\n                    case COMMAND_ID_DISCARD_LOADED_CLASSES:\n                        resetLoadedClasses();\n                        break;\n                    case COMMAND_ID_INSPECT:\n                        inspect();\n                        break;\n                }\n\n                continue;                                     // <<<< LOOP CONTROL <<<<<<<<\n            }\n\n            // Otherwise, it's part of a statement.  If it's just whitespace,\n            // we'll just accept it and move on.  Otherwise, parsing is attempted\n            // on the cumulated statement text, and errors are reported.  The\n            // pending input is accepted or rejected based on that parsing.\n\n            freshen();\n\n            if (pending.trim().length() == 0) {\n                accept();\n                continue;                                     // <<<< LOOP CONTROL <<<<<<<<\n            }\n\n            final String code = current();\n\n            if (parse(code, 1)) {\n                accept();\n                complete = true;\n            }\n            else if (error == null) {\n                accept();\n            }\n            else {\n                report();\n            }\n\n        }\n\n        // Get and return the statement.\n        return accepted(complete);\n    }","commit_id":"37214a748e7e6987f4f54707f043b358c494fb1b","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Reads commands and statements from input stream and processes them.\n     */\n    public void run(String[] args) throws Exception {\n        final String version = InvokerHelper.getVersion();\n\n        out.println(\"Lets get Groovy!\");\n        out.println(\"================\");\n        out.println(\"Version: \" + version + \" JVM: \" + System.getProperty(\"java.vm.version\"));\n        out.println(\"Type 'exit' to terminate the shell\");\n        out.println(\"Type 'help' for command help\");\n        out.println(\"Type 'go' to execute the statements\");\n\n        boolean running = true;\n        while (running) {\n            // Read a single top-level statement from the command line,\n            // trapping errors as they happen.  We quit on null.\n            final String command = read();\n            if (command == null) {\n                close();\n                break;\n            }\n\n            reset();\n\n            if (command.length() > 0) {\n                // We have a command that parses, so evaluate it.\n                try {\n                    lastResult = shell.evaluate(command, \"CommandLine.groovy\");\n                } catch (CompilationFailedException e) {\n                    err.println(e);\n                } catch (Throwable e) {\n                    if (e instanceof InvokerInvocationException) {\n                        InvokerInvocationException iie = (InvokerInvocationException) e;\n                        e = iie.getCause();\n                    }\n                    err.println(\"Caught: \" + e);\n                    StackTraceElement[] stackTrace = e.getStackTrace();\n                    for (int i = 0; i < stackTrace.length; i++) {\n                        StackTraceElement element = stackTrace[i];\n                        String fileName = element.getFileName();\n                        if (fileName==null || (!fileName.endsWith(\".java\"))) {\n                            err.println(\"\\tat \" + element);\n                        }\n                    }\n                }\n            }\n        }\n    }","id":42130,"modified_method":"/**\n     * Reads commands and statements from input stream and processes them.\n     */\n    public void run(String[] args) throws Exception {\n        final String version = InvokerHelper.getVersion();\n\n        out.println(\"Lets get Groovy!\");\n        out.println(\"================\");\n        out.println(\"Version: \" + version + \" JVM: \" + System.getProperty(\"java.vm.version\"));\n        out.println(\"Type 'exit' to terminate the shell\");\n        out.println(\"Type 'help' for command help\");\n        out.println(\"Type 'go' to execute the statements\");\n\n        boolean running = true;\n        while (running) {\n            // Read a single top-level statement from the command line,\n            // trapping errors as they happen.  We quit on null.\n            final String command = read();\n            if (command == null) {\n                close();\n                break;\n            }\n\n            reset();\n\n            if (command.length() > 0) {\n                // We have a command that parses, so evaluate it.\n                try {\n                    lastResult = shell.evaluate(command, \"CommandLine.groovy\");\n                    out.println(\"\\n===> \" + lastResult);\n                } catch (CompilationFailedException e) {\n                    err.println(e);\n                } catch (Throwable e) {\n                    if (e instanceof InvokerInvocationException) {\n                        InvokerInvocationException iie = (InvokerInvocationException) e;\n                        e = iie.getCause();\n                    }\n                    filterAndPrintStackTrace(e);\n                }\n            }\n        }\n    }","commit_id":"37214a748e7e6987f4f54707f043b358c494fb1b","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Handles the <tt>DocumentEvent<\/tt> triggered when user types in the UIN\n     * field. Enables or disables the \"Next\" wizard button according to whether\n     * the UIN field is empty.\n     * @param e the <tt>DocumentEvent<\/tt> that notified us\n     */\n    public void insertUpdate(DocumentEvent e)\n    {\n        regform.setNextFinishButtonEnabled(userIDField.getText() == null\n                                            || userIDField.getText().equals(\"\"));\n        regform.setServerFieldAccordingToUIN(userIDField.getText());\n    }","id":42131,"modified_method":"/**\n     * Handles the <tt>DocumentEvent<\/tt> triggered when user types in the UIN\n     * field. Enables or disables the \"Next\" wizard button according to whether\n     * the UIN field is empty.\n     * @param e the <tt>DocumentEvent<\/tt> that notified us\n     */\n    public void insertUpdate(DocumentEvent e)\n    {\n        regform.setNextFinishButtonEnabled(\n                userIDField.getText() != null\n                && userIDField.getText().length() > 0);\n        regform.setServerFieldAccordingToUIN(userIDField.getText());\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the advanced account panel.\n     */\n    void initAdvancedForm()\n    {\n        // If it's not yet added.\n        if (displayNameLabel.getParent() == null)\n            labelsPanel.add(displayNameLabel);\n\n        // If it's not yet added.\n        if (displayNameField.getParent() == null)\n            valuesPanel.add(displayNameField);\n    }","id":42132,"modified_method":"/**\n     * Initializes the advanced account panel.\n     */\n    void initAdvancedForm()\n    {\n        // If it's not yet added.\n        if (displayNameLabel.getParent() == null)\n            labelsPanel.add(displayNameLabel);\n\n        // If it's not yet added.\n        if (displayNameField.getParent() == null)\n            valuesPanel.add(displayNameField);\n\n        // Select the existing account radio button by default.\n        existingAccountButton.setSelected(true);\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>DocumentEvent<\/tt> triggered when user deletes letters\n     * from the UIN field. Enables or disables the \"Next\" wizard button\n     * according to whether the UIN field is empty.\n     * @param e the <tt>DocumentEvent<\/tt> that notified us\n     */\n    public void removeUpdate(DocumentEvent e)\n    {\n        regform.setNextFinishButtonEnabled(userIDField.getText() == null\n                                            || userIDField.getText().equals(\"\"));\n        regform.setServerFieldAccordingToUIN(userIDField.getText());\n    }","id":42133,"modified_method":"/**\n     * Handles the <tt>DocumentEvent<\/tt> triggered when user deletes letters\n     * from the UIN field. Enables or disables the \"Next\" wizard button\n     * according to whether the UIN field is empty.\n     * @param e the <tt>DocumentEvent<\/tt> that notified us\n     */\n    public void removeUpdate(DocumentEvent e)\n    {\n        regform.setNextFinishButtonEnabled(\n            userIDField.getText() != null\n            && userIDField.getText().length() > 0);\n        regform.setServerFieldAccordingToUIN(userIDField.getText());\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of the <tt>AccountPanel<\/tt>.\n     * @param regform the parent registration form\n     */\n    public AccountPanel(SIPAccountRegistrationForm regform)\n    {\n        super (new BorderLayout());\n\n        this.regform = regform;\n\n        this.userIDField.getDocument().addDocumentListener(this);\n\n        this.rememberPassBox.setSelected(true);\n\n        JLabel uinExampleLabel = new JLabel(regform.getUsernameExample());\n        uinExampleLabel.setForeground(Color.GRAY);\n        uinExampleLabel.setFont(uinExampleLabel.getFont().deriveFont(8));\n        emptyPanel.setMaximumSize(new Dimension(40, 35));\n        uinExampleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 8, 0));\n\n        JPanel uinPassPanel\n            = new TransparentPanel(new BorderLayout(10, 10));\n\n        JLabel uinLabel\n            = new JLabel(Resources.getString(\"plugin.sipaccregwizz.USERNAME\"));\n\n        JLabel passLabel\n            = new JLabel(Resources.getString(\"service.gui.PASSWORD\"));\n\n        labelsPanel.add(uinLabel);\n        labelsPanel.add(emptyPanel);\n        labelsPanel.add(passLabel);\n\n        valuesPanel.add(userIDField);\n        valuesPanel.add(uinExampleLabel);\n        valuesPanel.add(passField);\n\n        TransparentPanel southPanel\n            = new TransparentPanel(new GridLayout(1, 2));\n\n        uinPassPanel.add(labelsPanel, BorderLayout.WEST);\n        uinPassPanel.add(valuesPanel, BorderLayout.CENTER);\n        uinPassPanel.add(southPanel, BorderLayout.SOUTH);\n\n        southPanel.add(rememberPassBox);\n\n        String webSignup = regform.getWebSignupLinkName();\n        if (webSignup != null)\n        {\n            southPanel.add(createSubscribeLabel(webSignup));\n        }\n\n        uinPassPanel.setBorder(BorderFactory.createTitledBorder(Resources\n            .getString(\"plugin.sipaccregwizz.USERNAME_AND_PASSWORD\")));\n\n        this.add(uinPassPanel, BorderLayout.NORTH);\n    }","id":42134,"modified_method":"/**\n     * Creates an instance of the <tt>AccountPanel<\/tt>.\n     * @param regform the parent registration form\n     */\n    public AccountPanel(SIPAccountRegistrationForm regform)\n    {\n        super(new BorderLayout());\n\n        this.regform = regform;\n\n        this.userIDField.getDocument().addDocumentListener(this);\n\n        this.rememberPassBox.setSelected(true);\n\n        JLabel uinExampleLabel = new JLabel(regform.getUsernameExample());\n        uinExampleLabel.setForeground(Color.GRAY);\n        uinExampleLabel.setFont(uinExampleLabel.getFont().deriveFont(8));\n        emptyPanel.setMaximumSize(new Dimension(40, 35));\n        uinExampleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 8, 0));\n\n        JLabel uinLabel\n            = new JLabel(Resources.getString(\"plugin.sipaccregwizz.USERNAME\"));\n\n        JLabel passLabel\n            = new JLabel(Resources.getString(\"service.gui.PASSWORD\"));\n\n        labelsPanel.add(uinLabel);\n        labelsPanel.add(emptyPanel);\n        labelsPanel.add(passLabel);\n\n        valuesPanel.add(userIDField);\n        valuesPanel.add(uinExampleLabel);\n        valuesPanel.add(passField);\n\n        TransparentPanel southPanel\n            = new TransparentPanel(new GridLayout(1, 2));\n\n        uinPassPanel.add(labelsPanel, BorderLayout.WEST);\n        uinPassPanel.add(valuesPanel, BorderLayout.CENTER);\n        uinPassPanel.add(southPanel, BorderLayout.SOUTH);\n\n        southPanel.add(rememberPassBox);\n\n        String webSignup = regform.getWebSignupLinkName();\n        if (webSignup != null)\n        {\n            southPanel.add(createSubscribeLabel(webSignup));\n        }\n\n        uinPassPanel.setBorder(BorderFactory.createTitledBorder(Resources\n            .getString(\"plugin.sipaccregwizz.USERNAME_AND_PASSWORD\")));\n\n        CreateAccountService createAccountService\n            = regform.getCreateAccountService();\n\n        if (createAccountService != null)\n        {\n            registrationForm = createAccountService.getForm();\n            mainPanel.add(createRegisterChoicePanel(), BorderLayout.NORTH);\n        }\n        else\n            mainPanel.add(uinPassPanel, BorderLayout.NORTH);\n\n        this.add(mainPanel, BorderLayout.NORTH);\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates the dialog and initializes the UI.\n     */\n    public NewAccountDialog()\n    {\n        super(GuiActivator.getUIService().getMainFrame());\n\n        this.setTitle(GuiActivator.getResources()\n            .getI18NString(\"service.gui.NEW_ACCOUNT\"));\n\n        this.getContentPane().add(mainPanel);\n\n        this.mainPanel.setBorder(\n            BorderFactory.createEmptyBorder(15, 15, 15, 15));\n\n        this.networkPanel.setBorder(\n            BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n        this.mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n        this.buttonPanel.add(advancedButton, BorderLayout.WEST);\n        this.buttonPanel.add(rightButtonPanel, BorderLayout.EAST);\n        this.advancedButton.addActionListener(this);\n\n        this.rightButtonPanel.add(addAccountButton);\n        this.rightButtonPanel.add(cancelButton);\n        this.addAccountButton.addActionListener(this);\n        this.cancelButton.addActionListener(this);\n\n        this.mainPanel.add(networkPanel, BorderLayout.NORTH);\n        this.networkPanel.add(networkLabel, BorderLayout.WEST);\n        this.networkPanel.add(networkComboBox, BorderLayout.CENTER);\n\n        this.getRootPane().setDefaultButton(addAccountButton);\n\n        this.networkComboBox.setRenderer(new NetworkListCellRenderer());\n        this.networkComboBox.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                AccountRegistrationWizard wizard\n                    = (AccountRegistrationWizard) networkComboBox\n                        .getSelectedItem();\n\n                loadSelectedWizard(wizard);\n            }\n        });\n\n        this.mainPanel.add(accountPanel, BorderLayout.CENTER);\n\n        this.initNetworkList();\n    }","id":42135,"modified_method":"/**\n     * Creates the dialog and initializes the UI.\n     */\n    public NewAccountDialog()\n    {\n        super(GuiActivator.getUIService().getMainFrame(), false);\n\n        this.setTitle(GuiActivator.getResources()\n            .getI18NString(\"service.gui.NEW_ACCOUNT\"));\n\n        this.getContentPane().add(mainPanel);\n\n        this.mainPanel.setBorder(\n            BorderFactory.createEmptyBorder(15, 15, 15, 15));\n\n        this.networkPanel.setBorder(\n            BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n        this.mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n        this.buttonPanel.add(advancedButton, BorderLayout.WEST);\n        this.buttonPanel.add(rightButtonPanel, BorderLayout.EAST);\n        this.advancedButton.addActionListener(this);\n\n        this.rightButtonPanel.add(addAccountButton);\n        this.rightButtonPanel.add(cancelButton);\n        this.addAccountButton.addActionListener(this);\n        this.cancelButton.addActionListener(this);\n\n        this.mainPanel.add(networkPanel, BorderLayout.NORTH);\n        this.networkPanel.add(networkLabel, BorderLayout.WEST);\n        this.networkPanel.add(networkComboBox, BorderLayout.CENTER);\n\n        this.getRootPane().setDefaultButton(addAccountButton);\n\n        this.networkComboBox.setRenderer(new NetworkListCellRenderer());\n        this.networkComboBox.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                AccountRegistrationWizard wizard\n                    = (AccountRegistrationWizard) networkComboBox\n                        .getSelectedItem();\n\n                loadSelectedWizard(wizard);\n            }\n        });\n\n        this.mainPanel.add(accountPanel, BorderLayout.CENTER);\n\n        this.initNetworkList();\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Saves the user input when the \"Next\" wizard buttons is clicked.\n     * @param registration the SIPAccountRegistration\n     */\n    public void commitPage(SIPAccountRegistration registration)\n    {\n        String userID = accountPanel.getUserID();\n\n        if(userID == null || userID.trim().length() == 0)\n            throw new IllegalStateException(\"No user ID provided.\");\n\n        registration.setUserID(userID);\n\n        char[] password = accountPanel.getPassword();\n        if (password != null)\n            registration.setPassword(new String(password));\n\n        registration.setRememberPassword(accountPanel.isRememberPassword());\n\n        registration.setServerAddress(connectionPanel.getServerAddress());\n\n        String displayName = accountPanel.getDisplayName();\n        registration.setDisplayName(displayName);\n\n        String authName = connectionPanel.getAuthenticationName();\n        if(authName != null && authName.length() > 0)\n            registration.setAuthorizationName(authName);\n\n        registration.setServerPort(connectionPanel.getServerPort());\n        registration.setProxy(connectionPanel.getProxy());\n        registration.setProxyPort(connectionPanel.getProxyPort());\n\n        registration.setPreferredTransport(\n            connectionPanel.getSelectedTransport());\n\n        registration.setEnablePresence(\n            presencePanel.isPresenceEnabled());\n        registration.setForceP2PMode(\n            presencePanel.isForcePeerToPeerMode());\n        registration.setDefaultEncryption(\n            connectionPanel.isDefaultEncryptionEnabled());\n        registration.setSipZrtpAttribute(\n            connectionPanel.isSipZrtpEnabled());\n        registration.setPollingPeriod(\n            presencePanel.getPollPeriod());\n        registration.setSubscriptionExpiration(\n            presencePanel.getSubscriptionExpiration());\n        registration.setKeepAliveMethod(\n            connectionPanel.getKeepAliveMethod());\n        registration.setKeepAliveInterval(\n            connectionPanel.getKeepAliveInterval());\n\n        SIPAccRegWizzActivator.getUIService().getAccountRegWizardContainer()\n            .setBackButtonEnabled(true);\n    }","id":42136,"modified_method":"/**\n     * Saves the user input when the \"Next\" wizard buttons is clicked.\n     * @param registration the SIPAccountRegistration\n     */\n    public void commitPage(SIPAccountRegistration registration)\n    {\n        String userID = null;\n        char[] password = null;\n        String serverAddress = null;\n        String proxyAddress = null;\n        if (accountPanel.isCreateAccount())\n        {\n            NewAccount newAccount\n                = getCreateAccountService().createAccount();\n            if (newAccount != null)\n            {\n                userID = newAccount.getUserName();\n                password = newAccount.getPassword();\n                serverAddress = newAccount.getServerAddress();\n                proxyAddress = newAccount.getProxyAddress();\n\n                if (serverAddress == null)\n                    serverAddress = setServerFieldAccordingToUIN(userID);\n\n                if (proxyAddress == null)\n                    proxyAddress = serverAddress;\n            }\n            else\n            {\n                // If we didn't succeed to create our new account, we have\n                // nothing more to do here.\n                return;\n            }\n        }\n        else\n        {\n            userID = accountPanel.getUserID();\n            password = accountPanel.getPassword();\n            serverAddress = connectionPanel.getServerAddress();\n            proxyAddress = connectionPanel.getProxy();\n        }\n\n        if(userID == null || userID.trim().length() == 0)\n            throw new IllegalStateException(\"No user ID provided.\");\n\n        registration.setUserID(userID);\n\n        if (password != null)\n            registration.setPassword(new String(password));\n\n        registration.setRememberPassword(accountPanel.isRememberPassword());\n\n        registration.setServerAddress(serverAddress);\n        registration.setProxy(proxyAddress);\n\n        String displayName = accountPanel.getDisplayName();\n        registration.setDisplayName(displayName);\n\n        String authName = connectionPanel.getAuthenticationName();\n        if(authName != null && authName.length() > 0)\n            registration.setAuthorizationName(authName);\n\n        registration.setServerPort(connectionPanel.getServerPort());\n        registration.setProxyPort(connectionPanel.getProxyPort());\n\n        registration.setPreferredTransport(\n            connectionPanel.getSelectedTransport());\n\n        registration.setEnablePresence(\n            presencePanel.isPresenceEnabled());\n        registration.setForceP2PMode(\n            presencePanel.isForcePeerToPeerMode());\n        registration.setDefaultEncryption(\n            connectionPanel.isDefaultEncryptionEnabled());\n        registration.setSipZrtpAttribute(\n            connectionPanel.isSipZrtpEnabled());\n        registration.setPollingPeriod(\n            presencePanel.getPollPeriod());\n        registration.setSubscriptionExpiration(\n            presencePanel.getSubscriptionExpiration());\n        registration.setKeepAliveMethod(\n            connectionPanel.getKeepAliveMethod());\n        registration.setKeepAliveInterval(\n            connectionPanel.getKeepAliveInterval());\n\n        SIPAccRegWizzActivator.getUIService().getAccountRegWizardContainer()\n            .setBackButtonEnabled(true);\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes all panels, buttons, etc.\n     */\n    void init()\n    {\n        this.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n        accountPanel.initAdvancedForm();\n\n        if (accountPanel.getParent() != tabbedPane)\n            tabbedPane.addTab(  Resources.getString(\"service.gui.ACCOUNT\"),\n                                accountPanel);\n\n        if (connectionPanel.getParent() != tabbedPane)\n            tabbedPane.addTab(Resources.getString(\"service.gui.CONNECTION\"),\n                                connectionPanel);\n\n        if (presencePanel.getParent() != tabbedPane)\n            tabbedPane.addTab(Resources.getString(\"service.gui.PRESENCE\"),\n                                presencePanel);\n\n        if (tabbedPane.getParent() != this)\n            this.add(tabbedPane, BorderLayout.NORTH);\n\n        tabbedPane.setSelectedIndex(0);\n    }","id":42137,"modified_method":"/**\n     * Initializes all panels, buttons, etc.\n     */\n    void init()\n    {\n        this.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n        accountPanel.initAdvancedForm();\n\n        CreateAccountService createService = getCreateAccountService();\n        if (createService != null)\n            createService.clear();\n\n        if (accountPanel.getParent() != tabbedPane)\n            tabbedPane.addTab(  Resources.getString(\"service.gui.ACCOUNT\"),\n                                accountPanel);\n\n        if (connectionPanel.getParent() != tabbedPane)\n            tabbedPane.addTab(Resources.getString(\"service.gui.CONNECTION\"),\n                                connectionPanel);\n\n        if (presencePanel.getParent() != tabbedPane)\n            tabbedPane.addTab(Resources.getString(\"service.gui.PRESENCE\"),\n                                presencePanel);\n\n        if (tabbedPane.getParent() != this)\n            this.add(tabbedPane, BorderLayout.NORTH);\n\n        tabbedPane.setSelectedIndex(0);\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Parse the server part from the sip id and set it to server as default\n     * value. If Advanced option is enabled Do nothing.\n     * @param userName the account user name\n     */\n    void setServerFieldAccordingToUIN(String userName)\n    {\n        String serverAddress = getServerFromUserName(userName);\n\n        connectionPanel.setServerFieldAccordingToUIN(serverAddress);\n    }","id":42138,"modified_method":"/**\n     * Parse the server part from the sip id and set it to server as default\n     * value. If Advanced option is enabled Do nothing.\n     * @param userName the account user name\n     * @return the server address\n     */\n    String setServerFieldAccordingToUIN(String userName)\n    {\n        String serverAddress = getServerFromUserName(userName);\n\n        connectionPanel.setServerFieldAccordingToUIN(serverAddress);\n\n        return serverAddress;\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Installs the account created through this wizard.\n     * @return ProtocolProviderService\n     * @throws OperationFailedException problem signing in.\n     */\n    public ProtocolProviderService signin()\n        throws OperationFailedException\n    {\n        firstWizardPage.commitPage();\n\n        return signin(registration.getId(), registration.getPassword());\n    }","id":42139,"modified_method":"/**\n     * Installs the account created through this wizard.\n     * @return ProtocolProviderService\n     * @throws OperationFailedException problem signing in.\n     */\n    public ProtocolProviderService signin()\n        throws OperationFailedException\n    {\n        firstWizardPage.commitPage();\n\n        if (registration.getId() != null)\n            return signin(registration.getId(), registration.getPassword());\n        else\n            throw new OperationFailedException(\n                \"User name null.\", OperationFailedException.ILLEGAL_ARGUMENT);\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Starts this bundle.\r\n     * @param bc BundleContext\r\n     * @throws Exception\r\n     */\r\n    public void start(BundleContext bc)\r\n        throws Exception\r\n    {\r\n        bundleContext = bc;\r\n\r\n        uiService =\r\n            (UIService) bundleContext.getService(bundleContext\r\n                .getServiceReference(UIService.class.getName()));\r\n\r\n        Sip2SipAccountRegistrationWizard wizard\r\n            = new Sip2SipAccountRegistrationWizard(uiService\r\n                .getAccountRegWizardContainer());\r\n\r\n        Hashtable<String, String> containerFilter\r\n            = new Hashtable<String, String>();\r\n        containerFilter.put(\r\n                ProtocolProviderFactory.PROTOCOL,\r\n                Sip2SipAccountRegistrationWizard.PROTOCOL);\r\n\r\n        bundleContext.registerService(\r\n            AccountRegistrationWizard.class.getName(),\r\n            wizard,\r\n            containerFilter);\r\n    }","id":42140,"modified_method":"/**\r\n     * Starts this bundle.\r\n     * @param bc BundleContext\r\n     * @throws Exception\r\n     */\r\n    public void start(BundleContext bc)\r\n        throws Exception\r\n    {\r\n        bundleContext = bc;\r\n\r\n        System.setProperty(\r\n            \"http.agent\",\r\n            System.getProperty(\"sip-communicator.application.name\")\r\n                + \"/\" \r\n                + System.getProperty(\"sip-communicator.version\"));\r\n\r\n        uiService =\r\n            (UIService) bundleContext.getService(bundleContext\r\n                .getServiceReference(UIService.class.getName()));\r\n\r\n        Sip2SipAccountRegistrationWizard wizard\r\n            = new Sip2SipAccountRegistrationWizard(uiService\r\n                .getAccountRegWizardContainer());\r\n\r\n        Hashtable<String, String> containerFilter\r\n            = new Hashtable<String, String>();\r\n        containerFilter.put(\r\n                ProtocolProviderFactory.PROTOCOL,\r\n                Sip2SipAccountRegistrationWizard.PROTOCOL);\r\n\r\n        bundleContext.registerService(\r\n            AccountRegistrationWizard.class.getName(),\r\n            wizard,\r\n            containerFilter);\r\n    }","commit_id":"e5b562490fb9d645c6068ad12c1ee2ad2196a853","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static void resolveAndInvokePropertyMethod(Object obj, Method method, Properties props) throws Exception {\n    \tString methodName=method.getName();\n    \tif(method.isAnnotationPresent(Property.class) && isSetPropertyMethod(method)) {\n    \t\tString propertyName=PropertyHelper.getPropertyName(method) ;\n    \t\tString propertyValue=props.getProperty(propertyName);\n    \t\tif(propertyValue != null) {\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, method, props, propertyValue);\n    \t\t\t\tmethod.invoke(obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Could not assign property \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \", method is \" + methodName + \", converted value is \" + converted, e);\n    \t\t\t}\n    \t\t\tfinally {\n    \t\t\t\tprops.remove(propertyName);\n    \t\t\t}\n    \t\t}\n    \t}\n    }","id":42141,"modified_method":"public static void resolveAndInvokePropertyMethod(Object obj, Method method, Map<String,String> props) throws Exception {\n    \tString methodName=method.getName();\n    \tif(method.isAnnotationPresent(Property.class) && isSetPropertyMethod(method)) {\n    \t\tString propertyName=PropertyHelper.getPropertyName(method) ;\n    \t\tString propertyValue=props.get(propertyName);\n\n            // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n            String tmp=grabSystemProp(method.getAnnotation(Property.class));\n            if(tmp != null)\n                propertyValue=tmp;\n\n    \t\tif(propertyValue != null) {\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, method, props, propertyValue);\n    \t\t\t\tmethod.invoke(obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Could not assign property \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \", method is \" + methodName + \", converted value is \" + converted, e);\n    \t\t\t}\n    \t\t}\n\n            props.remove(propertyName);\n    \t}\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"private void parsePropertiesString(String properties_str, Properties properties) throws Exception {\n        \tint index = 0 ;\n            \n        \t/* \"in_port=5555;out_port=6666\" */\n            if(properties_str.length() > 0) {\n                String[] components=properties_str.split(\";\");\n                for(String property : components) {\n                    String name, value;\n                    index=property.indexOf('=');\n                    if(index == -1) {\n                        throw new Exception(\"Configurator.ProtocolConfiguration(): '=' not found in \" + property\n                                + \" of \"\n                                + protocol_name);\n                    }\n                    name=property.substring(0, index);\n                    value=property.substring(index + 1, property.length());\n                    properties.put(name, value);\n                }\n            }\n        }","id":42142,"modified_method":"private void parsePropertiesString(String properties_str, Map<String, String> properties) throws Exception {\n        \tint index = 0 ;\n            \n        \t/* \"in_port=5555;out_port=6666\" */\n            if(properties_str.length() > 0) {\n                String[] components=properties_str.split(\";\");\n                for(String property : components) {\n                    String name, value;\n                    index=property.indexOf('=');\n                    if(index == -1) {\n                        throw new Exception(\"Configurator.ProtocolConfiguration(): '=' not found in \" + property\n                                + \" of \" + protocol_name);\n                    }\n                    name=property.substring(0, index);\n                    value=property.substring(index + 1, property.length());\n                    properties.put(name, value);\n                }\n            }\n        }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void processDefaultValues(Vector<ProtocolConfiguration> protocol_configs, Vector<Protocol> protocols, boolean assumeIPv4) throws Exception {\n\n    \tfor (int i = 0; i < protocol_configs.size(); i++) {    \t\t\n    \t\tProtocolConfiguration protocol_config = protocol_configs.get(i) ;\n    \t\tProtocol protocol = protocols.get(i) ;\n    \t\tString protocolName = protocol.getName();\n\n    \t\t// regenerate the Properties which were destroyed during basic property processing\n    \t\tProperties properties = null ;\n    \t\tproperties = protocol_config.getOriginalProperties(); \n\n    \t\t// check which properties are null\n    \t\tMethod[] methods=protocol.getClass().getMethods();\n    \t\tfor(int j = 0; j < methods.length; j++) {\n    \t\t\tif (methods[j].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[j])) {\n    \t\t\t\tString propertyName = PropertyHelper.getPropertyName(methods[j]) ;\n    \t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n    \t\t\t\t// if propertyValue is null, check if there is a default value we can assign\n    \t\t\t\tif (propertyValue == null) {\n    \t\t\t\t\tProperty annotation = methods[j].getAnnotation(Property.class) ;\n    \t\t\t\t\t\n    \t\t\t\t\t// get the default value for the method- check for InetAddress types\n    \t\t\t\t\tString defaultValue = null ;\n    \t\t\t\t\tif (InetAddressInfo.isInetAddressRelated(methods[j])) {\n    \t\t\t\t\t\tif (assumeIPv4)\n    \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv4() ;\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv6() ;\n    \t\t\t\t\t}\n    \t\t\t\t\telse {\n    \t\t\t\t\t\tdefaultValue = annotation.defaultValue() ;\n    \t\t\t\t\t} \n    \t\t\t\t\t// got the default value\n    \t\t\t\t\tif (defaultValue != null && defaultValue.length() > 0) {\n    \t\t\t\t\t\tif (log.isDebugEnabled()) \n    \t\t\t\t\t\t\tlog.debug(\"Setting default value for property \" + propertyName) ;\n    \t\t\t\t\t\tObject converted=null;\n    \t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, defaultValue);\n    \t\t\t\t\t\t\tmethods[j].invoke(protocol, converted);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tcatch(Exception e) {\n    \t\t\t\t\t\t\tthrow new Exception(\"Deafult could not be assined for method \" + propertyName + \" in \"\n    \t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + defaultValue + \".Exception is \" +e, e);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif (log.isDebugEnabled()) {\n    \t\t\t\t\t\t\tif (converted != null)\n    \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value \" + converted.toString()) ;\n    \t\t\t\t\t\t\telse \n    \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value null\") ;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} // for methods\n\n    \t\t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \t\tfor(Class<?> clazz=protocol.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\t\tField[] fields=clazz.getDeclaredFields();\n    \t\t\tfor(int j = 0; j < fields.length; j++ ) {\n    \t\t\t\tif (fields[j].isAnnotationPresent(Property.class)) {\n    \t\t\t\t\tString propertyName = PropertyHelper.getPropertyName(fields[j], properties) ;\n    \t\t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n    \t\t\t\t\tif (propertyValue == null) {\n    \t\t\t\t\t\t// add to collection of @Properties with no user specified value\n    \t\t\t\t\t\tProperty annotation = fields[j].getAnnotation(Property.class) ;\n    \t\t\t\t\t\t\n        \t\t\t\t\t// get the default value for the field - check for InetAddress types\n        \t\t\t\t\tString defaultValue = null ;\n        \t\t\t\t\tif (InetAddressInfo.isInetAddressRelated(fields[j])) {\n        \t\t\t\t\t\tif (assumeIPv4)\n        \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv4() ;\n        \t\t\t\t\t\telse\n        \t\t\t\t\t\t\tdefaultValue = annotation.defaultValueIPv6() ;\n        \t\t\t\t\t}\n        \t\t\t\t\telse {\n        \t\t\t\t\t\tdefaultValue = annotation.defaultValue() ;\n        \t\t\t\t\t} \n        \t\t\t\t\t// got the default value    \n    \t\t\t\t\t\t\n        \t\t\t\t\t// set a default value for the field\n    \t\t\t\t\t\tif(defaultValue != null && defaultValue.length() > 0) {\n    \t\t\t\t\t\t\t// condition for invoking converter\n    \t\t\t\t\t\t\tif(defaultValue != null || !PropertyHelper.usesDefaultConverter(fields[j])) {\n    \t    \t\t\t\t\t\tif (log.isDebugEnabled()) \n    \t    \t\t\t\t\t\t\tlog.debug(\"Setting default value for property \" + propertyName) ;\n\n    \t\t\t\t\t\t\t\tObject converted=null;\n    \t\t\t\t\t\t\t\ttry {\n    \t\t\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, defaultValue);\n    \t\t\t\t\t\t\t\t\tif(converted != null)\n    \t\t\t\t\t\t\t\t\t\tsetField(fields[j], protocol, converted);\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\tcatch(Exception e) {\n    \t\t\t\t\t\t\t\t\tthrow new Exception(\"Deafult could not be assined for field \" + propertyName + \" in \"\n    \t\t\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + defaultValue + \".Exception is \" +e, e);\n    \t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\n            \t\t\t\t\t\tif (log.isDebugEnabled()) {\n            \t\t\t\t\t\t\tif (converted != null)\n            \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value \" + converted.toString()) ;\n            \t\t\t\t\t\t\telse \n            \t\t\t\t\t\t\t\tlog.debug(\"Set property \" + propertyName + \" to default value null\") ;\n            \t\t\t\t\t\t}\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t} // for fields\n    \t}\n    }","id":42143,"modified_method":"public static void processDefaultValues(Vector<ProtocolConfiguration> protocol_configs, Vector<Protocol> protocols, int ip_version) throws Exception {\n        InetAddress default_ip_address=Util.getFirstNonLoopbackAddress(ip_version);\n        if(default_ip_address == null) {\n            log.warn(\"unable to find an address other than loopback for IP version \" + ip_version);\n            default_ip_address=Util.getLocalhost(ip_version);\n        }\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            ProtocolConfiguration protocol_config=protocol_configs.get(i);\n            Protocol protocol=protocols.get(i);\n            String protocolName=protocol.getName();\n\n            // regenerate the Properties which were destroyed during basic property processing\n            Map<String,String> properties=protocol_config.getOriginalProperties();\n\n            Method[] methods=Util.getAllDeclaredMethodsWithAnnotations(protocol.getClass(), Property.class);\n            for(int j=0; j < methods.length; j++) {\n                if(isSetPropertyMethod(methods[j])) {\n                    String propertyName=PropertyHelper.getPropertyName(methods[j]);\n\n                    Object propertyValue=getValueFromProtocol(protocol, propertyName);\n                    if(propertyValue == null) { // if propertyValue is null, check if there is a we can use\n                        Property annotation=methods[j].getAnnotation(Property.class);\n\n                        // get the default value for the method- check for InetAddress types\n                        String defaultValue=null;\n                        if(InetAddressInfo.isInetAddressRelated(methods[j])) {\n                            defaultValue=ip_version == 4? annotation.defaultValueIPv4() : annotation.defaultValueIPv6();\n                            if(defaultValue != null && defaultValue.length() > 0) {\n                                Object converted=null;\n                                try {\n                                    if(defaultValue.equalsIgnoreCase(Global.NON_LOOPBACK_ADDRESS))\n                                        converted=default_ip_address;\n                                    else\n                                        converted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, defaultValue);\n                                    methods[j].invoke(protocol, converted);\n                                }\n                                catch(Exception e) {\n                                    throw new Exception(\"default could not be assigned for method \" + propertyName + \" in \"\n                                            + protocolName + \" with default \" + defaultValue, e);\n                                }\n                                if(log.isDebugEnabled())\n                                    log.debug(\"set property \" + protocolName + \".\" + propertyName + \" to default value \" + converted);\n                            }\n                        }\n                    }\n                }\n            } \n\n            //traverse class hierarchy and find all annotated fields and add them to the list if annotated\n            Field[] fields=Util.getAllDeclaredFieldsWithAnnotations(protocol.getClass(), Property.class);\n            for(int j=0; j < fields.length; j++) {\n                String propertyName=PropertyHelper.getPropertyName(fields[j], properties);\n                Object propertyValue=getValueFromProtocol(protocol, fields[j]);\n                if(propertyValue == null) {\n                    // add to collection of @Properties with no user specified value\n                    Property annotation=fields[j].getAnnotation(Property.class);\n\n                    // get the default value for the field - check for InetAddress types\n                    String defaultValue=null;\n                    if(InetAddressInfo.isInetAddressRelated(protocol, fields[j])) {\n                        defaultValue=ip_version == 4? annotation.defaultValueIPv4() : annotation.defaultValueIPv6();\n                        if(defaultValue != null && defaultValue.length() > 0) {\n                            // condition for invoking converter\n                            if(defaultValue != null || !PropertyHelper.usesDefaultConverter(fields[j])) {\n                                Object converted=null;\n                                try {\n                                    if(defaultValue.equalsIgnoreCase(Global.NON_LOOPBACK_ADDRESS))\n                                        converted=default_ip_address;\n                                    else\n                                        converted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, defaultValue);\n                                    if(converted != null)\n                                        setField(fields[j], protocol, converted);\n                                }\n                                catch(Exception e) {\n                                    throw new Exception(\"default could not be assigned for field \" + propertyName + \" in \"\n                                            + protocolName + \" with default value \" + defaultValue, e);\n                                }\n\n                                if(log.isDebugEnabled())\n                                    log.debug(\"set property \" + protocolName + \".\" + propertyName + \" to default value \" + converted);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public Properties getOriginalProperties() throws Exception {\n        \tProperties props = new Properties() ; \n        \t\n        \tparsePropertiesString(properties_str, props) ;\n        \treturn props ;\n        }","id":42144,"modified_method":"public Map<String, String> getOriginalProperties() throws Exception {\n        \tMap<String,String> props = new HashMap<String,String>();\n        \tparsePropertiesString(properties_str, props) ;\n        \treturn props ;\n        }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"static void checkDependencyReferencesPresent(List<AccessibleObject> objects, Map<String, AccessibleObject> props) {\n    \t\n    \t// iterate overall properties marked by @Property\n    \tfor(int i = 0; i < objects.size(); i++) {\n    \t\t\n    \t\t// get the Property annotation\n    \t\tAccessibleObject ao = objects.get(i) ;\n    \t\tProperty annotation = ao.getAnnotation(Property.class) ;\n            if (annotation == null) {\n            \tthrow new IllegalArgumentException(\"@Property annotation is required for checking dependencies;\" + \n            \t\t\t\" annotation is missing for Field/Method \" + ao.toString()) ;\n            }\n    \t\t\n    \t\tString dependsClause = annotation.dependsUpon() ;\n    \t\tif (dependsClause.trim().equals(\"\"))\n    \t\t\tcontinue ;\n    \t\t\n    \t\t// split dependsUpon specifier into tokens; trim each token; search for token in list\n    \t\tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \t\twhile (st.hasMoreTokens()) {\n    \t\t\tString token = st.nextToken().trim() ;\n    \t\t\t\n    \t\t\t// check that the string representing a property name is in the list\n    \t\t\tboolean found = false ;\n    \t\t\tSet<String> keyset = props.keySet();\n    \t\t\tfor (Iterator<String> iter = keyset.iterator(); iter.hasNext();) {\n    \t\t\t\tif (iter.next().equals(token)) {\n    \t\t\t\t\tfound = true ;\n    \t\t\t\t\tbreak ;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (!found) {\n    \t\t\t\tthrow new IllegalArgumentException(\"@Property annotation \" + annotation.name() + \n    \t\t\t\t\t\t\" has an unresolved dependsUpon property: \" + token) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    }","id":42145,"modified_method":"static void checkDependencyReferencesPresent(List<AccessibleObject> objects, Map<String, AccessibleObject> props) {\n    \t\n    \t// iterate overall properties marked by @Property\n    \tfor(int i = 0; i < objects.size(); i++) {\n    \t\t\n    \t\t// get the Property annotation\n    \t\tAccessibleObject ao = objects.get(i) ;\n    \t\tProperty annotation = ao.getAnnotation(Property.class) ;\n            if (annotation == null) {\n            \tthrow new IllegalArgumentException(\"@Property annotation is required for checking dependencies;\" + \n            \t\t\t\" annotation is missing for Field/Method \" + ao.toString()) ;\n            }\n    \t\t\n    \t\tString dependsClause = annotation.dependsUpon() ;\n    \t\tif (dependsClause.trim().length() == 0)\n    \t\t\tcontinue ;\n    \t\t\n    \t\t// split dependsUpon specifier into tokens; trim each token; search for token in list\n    \t\tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \t\twhile (st.hasMoreTokens()) {\n    \t\t\tString token = st.nextToken().trim() ;\n    \t\t\t\n    \t\t\t// check that the string representing a property name is in the list\n    \t\t\tboolean found = false ;\n    \t\t\tSet<String> keyset = props.keySet();\n    \t\t\tfor (Iterator<String> iter = keyset.iterator(); iter.hasNext();) {\n    \t\t\t\tif (iter.next().equals(token)) {\n    \t\t\t\t\tfound = true ;\n    \t\t\t\t\tbreak ;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif (!found) {\n    \t\t\t\tthrow new IllegalArgumentException(\"@Property annotation \" + annotation.name() + \n    \t\t\t\t\t\t\" has an unresolved dependsUpon property: \" + token) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     *  DFS of dependency graph formed by Property annotations and dependsUpon parameter\n     *  This is used to create a list of Properties in dependency order\n     */\n    static void addPropertyToDependencyList(List<AccessibleObject> orderedList, Map<String, AccessibleObject> props, Stack<AccessibleObject> stack, AccessibleObject obj) {\n    \n    \tif (orderedList.contains(obj))\n    \t\treturn ;\n    \t\n    \tif (stack.search(obj) > 0) {\n    \t\tthrow new RuntimeException(\"Deadlock in @Property dependency processing\") ;\n    \t}\n    \t// record the fact that we are processing obj\n    \tstack.push(obj) ;\n    \t// process dependencies for this object before adding it to the list\n    \tProperty annotation = obj.getAnnotation(Property.class) ;\n    \tString dependsClause = annotation.dependsUpon() ;\n    \tif (log.isDebugEnabled()) { \n    \t\tlog.trace(\"processing: \" + obj.toString() + \" with dependsUpon: \" + dependsClause);\n    \t}\n    \tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \twhile (st.hasMoreTokens()) {\n    \t\tString token = st.nextToken().trim();\n    \t\tAccessibleObject dep = props.get(token) ;\n    \t\t// if null, throw exception \n    \t\taddPropertyToDependencyList(orderedList, props, stack, dep) ;\n    \t}\n    \t// indicate we're done with processing dependencies\n    \tstack.pop() ;\n    \t// we can now add in dependency order\n    \torderedList.add(obj) ;\n    }","id":42146,"modified_method":"/**\n     *  DFS of dependency graph formed by Property annotations and dependsUpon parameter\n     *  This is used to create a list of Properties in dependency order\n     */\n    static void addPropertyToDependencyList(List<AccessibleObject> orderedList, Map<String, AccessibleObject> props, Stack<AccessibleObject> stack, AccessibleObject obj) {\n    \n    \tif (orderedList.contains(obj))\n    \t\treturn ;\n    \t\n    \tif (stack.search(obj) > 0) {\n    \t\tthrow new RuntimeException(\"Deadlock in @Property dependency processing\") ;\n    \t}\n    \t// record the fact that we are processing obj\n    \tstack.push(obj) ;\n    \t// process dependencies for this object before adding it to the list\n    \tProperty annotation = obj.getAnnotation(Property.class) ;\n    \tString dependsClause = annotation.dependsUpon() ;\n    \tStringTokenizer st = new StringTokenizer(dependsClause, \",\") ;\n    \twhile (st.hasMoreTokens()) {\n    \t\tString token = st.nextToken().trim();\n    \t\tAccessibleObject dep = props.get(token) ;\n    \t\t// if null, throw exception \n    \t\taddPropertyToDependencyList(orderedList, props, stack, dep) ;\n    \t}\n    \t// indicate we're done with processing dependencies\n    \tstack.pop() ;\n    \t// we can now add in dependency order\n    \torderedList.add(obj) ;\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"static void parameterizedTypeSanityCheck(ParameterizedType pt) throws IllegalArgumentException {\n\n    \t\tType rawType = pt.getRawType() ;\n    \t\tType[] actualTypes = pt.getActualTypeArguments() ;\n\n    \t\tif (log.isDebugEnabled()) {\n    \t\t\tlog.debug(\"sanity check: rawtype = \" + rawType.toString()) ;\n    \t\t\tlog.debug(\"sanity check: actualtypes = \" + actualTypes.length) ;\n    \t\t}\n    \t\t\t\n    \t\t// constraints on use of parameterized types with @Property\n    \t\tif (!(rawType instanceof Class<?> && rawType.equals(List.class))) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type definition - parameterized type must be a List\") ;\n    \t\t}\n    \t\t// check for non-parameterized type in List\n    \t\tif (!(actualTypes[0] instanceof Class<?>)) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type - List must not contain a parameterized type\") ;\n    \t\t}\n    \t}","id":42147,"modified_method":"static void parameterizedTypeSanityCheck(ParameterizedType pt) throws IllegalArgumentException {\n\n    \t\tType rawType = pt.getRawType() ;\n    \t\tType[] actualTypes = pt.getActualTypeArguments() ;\n    \t\t\t\n    \t\t// constraints on use of parameterized types with @Property\n    \t\tif (!(rawType instanceof Class<?> && rawType.equals(List.class))) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type definition - parameterized type must be a List\") ;\n    \t\t}\n    \t\t// check for non-parameterized type in List\n    \t\tif (!(actualTypes[0] instanceof Class<?>)) {\n    \t\t\tthrow new IllegalArgumentException(\"Invalid parameterized type - List must not contain a parameterized type\") ;\n    \t\t}\n    \t}","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    private Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {       \n        Vector<ProtocolConfiguration> protocol_configs=parseConfigurations(configuration);\n        Vector<Protocol> protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        // basic protocol sanity check\n        sanityCheck(protocols);\n        \n        // check InetAddress related features of stack\n        Map<String, Map<String,InetAddressInfo>> inetAddressMap = null ;\n        boolean assumeIPv4 ;\n        inetAddressMap = createInetAddressMap(protocol_configs, protocols) ;\n        assumeIPv4 = getIPVersion(inetAddressMap) ;\n        if (!assumeIPv4) {\n        \tcheckIPv6Scopes(inetAddressMap) ;\n        }\n        // process default values\n        processDefaultValues(protocol_configs, protocols, assumeIPv4) ;\n        \n        return connectProtocols(protocols);        \n    }","id":42148,"modified_method":"/**\n     * The configuration string has a number of entries, separated by a ':' (colon).\n     * Each entry consists of the name of the protocol, followed by an optional configuration\n     * of that protocol. The configuration is enclosed in parentheses, and contains entries\n     * which are name/value pairs connected with an assignment sign (=) and separated by\n     * a semicolon.\n     * <pre>UDP(in_port=5555;out_port=4445):FRAG(frag_size=1024)<\/pre><p>\n     * The <em>first<\/em> entry defines the <em>bottommost<\/em> layer, the string is parsed\n     * left to right and the protocol stack constructed bottom up. Example: the string\n     * \"UDP(in_port=5555):FRAG(frag_size=32000):DEBUG\" results is the following stack:<pre>\n     *\n     *   -----------------------\n     *  | DEBUG                 |\n     *  |-----------------------|\n     *  | FRAG frag_size=32000  |\n     *  |-----------------------|\n     *  | UDP in_port=32000     |\n     *   -----------------------\n     * <\/pre>\n     */\n    private static Protocol setupProtocolStack(String configuration, ProtocolStack st) throws Exception {\n        Vector<ProtocolConfiguration> protocol_configs=parseConfigurations(configuration);\n        Vector<Protocol> protocols=createProtocols(protocol_configs, st);\n        if(protocols == null)\n            return null;\n        // basic protocol sanity check\n        sanityCheck(protocols);\n        \n        // check InetAddress related features of stack\n        Map<String, Map<String,InetAddressInfo>> inetAddressMap = createInetAddressMap(protocol_configs, protocols) ;\n        Collection<InetAddress> addrs=getAddresses(inetAddressMap);\n\n        int ip_version=Util.getIpStackType(); // 0 = n/a, 4 = IPv4, 6 = IPv6, 10=both IPv4 and IPv6\n\n        if(!addrs.isEmpty()) {\n            // check that all user-supplied InetAddresses have a consistent version\n            int addr_versions=determineIpVersionFromAddresses(addrs);\n\n            if(ip_version == 10)\n                ip_version=addr_versions;\n            else {\n                if(addr_versions != ip_version) { // mismatch between user supplied addresses and type of stack\n\n\n                    throw new RuntimeException(\"the type of the stack (IPv\" + ip_version + \") and the user supplied \" +\n                            \"addresses (IPv\" + addr_versions + \") don't match: \" + addrs +\n                            \".\\nUse \" + Global.IPv4 + \" or \" + Global.IPv6 + \" to pick the correct stack\");\n                }\n            }\n        }\n\n        if(ip_version == 10) {\n            if(Util.checkForWindows())\n                ip_version=4;\n            else\n                ip_version=6;\n            log.info(\"found both an IPv4 and an IPv6 stack, and no addresses were found to pick a stack, \" +\n                    \"defaulting to IPv\" + ip_version);\n        }\n\n        // check that all IPv6 link-local addresses have a scope\n        if(ip_version == 6)\n            checkIPv6Scopes(inetAddressMap) ;\n\n        // process default values\n        processDefaultValues(protocol_configs, protocols, ip_version) ;\n        \n        return connectProtocols(protocols);        \n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"static boolean isInetAddressRelated(Method m) {\n    \t\tif (hasParameterizedType(m)) {\n    \t\t\tType[] types = m.getGenericParameterTypes();\n    \t\t\tParameterizedType methodParamType = (ParameterizedType)types[0] ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(methodParamType) ;\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\tif(log.isDebugEnabled()) {\n    \t\t\t\t\tlog.debug(\"Method \" + m.getName() + \" failed paramaterizedTypeSanityCheck()\") ;\n    \t\t\t\t}\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not \n    \t\t\t\t// an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) methodParamType.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;    \t\t\t\n    \t\t}\n    \t\telse {\n    \t\t\tClass<?> methodParamType = m.getParameterTypes()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(methodParamType) ;\n    \t\t}\n    \t}","id":42149,"modified_method":"static boolean isInetAddressRelated(Method m) {\n    \t\tif (hasParameterizedType(m)) {\n    \t\t\tType[] types = m.getGenericParameterTypes();\n    \t\t\tParameterizedType methodParamType = (ParameterizedType)types[0] ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(methodParamType) ;\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\tif(log.isErrorEnabled()) {\n    \t\t\t\t\tlog.error(\"Method \" + m.getName() + \" failed paramaterizedTypeSanityCheck()\") ;\n    \t\t\t\t}\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not \n    \t\t\t\t// an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) methodParamType.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;    \t\t\t\n    \t\t}\n    \t\telse {\n    \t\t\tClass<?> methodParamType = m.getParameterTypes()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(methodParamType) ;\n    \t\t}\n    \t}","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static Map<String, Map<String,InetAddressInfo>> createInetAddressMap(Vector<ProtocolConfiguration> protocol_configs, \n    \t\tVector<Protocol> protocols) throws Exception {\n    \t// Map protocol -> Map<String, InetAddressInfo>, where the latter is protocol specific\n    \tMap<String, Map<String,InetAddressInfo>> inetAddressMap = new HashMap<String, Map<String, InetAddressInfo>>() ;\n\n    \t// collect InetAddressInfo\n    \tfor (int i = 0; i < protocol_configs.size(); i++) {    \t\t        \t\n    \t\tProtocolConfiguration protocol_config = protocol_configs.get(i) ;\n    \t\tProtocol protocol = protocols.get(i) ;\n    \t\tString protocolName = protocol.getName();\n\n    \t\t// maps property names to InetAddressInfo objects\n    \t\tMap<String, InetAddressInfo> protocolInetAddressMap = new HashMap<String,InetAddressInfo>() ;\n    \t\tinetAddressMap.put(protocolName, protocolInetAddressMap) ;\n\n    \t\tProperties properties = null ;\n    \t\t// regenerate the Properties which were destroyed during basic property processing\n    \t\tproperties = protocol_config.getOriginalProperties();\n\n\t\t\tif (log.isDebugEnabled())\n\t\t\t\tlog.debug(\"Processing InetAddressInfo for protocol: \" + protocolName);\n\n    \t\t// check which InetAddress-related properties are ***non-null ***, and \n    \t\t// create an InetAddressInfo structure for them\n    \t\tMethod[] methods=protocol.getClass().getMethods();\n    \t\tfor(int j = 0; j < methods.length; j++) {\n    \t\t\tif (methods[j].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[j])) {\n    \t\t\t\tString propertyName = PropertyHelper.getPropertyName(methods[j]) ;\n    \t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n    \t\t\t\tif (log.isDebugEnabled())\n    \t\t\t\t\tlog.debug(\"Processing InetAddressInfo for property \"+ propertyName+\" with value \" +propertyValue );\n    \t\t\t\tif (propertyValue != null && InetAddressInfo.isInetAddressRelated(methods[j])) {\n    \t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, propertyValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t}\n\t    \t\t\t\tif (log.isDebugEnabled())\n\t    \t\t\t\t\tlog.debug(\"Adding InetAddressInfo for property \"+propertyName+\" with value \" +propertyValue );\n    \t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, methods[j], properties, propertyValue, converted) ;\n    \t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ; \n    \t\t\t\t} // recompute\n    \t\t\t}\n    \t\t}\n\n    \t\t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \t\tfor(Class<?> clazz=protocol.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\t\tField[] fields=clazz.getDeclaredFields();\n    \t\t\tfor(int j = 0; j < fields.length; j++ ) {\n    \t\t\t\tif (fields[j].isAnnotationPresent(Property.class)) {\n     \t\t\t\t\tString propertyName = PropertyHelper.getPropertyName(fields[j], properties) ;\n    \t\t\t\t\tString propertyValue = properties.getProperty(propertyName) ;\n        \t\t\t\tif (log.isDebugEnabled())\n        \t\t\t\t\tlog.debug(\"Processing InetAddressInfo for property \"+propertyName+\" with value \" +propertyValue );\n    \t\t\t\t\tif ((propertyValue != null || !PropertyHelper.usesDefaultConverter(fields[j])) \n    \t\t\t\t\t\t\t&& InetAddressInfo.isInetAddressRelated(fields[j])) {\n    \t\t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, propertyValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t\t}\n\t\t    \t\t\t\tif (log.isDebugEnabled())\n\t\t    \t\t\t\t\tlog.debug(\"Adding InetAddressInfo for property \"+propertyName+\" with value \" +propertyValue );\n    \t\t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, fields[j], properties, propertyValue, converted) ;\n    \t\t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ; \n    \t\t\t\t\t}// recompute\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\t\n    \t}\n\n    \t// print out maps for debugging\n    \tif (log.isDebugEnabled()) {\n    \t\tfor (Map.Entry<String,Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n    \t\t\tString protocol = inetAddressMapEntry.getKey() ;\n    \t\t\tMap<String, InetAddressInfo> protocolInetAddressMap = inetAddressMapEntry.getValue() ; \n\n    \t\t\tlog.debug(\"***InetAddressInfo for protocol: \" + protocol + \"***\") ;\n    \t\t\tfor (Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n    \t\t\t\tString propertyName = protocolInetAddressMapEntry.getKey() ;\n    \t\t\t\tInetAddressInfo inetAddressInfo = protocolInetAddressMapEntry.getValue() ; \n    \t\t\t\tlog.debug(\"propertyName=\" + propertyName + \", addrinfo=\" + inetAddressInfo.toString()) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn inetAddressMap ;\n    }","id":42150,"modified_method":"public static Map<String, Map<String,InetAddressInfo>> createInetAddressMap(Vector<ProtocolConfiguration> protocol_configs, \n    \t\tVector<Protocol> protocols) throws Exception {\n    \t// Map protocol -> Map<String, InetAddressInfo>, where the latter is protocol specific\n    \tMap<String, Map<String,InetAddressInfo>> inetAddressMap = new HashMap<String, Map<String, InetAddressInfo>>() ;\n\n    \t// collect InetAddressInfo\n    \tfor (int i = 0; i < protocol_configs.size(); i++) {    \t\t        \t\n    \t\tProtocolConfiguration protocol_config = protocol_configs.get(i) ;\n    \t\tProtocol protocol = protocols.get(i) ;\n    \t\tString protocolName = protocol.getName();\n\n    \t\t// regenerate the Properties which were destroyed during basic property processing\n    \t\tMap<String,String> properties = protocol_config.getOriginalProperties();\n\n    \t\t// check which InetAddress-related properties are ***non-null ***, and\n    \t\t// create an InetAddressInfo structure for them\n    \t\t// Method[] methods=protocol.getClass().getMethods();\n            Method[] methods=Util.getAllDeclaredMethodsWithAnnotations(protocol.getClass(), Property.class);\n    \t\tfor(int j = 0; j < methods.length; j++) {\n    \t\t\tif (methods[j].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[j])) {\n    \t\t\t\tString propertyName = PropertyHelper.getPropertyName(methods[j]) ;\n    \t\t\t\tString propertyValue = properties.get(propertyName);\n\n                    // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n                    String tmp=grabSystemProp(methods[j].getAnnotation(Property.class));\n                    if(tmp != null)\n                        propertyValue=tmp;\n\n    \t\t\t\tif (propertyValue != null && InetAddressInfo.isInetAddressRelated(methods[j])) {\n    \t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, methods[j], properties, propertyValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t}\n    \t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, methods[j], properties, propertyValue, converted) ;\n\n                        Map<String, InetAddressInfo> protocolInetAddressMap=inetAddressMap.get(protocolName);\n                        if(protocolInetAddressMap == null) {\n                            protocolInetAddressMap = new HashMap<String,InetAddressInfo>() ;\n                            inetAddressMap.put(protocolName, protocolInetAddressMap) ;\n                        }\n    \t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ; \n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n\n    \t\t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \t\tfor(Class<?> clazz=protocol.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\t\tField[] fields=clazz.getDeclaredFields();\n    \t\t\tfor(int j = 0; j < fields.length; j++ ) {\n    \t\t\t\tif (fields[j].isAnnotationPresent(Property.class)) {\n     \t\t\t\t\tString propertyName = PropertyHelper.getPropertyName(fields[j], properties) ;\n    \t\t\t\t\tString propertyValue = properties.get(propertyName) ;\n\n                        // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n                        String tmp=grabSystemProp(fields[j].getAnnotation(Property.class));\n                        if(tmp != null)\n                            propertyValue=tmp;\n                        \n    \t\t\t\t\tif ((propertyValue != null || !PropertyHelper.usesDefaultConverter(fields[j]))\n    \t\t\t\t\t\t\t&& InetAddressInfo.isInetAddressRelated(protocol, fields[j])) {\n    \t\t\t\t\t\tObject converted = null ;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconverted=PropertyHelper.getConvertedValue(protocol, fields[j], properties, propertyValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch(Exception e) {\n\t\t\t\t\t\t\t\tthrow new Exception(\"String value could not be converted for method \" + propertyName + \" in \"\n\t\t\t\t\t\t\t\t\t\t+ protocolName + \" with default value \" + propertyValue + \".Exception is \" +e, e);\n\t\t\t\t\t\t\t}\n    \t\t\t\t\t\tInetAddressInfo inetinfo = new InetAddressInfo(protocol, fields[j], properties, propertyValue, converted) ;\n\n                            Map<String, InetAddressInfo> protocolInetAddressMap=inetAddressMap.get(protocolName);\n                            if(protocolInetAddressMap == null) {\n                                protocolInetAddressMap = new HashMap<String,InetAddressInfo>() ;\n                                inetAddressMap.put(protocolName, protocolInetAddressMap) ;\n                            }\n    \t\t\t\t\t\tprotocolInetAddressMap.put(propertyName, inetinfo) ;\n    \t\t\t\t\t}// recompute\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\t\n    \t}\n    \treturn inetAddressMap ;\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This method creates a list of all properties (Field or Method) in dependency order, \n     * where dependencies are specified using the dependsUpon specifier of the Property annotation. \n     * In particular, it does the following:\n     * (i) creates a master list of properties \n     * (ii) checks that all dependency references are present\n     * (iii) creates a copy of the master list in dependency order\n     */\n    static AccessibleObject[] computePropertyDependencies(Object obj, Properties properties) {\n    \t\n    \t// List of Fields and Methods of the protocol annotated with @Property\n    \tList<AccessibleObject> unorderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \tList<AccessibleObject> orderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \t// Maps property name to property object\n    \tMap<String, AccessibleObject> propertiesInventory = new HashMap<String, AccessibleObject>() ;\n    \t\n    \t// get the methods for this class and add them to the list if annotated with @Property\n    \tMethod[] methods=obj.getClass().getMethods();\n    \tfor(int i = 0; i < methods.length; i++) {\n \n    \t\tif (methods[i].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[i])) {\n    \t\t\tString propertyName = PropertyHelper.getPropertyName(methods[i]) ;\n    \t\t\tunorderedFieldsAndMethods.add(methods[i]) ;\n    \t\t\tpropertiesInventory.put(propertyName, methods[i]) ;\n    \t\t}\n    \t}\n    \t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \tfor(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\tField[] fields=clazz.getDeclaredFields();\n    \t\tfor(int i = 0; i < fields.length; i++ ) {\n    \t\t\tif (fields[i].isAnnotationPresent(Property.class)) {\n         \t\t\tString propertyName = PropertyHelper.getPropertyName(fields[i], properties) ;\n    \t\t\t\tunorderedFieldsAndMethods.add(fields[i]) ;\n    \t\t\t\t// may need to change this based on name parameter of Property\n    \t\t\t\tpropertiesInventory.put(propertyName, fields[i]) ;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t    \t\n//    \tif (log.isDebugEnabled()) {\n//    \t\tlog.debug(\"Properties inventory keyset for protocol: \" + obj.getClass().getName());\n//    \t\tSet<String> keyset = propertiesInventory.keySet();\n//    \t\tfor (Iterator<String> i = keyset.iterator(); i.hasNext();) {\n//    \t\t\tString property = i.next() ;\n//    \t\t\tlog.debug(\"property = \" + property);\n//    \t\t}\n//    \t}    \t\n    \t\n    \t// at this stage, we have all Fields and Methods annotated with @Property\n    \tcheckDependencyReferencesPresent(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n    \t// order the fields and methods by dependency\n    \torderedFieldsAndMethods = orderFieldsAndMethodsByDependency(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n//    \tif (log.isDebugEnabled()) {\n//    \t\tlog.debug(\"Ordered Fields and Methods for protocol: \" + obj.getClass().getName());\n//    \t\tfor (int i = 0; i < orderedFieldsAndMethods.size(); i++) {\n//    \t\t\tAccessibleObject ao = orderedFieldsAndMethods.get(i) ;\n//    \t\t\tlog.debug(\"name = \" + ao.toString());\n//    \t\t}\n//    \t}\n    \t\n    \t// convert to array of Objects\n    \tAccessibleObject[] result = new AccessibleObject[orderedFieldsAndMethods.size()] ;\n    \tfor(int i = 0; i < orderedFieldsAndMethods.size(); i++) {\n    \t\tresult[i] = orderedFieldsAndMethods.get(i) ;\n    \t}\n    \t\n    \treturn result ;\n    }","id":42151,"modified_method":"/**\n     * This method creates a list of all properties (Field or Method) in dependency order, \n     * where dependencies are specified using the dependsUpon specifier of the Property annotation. \n     * In particular, it does the following:\n     * (i) creates a master list of properties \n     * (ii) checks that all dependency references are present\n     * (iii) creates a copy of the master list in dependency order\n     */\n    static AccessibleObject[] computePropertyDependencies(Object obj, Map<String,String> properties) {\n    \t\n    \t// List of Fields and Methods of the protocol annotated with @Property\n    \tList<AccessibleObject> unorderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \tList<AccessibleObject> orderedFieldsAndMethods = new LinkedList<AccessibleObject>() ;\n    \t// Maps property name to property object\n    \tMap<String, AccessibleObject> propertiesInventory = new HashMap<String, AccessibleObject>() ;\n    \t\n    \t// get the methods for this class and add them to the list if annotated with @Property\n    \tMethod[] methods=obj.getClass().getMethods();\n    \tfor(int i = 0; i < methods.length; i++) {\n \n    \t\tif (methods[i].isAnnotationPresent(Property.class) && isSetPropertyMethod(methods[i])) {\n    \t\t\tString propertyName = PropertyHelper.getPropertyName(methods[i]) ;\n    \t\t\tunorderedFieldsAndMethods.add(methods[i]) ;\n    \t\t\tpropertiesInventory.put(propertyName, methods[i]) ;\n    \t\t}\n    \t}\n    \t//traverse class hierarchy and find all annotated fields and add them to the list if annotated\n    \tfor(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n    \t\tField[] fields=clazz.getDeclaredFields();\n    \t\tfor(int i = 0; i < fields.length; i++ ) {\n    \t\t\tif (fields[i].isAnnotationPresent(Property.class)) {\n         \t\t\tString propertyName = PropertyHelper.getPropertyName(fields[i], properties) ;\n    \t\t\t\tunorderedFieldsAndMethods.add(fields[i]) ;\n    \t\t\t\t// may need to change this based on name parameter of Property\n    \t\t\t\tpropertiesInventory.put(propertyName, fields[i]) ;\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \t// at this stage, we have all Fields and Methods annotated with @Property\n    \tcheckDependencyReferencesPresent(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n    \t// order the fields and methods by dependency\n    \torderedFieldsAndMethods = orderFieldsAndMethodsByDependency(unorderedFieldsAndMethods, propertiesInventory) ;\n    \t\n    \t// convert to array of Objects\n    \tAccessibleObject[] result = new AccessibleObject[orderedFieldsAndMethods.size()] ;\n    \tfor(int i = 0; i < orderedFieldsAndMethods.size(); i++) {\n    \t\tresult[i] = orderedFieldsAndMethods.get(i) ;\n    \t}\n    \t\n    \treturn result ;\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"private InetAddress getInetAddress(Object obj) throws IllegalArgumentException {\n    \t\tif (obj == null)\n    \t\t\tthrow new IllegalArgumentException(\"Input argument must represent a non-null IP address\") ;\n    \t\tif (obj instanceof InetAddress) \n    \t\t\treturn (InetAddress) obj ;\n    \t\telse if (obj instanceof IpAddress) \n    \t\t\treturn ((IpAddress) obj).getIpAddress() ;\n    \t\telse if (obj instanceof InetSocketAddress)\n    \t\t\treturn ((InetSocketAddress) obj).getAddress() ;\n    \t\telse {\n    \t\t\tif (log.isDebugEnabled()) \n    \t\t\t\tlog.debug(\"Input argument does not represent one of InetAddress...: class=\" + obj.getClass().getName()) ;\n       \t\t\tthrow new IllegalArgumentException(\"Input argument does not represent one of InetAddress. IpAddress not InetSocketAddress\") ;    \t\t\t\n    \t\t}\n     \t}","id":42152,"modified_method":"private static InetAddress getInetAddress(Object obj) throws IllegalArgumentException {\n    \t\tif (obj == null)\n    \t\t\tthrow new IllegalArgumentException(\"Input argument must represent a non-null IP address\") ;\n    \t\tif (obj instanceof InetAddress) \n    \t\t\treturn (InetAddress) obj ;\n    \t\telse if (obj instanceof IpAddress) \n    \t\t\treturn ((IpAddress) obj).getIpAddress() ;\n    \t\telse if (obj instanceof InetSocketAddress)\n    \t\t\treturn ((InetSocketAddress) obj).getAddress() ;\n    \t\telse {\n    \t\t\tif (log.isWarnEnabled())\n    \t\t\t\tlog.warn(\"Input argument does not represent one of InetAddress...: class=\" + obj.getClass().getName()) ;\n       \t\t\tthrow new IllegalArgumentException(\"Input argument does not represent one of InetAddress. IpAddress not InetSocketAddress\") ;    \t\t\t\n    \t\t}\n     \t}","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private Vector<Protocol> createProtocols(Vector<ProtocolConfiguration> protocol_configs, final ProtocolStack stack) throws Exception {\n        Vector<Protocol> retval=new Vector<Protocol>();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n        String singleton_name;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=protocol_configs.elementAt(i);\n            singleton_name=protocol_config.getProperties().getProperty(Global.SINGLETON_NAME);\n            if(singleton_name != null && singleton_name.trim().length() > 0) {\n               Map<String,Tuple<TP, ProtocolStack.RefCounter>> singleton_transports=ProtocolStack.getSingletonTransports();\n                synchronized(singleton_transports) {\n                    if(i > 0) { // crude way to check whether protocol is a transport\n                        throw new IllegalArgumentException(\"Property 'singleton_name' can only be used in a transport\" +\n                                \" protocol (was used in \" + protocol_config.getProtocolName() + \")\");\n                    }\n                    Tuple<TP, ProtocolStack.RefCounter> val=singleton_transports.get(singleton_name);\n                    layer=val != null? val.getVal1() : null;\n                    if(layer != null) {\n                        retval.add(layer);\n                    }\n                    else {\n                        layer=protocol_config.createLayer(stack);\n                        if(layer == null)\n                            return null;\n                        singleton_transports.put(singleton_name, new Tuple<TP, ProtocolStack.RefCounter>((TP)layer,new ProtocolStack.RefCounter((short)0,(short)0)));\n                        retval.addElement(layer);\n                    }\n                }\n                continue;\n            }\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        return retval;\n    }","id":42153,"modified_method":"/**\n     * Takes vector of ProtocolConfigurations, iterates through it, creates Protocol for\n     * each ProtocolConfiguration and returns all Protocols in a vector.\n     * @param protocol_configs Vector of ProtocolConfigurations\n     * @param stack The protocol stack\n     * @return Vector of Protocols\n     */\n    private static Vector<Protocol> createProtocols(Vector<ProtocolConfiguration> protocol_configs, final ProtocolStack stack) throws Exception {\n        Vector<Protocol> retval=new Vector<Protocol>();\n        ProtocolConfiguration protocol_config;\n        Protocol layer;\n        String singleton_name;\n\n        for(int i=0; i < protocol_configs.size(); i++) {\n            protocol_config=protocol_configs.elementAt(i);\n            singleton_name=protocol_config.getProperties().get(Global.SINGLETON_NAME);\n            if(singleton_name != null && singleton_name.trim().length() > 0) {\n               Map<String,Tuple<TP, ProtocolStack.RefCounter>> singleton_transports=ProtocolStack.getSingletonTransports();\n                synchronized(singleton_transports) {\n                    if(i > 0) { // crude way to check whether protocol is a transport\n                        throw new IllegalArgumentException(\"Property 'singleton_name' can only be used in a transport\" +\n                                \" protocol (was used in \" + protocol_config.getProtocolName() + \")\");\n                    }\n                    Tuple<TP, ProtocolStack.RefCounter> val=singleton_transports.get(singleton_name);\n                    layer=val != null? val.getVal1() : null;\n                    if(layer != null) {\n                        retval.add(layer);\n                    }\n                    else {\n                        layer=protocol_config.createLayer(stack);\n                        if(layer == null)\n                            return null;\n                        singleton_transports.put(singleton_name, new Tuple<TP, ProtocolStack.RefCounter>((TP)layer,new ProtocolStack.RefCounter((short)0,(short)0)));\n                        retval.addElement(layer);\n                    }\n                }\n                continue;\n            }\n            layer=protocol_config.createLayer(stack);\n            if(layer == null)\n                return null;\n            retval.addElement(layer);\n        }\n        return retval;\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void removeDeprecatedProperties(Object obj, Properties props) throws Exception {\n        //traverse class hierarchy and find all deprecated properties\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            if(clazz.isAnnotationPresent(DeprecatedProperty.class)) {\n                DeprecatedProperty declaredAnnotation=clazz.getAnnotation(DeprecatedProperty.class);\n                String[] deprecatedProperties=declaredAnnotation.names();\n                for(String propertyName : deprecatedProperties) {\n                    String propertyValue=props.getProperty(propertyName);\n                    if(propertyValue != null) {\n                        if(log.isWarnEnabled()) {\n                            String name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n                            log.warn(name + \" property \" + propertyName + \" was deprecated and is ignored\");\n                        }\n                        props.remove(propertyName);\n                    }\n                }\n            }\n        }\n    }","id":42154,"modified_method":"public static void removeDeprecatedProperties(Object obj, Map<String,String> props) throws Exception {\n        //traverse class hierarchy and find all deprecated properties\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            if(clazz.isAnnotationPresent(DeprecatedProperty.class)) {\n                DeprecatedProperty declaredAnnotation=clazz.getAnnotation(DeprecatedProperty.class);\n                String[] deprecatedProperties=declaredAnnotation.names();\n                for(String propertyName : deprecatedProperties) {\n                    String propertyValue=props.get(propertyName);\n                    if(propertyValue != null) {\n                        if(log.isWarnEnabled()) {\n                            String name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n                            log.warn(name + \" property \" + propertyName + \" was deprecated and is ignored\");\n                        }\n                        props.remove(propertyName);\n                    }\n                }\n            }\n        }\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndInvokePropertyMethods(Object obj, Properties props) throws Exception {\n        Method[] methods=obj.getClass().getMethods();\n        for(Method method: methods) {\n        \tresolveAndInvokePropertyMethod(obj, method, props) ;\n        }\n    }","id":42155,"modified_method":"public static void resolveAndInvokePropertyMethods(Object obj, Map<String,String> props) throws Exception {\n        Method[] methods=obj.getClass().getMethods();\n        for(Method method: methods) {\n        \tresolveAndInvokePropertyMethod(obj, method, props) ;\n        }\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void checkIPv6Scopes(Map<String, Map<String,InetAddressInfo>> inetAddressMap) throws Exception {\n    \t\n    \t// for each IPv6 address specified, check that if a link-local address is used, it has a scope\n\t\tfor (Map.Entry<String,Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n\t\t\tString protocol = inetAddressMapEntry.getKey() ;\n\t\t\tMap<String, InetAddressInfo> protocolInetAddressMap = inetAddressMapEntry.getValue() ; \n\t\t\tfor (Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n\t\t\t\tString propertyName = protocolInetAddressMapEntry.getKey() ;\n\t\t\t\tInetAddressInfo inetAddressInfo = protocolInetAddressMapEntry.getValue() ; \n\t\t\t\tList<InetAddress> addresses = inetAddressInfo.getInetAddresses();\n\t\t\t\tfor (InetAddress address: addresses) {\n\t\t\t\t\tif (address == null) \n\t\t\t\t\t\tthrow new RuntimeException(\"This address should not be null! - something is wrong\") ;\n\t\t\t\t\t\n\t\t\t\t\t// check if each link-local address has a scope\n\t\t\t\t\tif (address instanceof Inet6Address && address.isLinkLocalAddress()) {\n\t\t\t\t\t\t// check scope is present\n\t\t\t\t\t\tString propertyValue = inetAddressInfo.getStringValue() ;\n\t\t\t\t\t\tif (propertyValue == null)\n\t\t\t\t\t\t\tthrow new RuntimeException(\"The string value for this address should not be null! - something is wrong\") ;\n\n\t\t\t\t\t\t//check for scope and scope value here!\n\t\t\t\t\t\tif (log.isDebugEnabled()) \n\t\t\t\t\t\t\tlog.debug(\"Checking scope for Inet6 address \" + address.getHostName() + \n\t\t\t\t\t\t\t\t\t\" with user specified value \" + propertyValue) ;\n\t\t\t\t\t\t// TODO - implement the check\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}    \t\n    }","id":42156,"modified_method":"public static void checkIPv6Scopes(Map<String, Map<String, InetAddressInfo>> map) throws Exception {\n        // for each IPv6 address specified, check that if a link-local address is used, it has a scope\n        for(Map.Entry<String, Map<String, InetAddressInfo>> entry : map.entrySet()) {\n            Map<String, InetAddressInfo> addr_map=entry.getValue();\n            for(Map.Entry<String, InetAddressInfo> entry2 : addr_map.entrySet()) {\n                InetAddressInfo info=entry2.getValue();\n                List<InetAddress> addresses=info.getInetAddresses();\n                for(InetAddress address : addresses) {\n                    if(address == null)\n                        throw new RuntimeException(\"This address should not be null! - something is wrong\");\n\n                    // check if each link-local address has a scope\n                    if(address instanceof Inet6Address && address.isLinkLocalAddress()) {\n                        // check scope is present\n                        String propertyValue=info.getStringValue();\n                        if(propertyValue == null)\n                            throw new RuntimeException(\"The string value for this address should not be null! - something is wrong\");\n\n                        // throw an exception if no scope is present\n                        int scope=((Inet6Address)address).getScopeId();\n                        if(scope == 0) {\n                            throw new RuntimeException(\"Link-local IPv6 address \" + address.getHostName() +\n                                    \" has no scope (e.g. %eth0)\");\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndAssignField(Object obj, Field field, Properties props) throws Exception {\n\n    \tif(field.isAnnotationPresent(Property.class)) {\n    \t\tString propertyName = PropertyHelper.getPropertyName(field, props) ;\n    \t\tString propertyValue=props.getProperty(propertyName);\n    \t\t\n    \t\tif(propertyValue != null || !PropertyHelper.usesDefaultConverter(field)){\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, field, props, propertyValue);\n    \t\t\t\tif(converted != null)\n    \t\t\t\t\tsetField(field, obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Property assignment of \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \" with original property value \" + propertyValue + \" and converted to \" + converted \n    \t\t\t\t\t\t+ \" could not be assigned. Exception is \" +e, e);\n    \t\t\t}\n    \t\t\tfinally {\n    \t\t\t\tprops.remove(propertyName);\n    \t\t\t}\n    \t\t}\n    \t}\n    }","id":42157,"modified_method":"public static void resolveAndAssignField(Object obj, Field field, Map<String,String> props) throws Exception {\n    \tif(field.isAnnotationPresent(Property.class)) {\n    \t\tString propertyName = PropertyHelper.getPropertyName(field, props) ;\n    \t\tString propertyValue=props.get(propertyName);\n\n            // if there is a systemProperty attribute defined in the annotation, set the property value from the system property\n            String tmp=grabSystemProp(field.getAnnotation(Property.class));\n            if(tmp != null)\n                propertyValue=tmp;\n            \n    \t\tif(propertyValue != null || !PropertyHelper.usesDefaultConverter(field)){\n    \t\t\tObject converted=null;\n    \t\t\ttry {\n    \t\t\t\tconverted=PropertyHelper.getConvertedValue(obj, field, props, propertyValue);\n    \t\t\t\tif(converted != null)\n    \t\t\t\t\tsetField(field, obj, converted);\n    \t\t\t}\n    \t\t\tcatch(Exception e) {\n    \t\t\t\tString name=obj instanceof Protocol? ((Protocol)obj).getName() : obj.getClass().getName();\n    \t\t\t\tthrow new Exception(\"Property assignment of \" + propertyName + \" in \"\n    \t\t\t\t\t\t+ name + \" with original property value \" + propertyValue + \" and converted to \" + converted \n    \t\t\t\t\t\t+ \" could not be assigned. Exception is \" +e, e);\n    \t\t\t}\n    \t\t}\n\n            props.remove(propertyName);\n    \t}\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void resolveAndAssignFields(Object obj, Properties props) throws Exception {\n        //traverse class hierarchy and find all annotated fields\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            Field[] fields=clazz.getDeclaredFields();\n            for(Field field: fields) {\n            \tresolveAndAssignField(obj, field, props) ;\n            }\n        }\n    }","id":42158,"modified_method":"public static void resolveAndAssignFields(Object obj, Map<String,String> props) throws Exception {\n        //traverse class hierarchy and find all annotated fields\n        for(Class<?> clazz=obj.getClass(); clazz != null; clazz=clazz.getSuperclass()) {\n            Field[] fields=clazz.getDeclaredFields();\n            for(Field field: fields) {\n            \tresolveAndAssignField(obj, field, props) ;\n            }\n        }\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public List<InetAddress> getInetAddresses() {\n    \t\tList<InetAddress> addresses = new ArrayList<InetAddress>() ;\n    \t\tif (getConvertedValue() == null)\n    \t\t\treturn addresses ;\n    \t\t// if we take only an InetAddress argument\n    \t\tif (!isParameterized()) {\n    \t\t\taddresses.add(getInetAddress(getConvertedValue())) ;\n    \t\t\treturn addresses ;\n    \t\t}\n    \t\t// if we take a List<InetAddress> or similar\n    \t\telse {\n    \t\t\tList<?> values = (List<?>) getConvertedValue() ;\n    \t\t\tif (values.size() == 0)\n    \t\t\t\treturn addresses ;\n    \t\t\tfor (int i = 0; i < values.size(); i++) {\n    \t\t\t\taddresses.add(getInetAddress(values.get(i))) ;\n    \t\t\t}\n    \t\t\treturn addresses ;\n    \t\t}\n    \t}","id":42159,"modified_method":"public List<InetAddress> getInetAddresses() {\n    \t\tList<InetAddress> addresses = new ArrayList<InetAddress>() ;\n    \t\tif (getConvertedValue() == null)\n    \t\t\treturn addresses ;\n    \t\t// if we take only an InetAddress argument\n    \t\tif (!isParameterized()) {\n    \t\t\taddresses.add(getInetAddress(getConvertedValue())) ;\n    \t\t\treturn addresses ;\n    \t\t}\n    \t\t// if we take a List<InetAddress> or similar\n    \t\telse {\n    \t\t\tList<?> values = (List<?>) getConvertedValue() ;\n    \t\t\tif (values.isEmpty())\n    \t\t\t\treturn addresses ;\n    \t\t\tfor (int i = 0; i < values.size(); i++) {\n    \t\t\t\taddresses.add(getInetAddress(values.get(i))) ;\n    \t\t\t}\n    \t\t\treturn addresses ;\n    \t\t}\n    \t}","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"static boolean isInetAddressRelated(Field f) {\n    \t\tif (hasParameterizedType(f)) {\n    \t\t\t// check for List<InetAddress>, List<InetSocketAddress>, List<IpAddress>\n    \t\t\tParameterizedType fieldtype = (ParameterizedType) f.getGenericType() ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(fieldtype) ;\t\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\tif(log.isDebugEnabled()) {\n    \t\t\t\t\tlog.debug(\"Field \" + f.getName() + \" failed paramaterizedTypeSanityCheck()\") ;\n    \t\t\t\t}\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not \n    \t\t\t\t// an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) fieldtype.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;\n    \t\t}\t\t\n    \t\telse {\n    \t\t\t// check if the non-parameterized type is InetAddress, InetSocketAddress or IpAddress\n    \t\t\tClass<?> fieldtype = f.getType() ;\n    \t\t\treturn isInetAddressOrCompatibleType(fieldtype) ;\n    \t\t}\n    \t}","id":42160,"modified_method":"static boolean isInetAddressRelated(Protocol prot, Field f) {\n    \t\tif (hasParameterizedType(f)) {\n    \t\t\t// check for List<InetAddress>, List<InetSocketAddress>, List<IpAddress>\n    \t\t\tParameterizedType fieldtype = (ParameterizedType) f.getGenericType() ;\n    \t\t\t// check that this parameterized type satisfies our constraints\n    \t\t\ttry {\n    \t\t\t\tparameterizedTypeSanityCheck(fieldtype) ;\t\n    \t\t\t}\n    \t\t\tcatch(IllegalArgumentException e) {\n    \t\t\t\t// because this Method's parameter fails the sanity check, its probably not an InetAddress related structure\n    \t\t\t\treturn false ;\n    \t\t\t}\n    \t\t\t\n    \t\t\tClass<?> listType = (Class<?>) fieldtype.getActualTypeArguments()[0] ;\n    \t\t\treturn isInetAddressOrCompatibleType(listType) ;\n    \t\t}\t\t\n    \t\telse {\n    \t\t\t// check if the non-parameterized type is InetAddress, InetSocketAddress or IpAddress\n    \t\t\tClass<?> fieldtype = f.getType() ;\n    \t\t\treturn isInetAddressOrCompatibleType(fieldtype) ;\n    \t\t}\n    \t}","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            StringBuilder retval=new StringBuilder();\n            retval.append(\"Protocol: \");\n            if(protocol_name == null)\n                retval.append(\"<unknown>\");\n            else\n                retval.append(protocol_name);\n            if(properties != null)\n                retval.append(\"(\" + properties + ')');\n            return retval.toString();\n        }","id":42161,"modified_method":"public String toString() {\n            StringBuilder retval=new StringBuilder();\n            if(protocol_name == null)\n                retval.append(\"<unknown>\");\n            else\n                retval.append(protocol_name);\n            if(properties != null)\n                retval.append(\"(\" + Util.print(properties) + ')');\n            return retval.toString();\n        }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"InetAddressInfo(Protocol protocol, AccessibleObject fieldOrMethod, Properties properties, String stringValue, \n    \t\t\tObject convertedValue) {\n    \t\t// check input values\n    \t\tif (protocol == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Protocol for Field/Method must be non-null\") ;\n    \t\t}\t\t\n    \t\tif (fieldOrMethod instanceof Field) {\n    \t\t\tisField = true ;\n    \t\t} else if (fieldOrMethod instanceof Method) {\n    \t\t\tisField = false ;\n    \t\t} else \n    \t\t\tthrow new IllegalArgumentException(\"AccesibleObject is neither Field nor Method\") ;\n    \t\tif (properties == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Properties for Field/Method must be non-null\") ;\n    \t\t}\t\t\n\n    \t\t// set the values passed by the user - need to check for null\n    \t\tthis.protocol = protocol ;\n    \t\tthis.fieldOrMethod = fieldOrMethod ;\n    \t\tthis.properties = properties ;\n    \t\tthis.stringValue = stringValue ;\n    \t\tthis.convertedValue = convertedValue ;\n    \t\t\n    \t\t// set the property name\n    \t\tProperty annotation=fieldOrMethod.getAnnotation(Property.class);    \t\t\n    \t\tif (isField())\n        \t\tpropertyName=PropertyHelper.getPropertyName((Field)fieldOrMethod, properties) ;\n    \t\telse \n        \t\tpropertyName=PropertyHelper.getPropertyName((Method)fieldOrMethod) ;\n    \t\t\n    \t\t// is variable type parameterized\n    \t\tthis.isParameterized = false ;\n    \t\tif (isField())\n    \t\t\tthis.isParameterized = hasParameterizedType((Field)fieldOrMethod) ;\n    \t\telse \n    \t\t\tthis.isParameterized = hasParameterizedType((Method)fieldOrMethod) ;\n\n    \t\t// if parameterized, what is the base type?\n    \t\tthis.baseType = null ;\n    \t\tif (isField() && isParameterized) {\n    \t\t\t// the Field has a single type\n    \t\t\tParameterizedType fpt = (ParameterizedType)((Field)fieldOrMethod).getGenericType() ;\n    \t\t\tthis.baseType = fpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t\telse if (!isField() && isParameterized) {\n    \t\t\t// the Method has several parameters (and so types)\n    \t\t\tType[] types = (Type[])((Method)fieldOrMethod).getGenericParameterTypes();\n    \t\t\tParameterizedType mpt = (ParameterizedType) types[0] ;\n    \t\t\tthis.baseType = mpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t}","id":42162,"modified_method":"InetAddressInfo(Protocol protocol, AccessibleObject fieldOrMethod, Map<String,String> properties, String stringValue,\n    \t\t\tObject convertedValue) {\n    \t\t// check input values\n    \t\tif (protocol == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Protocol for Field/Method must be non-null\") ;\n    \t\t}\t\t\n    \t\tif (fieldOrMethod instanceof Field) {\n    \t\t\tisField = true ;\n    \t\t} else if (fieldOrMethod instanceof Method) {\n    \t\t\tisField = false ;\n    \t\t} else \n    \t\t\tthrow new IllegalArgumentException(\"AccesibleObject is neither Field nor Method\") ;\n    \t\tif (properties == null) {\n    \t\t\tthrow new IllegalArgumentException(\"Properties for Field/Method must be non-null\") ;\n    \t\t}\t\t\n\n    \t\t// set the values passed by the user - need to check for null\n    \t\tthis.protocol = protocol ;\n    \t\tthis.fieldOrMethod = fieldOrMethod ;\n    \t\tthis.properties = properties ;\n    \t\tthis.stringValue = stringValue ;\n    \t\tthis.convertedValue = convertedValue ;\n    \t\t\n    \t\t// set the property name\n    \t\tProperty annotation=fieldOrMethod.getAnnotation(Property.class);    \t\t\n    \t\tif (isField())\n        \t\tpropertyName=PropertyHelper.getPropertyName((Field)fieldOrMethod, properties) ;\n    \t\telse \n        \t\tpropertyName=PropertyHelper.getPropertyName((Method)fieldOrMethod) ;\n    \t\t\n    \t\t// is variable type parameterized\n    \t\tthis.isParameterized = false ;\n    \t\tif (isField())\n    \t\t\tthis.isParameterized = hasParameterizedType((Field)fieldOrMethod) ;\n    \t\telse \n    \t\t\tthis.isParameterized = hasParameterizedType((Method)fieldOrMethod) ;\n\n    \t\t// if parameterized, what is the base type?\n    \t\tthis.baseType = null ;\n    \t\tif (isField() && isParameterized) {\n    \t\t\t// the Field has a single type\n    \t\t\tParameterizedType fpt = (ParameterizedType)((Field)fieldOrMethod).getGenericType() ;\n    \t\t\tthis.baseType = fpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t\telse if (!isField() && isParameterized) {\n    \t\t\t// the Method has several parameters (and so types)\n    \t\t\tType[] types = (Type[])((Method)fieldOrMethod).getGenericParameterTypes();\n    \t\t\tParameterizedType mpt = (ParameterizedType) types[0] ;\n    \t\t\tthis.baseType = mpt.getActualTypeArguments()[0] ;\n    \t\t}\n    \t}","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This method takes a set of InetAddresses, represented by an inetAddressmap, and:\n     * - if the resulting set is non-empty, goes through to see if all InetAddress-related \n     * user settings have a consistent IP version: v4 or v6, and throws an exception if not\n     * - if the resulting set is empty, sets the default IP version based on available stacks \n     * and if a dual stack, stack preferences \n     * - sets the IP version to be used in the JGroups session\n     */\n    public static boolean getIPVersion(Map<String, Map<String,InetAddressInfo>> inetAddressMap) throws Exception {\n    \t\n    \t// for each InetAddressInfo with non-null value, add to sets\n    \t// sets which hold user those IP addresses specified by user (non-null)\n    \tSet<InetAddress> userSpecified = new HashSet<InetAddress>() ;\n    \tSet<InetAddress> userSpecifiedIPv4 = new HashSet<InetAddress>() ;\n    \tSet<InetAddress> userSpecifiedIPv6 = new HashSet<InetAddress>() ;\n\n\t\tfor (Map.Entry<String,Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n\t\t\tString protocol = inetAddressMapEntry.getKey() ;\n\t\t\tMap<String, InetAddressInfo> protocolInetAddressMap = inetAddressMapEntry.getValue() ; \n\t\t\tfor (Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n\t\t\t\tString propertyName = protocolInetAddressMapEntry.getKey() ;\n\t\t\t\tInetAddressInfo inetAddressInfo = protocolInetAddressMapEntry.getValue() ; \n\t\t\t\t// add InetAddressInfo to sets based on IP version\n\t\t\t\tList<InetAddress> addresses = inetAddressInfo.getInetAddresses();\n\t\t\t\tfor (InetAddress address: addresses) {\n\t\t\t\t\tif (address == null) \n\t\t\t\t\t\tthrow new RuntimeException(\"This address should not be null! - something is wrong\") ;\n\t\t\t\t\tuserSpecified.add(address) ;\n\t\t\t\t\tif (address instanceof Inet4Address)\n\t\t\t\t\t\tuserSpecifiedIPv4.add(address) ;\n\t\t\t\t\telse \n\t\t\t\t\t\tuserSpecifiedIPv6.add(address) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}    \t\n\t\t\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"userSpecified set contents:\") ;\n\t\t\tfor (Iterator<InetAddress> iter = userSpecified.iterator(); iter.hasNext();) {\n\t\t\t\tInetAddress address = iter.next() ;\n\t\t\t\tlog.debug(address.toString()) ;\n\t\t\t}\n\t\t\tlog.debug(\"userSpecifiedIPv4 set contents:\") ;\n\t\t\tfor (Iterator<InetAddress> iter = userSpecifiedIPv4.iterator(); iter.hasNext();) {\n\t\t\t\tInetAddress address = iter.next() ;\n\t\t\t\tlog.debug(address.toString()) ;\n\t\t\t}\n\t\t\tlog.debug(\"userSpecifiedIPv6 set contents:\") ;\n\t\t\tfor (Iterator<InetAddress> iter = userSpecifiedIPv6.iterator(); iter.hasNext();) {\n\t\t\t\tInetAddress address = iter.next() ;\n\t\t\t\tlog.debug(address.toString()) ;\n\t\t\t}\n\t\t}\n\t\t\n    \t// now use sets to compute IP version\n\t\tboolean isIPv4StackAvailable = Util.isIPv4StackAvailable() ;\n\t\tboolean isIPv6StackAvailable = Util.isIPv6StackAvailable() ;\n\t\tboolean assumeIPv4 = true ;\n\t\t\n    \tif (log.isDebugEnabled()) {\n    \t\tlog.debug(\"isIPv4StackAvailable = \" + isIPv4StackAvailable) ;\n    \t\tlog.debug(\"isIPv6StackAvailable = \" + isIPv6StackAvailable) ;\n    \t}\n\t\t\n\t\t\n\t\t// the user supplied 1 or more IP address inputs. Check if we have a consistent set\n    \t// which matches a stack on this host\n    \tif (userSpecified.size() > 0) {\n    \t\t// check for a consistent IP version for IP addresses specified\n    \t\tif (!((userSpecifiedIPv4.size() > 0 && userSpecifiedIPv6.size() == 0) || \n    \t\t\t\t(userSpecifiedIPv4.size() == 0 && userSpecifiedIPv6.size() > 0))) {\n    \t\t\tthrow new RuntimeException(\"No consistent IP version available (IPv4 or IPv6) for user-specified IP addresses\") ;\n    \t\t}\n    \t\t// set the consistent version - we don't reach here unless we have one\n    \t\tassumeIPv4 = (userSpecifiedIPv4.size() > 0 && userSpecifiedIPv6.size() == 0) ;\n    \t\t\n    \t\tif (assumeIPv4 && !isIPv4StackAvailable) {\n    \t\t\tthrow new RuntimeException(\"A consistent IP version (IPv4) is available for \" + \n    \t\t\t\t\t\"user-specified addresses but there is no stack to support it\") ;\n    \t\t}\n    \t\tif (!assumeIPv4 && !isIPv6StackAvailable) {\n    \t\t\tthrow new RuntimeException(\"A consistent IP version (IPv6) is available for \" + \n\t\t\t\t\" user-specified addresses but there is no stack to support it\") ;\n    \t\t}\t\n    \t}\n    \telse {\n    \t\t// the user supplied no default IP addresses, so just get the stack preference.\n    \t\t\n    \t\t// if only IPv4 stack available, set assumeIPv4 = true\n    \t\tif (isIPv4StackAvailable && !isIPv6StackAvailable) {\n    \t\t\tassumeIPv4 = true ;\n    \t\t}\n    \t\telse if (isIPv6StackAvailable && !isIPv4StackAvailable) {\n    \t\t\tassumeIPv4 = false ;\n    \t\t}\n    \t\telse if (isIPv4StackAvailable && isIPv6StackAvailable) {\n    \t\t\t// get the System property which records user preference for a stack on a dual stack machine\n    \t\t\t// Bela wanted to check for null and set to IPv4\n    \t\t\tboolean preferIPv4Stack = Boolean.getBoolean(\"java.net.preferIPv4Stack\") ;\n    \t\t\tassumeIPv4 = preferIPv4Stack ;\n    \t\t}\n    \t}\n    \t\n    \tif (log.isDebugEnabled()) {\n    \t\tlog.debug(\"assumeIPv4 = \" + assumeIPv4) ;\n    \t}\n    \t\n    \treturn assumeIPv4 ;\n    }","id":42163,"modified_method":"/**\n     * Returns all inet addresses found\n     */\n    public static Collection<InetAddress> getAddresses(Map<String, Map<String, InetAddressInfo>> inetAddressMap) throws Exception {\n        Set<InetAddress> addrs=new HashSet<InetAddress>();\n\n        for(Map.Entry<String, Map<String, InetAddressInfo>> inetAddressMapEntry : inetAddressMap.entrySet()) {\n            Map<String, InetAddressInfo> protocolInetAddressMap=inetAddressMapEntry.getValue();\n            for(Map.Entry<String, InetAddressInfo> protocolInetAddressMapEntry : protocolInetAddressMap.entrySet()) {\n                InetAddressInfo inetAddressInfo=protocolInetAddressMapEntry.getValue();\n                // add InetAddressInfo to sets based on IP version\n                List<InetAddress> addresses=inetAddressInfo.getInetAddresses();\n                for(InetAddress address : addresses) {\n                    if(address == null)\n                        throw new RuntimeException(\"This address should not be null! - something is wrong\");\n                    addrs.add(address);\n                }\n            }\n        }\n        return addrs;\n    }","commit_id":"64822762dda7dc0968e8fe0ac05621fa361b52eb","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * Checks whether the <code>string<\/code> is considered empty. Empty means\n\t * that the string may contain whitespace, but no visible characters.\n\t * \n\t * \"\\n\\t \" is considered empty, while \" a\" is not.\n\t * \n\t * @param string\n\t *            The string\n\t * @return True if the string is null or \"\"\n\t */\n\tpublic static boolean isEmpty(final CharSequence string)\n\t{\n\t\treturn string == null || string.length() == 0 || string.toString().trim().equals(\"\");\n\t}","id":42164,"modified_method":"/**\n\t * Checks whether the <code>string<\/code> is considered empty. Empty means\n\t * that the string may contain whitespace, but no visible characters.\n\t * \n\t * \"\\n\\t \" is considered empty, while \" a\" is not.\n\t * \n\t * @param string\n\t *            The string\n\t * @return True if the string is null or \"\"\n\t */\n\tpublic static boolean isEmpty(final CharSequence string)\n\t{\n\t\treturn string == null || string.length() == 0 || string.toString().trim().length() == 0;\n\t}","commit_id":"43905f286da9b758f6b535db43cdd60ee23ca328","url":"https://github.com/apache/wicket"},{"original_method":"/**\n     * This will return true if the value is really a \"formula\" - in\n     * the sense of like an excel spreadsheet.\n     *\n     *  If it IS a formula, then the value should never be turned into a\n     *  string, always left as-is.\n     *\n     */\n    public boolean isFormula() {\n        if ( this.value == null ) {\n            return false;\n        }\n        if ( this.value.trim().startsWith( \"=\" ) ) {\n            return true;\n        } else {\n            return false;\n        }\n    }","id":42165,"modified_method":"/**\n     * This will return true if the value is really a \"formula\" - in\n     * the sense of like an excel spreadsheet.\n     *\n     *  If it IS a formula, then the value should never be turned into a\n     *  string, always left as-is.\n     *\n     */\n    public boolean isFormula() {\n        return this.value != null && this.value.trim().startsWith( \"=\" );\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Marshal LHS patterns\n     *\n     * @param buf\n     * @param model\n     */\n    private void marshalLHS(StringBuilder buf, RuleModel model,\n            boolean isDSLEnhanced) {\n        IPattern[] lhs = model.lhs;\n        LHSPatternVisitor visitor = new LHSPatternVisitor(isDSLEnhanced, buf);\n        for (int i = 0; i < lhs.length; i++) {\n            final IPattern cond = lhs[i];\n            visitor.visit(cond);\n        }\n    }","id":42166,"modified_method":"/**\n     * Marshal LHS patterns\n     *\n     * @param buf\n     * @param model\n     */\n    private void marshalLHS(StringBuilder buf, RuleModel model,\n            boolean isDSLEnhanced) {\n\t\tif (model.lhs != null) {\n\t\t\tLHSPatternVisitor visitor = new LHSPatternVisitor(isDSLEnhanced, buf);\n\t\t\tfor (IPattern cond : model.lhs) {\n\t\t\t\tvisitor.visit(cond);\n\t\t\t}\n\t\t}\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void marshalRHS(StringBuilder buf, RuleModel model,\n            boolean isDSLEnhanced) {\n        IAction[] rhs = model.rhs;\n        RHSActionVisitor visitor = new RHSActionVisitor(isDSLEnhanced, buf);\n        for (int i = 0; i < rhs.length; i++) {\n            final IAction action = rhs[i];\n            visitor.visit(action);\n        }\n    }","id":42167,"modified_method":"private void marshalRHS(StringBuilder buf, RuleModel model,\n            boolean isDSLEnhanced) {\n\t\tif (model.rhs != null) {\n\t\t\tRHSActionVisitor visitor = new RHSActionVisitor(isDSLEnhanced, buf);\n\t\t\tfor (IAction action : model.rhs) {\n\t\t\t\tvisitor.visit(action);\n\t\t\t}\n\t\t}\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private BRDRLPersistence() {\n    }","id":42168,"modified_method":"protected BRDRLPersistence() {\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public RuleModel unmarshal(String str) {\n        throw new UnsupportedOperationException(\n                \"Still not possible to convert pure DRL to RuleModel\");\n    }","id":42169,"modified_method":"/**\n     * @see\n     * org.drools.guvnor.server.util.BRLPersistence#unmarshal(java.lang.String)\n     */\n    public RuleModel unmarshal(String str) {\n        throw new UnsupportedOperationException(\n                \"Still not possible to convert pure DRL to RuleModel\");\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void generateSetMethodCalls(final String variableName,\n                final ActionFieldValue[] fieldValues) {\n            for (int i = 0; i < fieldValues.length; i++) {\n                buf.append(\"\\t\\t\");\n                if (isDSLEnhanced) {\n                    buf.append(\">\");\n                }\n                buf.append(variableName);\n\n                ActionFieldValue value = fieldValues[i];\n                if (value instanceof ActionFieldFunction) {\n                    buf.append(\".\");\n                    buf.append(value.field);\n                } else {\n                    buf.append(\".set\");\n                    buf.append(Character.toUpperCase(fieldValues[i].field.charAt(0)));\n                    buf.append(fieldValues[i].field.substring(1));\n                }\n                buf.append(\"( \");\n                if (fieldValues[i].isFormula()) {\n                    buf.append(fieldValues[i].value.substring(1));\n                } else if (SuggestionCompletionEngine.TYPE_STRING.equals(fieldValues[i].type)) {\n                    buf.append(\"\\\"\");\n                    buf.append(fieldValues[i].value);\n                    buf.append(\"\\\"\");\n                } else {\n                    buf.append(fieldValues[i].value);\n                }\n                buf.append(\" );\\n\");\n            }\n        }","id":42170,"modified_method":"private void generateSetMethodCalls(final String variableName,\n                final ActionFieldValue[] fieldValues) {\n            for (int i = 0; i < fieldValues.length; i++) {\n                buf.append(\"\\t\\t\");\n                if (isDSLEnhanced) {\n                    buf.append(\">\");\n                }\n                buf.append(variableName);\n\n                ActionFieldValue value = fieldValues[i];\n                if (value instanceof ActionFieldFunction) {\n                    buf.append(\".\");\n                    buf.append(value.field);\n                } else {\n                    buf.append(\".set\");\n                    buf.append(Character.toUpperCase(fieldValues[i].field.charAt(0)));\n                    buf.append(fieldValues[i].field.substring(1));\n                }\n                buf.append(\"( \");\n                if (fieldValues[i].isFormula()) {\n                    buf.append(fieldValues[i].value.substring(1));\n                } else if (SuggestionCompletionEngine.TYPE_STRING.equals(fieldValues[i].type)) {\n                    buf.append(\"\\\"\");\n                    buf.append(generateFieldValue(fieldValues[i]));\n                    buf.append(\"\\\"\");\n                } else {\n                    buf.append(generateFieldValue(fieldValues[i]));\n                }\n                buf.append(\" );\\n\");\n            }\n        }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public String marshal(RuleModel model) {\n        boolean isDSLEnhanced = model.hasDSLSentences();\n\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"rule \\\"\" + model.name + \"\\\"\");\n        if (null != model.parentName && model.parentName.length() > 0) {\n            buf.append(\" extends \\\"\" + model.parentName + \"\\\"\\n\");\n        } else {\n            buf.append(\"\\n\");\n        }\n        this.marshalMetadata(buf, model);\n        this.marshalAttributes(buf, model);\n\n        buf.append(\"\\twhen\\n\");\n        this.marshalLHS(buf, model, isDSLEnhanced);\n        buf.append(\"\\tthen\\n\");\n        this.marshalRHS(buf, model, isDSLEnhanced);\n        buf.append(\"end\\n\");\n        return buf.toString();\n    }","id":42171,"modified_method":"public String marshal(RuleModel model) {\n        return marshalRule(model);\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void addFieldRestriction(final StringBuilder buf,\n                final int type, final String operator, final String value,\n                final ExpressionFormLine expression) {\n            if (operator == null) {\n                return;\n            }\n\n            buf.append(\" \");\n            buf.append(operator);\n            buf.append(\" \");\n            switch (type) {\n                case ISingleFieldConstraint.TYPE_RET_VALUE:\n                    buf.append(\"( \");\n                    buf.append(value);\n                    buf.append(\" )\");\n                    break;\n                case ISingleFieldConstraint.TYPE_LITERAL:\n                    if (operator.equals(\"in\")) {\n                        buf.append(value);\n                    } else {\n                        buf.append('\"');\n                        buf.append(value);\n                        buf.append('\"');\n                    }\n                    break;\n                case ISingleFieldConstraint.TYPE_EXPR_BUILDER:\n                    if (expression!=null){\n                        buf.append(expression.getText());\n                    }\n                    break;\n                default:\n                    buf.append(value);\n            }\n            buf.append(\" \");\n        }","id":42172,"modified_method":"private void addFieldRestriction(final StringBuilder buf,\n                final int type, final String operator, final String value,\n                final ExpressionFormLine expression) {\n            if (operator == null) {\n                return;\n            }\n\n            buf.append(\" \");\n            buf.append(operator);\n            buf.append(\" \");\n            switch (type) {\n                case ISingleFieldConstraint.TYPE_RET_VALUE:\n                    buf.append(\"( \");\n                    buf.append(value);\n                    buf.append(\" )\");\n                    break;\n                case ISingleFieldConstraint.TYPE_LITERAL:\n                    if (operator.equals(\"in\")) {\n                        buf.append(value);\n                    } else {\n                        buf.append('\"');\n                        buf.append(value);\n                        buf.append('\"');\n                    }\n                    break;\n                case ISingleFieldConstraint.TYPE_EXPR_BUILDER:\n                    if (expression!=null){\n                        buf.append(expression.getText());\n                    }\n                    break;\n                case ISingleFieldConstraint.TYPE_TEMPLATE:\n                \tif (operator.equals(\"in\")) {\n                        buf.append(value);\n                    } else {\n                        buf.append(\"\\\"@{\");\n                        buf.append(value);\n                        buf.append(\"}\\\"\");\n                    }\n                \tbreak;\n                default:\n                    buf.append(value);\n            }\n            buf.append(\" \");\n        }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public RuleModel unmarshal(final String xml) {\n        if ( xml == null ) {\n            return new RuleModel();\n        }\n        if ( xml.trim().equals( \"\" ) ) {\n            return new RuleModel();\n        }\n        RuleModel rm = (RuleModel) this.xt.fromXML( xml );\n        //Fixme , hack for a upgrade to add Metadata\n        if ( rm.metadataList == null ) {\n            rm.metadataList = new RuleMetadata[0];\n        }\n        \n        updateMethodCall( rm );\n        \n        return rm;\n    }","id":42173,"modified_method":"public RuleModel unmarshal(final String xml) {\n        if ( xml == null || xml.trim().length() == 0) {\n            return createEmptyModel();\n        }\n        RuleModel rm = (RuleModel) this.xt.fromXML( xml );\n        //Fixme , hack for a upgrade to add Metadata\n        if ( rm.metadataList == null ) {\n            rm.metadataList = new RuleMetadata[0];\n        }\n        \n        updateMethodCall( rm );\n        \n        return rm;\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private BRXMLPersistence() {\n        this.xt = new XStream( new DomDriver() );\n\n        this.xt.alias( \"rule\",\n                       RuleModel.class );\n        this.xt.alias( \"fact\",\n                       FactPattern.class );\n        this.xt.alias( \"retract\",\n                       ActionRetractFact.class );\n        this.xt.alias( \"assert\",\n                       ActionInsertFact.class );\n        this.xt.alias( \"modify\",\n                       ActionUpdateField.class );\n        this.xt.alias( \"setField\",\n                       ActionSetField.class );\n        this.xt.alias( \"dslSentence\",\n                       DSLSentence.class );\n        this.xt.alias( \"compositePattern\",\n                       CompositeFactPattern.class );\n        this.xt.alias( \"fromCompositePattern\",\n                       FromCompositeFactPattern.class );\n        this.xt.alias( \"fromCollectCompositePattern\",\n                       FromCollectCompositeFactPattern.class );\n        this.xt.alias( \"fromAccumulateCompositePattern\",\n                       FromAccumulateCompositeFactPattern.class );\n        this.xt.alias( \"metadata\",\n                       RuleMetadata.class );\n        this.xt.alias( \"attribute\",\n                       RuleAttribute.class );\n\n        this.xt.alias( \"fieldValue\",\n                       ActionFieldValue.class );\n        this.xt.alias( \"connectiveConstraint\",\n                       ConnectiveConstraint.class );\n        this.xt.alias( \"fieldConstraint\",\n                       SingleFieldConstraint.class );\n\n        this.xt.alias( \"compositeConstraint\",\n                       CompositeFieldConstraint.class );\n\n        this.xt.alias( \"assertLogical\",\n                       ActionInsertLogicalFact.class );\n        this.xt.alias( \"freeForm\",\n                       FreeFormLine.class );\n\n        this.xt.alias( \"addToGlobal\",\n                       ActionGlobalCollectionAdd.class );\n        //Begin ExpressionFormLine\n        this.xt.alias( \"expression\",\n                ExpressionFormLine.class );\n        \n        this.xt.alias( \"field\",\n                ExpressionField.class );\n        \n        this.xt.alias( \"method\",\n                ExpressionMethod.class );\n        \n        this.xt.alias( \"collection\",\n                ExpressionCollection.class );\n        \n        this.xt.alias( \"collectionIndex\",\n                ExpressionCollectionIndex.class );\n        \n        this.xt.alias( \"text\",\n                ExpressionText.class );\n\n        this.xt.alias( \"global\",\n                ExpressionGlobalVariable.class );\n        \n        this.xt.alias( \"variable\",\n                ExpressionVariable.class );\n        //end ExpressionFormLine\n    }","id":42174,"modified_method":"protected BRXMLPersistence() {\n        this.xt = new XStream( new DomDriver() );\n\n        this.xt.alias( \"rule\",\n                       RuleModel.class );\n        this.xt.alias( \"fact\",\n                       FactPattern.class );\n        this.xt.alias( \"retract\",\n                       ActionRetractFact.class );\n        this.xt.alias( \"assert\",\n                       ActionInsertFact.class );\n        this.xt.alias( \"modify\",\n                       ActionUpdateField.class );\n        this.xt.alias( \"setField\",\n                       ActionSetField.class );\n        this.xt.alias( \"dslSentence\",\n                       DSLSentence.class );\n        this.xt.alias( \"compositePattern\",\n                       CompositeFactPattern.class );\n        this.xt.alias( \"fromCompositePattern\",\n                       FromCompositeFactPattern.class );\n        this.xt.alias( \"fromCollectCompositePattern\",\n                       FromCollectCompositeFactPattern.class );\n        this.xt.alias( \"fromAccumulateCompositePattern\",\n                       FromAccumulateCompositeFactPattern.class );\n        this.xt.alias( \"metadata\",\n                       RuleMetadata.class );\n        this.xt.alias( \"attribute\",\n                       RuleAttribute.class );\n\n        this.xt.alias( \"fieldValue\",\n                       ActionFieldValue.class );\n        this.xt.alias( \"connectiveConstraint\",\n                       ConnectiveConstraint.class );\n        this.xt.alias( \"fieldConstraint\",\n                       SingleFieldConstraint.class );\n\n        this.xt.alias( \"compositeConstraint\",\n                       CompositeFieldConstraint.class );\n\n        this.xt.alias( \"assertLogical\",\n                       ActionInsertLogicalFact.class );\n        this.xt.alias( \"freeForm\",\n                       FreeFormLine.class );\n\n        this.xt.alias( \"addToGlobal\",\n                       ActionGlobalCollectionAdd.class );\n        //Begin ExpressionFormLine\n        this.xt.alias( \"expression\",\n                ExpressionFormLine.class );\n        \n        this.xt.alias( \"field\",\n                ExpressionField.class );\n        \n        this.xt.alias( \"method\",\n                ExpressionMethod.class );\n        \n        this.xt.alias( \"collection\",\n                ExpressionCollection.class );\n        \n        this.xt.alias( \"collectionIndex\",\n                ExpressionCollectionIndex.class );\n        \n        this.xt.alias( \"text\",\n                ExpressionText.class );\n\n        this.xt.alias( \"global\",\n                ExpressionGlobalVariable.class );\n        \n        this.xt.alias( \"variable\",\n                ExpressionVariable.class );\n        //end ExpressionFormLine\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Returns true if any DSLSentences are used.\n     */\n    public boolean hasDSLSentences() {\n\n        if (this.lhs != null) {\n            for (int i = 0; i < this.lhs.length; i++) {\n                if (lhs[i] instanceof DSLSentence) {\n                    return true;\n                }\n            }\n        }\n\n        if (this.rhs != null) {\n            for (int i = 0; i < this.rhs.length; i++) {\n                if (rhs[i] instanceof DSLSentence) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","id":42175,"modified_method":"/**\n     * Returns true if any DSLSentences are used.\n     */\n    public boolean hasDSLSentences() {\n\n        if (this.lhs != null) {\n            for (IPattern pattern : this.lhs) {\n                if (pattern instanceof DSLSentence) {\n                    return true;\n                }\n            }\n        }\n\n        if (this.rhs != null) {\n            for (IAction action : this.rhs) {\n                if (action instanceof DSLSentence) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Returns true of there is a field binding.\n     */\n    public boolean isBound() {\n        if ( this.fieldBinding != null && !\"\".equals( this.fieldBinding ) ) {\n            return true;\n        } else {\n            return false;\n        }\n    }","id":42176,"modified_method":"/**\n     * Returns true of there is a field binding.\n     */\n    public boolean isBound() {\n        return this.fieldBinding != null && this.fieldBinding.length() > 0 ;\n    }","commit_id":"897817095ac6931c4f2b27b2a29657ec1f0fa2e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void preprocessTemplate(final PsiFile file, int caretOffset, final String textToInsert) {\n    if (file.getLanguage().equals(StdLanguages.JSPX)) {\n      if (XmlUtil.toCode(textToInsert)) {\n        try {\n          caretOffset += JspSpiUtil.escapeCharsInJspContext((JspFile)file, caretOffset, myTemplate.getTemplateText());\n          PostprocessReformattingAspect.getInstance(myProject).doPostponedFormatting();\n          myEditor.getCaretModel().moveToOffset(caretOffset);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":42177,"modified_method":"private void preprocessTemplate(final PsiFile file, int caretOffset, final String textToInsert) {\n    if (file.getLanguage().equals(StdLanguages.JSPX) && file instanceof JspFile) {\n      if (XmlUtil.toCode(textToInsert)) {\n        try {\n          caretOffset += JspSpiUtil.escapeCharsInJspContext((JspFile)file, caretOffset, myTemplate.getTemplateText());\n          PostprocessReformattingAspect.getInstance(myProject).doPostponedFormatting();\n          myEditor.getCaretModel().moveToOffset(caretOffset);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void recalcSegment(int segmentNumber, boolean isQuick, Expression expressionNode, Expression defaultValue) {\n    String oldValue = getExpressionString(segmentNumber);\n    int start = mySegments.getSegmentStart(segmentNumber);\n    int end = mySegments.getSegmentEnd(segmentNumber);\n    ExpressionContext context = createExpressionContext(start);\n    Result result;\n    if (isQuick) {\n      result = expressionNode.calculateQuickResult(context);\n    }\n    else {\n      result = expressionNode.calculateResult(context);\n      if (expressionNode instanceof ConstantNode) {\n        if (result instanceof TextResult) {\n          TextResult text = (TextResult)result;\n          if (text.getText().equals(\"\") && defaultValue != null) {\n            result = defaultValue.calculateResult(context);\n          }\n        }\n      }\n      if (result == null && defaultValue != null) {\n        result = defaultValue.calculateResult(context);\n      }\n    }\n    if (result == null) return;\n\n    PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument);\n    PsiElement element = psiFile.findElementAt(start);\n    if (result.equalsToText(oldValue, element)) return;\n\n    String newValue = result.toString();\n    if (newValue == null) newValue = \"\";\n\n    if (element instanceof PsiJavaToken && ((PsiJavaToken)element).getTokenType() == JavaTokenType.STRING_LITERAL) {\n      newValue = StringUtil.escapeStringCharacters(newValue);\n    }\n\n    replaceString(newValue, start, end, segmentNumber);\n\n    if (result instanceof PsiTypeResult) {\n      shortenReferences();\n      PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n      updateTypeBindings(((PsiTypeResult)result).getType(), psiFile, segmentNumber);\n    }\n  }","id":42178,"modified_method":"private void recalcSegment(int segmentNumber, boolean isQuick, Expression expressionNode, Expression defaultValue) {\n    String oldValue = getExpressionString(segmentNumber);\n    int start = mySegments.getSegmentStart(segmentNumber);\n    int end = mySegments.getSegmentEnd(segmentNumber);\n    ExpressionContext context = createExpressionContext(start);\n    Result result;\n    if (isQuick) {\n      result = expressionNode.calculateQuickResult(context);\n    }\n    else {\n      result = expressionNode.calculateResult(context);\n      if (expressionNode instanceof ConstantNode) {\n        if (result instanceof TextResult) {\n          TextResult text = (TextResult)result;\n          if (text.getText().length() == 0 && defaultValue != null) {\n            result = defaultValue.calculateResult(context);\n          }\n        }\n      }\n      if (result == null && defaultValue != null) {\n        result = defaultValue.calculateResult(context);\n      }\n    }\n    if (result == null) return;\n\n    PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument);\n    PsiElement element = psiFile.findElementAt(start);\n    if (result.equalsToText(oldValue, element)) return;\n\n    String newValue = result.toString();\n    if (newValue == null) newValue = \"\";\n\n    if (element instanceof PsiJavaToken && ((PsiJavaToken)element).getTokenType() == JavaTokenType.STRING_LITERAL) {\n      newValue = StringUtil.escapeStringCharacters(newValue);\n    }\n\n    replaceString(newValue, start, end, segmentNumber);\n\n    if (result instanceof PsiTypeResult) {\n      shortenReferences();\n      PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n      updateTypeBindings(((PsiTypeResult)result).getType(), psiFile, segmentNumber);\n    }\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void start(TemplateImpl template) {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    UndoManager.getInstance(myProject).undoableActionPerformed(\n      new UndoableAction() {\n        public void undo() throws UnexpectedUndoException {\n          if (myDocument != null) {\n            fireTemplateCancelled();\n            //hack to close lookup if any: TODO lookup API for closing active lookup\n            final int segmentNumber = getCurrentSegmentNumber();\n            if (segmentNumber >= 0) {\n              int offsetToMove = myTemplate.getSegmentOffset(segmentNumber) - 1;\n              if (offsetToMove < 0) offsetToMove = myDocument.getTextLength();\n              final int oldOffset = myEditor.getCaretModel().getOffset();\n              myEditor.getCaretModel().moveToOffset(offsetToMove);\n              myEditor.getCaretModel().moveToOffset(oldOffset);\n            }\n            setCurrentVariableNumber(-1);\n          }\n        }\n\n        public void redo() throws UnexpectedUndoException {\n          //TODO:\n          // throw new UnexpectedUndoException(\"Not implemented\");\n        }\n\n        public DocumentReference[] getAffectedDocuments() {\n          if (myDocument == null) return new DocumentReference[0];\n          return new DocumentReference[]{DocumentReferenceByDocument.createDocumentReference(myDocument)};\n        }\n\n        public boolean isComplex() {\n          return false;\n        }\n      }\n    );\n    myTemplateIndented = false;\n    myCurrentVariableNumber = -1;\n    mySegments = new TemplateSegments(myEditor);\n    myTemplate = template;\n\n\n    if (template.isInline()) {\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      myTemplateRange = myDocument.createRangeMarker(caretOffset, caretOffset + template.getTemplateText().length());\n    }\n    else {\n      preprocessTemplate(PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument), myEditor.getCaretModel().getOffset(), myTemplate.getTemplateText());\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      myTemplateRange = myDocument.createRangeMarker(caretOffset, caretOffset);\n    }\n    myTemplateRange.setGreedyToLeft(true);\n    myTemplateRange.setGreedyToRight(true);\n\n    processAllExpressions(template);\n  }","id":42179,"modified_method":"public void start(TemplateImpl template) {\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    UndoManager.getInstance(myProject).undoableActionPerformed(\n      new UndoableAction() {\n        public void undo() {\n          if (myDocument != null) {\n            fireTemplateCancelled();\n            //hack to close lookup if any: TODO lookup API for closing active lookup\n            final int segmentNumber = getCurrentSegmentNumber();\n            if (segmentNumber >= 0) {\n              int offsetToMove = myTemplate.getSegmentOffset(segmentNumber) - 1;\n              if (offsetToMove < 0) offsetToMove = myDocument.getTextLength();\n              final int oldOffset = myEditor.getCaretModel().getOffset();\n              myEditor.getCaretModel().moveToOffset(offsetToMove);\n              myEditor.getCaretModel().moveToOffset(oldOffset);\n            }\n            setCurrentVariableNumber(-1);\n          }\n        }\n\n        public void redo() {\n          //TODO:\n          // throw new UnexpectedUndoException(\"Not implemented\");\n        }\n\n        public DocumentReference[] getAffectedDocuments() {\n          if (myDocument == null) return new DocumentReference[0];\n          return new DocumentReference[]{DocumentReferenceByDocument.createDocumentReference(myDocument)};\n        }\n\n        public boolean isComplex() {\n          return false;\n        }\n      }\n    );\n    myTemplateIndented = false;\n    myCurrentVariableNumber = -1;\n    mySegments = new TemplateSegments(myEditor);\n    myTemplate = template;\n\n\n    if (template.isInline()) {\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      myTemplateRange = myDocument.createRangeMarker(caretOffset, caretOffset + template.getTemplateText().length());\n    }\n    else {\n      preprocessTemplate(PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument), myEditor.getCaretModel().getOffset(), myTemplate.getTemplateText());\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      myTemplateRange = myDocument.createRangeMarker(caretOffset, caretOffset);\n    }\n    myTemplateRange.setGreedyToLeft(true);\n    myTemplateRange.setGreedyToRight(true);\n\n    processAllExpressions(template);\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reformat() {\n    final PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument);\n    if (file != null) {\n      CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myProject);\n      if (myTemplate.isToShortenLongNames()) {\n        try {\n          PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n          codeStyleManager.shortenClassReferences(file, myTemplateRange.getStartOffset(), myTemplateRange.getEndOffset());\n          unblockDocument();\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      if (myTemplate.isToReformat()) {\n        try {\n          int endSegmentNumber = myTemplate.getEndSegmentNumber();\n          PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n          PsiElement marker;\n          RangeMarker rangeMarker = null;\n          if (endSegmentNumber >= 0) {\n            int endVarOffset = mySegments.getSegmentStart(endSegmentNumber);\n            marker = codeStyleManager.insertNewLineIndentMarker(file, endVarOffset);\n            if(marker != null) rangeMarker = myDocument.createRangeMarker(marker.getTextRange());\n          }\n          codeStyleManager.reformatText(file, myTemplateRange.getStartOffset(), myTemplateRange.getEndOffset());\n          PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n\n          if (rangeMarker != null && rangeMarker.isValid()) {\n            //[ven] TODO: [max] correct javadoc reformatting to eliminate isValid() check!!!\n            mySegments.replaceSegmentAt(endSegmentNumber, rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n            myDocument.deleteString(rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      else if (myTemplate.isToIndent()) {\n        if (!myTemplateIndented) {\n          smartIndent(myTemplateRange.getStartOffset(), myTemplateRange.getEndOffset());\n          myTemplateIndented = true;\n        }\n      }\n    }\n  }","id":42180,"modified_method":"private void reformat() {\n    final PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument);\n    if (file != null) {\n      CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myProject);\n      if (myTemplate.isToShortenLongNames()) {\n        try {\n          PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n          codeStyleManager.shortenClassReferences(file, myTemplateRange.getStartOffset(), myTemplateRange.getEndOffset());\n          unblockDocument();\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      if (myTemplate.isToReformat()) {\n        try {\n          int endSegmentNumber = myTemplate.getEndSegmentNumber();\n          PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n          RangeMarker rangeMarker = null;\n          if (endSegmentNumber >= 0) {\n            int endVarOffset = mySegments.getSegmentStart(endSegmentNumber);\n            PsiElement marker = codeStyleManager.insertNewLineIndentMarker(file, endVarOffset);\n            if(marker != null) rangeMarker = myDocument.createRangeMarker(marker.getTextRange());\n          }\n          codeStyleManager.reformatText(file, myTemplateRange.getStartOffset(), myTemplateRange.getEndOffset());\n          PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n\n          if (rangeMarker != null && rangeMarker.isValid()) {\n            //[ven] TODO: [max] correct javadoc reformatting to eliminate isValid() check!!!\n            mySegments.replaceSegmentAt(endSegmentNumber, rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n            myDocument.deleteString(rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      else if (myTemplate.isToIndent()) {\n        if (!myTemplateIndented) {\n          smartIndent(myTemplateRange.getStartOffset(), myTemplateRange.getEndOffset());\n          myTemplateIndented = true;\n        }\n      }\n    }\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateTypeBindings(Object item, PsiFile file, final int segmentNumber) {\n    PsiClass aClass = null;\n    if (item instanceof PsiClass) {\n      aClass = (PsiClass)item;\n    }\n    else if (item instanceof PsiType) {\n      aClass = PsiUtil.resolveClassInType(((PsiType)item));\n    }\n\n    if (aClass != null) {\n      if (aClass instanceof PsiTypeParameter) {\n        if (((PsiTypeParameter)aClass).getOwner() instanceof PsiMethod) {\n          PsiElement element = file.findElementAt(mySegments.getSegmentStart(segmentNumber));\n          PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n          if (method != null) {\n            PsiTypeParameterList paramList = method.getTypeParameterList();\n            PsiTypeParameter[] params = paramList.getTypeParameters();\n            for (PsiTypeParameter param : params) {\n              if (param.getName().equals(aClass.getName())) return;\n            }\n            try {\n              paramList.add(aClass.copy());\n              unblockDocument();\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n          }\n        }\n      }  else {\n        addImportForClass(aClass, segmentNumber);\n        unblockDocument();\n      }\n    }\n  }","id":42181,"modified_method":"private void updateTypeBindings(Object item, PsiFile file, final int segmentNumber) {\n    PsiClass aClass = null;\n    if (item instanceof PsiClass) {\n      aClass = (PsiClass)item;\n    }\n    else if (item instanceof PsiType) {\n      aClass = PsiUtil.resolveClassInType((PsiType)item);\n    }\n\n    if (aClass != null) {\n      if (aClass instanceof PsiTypeParameter) {\n        if (((PsiTypeParameter)aClass).getOwner() instanceof PsiMethod) {\n          PsiElement element = file.findElementAt(mySegments.getSegmentStart(segmentNumber));\n          PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n          if (method != null) {\n            PsiTypeParameterList paramList = method.getTypeParameterList();\n            PsiTypeParameter[] params = paramList.getTypeParameters();\n            for (PsiTypeParameter param : params) {\n              if (param.getName().equals(aClass.getName())) return;\n            }\n            try {\n              paramList.add(aClass.copy());\n              unblockDocument();\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n          }\n        }\n      }  else {\n        addImportForClass(aClass, segmentNumber);\n        unblockDocument();\n      }\n    }\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void smartIndent(int startOffset, int endOffset) {\n    int startLineNum = myDocument.getLineNumber(startOffset);\n    int endLineNum = myDocument.getLineNumber(endOffset);\n    if (endLineNum == startLineNum) {\n      return;\n    }\n\n    int indentLineNum = startLineNum;\n\n    int lineLength = 0;\n    for (; indentLineNum >= 0; indentLineNum--) {\n      lineLength = myDocument.getLineEndOffset(indentLineNum) - myDocument.getLineStartOffset(indentLineNum);\n      if (lineLength > 0) {\n        break;\n      }\n    }\n    if (indentLineNum < 0) {\n      return;\n    }\n    StringBuffer buffer = new StringBuffer();\n    CharSequence text = myDocument.getCharsSequence();\n    for (int i = 0; i < lineLength; i++) {\n      char ch = text.charAt(myDocument.getLineStartOffset(indentLineNum) + i);\n      if (ch != ' ' && ch != '\\t') {\n        break;\n      }\n      buffer.append(ch);\n    }\n    if (buffer.length() == 0) {\n      return;\n    }\n    String stringToInsert = buffer.toString();\n    for (int i = startLineNum + 1; i <= endLineNum; i++) {\n      myDocument.insertString(myDocument.getLineStartOffset(i), stringToInsert);\n    }\n  }","id":42182,"modified_method":"private void smartIndent(int startOffset, int endOffset) {\n    int startLineNum = myDocument.getLineNumber(startOffset);\n    int endLineNum = myDocument.getLineNumber(endOffset);\n    if (endLineNum == startLineNum) {\n      return;\n    }\n\n    int indentLineNum = startLineNum;\n\n    int lineLength = 0;\n    for (; indentLineNum >= 0; indentLineNum--) {\n      lineLength = myDocument.getLineEndOffset(indentLineNum) - myDocument.getLineStartOffset(indentLineNum);\n      if (lineLength > 0) {\n        break;\n      }\n    }\n    if (indentLineNum < 0) {\n      return;\n    }\n    StringBuilder buffer = new StringBuilder();\n    CharSequence text = myDocument.getCharsSequence();\n    for (int i = 0; i < lineLength; i++) {\n      char ch = text.charAt(myDocument.getLineStartOffset(indentLineNum) + i);\n      if (ch != ' ' && ch != '\\t') {\n        break;\n      }\n      buffer.append(ch);\n    }\n    if (buffer.length() == 0) {\n      return;\n    }\n    String stringToInsert = buffer.toString();\n    for (int i = startLineNum + 1; i <= endLineNum; i++) {\n      myDocument.insertString(myDocument.getLineStartOffset(i), stringToInsert);\n    }\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void focusCurrentExpression() {\n    if (isFinished()) {\n      return;\n    }\n\n    PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n\n    final int currentSegmentNumber = getCurrentSegmentNumber();\n    if (currentSegmentNumber < 0) return;\n    final int start = mySegments.getSegmentStart(currentSegmentNumber);\n    final int end = mySegments.getSegmentEnd(currentSegmentNumber);\n    myEditor.getCaretModel().moveToOffset(end);\n    myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    myEditor.getSelectionModel().removeSelection();\n\n\n    myEditor.getSelectionModel().setSelection(start, end);\n    Expression expressionNode = myTemplate.getExpressionAt(myCurrentVariableNumber);\n\n    final ExpressionContext context = createExpressionContext(start);\n    final LookupItem[] lookupItems = expressionNode.calculateLookupItems(context);\n    final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument);\n    if (lookupItems != null && lookupItems.length > 0) {\n      final LookupItemPreferencePolicy preferencePolicy = new LookupItemPreferencePolicy() {\n        public int compare(LookupItem i1, LookupItem i2) {\n          if (i1.equals(i2)) return 0;\n          if (i1.equals(lookupItems[0])) return -1;\n          if (i2.equals(lookupItems[0])) return +1;\n          return 0;\n        }\n\n        public void setPrefix(String prefix) {\n        }\n\n        public void itemSelected(LookupItem item) {\n        }\n      };\n\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          if (myEditor == null) return;\n\n          final LookupManager lookupManager = LookupManager.getInstance(myProject);\n          if (lookupManager.isDisposed()) return;\n          final Lookup lookup = lookupManager.showLookup(myEditor, lookupItems, \"\", preferencePolicy,\n                                                         new DefaultCharFilter(myEditor, psiFile, end));\n          lookup\n            .setCurrentItem(\n              lookupItems[0]); // [Valentin] not absolutely correct but all existing macros return the first item as the result\n          toProcessTab = false;\n          lookup.addLookupListener(\n            new LookupAdapter() {\n              public void lookupCanceled(LookupEvent event) {\n                lookup.removeLookupListener(this);\n                toProcessTab = true;\n              }\n\n              public void itemSelected(LookupEvent event) {\n                lookup.removeLookupListener(this);\n                if (isFinished()) return;\n                toProcessTab = true;\n\n                final LookupItem item = event.getItem();\n\n                if (item != null) {\n                  PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n                  Integer bracketCount = (Integer)item.getAttribute(LookupItem.BRACKETS_COUNT_ATTR);\n                  if (bracketCount != null) {\n                    StringBuffer tail = new StringBuffer();\n                    for (int i = 0; i < bracketCount.intValue(); i++) {\n                      tail.append(\"[]\");\n                    }\n                    EditorModificationUtil.insertStringAtCaret(myEditor, tail.toString());\n                    PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n                  }\n\n                  updateTypeBindings(item.getObject(), psiFile, currentSegmentNumber);\n\n                  char c = event.getCompletionChar();\n                  if (c == '.') {\n                    EditorModificationUtil.insertStringAtCaret(myEditor, \".\");\n                    AutoPopupController.getInstance(myProject).autoPopupMemberLookup(myEditor);\n                    return;\n                  }\n\n                  if (item.getAttribute(Expression.AUTO_POPUP_NEXT_LOOKUP) != null) {\n                    AutoPopupController.getInstance(myProject).autoPopupMemberLookup(myEditor);\n                    return;\n                  }\n\n                  if (!isFinished()) {\n                    calcResults(true);\n                  }\n                }\n\n                nextTab();\n              }\n            }\n          );\n        }\n      });\n    }\n    else {\n      Result result = expressionNode.calculateResult(context);\n      if (result instanceof PsiElementResult) {\n        updateTypeBindings(((PsiElementResult)result).getElement(), psiFile, currentSegmentNumber);\n      }\n      if (result instanceof PsiTypeResult) {\n        updateTypeBindings(((PsiTypeResult)result).getType(), psiFile, currentSegmentNumber);\n      }\n      if (result instanceof InvokeActionResult) {\n        ((InvokeActionResult)result).getAction().run();\n      }\n    }\n    focusCurrentHighlighter(true);\n  }","id":42183,"modified_method":"private void focusCurrentExpression() {\n    if (isFinished()) {\n      return;\n    }\n\n    PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n\n    final int currentSegmentNumber = getCurrentSegmentNumber();\n    if (currentSegmentNumber < 0) return;\n    final int start = mySegments.getSegmentStart(currentSegmentNumber);\n    final int end = mySegments.getSegmentEnd(currentSegmentNumber);\n    myEditor.getCaretModel().moveToOffset(end);\n    myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    myEditor.getSelectionModel().removeSelection();\n\n\n    myEditor.getSelectionModel().setSelection(start, end);\n    Expression expressionNode = myTemplate.getExpressionAt(myCurrentVariableNumber);\n\n    final ExpressionContext context = createExpressionContext(start);\n    final LookupItem[] lookupItems = expressionNode.calculateLookupItems(context);\n    final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myDocument);\n    if (lookupItems != null && lookupItems.length > 0) {\n      final LookupItemPreferencePolicy preferencePolicy = new LookupItemPreferencePolicy() {\n        public int compare(LookupItem i1, LookupItem i2) {\n          if (i1.equals(i2)) return 0;\n          if (i1.equals(lookupItems[0])) return -1;\n          if (i2.equals(lookupItems[0])) return +1;\n          return 0;\n        }\n\n        public void setPrefix(String prefix) {\n        }\n\n        public void itemSelected(LookupItem item) {\n        }\n      };\n\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          if (myEditor == null) return;\n\n          final LookupManager lookupManager = LookupManager.getInstance(myProject);\n          if (lookupManager.isDisposed()) return;\n          final Lookup lookup = lookupManager.showLookup(myEditor, lookupItems, \"\", preferencePolicy,\n                                                         new DefaultCharFilter(myEditor, psiFile, end));\n          lookup\n            .setCurrentItem(\n              lookupItems[0]); // [Valentin] not absolutely correct but all existing macros return the first item as the result\n          toProcessTab = false;\n          lookup.addLookupListener(\n            new LookupAdapter() {\n              public void lookupCanceled(LookupEvent event) {\n                lookup.removeLookupListener(this);\n                toProcessTab = true;\n              }\n\n              public void itemSelected(LookupEvent event) {\n                lookup.removeLookupListener(this);\n                if (isFinished()) return;\n                toProcessTab = true;\n\n                final LookupItem item = event.getItem();\n\n                if (item != null) {\n                  PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n                  Integer bracketCount = (Integer)item.getAttribute(LookupItem.BRACKETS_COUNT_ATTR);\n                  if (bracketCount != null) {\n                    StringBuilder tail = new StringBuilder();\n                    for (int i = 0; i < bracketCount.intValue(); i++) {\n                      tail.append(\"[]\");\n                    }\n                    EditorModificationUtil.insertStringAtCaret(myEditor, tail.toString());\n                    PsiDocumentManager.getInstance(myProject).commitDocument(myDocument);\n                  }\n\n                  updateTypeBindings(item.getObject(), psiFile, currentSegmentNumber);\n\n                  char c = event.getCompletionChar();\n                  if (c == '.') {\n                    EditorModificationUtil.insertStringAtCaret(myEditor, \".\");\n                    AutoPopupController.getInstance(myProject).autoPopupMemberLookup(myEditor);\n                    return;\n                  }\n\n                  if (item.getAttribute(Expression.AUTO_POPUP_NEXT_LOOKUP) != null) {\n                    AutoPopupController.getInstance(myProject).autoPopupMemberLookup(myEditor);\n                    return;\n                  }\n\n                  if (!isFinished()) {\n                    calcResults(true);\n                  }\n                }\n\n                nextTab();\n              }\n            }\n          );\n        }\n      });\n    }\n    else {\n      Result result = expressionNode.calculateResult(context);\n      if (result instanceof PsiElementResult) {\n        updateTypeBindings(((PsiElementResult)result).getElement(), psiFile, currentSegmentNumber);\n      }\n      if (result instanceof PsiTypeResult) {\n        updateTypeBindings(((PsiTypeResult)result).getType(), psiFile, currentSegmentNumber);\n      }\n      if (result instanceof InvokeActionResult) {\n        ((InvokeActionResult)result).getAction().run();\n      }\n    }\n    focusCurrentHighlighter(true);\n  }","commit_id":"d8cb526d50bc6e4cea7e361da8a252d6bc354f3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n   * Returns a formatted integer.\r\n   * @param ctx query context\r\n   * @return string\r\n   * @throws QueryException query exception\r\n   */\r\n  private Str formatInteger(final QueryContext ctx) throws QueryException {\r\n    final String pic = string(checkEStr(expr[1], ctx));\r\n    if(expr[0].empty()) return Str.ZERO;\r\n\r\n    final byte[] lang = expr.length == 2 ? EMPTY : checkEStr(expr[2], ctx);\r\n    final long num = checkItr(expr[0], ctx);\r\n\r\n    return Str.get(IntFormatter.format(num, pic, string(lang)));\r\n  }","id":42184,"modified_method":"/**\r\n   * Returns a formatted integer.\r\n   * @param ctx query context\r\n   * @return string\r\n   * @throws QueryException query exception\r\n   */\r\n  private Str formatInteger(final QueryContext ctx) throws QueryException {\r\n    final String pic = string(checkEStr(expr[1], ctx));\r\n    if(pic.length() == 0) WRONGINT.thrw(input, pic);\r\n    if(expr[0].empty()) return Str.ZERO;\r\n\r\n    final byte[] lang = expr.length == 2 ? EMPTY : checkEStr(expr[2], ctx);\r\n    final long num = checkItr(expr[0], ctx);\r\n    final byte[] str = IntFormatter.format(num, pic, string(lang));\r\n    if(str == null) PICDATE.thrw(input, pic);\r\n    return Str.get(str);\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Parses a decimal-digit-pattern.\r\n   * @param in input\r\n   * @return end position, or {@code -1} for error\r\n   */\r\n  private int decimal(final String in) {\r\n    int s = -1;\r\n    final int l = in.length();\r\n    boolean d = false;\r\n    boolean g = false;\r\n    while(++s < l) {\r\n      final int ch = cp(in, s);\r\n      if(Character.isLetter(ch)) break;\r\n\r\n      if(ch == '#') {\r\n        // optional after decimal sign\r\n        if(d) return -1;\r\n        g = false;\r\n      } else if(ch == '*') {\r\n        g = false;\r\n      } else if(digit(ch)) {\r\n        d = true;\r\n        g = false;\r\n      } else {\r\n        // adjacent grouping separators\r\n        if(g) return -1;\r\n        g = true;\r\n      }\r\n    }\r\n    // no decimal, or ending with grouping separator\r\n    if(!d || g) return -1;\r\n    return s;\r\n  }","id":42185,"modified_method":"/**\r\n   * Parses a decimal-digit-pattern.\r\n   * @param in input\r\n   * @param ba base char\r\n   * @return end position, or {@code -1} for error\r\n   */\r\n  private int decimal(final String in, final int ba) {\r\n    int s = -1;\r\n    final int l = in.length();\r\n    boolean d = false;\r\n    boolean g = false;\r\n    while(++s < l) {\r\n      final int ch = cp(in, s);\r\n      if(Character.isLetter(ch)) break;\r\n\r\n      if(ch == '#') {\r\n        // optional after decimal sign\r\n        if(d) return -1;\r\n        g = false;\r\n      } else if(ch == '*') {\r\n        g = false;\r\n      } else if(ch >= ba && ch <= ba + 9) {\r\n        d = true;\r\n        g = false;\r\n      } else {\r\n        // adjacent grouping separators\r\n        if(g) return -1;\r\n        g = true;\r\n      }\r\n    }\r\n    // no decimal, or ending with grouping separator\r\n    if(!d || g) return -1;\r\n    return s;\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor, parsing the input string. The {@link #error} variable is\r\n   * set to true if the input is invalid.\r\n   * @param in marker input\r\n   * @param p (valid) presentation modifier\r\n   * @param ext extended flag, allowing width modifier\r\n   */\r\n  FormatParser(final String in, final String p, final boolean ext) {\r\n    // no marker specified - use default settings\r\n    String pm = p;\r\n\r\n    final int l = in.length();\r\n    int s = -1;\r\n\r\n    // find presentation modifier\r\n    if(l != 0) {\r\n      final int ch = cp(in, 0);\r\n      final int cu = ch & 0xDF;\r\n      if(cu == 'A' || cu == 'I') {\r\n        s = 1;\r\n      } else if(cu == 'W' || cu == 'N') {\r\n        s = cp(in, 1) == (ch | 0x20) ? 2 : 1;\r\n      } else if(digit(ch) || ch == '#') {\r\n        s = decimal(in);\r\n        // invalid decimal parsing\r\n        error = s == -1;\r\n      }\r\n      if(s != -1) pm = in.substring(0, s);\r\n    }\r\n    if(s == -1) s = l;\r\n\r\n    // find format modifier\r\n    if(s < l) {\r\n      if(cp(in, s) == 'o') {\r\n        final StringBuilder sb = new StringBuilder();\r\n        if(cp(in, ++s) == '(') {\r\n          while(cp(in, ++s) != ')') {\r\n            // ordinal isn't closed by a parenthesis\r\n            error = s == l;\r\n            if(error) break;\r\n            sb.append(cp(in, s));\r\n          }\r\n        }\r\n        ord = sb.toString();\r\n      }\r\n    }\r\n\r\n    // find remaining modifier\r\n    if(s < l) {\r\n      if(cp(in, s) == ',') {\r\n        pm += in.substring(s);\r\n      } else {\r\n        // invalid remaining input\r\n        error = true;\r\n      }\r\n    }\r\n\r\n    if(ext) {\r\n      // extract and check width modifier\r\n      final int w = pm.lastIndexOf(',');\r\n      if(w != -1) {\r\n        final String wd = pm.substring(w + 1);\r\n        pm = pm.substring(0, w);\r\n\r\n        final Matcher match = WIDTH.matcher(wd);\r\n        if(match.find()) {\r\n          int m = toInt(match.group(1));\r\n          if(m != Integer.MIN_VALUE) min = m;\r\n          final String mc = match.group(3);\r\n          m = mc != null ? toInt(mc) : Integer.MIN_VALUE;\r\n          if(m != Integer.MIN_VALUE) max = m;\r\n        } else {\r\n          error = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // choose first character and case\r\n    cs = pm.length() > 1 ? Case.STANDARD :\r\n      (cp(pm, 0) & 0x20) != 0 ? Case.LOWER : Case.UPPER;\r\n    pres = pm.toLowerCase();\r\n  }","id":42186,"modified_method":"/**\r\n   * Constructor, parsing the input string. The {@link #error} variable is\r\n   * set to true if the input is invalid.\r\n   * @param in marker input\r\n   * @param p (valid) presentation modifier\r\n   * @param ext extended flag, allowing width modifier\r\n   */\r\n  public FormatParser(final String in, final String p, final boolean ext) {\r\n    // no marker specified - use default settings\r\n    String pm = p;\r\n\r\n    final int l = in.length();\r\n    int s = -1;\r\n\r\n    // find presentation modifier\r\n    if(l != 0) {\r\n      final int ch = cp(in, 0);\r\n      final int cu = ch & 0xFFFFFFDF;\r\n      if(cu == 'A' || cu == 'I' || cu == '\\u0391') {\r\n        s = 1;\r\n      } else if(cu == 'W' || cu == 'N') {\r\n        s = cp(in, 1) == (ch | 0x20) ? 2 : 1;\r\n      } else if(ch >= '\\u2460' && ch <= '\\u249b') {\r\n        s = 1;\r\n      } else if(ch == '#' || (ch >= '0' && ch <= '9') ||\r\n          (ch >= '\\u0660' && ch <= '\\u0669')) {\r\n        s = decimal(in, ch & 0xFFFFFFF0);\r\n        // invalid decimal parsing\r\n        error = s == -1;\r\n      } else {\r\n        error = true;\r\n      }\r\n      if(s != -1) pm = in.substring(0, s);\r\n    }\r\n    if(s == -1) s = l;\r\n\r\n    // find format modifier\r\n    if(s < l) {\r\n      if(cp(in, s) == 'o') {\r\n        final StringBuilder sb = new StringBuilder();\r\n        if(cp(in, ++s) == '(') {\r\n          while(cp(in, ++s) != ')') {\r\n            // ordinal isn't closed by a parenthesis\r\n            error = s == l;\r\n            if(error) break;\r\n            sb.append((char) cp(in, s));\r\n          }\r\n          ++s;\r\n        }\r\n        ord = sb.toString();\r\n      } else if(cp(in, s) == 't') {\r\n        // traditional numbering (ignored)\r\n        ++s;\r\n      }\r\n    }\r\n\r\n    // find remaining modifier\r\n    if(s < l) {\r\n      System.out.println(s + \"/\" + l + \": \" + in);\r\n      if(cp(in, s) == ',') {\r\n        pm += in.substring(s);\r\n      } else {\r\n        // invalid remaining input\r\n        error = true;\r\n      }\r\n    }\r\n\r\n    if(ext) {\r\n      // extract and check width modifier\r\n      final int w = pm.lastIndexOf(',');\r\n      if(w != -1) {\r\n        final String wd = pm.substring(w + 1);\r\n        pm = pm.substring(0, w);\r\n\r\n        final Matcher match = WIDTH.matcher(wd);\r\n        if(match.find()) {\r\n          int m = toInt(match.group(1));\r\n          if(m != Integer.MIN_VALUE) min = m;\r\n          final String mc = match.group(3);\r\n          m = mc != null ? toInt(mc) : Integer.MIN_VALUE;\r\n          if(m != Integer.MIN_VALUE) max = m;\r\n        } else {\r\n          error = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // choose first character and case\r\n    cs = pm.length() > 1 ? Case.STANDARD :\r\n      (cp(pm, 0) & 0x20) != 0 ? Case.LOWER : Case.UPPER;\r\n    pres = pm.toLowerCase();\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a formatted number.\r\n   * @param number number to be formatted\r\n   * @param mp marker parser\r\n   * @param form formatter\r\n   * @return string representation\r\n   */\r\n  public static byte[] format(final long number, final FormatParser mp,\r\n      final Formatter form) {\r\n\r\n    // choose sign\r\n    long num = number;\r\n    final boolean sign = num < 0;\r\n    if(sign) num = -num;\r\n\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    if(mp.pres.equals(\"a\")) {\r\n      latin(tb, num);\r\n    } else if(mp.pres.equals(\"i\")) {\r\n      roman(tb, num);\r\n    } else if(mp.pres.startsWith(\"w\")) {\r\n      tb.add(form.word(num, mp.ord));\r\n    } else if(digit(cp(mp.pres, 0)) || cp(mp.pres, 0) == '#') {\r\n      number(tb, num, mp, form);\r\n    }\r\n\r\n    // finalize formatted string\r\n    byte[] in = tb.finish();\r\n    if(mp.cs == Case.LOWER) in = lc(in);\r\n    if(mp.cs == Case.UPPER) in = uc(in);\r\n    return sign ? concat(new byte[] { '-' }, in) : in;\r\n  }","id":42187,"modified_method":"/**\r\n   * Returns a formatted number.\r\n   * @param number number to be formatted\r\n   * @param mp marker parser\r\n   * @param form formatter\r\n   * @return string representation\r\n   */\r\n  public static byte[] format(final long number, final FormatParser mp,\r\n      final Formatter form) {\r\n\r\n    // choose sign\r\n    long num = number;\r\n    final boolean sign = num < 0;\r\n    if(sign) num = -num;\r\n\r\n    final TokenBuilder tb = new TokenBuilder();\r\n    final int ch = cp(mp.pres, 0);\r\n    final boolean single = mp.pres.length() == 1;\r\n    if(ch == 'a' && single) {\r\n      alpha(tb, num, 'a', 26);\r\n    } else if(ch == '\\u03b1' && single) {\r\n      alpha(tb, num, '\\u03b1', 25);\r\n    } else if(ch == 'i' && single) {\r\n      roman(tb, num);\r\n    } else if(ch == 'w') {\r\n      tb.add(form.word(num, mp.ord));\r\n    } else if(ch >= '\\u2460' && ch <= '\\u249b') {\r\n      tb.add((char) (ch + number - 1));\r\n    } else if(ch == '#' || (ch >= '0' && ch <= '9') ||\r\n        (ch >= '\\u0660' && ch <= '\\u0669')) {\r\n      number(tb, num, mp, form, ch & 0xFFFFFFF0);\r\n    }\r\n\r\n    // finalize formatted string\r\n    byte[] in = tb.finish();\r\n    if(mp.cs == Case.LOWER) in = lc(in);\r\n    if(mp.cs == Case.UPPER) in = uc(in);\r\n    return sign ? concat(new byte[] { '-' }, in) : in;\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a formatted number.\r\n   * @param number number to be formatted\r\n   * @param picture picture\r\n   * @param lang language\r\n   * @return string representation\r\n   */\r\n  public static byte[] format(final long number, final String picture,\r\n      final String lang) {\r\n\r\n    final Formatter form = Formatter.get(lang);\r\n    return format(number, new FormatParser(picture, \"1\", false), form);\r\n  }","id":42188,"modified_method":"/**\r\n   * Returns a formatted number.\r\n   * @param number number to be formatted\r\n   * @param picture picture\r\n   * @param lang language\r\n   * @return string representation\r\n   */\r\n  public static byte[] format(final long number, final String picture,\r\n      final String lang) {\r\n\r\n    final Formatter form = Formatter.get(lang);\r\n    final FormatParser fp = new FormatParser(picture, \"1\", false);\r\n    return fp.error ? null : format(number, fp, form);\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a Latin character sequence.\r\n   * @param tb token builder\r\n   * @param n number to be formatted\r\n   */\r\n  private static void latin(final TokenBuilder tb, final long n) {\r\n    if(n > 26) latin(tb, (n - 1) / 26);\r\n    tb.add((char) ('A' + (n - 1) % 26));\r\n  }","id":42189,"modified_method":"/**\r\n   * Returns a Latin character sequence.\r\n   * @param tb token builder\r\n   * @param n number to be formatted\r\n   * @param f start character\r\n   * @param s alphabet size\r\n   */\r\n  private static void alpha(final TokenBuilder tb, final long n,\r\n      final int f, final int s) {\r\n    if(n > s) alpha(tb, (n - 1) / s, f, s);\r\n    tb.add((char) (f + (n - 1) % s));\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns a number character sequence.\r\n   * @param tb token builder\r\n   * @param n number to be formatted\r\n   * @param mp marker parser\r\n   * @param form language-dependent formatter\r\n   */\r\n  private static void number(final TokenBuilder tb, final long n,\r\n      final FormatParser mp, final Formatter form) {\r\n\r\n    // count optional-digit-signs\r\n    final String pres = mp.pres;\r\n    int o = 0;\r\n    for(int i = 0; i < pres.length(); ++i) {\r\n      if(pres.charAt(i) == '#') ++o;\r\n    }\r\n    // count digits\r\n    int d = 0;\r\n    for(int i = 0; i < pres.length(); ++i) {\r\n      if(digit(pres.charAt(i))) ++d;\r\n    }\r\n\r\n    // create string representation\r\n    final String str = Long.toString(n);\r\n\r\n    // build string\r\n    final StringBuilder tmp = new StringBuilder();\r\n    final int r = o + d - str.length();\r\n    for(int i = r; i > o; i--) tmp.append('0');\r\n    tmp.append(str);\r\n\r\n    for(int p = pres.length() - 1, t = tmp.length() - 1; p >= 0 && t >= 0;\r\n        p--, t--) {\r\n      final char ch = pres.charAt(p);\r\n      if(!digit(ch) && ch != '#') tmp.insert(t, ch);\r\n    }\r\n\r\n    // add ordinal suffix\r\n    tb.add(tmp.toString()).add(form.ordinal(n, mp.ord));\r\n  }","id":42190,"modified_method":"/**\r\n   * Returns a number character sequence.\r\n   * @param tb token builder\r\n   * @param n number to be formatted\r\n   * @param mp marker parser\r\n   * @param form language-dependent formatter\r\n   * @param start start character\r\n   */\r\n  private static void number(final TokenBuilder tb, final long n,\r\n      final FormatParser mp, final Formatter form, final int start) {\r\n\r\n    // count optional-digit-signs\r\n    final String pres = mp.pres;\r\n    int o = 0;\r\n    for(int i = 0; i < pres.length(); ++i) {\r\n      if(pres.charAt(i) == '#') ++o;\r\n    }\r\n    // count digits\r\n    int d = 0;\r\n    for(int i = 0; i < pres.length(); ++i) {\r\n      final char ch = pres.charAt(i);\r\n      if(ch >= start && ch <= start + 9) ++d;\r\n    }\r\n    \r\n    // create string representation and build string\r\n    final String s = Long.toString(n);\r\n    final StringBuilder tmp = new StringBuilder();\r\n    final int r = o + d - s.length();\r\n    for(int i = r; i > o; i--) tmp.append((char) start);\r\n    for(int i = 0; i < s.length(); i++) {\r\n      tmp.append((char) (s.charAt(i) - '0' + start));\r\n    }\r\n\r\n    for(int p = pres.length() - 1, t = tmp.length() - 1; p >= 0 && t >= 0;\r\n        p--, t--) {\r\n      final char ch = pres.charAt(p);\r\n      if(ch < start && ch > start + 9 && ch != '#') tmp.insert(t, ch);\r\n    }\r\n\r\n    // add ordinal suffix\r\n    tb.add(tmp.toString()).add(form.ordinal(n, mp.ord));\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Binds an object to a global variable. If the object is an {@link Expr}\r\n   * instance, it is directly assigned. Otherwise, it is first cast to the\r\n   * appropriate XQuery type.\r\n   * @param n name of variable\r\n   * @param o object to be bound\r\n   * @throws QueryException query exception\r\n   */\r\n  public void bind(final String n, final Object o) throws QueryException {\r\n    final Expr ex = o instanceof Expr ? (Expr) o : FunJava.type(o).e(o, null);\r\n    Var var = new Var(new QNm(Token.token(n))).bind(ex, ctx);\r\n    final Var gl = ctx.vars.global().get(var);\r\n    if(gl != null && gl.type != null) {\r\n      gl.bind(gl.type.type.e(var.item(ctx, null), ctx, null), ctx);\r\n      var = gl;\r\n    }\r\n    ctx.vars.setGlobal(var);\r\n  }","id":42191,"modified_method":"/**\r\n   * Binds an object to a global variable. If the object is an {@link Expr}\r\n   * instance, it is directly assigned. Otherwise, it is first cast to the\r\n   * appropriate XQuery type.\r\n   * @param n name of variable\r\n   * @param o object to be bound\r\n   * @throws QueryException query exception\r\n   */\r\n  public void bind(final String n, final Object o) throws QueryException {\r\n    // convert java to xquery type\r\n    final Expr ex = o instanceof Expr ? (Expr) o : FunJava.type(o).e(o, null);\r\n    // remove optional $ prefix\r\n    final byte[] nm = Token.token(n.replaceAll(\"^\\\\$\", \"\"));\r\n    Var var = new Var(new QNm(nm)).bind(ex, ctx);\r\n    final Var gl = ctx.vars.global().get(var);\r\n    if(gl != null && gl.type != null) {\r\n      gl.bind(gl.type.type.e(var.item(ctx, null), ctx, null), ctx);\r\n      var = gl;\r\n    }\r\n    ctx.vars.setGlobal(var);\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Tests the specified instance.\r\n   * @throws BaseXException database exception\r\n   */\r\n  @Test\r\n  public void test() throws BaseXException {\r\n    final String file = doc.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n    final String name = Util.name(this);\r\n    final boolean up = this instanceof XQUPTest;\r\n    new CreateDB(name, file).execute(context);\r\n\r\n    final StringBuilder sb = new StringBuilder();\r\n    int fail = 0;\r\n\r\n    for(final Object[] qu : queries) {\r\n      // added to renew document after each update test\r\n      if(up && ((String) qu[0]).startsWith(\"xxx\")) {\r\n        new CreateDB(name, file).execute(context);\r\n      }\r\n\r\n      final boolean correct = qu.length == 3;\r\n      final String query = qu[correct ? 2 : 1].toString();\r\n\r\n      final Command c = new XQuery(query);\r\n      try {\r\n        c.execute(context);\r\n        final Result val = c.result();\r\n        final Result cmp = correct ? (Result) qu[1] : null;\r\n        if(val instanceof Nodes && cmp instanceof Nodes) {\r\n          ((Nodes) cmp).data = ((Nodes) val).data;\r\n        }\r\n        if(!correct || !val.sameAs(cmp)) {\r\n          sb.append(\"-- \" + qu[0] + \": \" + query + \"\\n[E] \" + (correct ?\r\n              qu[1] : \"error\") + \"\\n[F] \" + val + \" \" + details() + \"\\n\");\r\n          ++fail;\r\n        }\r\n      } catch(final BaseXException ex) {\r\n        if(correct) {\r\n          sb.append(\"-- \" + qu[0] + \": \" + query + \"\\n[E] \" +\r\n              qu[1] + \"\\n[F] \" + ex.getMessage() + \" \" + details() + \"\\n\");\r\n          ++fail;\r\n        }\r\n      }\r\n    }\r\n    if(fail != 0) fail(fail + \" wrong queries; [E] expected, [F] found:\\n\" +\r\n        sb.toString().trim());\r\n  }","id":42192,"modified_method":"/**\r\n   * Tests the specified instance.\r\n   * @throws BaseXException database exception\r\n   */\r\n  @Test\r\n  public void test() throws BaseXException {\r\n    final String file = doc.replaceAll(\"\\\\\\\"\", \"\\\\\\\\\\\"\");\r\n    final String name = Util.name(this);\r\n    final boolean up = this instanceof XQUPTest;\r\n    new CreateDB(name, file).execute(context);\r\n\r\n    final StringBuilder sb = new StringBuilder();\r\n    int fail = 0;\r\n\r\n    for(final Object[] qu : queries) {\r\n      // added to renew document after each update test\r\n      final String title = (String) qu[0];\r\n      if(up && title.startsWith(\"xxx\")) {\r\n        new CreateDB(name, file).execute(context);\r\n      }\r\n\r\n      final boolean correct = qu.length == 3;\r\n      final String query = qu[correct ? 2 : 1].toString();\r\n\r\n      final Command c = new XQuery(query);\r\n      try {\r\n        c.execute(context);\r\n        final Result val = c.result();\r\n        final Result cmp = correct ? (Result) qu[1] : null;\r\n        if(val instanceof Nodes && cmp instanceof Nodes) {\r\n          ((Nodes) cmp).data = ((Nodes) val).data;\r\n        }\r\n        if(!correct || !val.sameAs(cmp)) {\r\n          sb.append(\"-- \" + qu[0] + \": \" + query + \"\\n[E] \" + (correct ?\r\n              qu[1] : \"error\") + \"\\n[F] \" + val + \" \" + details() + \"\\n\");\r\n          ++fail;\r\n        }\r\n      } catch(final BaseXException ex) {\r\n        if(correct) {\r\n          sb.append(\"-- \" + qu[0] + \": \" + query + \"\\n[E] \" +\r\n              qu[1] + \"\\n[F] \" + ex.getMessage() + \" \" + details() + \"\\n\");\r\n          ++fail;\r\n        }\r\n      }\r\n    }\r\n    if(fail != 0) fail(fail + \" wrong queries; [E] expected, [F] found:\\n\" +\r\n        sb.toString().trim());\r\n  }","commit_id":"6a05395ab02de5c05c226b62582baffe2b4842d2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * Search the Value by name in the row, return the Values index\n     * @param name the value name to search for.\n     * @return the index of the value with the given name, -1 is nothing was found.\n\t */\n\tpublic int searchValueIndex(String name)\n\t{\n\t\tif (name==null) return -1;\n\t\t\n\t\tfor (int i = 0; i < size(); i++)\n        {\n            Value v = getValue(i);\n            if (v.getName().compareToIgnoreCase(name) == 0) { return i; }\n        }\n\t\t\n\t\treturn -1;\n\t}","id":42193,"modified_method":"/**\n     * Search the Value by name in the row, return the Values index.\n     *\n     * @param name the value name to search for.\n     * @return the index of the value with the given name, -1 is nothing was found.\n\t */\n\tpublic int searchValueIndex(String name)\n\t{\n\t\tif (name==null) return -1;\n\n\t\tfor (int i = 0; i < size(); i++)\n        {\n            Value v = getValue(i);\n            if ( v.getName().equalsIgnoreCase(name) ) \n            { \n            \treturn i; \n            }\n        }\n\n\t\treturn -1;\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Compare 2 rows with each other using certain values in the rows and also considering an ascending clause.\n\t * @param r The row to compare with\n\t * @param fieldnrs The indexes of the values to compare\n\t * @param ascending an entry for each value to compare where true means and normal compare, false the reverse.\n\t * @return -1 if the row is smaller, 0 if they are equal and 1 if the row is larger.\n\t */\n\tpublic int compare(Row r, int fieldnrs[], boolean ascending[], boolean caseInsensitive[])\n\t{\n\t\tint retval=0;\n\t\tint i;\n\t\tint len=fieldnrs.length;\n\t\tValue v1, v2;\n\t\t\n\t\tfor (i=0;i<len;i++)\n\t\t{\n\t\t\tv1=  getValue(fieldnrs[i]);\n\t\t\tv2=r.getValue(fieldnrs[i]);\n\t\t\t\n            if (caseInsensitive!=null) \n                retval=v1.compare(v2, caseInsensitive[i]);\n            else \n                retval=v1.compare(v2);\n\t\t\t\n\t\t\tif (!ascending[i]) \n\t\t\t{\n\t\t\t\tretval=retval*(-1);\n\t\t\t} \n\t\t\t\n\t\t\tif (retval!=0) return retval;\n\t\t}\n\t\t\n\t\treturn retval;\n\t}","id":42194,"modified_method":"/**\n\t * Compare 2 rows with each other using certain values in the rows and\n\t * also considering an ascending clause.\n\t *\n\t * @param r The row to compare with\n\t * @param fieldnrs The indexes of the values to compare\n\t * @param ascending an entry for each value to compare where true means and normal compare, false the reverse.\n\t * @return -1 if the row is smaller, 0 if they are equal and 1 if the row is larger.\n\t */\n\tpublic int compare(Row r, int fieldnrs[], boolean ascending[], boolean caseInsensitive[])\n\t{\n\t\tint retval=0;\n\t\tint i;\n\t\tint len=fieldnrs.length;\n\t\tValue v1, v2;\n\n\t\tfor (i=0;i<len;i++)\n\t\t{\n\t\t\tv1=  getValue(fieldnrs[i]);\n\t\t\tv2=r.getValue(fieldnrs[i]);\n\n            if (caseInsensitive!=null)\n                retval=v1.compare(v2, caseInsensitive[i]);\n            else\n                retval=v1.compare(v2);\n\n\t\t\tif (!ascending[i])\n\t\t\t{\n\t\t\t\tretval=-retval;\n\t\t\t}\n\n\t\t\tif (retval!=0) return retval;\n\t\t}\n\n\t\treturn retval;\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Return the XML representation of a row\n\t * @return The XML representation of this row\n\t */\n\tpublic String getXML()\n\t{\n\t\tString retval=\"<row>\";\n\t\tretval+=XMLHandler.addTagValue(\"logdate\", logdate);\n\t\tfor (int i=0;i<size();i++)\n\t\t{\n\t\t\tretval+=getValue(i).getXML();\n\t\t}\n\t\tretval+=\"<\/row>\"+Const.CR;\n\t\t\n\t\treturn retval;\n\t}","id":42195,"modified_method":"/**\n\t * Return the XML representation of a row.\n\t *\n\t * @return The XML representation of this row\n\t */\n\tpublic String getXML()\n\t{\n\t\tStringBuffer retval= new StringBuffer(\"<row>\");\n\t\tretval.append(XMLHandler.addTagValue(\"logdate\", logdate));\n\t\tfor (int i=0;i<size();i++)\n\t\t{\n\t\t\tretval.append(getValue(i).getXML());\n\t\t}\n\t\tretval.append(\"<\/row>\").append(Const.CR);\n\n\t\treturn retval.toString();\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Return the meta-data of a row as a String.\n\t * @return the meta-data of a row as a String\n\t */\n\tpublic String toStringMeta()\n\t{\n\t\tint i;\n\t\tString retval=\"[\";\n\t\t\n\t\tfor (i=0;i<size();i++)\n\t\t{\n\t\t\tif (i!=0) retval+=\", \";\n\t\t\tif (getValue(i)!=null)\n\t\t\t{\n\t\t\t\tValue v=getValue(i);\n\t\t\t\tretval+=v.getName()+\"(\";\n\t\t\t\tretval+=v.getTypeDesc();\n\t\t\t\tif (v.getLength()>0) \n\t\t\t\t{\n\t\t\t\t\tretval+=\"(\";\n\t\t\t\t\tretval+=v.getLength();\n\t\t\t\t\tif (v.getPrecision()>0)\tretval+=\",\"+v.getPrecision();\n\t\t\t\t\tretval+=\")\";\n\t\t\t\t}\n\t\t\t\tretval+=\")\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval+=\"NULL\";\n\t\t\t}\n\t\t}\n\t\tretval+=\"]\";\n\t\t\n\t\treturn retval;\n\t}","id":42196,"modified_method":"/**\n\t * Return the meta-data of a row as a String.\n\t * @return the meta-data of a row as a String\n\t */\n\tpublic String toStringMeta()\n\t{\n\t\tint i;\n\t\tStringBuffer retval= new StringBuffer(\"[\");\n\n\t\tfor (i=0;i<size();i++)\n\t\t{\n\t\t\tif (i!=0) retval.append(\", \");\n\t\t\tif (getValue(i)!=null)\n\t\t\t{\n\t\t\t\tValue v=getValue(i);\n\t\t\t\tretval.append(v.getName()).append(\"(\");\n\t\t\t\tretval.append(v.getTypeDesc());\n\t\t\t\tif (v.getLength()>0)\n\t\t\t\t{\n\t\t\t\t\tretval.append(\"(\");\n\t\t\t\t\tretval.append(v.getLength());\n\t\t\t\t\tif (v.getPrecision()>0)\tretval.append(\",\").append(v.getPrecision());\n\t\t\t\t\tretval.append(\")\");\n\t\t\t\t}\n\t\t\t\tretval.append(\")\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval.append(\"NULL\");\n\t\t\t}\n\t\t}\n\t\tretval.append(\"]\");\n\n\t\treturn retval.toString();\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Compare 2 rows with each other using one value in the rows and also considering an ascending clause.\n\t * @param r The row to compare with\n\t * @param fieldnr The indexe of the values to compare\n\t * @param sort_desc true means and normal compare, false the reverse.\n\t * @return -1 if the row is smaller, 0 if they are equal and 1 if the row is larger.\n\t */\n\tpublic int compare(Row r, int fieldnr, boolean sort_desc)\n\t{\n\t\tint retval=0;\n\t\tValue v1, v2;\n\t\t\n\t\tv1=  getValue(fieldnr);\n\t\tv2=r.getValue(fieldnr);\n\t\t\t\n\t\tretval=v1.compare(v2);\n\t\t\t\n\t\tif (sort_desc) \n\t\t{\n\t\t\tretval=retval*(-1);\n\t\t}\n\t\t\n\t\treturn retval;\n\t}","id":42197,"modified_method":"/**\n\t * Compare 2 rows with each other using one value in the rows and\n\t * also considering an ascending clause.\n\t *\n\t * @param r The row to compare with\n\t * @param fieldnr The indexe of the values to compare\n\t * @param sort_desc true means and normal compare, false the reverse.\n\t * @return -1 if the row is smaller, 0 if they are equal and 1 if the row is larger.\n\t */\n\tpublic int compare(Row r, int fieldnr, boolean sort_desc)\n\t{\n\t\tint retval=0;\n\t\tValue v1, v2;\n\n\t\tv1=  getValue(fieldnr);\n\t\tv2=r.getValue(fieldnr);\n\n\t\tretval=v1.compare(v2);\n\n\t\tif (sort_desc)\n\t\t{\n\t\t\tretval=-retval;\n\t\t}\n\n\t\treturn retval;\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Checks whether or not the row is empty\n\t * A row is empty if all the values in the row are Null\n\t * A row is empty if there are no values in the row.\n\t * @return true if the row is considered empty, false if the row is not empty.\n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\tboolean empty=true;\n\t\tfor (int i=0;i<size();i++)\n\t\t{\n\t\t\tValue v = getValue(i);\n\t\t\tif (v!=null && !v.isNull()) empty=false;\n\t\t}\n\t\treturn empty;\n\t}","id":42198,"modified_method":"/**\n\t * Checks whether or not the row is empty\n\t * A row is empty if all the values in the row are null\n\t * A row is empty if there are no values in the row.\n\t *\n\t * @return true if the row is considered empty, false if the row is not empty.\n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\tboolean empty=true;\n\t\tfor (int i=0;i<size();i++)\n\t\t{\n\t\t\tValue v = getValue(i);\n\t\t\tif (v!=null && !v.isNull())  {\n\t\t\t\tempty=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn empty;\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public int size()\n    {\n        return list.size();\n    }","id":42199,"modified_method":"/**\n\t * Return number of Values in Row.\n\t *\n\t * @return number of Values.\n\t */\n    public int size()\n    {\n        return list.size();\n    }","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Convert the row to a String representation.\n\t * @return the row as a String.\n\t */\n\tpublic String toString()\n\t{\n\t\tString retval=\"[\";\n\t\t\n\t\tfor (int i=0;i<size();i++)\n\t\t{\n\t\t\tValue value = getValue(i);\n\t\t\t\n\t\t\tif (i!=0) retval+=\", \";\n\t\t\tif (value!=null)\n\t\t\t{\n\t\t\t\tretval+=value.getName()+\"=\"+value.toString(false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval+=\"NULL\";\n\t\t\t}\n\t\t}\n\t\tretval+=\"]\";\n\t\t\n\t\treturn retval;\n\t}","id":42200,"modified_method":"/**\n\t * Convert the row to a String representation.\n\t * @return the row as a String.\n\t */\n\tpublic String toString()\n\t{\n\t\tStringBuffer retval= new StringBuffer(\"[\");\n\n\t\tfor (int i=0;i<size();i++)\n\t\t{\n\t\t\tValue value = getValue(i);\n\n\t\t\tif (i!=0) retval.append(\", \");\n\t\t\tif (value!=null)\n\t\t\t{\n\t\t\t\tretval.append(value.getName()).append(\"=\").append(value.toString(false));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval.append(\"NULL\");\n\t\t\t}\n\t\t}\n\t\tretval.append(\"]\");\n\n\t\treturn retval.toString();\n\t}","commit_id":"f794ef6a71cf04740e0b6a2b972a928e5ed7b2b0","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void initialize(DataSource ds, DocumentMK.Builder builder, RDBOptions options) throws Exception {\n\n        this.tnNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.NODES));\n        this.tnClusterNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.CLUSTER_NODES));\n        this.tnSettings = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.SETTINGS));\n        this.tnJournal = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.JOURNAL));\n\n        this.ch = new RDBConnectionHandler(ds);\n        this.callStack = LOG.isDebugEnabled() ? new Exception(\"call stack of RDBDocumentStore creation\") : null;\n\n        this.nodesCache = builder.buildDocumentCache(this);\n        this.cacheStats = new CacheStats(nodesCache, \"Document-Documents\", builder.getWeigher(), builder.getDocumentCacheSize());\n\n        Connection con = this.ch.getRWConnection();\n\n        int isolation = con.getTransactionIsolation();\n        String isolationDiags = RDBJDBCTools.isolationLevelToString(isolation);\n        if (isolation != Connection.TRANSACTION_READ_COMMITTED) {\n            LOG.info(\"Detected transaction isolation level \" + isolationDiags + \" is \"\n                    + (isolation < Connection.TRANSACTION_READ_COMMITTED ? \"lower\" : \"higher\") + \" than expected \"\n                    + RDBJDBCTools.isolationLevelToString(Connection.TRANSACTION_READ_COMMITTED)\n                    + \" - check datasource configuration\");\n        }\n\n        DatabaseMetaData md = con.getMetaData();\n        String dbDesc = String.format(\"%s %s (%d.%d)\", md.getDatabaseProductName(), md.getDatabaseProductVersion(),\n                md.getDatabaseMajorVersion(), md.getDatabaseMinorVersion());\n        String driverDesc = String.format(\"%s %s (%d.%d)\", md.getDriverName(), md.getDriverVersion(), md.getDriverMajorVersion(),\n                md.getDriverMinorVersion());\n        String dbUrl = md.getURL();\n\n        this.db = DB.getValue(md.getDatabaseProductName());\n        this.metadata = ImmutableMap.<String,String>builder()\n                .put(\"type\", \"rdb\")\n                .put(\"db\", md.getDatabaseProductName())\n                .put(\"version\", md.getDatabaseProductVersion())\n                .build();\n        db.checkVersion(md);\n\n        if (! \"\".equals(db.getInitializationStatement())) {\n            Statement stmt = null;\n            try {\n                stmt = con.createStatement();\n                stmt.execute(db.getInitializationStatement());\n                stmt.close();\n                con.commit();\n            }\n            finally {\n                this.ch.closeStatement(stmt);\n            }\n        }\n\n        List<String> tablesCreated = new ArrayList<String>();\n        List<String> tablesPresent = new ArrayList<String>();\n        try {\n            createTableFor(con, Collection.CLUSTER_NODES, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.NODES, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.SETTINGS, tablesCreated, tablesPresent);\n            createTableFor(con, Collection.JOURNAL, tablesCreated, tablesPresent);\n        } finally {\n            con.commit();\n            con.close();\n        }\n\n        if (options.isDropTablesOnClose()) {\n            tablesToBeDropped.addAll(tablesCreated);\n        }\n\n        String diag = db.getAdditionalDiagnostics(this.ch, this.tnNodes);\n\n        LOG.info(\"RDBDocumentStore instantiated for database \" + dbDesc + \", using driver: \" + driverDesc + \", connecting to: \"\n                + dbUrl + (diag.isEmpty() ? \"\" : (\", properties: \" + diag)) + \", transaction isolation level: \" + isolationDiags\n                + \", detected size of DATA column: \" + this.dataLimitInOctets);\n        if (!tablesPresent.isEmpty()) {\n            LOG.info(\"Tables present upon startup: \" + tablesPresent);\n        }\n        if (!tablesCreated.isEmpty()) {\n            LOG.info(\"Tables created upon startup: \" + tablesCreated\n                    + (options.isDropTablesOnClose() ? \" (will be dropped on exit)\" : \"\"));\n        }\n    }","id":42201,"modified_method":"private void initialize(DataSource ds, DocumentMK.Builder builder, RDBOptions options) throws Exception {\n\n        this.tnNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.NODES));\n        this.tnClusterNodes = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.CLUSTER_NODES));\n        this.tnSettings = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.SETTINGS));\n        this.tnJournal = RDBJDBCTools.createTableName(options.getTablePrefix(), TABLEMAP.get(Collection.JOURNAL));\n\n        this.ch = new RDBConnectionHandler(ds);\n        this.callStack = LOG.isDebugEnabled() ? new Exception(\"call stack of RDBDocumentStore creation\") : null;\n\n        this.nodesCache = builder.buildDocumentCache(this);\n        this.cacheStats = new CacheStats(nodesCache, \"Document-Documents\", builder.getWeigher(), builder.getDocumentCacheSize());\n\n        Connection con = this.ch.getRWConnection();\n\n        int isolation = con.getTransactionIsolation();\n        String isolationDiags = RDBJDBCTools.isolationLevelToString(isolation);\n        if (isolation != Connection.TRANSACTION_READ_COMMITTED) {\n            LOG.info(\"Detected transaction isolation level \" + isolationDiags + \" is \"\n                    + (isolation < Connection.TRANSACTION_READ_COMMITTED ? \"lower\" : \"higher\") + \" than expected \"\n                    + RDBJDBCTools.isolationLevelToString(Connection.TRANSACTION_READ_COMMITTED)\n                    + \" - check datasource configuration\");\n        }\n\n        DatabaseMetaData md = con.getMetaData();\n        String dbDesc = String.format(\"%s %s (%d.%d)\", md.getDatabaseProductName(), md.getDatabaseProductVersion(),\n                md.getDatabaseMajorVersion(), md.getDatabaseMinorVersion());\n        String driverDesc = String.format(\"%s %s (%d.%d)\", md.getDriverName(), md.getDriverVersion(), md.getDriverMajorVersion(),\n                md.getDriverMinorVersion());\n        String dbUrl = md.getURL();\n\n        this.db = DB.getValue(md.getDatabaseProductName());\n        this.metadata = ImmutableMap.<String,String>builder()\n                .put(\"type\", \"rdb\")\n                .put(\"db\", md.getDatabaseProductName())\n                .put(\"version\", md.getDatabaseProductVersion())\n                .build();\n        db.checkVersion(md);\n\n        if (! \"\".equals(db.getInitializationStatement())) {\n            Statement stmt = null;\n            try {\n                stmt = con.createStatement();\n                stmt.execute(db.getInitializationStatement());\n                stmt.close();\n                con.commit();\n            }\n            finally {\n                this.ch.closeStatement(stmt);\n            }\n        }\n\n        List<String> tablesCreated = new ArrayList<String>();\n        List<String> tablesPresent = new ArrayList<String>();\n        StringBuilder tableDiags = new StringBuilder();\n        try {\n            createTableFor(con, Collection.CLUSTER_NODES, tablesCreated, tablesPresent, tableDiags);\n            createTableFor(con, Collection.NODES, tablesCreated, tablesPresent, tableDiags);\n            createTableFor(con, Collection.SETTINGS, tablesCreated, tablesPresent, tableDiags);\n            createTableFor(con, Collection.JOURNAL, tablesCreated, tablesPresent, tableDiags);\n        } finally {\n            con.commit();\n            con.close();\n        }\n\n        if (options.isDropTablesOnClose()) {\n            tablesToBeDropped.addAll(tablesCreated);\n        }\n\n        if (tableDiags.length() != 0) {\n            tableDiags.insert(0, \", \");\n        }\n\n        String diag = db.getAdditionalDiagnostics(this.ch, this.tnNodes);\n\n        LOG.info(\"RDBDocumentStore instantiated for database \" + dbDesc + \", using driver: \" + driverDesc + \", connecting to: \"\n                + dbUrl + (diag.isEmpty() ? \"\" : (\", properties: \" + diag)) + \", transaction isolation level: \" + isolationDiags\n                + tableDiags);\n        if (!tablesPresent.isEmpty()) {\n            LOG.info(\"Tables present upon startup: \" + tablesPresent);\n        }\n        if (!tablesCreated.isEmpty()) {\n            LOG.info(\"Tables created upon startup: \" + tablesCreated\n                    + (options.isDropTablesOnClose() ? \" (will be dropped on exit)\" : \"\"));\n        }\n    }","commit_id":"2de3a6718803becc1d16bf5ad2fa782604e57f20","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void createTableFor(Connection con, Collection<? extends Document> col, List<String> tablesCreated, List<String> tablesPresent) throws SQLException {\n        String dbname = this.db.toString();\n        if (con.getMetaData().getURL() != null) {\n            dbname += \" (\" + con.getMetaData().getURL() + \")\";\n        }\n        String tableName = getTable(col);\n\n        PreparedStatement checkStatement = null;\n        ResultSet checkResultSet = null;\n        Statement creatStatement = null;\n        try {\n            checkStatement = con.prepareStatement(\"select DATA from \" + tableName + \" where ID = ?\");\n            checkStatement.setString(1, \"0:/\");\n            checkResultSet = checkStatement.executeQuery();\n\n            if (col.equals(Collection.NODES)) {\n                // try to discover size of DATA column\n                ResultSetMetaData met = checkResultSet.getMetaData();\n                this.dataLimitInOctets = met.getPrecision(1);\n            }\n            tablesPresent.add(tableName);\n        } catch (SQLException ex) {\n            // table does not appear to exist\n            con.rollback();\n\n            try {\n                creatStatement = con.createStatement();\n                creatStatement.execute(this.db.getTableCreationStatement(tableName));\n                creatStatement.close();\n\n                for (String ic : this.db.getIndexCreationStatements(tableName)) {\n                    creatStatement = con.createStatement();\n                    creatStatement.execute(ic);\n                    creatStatement.close();\n                }\n\n                con.commit();\n\n                tablesCreated.add(tableName);\n\n                if (col.equals(Collection.NODES)) {\n                    PreparedStatement pstmt = con.prepareStatement(\"select DATA from \" + tableName + \" where ID = ?\");\n                    pstmt.setString(1, \"0:/\");\n                    ResultSet rs = pstmt.executeQuery();\n                    ResultSetMetaData met = rs.getMetaData();\n                    this.dataLimitInOctets = met.getPrecision(1);\n                }\n            }\n            catch (SQLException ex2) {\n                LOG.error(\"Failed to create table \" + tableName + \" in \" + dbname, ex2);\n                throw ex2;\n            }\n        }\n        finally {\n            this.ch.closeResultSet(checkResultSet);\n            this.ch.closeStatement(checkStatement);\n            this.ch.closeStatement(creatStatement);\n        }\n    }","id":42202,"modified_method":"private void createTableFor(Connection con, Collection<? extends Document> col, List<String> tablesCreated,\n            List<String> tablesPresent, StringBuilder diagnostics) throws SQLException {\n        String dbname = this.db.toString();\n        if (con.getMetaData().getURL() != null) {\n            dbname += \" (\" + con.getMetaData().getURL() + \")\";\n        }\n        String tableName = getTable(col);\n\n        PreparedStatement checkStatement = null;\n        ResultSet checkResultSet = null;\n        Statement creatStatement = null;\n        try {\n            checkStatement = con.prepareStatement(\"select ID, DATA from \" + tableName + \" where ID = ?\");\n            checkStatement.setString(1, \"0:/\");\n            checkResultSet = checkStatement.executeQuery();\n\n            if (col.equals(Collection.NODES)) {\n                // try to discover size of DATA column\n                ResultSetMetaData met = checkResultSet.getMetaData();\n                this.isIdBinary = isBinaryType(met.getColumnType(1));\n                this.dataLimitInOctets = met.getPrecision(2);\n                diagnostics.append(dumpTableMeta(met.getColumnType(1), met.getColumnTypeName(1), met.getPrecision(1),\n                        met.getColumnType(2), met.getColumnTypeName(2), met.getPrecision(2)));\n            }\n            tablesPresent.add(tableName);\n        } catch (SQLException ex) {\n            // table does not appear to exist\n            con.rollback();\n\n            try {\n                creatStatement = con.createStatement();\n                creatStatement.execute(this.db.getTableCreationStatement(tableName));\n                creatStatement.close();\n\n                for (String ic : this.db.getIndexCreationStatements(tableName)) {\n                    creatStatement = con.createStatement();\n                    creatStatement.execute(ic);\n                    creatStatement.close();\n                }\n\n                con.commit();\n\n                tablesCreated.add(tableName);\n\n                if (col.equals(Collection.NODES)) {\n                    PreparedStatement pstmt = con.prepareStatement(\"select ID, DATA from \" + tableName + \" where ID = ?\");\n                    pstmt.setString(1, \"0:/\");\n                    ResultSet rs = pstmt.executeQuery();\n                    ResultSetMetaData met = rs.getMetaData();\n                    this.isIdBinary = isBinaryType(met.getColumnType(1));\n                    this.dataLimitInOctets = met.getPrecision(2);\n                    diagnostics.append(dumpTableMeta(met.getColumnType(1), met.getColumnTypeName(1), met.getPrecision(1),\n                            met.getColumnType(2), met.getColumnTypeName(2), met.getPrecision(2)));\n                }\n            }\n            catch (SQLException ex2) {\n                LOG.error(\"Failed to create table \" + tableName + \" in \" + dbname, ex2);\n                throw ex2;\n            }\n        }\n        finally {\n            this.ch.closeResultSet(checkResultSet);\n            this.ch.closeStatement(checkStatement);\n            this.ch.closeStatement(creatStatement);\n        }\n    }","commit_id":"2de3a6718803becc1d16bf5ad2fa782604e57f20","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private String getIdFromRS(ResultSet rs, int idx) throws SQLException {\n        String id;\n        if (db.isPrimaryColumnByteEncoded()) {\n            try {\n                id = new String(rs.getBytes(idx), \"UTF-8\");\n\n            } catch (UnsupportedEncodingException ex) {\n                LOG.error(\"UTF-8 not supported??\", ex);\n                throw new DocumentStoreException(ex);\n            }\n        } else {\n            id = rs.getString(idx);\n        }\n        return id;\n    }","id":42203,"modified_method":"private String getIdFromRS(ResultSet rs, int idx) throws SQLException {\n        if (this.isIdBinary) {\n            try {\n                return new String(rs.getBytes(idx), \"UTF-8\");\n            } catch (UnsupportedEncodingException ex) {\n                LOG.error(\"UTF-8 not supported??\", ex);\n                throw new DocumentStoreException(ex);\n            }\n        } else {\n            return rs.getString(idx);\n        }\n    }","commit_id":"2de3a6718803becc1d16bf5ad2fa782604e57f20","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void setIdInStatement(PreparedStatement stmt, int idx, String id) throws SQLException {\n        if (db.isPrimaryColumnByteEncoded()) {\n            try {\n                stmt.setBytes(idx, id.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException ex) {\n                LOG.error(\"UTF-8 not supported??\", ex);\n                throw new DocumentStoreException(ex);\n            }\n        } else {\n            stmt.setString(idx, id);\n        }\n    }","id":42204,"modified_method":"private void setIdInStatement(PreparedStatement stmt, int idx, String id) throws SQLException {\n        if (this.isIdBinary) {\n            try {\n                stmt.setBytes(idx, id.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException ex) {\n                LOG.error(\"UTF-8 not supported??\", ex);\n                throw new DocumentStoreException(ex);\n            }\n        } else {\n            stmt.setString(idx, id);\n        }\n    }","commit_id":"2de3a6718803becc1d16bf5ad2fa782604e57f20","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nullable\n  private static SSBasedInspection getInspection(@NotNull Project project) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final InspectionToolWrapper entry = (InspectionToolWrapper)profile.getInspectionTool(SSBasedInspection.SHORT_NAME);\n\n    return entry == null ? null : (SSBasedInspection)entry.getTool();\n  }","id":42205,"modified_method":"@Nullable\n  private static SSBasedInspection getInspection(@NotNull Project project) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final InspectionToolWrapper entry = profile.getInspectionTool(SSBasedInspection.SHORT_NAME, project);\n\n    return entry == null ? null : (SSBasedInspection)entry.getTool();\n  }","commit_id":"f35e1bb3d881b9f585927fa1b5b3612be5ff4b83","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void runJaxpValidation(final XmlElement element, Validator.ValidationHost host) {\n    final PsiFile file = element.getContainingFile();\n\n    if (myFile == file &&\n        file != null &&\n        myModificationStamp == file.getModificationStamp() &&\n        !ValidateXmlActionHandler.isValidationDependentFilesOutOfDate((XmlFile)file) &&\n        myInfos!=null &&\n        myInfos.get()!=null // we have validated before\n        ) {\n      addAllInfos(host,myInfos.get());\n      return;\n    }\n\n    if (myHandler==null)  myHandler = new ValidateXmlActionHandler(false);\n    final Project project = element.getProject();\n\n    final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document==null) return;\n    final List<ValidationInfo> results = new LinkedList<ValidationInfo>();\n\n    myHost = new Validator.ValidationHost() {\n      public void addMessage(PsiElement context, String message, int type) {\n        final ValidationInfo o = new ValidationInfo();\n\n        results.add(o);\n        o.element = context;\n        o.message = message;\n        o.type = type;\n      }\n\n      public void addMessage(final PsiElement context, final String message, final ErrorType type, final IntentionAction... fixes) {\n        addMessage(context, message, type.ordinal());\n      }\n    };\n\n    myHandler.setErrorReporter(myHandler.new ErrorReporter() {\n      public boolean isStopOnUndeclaredResource() {\n        return true;\n      }\n\n      public void processError(final SAXParseException e, final ValidateXmlActionHandler.ProblemType warning) {\n        try {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              if (e.getPublicId() != null) {\n                return;\n              }\n\n              final VirtualFile errorFile = myHandler.getFile(e.getPublicId(), e.getSystemId());\n              if (!Comparing.equal(errorFile, file.getVirtualFile()) && errorFile != null) {\n                return; // error in attached schema\n              }\n\n              if (document.getLineCount() < e.getLineNumber() || e.getLineNumber() <= 0) {\n                return;\n              }\n\n              int problemType = getProblemType(warning);\n              int offset = Math.max(0, document.getLineStartOffset(e.getLineNumber() - 1) + e.getColumnNumber() - 2);\n              if (offset >= document.getTextLength()) return;\n              PsiElement currentElement = PsiDocumentManager.getInstance(project).getPsiFile(document).findElementAt(offset);\n              PsiElement originalElement = currentElement;\n              final String elementText = currentElement.getText();\n\n              if (elementText.equals(\"<\/\")) {\n                currentElement = currentElement.getNextSibling();\n              }\n              else if (elementText.equals(\">\") || elementText.equals(\"=\")) {\n                currentElement = currentElement.getPrevSibling();\n              }\n\n              // Cannot find the declaration of element\n              String localizedMessage = e.getLocalizedMessage();\n\n              // Ideally would be to switch one messageIds\n              int endIndex = localizedMessage.indexOf(':');\n              if (endIndex < localizedMessage.length() - 1 && localizedMessage.charAt(endIndex + 1) == '/') {\n                endIndex = -1;  // ignore : in http://\n              }\n              String messageId = endIndex != -1 ? localizedMessage.substring(0, endIndex ):\"\";\n              localizedMessage = localizedMessage.substring(endIndex + 1).trim();\n\n              if (localizedMessage.startsWith(CANNOT_FIND_DECLARATION_ERROR_PREFIX) ||\n                  localizedMessage.startsWith(ELEMENT_ERROR_PREFIX) ||\n                  localizedMessage.startsWith(ROOT_ELEMENT_ERROR_PREFIX) ||\n                  localizedMessage.startsWith(CONTENT_OF_ELEMENT_TYPE_ERROR_PREFIX)\n                  ) {\n                addProblemToTagName(currentElement, originalElement, localizedMessage, warning);\n                //return;\n              } else if (localizedMessage.startsWith(VALUE_ERROR_PREFIX)) {\n                addProblemToTagName(currentElement, originalElement, localizedMessage, warning);\n              } else {\n                if (messageId.startsWith(ATTRIBUTE_MESSAGE_PREFIX)) {\n                  @NonNls String prefix = \"of attribute \";\n                  final int i = localizedMessage.indexOf(prefix);\n\n                  if (i != -1) {\n                    int messagePrefixLength = prefix.length() + i;\n                    final int nextQuoteIndex = localizedMessage.indexOf(localizedMessage.charAt(messagePrefixLength), messagePrefixLength + 1);\n                    String attrName = nextQuoteIndex == -1 ? null : localizedMessage.substring(messagePrefixLength + 1, nextQuoteIndex);\n\n                    XmlTag parent = PsiTreeUtil.getParentOfType(originalElement,XmlTag.class);\n                    currentElement = parent.getAttribute(attrName,null);\n\n                    if (currentElement != null) {\n                      currentElement = ((XmlAttribute)currentElement).getValueElement();\n                    }\n                  }\n\n                  if (currentElement!=null) {\n                    assertValidElement(currentElement, originalElement,localizedMessage);\n                    myHost.addMessage(currentElement,localizedMessage, problemType);\n                  } else {\n                    addProblemToTagName(originalElement, originalElement, localizedMessage, warning);\n                  }\n                }\n                else if (localizedMessage.startsWith(ATTRIBUTE_ERROR_PREFIX)) {\n                  final int messagePrefixLength = ATTRIBUTE_ERROR_PREFIX.length();\n\n                  if ( localizedMessage.charAt(messagePrefixLength) == '\"' ||\n                       localizedMessage.charAt(messagePrefixLength) == '\\''\n                     ) {\n                    // extract the attribute name from message and get it from tag!\n                    final int nextQuoteIndex = localizedMessage.indexOf(localizedMessage.charAt(messagePrefixLength), messagePrefixLength + 1);\n                    String attrName = nextQuoteIndex == -1 ? null : localizedMessage.substring(messagePrefixLength + 1, nextQuoteIndex);\n\n                    XmlTag parent = PsiTreeUtil.getParentOfType(originalElement,XmlTag.class);\n                    currentElement = parent.getAttribute(attrName,null);\n\n                    if (currentElement!=null) {\n                      currentElement = SourceTreeToPsiMap.treeElementToPsi(\n                        XmlChildRole.ATTRIBUTE_NAME_FINDER.findChild(\n                          SourceTreeToPsiMap.psiElementToTree(currentElement)\n                        )\n                      );\n                    }\n                  } else {\n                    currentElement = PsiTreeUtil.getParentOfType(currentElement, XmlTag.class, false);\n                  }\n\n                  if (currentElement!=null) {\n                    assertValidElement(currentElement, originalElement,localizedMessage);\n                    myHost.addMessage(currentElement,localizedMessage, problemType);\n                  } else {\n                    addProblemToTagName(originalElement, originalElement, localizedMessage, warning);\n                  }\n                } else if (localizedMessage.startsWith(STRING_ERROR_PREFIX)) {\n                  if (currentElement != null) {\n                    myHost.addMessage(currentElement,localizedMessage,Validator.ValidationHost.WARNING);\n                  }\n                }\n                else {\n                  currentElement = getNodeForMessage(currentElement != null ? currentElement:originalElement);\n                  assertValidElement(currentElement, originalElement,localizedMessage);\n                  if (currentElement!=null) {\n                    myHost.addMessage(currentElement,localizedMessage, problemType);\n                  }\n                }\n              }\n            }\n          });\n        }\n        catch (Exception ex) {\n          if (ex instanceof ProcessCanceledException) throw (ProcessCanceledException)ex;\n          if (ex instanceof XmlResourceResolver.IgnoredResourceException) throw (XmlResourceResolver.IgnoredResourceException)ex;\n          LOG.error(ex);\n        }\n      }\n\n    });\n\n    myHandler.doValidate((XmlFile)element.getContainingFile());\n\n    myFile = file;\n    myModificationStamp = myFile.getModificationStamp();\n    myInfos = new WeakReference<List<ValidationInfo>>(results);\n\n    addAllInfos(host,results);\n  }","id":42206,"modified_method":"private void runJaxpValidation(final XmlElement element, Validator.ValidationHost host) {\n    final PsiFile file = element.getContainingFile();\n\n    if (myFile == file &&\n        file != null &&\n        myModificationStamp == file.getModificationStamp() &&\n        !ValidateXmlActionHandler.isValidationDependentFilesOutOfDate((XmlFile)file) &&\n        myInfos!=null &&\n        myInfos.get()!=null // we have validated before\n        ) {\n      addAllInfos(host,myInfos.get());\n      return;\n    }\n\n    if (myHandler==null)  myHandler = new ValidateXmlActionHandler(false);\n    final Project project = element.getProject();\n\n    final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document==null) return;\n    final List<ValidationInfo> results = new LinkedList<ValidationInfo>();\n\n    myHost = new Validator.ValidationHost() {\n      public void addMessage(PsiElement context, String message, int type) {\n        final ValidationInfo o = new ValidationInfo();\n\n        results.add(o);\n        o.element = context;\n        o.message = message;\n        o.type = type;\n      }\n\n      public void addMessage(final PsiElement context, final String message, final ErrorType type, final IntentionAction... fixes) {\n        addMessage(context, message, type.ordinal());\n      }\n    };\n\n    myHandler.setErrorReporter(new ErrorReporter(myHandler) {\n      public boolean isStopOnUndeclaredResource() {\n        return true;\n      }\n\n      public void processError(final SAXParseException e, final ValidateXmlActionHandler.ProblemType warning) {\n        try {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            public void run() {\n              if (e.getPublicId() != null) {\n                return;\n              }\n\n              final VirtualFile errorFile = myHandler.getFile(e.getPublicId(), e.getSystemId());\n              if (!Comparing.equal(errorFile, file.getVirtualFile()) && errorFile != null) {\n                return; // error in attached schema\n              }\n\n              if (document.getLineCount() < e.getLineNumber() || e.getLineNumber() <= 0) {\n                return;\n              }\n\n              int problemType = getProblemType(warning);\n              int offset = Math.max(0, document.getLineStartOffset(e.getLineNumber() - 1) + e.getColumnNumber() - 2);\n              if (offset >= document.getTextLength()) return;\n              PsiElement currentElement = PsiDocumentManager.getInstance(project).getPsiFile(document).findElementAt(offset);\n              PsiElement originalElement = currentElement;\n              final String elementText = currentElement.getText();\n\n              if (elementText.equals(\"<\/\")) {\n                currentElement = currentElement.getNextSibling();\n              }\n              else if (elementText.equals(\">\") || elementText.equals(\"=\")) {\n                currentElement = currentElement.getPrevSibling();\n              }\n\n              // Cannot find the declaration of element\n              String localizedMessage = e.getLocalizedMessage();\n\n              // Ideally would be to switch one messageIds\n              int endIndex = localizedMessage.indexOf(':');\n              if (endIndex < localizedMessage.length() - 1 && localizedMessage.charAt(endIndex + 1) == '/') {\n                endIndex = -1;  // ignore : in http://\n              }\n              String messageId = endIndex != -1 ? localizedMessage.substring(0, endIndex ):\"\";\n              localizedMessage = localizedMessage.substring(endIndex + 1).trim();\n\n              if (localizedMessage.startsWith(CANNOT_FIND_DECLARATION_ERROR_PREFIX) ||\n                  localizedMessage.startsWith(ELEMENT_ERROR_PREFIX) ||\n                  localizedMessage.startsWith(ROOT_ELEMENT_ERROR_PREFIX) ||\n                  localizedMessage.startsWith(CONTENT_OF_ELEMENT_TYPE_ERROR_PREFIX)\n                  ) {\n                addProblemToTagName(currentElement, originalElement, localizedMessage, warning);\n                //return;\n              } else if (localizedMessage.startsWith(VALUE_ERROR_PREFIX)) {\n                addProblemToTagName(currentElement, originalElement, localizedMessage, warning);\n              } else {\n                if (messageId.startsWith(ATTRIBUTE_MESSAGE_PREFIX)) {\n                  @NonNls String prefix = \"of attribute \";\n                  final int i = localizedMessage.indexOf(prefix);\n\n                  if (i != -1) {\n                    int messagePrefixLength = prefix.length() + i;\n                    final int nextQuoteIndex = localizedMessage.indexOf(localizedMessage.charAt(messagePrefixLength), messagePrefixLength + 1);\n                    String attrName = nextQuoteIndex == -1 ? null : localizedMessage.substring(messagePrefixLength + 1, nextQuoteIndex);\n\n                    XmlTag parent = PsiTreeUtil.getParentOfType(originalElement,XmlTag.class);\n                    currentElement = parent.getAttribute(attrName,null);\n\n                    if (currentElement != null) {\n                      currentElement = ((XmlAttribute)currentElement).getValueElement();\n                    }\n                  }\n\n                  if (currentElement!=null) {\n                    assertValidElement(currentElement, originalElement,localizedMessage);\n                    myHost.addMessage(currentElement,localizedMessage, problemType);\n                  } else {\n                    addProblemToTagName(originalElement, originalElement, localizedMessage, warning);\n                  }\n                }\n                else if (localizedMessage.startsWith(ATTRIBUTE_ERROR_PREFIX)) {\n                  final int messagePrefixLength = ATTRIBUTE_ERROR_PREFIX.length();\n\n                  if ( localizedMessage.charAt(messagePrefixLength) == '\"' ||\n                       localizedMessage.charAt(messagePrefixLength) == '\\''\n                     ) {\n                    // extract the attribute name from message and get it from tag!\n                    final int nextQuoteIndex = localizedMessage.indexOf(localizedMessage.charAt(messagePrefixLength), messagePrefixLength + 1);\n                    String attrName = nextQuoteIndex == -1 ? null : localizedMessage.substring(messagePrefixLength + 1, nextQuoteIndex);\n\n                    XmlTag parent = PsiTreeUtil.getParentOfType(originalElement,XmlTag.class);\n                    currentElement = parent.getAttribute(attrName,null);\n\n                    if (currentElement!=null) {\n                      currentElement = SourceTreeToPsiMap.treeElementToPsi(\n                        XmlChildRole.ATTRIBUTE_NAME_FINDER.findChild(\n                          SourceTreeToPsiMap.psiElementToTree(currentElement)\n                        )\n                      );\n                    }\n                  } else {\n                    currentElement = PsiTreeUtil.getParentOfType(currentElement, XmlTag.class, false);\n                  }\n\n                  if (currentElement!=null) {\n                    assertValidElement(currentElement, originalElement,localizedMessage);\n                    myHost.addMessage(currentElement,localizedMessage, problemType);\n                  } else {\n                    addProblemToTagName(originalElement, originalElement, localizedMessage, warning);\n                  }\n                } else if (localizedMessage.startsWith(STRING_ERROR_PREFIX)) {\n                  if (currentElement != null) {\n                    myHost.addMessage(currentElement,localizedMessage,Validator.ValidationHost.WARNING);\n                  }\n                }\n                else {\n                  currentElement = getNodeForMessage(currentElement != null ? currentElement:originalElement);\n                  assertValidElement(currentElement, originalElement,localizedMessage);\n                  if (currentElement!=null) {\n                    myHost.addMessage(currentElement,localizedMessage, problemType);\n                  }\n                }\n              }\n            }\n          });\n        }\n        catch (Exception ex) {\n          if (ex instanceof ProcessCanceledException) throw (ProcessCanceledException)ex;\n          if (ex instanceof XmlResourceResolver.IgnoredResourceException) throw (XmlResourceResolver.IgnoredResourceException)ex;\n          LOG.error(ex);\n        }\n      }\n\n    });\n\n    myHandler.doValidate((XmlFile)element.getContainingFile());\n\n    myFile = file;\n    myModificationStamp = myFile.getModificationStamp();\n    myInfos = new WeakReference<List<ValidationInfo>>(results);\n\n    addAllInfos(host,results);\n  }","commit_id":"ee89b065d216529201d737357c2cae61d813fe37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static synchronized void doValidation(final XmlDocument document, final Validator.ValidationHost host) {\n    final PsiFile containingFile = document.getContainingFile();\n    if (containingFile == null) {\n      return;\n    }\n\n    if (containingFile.getViewProvider() instanceof TemplateLanguageFileViewProvider) {\n      return;\n    }\n    \n    final FileType fileType = containingFile.getViewProvider().getVirtualFile().getFileType();\n    if (fileType != XmlFileType.INSTANCE && fileType != XHtmlFileType.INSTANCE) {\n      return;\n    }\n\n    for(Language lang: containingFile.getViewProvider().getLanguages()) {\n      if (\"ANT\".equals(lang.getID())) return;\n    }\n\n    final XmlTag rootTag = document.getRootTag();\n    if (rootTag == null) return;\n\n    String namespace = rootTag.getNamespace();\n    if (XmlUtil.ANT_URI.equals(namespace)) return;\n\n    final Project project = document.getProject();\n\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final LocalInspectionToolWrapper toolWrapper =\n      (LocalInspectionToolWrapper)profile.getInspectionTool(CheckXmlFileWithXercesValidatorInspection.SHORT_NAME, containingFile);\n\n    if (toolWrapper == null) return;\n    if (!profile.isToolEnabled(HighlightDisplayKey.find(CheckXmlFileWithXercesValidatorInspection.SHORT_NAME), containingFile)) return;\n\n    SoftReference<ExternalDocumentValidator> validatorReference = project.getUserData(validatorInstanceKey);\n    ExternalDocumentValidator validator = validatorReference != null? validatorReference.get() : null;\n\n    if(validator == null) {\n      validator = new ExternalDocumentValidator();\n      project.putUserData(validatorInstanceKey,new SoftReference<ExternalDocumentValidator>(validator));\n    }\n\n    validator.runJaxpValidation(document,host);\n  }","id":42207,"modified_method":"public static synchronized void doValidation(final XmlDocument document, final Validator.ValidationHost host) {\n    final PsiFile containingFile = document.getContainingFile();\n    if (containingFile == null) {\n      return;\n    }\n\n    if (containingFile.getViewProvider() instanceof TemplateLanguageFileViewProvider) {\n      return;\n    }\n    \n    final FileType fileType = containingFile.getViewProvider().getVirtualFile().getFileType();\n    if (fileType != XmlFileType.INSTANCE && fileType != XHtmlFileType.INSTANCE) {\n      return;\n    }\n\n    for(Language lang: containingFile.getViewProvider().getLanguages()) {\n      if (\"ANT\".equals(lang.getID())) return;\n    }\n\n    final XmlTag rootTag = document.getRootTag();\n    if (rootTag == null) return;\n\n    String namespace = rootTag.getNamespace();\n    if (XmlUtil.ANT_URI.equals(namespace)) return;\n\n    final Project project = document.getProject();\n\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final InspectionProfileEntry toolWrapper =\n      profile.getInspectionTool(CheckXmlFileWithXercesValidatorInspection.SHORT_NAME, containingFile);\n\n    if (toolWrapper == null) return;\n    if (!profile.isToolEnabled(HighlightDisplayKey.find(CheckXmlFileWithXercesValidatorInspection.SHORT_NAME), containingFile)) return;\n\n    SoftReference<ExternalDocumentValidator> validatorReference = project.getUserData(validatorInstanceKey);\n    ExternalDocumentValidator validator = validatorReference != null? validatorReference.get() : null;\n\n    if(validator == null) {\n      validator = new ExternalDocumentValidator();\n      project.putUserData(validatorInstanceKey,new SoftReference<ExternalDocumentValidator>(validator));\n    }\n\n    validator.runJaxpValidation(document,host);\n  }","commit_id":"ee89b065d216529201d737357c2cae61d813fe37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XSModel getXSModel(String... files) {\n    myFixture.configureByFiles(files);\n\n    XmlFile file = (XmlFile)myFixture.getFile();\n    ValidateXmlActionHandler handler = new ValidateXmlActionHandler(false) {\n      @Override\n      protected SAXParser createParser() throws SAXException, ParserConfigurationException {\n        SAXParser parser = super.createParser();\n        parser.getXMLReader().setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE, true);\n        return parser;\n      }\n    };\n    handler.setErrorReporter(handler.new TestErrorReporter());\n    handler.doValidate(file);\n    XMLGrammarPool grammarPool = ValidateXmlActionHandler.getGrammarPool(file);\n    assert grammarPool != null;\n    Grammar[] grammars = grammarPool.retrieveInitialGrammarSet(XMLGrammarDescription.XML_SCHEMA);\n    XSGrammar grammar = (XSGrammar)grammars[0];\n    return grammar.toXSModel();\n  }","id":42208,"modified_method":"private XSModel getXSModel(String... files) {\n    myFixture.configureByFiles(files);\n\n    XmlFile file = (XmlFile)myFixture.getFile();\n    ValidateXmlActionHandler handler = new ValidateXmlActionHandler(false) {\n      @Override\n      protected SAXParser createParser() throws SAXException, ParserConfigurationException {\n        SAXParser parser = super.createParser();\n        parser.getXMLReader().setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE, true);\n        return parser;\n      }\n    };\n    handler.setErrorReporter(new TestErrorReporter(handler));\n    handler.doValidate(file);\n    XMLGrammarPool grammarPool = ValidateXmlActionHandler.getGrammarPool(file);\n    assert grammarPool != null;\n    Grammar[] grammars = grammarPool.retrieveInitialGrammarSet(XMLGrammarDescription.XML_SCHEMA);\n    XSGrammar grammar = (XSGrammar)grammars[0];\n    return grammar.toXSModel();\n  }","commit_id":"ee89b065d216529201d737357c2cae61d813fe37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlResourceResolver(XmlFile _xmlFile, Project _project, final ValidateXmlActionHandler.ErrorReporter errorReporter) {\n    myFile = _xmlFile;\n    myProject = _project;\n    myErrorReporter = errorReporter;\n  }","id":42209,"modified_method":"public XmlResourceResolver(XmlFile _xmlFile, Project _project, final ErrorReporter errorReporter) {\n    myFile = _xmlFile;\n    myProject = _project;\n    myErrorReporter = errorReporter;\n  }","commit_id":"ee89b065d216529201d737357c2cae61d813fe37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static XSModel getXSModel(XmlFile file) {\n\n    ValidateXmlActionHandler handler = new ValidateXmlActionHandler(false) {\n      @Override\n      protected SAXParser createParser() throws SAXException, ParserConfigurationException {\n        SAXParser parser = super.createParser();\n        parser.getXMLReader().setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE, true);\n        return parser;\n      }\n    };\n    handler.setErrorReporter(handler.new ErrorReporter() {\n\n      int count;\n      @Override\n      public void processError(SAXParseException ex, ValidateXmlActionHandler.ProblemType warning) throws SAXException {\n        if (warning != ValidateXmlActionHandler.ProblemType.WARNING && count++ > 100) {\n          throw new SAXException(ex);\n        }\n      }\n\n      @Override\n      public boolean isUniqueProblem(SAXParseException e) {\n        return true;\n      }\n    });\n\n    handler.doValidate(file);\n    XMLGrammarPool grammarPool = ValidateXmlActionHandler.getGrammarPool(file);\n    if (grammarPool == null) {\n      return null;\n    }\n    Grammar[] grammars = grammarPool.retrieveInitialGrammarSet(XMLGrammarDescription.XML_SCHEMA);\n\n    return grammars.length == 0 ? null : ((XSGrammar)grammars[0]).toXSModel(ContainerUtil.map(grammars, new Function<Grammar, XSGrammar>() {\n      @Override\n      public XSGrammar fun(Grammar grammar) {\n        return (XSGrammar)grammar;\n      }\n    }, new XSGrammar[0]));\n  }","id":42210,"modified_method":"@Nullable\n  private static XSModel getXSModel(XmlFile file) {\n\n    ValidateXmlActionHandler handler = new ValidateXmlActionHandler(false) {\n      @Override\n      protected SAXParser createParser() throws SAXException, ParserConfigurationException {\n        SAXParser parser = super.createParser();\n        parser.getXMLReader().setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE, true);\n        return parser;\n      }\n    };\n    handler.setErrorReporter(new ErrorReporter(handler) {\n\n      int count;\n      @Override\n      public void processError(SAXParseException ex, ValidateXmlActionHandler.ProblemType warning) throws SAXException {\n        if (warning != ValidateXmlActionHandler.ProblemType.WARNING && count++ > 100) {\n          throw new SAXException(ex);\n        }\n      }\n\n      @Override\n      public boolean isUniqueProblem(SAXParseException e) {\n        return true;\n      }\n    });\n\n    handler.doValidate(file);\n    XMLGrammarPool grammarPool = ValidateXmlActionHandler.getGrammarPool(file);\n    if (grammarPool == null) {\n      return null;\n    }\n    Grammar[] grammars = grammarPool.retrieveInitialGrammarSet(XMLGrammarDescription.XML_SCHEMA);\n\n    return grammars.length == 0 ? null : ((XSGrammar)grammars[0]).toXSModel(ContainerUtil.map(grammars, new Function<Grammar, XSGrammar>() {\n      @Override\n      public XSGrammar fun(Grammar grammar) {\n        return (XSGrammar)grammar;\n      }\n    }, new XSGrammar[0]));\n  }","commit_id":"ee89b065d216529201d737357c2cae61d813fe37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void checkComponentProperties(Module module, final IComponent component, final FormErrorCollector collector) {\n    final GlobalSearchScope scope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n    final PsiManager psiManager = PsiManager.getInstance(module.getProject());\n    final PsiClass aClass = psiManager.findClass(component.getComponentClassName(), scope);\n    if (aClass == null) {\n      return;\n    }\n\n    for(final IProperty prop: component.getModifiedProperties()) {\n      final PsiMethod getter = PropertyUtil.findPropertyGetter(aClass, prop.getName(), false, true);\n      final Java15APIUsageInspection tool = (Java15APIUsageInspection)InspectionProjectProfileManager.getInstance(aClass.getProject()).getInspectionProfile(aClass)\n        .getInspectionTool(Java15APIUsageInspection.SHORT_NAME);\n      if (tool.isJava15ApiUsage(getter)) {\n        registerError(component, collector, prop, \"@since 1.5\");\n      } else if (tool.isJava16ApiUsage(getter)) {\n        registerError(component, collector, prop, \"@since 1.6\");\n      }\n    }\n  }","id":42211,"modified_method":"protected void checkComponentProperties(Module module, final IComponent component, final FormErrorCollector collector) {\n    final GlobalSearchScope scope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n    final PsiManager psiManager = PsiManager.getInstance(module.getProject());\n    final PsiClass aClass = psiManager.findClass(component.getComponentClassName(), scope);\n    if (aClass == null) {\n      return;\n    }\n\n    for(final IProperty prop: component.getModifiedProperties()) {\n      final PsiMethod getter = PropertyUtil.findPropertyGetter(aClass, prop.getName(), false, true);\n      InspectionProfileEntry profileEntry =\n        InspectionProjectProfileManager.getInstance(aClass.getProject()).getInspectionProfile(aClass)\n          .getInspectionTool(Java15APIUsageInspection.SHORT_NAME);\n      if (profileEntry instanceof LocalInspectionToolWrapper) {\n        profileEntry = ((LocalInspectionToolWrapper) profileEntry).getTool();\n      }\n      final Java15APIUsageInspection tool = (Java15APIUsageInspection)profileEntry;\n      if (tool.isJava15ApiUsage(getter)) {\n        registerError(component, collector, prop, \"@since 1.5\");\n      } else if (tool.isJava16ApiUsage(getter)) {\n        registerError(component, collector, prop, \"@since 1.6\");\n      }\n    }\n  }","commit_id":"b67382db2f5a1088745c14d7b3fb584f2e259333","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paint(final Graphics g,final JComponent c){\n    final StripeButton button=(StripeButton)c;\n\n    final String text=button.getText();\n    final Icon icon=(button.isEnabled()) ? button.getIcon() : button.getDisabledIcon();\n\n    if((icon==null)&&(text==null)){\n      return;\n    }\n\n    final FontMetrics fm=button.getFontMetrics(button.getFont());\n    ourViewInsets=c.getInsets(ourViewInsets);\n\n    ourViewRect.x=ourViewInsets.left;\n    ourViewRect.y=ourViewInsets.top;\n\n    final ToolWindowAnchor anchor=button.getWindowInfo().getAnchor();\n\n    // Use inverted height & width\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      ourViewRect.height=c.getWidth()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getHeight()-(ourViewInsets.top+ourViewInsets.bottom);\n    } else{\n      ourViewRect.height=c.getHeight()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getWidth()-(ourViewInsets.top+ourViewInsets.bottom);\n    }\n\n    ourIconRect.x=ourIconRect.y=ourIconRect.width=ourIconRect.height=0;\n    ourTextRect.x=ourTextRect.y=ourTextRect.width=ourTextRect.height=0;\n\n    final String clippedText=SwingUtilities.layoutCompoundLabel(\n      c,fm,text,icon,\n      button.getVerticalAlignment(),button.getHorizontalAlignment(),\n      button.getVerticalTextPosition(),button.getHorizontalTextPosition(),\n      ourViewRect,ourIconRect,ourTextRect,\n      button.getText()==null ? 0 : button.getIconTextGap()\n    );\n\n    // Paint button's background\n\n    final Graphics2D g2=(Graphics2D)g;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n    g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n\n    final ButtonModel model=button.getModel();\n\n    if (model.isArmed() && model.isPressed() || model.isSelected()) {\n      final Graphics2D g2d = (Graphics2D) g;\n      final GradientPaint paint;\n      if (ToolWindowAnchor.TOP == anchor || ToolWindowAnchor.BOTTOM == anchor) {\n        paint = new GradientPaint(0, 0, button.getBackground().darker(), 0, button.getHeight(), button.getBackground().brighter());\n      }\n      else {\n        paint = new GradientPaint(0, 0, button.getBackground().darker(), button.getWidth(), 0, button.getBackground().brighter());\n      }\n      g2d.setPaint(paint);\n      g2d.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n\n      g.setColor(Color.black);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n    else {\n      g.setColor(button.getBackground());\n      g.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n      g.setColor(Color.GRAY);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n\n    if (model.isRollover()) {\n      g.setColor(Color.darkGray);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n\n    AffineTransform tr=null;\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      tr=g2.getTransform();\n      if(ToolWindowAnchor.RIGHT==anchor){\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, ourIconRect.x);\n        }\n        g2.rotate(Math.PI/2);\n        g2.translate(0,-c.getWidth());\n      } else {\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, c.getHeight() - ourIconRect.x - icon.getIconHeight());\n        }\n        g2.rotate(-Math.PI/2);\n        g2.translate(-c.getHeight(),0);\n      }\n    }\n    else{\n      if(icon!=null){\n        icon.paintIcon(c,g2,ourIconRect.x,ourIconRect.y);\n      }\n    }\n\n    // paint text\n\n    if(text!=null){\n      if(model.isEnabled()){\n        if(model.isArmed()&&model.isPressed()||model.isSelected()){\n          g.setColor(button.getBackground());\n        } else{\n          g.setColor(button.getForeground());\n        }\n      } else{\n        g.setColor(button.getBackground().darker());\n      }\n      /* Draw the Text */\n      if(model.isEnabled()){\n        /*** paint the text normally */\n        g.setColor(button.getForeground());\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      } else{\n        /*** paint the text disabled ***/\n        if(model.isSelected()){\n          g.setColor(c.getBackground());\n        } else{\n          g.setColor(getDisabledTextColor());\n        }\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      }\n    }\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      g2.setTransform(tr);\n    }\n  }","id":42212,"modified_method":"public void paint(final Graphics g,final JComponent c){\n    final StripeButton button=(StripeButton)c;\n\n    final String text=button.getText();\n    final Icon icon=(button.isEnabled()) ? button.getIcon() : button.getDisabledIcon();\n\n    if((icon==null)&&(text==null)){\n      return;\n    }\n\n    final FontMetrics fm=button.getFontMetrics(button.getFont());\n    ourViewInsets=c.getInsets(ourViewInsets);\n\n    ourViewRect.x=ourViewInsets.left;\n    ourViewRect.y=ourViewInsets.top;\n\n    final ToolWindowAnchor anchor=button.getWindowInfo().getAnchor();\n\n    // Use inverted height & width\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      ourViewRect.height=c.getWidth()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getHeight()-(ourViewInsets.top+ourViewInsets.bottom);\n    } else{\n      ourViewRect.height=c.getHeight()-(ourViewInsets.left+ourViewInsets.right);\n      ourViewRect.width=c.getWidth()-(ourViewInsets.top+ourViewInsets.bottom);\n    }\n\n    ourIconRect.x=ourIconRect.y=ourIconRect.width=ourIconRect.height=0;\n    ourTextRect.x=ourTextRect.y=ourTextRect.width=ourTextRect.height=0;\n\n    final String clippedText=SwingUtilities.layoutCompoundLabel(\n      c,fm,text,icon,\n      button.getVerticalAlignment(),button.getHorizontalAlignment(),\n      button.getVerticalTextPosition(),button.getHorizontalTextPosition(),\n      ourViewRect,ourIconRect,ourTextRect,\n      button.getText()==null ? 0 : button.getIconTextGap()\n    );\n\n    // Paint button's background\n\n    final Graphics2D g2=(Graphics2D)g;\n    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);\n    g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);\n\n    final ButtonModel model=button.getModel();\n\n    final Color background = button.getBackground();\n    if (model.isArmed() && model.isPressed() || model.isSelected()) {\n      final Graphics2D g2d = (Graphics2D) g;\n      final GradientPaint paint;\n      if (ToolWindowAnchor.TOP == anchor || ToolWindowAnchor.BOTTOM == anchor) {\n        paint = new GradientPaint(0, 0, background.darker(), 0, button.getHeight(), background.brighter());\n      }\n      else {\n        paint = new GradientPaint(0, 0, background.darker(), button.getWidth(), 0, background.brighter());\n      }\n      g2d.setPaint(paint);\n      g2d.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n\n      g.setColor(Color.black);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n    else {\n      g.setColor(background);\n      g.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n      g.setColor(Color.GRAY);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n\n    if (model.isRollover()) {\n      if (!model.isArmed() && !model.isPressed() && !model.isSelected()) {\n        final Graphics2D g2d = (Graphics2D) g;\n        final GradientPaint paint;\n        if (ToolWindowAnchor.TOP == anchor || ToolWindowAnchor.BOTTOM == anchor) {\n          paint = new GradientPaint(0, 0, background, 0, button.getHeight(), Color.white);\n        }\n        else {\n          paint = new GradientPaint(0, 0, background, button.getWidth(), 0, Color.white);\n        }\n        g2d.setPaint(paint);\n        g2d.fillRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n      }\n\n      g.setColor(Color.darkGray);\n      g.drawRoundRect(3, 3, button.getWidth() - 6, button.getHeight() - 6, 5, 5);\n    }\n\n    AffineTransform tr=null;\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      tr=g2.getTransform();\n      if(ToolWindowAnchor.RIGHT==anchor){\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, ourIconRect.x);\n        }\n        g2.rotate(Math.PI/2);\n        g2.translate(0,-c.getWidth());\n      } else {\n        if(icon != null){ // do not rotate icon\n          icon.paintIcon(c, g2, ourIconRect.y, c.getHeight() - ourIconRect.x - icon.getIconHeight());\n        }\n        g2.rotate(-Math.PI/2);\n        g2.translate(-c.getHeight(),0);\n      }\n    }\n    else{\n      if(icon!=null){\n        icon.paintIcon(c,g2,ourIconRect.x,ourIconRect.y);\n      }\n    }\n\n    // paint text\n\n    if(text!=null){\n      if(model.isEnabled()){\n        if(model.isArmed()&&model.isPressed()||model.isSelected()){\n          g.setColor(background);\n        } else{\n          g.setColor(button.getForeground());\n        }\n      } else{\n        g.setColor(background.darker());\n      }\n      /* Draw the Text */\n      if(model.isEnabled()){\n        /*** paint the text normally */\n        g.setColor(button.getForeground());\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      } else{\n        /*** paint the text disabled ***/\n        if(model.isSelected()){\n          g.setColor(c.getBackground());\n        } else{\n          g.setColor(getDisabledTextColor());\n        }\n        BasicGraphicsUtils.drawString(g,clippedText,button.getMnemonic2(),ourTextRect.x,ourTextRect.y+fm.getAscent());\n      }\n    }\n    if(ToolWindowAnchor.RIGHT==anchor||ToolWindowAnchor.LEFT==anchor){\n      g2.setTransform(tr);\n    }\n  }","commit_id":"0fd7401b560675b0612c394d741bb9e22d5b6a96","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paintBorder(Graphics g, JComponent component, int state) {\n    if (state == ActionButtonComponent.NORMAL) return;\n    Rectangle r = new Rectangle(component.getWidth(), component.getHeight());\n\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      if (state == ActionButtonComponent.POPPED) {\n        g.setColor(ALPHA_30);\n        g.drawRoundRect(r.x, r.y, r.width - 2, r.height - 2, 4, 4);\n      }\n    }\n    else {\n      g.setColor(UIUtil.getPanelBackground().darker().darker());\n      ((Graphics2D)g).setStroke(BASIC_STROKE);\n      g.drawRoundRect(r.x, r.y, r.width - 2, r.height - 2, 4, 4);\n    }\n  }","id":42213,"modified_method":"public void paintBorder(Graphics g, JComponent component, int state) {\n    if (state == ActionButtonComponent.NORMAL) return;\n    Rectangle r = new Rectangle(component.getWidth(), component.getHeight());\n\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      if (state == ActionButtonComponent.POPPED) {\n        g.setColor(ALPHA_30);\n        g.drawRoundRect(r.x, r.y, r.width - 2, r.height - 2, 4, 4);\n      }\n    }\n    else {\n      final double shift = UIUtil.isUnderDarcula() ? 1/0.49 : 0.49;\n      g.setColor(ColorUtil.shift(UIUtil.getPanelBackground(), shift));\n      ((Graphics2D)g).setStroke(BASIC_STROKE);\n      final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n      g.drawRoundRect(r.x, r.y, r.width - 2, r.height - 2, 4, 4);\n      config.restore();\n    }\n  }","commit_id":"9d798bf7c26d3c2f3105530ec6a8cf28cc2cdf4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paintBackground(Graphics g, JComponent component, int state) {\n    if (state == ActionButtonComponent.NORMAL) return;\n    Dimension dimension = component.getSize();\n\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      if (state == ActionButtonComponent.PUSHED) {\n        ((Graphics2D)g).setPaint(new GradientPaint(0, 0, ALPHA_40, dimension.width, dimension.height, ALPHA_20));\n        g.fillRect(0, 0, dimension.width - 1, dimension.height - 1);\n\n        g.setColor(ALPHA_120);\n        g.drawLine(0, 0, 0, dimension.height - 2);\n        g.drawLine(1, 0, dimension.width - 2, 0);\n\n        g.setColor(ALPHA_30);\n        g.drawRect(1, 1, dimension.width - 3, dimension.height - 3);\n      }\n      else if (state == ActionButtonComponent.POPPED) {\n        ((Graphics2D)g).setPaint(new GradientPaint(0, 0, Gray._235, 0, dimension.height, Gray._200));\n        g.fillRect(1, 1, dimension.width - 3, dimension.height - 3);\n      }\n    }\n    else {\n      g.setColor(state == ActionButtonComponent.PUSHED ? UIUtil.getPanelBackground().darker() : ALPHA_40);\n      g.fillRect(1, 1, dimension.width - 2, dimension.height - 2);\n    }\n  }","id":42214,"modified_method":"public void paintBackground(Graphics g, JComponent component, int state) {\n    if (state == ActionButtonComponent.NORMAL) return;\n    Dimension dimension = component.getSize();\n\n    if (UIUtil.isUnderAquaLookAndFeel()) {\n      if (state == ActionButtonComponent.PUSHED) {\n        ((Graphics2D)g).setPaint(new GradientPaint(0, 0, ALPHA_40, dimension.width, dimension.height, ALPHA_20));\n        g.fillRect(0, 0, dimension.width - 1, dimension.height - 1);\n\n        g.setColor(ALPHA_120);\n        g.drawLine(0, 0, 0, dimension.height - 2);\n        g.drawLine(1, 0, dimension.width - 2, 0);\n\n        g.setColor(ALPHA_30);\n        g.drawRect(1, 1, dimension.width - 3, dimension.height - 3);\n      }\n      else if (state == ActionButtonComponent.POPPED) {\n        ((Graphics2D)g).setPaint(new GradientPaint(0, 0, Gray._235, 0, dimension.height, Gray._200));\n        g.fillRect(1, 1, dimension.width - 3, dimension.height - 3);\n      }\n    }\n    else {\n      final Color bg = UIUtil.getPanelBackground();\n      final boolean dark = UIUtil.isUnderDarcula();\n      g.setColor(state == ActionButtonComponent.PUSHED ? ColorUtil.shift(bg, dark ? 1d / 0.7d : 0.7d) : dark ? Gray._255.withAlpha(40) : ALPHA_40);\n      g.fillRect(1, 1, dimension.width - 2, dimension.height - 2);\n    }\n  }","commit_id":"9d798bf7c26d3c2f3105530ec6a8cf28cc2cdf4e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    if (mySelectedCell != null) {\n      g.setColor(mySelectedCell.isEditing() ? JBColor.GREEN : JBColor.GRAY);\n      g.drawRoundRect(100, mySelectedCell.getTop() - 1, getWidth() - 200, mySelectedCell.getHeight() + 2, 5, 5);\n    }\n  }","id":42215,"modified_method":"@Override\n  protected void paintComponent(Graphics g) {\n    super.paintComponent(g);\n    if (mySelectedCell != null) {\n      g.setColor(mySelectedCell.isEditing() ? JBColor.GREEN : JBColor.GRAY);\n      if (mySelectedCell instanceof IpnbCodePanel) {\n        g.drawRoundRect(mySelectedCell.getX() - 50, mySelectedCell.getTop() - 1,\n                        mySelectedCell.getWidth() + 145 - IpnbEditorUtil.PROMPT_SIZE.width, mySelectedCell.getHeight() + 2, 5, 5);\n      }\n      else {\n        g.drawRoundRect(mySelectedCell.getX() - IpnbEditorUtil.PROMPT_SIZE.width - 55, mySelectedCell.getTop() - 1,\n                        mySelectedCell.getWidth() + 150, mySelectedCell.getHeight() + 2, 5, 5);\n      }\n    }\n  }","commit_id":"bd633f88326faf512533dceedd00fd86c1e2bb9a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n    final Graphics2D g2d = (Graphics2D)g;\n    final Insets ins = getBorderInsets(c);\n    final int yOff = (ins.top + ins.bottom) / 4;\n    final boolean square = DarculaButtonUI.isSquare(c);\n    int offset = square ? 1 : getOffset();\n    if (c.hasFocus()) {\n      DarculaUIUtil.paintFocusRing(g2d, offset, yOff, width - 2 * offset, height - 2 * yOff);\n    } else {\n      final GraphicsConfig config = new GraphicsConfig(g);\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n      g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);\n      g2d.setPaint(UIUtil.getGradientPaint(width / 2, y + yOff + 1, Gray._80.withAlpha(90), width / 2, height - 2 * yOff, Gray._90.withAlpha(90)));\n      //g.drawRoundRect(x + offset + 1, y + yOff + 1, width - 2 * offset, height - 2*yOff, 5, 5);\n\n      ((Graphics2D)g).setPaint(Gray._100.withAlpha(180));\n      g.drawRoundRect(x + offset, y + yOff, width - 2 * offset, height - 2*yOff, square ? 3 : 5, square ? 3 : 5);\n\n      config.restore();\n    }\n  }","id":42216,"modified_method":"@Override\n  public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n    final Graphics2D g2d = (Graphics2D)g;\n    final Insets ins = getBorderInsets(c);\n    final int yOff = (ins.top + ins.bottom) / 4;\n    final boolean square = DarculaButtonUI.isSquare(c);\n    int offset = square ? 1 : getOffset();\n    if (c.hasFocus()) {\n      if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n        int w = c.getWidth();\n        int h = c.getHeight();\n        DarculaUIUtil.paintFocusOval(g2d, (w - 22) / 2, (h - 22) / 2, 22, 22);\n      } else {\n        DarculaUIUtil.paintFocusRing(g2d, offset, yOff, width - 2 * offset, height - 2 * yOff);\n      }\n    } else {\n      final GraphicsConfig config = new GraphicsConfig(g);\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n      g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);\n      g2d.setPaint(UIUtil.getGradientPaint(width / 2, y + yOff + 1, Gray._80.withAlpha(90), width / 2, height - 2 * yOff, Gray._90.withAlpha(90)));\n      //g.drawRoundRect(x + offset + 1, y + yOff + 1, width - 2 * offset, height - 2*yOff, 5, 5);\n      ((Graphics2D)g).setPaint(Gray._100.withAlpha(180));\n      if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n        int w = c.getWidth();\n        int h = c.getHeight();\n        g.drawOval((w - 22) / 2, (h - 22) / 2, 22, 22);\n      } else {\n        g.drawRoundRect(x + offset, y + yOff, width - 2 * offset, height - 2 * yOff, square ? 3 : 5, square ? 3 : 5);\n      }\n\n      config.restore();\n    }\n  }","commit_id":"d250fde95786bc677b97a453055790f7dcacf7f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void paintText(Graphics g, JComponent c, Rectangle textRect, String text) {\n    AbstractButton button = (AbstractButton)c;\n    ButtonModel model = button.getModel();\n    Color fg = button.getForeground();\n    if (fg instanceof UIResource && button instanceof JButton && ((JButton)button).isDefaultButton()) {\n      final Color selectedFg = UIManager.getColor(\"Button.darcula.selectedButtonForeground\");\n      if (selectedFg != null) {\n        fg = selectedFg;\n      }\n    }\n    g.setColor(fg);\n\n    FontMetrics metrics = SwingUtilities2.getFontMetrics(c, g);\n    int mnemonicIndex = button.getDisplayedMnemonicIndex();\n    if (model.isEnabled()) {\n\n      SwingUtilities2.drawStringUnderlineCharAt(c, g, text, mnemonicIndex,\n                                                textRect.x + getTextShiftOffset(),\n                                                textRect.y + metrics.getAscent() + getTextShiftOffset());\n    }\n    else {\n      g.setColor(UIManager.getColor(\"Button.darcula.disabledText.shadow\"));\n      SwingUtilities2.drawStringUnderlineCharAt(c, g, text, -1,\n                                                textRect.x + getTextShiftOffset()+1,\n                                                textRect.y + metrics.getAscent() + getTextShiftOffset()+1);\n      g.setColor(UIManager.getColor(\"Button.disabledText\"));\n      SwingUtilities2.drawStringUnderlineCharAt(c, g, text, -1,\n                                                textRect.x + getTextShiftOffset(),\n                                                textRect.y + metrics.getAscent() + getTextShiftOffset());\n\n\n    }\n  }","id":42217,"modified_method":"protected void paintText(Graphics g, JComponent c, Rectangle textRect, String text) {\n    if (isHelpButton(c)) {\n      return;\n    }\n    \n    AbstractButton button = (AbstractButton)c;\n    ButtonModel model = button.getModel();\n    Color fg = button.getForeground();\n    if (fg instanceof UIResource && button instanceof JButton && ((JButton)button).isDefaultButton()) {\n      final Color selectedFg = UIManager.getColor(\"Button.darcula.selectedButtonForeground\");\n      if (selectedFg != null) {\n        fg = selectedFg;\n      }\n    }\n    g.setColor(fg);\n\n    FontMetrics metrics = SwingUtilities2.getFontMetrics(c, g);\n    int mnemonicIndex = button.getDisplayedMnemonicIndex();\n    if (model.isEnabled()) {\n\n      SwingUtilities2.drawStringUnderlineCharAt(c, g, text, mnemonicIndex,\n                                                textRect.x + getTextShiftOffset(),\n                                                textRect.y + metrics.getAscent() + getTextShiftOffset());\n    }\n    else {\n      g.setColor(UIManager.getColor(\"Button.darcula.disabledText.shadow\"));\n      SwingUtilities2.drawStringUnderlineCharAt(c, g, text, -1,\n                                                textRect.x + getTextShiftOffset()+1,\n                                                textRect.y + metrics.getAscent() + getTextShiftOffset()+1);\n      g.setColor(UIManager.getColor(\"Button.disabledText\"));\n      SwingUtilities2.drawStringUnderlineCharAt(c, g, text, -1,\n                                                textRect.x + getTextShiftOffset(),\n                                                textRect.y + metrics.getAscent() + getTextShiftOffset());\n\n\n    }\n  }","commit_id":"d250fde95786bc677b97a453055790f7dcacf7f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void paint(Graphics g, JComponent c) {\n    final Border border = c.getBorder();\n    final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n    final boolean square = isSquare(c);\n    if (c.isEnabled() && border != null) {\n      final Insets ins = border.getBorderInsets(c);\n      final int yOff = (ins.top + ins.bottom) / 4;\n      if (!square) {\n        if (c instanceof JButton && ((JButton)c).isDefaultButton()) {\n          ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getSelectedButtonColor1(), 0, c.getHeight(), getSelectedButtonColor2()));\n        }\n        else {\n          ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getButtonColor1(), 0, c.getHeight(), getButtonColor2()));\n        }\n      }\n      g.fillRoundRect(square ? 2 : 4, yOff, c.getWidth() - 2 * 4, c.getHeight() - 2 * yOff, square ? 3 : 5, square ? 3 : 5);\n    }\n    config.restore();\n    super.paint(g, c);\n  }","id":42218,"modified_method":"@Override\n  public void paint(Graphics g, JComponent c) {\n    int w = c.getWidth();\n    int h = c.getHeight();\n    if (isHelpButton(c)) {\n      ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getButtonColor1(), 0, h, getButtonColor2()));\n      int x = (w - 22) / 2;\n      int y = (h - 22) / 2;\n      g.fillOval(x, y, 22, 22);\n      AllIcons.Actions.Help.paintIcon(c, g, x + 3, y + 3);\n    } else {\n      final Border border = c.getBorder();\n      final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n      final boolean square = isSquare(c);\n      if (c.isEnabled() && border != null) {\n        final Insets ins = border.getBorderInsets(c);\n        final int yOff = (ins.top + ins.bottom) / 4;\n        if (!square) {\n          if (c instanceof JButton && ((JButton)c).isDefaultButton()) {\n            ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getSelectedButtonColor1(), 0, h, getSelectedButtonColor2()));\n          }\n          else {\n            ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getButtonColor1(), 0, h, getButtonColor2()));\n          }\n        }\n        g.fillRoundRect(square ? 2 : 4, yOff, w - 2 * 4, h - 2 * yOff, square ? 3 : 5, square ? 3 : 5);\n      }\n      config.restore();\n      super.paint(g, c);\n    }\n  }","commit_id":"d250fde95786bc677b97a453055790f7dcacf7f5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void paintFeedback(Graphics g) {\n    Dimension size = getSize();\n    for (int i = 0; i < myLine; i++) {\n      g.drawRoundRect(i, i, size.width - i - i - 1, size.height - i - i - 1, myRadius, myRadius);\n    }\n  }","id":42219,"modified_method":"@Override\n  protected void paintFeedback(Graphics g) {\n    Graphics2D g2d = (Graphics2D)g;\n\n    Stroke oldStroke = g2d.getStroke();\n    g2d.setStroke(STROKE);\n    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n    Dimension size = getSize();\n    g.drawRoundRect(0, 0, size.width - 1, size.height - 1, myRadius, myRadius);\n\n    g2d.setStroke(oldStroke);\n  }","commit_id":"69f8e74aa8e95f57730131c55c9dac1022ef1cd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isChildren(RadComponent component) {\n    for (Object child : myContainer.getTreeChildren()) {\n      if (child == component) {\n        return true;\n      }\n    }\n    return false;\n  }","id":42220,"modified_method":"protected final boolean isChildren(RadComponent component) {\n    return ArrayUtil.indexOf(myContainer.getTreeChildren(), component) != -1;\n  }","commit_id":"69f8e74aa8e95f57730131c55c9dac1022ef1cd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void paint(Graphics2D g, int x, int y, int width, int height) {\n      Object old = g.getRenderingHint(RenderingHints.KEY_ANTIALIASING);\n      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n      x += myBorder;\n      y += myBorder;\n      width -= myBorder + myBorder;\n      height -= myBorder + myBorder;\n\n      int arc = Math.min(width, height);\n      if (myFillColor != null) {\n        g.setColor(myFillColor);\n        g.fillRoundRect(x, y, width, height, arc, arc);\n      }\n      if (myDrawColor != null) {\n        g.setColor(myDrawColor);\n        g.drawRoundRect(x, y, width - 1, height - 1, arc, arc);\n      }\n      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, old);\n    }","id":42221,"modified_method":"@Override\n    protected void paint(Graphics2D g, int x, int y, int width, int height) {\n      Object old = g.getRenderingHint(RenderingHints.KEY_ANTIALIASING);\n      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n      x += myBorder;\n      y += myBorder;\n      width -= myBorder + myBorder;\n      height -= myBorder + myBorder;\n\n      int arc = Math.min(width, height);\n      if (myFillColor != null) {\n        g.setColor(myFillColor);\n        g.fillRoundRect(x, y, width, height, arc, arc);\n      }\n      if (myDrawColor != null) {\n        g.setColor(myDrawColor);\n        if (UIUtil.isRetina(g)) {\n          g.draw(new RoundRectangle2D.Double(.5 + x, .5 + y, width - 1, height - 1, arc, arc));\n        }\n        else {\n          g.drawRoundRect(x, y, width - 1, height - 1, arc, arc);\n        }\n      }\n      g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, old);\n    }","commit_id":"2485a4ada6e8700c24b88ff8ea38804898263b3d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Insets getBorderInsets(Component c) {\n    if (DarculaButtonUI.isSquare(c)) {\n      return new InsetsUIResource(2, 0, 2, 0);\n    }\n    return new InsetsUIResource(8, 16, 8, 14);\n  }","id":42222,"modified_method":"@Override\n  public Insets getBorderInsets(Component c) {\n    if (DarculaButtonUI.isSquare(c)) {\n      return JBUI.insets(2, 0, 2, 0).asUIResource();\n    }\n    return JBUI.insets(8, 16, 8, 14).asUIResource();\n  }","commit_id":"6087c0591373c64701afbad70acb5696c5b50ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n    final Graphics2D g2d = (Graphics2D)g;\n    final Insets ins = getBorderInsets(c);\n    final int yOff = (ins.top + ins.bottom) / 4;\n    final boolean square = DarculaButtonUI.isSquare(c);\n    int offset = square ? 1 : getOffset();\n    if (c.hasFocus()) {\n      if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n        int w = c.getWidth();\n        int h = c.getHeight();\n        DarculaUIUtil.paintFocusOval(g2d, (w - 22) / 2, (h - 22) / 2, 22, 22);\n      } else {\n        DarculaUIUtil.paintFocusRing(g2d, offset, yOff, width - 2 * offset, height - 2 * yOff);\n      }\n    } else {\n      final GraphicsConfig config = new GraphicsConfig(g);\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n      g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);\n      g2d.setPaint(UIUtil.getGradientPaint(width / 2, y + yOff + 1, Gray._80.withAlpha(90), width / 2, height - 2 * yOff, Gray._90.withAlpha(90)));\n      //g.drawRoundRect(x + offset + 1, y + yOff + 1, width - 2 * offset, height - 2*yOff, 5, 5);\n      ((Graphics2D)g).setPaint(Gray._100.withAlpha(180));\n      if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n        int w = c.getWidth();\n        int h = c.getHeight();\n        g.drawOval((w - 22) / 2, (h - 22) / 2, 22, 22);\n      } else {\n        g.drawRoundRect(x + offset, y + yOff, width - 2 * offset, height - 2 * yOff, square ? 3 : 5, square ? 3 : 5);\n      }\n\n      config.restore();\n    }\n  }","id":42223,"modified_method":"@Override\n  public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n    final Graphics2D g2d = (Graphics2D)g;\n    final Insets ins = getBorderInsets(c);\n    final int yOff = (ins.top + ins.bottom) / 4;\n    final boolean square = DarculaButtonUI.isSquare(c);\n    int offset = JBUI.scale(square ? 1 : getOffset());\n    int w = c.getWidth();\n    int h = c.getHeight();\n    int diam = JBUI.scale(22);\n\n    if (c.hasFocus()) {\n      if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n          DarculaUIUtil.paintFocusOval(g2d, (w - diam) / 2, (h - diam) / 2, diam, diam);\n      } else {\n        DarculaUIUtil.paintFocusRing(g2d, offset, yOff, width - 2 * offset, height - 2 * yOff);\n      }\n    } else {\n      final GraphicsConfig config = new GraphicsConfig(g);\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n      g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_DEFAULT);\n      g2d.setPaint(UIUtil.getGradientPaint(width / 2, y + yOff + JBUI.scale(1), Gray._80.withAlpha(90), width / 2, height - 2 * yOff, Gray._90.withAlpha(90)));\n      //g.drawRoundRect(x + offset + 1, y + yOff + 1, width - 2 * offset, height - 2*yOff, 5, 5);\n      ((Graphics2D)g).setPaint(Gray._100.withAlpha(180));\n      if (DarculaButtonUI.isHelpButton((JComponent)c)) {\n        g.drawOval((w - diam) / 2, (h - diam) / 2, diam, diam);\n      } else {\n        g.translate(x,y);\n        int r = JBUI.scale(square ? 3 : 5);\n        g.drawRoundRect(offset, yOff, width - 2 * offset, height - 2 * yOff, r, r);\n        g.translate(-x,-y);\n      }\n\n      config.restore();\n    }\n  }","commit_id":"6087c0591373c64701afbad70acb5696c5b50ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PortalRenderEngine getRenderEngine(String context, HttpServletRequest request)\n\t{\n\t\t// at this point we ignore request but we might use ut to return more\n\t\t// than one render engine\n\n\t\tif (context == null || context.length() == 0)\n\t\t{\n\t\t\tcontext = Portal.DEFAULT_PORTAL_CONTEXT;\n\t\t}\n\n\t\treturn (PortalRenderEngine) safeGet(renderEngines, context);\n\t}","id":42224,"modified_method":"public PortalRenderEngine getRenderEngine(String context, HttpServletRequest request)\n\t{\n\t\t// at this point we ignore request but we might use ut to return more\n\t\t// than one render engine\n\n\t\tif (context == null || context.length() == 0)\n\t\t{\n\t\t\tcontext = Portal.DEFAULT_PORTAL_CONTEXT;\n\t\t}\n\n\t\treturn (PortalRenderEngine) renderEngines.get(context);\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void addPortal(Portal portal)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tsafePut(portals, portalContext, portal);\n\t\t// reconnect any handlers\n\t\tMap<String, PortalHandler> phm = getHandlerMap(portal);\n\t\tfor (Iterator<PortalHandler> pIterator = phm.values().iterator(); pIterator\n\t\t\t\t.hasNext();)\n\t\t{\n\t\t\tPortalHandler ph = pIterator.next();\n\t\t\tph.register(portal, this, portal.getServletContext());\n\t\t}\n\t}","id":42225,"modified_method":"public void addPortal(Portal portal)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tportals.put(portalContext, portal);\n\t\t// reconnect any handlers\n\t\tMap<String, PortalHandler> phm = getHandlerMap(portal);\n\t\tfor (Iterator<PortalHandler> pIterator = phm.values().iterator(); pIterator\n\t\t\t\t.hasNext();)\n\t\t{\n\t\t\tPortalHandler ph = pIterator.next();\n\t\t\tph.register(portal, this, portal.getServletContext());\n\t\t}\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void addRenderEngine(String context, PortalRenderEngine vengine)\n\t{\n\n\t\tsafePut(renderEngines, context, vengine);\n\t}","id":42226,"modified_method":"public void addRenderEngine(String context, PortalRenderEngine vengine)\n\t{\n\n\t\trenderEngines.put(context, vengine);\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void removeRenderEngine(String context, PortalRenderEngine vengine)\n\t{\n\t\tsafePut(renderEngines, context, null);\n\t}","id":42227,"modified_method":"public void removeRenderEngine(String context, PortalRenderEngine vengine)\n\t{\n\t\trenderEngines.put(context, null);\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void removeHandler(Portal portal, String urlFragment)\n\t{\n\t\tMap<String, PortalHandler> handlerMap = getHandlerMap(portal, false);\n\t\tif (handlerMap != null)\n\t\t{\n\t\t\tPortalHandler ph = (PortalHandler) safeGet(handlerMap, urlFragment);\n\t\t\tif (ph != null)\n\t\t\t{\n\t\t\t\tph.deregister(portal);\n\t\t\t\tsafePut(handlerMap, urlFragment, null);\n\t\t\t\tlog.warn(\"Handler Present on  \" + urlFragment + \" \" + ph\n\t\t\t\t\t\t+ \" will be removed \");\n\t\t\t}\n\t\t}\n\t}","id":42228,"modified_method":"public void removeHandler(Portal portal, String urlFragment)\n\t{\n\t\tMap<String, PortalHandler> handlerMap = getHandlerMap(portal.getPortalContext(), false);\n\t\tif (handlerMap != null)\n\t\t{\n\t\t\tPortalHandler ph = handlerMap.get(urlFragment);\n\t\t\tif (ph != null)\n\t\t\t{\n\t\t\t\tph.deregister(portal);\n\t\t\t\thandlerMap.put(urlFragment, null);\n\t\t\t\tlog.warn(\"Handler Present on  \" + urlFragment + \" \" + ph\n\t\t\t\t\t\t+ \" will be removed \");\n\t\t\t}\n\t\t}\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate Map<String, PortalHandler> getHandlerMap(Portal portal, boolean create)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tMap<String, PortalHandler> handlerMap = (Map<String, PortalHandler>) safeGet(\n\t\t\t\thandlerMaps, portalContext);\n\t\tif (create && handlerMap == null)\n\t\t{\n\t\t\thandlerMap = new HashMap<String, PortalHandler>();\n\t\t\tsafePut(handlerMaps, portalContext, handlerMap);\n\t\t}\n\t\treturn handlerMap;\n\t}","id":42229,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate Map<String, PortalHandler> getHandlerMap(String portalContext, boolean create)\n\t{\n\t\tMap<String, PortalHandler> handlerMap = handlerMaps.get(portalContext);\n\t\tif (create && handlerMap == null)\n\t\t{\n\t\t\thandlerMap = new ConcurrentHashMap<String, PortalHandler>();\n\t\t\thandlerMaps.put(portalContext, handlerMap);\n\t\t}\n\t\treturn handlerMap;\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void addHandler(Portal portal, PortalHandler handler)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tMap<String, PortalHandler> handlerMap = getHandlerMap(portal);\n\t\tString urlFragment = handler.getUrlFragment();\n\t\tPortalHandler ph = (PortalHandler) safeGet(handlerMap, urlFragment);\n\t\tif (ph != null)\n\t\t{\n\t\t\thandler.deregister(portal);\n\t\t\tlog.warn(\"Handler Present on  \" + urlFragment + \" will replace \" + ph\n\t\t\t\t\t+ \" with \" + handler);\n\t\t}\n\t\thandler.register(portal, this, portal.getServletContext());\n\t\tsafePut(handlerMap, urlFragment, handler);\n\n\t\tlog.info(\"URL \" + portalContext + \":/\" + urlFragment + \" will be handled by \"\n\t\t\t\t+ handler);\n\n\t}","id":42230,"modified_method":"public void addHandler(Portal portal, PortalHandler handler)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tMap<String, PortalHandler> handlerMap = getHandlerMap(portal);\n\t\tString urlFragment = handler.getUrlFragment();\n\t\tPortalHandler ph = handlerMap.get(urlFragment);\n\t\tif (ph != null)\n\t\t{\n\t\t\thandler.deregister(portal);\n\t\t\tlog.warn(\"Handler Present on  \" + urlFragment + \" will replace \" + ph\n\t\t\t\t\t+ \" with \" + handler);\n\t\t}\n\t\thandler.register(portal, this, portal.getServletContext());\n\t\thandlerMap.put(urlFragment, handler);\n\n\t\tlog.info(\"URL \" + portalContext + \":/\" + urlFragment + \" will be handled by \"\n\t\t\t\t+ handler);\n\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void removePortal(Portal portal)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tsafePut(portals, portalContext, null);\n\t}","id":42231,"modified_method":"public void removePortal(Portal portal)\n\t{\n\t\tString portalContext = portal.getPortalContext();\n\t\tportals.put(portalContext, null);\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Map<String, PortalHandler> getHandlerMap(Portal portal)\n\t{\n\t\treturn getHandlerMap(portal, true);\n\t}","id":42232,"modified_method":"public Map<String, PortalHandler> getHandlerMap(Portal portal)\n\t{\n\t\treturn getHandlerMap(portal.getPortalContext(), true);\n\t}","commit_id":"31f8efa6f829b60c1fa47d66874828d13037dc33","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected static long calculateUnsignedInt(byte value1, byte value2, byte value3, byte value4) {\n        return (calculateUnsignedByte(value1) << 24) + (calculateUnsignedByte(value2) << 16) + (calculateUnsignedByte(value3) << 8) + calculateUnsignedByte(value4);\n    }","id":42233,"modified_method":"protected static long calculateUnsignedInt(byte value1, byte value2, byte value3, byte value4) {\n        return (((long)calculateUnsignedByte(value1)) << 24)\n                + (((long)calculateUnsignedByte(value2)) << 16)\n                + (((long)calculateUnsignedByte(value3)) << 8)\n                + calculateUnsignedByte(value4);\n    }","commit_id":"b5625c05d04c7c886192ba9c3e8ed7c0b05ea482","url":"https://github.com/apache/cloudstack"},{"original_method":"public void deployDirectory(\n\t\t\tFile srcFile, File mergeDir, File deployDir, String displayName,\n\t\t\tboolean overwrite, PluginPackage pluginPackage)\n\t\tthrows Exception {\n\n\t\trewriteFiles(srcFile);\n\n\t\tmergeDirectory(mergeDir, srcFile);\n\n\t\tprocessPluginPackageProperties(srcFile, displayName, pluginPackage);\n\n\t\tcopyDtds(srcFile, pluginPackage);\n\t\tcopyJars(srcFile, pluginPackage);\n\t\tcopyProperties(srcFile, pluginPackage);\n\t\tcopyTlds(srcFile, pluginPackage);\n\t\tcopyXmls(srcFile, displayName, pluginPackage);\n\t\tcopyPortalDependencies(srcFile);\n\n\t\tupdateGeronimoWebXml(srcFile, displayName, pluginPackage);\n\n\t\tFile webXml = new File(srcFile + \"/WEB-INF/web.xml\");\n\n\t\tupdateWebXml(webXml, srcFile, displayName, pluginPackage);\n\n\t\tFile extLibGlobalDir = new File(\n\t\t\tsrcFile.getAbsolutePath() + \"/WEB-INF/ext-lib/global\");\n\n\t\tif (extLibGlobalDir.exists()) {\n\t\t\tFile globalLibDir = new File(PortalUtil.getGlobalLibDir());\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\textLibGlobalDir, globalLibDir, \"*.jar\", StringPool.BLANK,\n\t\t\t\toverwrite, true);\n\t\t}\n\n\t\tFile extLibPortalDir = new File(\n\t\t\tsrcFile.getAbsolutePath() + \"/WEB-INF/ext-lib/portal\");\n\n\t\tif (extLibPortalDir.exists()) {\n\t\t\tFile portalLibDir = new File(PortalUtil.getPortalLibDir());\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\textLibPortalDir, portalLibDir, \"*.jar\", StringPool.BLANK,\n\t\t\t\toverwrite, true);\n\t\t}\n\n\t\tif ((deployDir == null) || baseDir.equals(destDir)) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateDeployDirectory(srcFile);\n\n\t\tString excludes = StringPool.BLANK;\n\n\t\tif (appServerType.equals(ServerDetector.JBOSS_ID)) {\n\t\t\texcludes += \"**/WEB-INF/lib/log4j.jar,\";\n\t\t}\n\t\telse if (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\t\t\tString[] libs = FileUtil.listFiles(tomcatLibDir);\n\n\t\t\tfor (String lib : libs) {\n\t\t\t\texcludes += \"**/WEB-INF/lib/\" + lib + \",\";\n\t\t\t}\n\n\t\t\tFile contextXml = new File(srcFile + \"/META-INF/context.xml\");\n\n\t\t\tif (contextXml.exists()) {\n\t\t\t\tString content = FileUtil.read(contextXml);\n\n\t\t\t\tif (content.contains(_PORTAL_CLASS_LOADER)) {\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-bridges.jar,\";\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-java.jar,\";\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-taglib.jar,\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\t// LEP-2990\n\n\t\t\t\tClass.forName(\"javax.el.ELContext\");\n\n\t\t\t\texcludes += \"**/WEB-INF/lib/el-api.jar,\";\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\t}\n\t\t}\n\n\t\t// LPS-11268\n\n\t\tProperties properties = getPluginPackageProperties(srcFile);\n\n\t\tif (properties != null) {\n\t\t\tString deployExcludes = properties.getProperty(\"deploy-excludes\");\n\n\t\t\tif (deployExcludes != null) {\n\t\t\t\texcludes += deployExcludes.trim();\n\n\t\t\t\tif (!excludes.endsWith(\",\")) {\n\t\t\t\t\texcludes += \",\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdeployExcludes = properties.getProperty(\n\t\t\t\t\"deploy-excludes-\" + appServerType);\n\n\t\t\tif (deployExcludes != null) {\n\t\t\t\texcludes += deployExcludes.trim();\n\n\t\t\t\tif (!excludes.endsWith(\",\")) {\n\t\t\t\t\texcludes += \",\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Excludes \" + excludes);\n\t\t}\n\n\t\tif (!unpackWar) {\n\t\t\tFile tempDir = new File(\n\t\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) +\n\t\t\t\t\tFile.separator + Time.getTimestamp());\n\n\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\tWarTask.war(srcFile, tempDir, excludes, webXml);\n\n\t\t\tif (isJEEDeploymentEnabled()) {\n\t\t\t\tFile tempWarDir = new File(\n\t\t\t\t\ttempDir.getParent(), deployDir.getName());\n\n\t\t\t\tif (tempWarDir.exists()) {\n\t\t\t\t\ttempWarDir.delete();\n\t\t\t\t}\n\n\t\t\t\tif (!tempDir.renameTo(tempWarDir)) {\n\t\t\t\t\ttempWarDir = tempDir;\n\t\t\t\t}\n\n\t\t\t\tDeploymentHandler deploymentHandler = getDeploymentHandler();\n\n\t\t\t\tdeploymentHandler.deploy(tempWarDir, displayName);\n\n\t\t\t\tdeploymentHandler.releaseDeploymentManager();\n\n\t\t\t\tDeleteTask.deleteDirectory(tempWarDir);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!tempDir.renameTo(deployDir)) {\n\t\t\t\t\tWarTask.war(srcFile, deployDir, excludes, webXml);\n\t\t\t\t}\n\n\t\t\t\tDeleteTask.deleteDirectory(tempDir);\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// The deployer might only copy files that have been modified.\n\t\t\t// However, the deployer always copies and overwrites web.xml after\n\t\t\t// the other files have been copied because application servers\n\t\t\t// usually detect that a WAR has been modified based on the web.xml\n\t\t\t// timestamp.\n\n\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\tsrcFile, deployDir, StringPool.BLANK, excludes, overwrite,\n\t\t\t\ttrue);\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\tsrcFile, deployDir, \"**/WEB-INF/web.xml\", StringPool.BLANK,\n\t\t\t\ttrue, false);\n\n\t\t\tif (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\n\t\t\t\t// See org.apache.catalina.startup.HostConfig to see how Tomcat\n\t\t\t\t// checks to make sure that web.xml was modified 5 seconds after\n\t\t\t\t// WEB-INF\n\n\t\t\t\tFile deployWebXml = new File(deployDir + \"/WEB-INF/web.xml\");\n\n\t\t\t\tdeployWebXml.setLastModified(\n\t\t\t\t\tSystem.currentTimeMillis() + (Time.SECOND * 6));\n\t\t\t}\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JETTY_ID)) {\n\t\t\tDeployUtil.redeployJetty(displayName);\n\t\t}\n\t}","id":42234,"modified_method":"public void deployDirectory(\n\t\t\tFile srcFile, File mergeDir, File deployDir, String displayName,\n\t\t\tboolean overwrite, PluginPackage pluginPackage)\n\t\tthrows Exception {\n\n\t\trewriteFiles(srcFile);\n\n\t\tmergeDirectory(mergeDir, srcFile);\n\n\t\tprocessPluginPackageProperties(srcFile, displayName, pluginPackage);\n\n\t\tcopyDtds(srcFile, pluginPackage);\n\t\tcopyJars(srcFile, pluginPackage);\n\t\tcopyProperties(srcFile, pluginPackage);\n\t\tcopyTlds(srcFile, pluginPackage);\n\t\tcopyXmls(srcFile, displayName, pluginPackage);\n\t\tcopyPortalDependencies(srcFile);\n\n\t\tupdateGeronimoWebXml(srcFile, displayName, pluginPackage);\n\n\t\tFile webXml = new File(srcFile + \"/WEB-INF/web.xml\");\n\n\t\tupdateWebXml(webXml, srcFile, displayName, pluginPackage);\n\n\t\tFile extLibGlobalDir = new File(\n\t\t\tsrcFile.getAbsolutePath() + \"/WEB-INF/ext-lib/global\");\n\n\t\tif (extLibGlobalDir.exists()) {\n\t\t\tFile globalLibDir = new File(PortalUtil.getGlobalLibDir());\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\textLibGlobalDir, globalLibDir, \"*.jar\", StringPool.BLANK,\n\t\t\t\toverwrite, true);\n\t\t}\n\n\t\tFile extLibPortalDir = new File(\n\t\t\tsrcFile.getAbsolutePath() + \"/WEB-INF/ext-lib/portal\");\n\n\t\tif (extLibPortalDir.exists()) {\n\t\t\tFile portalLibDir = new File(PortalUtil.getPortalLibDir());\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\textLibPortalDir, portalLibDir, \"*.jar\", StringPool.BLANK,\n\t\t\t\toverwrite, true);\n\t\t}\n\n\t\tif ((deployDir == null) || baseDir.equals(destDir)) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateDeployDirectory(srcFile);\n\n\t\tString excludes = StringPool.BLANK;\n\n\t\tif (appServerType.equals(ServerDetector.JBOSS_ID)) {\n\t\t\texcludes += \"**/WEB-INF/lib/log4j.jar,\";\n\t\t}\n\t\telse if (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\t\t\tString[] libs = FileUtil.listFiles(tomcatLibDir);\n\n\t\t\tfor (String lib : libs) {\n\t\t\t\texcludes += \"**/WEB-INF/lib/\" + lib + \",\";\n\t\t\t}\n\n\t\t\tFile contextXml = new File(srcFile + \"/META-INF/context.xml\");\n\n\t\t\tif (contextXml.exists()) {\n\t\t\t\tString content = FileUtil.read(contextXml);\n\n\t\t\t\tif (content.contains(_PORTAL_CLASS_LOADER)) {\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-bridges.jar,\";\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-java.jar,\";\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-taglib.jar,\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\t// LEP-2990\n\n\t\t\t\tClass.forName(\"javax.el.ELContext\");\n\n\t\t\t\texcludes += \"**/WEB-INF/lib/el-api.jar,\";\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\t}\n\t\t}\n\n\t\t// LPS-11268\n\n\t\tProperties properties = getPluginPackageProperties(srcFile);\n\n\t\tif (properties != null) {\n\t\t\tString deployExcludes = properties.getProperty(\"deploy-excludes\");\n\n\t\t\tif (deployExcludes != null) {\n\t\t\t\texcludes += deployExcludes.trim();\n\n\t\t\t\tif (!excludes.endsWith(\",\")) {\n\t\t\t\t\texcludes += \",\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdeployExcludes = properties.getProperty(\n\t\t\t\t\"deploy-excludes-\" + appServerType);\n\n\t\t\tif (deployExcludes != null) {\n\t\t\t\texcludes += deployExcludes.trim();\n\n\t\t\t\tif (!excludes.endsWith(\",\")) {\n\t\t\t\t\texcludes += \",\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Excludes \" + excludes);\n\t\t}\n\n\t\tif (!unpackWar) {\n\t\t\tFile tempDir = new File(\n\t\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) +\n\t\t\t\t\tFile.separator + Time.getTimestamp());\n\n\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\tWarTask.war(srcFile, tempDir, excludes, webXml);\n\n\t\t\tif (isJEEDeploymentEnabled()) {\n\t\t\t\tFile tempWarDir = new File(\n\t\t\t\t\ttempDir.getParent(), deployDir.getName());\n\n\t\t\t\tif (tempWarDir.exists()) {\n\t\t\t\t\ttempWarDir.delete();\n\t\t\t\t}\n\n\t\t\t\tif (!tempDir.renameTo(tempWarDir)) {\n\t\t\t\t\ttempWarDir = tempDir;\n\t\t\t\t}\n\n\t\t\t\tDeploymentHandler deploymentHandler = getDeploymentHandler();\n\n\t\t\t\tdeploymentHandler.deploy(tempWarDir, displayName);\n\n\t\t\t\tdeploymentHandler.releaseDeploymentManager();\n\n\t\t\t\tDeleteTask.deleteDirectory(tempWarDir);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!tempDir.renameTo(deployDir)) {\n\t\t\t\t\tWarTask.war(srcFile, deployDir, excludes, webXml);\n\t\t\t\t}\n\n\t\t\t\tif (tempDir.isDirectory()) {\n\t\t\t\t\tDeleteTask.deleteDirectory(tempDir);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttempDir.delete();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// The deployer might only copy files that have been modified.\n\t\t\t// However, the deployer always copies and overwrites web.xml after\n\t\t\t// the other files have been copied because application servers\n\t\t\t// usually detect that a WAR has been modified based on the web.xml\n\t\t\t// timestamp.\n\n\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\tsrcFile, deployDir, StringPool.BLANK, excludes, overwrite,\n\t\t\t\ttrue);\n\n\t\t\tCopyTask.copyDirectory(\n\t\t\t\tsrcFile, deployDir, \"**/WEB-INF/web.xml\", StringPool.BLANK,\n\t\t\t\ttrue, false);\n\n\t\t\tif (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\n\t\t\t\t// See org.apache.catalina.startup.HostConfig to see how Tomcat\n\t\t\t\t// checks to make sure that web.xml was modified 5 seconds after\n\t\t\t\t// WEB-INF\n\n\t\t\t\tFile deployWebXml = new File(deployDir + \"/WEB-INF/web.xml\");\n\n\t\t\t\tdeployWebXml.setLastModified(\n\t\t\t\t\tSystem.currentTimeMillis() + (Time.SECOND * 6));\n\t\t\t}\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JETTY_ID)) {\n\t\t\tDeployUtil.redeployJetty(displayName);\n\t\t}\n\t}","commit_id":"41b14855278ed555900bfb8535b0a986c7849c1c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void execute()\r\n        throws MojoExecutionException\r\n    {\r\n        try\r\n        {\r\n            initScmManager();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't initialize ReleaseMojo.\", e );\r\n        }\r\n\r\n        try\r\n        {\r\n            executeTask();\r\n        }\r\n        finally\r\n        {\r\n            releaseScmManager();\r\n        }\r\n    }","id":42235,"modified_method":"public void execute()\r\n        throws MojoExecutionException\r\n    {\r\n        try\r\n        {\r\n            initScmManager();\r\n\r\n            // ----------------------------------------------------------------------\r\n            // The release properties file has been created by the prepare phase and\r\n            // wants to be shared with the perform.\r\n            // ----------------------------------------------------------------------\r\n\r\n            File releasePropertiesFile = new File( project.getFile().getParentFile(), RELEASE_PROPS );\r\n\r\n            if ( releasePropertiesFile.exists() )\r\n            {\r\n\r\n                releaseProperties = new Properties();\r\n\r\n                InputStream is = new FileInputStream( releasePropertiesFile );\r\n\r\n                releaseProperties.load( is );\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't initialize ReleaseMojo.\", e );\r\n        }\r\n\r\n        try\r\n        {\r\n            executeTask();\r\n        }\r\n        finally\r\n        {\r\n            releaseScmManager();\r\n        }\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected ScmBean getScm()\r\n    {\r\n        ScmBean scm = new ScmBean();\r\n\r\n        scm.setScmManager( scmManager );\r\n\r\n        scm.setUrl( urlScm );\r\n\r\n        scm.setTag( tag );\r\n\r\n        scm.setTagBase( tagBase );\r\n\r\n        scm.setUsername( username );\r\n\r\n        scm.setPassword( password );\r\n\r\n        scm.setWorkingDirectory( workingDirectory );\r\n\r\n        return scm;\r\n    }","id":42236,"modified_method":"protected ScmBean getScm()\r\n    {\r\n        ScmBean scm = new ScmBean();\r\n\r\n        scm.setScmManager( scmManager );\r\n\r\n        if ( releaseProperties != null )\r\n        {\r\n            urlScm = releaseProperties.getProperty( SCM_URL );\r\n        }\r\n\r\n        scm.setUrl( urlScm );\r\n\r\n        System.out.println( \"urlScm = \" + urlScm );\r\n\r\n        if ( releaseProperties != null )\r\n        {\r\n            tag = releaseProperties.getProperty( TAG );\r\n        }\r\n\r\n        scm.setTag( tag );\r\n\r\n        scm.setTagBase( tagBase );\r\n\r\n        if ( releaseProperties != null )\r\n        {\r\n            username = releaseProperties.getProperty( USERNAME );\r\n        }\r\n\r\n        System.out.println( \"username = \" + username );\r\n\r\n        scm.setUsername( username );\r\n\r\n        scm.setPassword( password );\r\n\r\n        scm.setWorkingDirectory( workingDirectory );\r\n\r\n        return scm;\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void runGoals()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we need to get a reference to the maven component and use that so this\r\n        // will work purely in an embedded mode.\r\n\r\n        Commandline cl = new Commandline();\r\n\r\n        cl.setExecutable( \"m2\" );\r\n\r\n        cl.setWorkingDirectory( getWorkingDirectory() );\r\n\r\n        cl.createArgument().setLine( goals );\r\n\r\n        StreamConsumer consumer = new DefaultConsumer();\r\n\r\n        try\r\n        {\r\n            CommandLineUtils.executeCommandLine( cl, consumer, consumer );\r\n        }\r\n        catch ( CommandLineException e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\r\n        }\r\n    }","id":42237,"modified_method":"private void runGoals()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we need to get a reference to the maven component and use that so this\r\n        // will work purely in an embedded mode.\r\n\r\n        Commandline cl = new Commandline();\r\n\r\n        cl.setExecutable( \"m2\" );\r\n\r\n        cl.setWorkingDirectory( workingDirectory );\r\n\r\n        cl.createArgument().setLine( goals );\r\n\r\n        StreamConsumer consumer = new DefaultConsumer();\r\n\r\n        try\r\n        {\r\n            CommandLineUtils.executeCommandLine( cl, consumer, consumer );\r\n        }\r\n        catch ( CommandLineException e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\r\n        }\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\r\n     * Tag the release in preparation for performing the release.\r\n     *\r\n     * We will provide the user with a default tag name based on the artifact id\r\n     * and the version of the project being released.\r\n     *\r\n     * where artifactId is <code>plexus-action<\/code> and the version is <code>1.0-beta-4<\/code>, the\r\n     * the suggested tag will be <code>PLEXUS_ACTION_1_0_BETA_4<\/code>.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void tagRelease()\r\n        throws MojoExecutionException\r\n    {\r\n\r\n        String tag = project.getArtifactId().toUpperCase() + \"_\" + projectVersion.toUpperCase();\r\n\r\n        tag = tag.replace( '-', '_' );\r\n\r\n        tag = tag.replace( '.', '_' );\r\n\r\n        try\r\n        {\r\n            ScmBean scm = getScm();\r\n\r\n            scm.setWorkingDirectory( basedir );\r\n\r\n            if ( scm.getTag() == null )\r\n            {\r\n                getLog().info( \"What tag name should be used? [ \" + tag + \" ]\" );\r\n\r\n                InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n                String inputTag = handler.readLine();\r\n\r\n                if ( !StringUtils.isEmpty( inputTag ) )\r\n                {\r\n                    tag = inputTag;\r\n                }\r\n\r\n                scm.setTag( tag );\r\n            }\r\n\r\n            scm.tag();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"An error is occurred in the tag process.\", e );\r\n        }\r\n    }","id":42238,"modified_method":"/**\r\n     * Tag the release in preparation for performing the release.\r\n     *\r\n     * We will provide the user with a default tag name based on the artifact id\r\n     * and the version of the project being released.\r\n     *\r\n     * where artifactId is <code>plexus-action<\/code> and the version is <code>1.0-beta-4<\/code>, the\r\n     * the suggested tag will be <code>PLEXUS_ACTION_1_0_BETA_4<\/code>.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void tagRelease()\r\n        throws MojoExecutionException\r\n    {\r\n        String tag = getTagLabel();\r\n\r\n        try\r\n        {\r\n            ScmBean scm = getScm();\r\n\r\n            scm.setWorkingDirectory( basedir );\r\n\r\n            if ( scm.getTag() == null )\r\n            {\r\n                getLog().info( \"What tag name should be used? [ \" + tag + \" ]\" );\r\n\r\n                InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n                String inputTag = handler.readLine();\r\n\r\n                if ( !StringUtils.isEmpty( inputTag ) )\r\n                {\r\n                    tag = inputTag;\r\n                }\r\n\r\n                scm.setTag( tag );\r\n            }\r\n\r\n            scm.tag();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"An error is occurred in the tag process.\", e );\r\n        }\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void executeTask()\r\n        throws MojoExecutionException\r\n    {\r\n        checkForLocalModifications();\r\n\r\n        checkForPresenceOfSnapshots();\r\n\r\n        transformPom();\r\n\r\n        checkInReleaseVersionPom();\r\n\r\n        tagRelease();\r\n    }","id":42239,"modified_method":"protected void executeTask()\r\n        throws MojoExecutionException\r\n    {\r\n        model = project.getModel();\r\n\r\n        checkForLocalModifications();\r\n\r\n        checkForPresenceOfSnapshots();\r\n\r\n        transformPomToReleaseVersionPom();\r\n\r\n        checkInReleaseVersionPom();\r\n\r\n        tagRelease();\r\n\r\n        transformPomToSnapshotVersionPom();\r\n\r\n        checkInSnapshotVersionPom();\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\r\n     * Check in the POM to SCM after it has been transformed where the version has been\r\n     * set to the release version.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void checkInReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        try\r\n        {\r\n            ScmBean scm = getScm();\r\n\r\n            scm.setWorkingDirectory( basedir );\r\n\r\n            scm.checkin( \"[maven-release-plugin] prepare release \" + projectVersion, \"pom.xml\", null );\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"An error is occurred in the checkin process.\", e );\r\n        }\r\n    }","id":42240,"modified_method":"/**\r\n     * Check in the POM to SCM after it has been transformed where the version has been\r\n     * set to the release version.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void checkInReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        checkInPom( \"[maven-release-plugin] prepare release \" + projectVersion );\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void transformPom()\r\n        throws MojoExecutionException\r\n    {\r\n        Model model = project.getModel();\r\n\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't update pom.\", e );\r\n        }\r\n    }","id":42241,"modified_method":"private void transformPomToReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        try\r\n        {\r\n            Properties releaseProperties = new Properties();\r\n\r\n            releaseProperties.setProperty( \"version\", projectVersion );\r\n\r\n            releaseProperties.setProperty( USERNAME, username );\r\n\r\n            releaseProperties.setProperty( TAG, getTagLabel() );\r\n\r\n            releaseProperties.setProperty( SCM_URL, urlScm );\r\n\r\n            FileOutputStream os = new FileOutputStream( new File( project.getFile().getParentFile(), RELEASE_PROPS ) );\r\n\r\n            releaseProperties.store( os, \"maven release plugin info\" );\r\n\r\n            os.close();\r\n        }\r\n        catch ( IOException e )\r\n        {\r\n            throw new MojoExecutionException( \"Cannote write release-version file.\", e );\r\n        }\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its release version form.\", e );\r\n        }\r\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void checkout()\n        throws ScmException, IOException\n    {\n        ScmRepository repository = getScmRepository();\n\n        checkoutDirectory = new File( workingDirectory );\n        if ( checkoutDirectory.exists() )\n        {\n            // TODO: sanity check that it is not . or .. or lower\n            FileUtils.deleteDirectory( checkoutDirectory );\n        }\n        checkoutDirectory.mkdirs();\n\n        CheckOutScmResult result = getScmManager().checkOut( repository, new ScmFileSet( checkoutDirectory ), tag );\n\n        checkResult( result );\n    }","id":42242,"modified_method":"public void checkout()\n        throws ScmException, IOException\n    {\n        ScmRepository repository = getScmRepository();\n\n        checkoutDirectory = new File( workingDirectory );\n\n        System.out.println( \"workingDirectory = \" + workingDirectory );\n\n        System.out.println( \"tag = \" + tag );\n\n        // TODO: sanity check that it is not . or .. or lower\n\n        if ( FileUtils.fileExists( workingDirectory ) )\n        {\n            FileUtils.deleteDirectory( workingDirectory );\n\n            FileUtils.mkdir( workingDirectory );\n        }\n\n        CheckOutScmResult result = getScmManager().checkOut( repository, new ScmFileSet( checkoutDirectory ), tag );\n\n        checkResult( result );\n    }","commit_id":"83171f26b6354b1a06b24ba3913f48cbcc979a1e","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void deployDirectory(\n\t\t\tFile srcFile, File mergeDir, File deployDir, String displayName,\n\t\t\tboolean overwrite, PluginPackage pluginPackage)\n\t\tthrows Exception {\n\n\t\tif ((PropsValues.PORTLET_CONTAINER_IMPL_SUN) &&\n\t\t\t(this instanceof PortletDeployer)) {\n\n\t\t\tProperties properties = new Properties();\n\n\t\t\tproperties.setProperty(PortletWarUpdater.ADD_WEB_XML, \"true\");\n\n\t\t\tPortletWarUpdater portletWarUpdater = new PortletWarUpdater(\n\t\t\t\tproperties);\n\n\t\t\tportletWarUpdater.preparePortlet(displayName, srcFile);\n\t\t}\n\n\t\trewriteFiles(srcFile);\n\n\t\tmergeDirectory(mergeDir, srcFile);\n\n\t\tprocessPluginPackageProperties(srcFile, displayName, pluginPackage);\n\n\t\tcopyJars(srcFile, pluginPackage);\n\t\tcopyProperties(srcFile, pluginPackage);\n\t\tcopyTlds(srcFile, pluginPackage);\n\t\tcopyXmls(srcFile, displayName, pluginPackage);\n\t\tcopyPortalDependencies(srcFile);\n\n\t\tupdateGeronimoWebXml(srcFile, displayName, pluginPackage);\n\n\t\tFile webXml = new File(srcFile + \"/WEB-INF/web.xml\");\n\n\t\tupdateWebXml(webXml, srcFile, displayName, pluginPackage);\n\n\t\tif ((deployDir != null) && !baseDir.equals(destDir)) {\n\t\t\tupdateDeployDirectory(srcFile);\n\n\t\t\tString excludes = StringPool.BLANK;\n\n\t\t\tif (appServerType.startsWith(\"jboss\")) {\n\t\t\t\texcludes += \"**/WEB-INF/lib/log4j.jar,\";\n\t\t\t}\n\t\t\telse if (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\t\t\t\tString[] libs = FileUtil.listFiles(tomcatLibDir);\n\n\t\t\t\tfor (int i = 0; i < libs.length; i++) {\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/\" + libs[i] + \",\";\n\t\t\t\t}\n\n\t\t\t\tFile contextXml = new File(srcFile + \"/META-INF/context.xml\");\n\n\t\t\t\tif (contextXml.exists()) {\n\t\t\t\t\tString content = FileUtil.read(contextXml);\n\n\t\t\t\t\tif (content.indexOf(_PORTAL_CLASS_LOADER) != -1) {\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-bridges.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-java.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-taglib.jar,\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// LEP-2990\n\n\t\t\t\t\tClass.forName(\"javax.el.ELContext\");\n\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/el-api.jar,\";\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!unpackWar || appServerType.equals(\"websphere\")) {\n\t\t\t\tFile tempDir = new File(\n\t\t\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) +\n\t\t\t\t\t\tFile.separator + Time.getTimestamp());\n\n\t\t\t\tWarTask.war(srcFile, tempDir, \"WEB-INF/web.xml\", webXml);\n\n\t\t\t\tif (!tempDir.renameTo(deployDir)) {\n\t\t\t\t\tWarTask.war(srcFile, deployDir, \"WEB-INF/web.xml\", webXml);\n\t\t\t\t}\n\n\t\t\t\tDeleteTask.deleteDirectory(tempDir);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// The deployer might only copy files that have been modified.\n\t\t\t\t// However, the deployer always copies and overwrites web.xml\n\t\t\t\t// after the other files have been copied because application\n\t\t\t\t// servers usually detect that a WAR has been modified based on\n\t\t\t\t// the web.xml time stamp.\n\n\t\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, StringPool.BLANK, excludes, overwrite,\n\t\t\t\t\ttrue);\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, \"**/WEB-INF/web.xml\", StringPool.BLANK,\n\t\t\t\t\ttrue, false);\n\n\t\t\t\tif (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\n\t\t\t\t\t// See org.apache.catalina.startup.HostConfig to see how\n\t\t\t\t\t// Tomcat checks to make sure that web.xml was modified 5\n\t\t\t\t\t// seconds after WEB-INF\n\n\t\t\t\t\tFile deployWebXml = new File(\n\t\t\t\t\t\tdeployDir + \"/WEB-INF/web.xml\");\n\n\t\t\t\t\tdeployWebXml.setLastModified(\n\t\t\t\t\t\tSystem.currentTimeMillis() + (Time.SECOND * 6));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":42243,"modified_method":"protected void deployDirectory(\n\t\t\tFile srcFile, File mergeDir, File deployDir, String displayName,\n\t\t\tboolean overwrite, PluginPackage pluginPackage)\n\t\tthrows Exception {\n\n\t\tif ((PropsValues.PORTLET_CONTAINER_IMPL_SUN) &&\n\t\t\t(this instanceof PortletDeployer)) {\n\n\t\t\tProperties properties = new Properties();\n\n\t\t\tproperties.setProperty(PortletWarUpdater.ADD_WEB_XML, \"true\");\n\n\t\t\tPortletWarUpdater portletWarUpdater = new PortletWarUpdater(\n\t\t\t\tproperties);\n\n\t\t\tportletWarUpdater.preparePortlet(displayName, srcFile);\n\t\t}\n\n\t\trewriteFiles(srcFile);\n\n\t\tmergeDirectory(mergeDir, srcFile);\n\n\t\tprocessPluginPackageProperties(srcFile, displayName, pluginPackage);\n\n\t\tcopyJars(srcFile, pluginPackage);\n\t\tcopyProperties(srcFile, pluginPackage);\n\t\tcopyTlds(srcFile, pluginPackage);\n\t\tcopyXmls(srcFile, displayName, pluginPackage);\n\t\tcopyPortalDependencies(srcFile);\n\n\t\tupdateGeronimoWebXml(srcFile, displayName, pluginPackage);\n\n\t\tFile webXml = new File(srcFile + \"/WEB-INF/web.xml\");\n\n\t\tupdateWebXml(webXml, srcFile, displayName, pluginPackage);\n\n\t\tif ((deployDir != null) && !baseDir.equals(destDir)) {\n\t\t\tupdateDeployDirectory(srcFile);\n\n\t\t\tString excludes = StringPool.BLANK;\n\n\t\t\tif (appServerType.startsWith(\"jboss\")) {\n\t\t\t\texcludes += \"**/WEB-INF/lib/log4j.jar,\";\n\t\t\t}\n\t\t\telse if (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\t\t\t\tString[] libs = FileUtil.listFiles(tomcatLibDir);\n\n\t\t\t\tfor (int i = 0; i < libs.length; i++) {\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/\" + libs[i] + \",\";\n\t\t\t\t}\n\n\t\t\t\tFile contextXml = new File(srcFile + \"/META-INF/context.xml\");\n\n\t\t\t\tif (contextXml.exists()) {\n\t\t\t\t\tString content = FileUtil.read(contextXml);\n\n\t\t\t\t\tif (content.indexOf(_PORTAL_CLASS_LOADER) != -1) {\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-bridges.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-java.jar,\";\n\t\t\t\t\t\texcludes += \"**/WEB-INF/lib/util-taglib.jar,\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// LEP-2990\n\n\t\t\t\t\tClass.forName(\"javax.el.ELContext\");\n\n\t\t\t\t\texcludes += \"**/WEB-INF/lib/el-api.jar,\";\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!unpackWar || appServerType.equals(\"websphere\")) {\n\t\t\t\tFile tempDir = new File(\n\t\t\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) +\n\t\t\t\t\t\tFile.separator + Time.getTimestamp());\n\n\t\t\t\tWarTask.war(srcFile, tempDir, \"WEB-INF/web.xml\", webXml);\n\n\t\t\t\tif (ServerDetector.isGlassfish()) {\n\t\t\t\t\tJSR88Deployer.deploy(\n\t\t\t\t\t\tdisplayName, tempDir, deployDir.getName());\n\t\t\t\t} else {\n\t\t\t\t\tif (!tempDir.renameTo(deployDir)) {\n\t\t\t\t\t\tWarTask.war(\n\t\t\t\t\t\t\tsrcFile, deployDir, \"WEB-INF/web.xml\", webXml);\n\t\t\t\t\t}\n\t\t\t\t\tDeleteTask.deleteDirectory(tempDir);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// The deployer might only copy files that have been modified.\n\t\t\t\t// However, the deployer always copies and overwrites web.xml\n\t\t\t\t// after the other files have been copied because application\n\t\t\t\t// servers usually detect that a WAR has been modified based on\n\t\t\t\t// the web.xml time stamp.\n\n\t\t\t\texcludes += \"**/WEB-INF/web.xml\";\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, StringPool.BLANK, excludes, overwrite,\n\t\t\t\t\ttrue);\n\n\t\t\t\tCopyTask.copyDirectory(\n\t\t\t\t\tsrcFile, deployDir, \"**/WEB-INF/web.xml\", StringPool.BLANK,\n\t\t\t\t\ttrue, false);\n\n\t\t\t\tif (appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\n\t\t\t\t\t// See org.apache.catalina.startup.HostConfig to see how\n\t\t\t\t\t// Tomcat checks to make sure that web.xml was modified 5\n\t\t\t\t\t// seconds after WEB-INF\n\n\t\t\t\t\tFile deployWebXml = new File(\n\t\t\t\t\t\tdeployDir + \"/WEB-INF/web.xml\");\n\n\t\t\t\t\tdeployWebXml.setLastModified(\n\t\t\t\t\t\tSystem.currentTimeMillis() + (Time.SECOND * 6));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"5fcc32c5ceebaba5b43c977898715a429fc37d57","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void execute()\r\n        throws MojoExecutionException\r\n    {\r\n        try\r\n        {\r\n            initScmManager();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't initialize ReleaseMojo.\", e );\r\n        }\r\n\r\n        try\r\n        {\r\n            executeTask();\r\n        }\r\n        finally\r\n        {\r\n            releaseScmManager();\r\n        }\r\n    }","id":42244,"modified_method":"public void execute()\r\n        throws MojoExecutionException\r\n    {\r\n        try\r\n        {\r\n            initScmManager();\r\n\r\n            // ----------------------------------------------------------------------\r\n            // The release properties file has been created by the prepare phase and\r\n            // wants to be shared with the perform.\r\n            // ----------------------------------------------------------------------\r\n\r\n            File releasePropertiesFile = new File( project.getFile().getParentFile(), RELEASE_PROPS );\r\n\r\n            if ( releasePropertiesFile.exists() )\r\n            {\r\n\r\n                releaseProperties = new Properties();\r\n\r\n                InputStream is = new FileInputStream( releasePropertiesFile );\r\n\r\n                releaseProperties.load( is );\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't initialize ReleaseMojo.\", e );\r\n        }\r\n\r\n        try\r\n        {\r\n            executeTask();\r\n        }\r\n        finally\r\n        {\r\n            releaseScmManager();\r\n        }\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"protected ScmBean getScm()\r\n    {\r\n        ScmBean scm = new ScmBean();\r\n\r\n        scm.setScmManager( scmManager );\r\n\r\n        scm.setUrl( urlScm );\r\n\r\n        scm.setTag( tag );\r\n\r\n        scm.setTagBase( tagBase );\r\n\r\n        scm.setUsername( username );\r\n\r\n        scm.setPassword( password );\r\n\r\n        scm.setWorkingDirectory( workingDirectory );\r\n\r\n        return scm;\r\n    }","id":42245,"modified_method":"protected ScmBean getScm()\r\n    {\r\n        ScmBean scm = new ScmBean();\r\n\r\n        scm.setScmManager( scmManager );\r\n\r\n        if ( releaseProperties != null )\r\n        {\r\n            urlScm = releaseProperties.getProperty( SCM_URL );\r\n        }\r\n\r\n        scm.setUrl( urlScm );\r\n\r\n        System.out.println( \"urlScm = \" + urlScm );\r\n\r\n        if ( releaseProperties != null )\r\n        {\r\n            tag = releaseProperties.getProperty( TAG );\r\n        }\r\n\r\n        scm.setTag( tag );\r\n\r\n        scm.setTagBase( tagBase );\r\n\r\n        if ( releaseProperties != null )\r\n        {\r\n            username = releaseProperties.getProperty( USERNAME );\r\n        }\r\n\r\n        System.out.println( \"username = \" + username );\r\n\r\n        scm.setUsername( username );\r\n\r\n        scm.setPassword( password );\r\n\r\n        scm.setWorkingDirectory( workingDirectory );\r\n\r\n        return scm;\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"private void runGoals()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we need to get a reference to the maven component and use that so this\r\n        // will work purely in an embedded mode.\r\n\r\n        Commandline cl = new Commandline();\r\n\r\n        cl.setExecutable( \"m2\" );\r\n\r\n        cl.setWorkingDirectory( getWorkingDirectory() );\r\n\r\n        cl.createArgument().setLine( goals );\r\n\r\n        StreamConsumer consumer = new DefaultConsumer();\r\n\r\n        try\r\n        {\r\n            CommandLineUtils.executeCommandLine( cl, consumer, consumer );\r\n        }\r\n        catch ( CommandLineException e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\r\n        }\r\n    }","id":42246,"modified_method":"private void runGoals()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we need to get a reference to the maven component and use that so this\r\n        // will work purely in an embedded mode.\r\n\r\n        Commandline cl = new Commandline();\r\n\r\n        cl.setExecutable( \"m2\" );\r\n\r\n        cl.setWorkingDirectory( workingDirectory );\r\n\r\n        cl.createArgument().setLine( goals );\r\n\r\n        StreamConsumer consumer = new DefaultConsumer();\r\n\r\n        try\r\n        {\r\n            CommandLineUtils.executeCommandLine( cl, consumer, consumer );\r\n        }\r\n        catch ( CommandLineException e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\r\n        }\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"/**\r\n     * Check in the POM to SCM after it has been transformed where the version has been\r\n     * set to the release version.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void checkInReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        try\r\n        {\r\n            ScmBean scm = getScm();\r\n\r\n            scm.setWorkingDirectory( basedir );\r\n\r\n            scm.checkin( \"[maven-release-plugin] prepare release \" + projectVersion, \"pom.xml\", null );\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"An error is occurred in the checkin process.\", e );\r\n        }\r\n    }","id":42247,"modified_method":"/**\r\n     * Check in the POM to SCM after it has been transformed where the version has been\r\n     * set to the release version.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void checkInReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        checkInPom( \"[maven-release-plugin] prepare release \" + projectVersion );\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"private void transformPom()\r\n        throws MojoExecutionException\r\n    {\r\n        Model model = project.getModel();\r\n\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't update pom.\", e );\r\n        }\r\n    }","id":42248,"modified_method":"private void transformPomToReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        try\r\n        {\r\n            Properties releaseProperties = new Properties();\r\n\r\n            releaseProperties.setProperty( \"version\", projectVersion );\r\n\r\n            releaseProperties.setProperty( USERNAME, username );\r\n\r\n            releaseProperties.setProperty( TAG, getTagLabel() );\r\n\r\n            releaseProperties.setProperty( SCM_URL, urlScm );\r\n\r\n            FileOutputStream os = new FileOutputStream( new File( project.getFile().getParentFile(), RELEASE_PROPS ) );\r\n\r\n            releaseProperties.store( os, \"maven release plugin info\" );\r\n\r\n            os.close();\r\n        }\r\n        catch ( IOException e )\r\n        {\r\n            throw new MojoExecutionException( \"Cannote write release-version file.\", e );\r\n        }\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its release version form.\", e );\r\n        }\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"protected void executeTask()\r\n        throws MojoExecutionException\r\n    {\r\n        checkForLocalModifications();\r\n\r\n        checkForPresenceOfSnapshots();\r\n\r\n        transformPom();\r\n\r\n        checkInReleaseVersionPom();\r\n\r\n        tagRelease();\r\n    }","id":42249,"modified_method":"protected void executeTask()\r\n        throws MojoExecutionException\r\n    {\r\n        model = project.getModel();\r\n\r\n        checkForLocalModifications();\r\n\r\n        checkForPresenceOfSnapshots();\r\n\r\n        transformPomToReleaseVersionPom();\r\n\r\n        checkInReleaseVersionPom();\r\n\r\n        tagRelease();\r\n\r\n        transformPomToSnapshotVersionPom();\r\n\r\n        checkInSnapshotVersionPom();\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"/**\r\n     * Tag the release in preparation for performing the release.\r\n     *\r\n     * We will provide the user with a default tag name based on the artifact id\r\n     * and the version of the project being released.\r\n     *\r\n     * where artifactId is <code>plexus-action<\/code> and the version is <code>1.0-beta-4<\/code>, the\r\n     * the suggested tag will be <code>PLEXUS_ACTION_1_0_BETA_4<\/code>.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void tagRelease()\r\n        throws MojoExecutionException\r\n    {\r\n\r\n        String tag = project.getArtifactId().toUpperCase() + \"_\" + projectVersion.toUpperCase();\r\n\r\n        tag = tag.replace( '-', '_' );\r\n\r\n        tag = tag.replace( '.', '_' );\r\n\r\n        try\r\n        {\r\n            ScmBean scm = getScm();\r\n\r\n            scm.setWorkingDirectory( basedir );\r\n\r\n            if ( scm.getTag() == null )\r\n            {\r\n                getLog().info( \"What tag name should be used? [ \" + tag + \" ]\" );\r\n\r\n                InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n                String inputTag = handler.readLine();\r\n\r\n                if ( !StringUtils.isEmpty( inputTag ) )\r\n                {\r\n                    tag = inputTag;\r\n                }\r\n\r\n                scm.setTag( tag );\r\n            }\r\n\r\n            scm.tag();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"An error is occurred in the tag process.\", e );\r\n        }\r\n    }","id":42250,"modified_method":"/**\r\n     * Tag the release in preparation for performing the release.\r\n     *\r\n     * We will provide the user with a default tag name based on the artifact id\r\n     * and the version of the project being released.\r\n     *\r\n     * where artifactId is <code>plexus-action<\/code> and the version is <code>1.0-beta-4<\/code>, the\r\n     * the suggested tag will be <code>PLEXUS_ACTION_1_0_BETA_4<\/code>.\r\n     *\r\n     * @throws MojoExecutionException\r\n     */\r\n    private void tagRelease()\r\n        throws MojoExecutionException\r\n    {\r\n        String tag = getTagLabel();\r\n\r\n        try\r\n        {\r\n            ScmBean scm = getScm();\r\n\r\n            scm.setWorkingDirectory( basedir );\r\n\r\n            if ( scm.getTag() == null )\r\n            {\r\n                getLog().info( \"What tag name should be used? [ \" + tag + \" ]\" );\r\n\r\n                InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n                String inputTag = handler.readLine();\r\n\r\n                if ( !StringUtils.isEmpty( inputTag ) )\r\n                {\r\n                    tag = inputTag;\r\n                }\r\n\r\n                scm.setTag( tag );\r\n            }\r\n\r\n            scm.tag();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"An error is occurred in the tag process.\", e );\r\n        }\r\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"public void checkout()\n        throws ScmException, IOException\n    {\n        ScmRepository repository = getScmRepository();\n\n        checkoutDirectory = new File( workingDirectory );\n        if ( checkoutDirectory.exists() )\n        {\n            // TODO: sanity check that it is not . or .. or lower\n            FileUtils.deleteDirectory( checkoutDirectory );\n        }\n        checkoutDirectory.mkdirs();\n\n        CheckOutScmResult result = getScmManager().checkOut( repository, new ScmFileSet( checkoutDirectory ), tag );\n\n        checkResult( result );\n    }","id":42251,"modified_method":"public void checkout()\n        throws ScmException, IOException\n    {\n        ScmRepository repository = getScmRepository();\n\n        checkoutDirectory = new File( workingDirectory );\n\n        System.out.println( \"workingDirectory = \" + workingDirectory );\n\n        System.out.println( \"tag = \" + tag );\n\n        // TODO: sanity check that it is not . or .. or lower\n\n        if ( FileUtils.fileExists( workingDirectory ) )\n        {\n            FileUtils.deleteDirectory( workingDirectory );\n\n            FileUtils.mkdir( workingDirectory );\n        }\n\n        CheckOutScmResult result = getScmManager().checkOut( repository, new ScmFileSet( checkoutDirectory ), tag );\n\n        checkResult( result );\n    }","commit_id":"aed93fb8b46a6481d3dcf2491f44ed5fc1f397d7","url":"https://github.com/apache/maven"},{"original_method":"public static void undeploy(String appServerType, File deployDir)\n\t\tthrows Exception {\n\n\t\tboolean undeployEnabled = PrefsPropsUtil.getBoolean(\n\t\t\tPropsKeys.HOT_UNDEPLOY_ENABLED, PropsValues.HOT_UNDEPLOY_ENABLED);\n\n\t\tif (!undeployEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!appServerType.equals(ServerDetector.JBOSS_ID) &&\n\t\t\t!appServerType.equals(ServerDetector.JETTY_ID) &&\n\t\t\t!appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!deployDir.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tFile webXml = new File(deployDir + \"/WEB-INF/web.xml\");\n\n\t\tif (!webXml.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Undeploy \" + deployDir);\n\t\t}\n\n\t\tFileUtil.delete(deployDir + \"/WEB-INF/web.xml\");\n\n\t\tDeleteTask.deleteDirectory(deployDir);\n\n\t\tif (appServerType.equals(ServerDetector.JETTY_ID)) {\n\t\t\tFileUtil.delete(\n\t\t\t\tSystem.getProperty(\"jetty.home\") + \"/contexts/\" +\n\t\t\t\t\tdeployDir.getName() + \".xml\");\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JBOSS_ID)) {\n\t\t\tFile deployedFile = new File(\n\t\t\t\tdeployDir.getParent(), deployDir.getName() + \".deployed\");\n\n\t\t\tFileUtil.delete(deployedFile);\n\t\t}\n\n\t\tint undeployInterval = PrefsPropsUtil.getInteger(\n\t\t\tPropsKeys.HOT_UNDEPLOY_INTERVAL,\n\t\t\tPropsValues.HOT_UNDEPLOY_INTERVAL);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Wait \" + undeployInterval +\n\t\t\t\t\t\" ms to allow the plugin time to fully undeploy\");\n\t\t}\n\n\t\tif (undeployInterval > 0) {\n\t\t\tThread.sleep(undeployInterval);\n\t\t}\n\t}","id":42252,"modified_method":"public static void undeploy(String appServerType, File deployDir)\n\t\tthrows Exception {\n\n\t\tboolean undeployEnabled = PrefsPropsUtil.getBoolean(\n\t\t\tPropsKeys.HOT_UNDEPLOY_ENABLED, PropsValues.HOT_UNDEPLOY_ENABLED);\n\n\t\tif (!undeployEnabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!appServerType.equals(ServerDetector.GLASSFISH_ID) &&\n\t\t\t!appServerType.equals(ServerDetector.JBOSS_ID) &&\n\t\t\t!appServerType.equals(ServerDetector.JETTY_ID) &&\n\t\t\t!appServerType.equals(ServerDetector.TOMCAT_ID)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!deployDir.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (deployDir.isFile()) {\n\t\t\tFileUtil.delete(deployDir);\n\t\t}\n\t\telse {\n\t\t\tFile webXml = new File(deployDir + \"/WEB-INF/web.xml\");\n\n\t\t\tif (!webXml.exists()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Undeploy \" + deployDir);\n\t\t\t}\n\n\t\t\tFileUtil.delete(deployDir + \"/WEB-INF/web.xml\");\n\n\t\t\tDeleteTask.deleteDirectory(deployDir);\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JETTY_ID)) {\n\t\t\tFileUtil.delete(\n\t\t\t\tSystem.getProperty(\"jetty.home\") + \"/contexts/\" +\n\t\t\t\t\tdeployDir.getName() + \".xml\");\n\t\t}\n\n\t\tif (appServerType.equals(ServerDetector.JBOSS_ID)) {\n\t\t\tFile deployedFile = new File(\n\t\t\t\tdeployDir.getParent(), deployDir.getName() + \".deployed\");\n\n\t\t\tFileUtil.delete(deployedFile);\n\t\t}\n\n\t\tint undeployInterval = PrefsPropsUtil.getInteger(\n\t\t\tPropsKeys.HOT_UNDEPLOY_INTERVAL,\n\t\t\tPropsValues.HOT_UNDEPLOY_INTERVAL);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Wait \" + undeployInterval +\n\t\t\t\t\t\" ms to allow the plugin time to fully undeploy\");\n\t\t}\n\n\t\tif (undeployInterval > 0) {\n\t\t\tThread.sleep(undeployInterval);\n\t\t}\n\t}","commit_id":"8dea9183add33afc90354179f01f3b817c1bdf4f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        knownHashTable = new javax.swing.JTable();\n        knownBadHashDbsLabel = new javax.swing.JLabel();\n        knownHashDbsLabel = new javax.swing.JLabel();\n        alwaysCalcHashesCheckbox = new javax.swing.JCheckBox();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        knownBadHashTable = new javax.swing.JTable();\n\n        jScrollPane1.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n\n        knownHashTable.setBackground(new java.awt.Color(240, 240, 240));\n        knownHashTable.setShowHorizontalLines(false);\n        knownHashTable.setShowVerticalLines(false);\n        jScrollPane1.setViewportView(knownHashTable);\n\n        knownBadHashDbsLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimpleConfigPanel.class, \"HashDbSimpleConfigPanel.knownBadHashDbsLabel.text\")); // NOI18N\n\n        knownHashDbsLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimpleConfigPanel.class, \"HashDbSimpleConfigPanel.knownHashDbsLabel.text\")); // NOI18N\n\n        alwaysCalcHashesCheckbox.setText(org.openide.util.NbBundle.getMessage(HashDbSimpleConfigPanel.class, \"HashDbSimpleConfigPanel.alwaysCalcHashesCheckbox.text\")); // NOI18N\n\n        jScrollPane2.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n\n        knownBadHashTable.setBackground(new java.awt.Color(240, 240, 240));\n        knownBadHashTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        knownBadHashTable.setShowHorizontalLines(false);\n        knownBadHashTable.setShowVerticalLines(false);\n        jScrollPane2.setViewportView(knownBadHashTable);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(knownHashDbsLabel)\n                            .addComponent(knownBadHashDbsLabel))\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addComponent(alwaysCalcHashesCheckbox, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(knownHashDbsLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(knownBadHashDbsLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(alwaysCalcHashesCheckbox)\n                .addContainerGap())\n        );\n    }","id":42253,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        knownHashTable = new javax.swing.JTable();\n        knownBadHashDbsLabel = new javax.swing.JLabel();\n        knownHashDbsLabel = new javax.swing.JLabel();\n        alwaysCalcHashesCheckbox = new javax.swing.JCheckBox();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        knownBadHashTable = new javax.swing.JTable();\n\n        jScrollPane1.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n\n        knownHashTable.setBackground(new java.awt.Color(240, 240, 240));\n        knownHashTable.setShowHorizontalLines(false);\n        knownHashTable.setShowVerticalLines(false);\n        jScrollPane1.setViewportView(knownHashTable);\n\n        knownBadHashDbsLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimpleConfigPanel.class, \"HashDbSimpleConfigPanel.knownBadHashDbsLabel.text\")); // NOI18N\n\n        knownHashDbsLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimpleConfigPanel.class, \"HashDbSimpleConfigPanel.knownHashDbsLabel.text\")); // NOI18N\n\n        alwaysCalcHashesCheckbox.setText(org.openide.util.NbBundle.getMessage(HashDbSimpleConfigPanel.class, \"HashDbSimpleConfigPanel.alwaysCalcHashesCheckbox.text\")); // NOI18N\n        alwaysCalcHashesCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                alwaysCalcHashesCheckboxActionPerformed(evt);\n            }\n        });\n\n        jScrollPane2.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n\n        knownBadHashTable.setBackground(new java.awt.Color(240, 240, 240));\n        knownBadHashTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        knownBadHashTable.setShowHorizontalLines(false);\n        knownBadHashTable.setShowVerticalLines(false);\n        jScrollPane2.setViewportView(knownBadHashTable);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(alwaysCalcHashesCheckbox, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 285, Short.MAX_VALUE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(knownHashDbsLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 272, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addComponent(knownBadHashDbsLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(knownHashDbsLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(knownBadHashDbsLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(alwaysCalcHashesCheckbox)\n                .addContainerGap())\n        );\n    }","commit_id":"92e5d3e776ef5f6ad99af0bb3a7a6a0f7b796f7d","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        txtServer = new javax.swing.JTextField();\n        lblServer = new javax.swing.JLabel();\n        lblPort = new javax.swing.JLabel();\n        txtPort = new javax.swing.JTextField();\n        txtUserName = new javax.swing.JTextField();\n        lblUserName = new javax.swing.JLabel();\n        btnConnect = new javax.swing.JButton();\n        btnCancel = new javax.swing.JButton();\n        chkAutoConnect = new javax.swing.JCheckBox();\n        jButton1 = new javax.swing.JButton();\n        cbProxyType = new javax.swing.JComboBox();\n        lblProxyType = new javax.swing.JLabel();\n        pnlProxySettings = new javax.swing.JPanel();\n        pnlProxy = new javax.swing.JPanel();\n        lblProxyServer = new javax.swing.JLabel();\n        txtProxyServer = new javax.swing.JTextField();\n        lblProxyPort = new javax.swing.JLabel();\n        txtProxyPort = new javax.swing.JTextField();\n        pnlProxyAuth = new javax.swing.JPanel();\n        lblProxyUserName = new javax.swing.JLabel();\n        txtProxyUserName = new javax.swing.JTextField();\n        txtProxyPassword = new javax.swing.JTextField();\n        lblProxyPassword = new javax.swing.JLabel();\n\n        setTitle(\"Connect\");\n        setNormalBounds(new java.awt.Rectangle(100, 100, 410, 307));\n\n        lblServer.setLabelFor(txtServer);\n        lblServer.setText(\"Server:\");\n\n        lblPort.setLabelFor(txtPort);\n        lblPort.setText(\"Port:\");\n\n        txtPort.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyTyped(java.awt.event.KeyEvent evt) {\n                ConnectDialog.this.keyTyped(evt);\n            }\n        });\n\n        lblUserName.setLabelFor(txtUserName);\n        lblUserName.setText(\"User Name:\");\n\n        btnConnect.setText(\"Connect\");\n        btnConnect.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnConnectActionPerformed(evt);\n            }\n        });\n\n        btnCancel.setText(\"Cancel\");\n        btnCancel.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCancelActionPerformed(evt);\n            }\n        });\n\n        chkAutoConnect.setText(\"Automatically connect to this server next time\");\n        chkAutoConnect.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                chkAutoConnectActionPerformed(evt);\n            }\n        });\n\n        jButton1.setText(\"Find...\");\n        jButton1.setToolTipText(\"Find public server\");\n        jButton1.setName(\"findServerBtn\"); // NOI18N\n        jButton1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findPublicServerActionPerformed(evt);\n            }\n        });\n\n        cbProxyType.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cbProxyTypeActionPerformed(evt);\n            }\n        });\n\n        lblProxyType.setLabelFor(cbProxyType);\n        lblProxyType.setText(\"Proxy:\");\n\n        pnlProxySettings.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n        pnlProxySettings.setMinimumSize(new java.awt.Dimension(0, 0));\n\n        lblProxyServer.setLabelFor(txtProxyServer);\n        lblProxyServer.setText(\"Server:\");\n\n        lblProxyPort.setLabelFor(txtProxyPort);\n        lblProxyPort.setText(\"Port:\");\n\n        txtProxyPort.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyTyped(java.awt.event.KeyEvent evt) {\n                txtProxyPortkeyTyped(evt);\n            }\n        });\n\n        javax.swing.GroupLayout pnlProxyLayout = new javax.swing.GroupLayout(pnlProxy);\n        pnlProxy.setLayout(pnlProxyLayout);\n        pnlProxyLayout.setHorizontalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                    .addGroup(pnlProxyLayout.createSequentialGroup()\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(lblProxyPort))\n                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, pnlProxyLayout.createSequentialGroup()\n                        .addGap(28, 28, 28)\n                        .addComponent(lblProxyServer)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.DEFAULT_SIZE, 360, Short.MAX_VALUE)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap())\n        );\n        pnlProxyLayout.setVerticalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyServer))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblProxyPort)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        lblProxyUserName.setLabelFor(txtProxyUserName);\n        lblProxyUserName.setText(\"User Name:\");\n\n        lblProxyPassword.setLabelFor(txtProxyPassword);\n        lblProxyPassword.setText(\"Password:\");\n\n        javax.swing.GroupLayout pnlProxyAuthLayout = new javax.swing.GroupLayout(pnlProxyAuth);\n        pnlProxyAuth.setLayout(pnlProxyAuthLayout);\n        pnlProxyAuthLayout.setHorizontalGroup(\n            pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 438, Short.MAX_VALUE)\n            .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                .addGroup(pnlProxyAuthLayout.createSequentialGroup()\n                    .addContainerGap()\n                    .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                        .addComponent(lblProxyUserName)\n                        .addComponent(lblProxyPassword))\n                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                    .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                        .addComponent(txtProxyPassword, javax.swing.GroupLayout.DEFAULT_SIZE, 358, Short.MAX_VALUE)\n                        .addComponent(txtProxyUserName, javax.swing.GroupLayout.DEFAULT_SIZE, 358, Short.MAX_VALUE))\n                    .addContainerGap()))\n        );\n        pnlProxyAuthLayout.setVerticalGroup(\n            pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 59, Short.MAX_VALUE)\n            .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                .addGroup(pnlProxyAuthLayout.createSequentialGroup()\n                    .addGap(2, 2, 2)\n                    .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(lblProxyUserName)\n                        .addComponent(txtProxyUserName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                    .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                        .addComponent(txtProxyPassword, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addComponent(lblProxyPassword))\n                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n        );\n\n        javax.swing.GroupLayout pnlProxySettingsLayout = new javax.swing.GroupLayout(pnlProxySettings);\n        pnlProxySettings.setLayout(pnlProxySettingsLayout);\n        pnlProxySettingsLayout.setHorizontalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(pnlProxy, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addComponent(pnlProxyAuth, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n        pnlProxySettingsLayout.setVerticalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxySettingsLayout.createSequentialGroup()\n                .addComponent(pnlProxy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(pnlProxyAuth, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(lblProxyType)\n                            .addComponent(lblPort)\n                            .addComponent(lblServer)\n                            .addComponent(lblUserName))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(txtPort, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(131, 131, 131))\n                            .addComponent(txtUserName, javax.swing.GroupLayout.DEFAULT_SIZE, 382, Short.MAX_VALUE)\n                            .addComponent(chkAutoConnect, javax.swing.GroupLayout.DEFAULT_SIZE, 382, Short.MAX_VALUE)\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                .addComponent(txtServer, javax.swing.GroupLayout.DEFAULT_SIZE, 311, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jButton1))\n                            .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(btnConnect)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnCancel))\n                    .addComponent(pnlProxySettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblServer)\n                    .addComponent(txtServer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jButton1))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblPort))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(txtUserName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblUserName))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(chkAutoConnect)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyType))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(pnlProxySettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(btnCancel)\n                    .addComponent(btnConnect))\n                .addContainerGap())\n        );\n\n        pack();\n    }","id":42254,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        txtServer = new javax.swing.JTextField();\n        lblServer = new javax.swing.JLabel();\n        lblPort = new javax.swing.JLabel();\n        txtPort = new javax.swing.JTextField();\n        txtUserName = new javax.swing.JTextField();\n        lblUserName = new javax.swing.JLabel();\n        btnConnect = new javax.swing.JButton();\n        btnCancel = new javax.swing.JButton();\n        chkAutoConnect = new javax.swing.JCheckBox();\n        jButton1 = new javax.swing.JButton();\n        cbProxyType = new javax.swing.JComboBox();\n        lblProxyType = new javax.swing.JLabel();\n        pnlProxySettings = new javax.swing.JPanel();\n        pnlProxy = new javax.swing.JPanel();\n        lblProxyServer = new javax.swing.JLabel();\n        txtProxyServer = new javax.swing.JTextField();\n        lblProxyPort = new javax.swing.JLabel();\n        txtProxyPort = new javax.swing.JTextField();\n        pnlProxyAuth = new javax.swing.JPanel();\n        lblProxyUserName = new javax.swing.JLabel();\n        txtProxyUserName = new javax.swing.JTextField();\n        lblProxyPassword = new javax.swing.JLabel();\n        txtPasswordField = new javax.swing.JPasswordField();\n\n        setTitle(\"Connect\");\n        setNormalBounds(new java.awt.Rectangle(100, 100, 410, 307));\n\n        lblServer.setLabelFor(txtServer);\n        lblServer.setText(\"Server:\");\n\n        lblPort.setLabelFor(txtPort);\n        lblPort.setText(\"Port:\");\n\n        txtPort.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyTyped(java.awt.event.KeyEvent evt) {\n                ConnectDialog.this.keyTyped(evt);\n            }\n        });\n\n        lblUserName.setLabelFor(txtUserName);\n        lblUserName.setText(\"User Name:\");\n\n        btnConnect.setText(\"Connect\");\n        btnConnect.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnConnectActionPerformed(evt);\n            }\n        });\n\n        btnCancel.setText(\"Cancel\");\n        btnCancel.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnCancelActionPerformed(evt);\n            }\n        });\n\n        chkAutoConnect.setText(\"Automatically connect to this server next time\");\n        chkAutoConnect.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                chkAutoConnectActionPerformed(evt);\n            }\n        });\n\n        jButton1.setText(\"Find...\");\n        jButton1.setToolTipText(\"Find public server\");\n        jButton1.setName(\"findServerBtn\"); // NOI18N\n        jButton1.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                findPublicServerActionPerformed(evt);\n            }\n        });\n\n        cbProxyType.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                cbProxyTypeActionPerformed(evt);\n            }\n        });\n\n        lblProxyType.setLabelFor(cbProxyType);\n        lblProxyType.setText(\"Proxy:\");\n\n        pnlProxySettings.setBorder(javax.swing.BorderFactory.createEtchedBorder());\n        pnlProxySettings.setMinimumSize(new java.awt.Dimension(0, 0));\n\n        lblProxyServer.setLabelFor(txtProxyServer);\n        lblProxyServer.setText(\"Server:\");\n\n        lblProxyPort.setLabelFor(txtProxyPort);\n        lblProxyPort.setText(\"Port:\");\n\n        txtProxyPort.addKeyListener(new java.awt.event.KeyAdapter() {\n            public void keyTyped(java.awt.event.KeyEvent evt) {\n                txtProxyPortkeyTyped(evt);\n            }\n        });\n\n        javax.swing.GroupLayout pnlProxyLayout = new javax.swing.GroupLayout(pnlProxy);\n        pnlProxy.setLayout(pnlProxyLayout);\n        pnlProxyLayout.setHorizontalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addContainerGap(28, Short.MAX_VALUE)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(lblProxyPort)\n                    .addComponent(lblProxyServer))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.DEFAULT_SIZE, 360, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        pnlProxyLayout.setVerticalGroup(\n            pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxyLayout.createSequentialGroup()\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyServer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyServer))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblProxyPort)\n                    .addComponent(txtProxyPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        lblProxyUserName.setLabelFor(txtProxyUserName);\n        lblProxyUserName.setText(\"User Name:\");\n\n        lblProxyPassword.setText(\"Password:\");\n\n        txtPasswordField.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                txtPasswordFieldActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout pnlProxyAuthLayout = new javax.swing.GroupLayout(pnlProxyAuth);\n        pnlProxyAuth.setLayout(pnlProxyAuthLayout);\n        pnlProxyAuthLayout.setHorizontalGroup(\n            pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlProxyAuthLayout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(lblProxyPassword)\n                    .addComponent(lblProxyUserName))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                    .addComponent(txtPasswordField)\n                    .addComponent(txtProxyUserName, javax.swing.GroupLayout.DEFAULT_SIZE, 358, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        pnlProxyAuthLayout.setVerticalGroup(\n            pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlProxyAuthLayout.createSequentialGroup()\n                .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtProxyUserName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyUserName))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)\n                .addGroup(pnlProxyAuthLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPasswordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyPassword))\n                .addContainerGap())\n        );\n\n        javax.swing.GroupLayout pnlProxySettingsLayout = new javax.swing.GroupLayout(pnlProxySettings);\n        pnlProxySettings.setLayout(pnlProxySettingsLayout);\n        pnlProxySettingsLayout.setHorizontalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(pnlProxy, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addComponent(pnlProxyAuth, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n        );\n        pnlProxySettingsLayout.setVerticalGroup(\n            pnlProxySettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(pnlProxySettingsLayout.createSequentialGroup()\n                .addComponent(pnlProxy, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 26, Short.MAX_VALUE)\n                .addComponent(pnlProxyAuth, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addContainerGap())\n        );\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                            .addComponent(lblProxyType)\n                            .addComponent(lblPort)\n                            .addComponent(lblServer)\n                            .addComponent(lblUserName))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(txtPort, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(131, 131, 131))\n                            .addComponent(txtUserName, javax.swing.GroupLayout.DEFAULT_SIZE, 382, Short.MAX_VALUE)\n                            .addComponent(chkAutoConnect, javax.swing.GroupLayout.DEFAULT_SIZE, 382, Short.MAX_VALUE)\n                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                                .addComponent(txtServer, javax.swing.GroupLayout.DEFAULT_SIZE, 311, Short.MAX_VALUE)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                                .addComponent(jButton1))\n                            .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(btnConnect)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(btnCancel))\n                    .addComponent(pnlProxySettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lblServer)\n                    .addComponent(txtServer, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jButton1))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(txtPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblPort))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(txtUserName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblUserName))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(chkAutoConnect)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(cbProxyType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(lblProxyType))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(pnlProxySettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(btnCancel)\n                    .addComponent(btnConnect))\n                .addContainerGap())\n        );\n\n        pack();\n    }","commit_id":"2695f584bec6146746ffc10574c9e022cc51abe5","url":"https://github.com/magefree/mage"},{"original_method":"private void btnConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConnectActionPerformed\n\t\t\n\t\tif (txtUserName.getText().isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Please provide a user name\");\n\t\t\treturn;\n\t\t}\n\t\tif (txtServer.getText().trim().isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Please provide a server address\");\n\t\t\treturn;\n\t\t}\n\t\tif (txtPort.getText().trim().isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Please provide a port number\");\n\t\t\treturn;\n\t\t}\n\t\tif (Integer.valueOf(txtPort.getText()) < 1 || Integer.valueOf(txtPort.getText()) > 65535 ) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Invalid port number\");\n\t\t\ttxtPort.setText(MageFrame.getPreferences().get(\"serverPort\", Integer.toString(Config.port)));\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tsetCursor(new Cursor(Cursor.WAIT_CURSOR));\n\t\t\tConnection connection = new Connection();\n\t\t\tconnection.setHost(this.txtServer.getText());\n\t\t\tconnection.setPort(Integer.valueOf(this.txtPort.getText()));\n\t\t\tconnection.setUsername(this.txtUserName.getText());\n\t\t\tconnection.setProxyType((ProxyType) this.cbProxyType.getSelectedItem());\n\t\t\tconnection.setProxyHost(this.txtProxyServer.getText());\n\t\t\tconnection.setProxyPort(Integer.valueOf(this.txtProxyPort.getText()));\n\t\t\tconnection.setProxyUsername(this.txtProxyUserName.getText());\n\t\t\tconnection.setProxyPassword(this.txtProxyPassword.getText());\n\t\t\tif (MageFrame.connect(connection)) {\n\t\t\t\tthis.saveSettings();\n\t\t\t\tthis.setVisible(false);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n\t\t}\n\n\t}","id":42255,"modified_method":"private void btnConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnConnectActionPerformed\n\t\t\n\t\tif (txtUserName.getText().isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Please provide a user name\");\n\t\t\treturn;\n\t\t}\n\t\tif (txtServer.getText().trim().isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Please provide a server address\");\n\t\t\treturn;\n\t\t}\n\t\tif (txtPort.getText().trim().isEmpty()) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Please provide a port number\");\n\t\t\treturn;\n\t\t}\n\t\tif (Integer.valueOf(txtPort.getText()) < 1 || Integer.valueOf(txtPort.getText()) > 65535 ) {\n\t\t\tJOptionPane.showMessageDialog(rootPane, \"Invalid port number\");\n\t\t\ttxtPort.setText(MageFrame.getPreferences().get(\"serverPort\", Integer.toString(Config.port)));\n\t\t\treturn;\n\t\t}\n\n\t\tchar[] input = new char[0];\n\t\ttry {\n\t\t\tsetCursor(new Cursor(Cursor.WAIT_CURSOR));\n\t\t\tConnection connection = new Connection();\n\t\t\tconnection.setHost(this.txtServer.getText());\n\t\t\tconnection.setPort(Integer.valueOf(this.txtPort.getText()));\n\t\t\tconnection.setUsername(this.txtUserName.getText());\n\t\t\tconnection.setProxyType((ProxyType) this.cbProxyType.getSelectedItem());\n\t\t\tconnection.setProxyHost(this.txtProxyServer.getText());\n\t\t\tconnection.setProxyPort(Integer.valueOf(this.txtProxyPort.getText()));\n\t\t\tconnection.setProxyUsername(this.txtProxyUserName.getText());\n\t\t\tinput = txtPasswordField.getPassword();\n\t\t\tconnection.setProxyPassword(new String(input));\n\t\t\tlogger.debug(\"connecting: \" + connection.getProxyType() + \" \" + connection.getProxyHost() + \" \" + connection.getProxyPort());\n\t\t\tif (MageFrame.connect(connection)) {\n\t\t\t\tthis.saveSettings();\n\t\t\t\tthis.setVisible(false);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tsetCursor(new Cursor(Cursor.DEFAULT_CURSOR));\n\t\t\tArrays.fill(input, '0');\n\t\t}\n\n\t}","commit_id":"2695f584bec6146746ffc10574c9e022cc51abe5","url":"https://github.com/magefree/mage"},{"original_method":"public void showDialog() {\n\t\tthis.txtServer.setText(MageFrame.getPreferences().get(\"serverAddress\", Config.serverName));\n\t\tthis.txtPort.setText(MageFrame.getPreferences().get(\"serverPort\", Integer.toString(Config.port)));\n\t\tthis.txtUserName.setText(MageFrame.getPreferences().get(\"userName\", \"\"));\n\t\tthis.chkAutoConnect.setSelected(Boolean.parseBoolean(MageFrame.getPreferences().get(\"autoConnect\", \"false\")));\n\t\tthis.txtProxyServer.setText(MageFrame.getPreferences().get(\"proxyAddress\", Config.serverName));\n\t\tthis.txtProxyPort.setText(MageFrame.getPreferences().get(\"proxyPort\", Integer.toString(Config.port)));\n\t\tthis.cbProxyType.setSelectedItem(Connection.ProxyType.valueOf(MageFrame.getPreferences().get(\"proxyType\", \"NONE\").toUpperCase()));\n\t\tthis.showProxySettings();\n\t\tthis.setModal(true);\n\t\tthis.setLocation(50, 50);\n\t\tthis.setVisible(true);\n\t}","id":42256,"modified_method":"public void showDialog() {\n\t\tthis.txtServer.setText(MageFrame.getPreferences().get(\"serverAddress\", Config.serverName));\n\t\tthis.txtPort.setText(MageFrame.getPreferences().get(\"serverPort\", Integer.toString(Config.port)));\n\t\tthis.txtUserName.setText(MageFrame.getPreferences().get(\"userName\", \"\"));\n\t\tthis.chkAutoConnect.setSelected(Boolean.parseBoolean(MageFrame.getPreferences().get(\"autoConnect\", \"false\")));\n\t\tthis.txtProxyServer.setText(MageFrame.getPreferences().get(\"proxyAddress\", Config.serverName));\n\t\tthis.txtProxyPort.setText(MageFrame.getPreferences().get(\"proxyPort\", Integer.toString(Config.port)));\n\t\tthis.cbProxyType.setSelectedItem(Connection.ProxyType.valueOf(MageFrame.getPreferences().get(\"proxyType\", \"NONE\").toUpperCase()));\n\t\tthis.txtProxyUserName.setText(MageFrame.getPreferences().get(\"proxyUsername\", \"\"));\n\t\tthis.txtPasswordField.setText(MageFrame.getPreferences().get(\"proxyPassword\", \"\"));\n\t\tthis.showProxySettings();\n\t\tthis.setModal(true);\n\t\tthis.setLocation(50, 50);\n\t\tthis.setVisible(true);\n\t}","commit_id":"2695f584bec6146746ffc10574c9e022cc51abe5","url":"https://github.com/magefree/mage"},{"original_method":"private void saveSettings() {\n\t\tMageFrame.getPreferences().put(\"serverAddress\", txtServer.getText());\n\t\tMageFrame.getPreferences().put(\"serverPort\", txtPort.getText());\n\t\tMageFrame.getPreferences().put(\"userName\", txtUserName.getText());\n\t\tMageFrame.getPreferences().put(\"autoConnect\", Boolean.toString(chkAutoConnect.isSelected()));\n\t\tMageFrame.getPreferences().put(\"proxyAddress\", txtProxyServer.getText());\n\t\tMageFrame.getPreferences().put(\"proxyPort\", txtProxyPort.getText());\n\t\tMageFrame.getPreferences().put(\"proxyType\", cbProxyType.getSelectedItem().toString());\n\t}","id":42257,"modified_method":"private void saveSettings() {\n\t\tMageFrame.getPreferences().put(\"serverAddress\", txtServer.getText());\n\t\tMageFrame.getPreferences().put(\"serverPort\", txtPort.getText());\n\t\tMageFrame.getPreferences().put(\"userName\", txtUserName.getText());\n\t\tMageFrame.getPreferences().put(\"autoConnect\", Boolean.toString(chkAutoConnect.isSelected()));\n\t\tMageFrame.getPreferences().put(\"proxyAddress\", txtProxyServer.getText());\n\t\tMageFrame.getPreferences().put(\"proxyPort\", txtProxyPort.getText());\n\t\tMageFrame.getPreferences().put(\"proxyType\", cbProxyType.getSelectedItem().toString());\n\t\tMageFrame.getPreferences().put(\"proxyUsername\", txtProxyUserName.getText());\n\t\tchar[] input = txtPasswordField.getPassword();\n\t\tMageFrame.getPreferences().put(\"proxyPassword\", new String(input));\n\t\tArrays.fill(input, '0');\n\t}","commit_id":"2695f584bec6146746ffc10574c9e022cc51abe5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Serializable patch(String key, Patch patch, int ttl, TimeUnit timeUnit) throws DatastoreOperationException {\n        Serializable potentialNewValue = (Serializable)patch.newFromPatch();\n        Element element = new Element(key, potentialNewValue);\n        if(ttl != -1) {\n            element.setTimeToLive((int)TimeUnit.SECONDS.convert(ttl, timeUnit));\n        }\n        Element currentElement = ehCacheInstance.putIfAbsent(element);\n        if(currentElement == null) {\n            return potentialNewValue;\n        }\n        else {\n            currentElement = ehCacheInstance.get(key);\n            try {\n                Element returnElement = (Element)currentElement.clone();\n                ((Patchable)currentElement.getValue()).applyPatch(patch);\n                return (Serializable)((Patchable)returnElement.getValue()).applyPatch(patch);\n            } catch (CloneNotSupportedException cnse) {\n                throw new DatastoreOperationException(\"Failed to clone datastore stored version\", cnse);\n            }\n        }\n    }","id":42258,"modified_method":"@Override\n    public Serializable patch(String key, Patch patch, int ttl, TimeUnit timeUnit) throws DatastoreOperationException {\n        Serializable potentialNewValue = (Serializable)patch.newFromPatch();\n        Element element = new Element(key, potentialNewValue);\n        if(ttl != -1) {\n            element.setTimeToLive((int)TimeUnit.SECONDS.convert(ttl, timeUnit));\n        }\n        Element currentElement = ehCacheInstance.putIfAbsent(element);\n        if(currentElement == null) {\n            return potentialNewValue;\n        }\n        else {\n            currentElement = ehCacheInstance.get(key);\n            return (Serializable)((Patchable)currentElement.getValue()).applyPatch(patch);\n        }\n    }","commit_id":"99a5f91a558d575cf5c7b23086f1594283157507","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        Version v = null;\n        if (version != null && !version.isEmpty()) {\n            v = fabricService.getVersion(version);\n        }\n        username = username != null && !username.isEmpty() ? username : ShellUtils.retrieveFabricUser(session);\n        password = password != null ? password : ShellUtils.retrieveFabricUserPassword(session);\n        fabricService.getPatchService().applyPatch(v, patch, username, password);\n        return null;\n    }","id":42259,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        List<Version> versions;\n        if (version != null && !version.isEmpty()) {\n            versions = Collections.singletonList(fabricService.getVersion(version));\n        } else if (allVersions) {\n            versions = Arrays.asList(fabricService.getVersions());\n        } else {\n            versions = Collections.singletonList(fabricService.getDefaultVersion());\n        }\n        username = username != null && !username.isEmpty() ? username : ShellUtils.retrieveFabricUser(session);\n        password = password != null ? password : ShellUtils.retrieveFabricUserPassword(session);\n        for (Version version : versions) {\n            fabricService.getPatchService().applyPatch(version, patch, username, password);\n        }\n        return null;\n    }","commit_id":"8e8e51785fb895b58255d8b461028ec297ea71ab","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n   public void setDetails(final UnifiedParser unifiedParser)\n   {\n      invalidation_.invalidate();\n      final Token token = invalidation_.getInvalidationToken();\n\n      Scheduler.get().scheduleIncremental(new RepeatingCommand() {\n         @Override\n         public boolean execute()\n         {\n            if (token.isInvalid())\n               return false;\n\n            DiffFileHeader fileHeader = unifiedParser.nextFilePair();\n            if (fileHeader == null)\n               return false;\n\n            LineTableView view = new LineTableView();\n            view.setShowActions(false);\n            ArrayList<ChunkOrLine> lines = new ArrayList<ChunkOrLine>();\n            DiffChunk chunk;\n            while (null != (chunk = unifiedParser.nextChunk()))\n            {\n               lines.addAll(ChunkOrLine.fromChunk(chunk));\n            }\n            view.setShowActions(false);\n            view.setData(lines, PatchMode.Stage);\n            view.setWidth(\"100%\");\n\n            final DiffFrame diffFrame = new DiffFrame(\n                  null, fileHeader.getDescription(), null, view);\n            diffFrame.setWidth(\"100%\");\n            detailPanel_.add(diffFrame);\n\n            Anchor tocAnchor = new Anchor(fileHeader.getDescription());\n            tocAnchor.addClickHandler(new ClickHandler()\n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  Point relativePosition = DomUtils.getRelativePosition(\n                        container_.getElement(),\n                        diffFrame.getElement());\n                  container_.setVerticalScrollPosition(relativePosition.getY());\n               }\n            });\n            tocPanel_.add(tocAnchor);\n\n            return true;\n         }\n      });\n   }","id":42260,"modified_method":"@Override\n   public void setDetails(final UnifiedParser unifiedParser)\n   {\n      invalidation_.invalidate();\n      final Token token = invalidation_.getInvalidationToken();\n\n      Scheduler.get().scheduleIncremental(new RepeatingCommand() {\n         @Override\n         public boolean execute()\n         {\n            if (token.isInvalid())\n               return false;\n\n            DiffFileHeader fileHeader = unifiedParser.nextFilePair();\n            if (fileHeader == null)\n               return false;\n\n            LineTableView view = new LineTableView();\n            view.setShowActions(false);\n            ArrayList<ChunkOrLine> lines = new ArrayList<ChunkOrLine>();\n            DiffChunk chunk;\n            while (null != (chunk = unifiedParser.nextChunk()))\n            {\n               lines.addAll(ChunkOrLine.fromChunk(chunk));\n            }\n            view.setData(lines, PatchMode.Stage);\n            view.setWidth(\"100%\");\n\n            final DiffFrame diffFrame = new DiffFrame(\n                  null, fileHeader.getDescription(), null, view);\n            diffFrame.setWidth(\"100%\");\n            detailPanel_.add(diffFrame);\n\n            Anchor tocAnchor = new Anchor(fileHeader.getDescription());\n            tocAnchor.addClickHandler(new ClickHandler()\n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  Point relativePosition = DomUtils.getRelativePosition(\n                        container_.getElement(),\n                        diffFrame.getElement());\n                  container_.setVerticalScrollPosition(relativePosition.getY());\n               }\n            });\n            tocPanel_.add(tocAnchor);\n\n            return true;\n         }\n      });\n   }","commit_id":"34bbc6d63450c68d274b6257e8f8408a21667210","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void setShowActions(boolean showActions)\n   {\n      showActions_ = showActions;\n   }","id":42261,"modified_method":"public void setShowActions(boolean showActions)\n   {\n      showActions_ = showActions;\n      selectionModel_.setEnabled(showActions);\n   }","commit_id":"34bbc6d63450c68d274b6257e8f8408a21667210","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public LineTableView(final LineTableResources res)\n   {\n      super(1, res);\n\n      TextColumn<ChunkOrLine> oldCol = new TextColumn<ChunkOrLine>()\n      {\n         @Override\n         public String getValue(ChunkOrLine object)\n         {\n            Line line = object.getLine();\n            return line == null ? \"\" :\n                   line.getType() == Type.Insertion ? \"\" :\n                   line.getType() == Type.Comment ? \"\" :\n                   intToString(line.getOldLine());\n         }\n      };\n      addColumn(oldCol);\n\n      TextColumn<ChunkOrLine> newCol = new TextColumn<ChunkOrLine>()\n      {\n         @Override\n         public String getValue(ChunkOrLine object)\n         {\n            Line line = object.getLine();\n            return line == null ? \"\" :\n                   line.getType() == Type.Deletion ? \"\" :\n                   line.getType() == Type.Comment ? \"\" :\n                   intToString(line.getNewLine());\n         }\n      };\n      addColumn(newCol);\n\n      Column<ChunkOrLine, ChunkOrLine> textCol =\n            new Column<ChunkOrLine, ChunkOrLine>(new LineContentCell())\n            {\n               @Override\n               public ChunkOrLine getValue(ChunkOrLine object)\n               {\n                  return object;\n               }\n            };\n      addColumn(textCol);\n\n      setColumnWidth(oldCol, 100, Unit.PX);\n      setColumnWidth(newCol, 100, Unit.PX);\n      setColumnWidth(textCol, 100, Unit.PCT);\n\n      setRowStyles(new RowStyles<ChunkOrLine>()\n      {\n         @Override\n         public String getStyleNames(ChunkOrLine chunkOrLine, int rowIndex)\n         {\n            Line line = chunkOrLine.getLine();\n\n            if (line == null)\n            {\n               return res.cellTableStyle().header();\n            }\n            else\n            {\n               String prefix = \"\";\n               if (startRows_.contains(rowIndex))\n                  prefix += res.cellTableStyle().start() + \" \";\n               if (endRows_.contains(rowIndex))\n                  prefix += res.cellTableStyle().end() + \" \";\n\n               switch (line.getType())\n               {\n                  case Same:\n                     return prefix + res.cellTableStyle().same();\n                  case Insertion:\n                     return prefix + res.cellTableStyle().insertion();\n                  case Deletion:\n                     return prefix + res.cellTableStyle().deletion();\n                  case Comment:\n                     return prefix + res.cellTableStyle().comment();\n                  default:\n                     return \"\";\n               }\n            }\n\n         }\n      });\n\n      selectionModel_ = new MultiSelectionModel<ChunkOrLine>(new ProvidesKey<ChunkOrLine>()\n      {\n         @Override\n         public Object getKey(ChunkOrLine item)\n         {\n            if (item.getChunk() != null)\n            {\n               DiffChunk chunk = item.getChunk();\n               return chunk.oldRowStart + \",\" + chunk.oldRowCount + \",\" +\n                     chunk.newRowStart + \",\" + chunk.newRowCount;\n            }\n\n            Line line = item.getLine();\n            return line.getOldLine() + \",\" + line.getNewLine();\n         }\n      }) {\n         @Override\n         public void setSelected(ChunkOrLine object, boolean selected)\n         {\n            if (object.getLine() != null && object.getLine().getType() != Line.Type.Same)\n               super.setSelected(object, selected);\n         }\n      };\n      setSelectionModel(selectionModel_);\n\n      setData(new ArrayList<ChunkOrLine>(), PatchMode.Working);\n   }","id":42262,"modified_method":"@Inject\n   public LineTableView(final LineTableResources res)\n   {\n      super(1, res);\n\n      TextColumn<ChunkOrLine> oldCol = new TextColumn<ChunkOrLine>()\n      {\n         @Override\n         public String getValue(ChunkOrLine object)\n         {\n            Line line = object.getLine();\n            return line == null ? \"\" :\n                   line.getType() == Type.Insertion ? \"\" :\n                   line.getType() == Type.Comment ? \"\" :\n                   intToString(line.getOldLine());\n         }\n      };\n      addColumn(oldCol);\n\n      TextColumn<ChunkOrLine> newCol = new TextColumn<ChunkOrLine>()\n      {\n         @Override\n         public String getValue(ChunkOrLine object)\n         {\n            Line line = object.getLine();\n            return line == null ? \"\" :\n                   line.getType() == Type.Deletion ? \"\" :\n                   line.getType() == Type.Comment ? \"\" :\n                   intToString(line.getNewLine());\n         }\n      };\n      addColumn(newCol);\n\n      Column<ChunkOrLine, ChunkOrLine> textCol =\n            new Column<ChunkOrLine, ChunkOrLine>(new LineContentCell())\n            {\n               @Override\n               public ChunkOrLine getValue(ChunkOrLine object)\n               {\n                  return object;\n               }\n            };\n      addColumn(textCol);\n\n      setColumnWidth(oldCol, 100, Unit.PX);\n      setColumnWidth(newCol, 100, Unit.PX);\n      setColumnWidth(textCol, 100, Unit.PCT);\n\n      setRowStyles(new RowStyles<ChunkOrLine>()\n      {\n         @Override\n         public String getStyleNames(ChunkOrLine chunkOrLine, int rowIndex)\n         {\n            Line line = chunkOrLine.getLine();\n\n            if (line == null)\n            {\n               return res.cellTableStyle().header();\n            }\n            else\n            {\n               String prefix = \"\";\n               if (startRows_.contains(rowIndex))\n                  prefix += res.cellTableStyle().start() + \" \";\n               if (endRows_.contains(rowIndex))\n                  prefix += res.cellTableStyle().end() + \" \";\n\n               switch (line.getType())\n               {\n                  case Same:\n                     return prefix + res.cellTableStyle().same();\n                  case Insertion:\n                     return prefix + res.cellTableStyle().insertion();\n                  case Deletion:\n                     return prefix + res.cellTableStyle().deletion();\n                  case Comment:\n                     return prefix + res.cellTableStyle().comment();\n                  default:\n                     return \"\";\n               }\n            }\n\n         }\n      });\n\n      selectionModel_ = new SwitchableSelectionModel<ChunkOrLine>(new ProvidesKey<ChunkOrLine>()\n      {\n         @Override\n         public Object getKey(ChunkOrLine item)\n         {\n            if (item.getChunk() != null)\n            {\n               DiffChunk chunk = item.getChunk();\n               return chunk.oldRowStart + \",\" + chunk.oldRowCount + \",\" +\n                     chunk.newRowStart + \",\" + chunk.newRowCount;\n            }\n\n            Line line = item.getLine();\n            return line.getOldLine() + \",\" + line.getNewLine();\n         }\n      }) {\n         @Override\n         public void setSelected(ChunkOrLine object, boolean selected)\n         {\n            if (object.getLine() != null && object.getLine().getType() != Line.Type.Same)\n               super.setSelected(object, selected);\n         }\n      };\n      setSelectionModel(selectionModel_);\n\n      setData(new ArrayList<ChunkOrLine>(), PatchMode.Working);\n   }","commit_id":"34bbc6d63450c68d274b6257e8f8408a21667210","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void updateDiff(boolean allowModeSwitch)\n   {\n      view_.getLineTableDisplay().clear();\n      view_.setFilename(\"\");\n      ArrayList<String> paths = view_.getChangelistTable().getSelectedPaths();\n      if (paths.size() != 1)\n         return;\n\n      if (allowModeSwitch)\n      {\n         StatusAndPath item = view_.getChangelistTable().getSelectedItems().get(0);\n         if ((item.getStatus().charAt(0) == ' ' || item.getStatus().charAt(0) == '?')\n             && view_.getStagedCheckBox().getValue())\n         {\n            view_.getUnstagedCheckBox().setValue(true, true);\n         }\n         else if (item.getStatus().charAt(1) == ' ' && view_.getUnstagedCheckBox().getValue())\n         {\n            view_.getStagedCheckBox().setValue(true, true);\n         }\n      }\n\n      view_.setFilename(paths.get(0));\n\n      diffInvalidation_.invalidate();\n      final Token token = diffInvalidation_.getInvalidationToken();\n\n      final PatchMode patchMode = view_.getStagedCheckBox().getValue()\n                                  ? PatchMode.Stage\n                                  : PatchMode.Working;\n      server_.vcsDiffFile(\n            paths.get(0),\n            patchMode,\n            view_.getContextLines().getValue(),\n            new SimpleRequestCallback<String>(\"Diff Error\")\n            {\n               @Override\n               public void onResponseReceived(String response)\n               {\n                  if (token.isInvalid())\n                     return;\n\n                  UnifiedParser parser = new UnifiedParser(response);\n                  parser.nextFilePair();\n\n                  ArrayList<ChunkOrLine> allLines = new ArrayList<ChunkOrLine>();\n\n                  activeChunks_.clear();\n                  for (DiffChunk chunk;\n                       null != (chunk = parser.nextChunk()); )\n                  {\n                     activeChunks_.add(chunk);\n                     allLines.add(new ChunkOrLine(chunk));\n                     for (Line line : chunk.diffLines)\n                        allLines.add(new ChunkOrLine(line));\n                  }\n\n                  view_.getLineTableDisplay().setData(allLines, patchMode);\n                  view_.getGutter().setValue(allLines);\n               }\n            });\n   }","id":42263,"modified_method":"private void updateDiff(boolean allowModeSwitch)\n   {\n      view_.getLineTableDisplay().clear();\n      view_.setFilename(\"\");\n      final ArrayList<StatusAndPath> paths = view_.getChangelistTable().getSelectedItems();\n      if (paths.size() != 1)\n         return;\n\n      if (allowModeSwitch)\n      {\n         StatusAndPath item = view_.getChangelistTable().getSelectedItems().get(0);\n         if ((item.getStatus().charAt(0) == ' ' || item.getStatus().charAt(0) == '?')\n             && view_.getStagedCheckBox().getValue())\n         {\n            view_.getUnstagedCheckBox().setValue(true, true);\n         }\n         else if (item.getStatus().charAt(1) == ' ' && view_.getUnstagedCheckBox().getValue())\n         {\n            view_.getStagedCheckBox().setValue(true, true);\n         }\n      }\n\n      view_.setFilename(paths.get(0).getPath());\n\n      diffInvalidation_.invalidate();\n      final Token token = diffInvalidation_.getInvalidationToken();\n\n      final PatchMode patchMode = view_.getStagedCheckBox().getValue()\n                                  ? PatchMode.Stage\n                                  : PatchMode.Working;\n      server_.vcsDiffFile(\n            paths.get(0).getPath(),\n            patchMode,\n            view_.getContextLines().getValue(),\n            new SimpleRequestCallback<String>(\"Diff Error\")\n            {\n               @Override\n               public void onResponseReceived(String response)\n               {\n                  if (token.isInvalid())\n                     return;\n\n                  UnifiedParser parser = new UnifiedParser(response);\n                  parser.nextFilePair();\n\n                  ArrayList<ChunkOrLine> allLines = new ArrayList<ChunkOrLine>();\n\n                  activeChunks_.clear();\n                  for (DiffChunk chunk;\n                       null != (chunk = parser.nextChunk()); )\n                  {\n                     activeChunks_.add(chunk);\n                     allLines.add(new ChunkOrLine(chunk));\n                     for (Line line : chunk.diffLines)\n                        allLines.add(new ChunkOrLine(line));\n                  }\n\n                  view_.getLineTableDisplay().setShowActions(\n                        paths.get(0).isFineGrainedActionable());\n                  view_.getLineTableDisplay().setData(allLines, patchMode);\n                  view_.getGutter().setValue(allLines);\n               }\n            });\n   }","commit_id":"34bbc6d63450c68d274b6257e8f8408a21667210","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n      public void onClick(ClickEvent event)\n      {\n         ArrayList<Line> selectedLines = view_.getLineTableDisplay().getSelectedLines();\n         if (selectedLines.size() == 0)\n            selectedLines = view_.getLineTableDisplay().getAllLines();\n\n         applyPatch(activeChunks_, selectedLines, reverse_, patchMode_);\n      }","id":42264,"modified_method":"@Override\n      public void onClick(ClickEvent event)\n      {\n         ArrayList<Line> selectedLines = view_.getLineTableDisplay().getSelectedLines();\n         if (selectedLines.size() != 0)\n         {\n            applyPatch(activeChunks_, selectedLines, reverse_, patchMode_);\n         }\n         else\n         {\n            ArrayList<String> paths = view_.getSelectedPaths();\n\n            if (patchMode_ == PatchMode.Stage && !reverse_)\n               server_.vcsStage(paths, new SimpleRequestCallback<Void>(\"Stage\"));\n            else if (patchMode_ == PatchMode.Stage && reverse_)\n               server_.vcsUnstage(paths, new SimpleRequestCallback<Void>(\"Unstage\"));\n            else if (patchMode_ == PatchMode.Working && reverse_)\n               server_.vcsDiscard(paths, new SimpleRequestCallback<Void>(\"Discard\"));\n            else\n               throw new RuntimeException(\"Unknown patchMode and reverse combo\");\n         }\n      }","commit_id":"34bbc6d63450c68d274b6257e8f8408a21667210","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n    public void execute( String[] args ) throws IncorrectUsage, CommandFailed\n    {\n        String database;\n        Boolean verbose;\n        File additionalConfigFile;\n\n        Args parsedArgs = Args.parse( args );\n        try\n        {\n            database = parsedArgs.interpretOption( \"database\", Converters.mandatory(), s -> s );\n            verbose = parsedArgs.getBoolean( \"verbose\" );\n            additionalConfigFile =\n                    parsedArgs.interpretOption( \"additional-config\", Converters.optional(), Converters.toFile() );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new IncorrectUsage( e.getMessage() );\n        }\n\n        Config config = loadNeo4jConfig( homeDir, configDir, database, loadAdditionalConfig( additionalConfigFile ) );\n\n        try\n        {\n            File storeDir = config.get( database_path );\n            checkDbState( storeDir, config );\n            consistencyCheckService.runFullConsistencyCheck( storeDir, config,\n                    ProgressMonitorFactory.textual( System.err ), FormattedLogProvider.toOutputStream( System.out ),\n                    this.fileSystemAbstraction, verbose );\n        }\n        catch ( ConsistencyCheckIncompleteException | IOException e )\n        {\n            throw new CommandFailed( \"Consistency checking failed.\" + e.getMessage(), e );\n        }\n    }","id":42265,"modified_method":"@Override\n    public void execute( String[] args ) throws IncorrectUsage, CommandFailed\n    {\n        String database;\n        Boolean verbose;\n        File additionalConfigFile;\n\n        Args parsedArgs = Args.parse( args );\n        try\n        {\n            database = parsedArgs.interpretOption( \"database\", Converters.mandatory(), s -> s );\n            verbose = parsedArgs.getBoolean( \"verbose\" );\n            additionalConfigFile =\n                    parsedArgs.interpretOption( \"additional-config\", Converters.optional(), Converters.toFile() );\n        }\n        catch ( IllegalArgumentException e )\n        {\n            throw new IncorrectUsage( e.getMessage() );\n        }\n\n        Config config = loadNeo4jConfig( homeDir, configDir, database, loadAdditionalConfig( additionalConfigFile ) );\n\n        try\n        {\n            File storeDir = config.get( database_path );\n            checkDbState( storeDir, config );\n            ConsistencyCheckService.Result consistencyCheckResult = consistencyCheckService\n                    .runFullConsistencyCheck( storeDir, config, ProgressMonitorFactory.textual( System.err ),\n                            FormattedLogProvider.toOutputStream( System.out ), this.fileSystemAbstraction, verbose );\n\n            if ( !consistencyCheckResult.isSuccessful() )\n            {\n                throw new CommandFailed( String.format( \"Inconsistencies found. See '%s' for details.\",\n                        consistencyCheckService.chooseReportPath( config, storeDir ).toString() ) );\n            }\n        }\n        catch ( ConsistencyCheckIncompleteException | IOException e )\n        {\n            throw new CommandFailed( \"Consistency checking failed.\" + e.getMessage(), e );\n        }\n    }","commit_id":"c4214fcca4bc30e7bad7c36f9284d784c3fa986e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void runsConsistencyChecker() throws Exception\n    {\n        ConsistencyCheckService consistencyCheckService = mock( ConsistencyCheckService.class );\n\n        Path homeDir = testDir.directory( \"home\" ).toPath();\n        OutsideWorld outsideWorld = mock( OutsideWorld.class );\n        CheckConsistencyCommand checkConsistencyCommand =\n                new CheckConsistencyCommand( homeDir, testDir.directory( \"conf\" ).toPath(), outsideWorld,\n                        consistencyCheckService );\n\n        File databasePath = new File( homeDir.toFile(), \"data/databases/mydb\" );\n        checkConsistencyCommand.execute( new String[]{\"--database=mydb\"} );\n\n        verify( consistencyCheckService )\n                .runFullConsistencyCheck( eq( databasePath ), any( Config.class ), any( ProgressMonitorFactory.class ),\n                        any( LogProvider.class ), any( FileSystemAbstraction.class ), eq( false ) );\n    }","id":42266,"modified_method":"@Test\n    public void runsConsistencyChecker() throws Exception\n    {\n        ConsistencyCheckService consistencyCheckService = mock( ConsistencyCheckService.class );\n\n        Path homeDir = testDir.directory( \"home\" ).toPath();\n        OutsideWorld outsideWorld = mock( OutsideWorld.class );\n        CheckConsistencyCommand checkConsistencyCommand =\n                new CheckConsistencyCommand( homeDir, testDir.directory( \"conf\" ).toPath(), outsideWorld,\n                        consistencyCheckService );\n\n        File databasePath = new File( homeDir.toFile(), \"data/databases/mydb\" );\n\n        when( consistencyCheckService\n                .runFullConsistencyCheck( eq( databasePath ), any( Config.class ), any( ProgressMonitorFactory.class ),\n                        any( LogProvider.class ), any( FileSystemAbstraction.class ), eq( false ) ) )\n                .thenReturn( ConsistencyCheckService.Result.SUCCESS );\n\n        checkConsistencyCommand.execute( new String[]{\"--database=mydb\"} );\n\n        verify( consistencyCheckService )\n                .runFullConsistencyCheck( eq( databasePath ), any( Config.class ), any( ProgressMonitorFactory.class ),\n                        any( LogProvider.class ), any( FileSystemAbstraction.class ), eq( false ) );\n    }","commit_id":"c4214fcca4bc30e7bad7c36f9284d784c3fa986e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void enablesVerbosity() throws Exception\n    {\n        ConsistencyCheckService consistencyCheckService = mock( ConsistencyCheckService.class );\n\n        Path homeDir = testDir.directory( \"home\" ).toPath();\n        OutsideWorld outsideWorld = mock( OutsideWorld.class );\n        CheckConsistencyCommand checkConsistencyCommand =\n                new CheckConsistencyCommand( homeDir, testDir.directory( \"conf\" ).toPath(), outsideWorld,\n                        consistencyCheckService );\n\n        File databasePath = new File( homeDir.toFile(), \"data/databases/mydb\" );\n\n        checkConsistencyCommand.execute( new String[]{\"--database=mydb\", \"--verbose\"} );\n\n        verify( consistencyCheckService )\n                .runFullConsistencyCheck( eq( databasePath ), any( Config.class ), any( ProgressMonitorFactory.class ),\n                        any( LogProvider.class ), any( FileSystemAbstraction.class ), eq( true ) );\n    }","id":42267,"modified_method":"@Test\n    public void enablesVerbosity() throws Exception\n    {\n        ConsistencyCheckService consistencyCheckService = mock( ConsistencyCheckService.class );\n\n        Path homeDir = testDir.directory( \"home\" ).toPath();\n        OutsideWorld outsideWorld = mock( OutsideWorld.class );\n        CheckConsistencyCommand checkConsistencyCommand =\n                new CheckConsistencyCommand( homeDir, testDir.directory( \"conf\" ).toPath(), outsideWorld,\n                        consistencyCheckService );\n\n        File databasePath = new File( homeDir.toFile(), \"data/databases/mydb\" );\n\n        when( consistencyCheckService\n                .runFullConsistencyCheck( eq( databasePath ), any( Config.class ), any( ProgressMonitorFactory.class ),\n                        any( LogProvider.class ), any( FileSystemAbstraction.class ), eq( true ) ) )\n                .thenReturn( ConsistencyCheckService.Result.SUCCESS );\n\n        checkConsistencyCommand.execute( new String[]{\"--database=mydb\", \"--verbose\"} );\n\n        verify( consistencyCheckService )\n                .runFullConsistencyCheck( eq( databasePath ), any( Config.class ), any( ProgressMonitorFactory.class ),\n                        any( LogProvider.class ), any( FileSystemAbstraction.class ), eq( true ) );\n    }","commit_id":"c4214fcca4bc30e7bad7c36f9284d784c3fa986e","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File chooseReportPath( Config tuningConfiguration, File storeDir )\n    {\n        if ( tuningConfiguration.get( GraphDatabaseSettings.neo4j_home ) == null )\n        {\n            tuningConfiguration = tuningConfiguration.with(\n                    stringMap( GraphDatabaseSettings.neo4j_home.name(), storeDir.getAbsolutePath() ) );\n        }\n\n        final File reportPath = tuningConfiguration.get( GraphDatabaseSettings.logs_directory );\n        return new File( reportPath, defaultLogFileName( timestamp ) );\n    }","id":42268,"modified_method":"public File chooseReportPath( Config tuningConfiguration, File storeDir )\n    {\n        if ( tuningConfiguration.get( GraphDatabaseSettings.neo4j_home ) == null )\n        {\n            tuningConfiguration = tuningConfiguration.with(\n                    stringMap( GraphDatabaseSettings.neo4j_home.name(), storeDir.getAbsolutePath() ) );\n        }\n\n        final File reportPath = tuningConfiguration.get( GraphDatabaseSettings.logs_directory );\n        return new File( reportPath, defaultLogFileName( timestamp ) );\n    }","commit_id":"c4214fcca4bc30e7bad7c36f9284d784c3fa986e","url":"https://github.com/neo4j/neo4j"},{"original_method":"String defaultLogFileName()\n    {\n        return String.format( \"inconsistencies-%s.report\",\n                new SimpleDateFormat( \"yyyy-MM-dd.HH.mm.ss\" ).format( timestamp ) );\n    }","id":42269,"modified_method":"public static String defaultLogFileName( Date date )\n    {\n        final String formattedDate = new SimpleDateFormat( \"yyyy-MM-dd.HH.mm.ss\" ).format( date );\n        return String.format( \"inconsistencies-%s.report\", formattedDate );\n    }","commit_id":"511cc95b8020ad47ddf74465d45290d36d0350f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"private File chooseReportPath( Config tuningConfiguration )\n    {\n        File reportPath = tuningConfiguration.get( ConsistencyCheckSettings.consistency_check_report_file );\n        File reportFile;\n        if ( reportPath == null )\n        {\n            reportFile = new File( tuningConfiguration.get( GraphDatabaseSettings.store_dir ), defaultLogFileName() );\n        } else\n        {\n            if ( reportPath.isDirectory() )\n            {\n                reportFile = new File( reportPath, defaultLogFileName() );\n            }\n            else\n            {\n                reportFile = reportPath;\n            }\n        }\n        return reportFile;\n    }","id":42270,"modified_method":"private File chooseReportPath( Config tuningConfiguration )\n    {\n        final File reportPath = tuningConfiguration.get( ConsistencyCheckSettings.consistency_check_report_file );\n        if ( reportPath == null )\n        {\n            return new File( tuningConfiguration.get( GraphDatabaseSettings.store_dir ),\n                    defaultLogFileName( timestamp ) );\n        }\n\n        if ( reportPath.isDirectory() )\n        {\n            return new File( reportPath, defaultLogFileName( timestamp ) );\n        }\n\n        return reportPath;\n    }","commit_id":"511cc95b8020ad47ddf74465d45290d36d0350f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Result runFullConsistencyCheck( String storeDir,\n                                           Config tuningConfiguration,\n                                           ProgressMonitorFactory progressFactory,\n                                           StringLogger logger ) throws ConsistencyCheckIncompleteException\n    {\n        Map<String, String> params = tuningConfiguration.getParams();\n        params.put( GraphDatabaseSettings.store_dir.name(), storeDir );\n        tuningConfiguration.applyChanges( params );\n\n        DefaultFileSystemAbstraction fileSystem = new DefaultFileSystemAbstraction();\n        StoreFactory factory = new StoreFactory(\n                tuningConfiguration,\n                new DefaultIdGeneratorFactory(),\n                tuningConfiguration.get( ConsistencyCheckSettings.consistency_check_window_pool_implementation )\n                        .windowPoolFactory( tuningConfiguration, logger ), fileSystem, logger,\n                new DefaultTxHook() );\n\n        ConsistencySummaryStatistics summary;\n        File reportFile = chooseReportPath( tuningConfiguration );\n        StringLogger report = StringLogger.lazyLogger( reportFile );\n\n        NeoStore neoStore = factory.newNeoStore( new File( storeDir, NeoStore.DEFAULT_NAME ) );\n        try\n        {\n            neoStore.makeStoreOk();\n            StoreAccess store = new StoreAccess( neoStore );\n            LabelScanStore labelScanStore = null;\n            try {\n\n                labelScanStore =\n                    new LuceneLabelScanStoreBuilder( storeDir, store.getRawNeoStore(), fileSystem, logger ).build();\n                SchemaIndexProvider indexes = new LuceneSchemaIndexProvider( DirectoryFactory.PERSISTENT, tuningConfiguration );\n                DirectStoreAccess stores = new DirectStoreAccess( store, labelScanStore, indexes );\n                summary = new FullCheck( tuningConfiguration, progressFactory )\n                        .execute( stores, StringLogger.tee( logger, report ) );\n            }\n            finally\n            {\n                try\n                {\n                    if ( null != labelScanStore )\n                    {\n                        labelScanStore.shutdown();\n                    }\n                }\n                catch ( IOException e )\n                {\n                    logger.error( \"Faiure during shutdown of label scan store\", e );\n                }\n            }\n        }\n        finally\n        {\n\n            report.close();\n            neoStore.close();\n        }\n\n        if ( !summary.isConsistent() )\n        {\n            logger.logMessage( String.format( \"See '%s' for a detailed consistency report.\", reportFile.getPath() ) );\n            return Result.FAILURE;\n        }\n        else\n        {\n            return Result.SUCCESS;\n        }\n    }","id":42271,"modified_method":"public Result runFullConsistencyCheck( String storeDir,\n                                                  Config tuningConfiguration,\n                                                  ProgressMonitorFactory progressFactory,\n                                           StringLogger logger ) throws ConsistencyCheckIncompleteException\n    {\n        Map<String, String> params = tuningConfiguration.getParams();\n        params.put( GraphDatabaseSettings.store_dir.name(), storeDir );\n        tuningConfiguration.applyChanges( params );\n\n        DefaultFileSystemAbstraction fileSystem = new DefaultFileSystemAbstraction();\n        StoreFactory factory = new StoreFactory(\n                tuningConfiguration,\n                new DefaultIdGeneratorFactory(),\n                tuningConfiguration.get( ConsistencyCheckSettings.consistency_check_window_pool_implementation )\n                        .windowPoolFactory( tuningConfiguration, logger ), fileSystem, logger,\n                new DefaultTxHook() );\n\n        ConsistencySummaryStatistics summary;\n        File reportFile = chooseReportPath( tuningConfiguration );\n        StringLogger report = StringLogger.lazyLogger( reportFile );\n\n        NeoStore neoStore = factory.newNeoStore( new File( storeDir, NeoStore.DEFAULT_NAME ) );\n        try\n        {\n            neoStore.makeStoreOk();\n            StoreAccess store = new StoreAccess( neoStore );\n            LabelScanStore labelScanStore = null;\n            try {\n\n                labelScanStore =\n                    new LuceneLabelScanStoreBuilder( storeDir, store.getRawNeoStore(), fileSystem, logger ).build();\n                SchemaIndexProvider indexes = new LuceneSchemaIndexProvider( DirectoryFactory.PERSISTENT, tuningConfiguration );\n                DirectStoreAccess stores = new DirectStoreAccess( store, labelScanStore, indexes );\n                summary = new FullCheck( tuningConfiguration, progressFactory )\n                        .execute( stores, StringLogger.tee( logger, report ) );\n            }\n            finally\n            {\n                try\n                {\n                    if ( null != labelScanStore )\n                    {\n                        labelScanStore.shutdown();\n                    }\n                }\n                catch ( IOException e )\n                {\n                    logger.error( \"Faiure during shutdown of label scan store\", e );\n                }\n            }\n        }\n        finally\n        {\n\n            report.close();\n            neoStore.close();\n        }\n\n        if ( !summary.isConsistent() )\n        {\n            logger.logMessage( String.format( \"See '%s' for a detailed consistency report.\", reportFile.getPath() ) );\n            return Result.FAILURE;\n        }\n\n        return Result.SUCCESS;\n    }","commit_id":"511cc95b8020ad47ddf74465d45290d36d0350f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldWriteInconsistenciesToLogFileAtSpecifiedLocation() throws Exception\n    {\n        // given\n        breakNodeStore();\n        ConsistencyCheckService service = new ConsistencyCheckService();\n        File specificLogFile = new File( testDirectory.directory(), \"specific_logfile.txt\" );\n\n        // when\n        service.runFullConsistencyCheck( fixture.directory().getPath(),\n                new Config( stringMap( ConsistencyCheckSettings.consistency_check_report_file.name(),specificLogFile.getPath()),\n                        GraphDatabaseSettings.class, ConsistencyCheckSettings.class ),\n                ProgressMonitorFactory.NONE, StringLogger.DEV_NULL );\n\n        // then\n        assertTrue( \"Inconsistency report file \" + specificLogFile + \" not generated\", specificLogFile.exists() );\n    }","id":42272,"modified_method":"@Test\n    public void shouldWriteInconsistenciesToLogFileAtSpecifiedLocation() throws Exception\n    {\n        // given\n        breakNodeStore();\n        ConsistencyCheckService service = new ConsistencyCheckService();\n        File specificLogFile = new File( testDirectory.directory(), \"specific_logfile.txt\" );\n        Config configuration = new Config(\n                stringMap( ConsistencyCheckSettings.consistency_check_report_file.name(), specificLogFile.getPath() ),\n                GraphDatabaseSettings.class, ConsistencyCheckSettings.class\n        );\n\n        // when\n        service.runFullConsistencyCheck( fixture.directory().getPath(), configuration,\n                ProgressMonitorFactory.NONE, StringLogger.DEV_NULL );\n\n        // then\n        assertTrue( \"Inconsistency report file \" + specificLogFile + \" not generated\", specificLogFile.exists() );\n    }","commit_id":"511cc95b8020ad47ddf74465d45290d36d0350f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldSucceedIfStoreIsConsistent() throws Exception\n    {\n        // given\n        ConsistencyCheckService service = new ConsistencyCheckService();\n\n        // when\n        ConsistencyCheckService.Result result = service.runFullConsistencyCheck( fixture.directory().getPath(),\n                new Config( stringMap(  ), GraphDatabaseSettings.class, ConsistencyCheckSettings.class ),\n                ProgressMonitorFactory.NONE, StringLogger.DEV_NULL );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.SUCCESS, result );\n        File reportFile = new File( fixture.directory(), service.defaultLogFileName() );\n        assertFalse( \"Inconsistency report file \" + reportFile + \" not generated\", reportFile.exists() );\n    }","id":42273,"modified_method":"@Test\n    public void shouldSucceedIfStoreIsConsistent() throws Exception\n    {\n        // given\n        Date timestamp = new Date();\n        ConsistencyCheckService service = new ConsistencyCheckService( timestamp );\n        Config configuration = new Config( stringMap(), GraphDatabaseSettings.class, ConsistencyCheckSettings.class );\n\n        // when\n        ConsistencyCheckService.Result result = service.runFullConsistencyCheck( fixture.directory().getPath(),\n                configuration, ProgressMonitorFactory.NONE, StringLogger.DEV_NULL );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.SUCCESS, result );\n        File reportFile = new File( fixture.directory(), defaultLogFileName( timestamp ) );\n        assertFalse( \"Inconsistency report file \" + reportFile + \" not generated\", reportFile.exists() );\n    }","commit_id":"511cc95b8020ad47ddf74465d45290d36d0350f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailIfTheStoreInNotConsistent() throws Exception\n    {\n        // given\n        breakNodeStore();\n        ConsistencyCheckService service = new ConsistencyCheckService();\n\n        // when\n        ConsistencyCheckService.Result result = service.runFullConsistencyCheck( fixture.directory().getPath(),\n                new Config( stringMap(), GraphDatabaseSettings.class, ConsistencyCheckSettings.class ),\n                ProgressMonitorFactory.NONE, StringLogger.DEV_NULL );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.FAILURE, result );\n        File reportFile = new File(fixture.directory(), service.defaultLogFileName());\n        assertTrue( \"Inconsistency report file \" + reportFile + \" not generated\", reportFile.exists() );\n    }","id":42274,"modified_method":"@Test\n    public void shouldFailIfTheStoreInNotConsistent() throws Exception\n    {\n        // given\n        breakNodeStore();\n        Date timestamp = new Date();\n        ConsistencyCheckService service = new ConsistencyCheckService( timestamp );\n        Config configuration = new Config( stringMap(), GraphDatabaseSettings.class, ConsistencyCheckSettings.class );\n\n        // when\n        ConsistencyCheckService.Result result = service.runFullConsistencyCheck( fixture.directory().getPath(),\n                configuration, ProgressMonitorFactory.NONE, StringLogger.DEV_NULL );\n\n        // then\n        assertEquals( ConsistencyCheckService.Result.FAILURE, result );\n        File reportFile = new File( fixture.directory(), defaultLogFileName( timestamp ) );\n        assertTrue( \"Inconsistency report file \" + reportFile + \" not generated\", reportFile.exists() );\n    }","commit_id":"511cc95b8020ad47ddf74465d45290d36d0350f3","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ApplicationEnvironment(CoreApplicationEnvironment appEnvironment) {\n      appEnvironment.registerFileType(GroovyFileType.GROOVY_FILE_TYPE, GroovyFileType.DEFAULT_EXTENSION);\n\n      appEnvironment.addExplicitExtension(SyntaxHighlighterFactory.LANGUAGE_FACTORY, GroovyLanguage.INSTANCE,\n                                          new GroovySyntaxHighlighterFactory());\n\n      appEnvironment.addExplicitExtension(LanguageParserDefinitions.INSTANCE, GroovyLanguage.INSTANCE, new GroovyParserDefinition());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrMethodComparator.EP_NAME, GrMethodComparator.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), NonCodeMembersContributor.EP_NAME, NonCodeMembersContributor.class);\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebBrowserMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebJUnitTestMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebModuleMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebPageMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebSpockTestMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebTestNGTestMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GrCollectionTypeMembersProvider());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new MixinMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new SpockMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new XmlMarkupBuilderNonCodeMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new DGMMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new SwingBuilderNonCodeMemberContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), DefaultImportContributor.EP_NAME,\n                                                        DefaultImportContributor.class);\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), AstTransformContributor.EP_NAME, AstTransformContributor.class);\n      appEnvironment.addExtension(AstTransformContributor.EP_NAME, new AutoCloneContributor());\n      appEnvironment.addExtension(AstTransformContributor.EP_NAME, new AutoExternalizeContributor());\n      appEnvironment.addExtension(AstTransformContributor.EP_NAME, new ConstructorAnnotationsProcessor());\n      appEnvironment.addExtension(AstTransformContributor.EP_NAME, new DelegatedMethodsContributor());\n      appEnvironment.addExtension(AstTransformContributor.EP_NAME, new GrInheritConstructorContributor());\n      appEnvironment.addExtension(AstTransformContributor.EP_NAME, new LoggingContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ClosureMissingMethodContributor.EP_NAME,\n                                                        ClosureMissingMethodContributor.class);\n      appEnvironment.addExtension(ClosureMissingMethodContributor.EP_NAME, new PluginXmlClosureMemberContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrVariableEnhancer.EP_NAME, GrVariableEnhancer.class);\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new ClosureAsAnonymousParameterEnhancer());\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new ClosureParameterEnhancer());\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new ClosureParamsEnhancer());\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new GppClosureParameterTypeProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrReferenceTypeEnhancer.EP_NAME,\n                                                        GrReferenceTypeEnhancer.class);\n      appEnvironment.addExtension(GrReferenceTypeEnhancer.EP_NAME, new GroovyMapValueTypeEnhancer());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrTypeConverter.EP_NAME, GrTypeConverter.class);\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrBooleanTypeConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrGenericTypeConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrClassConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrNullVoidConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrCharConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrNumberConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrStringConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrEnumConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrContainerTypeConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new ClosureToSamConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrContainerConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GppTypeConverter());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyExpectedTypesContributor.EP_NAME,\n                                                        GroovyExpectedTypesContributor.class);\n      appEnvironment.addExtension(GroovyExpectedTypesContributor.EP_NAME, new GppExpectedTypesContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyScriptTypeDetector.EP_NAME,\n                                                        GroovyScriptTypeDetector.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyNamedArgumentProvider.EP_NAME, GroovyNamedArgumentProvider.class);\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new GroovyConstructorNamedArgumentProvider());\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new GroovyMethodReturnNamedArgumentProvider());\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new GroovySourceCodeNamedArgumentProvider());\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new SwingBuilderNamedArgumentProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyMapContentProvider.EP_NAME,\n                                                        GroovyMapContentProvider.class);\n      appEnvironment.addExtension(GroovyMapContentProvider.EP_NAME, new ConfigSlurperMapContentProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyUnresolvedHighlightFilter.EP_NAME,\n                                                        GroovyUnresolvedHighlightFilter.class);\n      appEnvironment.addExtension(GroovyUnresolvedHighlightFilter.EP_NAME, new GroovyUnresolvedReferenceFilterByFile());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyUnresolvedHighlightFileFilter.EP_NAME,\n                                                        GroovyUnresolvedHighlightFileFilter.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrCallExpressionTypeCalculator.EP_NAME, GrCallExpressionTypeCalculator.class);\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new DefaultCallExpressionTypeCalculator());\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new GrDescriptorReturnTypeCalculator());\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new GrDGMTypeCalculator());\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new GrWithTraitTypeCalculator());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrExpressionTypeCalculator.EP_NAME, GrExpressionTypeCalculator.class);\n      appEnvironment.addExtension(GrExpressionTypeCalculator.EP_NAME, new GrClosureDelegateTypeCalculator());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyClassDescriptor.EP_NAME,\n                                                        GroovyClassDescriptor.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyMethodDescriptorExtension.EP_NAME,\n                                                        GroovyMethodDescriptorExtension.class);\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), PsiEnhancerCategory.EP_NAME, PsiEnhancerCategory.class);\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new GrExpressionCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiClassCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiElementCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiExpressionCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiMethodCategory());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GdslMembersProvider.EP_NAME, GdslMembersProvider.class);\n      appEnvironment.addExtension(GdslMembersProvider.EP_NAME, new GdkMethodDslProvider());\n      appEnvironment.addExtension(GdslMembersProvider.EP_NAME, new GroovyDslDefaultMembers());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyFrameworkConfigNotification.EP_NAME,\n                                                        GroovyFrameworkConfigNotification.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrMethodMayBeStaticInspectionFilter.EP_NAME, GrMethodMayBeStaticInspectionFilter.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), CustomAnnotationChecker.EP_NAME, CustomAnnotationChecker.class);\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new AnnotationCollectorChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new BaseScriptAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new DelegatesToAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new FieldAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new GrabAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new GrAliasAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new NewifyAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new TypeCheckedAnnotationChecker());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ImplicitPropertyUsageProvider.EP_NAME,\n                                                        ImplicitPropertyUsageProvider.class);\n      appEnvironment.addExtension(ImplicitPropertyUsageProvider.EP_NAME, new DGMImplicitPropertyUsageProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ImplicitUsageProvider.EP_NAME,\n                                                        ImplicitUsageProvider.class);\n      appEnvironment.addExtension(ImplicitUsageProvider.EP_NAME, new GrImplicitUsageProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), FileTypeRegistry.FileTypeDetector.EP_NAME,\n                                                        FileTypeRegistry.FileTypeDetector.class);\n      appEnvironment.addExtension(FileTypeRegistry.FileTypeDetector.EP_NAME, new GroovyHashBangFileTypeDetector());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ClsCustomNavigationPolicy.EP_NAME,\n                                                        ClsCustomNavigationPolicy.class);\n      appEnvironment.addExtension(ClsCustomNavigationPolicy.EP_NAME, new GroovyClsCustomNavigationPolicy());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), PomDeclarationSearcher.EP_NAME,\n                                                        PomDeclarationSearcher.class);\n      appEnvironment.addExtension(PomDeclarationSearcher.EP_NAME, new GebContentDeclarationSearcher());\n      appEnvironment.addExtension(PomDeclarationSearcher.EP_NAME, new SpockPomDeclarationSearcher());\n\n      appEnvironment.addExplicitExtension(LanguageConstantExpressionEvaluator.INSTANCE, GroovyLanguage.INSTANCE,\n                                          new GroovyConstantExpressionEvaluator());\n\n      appEnvironment.addExplicitExtension(ExpressionConverter.EP, GroovyLanguage.INSTANCE, new GroovyExpressionConverter());\n      appEnvironment.addExplicitExtension(LanguageAnnotators.INSTANCE, GroovyLanguage.INSTANCE, new GrAnnotatorImpl());\n      appEnvironment.addExplicitExtension(LanguageAnnotators.INSTANCE, GroovyLanguage.INSTANCE, new GroovyDslAnnotator());\n\n      appEnvironment.addExplicitExtension(LanguageStructureViewBuilder.INSTANCE, GroovyLanguage.INSTANCE, new GroovyStructureViewFactory());\n      appEnvironment.addExplicitExtension(LanguageFolding.INSTANCE, GroovyLanguage.INSTANCE, new GroovyFoldingBuilder());\n      appEnvironment.addExplicitExtension(LanguageFindUsages.INSTANCE, GroovyLanguage.INSTANCE, new GroovyFindUsagesProvider());\n      appEnvironment.addExplicitExtension(ReferenceAdjuster.Extension.INSTANCE, GroovyLanguage.INSTANCE, new GrReferenceAdjuster());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), UseScopeEnlarger.EP_NAME, UseScopeEnlarger.class);\n      appEnvironment.addExtension(UseScopeEnlarger.EP_NAME, new GrPrivateFieldScopeEnlarger());\n\n      DirectClassInheritorsSearch.INSTANCE.registerExecutor(new GroovyDirectInheritorsSearcher());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), MethodReferencesSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new AccessorMethodReferencesSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new MethodLateBoundReferencesSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new GroovyConstructorUsagesSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new GroovyReflectedMethodReferenceSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new GrLiteralMethodSearcher());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), AnnotatedElementsSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(AnnotatedElementsSearch.EP_NAME, new AnnotatedMembersSearcher());\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), SuperMethodsSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(SuperMethodsSearch.EP_NAME, new GDKSuperMethodSearcher());\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), DefinitionsScopedSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(DefinitionsScopedSearch.EP_NAME, new GroovyImplementationSearch());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), StubIndexExtension.EP_NAME, StubIndexExtension.class);\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrAnnotationMethodNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrAnnotatedMemberIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrAnonymousClassIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrDirectInheritorsIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrFieldNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrFullClassNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrFullScriptNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrMethodNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrScriptClassNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrScriptClassNameIndex());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), FileBasedIndexExtension.EXTENSION_POINT_NAME,\n                                                        FileBasedIndexExtension.class);\n      appEnvironment.addExtension(FileBasedIndexExtension.EXTENSION_POINT_NAME, new GroovyDslFileIndex());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ReferencesSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new ConstructorReferencesSearcher());\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new GrAliasedImportedElementSearcher());\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new AccessorReferencesSearcher());\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new GroovyTraitFieldSearcher());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), FileIconProvider.EP_NAME, FileIconProvider.class);\n      appEnvironment.addExtension(FileIconProvider.EP_NAME, new GroovyFileIconProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ResolveScopeProvider.EP_NAME, ResolveScopeProvider.class);\n      appEnvironment.addExtension(ResolveScopeProvider.EP_NAME, new GroovyResolveScopeProvider());\n\n\n      Class<Condition<VirtualFile>> conditionClass = (Class)Condition.class;\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), WolfTheProblemSolver.FILTER_EP_NAME, conditionClass);\n      appEnvironment.addExtension(WolfTheProblemSolver.FILTER_EP_NAME, new GroovyProblemFileHighlightFilter());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ClassTypePointerFactory.EP_NAME, ClassTypePointerFactory.class);\n      appEnvironment.addExtension(ClassTypePointerFactory.EP_NAME, new GrClassReferenceTypePointerFactory());\n\n      appEnvironment.registerApplicationService(GroovyQuickFixFactory.class, new EmptyGroovyQuickFixFactory());\n      appEnvironment.registerApplicationComponent(DslActivationStatus.class, new DslActivationStatus());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ReadWriteAccessDetector.EP_NAME, ReadWriteAccessDetector.class);\n      appEnvironment.addExtension(ReadWriteAccessDetector.EP_NAME, new GroovyReadWriteAccessDetector());\n      if (GroovyElementTypes.ADDITIVE_EXPRESSION == null) throw new IllegalStateException(); // initialize tokens\n    }","id":42275,"modified_method":"public ApplicationEnvironment(CoreApplicationEnvironment appEnvironment) {\n      appEnvironment.registerFileType(GroovyFileType.GROOVY_FILE_TYPE, GroovyFileType.DEFAULT_EXTENSION);\n\n      appEnvironment.addExplicitExtension(SyntaxHighlighterFactory.LANGUAGE_FACTORY, GroovyLanguage.INSTANCE,\n                                          new GroovySyntaxHighlighterFactory());\n\n      appEnvironment.addExplicitExtension(LanguageParserDefinitions.INSTANCE, GroovyLanguage.INSTANCE, new GroovyParserDefinition());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrMethodComparator.EP_NAME, GrMethodComparator.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), NonCodeMembersContributor.EP_NAME, NonCodeMembersContributor.class);\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebBrowserMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebJUnitTestMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebModuleMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebPageMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebSpockTestMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GebTestNGTestMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new GrCollectionTypeMembersProvider());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new MixinMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new SpockMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new XmlMarkupBuilderNonCodeMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new DGMMemberContributor());\n      appEnvironment.addExtension(NonCodeMembersContributor.EP_NAME, new SwingBuilderNonCodeMemberContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), DefaultImportContributor.EP_NAME,\n                                                        DefaultImportContributor.class);\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), AstTransformationSupport.EP_NAME, AstTransformationSupport.class);\n\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new AutoExternalizeContributor());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new AutoCloneContributor());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new ConstructorAnnotationsProcessor());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new InheritConstructorContributor());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new DefaultBuilderStrategySupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new SimpleBuilderStrategySupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new ExternalBuilderStrategySupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new InitializerBuilderStrategySupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new BindableTransformContributor());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new LoggingContributor());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new CategoryTransformationSupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new DelegateTransformationSupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new DefaultTransformationSupport());\n      appEnvironment.addExtension(AstTransformationSupport.EP_NAME, new TraitTransformationSupport());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ClosureMissingMethodContributor.EP_NAME,\n                                                        ClosureMissingMethodContributor.class);\n      appEnvironment.addExtension(ClosureMissingMethodContributor.EP_NAME, new PluginXmlClosureMemberContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrVariableEnhancer.EP_NAME, GrVariableEnhancer.class);\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new ClosureAsAnonymousParameterEnhancer());\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new ClosureParameterEnhancer());\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new ClosureParamsEnhancer());\n      appEnvironment.addExtension(GrVariableEnhancer.EP_NAME, new GppClosureParameterTypeProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrReferenceTypeEnhancer.EP_NAME,\n                                                        GrReferenceTypeEnhancer.class);\n      appEnvironment.addExtension(GrReferenceTypeEnhancer.EP_NAME, new GroovyMapValueTypeEnhancer());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrTypeConverter.EP_NAME, GrTypeConverter.class);\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrBooleanTypeConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrGenericTypeConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrClassConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrNullVoidConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrCharConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrNumberConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrStringConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrEnumConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrContainerTypeConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new ClosureToSamConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GrContainerConverter());\n      appEnvironment.addExtension(GrTypeConverter.EP_NAME, new GppTypeConverter());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyExpectedTypesContributor.EP_NAME,\n                                                        GroovyExpectedTypesContributor.class);\n      appEnvironment.addExtension(GroovyExpectedTypesContributor.EP_NAME, new GppExpectedTypesContributor());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyScriptTypeDetector.EP_NAME,\n                                                        GroovyScriptTypeDetector.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyNamedArgumentProvider.EP_NAME, GroovyNamedArgumentProvider.class);\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new GroovyConstructorNamedArgumentProvider());\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new GroovyMethodReturnNamedArgumentProvider());\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new GroovySourceCodeNamedArgumentProvider());\n      appEnvironment.addExtension(GroovyNamedArgumentProvider.EP_NAME, new SwingBuilderNamedArgumentProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyMapContentProvider.EP_NAME,\n                                                        GroovyMapContentProvider.class);\n      appEnvironment.addExtension(GroovyMapContentProvider.EP_NAME, new ConfigSlurperMapContentProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyUnresolvedHighlightFilter.EP_NAME,\n                                                        GroovyUnresolvedHighlightFilter.class);\n      appEnvironment.addExtension(GroovyUnresolvedHighlightFilter.EP_NAME, new GroovyUnresolvedReferenceFilterByFile());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyUnresolvedHighlightFileFilter.EP_NAME,\n                                                        GroovyUnresolvedHighlightFileFilter.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrCallExpressionTypeCalculator.EP_NAME, GrCallExpressionTypeCalculator.class);\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new DefaultCallExpressionTypeCalculator());\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new GrDescriptorReturnTypeCalculator());\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new GrDGMTypeCalculator());\n      appEnvironment.addExtension(GrCallExpressionTypeCalculator.EP_NAME, new GrWithTraitTypeCalculator());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrExpressionTypeCalculator.EP_NAME, GrExpressionTypeCalculator.class);\n      appEnvironment.addExtension(GrExpressionTypeCalculator.EP_NAME, new GrClosureDelegateTypeCalculator());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyClassDescriptor.EP_NAME,\n                                                        GroovyClassDescriptor.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyMethodDescriptorExtension.EP_NAME,\n                                                        GroovyMethodDescriptorExtension.class);\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), PsiEnhancerCategory.EP_NAME, PsiEnhancerCategory.class);\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new GrExpressionCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiClassCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiElementCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiExpressionCategory());\n      appEnvironment.addExtension(PsiEnhancerCategory.EP_NAME, new PsiMethodCategory());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GdslMembersProvider.EP_NAME, GdslMembersProvider.class);\n      appEnvironment.addExtension(GdslMembersProvider.EP_NAME, new GdkMethodDslProvider());\n      appEnvironment.addExtension(GdslMembersProvider.EP_NAME, new GroovyDslDefaultMembers());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GroovyFrameworkConfigNotification.EP_NAME,\n                                                        GroovyFrameworkConfigNotification.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), GrMethodMayBeStaticInspectionFilter.EP_NAME, GrMethodMayBeStaticInspectionFilter.class);\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), CustomAnnotationChecker.EP_NAME, CustomAnnotationChecker.class);\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new AnnotationCollectorChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new BaseScriptAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new DelegatesToAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new FieldAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new GrabAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new GrAliasAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new NewifyAnnotationChecker());\n      appEnvironment.addExtension(CustomAnnotationChecker.EP_NAME, new TypeCheckedAnnotationChecker());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ImplicitPropertyUsageProvider.EP_NAME,\n                                                        ImplicitPropertyUsageProvider.class);\n      appEnvironment.addExtension(ImplicitPropertyUsageProvider.EP_NAME, new DGMImplicitPropertyUsageProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ImplicitUsageProvider.EP_NAME,\n                                                        ImplicitUsageProvider.class);\n      appEnvironment.addExtension(ImplicitUsageProvider.EP_NAME, new GrImplicitUsageProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), FileTypeRegistry.FileTypeDetector.EP_NAME,\n                                                        FileTypeRegistry.FileTypeDetector.class);\n      appEnvironment.addExtension(FileTypeRegistry.FileTypeDetector.EP_NAME, new GroovyHashBangFileTypeDetector());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ClsCustomNavigationPolicy.EP_NAME,\n                                                        ClsCustomNavigationPolicy.class);\n      appEnvironment.addExtension(ClsCustomNavigationPolicy.EP_NAME, new GroovyClsCustomNavigationPolicy());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), PomDeclarationSearcher.EP_NAME,\n                                                        PomDeclarationSearcher.class);\n      appEnvironment.addExtension(PomDeclarationSearcher.EP_NAME, new GebContentDeclarationSearcher());\n      appEnvironment.addExtension(PomDeclarationSearcher.EP_NAME, new SpockPomDeclarationSearcher());\n\n      appEnvironment.addExplicitExtension(LanguageConstantExpressionEvaluator.INSTANCE, GroovyLanguage.INSTANCE,\n                                          new GroovyConstantExpressionEvaluator());\n\n      appEnvironment.addExplicitExtension(ExpressionConverter.EP, GroovyLanguage.INSTANCE, new GroovyExpressionConverter());\n      appEnvironment.addExplicitExtension(LanguageAnnotators.INSTANCE, GroovyLanguage.INSTANCE, new GrAnnotatorImpl());\n      appEnvironment.addExplicitExtension(LanguageAnnotators.INSTANCE, GroovyLanguage.INSTANCE, new GroovyDslAnnotator());\n\n      appEnvironment.addExplicitExtension(LanguageStructureViewBuilder.INSTANCE, GroovyLanguage.INSTANCE, new GroovyStructureViewFactory());\n      appEnvironment.addExplicitExtension(LanguageFolding.INSTANCE, GroovyLanguage.INSTANCE, new GroovyFoldingBuilder());\n      appEnvironment.addExplicitExtension(LanguageFindUsages.INSTANCE, GroovyLanguage.INSTANCE, new GroovyFindUsagesProvider());\n      appEnvironment.addExplicitExtension(ReferenceAdjuster.Extension.INSTANCE, GroovyLanguage.INSTANCE, new GrReferenceAdjuster());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), UseScopeEnlarger.EP_NAME, UseScopeEnlarger.class);\n      appEnvironment.addExtension(UseScopeEnlarger.EP_NAME, new GrPrivateFieldScopeEnlarger());\n\n      DirectClassInheritorsSearch.INSTANCE.registerExecutor(new GroovyDirectInheritorsSearcher());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), MethodReferencesSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new AccessorMethodReferencesSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new MethodLateBoundReferencesSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new GroovyConstructorUsagesSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new GroovyReflectedMethodReferenceSearcher());\n      appEnvironment.addExtension(MethodReferencesSearch.EP_NAME, new GrLiteralMethodSearcher());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), AnnotatedElementsSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(AnnotatedElementsSearch.EP_NAME, new AnnotatedMembersSearcher());\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), SuperMethodsSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(SuperMethodsSearch.EP_NAME, new GDKSuperMethodSearcher());\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), DefinitionsScopedSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(DefinitionsScopedSearch.EP_NAME, new GroovyImplementationSearch());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), StubIndexExtension.EP_NAME, StubIndexExtension.class);\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrAnnotationMethodNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrAnnotatedMemberIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrAnonymousClassIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrDirectInheritorsIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrFieldNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrFullClassNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrFullScriptNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrMethodNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrScriptClassNameIndex());\n      appEnvironment.addExtension(StubIndexExtension.EP_NAME, new GrScriptClassNameIndex());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), FileBasedIndexExtension.EXTENSION_POINT_NAME,\n                                                        FileBasedIndexExtension.class);\n      appEnvironment.addExtension(FileBasedIndexExtension.EXTENSION_POINT_NAME, new GroovyDslFileIndex());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ReferencesSearch.EP_NAME, QueryExecutor.class);\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new ConstructorReferencesSearcher());\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new GrAliasedImportedElementSearcher());\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new AccessorReferencesSearcher());\n      appEnvironment.addExtension(ReferencesSearch.EP_NAME, new GroovyTraitFieldSearcher());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), FileIconProvider.EP_NAME, FileIconProvider.class);\n      appEnvironment.addExtension(FileIconProvider.EP_NAME, new GroovyFileIconProvider());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ResolveScopeProvider.EP_NAME, ResolveScopeProvider.class);\n      appEnvironment.addExtension(ResolveScopeProvider.EP_NAME, new GroovyResolveScopeProvider());\n\n\n      Class<Condition<VirtualFile>> conditionClass = (Class)Condition.class;\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), WolfTheProblemSolver.FILTER_EP_NAME, conditionClass);\n      appEnvironment.addExtension(WolfTheProblemSolver.FILTER_EP_NAME, new GroovyProblemFileHighlightFilter());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ClassTypePointerFactory.EP_NAME, ClassTypePointerFactory.class);\n      appEnvironment.addExtension(ClassTypePointerFactory.EP_NAME, new GrClassReferenceTypePointerFactory());\n\n      appEnvironment.registerApplicationService(GroovyQuickFixFactory.class, new EmptyGroovyQuickFixFactory());\n      appEnvironment.registerApplicationComponent(DslActivationStatus.class, new DslActivationStatus());\n\n      CoreApplicationEnvironment.registerExtensionPoint(Extensions.getRootArea(), ReadWriteAccessDetector.EP_NAME, ReadWriteAccessDetector.class);\n      appEnvironment.addExtension(ReadWriteAccessDetector.EP_NAME, new GroovyReadWriteAccessDetector());\n      if (GroovyElementTypes.ADDITIVE_EXPRESSION == null) throw new IllegalStateException(); // initialize tokens\n    }","commit_id":"d635f323dd7b5881ec2c6fa0a0e51b90825c637f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String authRequest(String userSuppliedString,\n\t\t\tHttpServletRequest httpReq, HttpServletResponse httpResp)\n\t\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\thttpReq.getContextPath();\n\n\t\t\tString returnAfterAuthentication = httpReq.getParameter(\"return_to\");\n\n\t\t\t// configure the return_to URL where your application will receive\n\t\t\t// the authentication responses from the OpenID provider\n\t\t\tString returnToUrl = httpReq.getRequestURL().toString() + \"?is_return=true&exist_return=\"+returnAfterAuthentication;\n\n\t\t\t// perform discovery on the user-supplied identifier\n\t\t\tList<?> discoveries = manager.discover(userSuppliedString);\n\n\t\t\t// attempt to associate with the OpenID provider\n\t\t\t// and retrieve one service endpoint for authentication\n\t\t\tDiscoveryInformation discovered = manager.associate(discoveries);\n\n\t\t\t// store the discovery information in the user's session\n\t\t\thttpReq.getSession().setAttribute(\"openid-disc\", discovered);\n\n\t\t\t// obtain a AuthRequest message to be sent to the OpenID provider\n\t\t\tAuthRequest authReq = manager.authenticate(discovered, returnToUrl);\n\t\t\t\n\t\t\tFetchRequest fetch = FetchRequest.createFetchRequest();\n\n\t\t\tfetch.addAttribute(\"firstname\", \"http://axschema.org/namePerson/first\", true);\n\t\t\tfetch.addAttribute(\"lastname\", \"http://axschema.org/namePerson/last\", true);\n\t\t\tfetch.addAttribute(\"email\", \"http://axschema.org/contact/email\", true);\n\t\t\tfetch.addAttribute(\"country\", \"http://axschema.org/contact/country/home\", true);\n\t\t\tfetch.addAttribute(\"language\", \"http://axschema.org/pref/language\", true);\n\n\t\t\t// wants up to three email addresses\n\t\t\tfetch.setCount(\"email\", 3);\n\n\t\t\tauthReq.addExtension(fetch);\n\t\t\t\n\t\t\tif (!discovered.isVersion2()) {\n\t\t\t\t// Option 1: GET HTTP-redirect to the OpenID Provider endpoint\n\t\t\t\t// The only method supported in OpenID 1.x\n\t\t\t\t// redirect-URL usually limited ~2048 bytes\n\t\t\t\thttpResp.sendRedirect(authReq.getDestinationUrl(true));\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\t\t\t\t// Option 2: HTML FORM Redirection (Allows payloads >2048 bytes)\n\n\t\t\t\tObject OPEndpoint = authReq.getDestinationUrl(false);\n\t\t\t\t\n\t\t\t\tServletOutputStream out = httpResp.getOutputStream();\n\t\t        \n\t\t\t\thttpResp.setContentType(\"text/html; charset=UTF-8\");\n\t\t\t\thttpResp.addHeader( \"pragma\", \"no-cache\" );\n\t\t\t\thttpResp.addHeader( \"Cache-Control\", \"no-cache\" );\n\n\t\t        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\");\n\t\t\t\tout.println(\"<head>\");\n\t\t\t\tout.println(\"    <title>OpenID HTML FORM Redirection<\/title>\");\n\t\t\t\tout.println(\"<\/head>\");\n\t\t\t\tout.println(\"<body onload=\\\"document.forms['openid-form-redirection'].submit();\\\">\");\n\t\t\t\tout.println(\"    <form name=\\\"openid-form-redirection\\\" action=\\\"\"+OPEndpoint+\"\\\" method=\\\"post\\\" accept-charset=\\\"utf-8\\\">\");\n\n\t\t\t\tMap<String, String> parameterMap = authReq.getParameterMap();\n\t\t\t\tfor (String key : parameterMap.keySet()) {\n\t\t\t\t\tout.println(\"\t<input type=\\\"hidden\\\" name=\\\"\"+key+\"\\\" value=\\\"\"+parameterMap.get(key)+\"\\\"/>\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tout.println(\"        <button type=\\\"submit\\\">Continue...<\/button>\");\n\t\t\t\tout.println(\"    <\/form>\");\n\t\t\t\tout.println(\"<\/body>\");\n\t\t\t\tout.println(\"<\/html>\");\n\t\t\t\t\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t} catch (OpenIDException e) {\n\t\t\t// present error to the user\n\t\t\tLOG.debug(\"OpenIDException\",e);\n\n\t\t\tServletOutputStream out = httpResp.getOutputStream();\n\t        httpResp.setContentType(\"text/html; charset=\\\"UTF-8\\\"\");\n\t        httpResp.addHeader( \"pragma\", \"no-cache\" );\n\t        httpResp.addHeader( \"Cache-Control\", \"no-cache\" );\n\n\t        httpResp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\n\t        out.print(\"<html><head>\");\n\t        out.print(\"<title>OpenIDServlet Error<\/title>\");\n\t        out.print(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"error.css\\\"><\/link><\/head>\");\n\t        out.print(\"<body><div id=\\\"container\\\"><h1>Error found<\/h1>\");\n            \n\t        out.print(\"<h2>Message:\");\n            out.print(e.getMessage());\n            out.print(\"<\/h2>\");\n\t        \n\t        Throwable t = e.getCause();\n\t        if(t!=null){\n\t            // t can be null\n\t            out.print(HTTPUtils.printStackTraceHTML(t));\n\t        }\n\t        \n\t        out.print(\"<\/div><\/body><\/html>\");\n\t\t}\n\n\t\treturn null;\n\t}","id":42276,"modified_method":"public String authRequest(String userSuppliedString,\n\t\t\tHttpServletRequest httpReq, HttpServletResponse httpResp)\n\t\t\tthrows IOException, ServletException {\n\n\t\ttry {\n\t\t\tString returnAfterAuthentication = httpReq.getParameter(\"return_to\");\n\n\t\t\t// configure the return_to URL where your application will receive\n\t\t\t// the authentication responses from the OpenID provider\n\t\t\tString returnToUrl = httpReq.getRequestURL().toString() + \"?is_return=true&exist_return=\"+returnAfterAuthentication;\n\n\t\t\t// perform discovery on the user-supplied identifier\n\t\t\tList<?> discoveries = manager.discover(userSuppliedString);\n\n\t\t\t// attempt to associate with the OpenID provider\n\t\t\t// and retrieve one service endpoint for authentication\n\t\t\tDiscoveryInformation discovered = manager.associate(discoveries);\n\n\t\t\t// store the discovery information in the user's session\n\t\t\thttpReq.getSession().setAttribute(\"openid-disc\", discovered);\n\n\t\t\t// obtain a AuthRequest message to be sent to the OpenID provider\n\t\t\tAuthRequest authReq = manager.authenticate(discovered, returnToUrl);\n\t\t\t\n\t\t\tif (authReq.getOPEndpoint().indexOf(\"myopenid.com\")>0) {\n\t\t\t\tSRegRequest sregReq = SRegRequest.createFetchRequest();\n\n\t\t\t\tsregReq.addAttribute(UserAttributes._FULLNAME.toLowerCase(), true);\n\t\t\t\tsregReq.addAttribute(UserAttributes._EMAIL.toLowerCase(), true);\n\t\t\t\tsregReq.addAttribute(UserAttributes._COUNTRY.toLowerCase(), true);\n\t\t\t\tsregReq.addAttribute(UserAttributes._LANGUAGE.toLowerCase(), true);\n\n\t\t\t\tauthReq.addExtension(sregReq);\n\t\t\t} else {\n\n\t\t\t\tFetchRequest fetch = FetchRequest.createFetchRequest();\n\n\t\t\t\tfetch.addAttribute(UserAttributes._FIRTSNAME, UserAttributes.FIRTSNAME, true);\n\t\t\t\tfetch.addAttribute(UserAttributes._LASTNAME, UserAttributes.LASTNAME, true);\n\t\t\t\tfetch.addAttribute(UserAttributes._EMAIL, UserAttributes.EMAIL, true);\n\t\t\t\tfetch.addAttribute(UserAttributes._COUNTRY, UserAttributes.COUNTRY, true);\n\t\t\t\tfetch.addAttribute(UserAttributes._LANGUAGE, UserAttributes.LANGUAGE, true);\n\n\t\t\t\t// wants up to three email addresses\n\t\t\t\tfetch.setCount(UserAttributes._EMAIL, 3);\n\n\t\t\t\tauthReq.addExtension(fetch);\n\t\t\t}\n\t\t\t\n\t\t\tif (!discovered.isVersion2()) {\n\t\t\t\t// Option 1: GET HTTP-redirect to the OpenID Provider endpoint\n\t\t\t\t// The only method supported in OpenID 1.x\n\t\t\t\t// redirect-URL usually limited ~2048 bytes\n\t\t\t\thttpResp.sendRedirect(authReq.getDestinationUrl(true));\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\t\t\t\t// Option 2: HTML FORM Redirection (Allows payloads >2048 bytes)\n\n\t\t\t\tObject OPEndpoint = authReq.getDestinationUrl(false);\n\t\t\t\t\n\t\t\t\tServletOutputStream out = httpResp.getOutputStream();\n\t\t        \n\t\t\t\thttpResp.setContentType(\"text/html; charset=UTF-8\");\n\t\t\t\thttpResp.addHeader( \"pragma\", \"no-cache\" );\n\t\t\t\thttpResp.addHeader( \"Cache-Control\", \"no-cache\" );\n\n\t\t        out.println(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\");\n\t\t\t\tout.println(\"<head>\");\n\t\t\t\tout.println(\"    <title>OpenID HTML FORM Redirection<\/title>\");\n\t\t\t\tout.println(\"<\/head>\");\n\t\t\t\tout.println(\"<body onload=\\\"document.forms['openid-form-redirection'].submit();\\\">\");\n\t\t\t\tout.println(\"    <form name=\\\"openid-form-redirection\\\" action=\\\"\"+OPEndpoint+\"\\\" method=\\\"post\\\" accept-charset=\\\"utf-8\\\">\");\n\n\t\t\t\tMap<String, String> parameterMap = authReq.getParameterMap();\n\t\t\t\tfor (String key : parameterMap.keySet()) {\n\t\t\t\t\tout.println(\"\t<input type=\\\"hidden\\\" name=\\\"\"+key+\"\\\" value=\\\"\"+parameterMap.get(key)+\"\\\"/>\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tout.println(\"        <button type=\\\"submit\\\">Continue...<\/button>\");\n\t\t\t\tout.println(\"    <\/form>\");\n\t\t\t\tout.println(\"<\/body>\");\n\t\t\t\tout.println(\"<\/html>\");\n\t\t\t\t\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t} catch (OpenIDException e) {\n\t\t\t// present error to the user\n\t\t\tLOG.debug(\"OpenIDException\",e);\n\n\t\t\tServletOutputStream out = httpResp.getOutputStream();\n\t        httpResp.setContentType(\"text/html; charset=\\\"UTF-8\\\"\");\n\t        httpResp.addHeader( \"pragma\", \"no-cache\" );\n\t        httpResp.addHeader( \"Cache-Control\", \"no-cache\" );\n\n\t        httpResp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\n\t        out.print(\"<html><head>\");\n\t        out.print(\"<title>OpenIDServlet Error<\/title>\");\n\t        out.print(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"error.css\\\"><\/link><\/head>\");\n\t        out.print(\"<body><div id=\\\"container\\\"><h1>Error found<\/h1>\");\n            \n\t        out.print(\"<h2>Message:\");\n            out.print(e.getMessage());\n            out.print(\"<\/h2>\");\n\t        \n\t        Throwable t = e.getCause();\n\t        if(t!=null){\n\t            // t can be null\n\t            out.print(HTTPUtils.printStackTraceHTML(t));\n\t        }\n\t        \n\t        out.print(\"<\/div><\/body><\/html>\");\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"2985a07a1cbcb42808435c2640a5629ca339099a","url":"https://github.com/eXist-db/exist"},{"original_method":"private void processReturn(HttpServletRequest req, HttpServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\tUser principal = this.verifyResponse(req);\n\t\t\n        String returnURL = req.getParameter(\"exist_return\");\n\n        if (principal == null) {\n//\t\t\tthis.getServletContext().getRequestDispatcher(\"/openid/login.xql\").forward(req, resp);\n\t\t\tresp.sendRedirect(returnURL);\n\t\t} else {\n\t        HttpSession session = req.getSession(true);\n\n//\t\t\t((XQueryURLRewrite.RequestWrapper)req).setUserPrincipal(principal);\n\n\t\t\tSubject subject = new Subject();\n\t\t\t\n\t\t\t//TODO: hardcoded to jetty - rewrite\n\t\t\t//*******************************************************\n\t\t\tDefaultIdentityService _identityService = new DefaultIdentityService();\n\t\t\tUserIdentity user = _identityService.newUserIdentity(subject, principal, new String[0]);\n            \n\t\t\tFormAuthenticator authenticator = new FormAuthenticator(\"\",\"\",false);\n\t\t\t\n\t\t\tAuthentication cached=new SessionAuthentication(session,authenticator,user);\n            session.setAttribute(SessionAuthentication.__J_AUTHENTICATED, cached);\n\t\t\t//*******************************************************\n            \n\t\t\tresp.sendRedirect(returnURL);\n\t\t}\n\t}","id":42277,"modified_method":"private void processReturn(HttpServletRequest req, HttpServletResponse resp)\n\t\t\tthrows ServletException, IOException {\n\t\tUser principal = this.verifyResponse(req);\n\t\t\n\t\tSystem.out.println(principal);\n        \n\t\tString returnURL = req.getParameter(\"exist_return\");\n\n        if (principal == null) {\n//\t\t\tthis.getServletContext().getRequestDispatcher(\"/openid/login.xql\").forward(req, resp);\n\t\t\tresp.sendRedirect(returnURL);\n\t\t} else {\n\t        HttpSession session = req.getSession(true);\n\n//\t\t\t((XQueryURLRewrite.RequestWrapper)req).setUserPrincipal(principal);\n\n\t\t\tSubject subject = new Subject();\n\t\t\t\n\t\t\t//TODO: hardcoded to jetty - rewrite\n\t\t\t//*******************************************************\n\t\t\tDefaultIdentityService _identityService = new DefaultIdentityService();\n\t\t\tUserIdentity user = _identityService.newUserIdentity(subject, principal, new String[0]);\n            \n\t\t\tFormAuthenticator authenticator = new FormAuthenticator(\"\",\"\",false);\n\t\t\t\n\t\t\tAuthentication cached=new SessionAuthentication(session,authenticator,user);\n            session.setAttribute(SessionAuthentication.__J_AUTHENTICATED, cached);\n\t\t\t//*******************************************************\n            \n\t\t\tresp.sendRedirect(returnURL);\n\t\t}\n\t}","commit_id":"2985a07a1cbcb42808435c2640a5629ca339099a","url":"https://github.com/eXist-db/exist"},{"original_method":"public User verifyResponse(HttpServletRequest httpReq)\n\t\t\tthrows ServletException {\n\n\t\ttry {\n\t\t\t// extract the parameters from the authentication response\n\t\t\t// (which comes in as a HTTP request from the OpenID provider)\n\t\t\tParameterList response = new ParameterList(httpReq\n\t\t\t\t\t.getParameterMap());\n\n\t\t\t// retrieve the previously stored discovery information\n\t\t\tDiscoveryInformation discovered = (DiscoveryInformation) httpReq\n\t\t\t\t\t.getSession().getAttribute(\"openid-disc\");\n\n\t\t\t// extract the receiving URL from the HTTP request\n\t\t\tStringBuffer receivingURL = httpReq.getRequestURL();\n\t\t\tString queryString = httpReq.getQueryString();\n\t\t\tif (queryString != null && queryString.length() > 0)\n\t\t\t\treceivingURL.append(\"?\").append(httpReq.getQueryString());\n\n\t\t\t// verify the response; ConsumerManager needs to be the same\n\t\t\t// (static) instance used to place the authentication request\n\t\t\tVerificationResult verification = manager.verify(receivingURL\n\t\t\t\t\t.toString(), response, discovered);\n\n\t\t\t// examine the verification result and extract the verified\n\t\t\t// identifier\n\t\t\tIdentifier verified = verification.getVerifiedId();\n\t\t\tif (verified != null) {\n\t\t\t\t// success\n\t\t\t\tUser principal = new UserImpl(verified);\n\t\t\t\t\n\t\t\t\tAuthSuccess authSuccess = (AuthSuccess) verification.getAuthResponse();\n\t\t\t\tauthSuccess.getExtensions();\n\n\t\t\t\tif (authSuccess.hasExtension(SRegMessage.OPENID_NS_SREG)) {\n\t\t\t\t\tMessageExtension ext = authSuccess.getExtension(SRegMessage.OPENID_NS_SREG);\n\t\t\t\t\tif (ext instanceof SRegResponse) {\n\t\t\t\t\t\tSRegResponse sregResp = (SRegResponse) ext;\n\t\t\t\t\t\tfor (Iterator iter = sregResp.getAttributeNames().iterator(); iter.hasNext();) {\n\t\t\t\t\t\t\tString name = (String) iter.next();\n\t\t\t\t\t\t\tString value = sregResp.getParameterValue(name);\n\t\t\t\t\t\t\thttpReq.setAttribute(name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (authSuccess.hasExtension(AxMessage.OPENID_NS_AX)) {\n\t\t\t\t\tFetchResponse fetchResp = (FetchResponse) authSuccess.getExtension(AxMessage.OPENID_NS_AX);\n\n\t\t\t\t\tList aliases = fetchResp.getAttributeAliases();\n\t\t\t\t\tfor (Iterator iter = aliases.iterator(); iter.hasNext();) {\n\t\t\t\t\t\tString alias = (String) iter.next();\n\t\t\t\t\t\tList values = fetchResp.getAttributeValues(alias);\n\t\t\t\t\t\tif (values.size() > 0) {\n\t\t\t\t\t\t\tLOG.debug(alias + \" : \" + values.get(0));\n\t\t\t\t\t\t\tprincipal.setAttribute(alias, values.get(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn principal; \n\t\t\t}\n\t\t} catch (OpenIDException e) {\n\t\t\t// present error to the user\n\t\t}\n\n\t\treturn null;\n\t}","id":42278,"modified_method":"public User verifyResponse(HttpServletRequest httpReq)\n\t\t\tthrows ServletException {\n\n\t\ttry {\n\t\t\t// extract the parameters from the authentication response\n\t\t\t// (which comes in as a HTTP request from the OpenID provider)\n\t\t\tParameterList response = new ParameterList(httpReq\n\t\t\t\t\t.getParameterMap());\n\n\t\t\t// retrieve the previously stored discovery information\n\t\t\tDiscoveryInformation discovered = (DiscoveryInformation) httpReq\n\t\t\t\t\t.getSession().getAttribute(\"openid-disc\");\n\n\t\t\t// extract the receiving URL from the HTTP request\n\t\t\tStringBuffer receivingURL = httpReq.getRequestURL();\n\t\t\tString queryString = httpReq.getQueryString();\n\t\t\tif (queryString != null && queryString.length() > 0)\n\t\t\t\treceivingURL.append(\"?\").append(httpReq.getQueryString());\n\n\t\t\t// verify the response; ConsumerManager needs to be the same\n\t\t\t// (static) instance used to place the authentication request\n\t\t\tVerificationResult verification = manager.verify(receivingURL.toString(), response, discovered);\n\n\t\t\t// examine the verification result and extract the verified\n\t\t\t// identifier\n\t\t\tIdentifier verified = verification.getVerifiedId();\n\t\t\tif (verified != null) {\n\t\t\t\t// success\n\t\t\t\tUser principal = new UserImpl(verified);\n\t\t\t\t\n\t\t\t\tAuthSuccess authSuccess = (AuthSuccess) verification.getAuthResponse();\n\t\t\t\tauthSuccess.getExtensions();\n\n\t\t\t\tif (authSuccess.hasExtension(SRegMessage.OPENID_NS_SREG)) {\n\t\t\t\t\tMessageExtension ext = authSuccess.getExtension(SRegMessage.OPENID_NS_SREG);\n\t\t\t\t\tif (ext instanceof SRegResponse) {\n\t\t\t\t\t\tSRegResponse sregResp = (SRegResponse) ext;\n\t\t\t\t\t\tfor (Iterator iter = sregResp.getAttributeNames().iterator(); iter.hasNext();) {\n\t\t\t\t\t\t\tString name = (String) iter.next();\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled())\n\t\t\t\t\t\t\t\tLOG.debug(name + \" : \" + sregResp.getParameterValue(name));\n\t\t\t\t\t\t\tprincipal.setAttribute(name, sregResp.getParameterValue(name));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (authSuccess.hasExtension(AxMessage.OPENID_NS_AX)) {\n\t\t\t\t\tFetchResponse fetchResp = (FetchResponse) authSuccess.getExtension(AxMessage.OPENID_NS_AX);\n\n\t\t\t\t\tList aliases = fetchResp.getAttributeAliases();\n\t\t\t\t\tfor (Iterator iter = aliases.iterator(); iter.hasNext();) {\n\t\t\t\t\t\tString alias = (String) iter.next();\n\t\t\t\t\t\tList values = fetchResp.getAttributeValues(alias);\n\t\t\t\t\t\tif (values.size() > 0) {\n\t\t\t\t\t\t\tif (LOG.isDebugEnabled())\n\t\t\t\t\t\t\t\tLOG.debug(alias + \" : \" + values.get(0));\n\t\t\t\t\t\t\tprincipal.setAttribute(alias, values.get(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn principal; \n\t\t\t}\n\t\t} catch (OpenIDException e) {\n\t\t\t// present error to the user\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"2985a07a1cbcb42808435c2640a5629ca339099a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tpublic void setAttribute(String name, Object value) {\n\t\tattributes.put(name, value);\n\t}","id":42279,"modified_method":"@Override\n\tpublic void setAttribute(String name, Object value) {\n\t\tString id = UserAttributes.alias.get(name);\n\t\tif (id == null)\n\t\t\tattributes.put(name, value);\n\t\telse\n\t\t\tattributes.put(id, value);\n\t}","commit_id":"2985a07a1cbcb42808435c2640a5629ca339099a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tpublic Object getAttribute(String name) {\n\t\tif (name.equalsIgnoreCase(\"id\")) {\n\t\t\treturn _identifier.getIdentifier();\n\t\t}\n\t\treturn attributes.get(name);\n\t}","id":42280,"modified_method":"@Override\n\tpublic Object getAttribute(String name) {\n\t\tString id = UserAttributes.alias.get(name);\n\t\tif (id != null)\n\t\t\treturn attributes.get(id);\n\n\t\tif (name.equalsIgnoreCase(\"id\"))\n\t\t\treturn _identifier.getIdentifier();\n\t\t\n\t\treturn attributes.get(name);\n\t}","commit_id":"2985a07a1cbcb42808435c2640a5629ca339099a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tpublic String getName() {\n\t\tString name = \"\";\n\t\tif (attributes.containsKey(\"firstname\")) \n\t\t\tname += attributes.get(\"firstname\"); \n\t\tif (attributes.containsKey(\"lastname\"))\n\t\t\tif (name != \"\") name += \" \";\n\t\t\tname += attributes.get(\"lastname\");\n\t\t\n\t\tif (name == \"\") \n\t\t\treturn _identifier.getIdentifier();\n\t\t\n\t\treturn name;\n\t}","id":42281,"modified_method":"@Override\n\tpublic String getName() {\n\t\tString name = \"\";\n\t\tif (attributes.containsKey(UserAttributes.FIRTSNAME)) \n\t\t\tname += attributes.get(UserAttributes.FIRTSNAME); \n\t\t\n\t\tif (attributes.containsKey(UserAttributes.LASTNAME)) {\n\t\t\tif (name != \"\") name += \" \";\n\t\t\tname += attributes.get(UserAttributes.LASTNAME);\n\t\t}\n\t\t\n\t\tif (name.equals(\"\")) \n\t\t\tname += attributes.get(UserAttributes.FULLNAME);\n\t\t\n\t\tif (name.equals(\"\")) \n\t\t\treturn _identifier.getIdentifier();\n\n\t\treturn name;\n\t}","commit_id":"2985a07a1cbcb42808435c2640a5629ca339099a","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tprotected void addDependencies() {\n\t\tsuper.addDependencies();\n\n\t\tif (!isLegacy()) {\n\t\t\taddDependency(\n\t\t\t\t\"com.liferay\", \"com.liferay.sass.compiler\", \"1.0.0-SNAPSHOT\");\n\t\t}\n\n\t\taddDependency(\"com.liferay\", \"com.liferay.rtl.css\", \"1.0.0-SNAPSHOT\");\n\t\taddDependency(\"com.liferay\", \"com.liferay.ruby.gems\", \"1.0.0-SNAPSHOT\");\n\t\taddDependency(\"javax.portlet\", \"portlet-api\", \"2.0\");\n\t\taddDependency(\"org.apache.ant\", \"ant\", \"1.8.2\");\n\t\taddDependency(\"org.jruby\", \"jruby-complete\", \"1.6.5\");\n\t\taddDependency(\"org.springframework\", \"spring-web\", \"3.2.10.RELEASE\");\n\t\taddDependency(\"struts\", \"struts\", \"1.2.9\");\n\t}","id":42282,"modified_method":"@Override\n\tprotected void addDependencies() {\n\t\tsuper.addDependencies();\n\n\t\tif (!isLegacy()) {\n\t\t\taddDependency(\n\t\t\t\t\"com.liferay\", \"com.liferay.sass.compiler\", \"1.0.0-SNAPSHOT\");\n\t\t}\n\n\t\taddDependency(\"com.liferay\", \"com.liferay.rtl.css\", \"1.0.0-SNAPSHOT\");\n\t\taddDependency(\"com.liferay\", \"com.liferay.ruby.gems\", \"1.0.0-SNAPSHOT\");\n\t\taddDependency(\"com.liferay.portal\", \"util-slf4j\", \"default\");\n\t\taddDependency(\"javax.portlet\", \"portlet-api\", \"2.0\");\n\t\taddDependency(\"org.apache.ant\", \"ant\", \"1.8.2\");\n\t\taddDependency(\"org.jruby\", \"jruby-complete\", \"1.6.5\");\n\t\taddDependency(\"org.springframework\", \"spring-web\", \"3.2.10.RELEASE\");\n\t\taddDependency(\"struts\", \"struts\", \"1.2.9\");\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void copySassPortalCommon() {\n\t\tfinal File portalWebDir = getPortalWebDir();\n\n\t\tFile portalWebHtmlDir = new File(portalWebDir, \"html\");\n\n\t\tif (portalWebHtmlDir.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClosure<Void> closure = new Closure<Void>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\tFileTree fileTree = project.zipTree(\n\t\t\t\t\t_portalWebConfiguration.getSingleFile());\n\n\t\t\t\tCopySpec fileTreeCopySpec = copySpec.from(fileTree);\n\n\t\t\t\tfileTreeCopySpec.include(\"html/css/**/*\", \"html/themes/**/*\");\n\n\t\t\t\tcopySpec.into(portalWebDir);\n\t\t\t}\n\n\t\t};\n\n\t\tproject.copy(closure);\n\t}","id":42283,"modified_method":"protected void copyPortalCommon() {\n\t\tfinal File portalWebDir = getPortalWebDir();\n\n\t\tFile portalWebHtmlDir = new File(portalWebDir, \"html\");\n\n\t\tif (portalWebHtmlDir.exists()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClosure<Void> closure = new Closure<Void>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\tFileTree fileTree = project.zipTree(\n\t\t\t\t\t_portalWebConfiguration.getSingleFile());\n\n\t\t\t\tCopySpec fileTreeCopySpec = copySpec.from(fileTree);\n\n\t\t\t\tfileTreeCopySpec.include(\"html/css/**/*\", \"html/themes/**/*\");\n\n\t\t\t\tcopySpec.into(portalWebDir);\n\t\t\t}\n\n\t\t};\n\n\t\tproject.copy(closure);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<String> getArgs() {\n\t\tList<String> args = new ArrayList<>(3);\n\n\t\targs.add(\"sass.dir=/\");\n\n\t\tFile sassDocrootDir = getSassDocrootDir();\n\n\t\targs.add(\"sass.docroot.dir=\" + sassDocrootDir.toString());\n\n\t\tFile sassPortalCommonDir = new File(\n\t\t\tgetPortalWebDir(), \"html/css/common\");\n\n\t\targs.add(\"sass.portal.common.dir=\" + sassPortalCommonDir.toString());\n\n\t\treturn args;\n\t}","id":42284,"modified_method":"@Override\n\tpublic List<String> getArgs() {\n\t\tList<String> args = new ArrayList<>(3);\n\n\t\tfor (int i = 0; i < _cssDirNames.size(); i++) {\n\t\t\tString cssDirName = _cssDirNames.get(i);\n\n\t\t\targs.add(\"sass.dir.\" + i + \"=/\" + cssDirName);\n\t\t}\n\n\t\targs.add(\"sass.docroot.dir=\" + project.getProjectDir());\n\n\t\tFile cssPortalCommonDir = new File(\n\t\t\tgetPortalWebDir(), \"html/css/common\");\n\n\t\targs.add(\"sass.portal.common.dir=\" + cssPortalCommonDir.toString());\n\n\t\treturn args;\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void exec() {\n\t\tcopySassPortalCommon();\n\n\t\tsuper.exec();\n\t}","id":42285,"modified_method":"@Override\n\tpublic void exec() {\n\t\tcopyPortalCommon();\n\n\t\tsuper.exec();\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@OutputDirectories\n\tpublic Iterable<File> getSassCacheDirs() {\n\t\tSet<File> sassCacheDirs = new HashSet<>();\n\n\t\tIterable<File> sassFiles = getSassFiles();\n\n\t\tfor (File sassFile : sassFiles) {\n\t\t\tFile sassCacheDir = project.file(sassFile + \"/../.sass-cache\");\n\n\t\t\tsassCacheDirs.add(sassCacheDir);\n\t\t}\n\n\t\treturn sassCacheDirs;\n\t}","id":42286,"modified_method":"@OutputDirectories\n\tpublic Iterable<File> getCssCacheDirs() {\n\t\tSet<File> cssCacheDirs = new HashSet<>();\n\n\t\tIterable<File> cssFiles = getCssFiles();\n\n\t\tfor (File cssFile : cssFiles) {\n\t\t\tFile cssCacheDir = project.file(cssFile + \"/../.sass-cache\");\n\n\t\t\tcssCacheDirs.add(cssCacheDir);\n\t\t}\n\n\t\treturn cssCacheDirs;\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@InputFiles\n\t@SkipWhenEmpty\n\tpublic Iterable<File> getSassFiles() {\n\t\tMap<String, Object> args = new HashMap<>();\n\n\t\targs.put(\"dir\", getSassDocrootDir());\n\t\targs.put(\"exclude\", \"**/.sass-cache/**\");\n\t\targs.put(\"include\", \"**/*.css\");\n\n\t\treturn project.fileTree(args);\n\t}","id":42287,"modified_method":"@InputFiles\n\t@SkipWhenEmpty\n\tpublic Iterable<File> getCssFiles() {\n\t\tif (_cssDirNames.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tMap<String, Object> args = new HashMap<>();\n\n\t\targs.put(\"dir\", project.getProjectDir());\n\t\targs.put(\"exclude\", \"**/.sass-cache/**\");\n\n\t\tfor (String cssDirName : _cssDirNames) {\n\t\t\targs.put(\"include\", cssDirName + \"/**/*.css\");\n\t\t}\n\n\t\treturn project.fileTree(args);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public BuildCssTask() {\n\t\t_portalWebConfiguration = GradleUtil.addConfiguration(\n\t\t\tproject, _PORTAL_WEB_CONFIGURATION_NAME);\n\n\t\t_portalWebConfiguration.setDescription(\n\t\t\t\"The portal-web configuration used for compiling CSS files.\");\n\t\t_portalWebConfiguration.setVisible(false);\n\n\t\tGradleUtil.executeIfEmpty(\n\t\t\t_portalWebConfiguration,\n\t\t\tnew Action<Configuration>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Configuration configuration) {\n\t\t\t\t\taddPortalWebDependencies();\n\t\t\t\t}\n\n\t\t\t});\n\n\t\tif (liferayExtension.isOsgiPlugin()) {\n\t\t\t_sassDocrootDir = project.file(\"src/META-INF/resources\");\n\t\t}\n\t\telse {\n\t\t\t_sassDocrootDir = project.file(\"docroot\");\n\t\t}\n\t}","id":42288,"modified_method":"public BuildCssTask() {\n\t\t_portalWebConfiguration = GradleUtil.addConfiguration(\n\t\t\tproject, _PORTAL_WEB_CONFIGURATION_NAME);\n\n\t\t_portalWebConfiguration.setDescription(\n\t\t\t\"The portal-web configuration used for compiling CSS files.\");\n\t\t_portalWebConfiguration.setVisible(false);\n\n\t\tGradleUtil.executeIfEmpty(\n\t\t\t_portalWebConfiguration,\n\t\t\tnew Action<Configuration>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Configuration configuration) {\n\t\t\t\t\taddPortalWebDependencies();\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static FileTree getFilteredFileTree(\n\t\tFileTree fileTree, final String[] includes, final String[] excludes) {\n\n\t\tClosure<Void> closure = new Closure<Void>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic void doCall(PatternFilterable patternFilterable) {\n\t\t\t\tif (Validator.isNotNull(excludes)) {\n\t\t\t\t\tpatternFilterable.setExcludes(Arrays.asList(excludes));\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNotNull(includes)) {\n\t\t\t\t\tpatternFilterable.setIncludes(Arrays.asList(includes));\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\treturn fileTree.matching(closure);\n\t}","id":42289,"modified_method":"public static FileTree getFilteredFileTree(\n\t\tFileTree fileTree, final String[] includes, final String[] excludes) {\n\n\t\tClosure<Void> closure = new Closure<Void>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic void doCall(PatternFilterable patternFilterable) {\n\t\t\t\tif (ArrayUtil.isNotEmpty(excludes)) {\n\t\t\t\t\tpatternFilterable.setExcludes(Arrays.asList(excludes));\n\t\t\t\t}\n\n\t\t\t\tif (ArrayUtil.isNotEmpty(includes)) {\n\t\t\t\t\tpatternFilterable.setIncludes(Arrays.asList(includes));\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\treturn fileTree.matching(closure);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public LiferayExtension(Project project) throws Exception {\n\t\t_bndProperties = FileUtil.readProperties(project, \"bnd.bnd\");\n\t\t_pluginPackageProperties = FileUtil.readProperties(\n\t\t\tproject, \"docroot/WEB-INF/liferay-plugin-package.properties\");\n\n\t\tFile pluginSrcDir = project.file(\"docroot/WEB-INF/src\");\n\n\t\tif (!pluginSrcDir.exists()) {\n\t\t\tpluginSrcDir = project.file(\"src\");\n\t\t}\n\n\t\t_pluginSrcDir = pluginSrcDir;\n\n\t\tString projectName = project.getName();\n\n\t\tint index = projectName.lastIndexOf(\"-\");\n\n\t\t_pluginType = projectName.substring(index + 1);\n\n\t\t_tmpDir = new File(project.getRootDir(), \"tmp\");\n\t}","id":42290,"modified_method":"public LiferayExtension(Project project) throws Exception {\n\t\t_tmpDir = new File(project.getRootDir(), \"tmp\");\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureDependenciesProvidedCompile() {\n\t\taddDependencies(\n\t\t\tWarPlugin.PROVIDED_COMPILE_CONFIGURATION_NAME,\n\t\t\t\"biz.aQute.bnd:biz.aQute.bnd:2.4.1\",\n\t\t\t\"com.liferay.portal:portal-service:default\",\n\t\t\t\"hsqldb:hsqldb:1.8.0.7\", \"javax.activation:activation:1.1\",\n\t\t\t\"javax.ccpp:ccpp:1.0\", \"javax.jms:jms:1.1\", \"javax.mail:mail:1.4\",\n\t\t\t\"javax.portlet:portlet-api:2.0\", \"javax.servlet.jsp:jsp-api:2.1\",\n\t\t\t\"javax.servlet:javax.servlet-api:3.0.1\",\n\t\t\t\"mysql:mysql-connector-java:5.1.23\", \"net.sf:jargs:1.0\",\n\t\t\t\"net.sourceforge.jtds:jtds:1.2.6\",\n\t\t\t\"org.eclipse.persistence:javax.persistence:2.0.0\",\n\t\t\t\"postgresql:postgresql:9.2-1002.jdbc4\");\n\n\t\tString pluginType = _liferayExtension.getPluginType();\n\n\t\tif (!pluginType.equals(\"theme\")) {\n\t\t\taddDependencies(\n\t\t\t\tWarPlugin.PROVIDED_COMPILE_CONFIGURATION_NAME,\n\t\t\t\t\"com.liferay.portal:util-bridges:default\",\n\t\t\t\t\"com.liferay.portal:util-java:default\",\n\t\t\t\t\"com.liferay.portal:util-taglib:default\",\n\t\t\t\t\"commons-logging:commons-logging:1.1.1\", \"log4j:log4j:1.2.16\");\n\t\t}\n\t}","id":42291,"modified_method":"protected void configureDependenciesCompile(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tfor (String dependencyNotation : COMPILE_DEPENDENCY_NOTATIONS) {\n\t\t\tGradleUtil.addDependency(\n\t\t\t\tproject, JavaPlugin.COMPILE_CONFIGURATION_NAME,\n\t\t\t\tdependencyNotation);\n\t\t}\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureTaskCleanDependsOn(Task cleanTask) {\n\t\tfor (Task task : project.getTasks()) {\n\t\t\tString taskName =\n\t\t\t\torg.gradle.api.plugins.BasePlugin.CLEAN_TASK_NAME +\n\t\t\t\t\tStringUtil.capitalize(task.getName());\n\n\t\t\tcleanTask.dependsOn(taskName);\n\t\t}\n\n\t\tConfiguration compileConfiguration = getConfiguration(\n\t\t\tJavaPlugin.COMPILE_CONFIGURATION_NAME);\n\n\t\tSet<Dependency> compileDependencies =\n\t\t\tcompileConfiguration.getAllDependencies();\n\n\t\tfor (Dependency dependency : compileDependencies) {\n\t\t\tif (!(dependency instanceof ProjectDependency)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tProjectDependency projectDependency = (ProjectDependency)dependency;\n\n\t\t\tProject dependencyProject =\n\t\t\t\tprojectDependency.getDependencyProject();\n\n\t\t\tString taskName =\n\t\t\t\tdependencyProject.getPath() + Project.PATH_SEPARATOR +\n\t\t\t\t\torg.gradle.api.plugins.BasePlugin.CLEAN_TASK_NAME;\n\n\t\t\tcleanTask.dependsOn(taskName);\n\t\t}\n\t}","id":42292,"modified_method":"protected void configureTaskCleanDependsOn(Task cleanTask) {\n\t\tProject project = cleanTask.getProject();\n\n\t\tfor (Task task : project.getTasks()) {\n\t\t\tString taskName =\n\t\t\t\tBasePlugin.CLEAN_TASK_NAME +\n\t\t\t\t\tStringUtil.capitalize(task.getName());\n\n\t\t\tcleanTask.dependsOn(taskName);\n\t\t}\n\n\t\tConfiguration compileConfiguration = GradleUtil.getConfiguration(\n\t\t\tproject, JavaPlugin.COMPILE_CONFIGURATION_NAME);\n\n\t\tSet<Dependency> compileDependencies =\n\t\t\tcompileConfiguration.getAllDependencies();\n\n\t\tfor (Dependency dependency : compileDependencies) {\n\t\t\tif (!(dependency instanceof ProjectDependency)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tProjectDependency projectDependency = (ProjectDependency)dependency;\n\n\t\t\tProject dependencyProject =\n\t\t\t\tprojectDependency.getDependencyProject();\n\n\t\t\tString taskName =\n\t\t\t\tdependencyProject.getPath() + Project.PATH_SEPARATOR +\n\t\t\t\t\tBasePlugin.CLEAN_TASK_NAME;\n\n\t\t\tcleanTask.dependsOn(taskName);\n\t\t}\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureSourceSets() {\n\t\tSourceSet sourceSet = getSourceSet(SourceSet.MAIN_SOURCE_SET_NAME);\n\n\t\tSourceDirectorySet javaSourceDirectorySet = sourceSet.getJava();\n\n\t\tSet<File> srcDirs = Collections.singleton(\n\t\t\t_liferayExtension.getPluginSrcDir());\n\n\t\tjavaSourceDirectorySet.setSrcDirs(srcDirs);\n\n\t\tSourceDirectorySet resourcesSourceDirectorySet =\n\t\t\tsourceSet.getResources();\n\n\t\tresourcesSourceDirectorySet.setSrcDirs(srcDirs);\n\t}","id":42293,"modified_method":"protected void configureSourceSets(Project project) {\n\t\tconfigureSourceSetMain(project);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addTaskFormatSource() {\n\t\tTask task = addTask(\"formatSource\", FormatSourceTask.class);\n\n\t\ttask.setDescription(\"Runs Liferay Source Formatter to format files.\");\n\t}","id":42294,"modified_method":"protected void addTaskInitGradle(Project project) {\n\t\tTask task = GradleUtil.addTask(\n\t\t\tproject, _INIT_GRADLE_TASK_NAME, InitGradleTask.class);\n\n\t\ttask.setDescription(\n\t\t\t\"Initializes build.gradle by migrating information from legacy \" +\n\t\t\t\t\"files.\");\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addTaskInitGradle() {\n\t\tTask task = addTask(\"initGradle\", InitGradleTask.class);\n\n\t\ttask.setDescription(\n\t\t\t\"Initializes build.gradle by migrating information from legacy \" +\n\t\t\t\t\"files.\");\n\t}","id":42295,"modified_method":"protected void addTasks(Project project) {\n\t\taddTaskBuildCss(project);\n\t\taddTaskFormatSource(project);\n\t\taddTaskInitGradle(project);\n\t\taddTaskWar(project);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureDependenciesCompile() {\n\t\tFile serviceJarFile = project.file(\n\t\t\t\"docroot/WEB-INF/lib/\" + project.getName() + \"-service.jar\");\n\n\t\tif (serviceJarFile.exists()) {\n\t\t\tDependencyHandler dependencyHandler = project.getDependencies();\n\n\t\t\tdependencyHandler.add(\n\t\t\t\tJavaPlugin.COMPILE_CONFIGURATION_NAME,\n\t\t\t\tproject.files(serviceJarFile));\n\t\t}\n\t}","id":42296,"modified_method":"protected void configureDependencies(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tconfigureDependenciesCompile(project, liferayExtension);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addTaskBuildCss() {\n\t\tTask task = addTask(\"buildCss\", BuildCssTask.class);\n\n\t\ttask.setDescription(\"Compiles CSS files.\");\n\t\ttask.setGroup(org.gradle.api.plugins.BasePlugin.BUILD_GROUP);\n\t}","id":42297,"modified_method":"protected void addTaskFormatSource(Project project) {\n\t\tTask task = GradleUtil.addTask(\n\t\t\tproject, _FORMAT_SOURCE_TASK_NAME, FormatSourceTask.class);\n\n\t\ttask.setDescription(\"Runs Liferay Source Formatter to format files.\");\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureTaskClean() {\n\t\tTask cleanTask = getTask(\n\t\t\torg.gradle.api.plugins.BasePlugin.CLEAN_TASK_NAME);\n\n\t\tconfigureTaskCleanDependsOn(cleanTask);\n\t}","id":42298,"modified_method":"protected void configureTaskClean(Project project) {\n\t\tTask cleanTask = GradleUtil.getTask(\n\t\t\tproject, BasePlugin.CLEAN_TASK_NAME);\n\n\t\tconfigureTaskCleanDependsOn(cleanTask);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addLiferayExtension() {\n\t\tString projectName = project.getName();\n\n\t\tif (projectName.endsWith(\"-theme\")) {\n\t\t\t_liferayExtension = addExtension(\n\t\t\t\tEXTENSION_NAME, LiferayThemeExtension.class);\n\t\t}\n\t\telse {\n\t\t\t_liferayExtension = addExtension(\n\t\t\t\tEXTENSION_NAME, LiferayExtension.class);\n\t\t}\n\t}","id":42299,"modified_method":"protected LiferayExtension addLiferayExtension(Project project) {\n\t\treturn GradleUtil.addExtension(\n\t\t\tproject, LiferayPlugin.PLUGIN_NAME, LiferayExtension.class);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureTaskWarRenameDependencies(War warTask) {\n\t\tClosure<String> closure = new Closure<String>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic String doCall(String name) {\n\t\t\t\tMap<String, String> newDependencyNames =\n\t\t\t\t\t_getNewDependencyNames();\n\n\t\t\t\tString newDependencyName = newDependencyNames.get(name);\n\n\t\t\t\tif (Validator.isNotNull(newDependencyName)) {\n\t\t\t\t\treturn newDependencyName;\n\t\t\t\t}\n\n\t\t\t\treturn name;\n\t\t\t}\n\n\t\t\tprivate Map<String, String> _getNewDependencyNames() {\n\t\t\t\tif (_newDependencyNames != null) {\n\t\t\t\t\treturn _newDependencyNames;\n\t\t\t\t}\n\n\t\t\t\t_newDependencyNames = new HashMap<>();\n\n\t\t\t\tConfiguration compileConfiguration = getConfiguration(\n\t\t\t\t\tJavaPlugin.COMPILE_CONFIGURATION_NAME);\n\n\t\t\t\tResolvedConfiguration resolvedConfiguration =\n\t\t\t\t\tcompileConfiguration.getResolvedConfiguration();\n\n\t\t\t\tfor (ResolvedArtifact resolvedArtifact :\n\t\t\t\t\t\tresolvedConfiguration.getResolvedArtifacts()) {\n\n\t\t\t\t\tResolvedModuleVersion resolvedModuleVersion =\n\t\t\t\t\t\tresolvedArtifact.getModuleVersion();\n\n\t\t\t\t\tModuleVersionIdentifier moduleVersionIdentifier =\n\t\t\t\t\t\tresolvedModuleVersion.getId();\n\n\t\t\t\t\tString oldDependencyName =\n\t\t\t\t\t\tmoduleVersionIdentifier.getName() + \"-\" +\n\t\t\t\t\t\t\tmoduleVersionIdentifier.getVersion() + \".jar\";\n\t\t\t\t\tString newDependencyName =\n\t\t\t\t\t\tmoduleVersionIdentifier.getName() + \".jar\";\n\n\t\t\t\t\t_newDependencyNames.put(\n\t\t\t\t\t\toldDependencyName, newDependencyName);\n\t\t\t\t}\n\n\t\t\t\treturn _newDependencyNames;\n\t\t\t}\n\n\t\t\tprivate Map<String, String> _newDependencyNames;\n\n\t\t};\n\n\t\tCopySpecInternal copySpecInternal = warTask.getRootSpec();\n\n\t\tfor (CopySpecInternal childCopySpecInternal :\n\t\t\t\tcopySpecInternal.getChildren()) {\n\n\t\t\tchildCopySpecInternal.rename(closure);\n\t\t}\n\t}","id":42300,"modified_method":"protected void configureTaskWarRenameDependencies(War warTask) {\n\t\tfinal Project project = warTask.getProject();\n\n\t\tClosure<String> closure = new Closure<String>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic String doCall(String name) {\n\t\t\t\tMap<String, String> newDependencyNames =\n\t\t\t\t\t_getNewDependencyNames();\n\n\t\t\t\tString newDependencyName = newDependencyNames.get(name);\n\n\t\t\t\tif (Validator.isNotNull(newDependencyName)) {\n\t\t\t\t\treturn newDependencyName;\n\t\t\t\t}\n\n\t\t\t\treturn name;\n\t\t\t}\n\n\t\t\tprivate Map<String, String> _getNewDependencyNames() {\n\t\t\t\tif (_newDependencyNames != null) {\n\t\t\t\t\treturn _newDependencyNames;\n\t\t\t\t}\n\n\t\t\t\t_newDependencyNames = new HashMap<>();\n\n\t\t\t\tConfiguration compileConfiguration =\n\t\t\t\t\tGradleUtil.getConfiguration(\n\t\t\t\t\t\tproject, JavaPlugin.COMPILE_CONFIGURATION_NAME);\n\n\t\t\t\tResolvedConfiguration resolvedConfiguration =\n\t\t\t\t\tcompileConfiguration.getResolvedConfiguration();\n\n\t\t\t\tfor (ResolvedArtifact resolvedArtifact :\n\t\t\t\t\t\tresolvedConfiguration.getResolvedArtifacts()) {\n\n\t\t\t\t\tResolvedModuleVersion resolvedModuleVersion =\n\t\t\t\t\t\tresolvedArtifact.getModuleVersion();\n\n\t\t\t\t\tModuleVersionIdentifier moduleVersionIdentifier =\n\t\t\t\t\t\tresolvedModuleVersion.getId();\n\n\t\t\t\t\tString oldDependencyName =\n\t\t\t\t\t\tmoduleVersionIdentifier.getName() + \"-\" +\n\t\t\t\t\t\t\tmoduleVersionIdentifier.getVersion() + \".jar\";\n\t\t\t\t\tString newDependencyName =\n\t\t\t\t\t\tmoduleVersionIdentifier.getName() + \".jar\";\n\n\t\t\t\t\t_newDependencyNames.put(\n\t\t\t\t\t\toldDependencyName, newDependencyName);\n\t\t\t\t}\n\n\t\t\t\treturn _newDependencyNames;\n\t\t\t}\n\n\t\t\tprivate Map<String, String> _newDependencyNames;\n\n\t\t};\n\n\t\tCopySpecInternal copySpecInternal = warTask.getRootSpec();\n\n\t\tfor (CopySpecInternal childCopySpecInternal :\n\t\t\t\tcopySpecInternal.getChildren()) {\n\n\t\t\tchildCopySpecInternal.rename(closure);\n\t\t}\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureSourceSets() {\n\t\tSourceSet sourceSet = getSourceSet(SourceSet.MAIN_SOURCE_SET_NAME);\n\n\t\tSourceDirectorySet javaSourceDirectorySet = sourceSet.getJava();\n\n\t\tSet<File> srcDirs = Collections.singleton(\n\t\t\t_liferayExtension.getPluginSrcDir());\n\n\t\tjavaSourceDirectorySet.setSrcDirs(srcDirs);\n\n\t\tSourceDirectorySet resourcesSourceDirectorySet =\n\t\t\tsourceSet.getResources();\n\n\t\tresourcesSourceDirectorySet.setSrcDirs(srcDirs);\n\t}","id":42301,"modified_method":"@Override\n\tprotected void configureSourceSetMain(Project project) {\n\t\tSourceSet sourceSet = GradleUtil.getSourceSet(\n\t\t\tproject, SourceSet.MAIN_SOURCE_SET_NAME);\n\n\t\tSourceDirectorySet javaSourceDirectorySet = sourceSet.getJava();\n\n\t\tFile srcDir = project.file(\"docroot/WEB-INF/src\");\n\n\t\tSet<File> srcDirs = Collections.singleton(srcDir);\n\n\t\tjavaSourceDirectorySet.setSrcDirs(srcDirs);\n\n\t\tSourceDirectorySet resourcesSourceDirectorySet =\n\t\t\tsourceSet.getResources();\n\n\t\tresourcesSourceDirectorySet.setSrcDirs(srcDirs);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureTaskWarManifest(War warTask) {\n\t\tFile manifestFile = null;\n\n\t\tif (_liferayExtension.isOsgiPlugin()) {\n\t\t\tmanifestFile = project.file(\"src/META-INF/MANIFEST.MF\");\n\t\t}\n\t\telse {\n\t\t\tmanifestFile = project.file(\"docroot/META-INF/MANIFEST.MF\");\n\t\t}\n\n\t\tManifest manifest = warTask.getManifest();\n\n\t\tif (manifestFile.exists()) {\n\t\t\tmanifest.from(manifestFile);\n\t\t}\n\t\telse {\n\t\t\tCopySpecInternal copySpecInternal = warTask.getRootSpec();\n\n\t\t\tfor (CopySpecInternal childCopySpecInternal :\n\t\t\t\t\tcopySpecInternal.getChildren()) {\n\n\t\t\t\tCopySpecResolver copySpecResolver =\n\t\t\t\t\tchildCopySpecInternal.buildRootResolver();\n\n\t\t\t\tRelativePath destRelativePath = copySpecResolver.getDestPath();\n\n\t\t\t\tString destRelativePathString =\n\t\t\t\t\tdestRelativePath.getPathString();\n\n\t\t\t\tif (destRelativePathString.equals(\"META-INF\")) {\n\t\t\t\t\tchildCopySpecInternal.exclude(\"**\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":42302,"modified_method":"protected void configureTaskWarExcludeManifest(War warTask) {\n\t\tCopySpecInternal copySpecInternal = warTask.getRootSpec();\n\n\t\tfor (CopySpecInternal childCopySpecInternal :\n\t\t\t\tcopySpecInternal.getChildren()) {\n\n\t\t\tCopySpecResolver copySpecResolver =\n\t\t\t\tchildCopySpecInternal.buildRootResolver();\n\n\t\t\tRelativePath destRelativePath = copySpecResolver.getDestPath();\n\n\t\t\tString destRelativePathString = destRelativePath.getPathString();\n\n\t\t\tif (destRelativePathString.equals(\"META-INF\")) {\n\t\t\t\tchildCopySpecInternal.exclude(\"**\");\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureConfigurations() {\n\t\tAction<Configuration> action = new Action<Configuration>() {\n\n\t\t\t@Override\n\t\t\tpublic void execute(Configuration configuration) {\n\t\t\t\tResolutionStrategy resolutionStrategy =\n\t\t\t\t\tconfiguration.getResolutionStrategy();\n\n\t\t\t\tresolutionStrategy.eachDependency(\n\t\t\t\t\tnew Action<DependencyResolveDetails>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void execute(\n\t\t\t\t\t\t\tDependencyResolveDetails dependencyResolveDetails) {\n\t\t\t\t\t\t\t\tModuleVersionSelector moduleVersionSelector =\n\t\t\t\t\t\t\t\t\tdependencyResolveDetails.getRequested();\n\n\t\t\t\t\t\t\t\tString group = moduleVersionSelector.getGroup();\n\t\t\t\t\t\t\t\tString version =\n\t\t\t\t\t\t\t\t\tmoduleVersionSelector.getVersion();\n\n\t\t\t\t\t\t\t\tif (group.equals(\"com.liferay.portal\") &&\n\t\t\t\t\t\t\t\t\tversion.equals(\"default\")) {\n\n\t\t\t\t\t\t\t\t\tdependencyResolveDetails.useVersion(\n\t\t\t\t\t\t\t\t\t\t_liferayExtension.getPortalVersion());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t};\n\n\t\tConfigurationContainer configurationContainer =\n\t\t\tproject.getConfigurations();\n\n\t\tconfigurationContainer.all(action);\n\t}","id":42303,"modified_method":"protected void configureDependenciesProvidedCompile(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tfor (String dependencyNotation : COMPILE_DEPENDENCY_NOTATIONS) {\n\t\t\tif ((liferayExtension instanceof LiferayThemeExtension) &&\n\t\t\t\tArrayUtil.contains(\n\t\t\t\t\t_THEME_COMPILE_DEPENDENCY_NOTATIONS, dependencyNotation)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGradleUtil.addDependency(\n\t\t\t\tproject, WarPlugin.PROVIDED_COMPILE_CONFIGURATION_NAME,\n\t\t\t\tdependencyNotation);\n\t\t}\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureWebAppDirName() {\n\t\tWarPluginConvention warPluginConvention = getPluginConvention(\n\t\t\tWarPluginConvention.class);\n\n\t\twarPluginConvention.setWebAppDirName(\"docroot\");\n\t}","id":42304,"modified_method":"protected void configureWebAppDirName(Project project) {\n\t\tWarPluginConvention warPluginConvention = GradleUtil.getConvention(\n\t\t\tproject, WarPluginConvention.class);\n\n\t\twarPluginConvention.setWebAppDirName(\"docroot\");\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureTaskWarFilesMatching(War warTask) {\n\t\tfinal Closure<String> closure = new Closure<String>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic String doCall(String line) {\n\t\t\t\tif (!line.contains(\"content/Language*.properties\")) {\n\t\t\t\t\treturn line;\n\t\t\t\t}\n\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tFile contentDir = new File(\n\t\t\t\t\t_liferayExtension.getPluginSrcDir(), \"content\");\n\n\t\t\t\tFile[] files = contentDir.listFiles();\n\n\t\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t\t\tFile file = files[i];\n\n\t\t\t\t\tsb.append(\"\\t<language-properties>content/\");\n\t\t\t\t\tsb.append(file.getName());\n\t\t\t\t\tsb.append(\"<\/language-properties>\");\n\n\t\t\t\t\tif ((i + 1) < files.length) {\n\t\t\t\t\t\tsb.append(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\n\t\t};\n\n\t\twarTask.filesMatching(\n\t\t\t\"WEB-INF/liferay-hook.xml\",\n\t\t\tnew Action<FileCopyDetails>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(FileCopyDetails fileCopyDetails) {\n\t\t\t\t\tfileCopyDetails.filter(closure);\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":42305,"modified_method":"protected void configureTaskWarFilesMatching(War warTask) {\n\t\tfinal Project project = warTask.getProject();\n\n\t\tfinal Closure<String> closure = new Closure<String>(null) {\n\n\t\t\t@SuppressWarnings(\"unused\")\n\t\t\tpublic String doCall(String line) {\n\t\t\t\tif (!line.contains(\"content/Language*.properties\")) {\n\t\t\t\t\treturn line;\n\t\t\t\t}\n\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tSourceSet sourceSet = GradleUtil.getSourceSet(\n\t\t\t\t\tproject, SourceSet.MAIN_SOURCE_SET_NAME);\n\n\t\t\t\tFileTree fileTree = GradleUtil.getFilteredFileTree(\n\t\t\t\t\tsourceSet.getResources(),\n\t\t\t\t\tnew String[] {\"content/Language*.properties\"}, null);\n\n\t\t\t\tIterator<File> iterator = fileTree.iterator();\n\n\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tFile file = iterator.next();\n\n\t\t\t\t\tsb.append(\"\\t<language-properties>content/\");\n\t\t\t\t\tsb.append(file.getName());\n\t\t\t\t\tsb.append(\"<\/language-properties>\");\n\t\t\t\t\tsb.append(\"\\n\");\n\t\t\t\t}\n\n\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\tsb.setLength(sb.length() - 1);\n\t\t\t\t}\n\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\n\t\t};\n\n\t\twarTask.filesMatching(\n\t\t\t\"WEB-INF/liferay-hook.xml\",\n\t\t\tnew Action<FileCopyDetails>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(FileCopyDetails fileCopyDetails) {\n\t\t\t\t\tfileCopyDetails.filter(closure);\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureDependencies() {\n\t\tconfigureDependenciesCompile();\n\t\tconfigureDependenciesProvidedCompile();\n\t}","id":42306,"modified_method":"@Override\n\tprotected void configureDependencies(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tsuper.configureDependencies(project, liferayExtension);\n\n\t\tconfigureDependenciesProvidedCompile(project, liferayExtension);\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addLiferayExtension() {\n\t\tString projectName = project.getName();\n\n\t\tif (projectName.endsWith(\"-theme\")) {\n\t\t\t_liferayExtension = addExtension(\n\t\t\t\tEXTENSION_NAME, LiferayThemeExtension.class);\n\t\t}\n\t\telse {\n\t\t\t_liferayExtension = addExtension(\n\t\t\t\tEXTENSION_NAME, LiferayExtension.class);\n\t\t}\n\t}","id":42307,"modified_method":"@Override\n\tprotected void configureDependenciesCompile(\n\t\tProject project, LiferayExtension liferayExtension) {\n\n\t\tsuper.configureDependenciesCompile(project, liferayExtension);\n\n\t\tif (liferayExtension instanceof LiferayThemeExtension) {\n\t\t\tfor (String dependencyNotation :\n\t\t\t\t\t_THEME_COMPILE_DEPENDENCY_NOTATIONS) {\n\n\t\t\t\tGradleUtil.addDependency(\n\t\t\t\t\tproject, JavaPlugin.COMPILE_CONFIGURATION_NAME,\n\t\t\t\t\tdependencyNotation);\n\t\t\t}\n\t\t}\n\n\t\tproject.afterEvaluate(\n\t\t\tnew Action<Project>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Project project) {\n\t\t\t\t\tFile serviceJarFile = new File(\n\t\t\t\t\t\tgetWebAppDir(project),\n\t\t\t\t\t\t\"WEB-INF/lib/\" + project.getName() + \"-service.jar\");\n\n\t\t\t\t\tif (serviceJarFile.exists()) {\n\t\t\t\t\t\tGradleUtil.addDependency(\n\t\t\t\t\t\t\tproject, JavaPlugin.COMPILE_CONFIGURATION_NAME,\n\t\t\t\t\t\t\tserviceJarFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"4a95f7756273fc085087238b3bdc52845c6493f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean expectBadServerSingle() throws IOException\n    {\n        ServerSocket server = new ServerSocket();\n        Socket client = null;\n        try {\n            server.bind(new InetSocketAddress(LOCALHOST, SERVER_PORT));\n            client = new Socket(LOCALHOST, SERVER_PORT);\n            Socket out = server.accept();\n            badSend(out);\n            return client.getInputStream().read() > -1;\n        }\n        finally\n        {\n            if (null != client)\n            {\n                client.close();\n            }\n            server.close();\n        }\n    }","id":42308,"modified_method":"protected boolean expectBadServerSingle() throws IOException, InterruptedException\n    {\n        ServerSocket server = new ServerSocket();\n        try {\n            server.bind(new InetSocketAddress(LOCALHOST, SERVER_PORT));\n            Socket client = new Socket(LOCALHOST, SERVER_PORT);\n            return badSend(server.accept(), client, server);\n        }\n        finally\n        {\n            server.close();\n        }\n    }","commit_id":"a100f78bafe002e0bbd3123ba0e1ce2b20e12b27","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void badSend(Socket socket) throws IOException\n    {\n        // just in case this reduces close time\n        socket.setReuseAddress(true);\n        // turn off linger\n        socket.setSoLinger(false, 0);\n        // set buffer larger than the size we will send\n        socket.setSendBufferSize(10);\n        // don't sent until buffer full\n        socket.setTcpNoDelay(false);\n        // write a single byte to the buffer\n        socket.getOutputStream().write(0);\n        // close (before buffer sent)\n        socket.close();\n    }","id":42309,"modified_method":"protected boolean badSend(Socket from, Socket to, ServerSocket server) throws IOException, InterruptedException\n    {\n        try\n        {\n            // reduce target buffer so that it is easy to fill\n            to.setReceiveBufferSize(1);\n            from.setSendBufferSize(1);\n            // just in case this reduces close time\n//            from.setReuseAddress(true);\n            // make linger very small (same result if false or omitted)\n//            from.setSoLinger(true, 1);\n//            to.setSoLinger(true, 1);\n            // don't send until buffer full (should be default)\n//            to.setTcpNoDelay(false);\n//            from.setTcpNoDelay(false);\n            // write two bytes to the buffer - this is more than the target can receive\n            // so we end up with one byte in receiver and one in sender\n            from.getOutputStream().write(1);\n            from.getOutputStream().write(2);\n            // this blocks, confirming buffers are correct\n//            from.getOutputStream().write(3);\n            // close (before buffer sent)\n            // close everything we can think of...\n            from.shutdownInput();\n            from.shutdownOutput();\n            from.close();\n            to.shutdownOutput();\n            if (null != server)\n            {\n                server.close();\n            }\n            // make sure tcp has time to fail\n            Thread.sleep(100);\n            // this works when server is closed (bad server case)\n            if (null != server)\n            {\n                ServerSocket another = new ServerSocket();\n                another.bind(new InetSocketAddress(LOCALHOST, SERVER_PORT));\n                another.setReuseAddress(true);\n                Socket another2 = new Socket(LOCALHOST, SERVER_PORT);\n                Socket another3 = another.accept();\n                another2.getOutputStream().write(9);\n                assertEquals(9, another3.getInputStream().read());\n                another3.close();\n                another2.close();\n                another.close();\n            }\n            // now try reading - this should fail on second value?\n            return 1 == to.getInputStream().read()\n                    && 2 == to.getInputStream().read();\n        }\n        finally\n        {\n            to.close();\n            if (!from.isClosed())\n            {\n                 from.close();\n            }\n        }\n    }","commit_id":"a100f78bafe002e0bbd3123ba0e1ce2b20e12b27","url":"https://github.com/mulesoft/mule"},{"original_method":"protected boolean expectBadClientSingle() throws IOException\n    {\n        ServerSocket server = new ServerSocket();\n        Socket in = null;\n        try {\n            server.bind(new InetSocketAddress(LOCALHOST, SERVER_PORT));\n            Socket client = new Socket(LOCALHOST, SERVER_PORT);\n            in = server.accept();\n            badSend(client);\n            return in.getInputStream().read() > -1;\n        }\n        finally\n        {\n            if (null != in)\n            {\n                in.close();\n            }\n            server.close();\n        }\n    }","id":42310,"modified_method":"protected boolean expectBadClientSingle() throws IOException, InterruptedException\n    {\n        ServerSocket server = new ServerSocket();\n        try {\n            server.bind(new InetSocketAddress(LOCALHOST, SERVER_PORT));\n            return badSend(new Socket(LOCALHOST, SERVER_PORT), server.accept(), null);\n        }\n        finally\n        {\n            server.close();\n        }\n    }","commit_id":"a100f78bafe002e0bbd3123ba0e1ce2b20e12b27","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSocketTiming() throws IOException\n    {\n        boolean expectBadClient = expectBadClient();\n        logger.info(\"Expected bad client: \" + expectBadClient);\n        boolean expectBadServer = expectBadServer();\n        logger.info(\"Expected bad server: \" + expectBadServer);\n    }","id":42311,"modified_method":"public void testSocketTiming() throws IOException, InterruptedException\n    {\n        try\n        {\n            boolean expectBadClient = expectBadClient();\n            logger.info(\"Expected bad client: \" + expectBadClient);\n        }\n        catch (Exception e)\n        {\n            logger.info(e);\n        }\n        try\n        {\n            boolean expectBadServer = expectBadServer();\n            logger.info(\"Expected bad server: \" + expectBadServer);\n        }\n        catch (Exception e)\n        {\n            logger.info(e);\n        }\n    }","commit_id":"a100f78bafe002e0bbd3123ba0e1ce2b20e12b27","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates a port finder that operates on private ports.\n     *\n     * @return a port finder that operates on private ports\n     */\n    public static AvailablePortFinder createPrivate() {\n        return new AvailablePortFinder(MIN_PRIVATE_PORT, MAX_PRIVATE_PORT);\n    }","id":42312,"modified_method":"/**\n     * Creates a port finder that operates on private ports.\n     *\n     * @return a port finder that operates on private ports\n     */\n    public static AvailablePortFinder createPrivate() {\n        return new AvailablePortFinder();\n    }","commit_id":"b525647a185231a0de30a87b4f720edba7c83d18","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Gets the next available port. Every port in the range is tried at most once.\n     * Tries to avoid returning the same port on successive invocations (but it may\n     * happen if no other available ports are found).\n     *\n     * @throws NoSuchElementException if no available port is found\n     *\n     * @return the next available port\n     */\n    public int getNextAvailable() {\n        int range = toPort - fromPort + 1;\n        int curr = candidateCounter.getAndIncrement();\n        int last = curr + range;\n        while (curr < last) {\n            int candidate = fromPort + curr % range;\n            if (available(candidate)) {\n                return candidate;\n            }\n            curr = candidateCounter.getAndIncrement();\n        }\n\n        throw new NoSuchElementException(\"Could not find an available port within port range\");\n    }","id":42313,"modified_method":"/**\n     * Gets the next available port.\n     *\n     * <p>Tries to avoid returning the same port on successive invocations (but it may happen if no other available ports are found).\n     *\n     * @return the next available port\n     * @throws NoSuchElementException if no available port is found\n     */\n    public int getNextAvailable() {\n        lock.lock();\n        try {\n            while (true) {\n                if (current >= MAX_PRIVATE_PORT) {\n                    current = MIN_PRIVATE_PORT;\n                } else {\n                    current++;\n                }\n                if (current == startPort) {\n                    throw new NoSuchElementException(\"Could not find an available port within port range.\");\n                }\n                int candidate = current;\n                if (available(candidate)) {\n                    return candidate;\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }","commit_id":"b525647a185231a0de30a87b4f720edba7c83d18","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Checks to see if a specific port is available.\n     *\n     * @param port the port to check for availability\n     *\n     * @return <tt>true<\/tt> if the port is available, <tt>false<\/tt> otherwise\n     */\n    public boolean available(int port) {\n        if (port < fromPort || port > toPort) {\n            throw new IllegalArgumentException(\"Port outside port range: \" + port);\n        }\n\n        ServerSocket ss = null;\n        DatagramSocket ds = null;\n        try {\n            ss = new ServerSocket(port);\n            ss.setReuseAddress(true);\n            ds = new DatagramSocket(port);\n            ds.setReuseAddress(true);\n            return true;\n        } catch (IOException ignored) {\n            /* checkstyle drives me nuts */\n        } finally {\n            if (ds != null) {\n                ds.close();\n            }\n\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException ignored) {\n                    /* checkstyle drives me nuts */\n                }\n            }\n        }\n\n        return false;\n    }","id":42314,"modified_method":"/**\n     * Checks to see if a specific port is available.\n     *\n     * @param port the port to check for availability\n     * @return <tt>true<\/tt> if the port is available, <tt>false<\/tt> otherwise\n     */\n    private boolean available(int port) {\n        try {\n            ServerSocket ss = new ServerSocket(port);\n            try {\n                ss.setReuseAddress(true);\n            } finally {\n                ss.close();\n            }\n            DatagramSocket ds = new DatagramSocket(port);\n            try {\n                ds.setReuseAddress(true);\n            } finally {\n                ds.close();\n            }\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }","commit_id":"b525647a185231a0de30a87b4f720edba7c83d18","url":"https://github.com/gradle/gradle"},{"original_method":"private AvailablePortFinder(int fromPort, int toPort) {\n        if (fromPort < MIN_PORT || toPort > MAX_PORT || fromPort > toPort) {\n            throw new IllegalArgumentException(\"Invalid port range\");\n        }\n\n        this.fromPort = fromPort;\n        this.toPort = toPort;\n    }","id":42315,"modified_method":"public AvailablePortFinder() {\n        startPort = new Random().nextInt(MAX_PRIVATE_PORT - MIN_PRIVATE_PORT) + MIN_PRIVATE_PORT;\n        current = startPort;\n    }","commit_id":"b525647a185231a0de30a87b4f720edba7c83d18","url":"https://github.com/gradle/gradle"},{"original_method":"public void addRead( SAMRecord newRead ) {\n        if ( DEBUG ) logger.info(\"New read pos \" + newRead.getAlignmentStart() + \" OP = \" + newRead.getAttribute(\"OP\"));\n\n        //final long curTime = timer.currentTime();\n        //if ( curTime - lastProgressPrintTime > PROGRESS_PRINT_FREQUENCY ) {\n        //    lastProgressPrintTime = curTime;\n        //    System.out.println(\"WaitingReads.size = \" + waitingReads.size() + \", forMateMatching.size = \" + forMateMatching.size());\n        //}\n\n        // if the new read is on a different contig or we have too many reads, then we need to flush the queue and clear the map\n        boolean tooManyReads = getNReadsInQueue() >= MAX_RECORDS_IN_MEMORY;\n        if ( tooManyReads || (getNReadsInQueue() > 0 && waitingReads.peek().getReferenceIndex() != newRead.getReferenceIndex()) ) {\n            if ( DEBUG ) logger.warn(\"Flushing queue on \" + (tooManyReads ? \"too many reads\" : (\"move to new contig: \" + newRead.getReferenceName() + \" from \" + waitingReads.peek().getReferenceName())) + \" at \" + newRead.getAlignmentStart());\n\n            while ( getNReadsInQueue() > 1 ) {\n                // emit to disk\n                writeRead(waitingReads.remove());\n            }\n\n            SAMRecord lastRead = waitingReads.remove();\n            lastLocFlushed = (lastRead.getReferenceIndex() == -1) ? null : genomeLocParser.createGenomeLoc(lastRead);\n            writeRead(lastRead);\n\n            if ( !tooManyReads )\n                forMateMatching.clear();\n        }\n\n        // fix mates, as needed\n        // Since setMateInfo can move reads, we potentially need to remove the mate, and requeue\n        // it to ensure proper sorting\n        if ( newRead.getReadPairedFlag() ) {\n            SAMRecord mate = forMateMatching.get(newRead.getReadName());\n            if ( mate != null ) {\n                // 1. Frustratingly, Picard's setMateInfo() method unaligns (by setting the reference contig\n                // to '*') read pairs when both of their flags have the unmapped bit set.  This is problematic\n                // when trying to emit reads in coordinate order because all of a sudden we have reads in the\n                // middle of the bam file that now belong at the end - and any mapped reads that get emitted\n                // after them trigger an exception in the writer.  For our purposes, because we shouldn't be\n                // moving read pairs when they are both unmapped anyways, we'll just not run fix mates on them.\n                // 2. Furthermore, when reads get mapped to the junction of two chromosomes (e.g. MT since it\n                // is actually circular DNA), their unmapped bit is set, but they are given legitimate coordinates.\n                // The Picard code will come in and move the read all the way back to its mate (which can be\n                // arbitrarily far away).  However, we do still want to move legitimately unmapped reads whose\n                // mates are mapped, so the compromise will be that if the mate is still in the queue then we'll\n                // move the read and otherwise we won't.\n                boolean doNotFixMates = newRead.getReadUnmappedFlag() && (mate.getReadUnmappedFlag() || !waitingReads.contains(mate));\n                if ( !doNotFixMates ) {\n\n                    boolean reQueueMate = mate.getReadUnmappedFlag() && ! newRead.getReadUnmappedFlag();\n                    if ( reQueueMate ) {\n                        // the mate was unmapped, but newRead was mapped, so the mate may have been moved\n                        // to be next-to newRead, so needs to be reinserted into the waitingReads queue\n                        // note -- this must be called before the setMateInfo call below\n                        if ( ! waitingReads.remove(mate) )\n                            // we must have hit a region with too much depth and flushed the queue\n                            reQueueMate = false;\n                    }\n\n                    // we've already seen our mate -- set the mate info and remove it from the map\n                    SamPairUtil.setMateInfo(mate, newRead, null);\n                    if ( reQueueMate ) waitingReads.add(mate);\n                }\n\n                forMateMatching.remove(newRead.getReadName());\n            } else {\n                forMateMatching.put(newRead.getReadName(), newRead);\n            }\n        }\n\n        waitingReads.add(newRead);\n\n        if ( ++counter % EMIT_FREQUENCY == 0 ) {\n            while ( ! waitingReads.isEmpty() ) { // there's something in the queue\n                SAMRecord read = waitingReads.peek();\n\n                if ( noReadCanMoveBefore(read.getAlignmentStart(), newRead) &&\n                        (iSizeTooBigToMove(read)                                           // we won't try to move such a read\n                                || ! read.getReadPairedFlag()                                     // we're not a paired read\n                                || read.getReadUnmappedFlag() && read.getMateUnmappedFlag()       // both reads are unmapped\n                                || noReadCanMoveBefore(read.getMateAlignmentStart(), newRead ) ) ) { // we're already past where the mate started\n\n                    // remove reads from the map that we have emitted -- useful for case where the mate never showed up\n                    forMateMatching.remove(read.getReadName());\n\n                    if ( DEBUG )\n                        logger.warn(String.format(\"EMIT!  At %d: read %s at %d with isize %d, mate start %d, op = %s\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(),\n                                read.getInferredInsertSize(), read.getMateAlignmentStart(), read.getAttribute(\"OP\")));\n                    // emit to disk\n                    writeRead(waitingReads.remove());\n                } else {\n                    if ( DEBUG )\n                        logger.warn(String.format(\"At %d: read %s at %d with isize %d couldn't be emited, mate start %d\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(), read.getInferredInsertSize(), read.getMateAlignmentStart()));\n                    break;\n                }\n            }\n\n            if ( DEBUG ) logger.warn(String.format(\"At %d: Done with emit cycle\", newRead.getAlignmentStart()));\n        }\n    }","id":42316,"modified_method":"public void addRead( SAMRecord newRead ) {\n        if ( DEBUG ) logger.info(\"New read pos \" + newRead.getAlignmentStart() + \" OP = \" + newRead.getAttribute(\"OP\"));\n\n        //final long curTime = timer.currentTime();\n        //if ( curTime - lastProgressPrintTime > PROGRESS_PRINT_FREQUENCY ) {\n        //    lastProgressPrintTime = curTime;\n        //    System.out.println(\"WaitingReads.size = \" + waitingReads.size() + \", forMateMatching.size = \" + forMateMatching.size());\n        //}\n\n        // if the new read is on a different contig or we have too many reads, then we need to flush the queue and clear the map\n        boolean tooManyReads = getNReadsInQueue() >= MAX_RECORDS_IN_MEMORY;\n        if ( tooManyReads || (getNReadsInQueue() > 0 && !waitingReads.peek().getReferenceIndex().equals(newRead.getReferenceIndex())) ) {\n            if ( DEBUG ) logger.warn(\"Flushing queue on \" + (tooManyReads ? \"too many reads\" : (\"move to new contig: \" + newRead.getReferenceName() + \" from \" + waitingReads.peek().getReferenceName())) + \" at \" + newRead.getAlignmentStart());\n\n            while ( getNReadsInQueue() > 1 ) {\n                // emit to disk\n                writeRead(waitingReads.remove());\n            }\n\n            SAMRecord lastRead = waitingReads.remove();\n            lastLocFlushed = (lastRead.getReferenceIndex() == -1) ? null : genomeLocParser.createGenomeLoc(lastRead);\n            writeRead(lastRead);\n\n            if ( !tooManyReads )\n                forMateMatching.clear();\n        }\n\n        // fix mates, as needed\n        // Since setMateInfo can move reads, we potentially need to remove the mate, and requeue\n        // it to ensure proper sorting\n        if ( newRead.getReadPairedFlag() ) {\n            SAMRecord mate = forMateMatching.get(newRead.getReadName());\n            if ( mate != null ) {\n                // 1. Frustratingly, Picard's setMateInfo() method unaligns (by setting the reference contig\n                // to '*') read pairs when both of their flags have the unmapped bit set.  This is problematic\n                // when trying to emit reads in coordinate order because all of a sudden we have reads in the\n                // middle of the bam file that now belong at the end - and any mapped reads that get emitted\n                // after them trigger an exception in the writer.  For our purposes, because we shouldn't be\n                // moving read pairs when they are both unmapped anyways, we'll just not run fix mates on them.\n                // 2. Furthermore, when reads get mapped to the junction of two chromosomes (e.g. MT since it\n                // is actually circular DNA), their unmapped bit is set, but they are given legitimate coordinates.\n                // The Picard code will come in and move the read all the way back to its mate (which can be\n                // arbitrarily far away).  However, we do still want to move legitimately unmapped reads whose\n                // mates are mapped, so the compromise will be that if the mate is still in the queue then we'll\n                // move the read and otherwise we won't.\n                boolean doNotFixMates = newRead.getReadUnmappedFlag() && (mate.getReadUnmappedFlag() || !waitingReads.contains(mate));\n                if ( !doNotFixMates ) {\n\n                    boolean reQueueMate = mate.getReadUnmappedFlag() && ! newRead.getReadUnmappedFlag();\n                    if ( reQueueMate ) {\n                        // the mate was unmapped, but newRead was mapped, so the mate may have been moved\n                        // to be next-to newRead, so needs to be reinserted into the waitingReads queue\n                        // note -- this must be called before the setMateInfo call below\n                        if ( ! waitingReads.remove(mate) )\n                            // we must have hit a region with too much depth and flushed the queue\n                            reQueueMate = false;\n                    }\n\n                    // we've already seen our mate -- set the mate info and remove it from the map\n                    SamPairUtil.setMateInfo(mate, newRead, null);\n                    if ( reQueueMate ) waitingReads.add(mate);\n                }\n\n                forMateMatching.remove(newRead.getReadName());\n            } else {\n                forMateMatching.put(newRead.getReadName(), newRead);\n            }\n        }\n\n        waitingReads.add(newRead);\n\n        if ( ++counter % EMIT_FREQUENCY == 0 ) {\n            while ( ! waitingReads.isEmpty() ) { // there's something in the queue\n                SAMRecord read = waitingReads.peek();\n\n                if ( noReadCanMoveBefore(read.getAlignmentStart(), newRead) &&\n                        (iSizeTooBigToMove(read)                                           // we won't try to move such a read\n                                || ! read.getReadPairedFlag()                                     // we're not a paired read\n                                || read.getReadUnmappedFlag() && read.getMateUnmappedFlag()       // both reads are unmapped\n                                || noReadCanMoveBefore(read.getMateAlignmentStart(), newRead ) ) ) { // we're already past where the mate started\n\n                    // remove reads from the map that we have emitted -- useful for case where the mate never showed up\n                    forMateMatching.remove(read.getReadName());\n\n                    if ( DEBUG )\n                        logger.warn(String.format(\"EMIT!  At %d: read %s at %d with isize %d, mate start %d, op = %s\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(),\n                                read.getInferredInsertSize(), read.getMateAlignmentStart(), read.getAttribute(\"OP\")));\n                    // emit to disk\n                    writeRead(waitingReads.remove());\n                } else {\n                    if ( DEBUG )\n                        logger.warn(String.format(\"At %d: read %s at %d with isize %d couldn't be emited, mate start %d\",\n                                newRead.getAlignmentStart(), read.getReadName(), read.getAlignmentStart(), read.getInferredInsertSize(), read.getMateAlignmentStart()));\n                    break;\n                }\n            }\n\n            if ( DEBUG ) logger.warn(String.format(\"At %d: Done with emit cycle\", newRead.getAlignmentStart()));\n        }\n    }","commit_id":"26e3bea76e1376ceef6c283b2a0d4731baeea893","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public boolean canRead(File file) {\n        final byte[] BAM_MAGIC = \"BAM\\1\".getBytes();\n        final byte[] buffer = new byte[BAM_MAGIC.length];\n        try {\n            InputStream fstream = new BufferedInputStream(new FileInputStream(file));\n            if ( !BlockCompressedInputStream.isValidFile(fstream) )\n                return false;\n            new BlockCompressedInputStream(fstream).read(buffer, 0, BAM_MAGIC.length);\n            return Arrays.equals(buffer, BAM_MAGIC);\n        } catch ( IOException e ) {\n            return false;\n        } catch ( net.sf.samtools.FileTruncatedException e ) {\n            return false;\n        }\n    }","id":42317,"modified_method":"@Override\n    public boolean canRead(File file) {\n        final byte[] BAM_MAGIC = \"BAM\\1\".getBytes();\n        final byte[] buffer = new byte[BAM_MAGIC.length];\n        try {\n            InputStream fstream = new BufferedInputStream(new FileInputStream(file));\n            if ( !BlockCompressedInputStream.isValidFile(fstream) )\n                return false;\n            final BlockCompressedInputStream BCIS = new BlockCompressedInputStream(fstream);\n            BCIS.read(buffer, 0, BAM_MAGIC.length);\n            BCIS.close();\n            return Arrays.equals(buffer, BAM_MAGIC);\n        } catch ( IOException e ) {\n            return false;\n        } catch ( net.sf.samtools.FileTruncatedException e ) {\n            return false;\n        }\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static boolean iSizeTooBigToMove(SAMRecord read, int maxInsertSizeForMovingReadPairs) {\n        return ( read.getReadPairedFlag() && ! read.getMateUnmappedFlag() && read.getReferenceName() != read.getMateReferenceName() ) // maps to different chromosomes\n                || Math.abs(read.getInferredInsertSize()) > maxInsertSizeForMovingReadPairs;     // we won't try to move such a read\n    }","id":42318,"modified_method":"public static boolean iSizeTooBigToMove(SAMRecord read, int maxInsertSizeForMovingReadPairs) {\n        return ( read.getReadPairedFlag() && ! read.getMateUnmappedFlag() && !read.getReferenceName().equals(read.getMateReferenceName()) ) // maps to different chromosomes\n                || Math.abs(read.getInferredInsertSize()) > maxInsertSizeForMovingReadPairs;     // we won't try to move such a read\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Creates fasta sequence index from fasta file\n     * @return FastaSequenceIndex that is read from file\n     */\n    public FastaSequenceIndex createIndex() {    // should this be static?\n        bytesRead = -1;\n        endOfLastLine = -1;\n        contig = \"\";\n        location = 0;\n        size = 0;\n        bytesPerLine = 0;\n        basesPerLine = 0;\n        basesThisLine = 0;\n        lastTimestamp = System.currentTimeMillis();\n        FastaSequenceIndex sequenceIndex = new FastaSequenceIndex();\n\n        // initialize input stream\n        DataInputStream in;\n        try {\n            in = new DataInputStream(new BufferedInputStream(new FileInputStream(fastaFile)));\n        }\n        catch (Exception e) {\n            throw new UserException.CouldNotReadInputFile(fastaFile, \"Could not read fasta file\", e);\n        }\n\n        /*\n        * iterate through each character in file one at a time, but must account for variance in line terminators\n        * strategy is to check if current character is a line terminator (\\n, \\r), then check next character\n        * only treat as end of line if next character is NOT a line terminator\n        */\n        try {\n            // intialize iterators\n            nextByte = in.readByte();\n            currentByte = '\\n';\n            while(currentByte != -1) {\n\n                bytesRead ++; // update position in file\n                lastByte = currentByte;\n                currentByte = nextByte;\n                try {\n                    nextByte = in.readByte();\n                }                                          \n                catch (EOFException e) {\n                    nextByte = -1;\n                }\n\n                switch(status) {\n\n                    // if not currently reading anything\n                    // only thing that can trigger action is '>' (start of contig) or ';' (comment)\n                    case NONE:\n                        if (currentByte == '>')\n                            status = CONTIG;\n                        else if (currentByte == ';')\n                            status = COMMENT;\n                        break;\n\n                    // if reading a comment, just ignore everything until end of line\n                    case COMMENT:\n                        if (isEol(currentByte)) {\n                            if (!isEol(nextByte))\n                                status = Status.NONE;\n                        }\n                        break;\n\n                    // if reading a contig, add char to contig string\n                    // contig string can be anything, including spaces\n                    case CONTIG:\n                        if (isEol(currentByte)) {\n                            if (!isEol(nextByte)) {\n                                status = Status.FIRST_SEQ_LINE;\n                                location = bytesRead + 1;\n                            }\n                        }\n                        else\n                            contig += (char) currentByte;\n                        break;\n\n                    // record bases and bytes of first sequence line, to validate against later lines\n                    case FIRST_SEQ_LINE:\n\n                        if (isEol(currentByte)) {\n\n                            // record bases per line if last character was a base\n                            if (!isEol(lastByte)) {\n                                basesPerLine = bytesRead - location;\n                                basesThisLine = basesPerLine;\n                                size += basesPerLine;\n                            }\n\n                            // next character is start of next line, now know bytes per line\n                            if (!isEol(nextByte)) {   // figure out what to do if there is only one data line\n                                bytesPerLine = bytesRead - location + 1;\n                                status = Status.SEQ_LINE;\n                                endOfLastLine = bytesRead;\n\n                                // if next char is ';' or '>', then there is only one contig =>\n                                if (nextByte == ';' || nextByte == '>')\n                                    finishReadingContig(sequenceIndex);\n                            }\n                        }\n\n                        // validate base character\n                        else {\n                            if (!isValidBase(currentByte))\n                                throw new UserException.MalformedFile(fastaFile, String.format(\"An invalid base was found in the contig: %s\", contig));\n                        }\n                        break;\n\n\n                    case SEQ_LINE:\n\n                        if (isEol(currentByte)) {\n\n                            // record bases per line if last character was a base\n                            if (!isEol(lastByte)) {\n                                basesThisLine = bytesRead - endOfLastLine - 1;\n                                size += basesThisLine;\n                            }\n\n                            // reached end of line - check if end of contig\n                            if (!isEol(nextByte)) {\n\n                                // if comment or new contig, definitely end of sequence\n                                if (nextByte == ';' || nextByte == '>')\n                                    finishReadingContig(sequenceIndex);\n\n                                    // if this line has different # of bases OR same # of bases and different # of bytes:\n                                    // error if next char is a valid base, end of contig otherwise\n                                else if (basesThisLine != basesPerLine || bytesPerLine != bytesRead - endOfLastLine) {\n                                    if (isValidBase(nextByte) && nextByte != -1) {\n                                        throw new UserException.MalformedFile(fastaFile, String.format(\"An invalid line was found in the contig: %s\", contig));\n                                    }\n                                    else\n                                        finishReadingContig(sequenceIndex);\n                                }\n                                endOfLastLine = bytesRead;\n                            }\n                        }\n\n                        // validate base character\n                        else {\n                            if (!isValidBase(currentByte))\n                                throw new UserException.MalformedFile(fastaFile, String.format(\"An invalid base was found in the contig: %s\", contig));\n                        }\n                        break;\n                }\n            }\n            return sequenceIndex;\n        }\n        catch (IOException e) {\n            throw new UserException.CouldNotReadInputFile(fastaFile, \"Could not read fasta file\", e);\n        }\n        catch (Exception e) {\n            throw new ReviewedStingException(e.getMessage(), e);\n        }\n    }","id":42319,"modified_method":"/**\n     * Creates fasta sequence index from fasta file\n     * @return FastaSequenceIndex that is read from file\n     */\n    public FastaSequenceIndex createIndex() {    // should this be static?\n        bytesRead = -1;\n        endOfLastLine = -1;\n        contig = \"\";\n        location = 0;\n        size = 0;\n        bytesPerLine = 0;\n        basesPerLine = 0;\n        basesThisLine = 0;\n        lastTimestamp = System.currentTimeMillis();\n        FastaSequenceIndex sequenceIndex = new FastaSequenceIndex();\n\n        // initialize input stream\n        DataInputStream in;\n        try {\n            in = new DataInputStream(new BufferedInputStream(new FileInputStream(fastaFile)));\n        }\n        catch (Exception e) {\n            throw new UserException.CouldNotReadInputFile(fastaFile, \"Could not read fasta file\", e);\n        }\n\n        /*\n        * iterate through each character in file one at a time, but must account for variance in line terminators\n        * strategy is to check if current character is a line terminator (\\n, \\r), then check next character\n        * only treat as end of line if next character is NOT a line terminator\n        */\n        try {\n            // intialize iterators\n            nextByte = in.readByte();\n            currentByte = '\\n';\n            while(currentByte != -1) {\n\n                bytesRead ++; // update position in file\n                lastByte = currentByte;\n                currentByte = nextByte;\n                try {\n                    nextByte = in.readByte();\n                }                                          \n                catch (EOFException e) {\n                    nextByte = -1;\n                }\n\n                switch(status) {\n\n                    // if not currently reading anything\n                    // only thing that can trigger action is '>' (start of contig) or ';' (comment)\n                    case NONE:\n                        if (currentByte == '>')\n                            status = CONTIG;\n                        else if (currentByte == ';')\n                            status = COMMENT;\n                        break;\n\n                    // if reading a comment, just ignore everything until end of line\n                    case COMMENT:\n                        if (isEol(currentByte)) {\n                            if (!isEol(nextByte))\n                                status = Status.NONE;\n                        }\n                        break;\n\n                    // if reading a contig, add char to contig string\n                    // contig string can be anything, including spaces\n                    case CONTIG:\n                        if (isEol(currentByte)) {\n                            if (!isEol(nextByte)) {\n                                status = Status.FIRST_SEQ_LINE;\n                                location = bytesRead + 1;\n                            }\n                        }\n                        else\n                            contig += (char) currentByte;\n                        break;\n\n                    // record bases and bytes of first sequence line, to validate against later lines\n                    case FIRST_SEQ_LINE:\n\n                        if (isEol(currentByte)) {\n\n                            // record bases per line if last character was a base\n                            if (!isEol(lastByte)) {\n                                basesPerLine = bytesRead - location;\n                                basesThisLine = basesPerLine;\n                                size += basesPerLine;\n                            }\n\n                            // next character is start of next line, now know bytes per line\n                            if (!isEol(nextByte)) {   // figure out what to do if there is only one data line\n                                bytesPerLine = bytesRead - location + 1;\n                                status = Status.SEQ_LINE;\n                                endOfLastLine = bytesRead;\n\n                                // if next char is ';' or '>', then there is only one contig =>\n                                if (nextByte == ';' || nextByte == '>')\n                                    finishReadingContig(sequenceIndex);\n                            }\n                        }\n\n                        // validate base character\n                        else {\n                            if (!isValidBase(currentByte))\n                                throw new UserException.MalformedFile(fastaFile, String.format(\"An invalid base was found in the contig: %s\", contig));\n                        }\n                        break;\n\n\n                    case SEQ_LINE:\n\n                        if (isEol(currentByte)) {\n\n                            // record bases per line if last character was a base\n                            if (!isEol(lastByte)) {\n                                basesThisLine = bytesRead - endOfLastLine - 1;\n                                size += basesThisLine;\n                            }\n\n                            // reached end of line - check if end of contig\n                            if (!isEol(nextByte)) {\n\n                                // if comment or new contig, definitely end of sequence\n                                if (nextByte == ';' || nextByte == '>')\n                                    finishReadingContig(sequenceIndex);\n\n                                    // if this line has different # of bases OR same # of bases and different # of bytes:\n                                    // error if next char is a valid base, end of contig otherwise\n                                else if (basesThisLine != basesPerLine || bytesPerLine != bytesRead - endOfLastLine) {\n                                    if (isValidBase(nextByte) && nextByte != -1) {\n                                        throw new UserException.MalformedFile(fastaFile, String.format(\"An invalid line was found in the contig: %s\", contig));\n                                    }\n                                    else\n                                        finishReadingContig(sequenceIndex);\n                                }\n                                endOfLastLine = bytesRead;\n                            }\n                        }\n\n                        // validate base character\n                        else {\n                            if (!isValidBase(currentByte))\n                                throw new UserException.MalformedFile(fastaFile, String.format(\"An invalid base was found in the contig: %s\", contig));\n                        }\n                        break;\n                }\n            }\n            in.close();\n            return sequenceIndex;\n        }\n        catch (IOException e) {\n            throw new UserException.CouldNotReadInputFile(fastaFile, \"Could not read fasta file\", e);\n        }\n        catch (Exception e) {\n            throw new ReviewedStingException(e.getMessage(), e);\n        }\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static String httpPost(String data, String URL) {\n        try {\n\n            DefaultHttpClient httpClient = new DefaultHttpClient();\n            HttpPost postRequest = new HttpPost(URL);\n\n            StringEntity input = new StringEntity(data);\n            input.setContentType(\"application/json\");\n            postRequest.setEntity(input);\n\n            HttpResponse response = httpClient.execute(postRequest);\n\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new RuntimeException(\"Failed : HTTP error code : \"\n                        + response.getStatusLine().getStatusCode());\n            }\n\n            BufferedReader br = new BufferedReader(\n                    new InputStreamReader((response.getEntity().getContent())));\n\n            String output = \"\";\n            String line;\n            System.out.println(\"Output from Server .... \\n\");\n            while ((line = br.readLine()) != null) {\n                output += (line + '\\n');\n                System.out.println(line);\n            }\n\n            httpClient.getConnectionManager().shutdown();\n            return output;\n\n        } catch (MalformedURLException e) {\n\n            e.printStackTrace();\n\n        } catch (IOException e) {\n\n            e.printStackTrace();\n\n        }\n        return null;\n    }","id":42320,"modified_method":"private static String httpPost(String data, String URL) {\n        try {\n\n            DefaultHttpClient httpClient = new DefaultHttpClient();\n            HttpPost postRequest = new HttpPost(URL);\n\n            StringEntity input = new StringEntity(data);\n            input.setContentType(\"application/json\");\n            postRequest.setEntity(input);\n\n            HttpResponse response = httpClient.execute(postRequest);\n\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new RuntimeException(\"Failed : HTTP error code : \"\n                        + response.getStatusLine().getStatusCode());\n            }\n\n            BufferedReader br = new BufferedReader(\n                    new InputStreamReader((response.getEntity().getContent())));\n\n            String output = \"\";\n            String line;\n            System.out.println(\"Output from Server .... \\n\");\n            while ((line = br.readLine()) != null) {\n                output += (line + '\\n');\n                System.out.println(line);\n            }\n\n            br.close();\n            httpClient.getConnectionManager().shutdown();\n            return output;\n\n        } catch (MalformedURLException e) {\n\n            e.printStackTrace();\n\n        } catch (IOException e) {\n\n            e.printStackTrace();\n\n        }\n        return null;\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public boolean canRead(File file) {\n        try {\n            final String HEADER = GATKReport.GATKREPORT_HEADER_PREFIX;\n            char[] buff = new char[HEADER.length()];\n            new FileReader(file).read(buff, 0, HEADER.length());\n            String firstLine = new String(buff);\n            return firstLine.startsWith(HEADER);\n        } catch (IOException e) {\n            return false;\n        }\n    }","id":42321,"modified_method":"@Override\n    public boolean canRead(File file) {\n        try {\n            final String HEADER = GATKReport.GATKREPORT_HEADER_PREFIX;\n            final char[] buff = new char[HEADER.length()];\n            final FileReader FR = new FileReader(file);\n            FR.read(buff, 0, HEADER.length());\n            FR.close();\n            String firstLine = new String(buff);\n            return firstLine.startsWith(HEADER);\n        } catch (IOException e) {\n            return false;\n        }\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"boolean hasValidMate(GATKSAMRecord read, ThresHolder thresholds) {\n        /** Check the following\n         * Does it have a pair?\n         * reasonable insert size?\n         * inverted?\n         * same orientation?\n         * same contig?\n         * is pair mapped?\n         * todo - is forced mate?\n         *\n         */\n\n        // has NO pair\n        if (!read.getReadPairedFlag())\n            return false;\n\n        // different contigs\n        if (read.getMateReferenceIndex() != read.getReferenceIndex())\n            return false;\n\n        // unmapped\n        if (read.getMateUnmappedFlag() || read.getReadUnmappedFlag())\n            return false;\n\n        // same orientation\n        if (read.getReadNegativeStrandFlag() == read.getMateNegativeStrandFlag())\n            return false;\n\n        // inverted\n        if (read.getReadNegativeStrandFlag() ==\n                read.getAlignmentStart() < read.getMateAlignmentStart())\n            return false;\n\n        // TODO note: IGV uses a different algorithm for insert size, there should be a common util class that does this for you\n        // mates are too far apart\n        if (Math.abs(read.getAlignmentStart() - read.getMateAlignmentStart()) > thresholds.getMaximumInsertSize())\n            return false;\n\n        return true;\n    }","id":42322,"modified_method":"boolean hasValidMate(GATKSAMRecord read, ThresHolder thresholds) {\n        /** Check the following\n         * Does it have a pair?\n         * reasonable insert size?\n         * inverted?\n         * same orientation?\n         * same contig?\n         * is pair mapped?\n         * todo - is forced mate?\n         *\n         */\n\n        // has NO pair\n        if (!read.getReadPairedFlag())\n            return false;\n\n        // different contigs\n        if (!read.getMateReferenceIndex().equals(read.getReferenceIndex()))\n            return false;\n\n        // unmapped\n        if (read.getMateUnmappedFlag() || read.getReadUnmappedFlag())\n            return false;\n\n        // same orientation\n        if (read.getReadNegativeStrandFlag() == read.getMateNegativeStrandFlag())\n            return false;\n\n        // inverted\n        if (read.getReadNegativeStrandFlag() ==\n                read.getAlignmentStart() < read.getMateAlignmentStart())\n            return false;\n\n        // TODO note: IGV uses a different algorithm for insert size, there should be a common util class that does this for you\n        // mates are too far apart\n        if (Math.abs(read.getAlignmentStart() - read.getMateAlignmentStart()) > thresholds.getMaximumInsertSize())\n            return false;\n\n        return true;\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static void writeTranchesDebuggingInfo(File f, List<VariantDatum> tranchesData, SelectionMetric metric ) {\n        try {\n            PrintStream out = new PrintStream(f);\n            out.println(\"Qual metricValue runningValue\");\n            for ( int i = 0; i < tranchesData.size(); i++ ) {\n                VariantDatum  d = tranchesData.get(i);\n                int score = metric.datumValue(d);\n                double runningValue = metric.getRunningMetric(i);\n                out.printf(\"%.4f %d %.4f%n\", d.lod, score, runningValue);\n            }\n        } catch (FileNotFoundException e) {\n            throw new UserException.CouldNotCreateOutputFile(f, e);\n        }\n    }","id":42323,"modified_method":"private static void writeTranchesDebuggingInfo(File f, List<VariantDatum> tranchesData, SelectionMetric metric ) {\n        try {\n            PrintStream out = new PrintStream(f);\n            out.println(\"Qual metricValue runningValue\");\n            for ( int i = 0; i < tranchesData.size(); i++ ) {\n                VariantDatum  d = tranchesData.get(i);\n                int score = metric.datumValue(d);\n                double runningValue = metric.getRunningMetric(i);\n                out.printf(\"%.4f %d %.4f%n\", d.lod, score, runningValue);\n            }\n            out.close();\n        } catch (FileNotFoundException e) {\n            throw new UserException.CouldNotCreateOutputFile(f, e);\n        }\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone(Integer numSites) {\n        logger.info(String.format(\"%d sites processed!\",numSites));\n        // push out the remaining genotypes and close stream\n        for ( String sample : printMap.keySet() ) {\n            try {\n                int lim = byteCount + (genotypeCount > 0 ? 1 : 0);\n                printMap.get(sample).write(genotypeBuffer.get(sample),0,lim);\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error closing temporary file.\",e);\n            }\n\n            try {\n               printMap.get(sample).close();\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error closing temporary file.\",e);\n            }\n        }\n        for ( String sample : famOrder ) {\n            logger.info(\"Merging genotypes for \"+sample);\n            FileInputStream inStream;\n            try {\n                inStream = new FileInputStream(tempFiles.get(sample));\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error opening temp file for input.\",e);\n            }\n\n\n            try {\n                int ttr = numSites/4 + (genotypeCount > 0 ? 1 : 0);\n                for ( ; ttr > BUFFER_SIZE ; ttr -= BUFFER_SIZE ) {\n                    byte[] readGenotypes = new byte[BUFFER_SIZE];\n                    inStream.read(readGenotypes);\n                    outBed.write(readGenotypes);\n                }\n                if ( ttr > 0 ) {\n                    byte[] readGenotypes = new byte[ttr];\n                    inStream.read(readGenotypes);\n                    outBed.write(readGenotypes);\n                }\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error reading form temp file for input.\",e);\n            }\n        }\n\n    }","id":42324,"modified_method":"public void onTraversalDone(Integer numSites) {\n        logger.info(String.format(\"%d sites processed!\",numSites));\n        // push out the remaining genotypes and close stream\n        for ( String sample : printMap.keySet() ) {\n            try {\n                int lim = byteCount + (genotypeCount > 0 ? 1 : 0);\n                printMap.get(sample).write(genotypeBuffer.get(sample),0,lim);\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error closing temporary file.\",e);\n            }\n\n            try {\n               printMap.get(sample).close();\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error closing temporary file.\",e);\n            }\n        }\n        for ( String sample : famOrder ) {\n            logger.info(\"Merging genotypes for \"+sample);\n            FileInputStream inStream;\n            try {\n                inStream = new FileInputStream(tempFiles.get(sample));\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error opening temp file for input.\",e);\n            }\n\n\n            try {\n                int ttr = numSites/4 + (genotypeCount > 0 ? 1 : 0);\n                for ( ; ttr > BUFFER_SIZE ; ttr -= BUFFER_SIZE ) {\n                    byte[] readGenotypes = new byte[BUFFER_SIZE];\n                    inStream.read(readGenotypes);\n                    outBed.write(readGenotypes);\n                }\n                if ( ttr > 0 ) {\n                    byte[] readGenotypes = new byte[ttr];\n                    inStream.read(readGenotypes);\n                    outBed.write(readGenotypes);\n                }\n                inStream.close();\n            } catch (IOException e) {\n                throw new ReviewedStingException(\"Error reading form temp file for input.\",e);\n            }\n        }\n\n    }","commit_id":"550472efa7d537524f8c062052c4f278750284b9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Merge two overlapping reads from the same fragment into a single super read, if possible\n     *\n     * firstRead and secondRead must be part of the same fragment (though this isn't checked).  Looks\n     * at the bases and alignment, and tries its best to create a meaningful synthetic single super read\n     * that represents the entire sequenced fragment.\n     *\n     * Assumes that firstRead starts before secondRead (according to their soft clipped starts)\n     *\n     * @param clippedFirstRead the left most read\n     * @param clippedSecondRead the right most read\n     *\n     * @return a strandless merged read of first and second, or null if the algorithm cannot create a meaningful one\n     */\n    public static void adjustQualsOfOverlappingPairedFragments(final GATKSAMRecord clippedFirstRead, final GATKSAMRecord clippedSecondRead) {\n        if ( clippedFirstRead == null ) throw new IllegalArgumentException(\"clippedFirstRead cannot be null\");\n        if ( clippedSecondRead == null ) throw new IllegalArgumentException(\"clippedSecondRead cannot be null\");\n        if ( ! clippedFirstRead.getReadName().equals(clippedSecondRead.getReadName()) ) throw new IllegalArgumentException(\"attempting to merge two reads with different names \" + clippedFirstRead + \" and \" + clippedSecondRead);\n\n        // don't adjust fragments that do not overlap\n        if ( clippedFirstRead.getAlignmentEnd() < clippedSecondRead.getAlignmentStart() || clippedFirstRead.getReferenceIndex() != clippedSecondRead.getReferenceIndex() )\n            return;\n\n        final Pair<Integer, Boolean> pair = ReadUtils.getReadCoordinateForReferenceCoordinate(clippedFirstRead, clippedSecondRead.getAlignmentStart());\n        final int firstReadStop = ( pair.getSecond() ? pair.getFirst() + 1 : pair.getFirst() );\n        final int numOverlappingBases = Math.min(clippedFirstRead.getReadLength() - firstReadStop, clippedSecondRead.getReadLength());\n\n        final byte[] firstReadBases = clippedFirstRead.getReadBases();\n        final byte[] firstReadQuals = clippedFirstRead.getBaseQualities();\n        final byte[] secondReadBases = clippedSecondRead.getReadBases();\n        final byte[] secondReadQuals = clippedSecondRead.getBaseQualities();\n\n        for ( int i = 0; i < numOverlappingBases; i++ ) {\n            final int firstReadIndex = firstReadStop + i;\n            final byte firstReadBase = firstReadBases[firstReadIndex];\n            final byte secondReadBase = secondReadBases[i];\n\n            if ( firstReadBase == secondReadBase ) {\n                firstReadQuals[firstReadIndex] = (byte) Math.min(firstReadQuals[firstReadIndex], HALF_OF_DEFAULT_PCR_ERROR_QUAL);\n                secondReadQuals[i] = (byte) Math.min(secondReadQuals[i], HALF_OF_DEFAULT_PCR_ERROR_QUAL);\n            } else {\n                // TODO -- use the proper statistical treatment of the quals from DiploidSNPGenotypeLikelihoods.java\n                firstReadQuals[firstReadIndex] = 0;\n                secondReadQuals[i] = 0;\n            }\n        }\n\n        clippedFirstRead.setBaseQualities(firstReadQuals);\n        clippedSecondRead.setBaseQualities(secondReadQuals);\n    }","id":42325,"modified_method":"/**\n     * Fix two overlapping reads from the same fragment by adjusting base qualities, if possible\n     *\n     * firstRead and secondRead must be part of the same fragment (though this isn't checked).  Looks\n     * at the bases and alignment, and tries its best to create adjusted base qualities so that the observations\n     * are not treated independently.\n     *\n     * Assumes that firstRead starts before secondRead (according to their soft clipped starts)\n     *\n     * @param clippedFirstRead the left most read\n     * @param clippedSecondRead the right most read\n     *\n     * @return a strandless merged read of first and second, or null if the algorithm cannot create a meaningful one\n     */\n    public static void adjustQualsOfOverlappingPairedFragments(final GATKSAMRecord clippedFirstRead, final GATKSAMRecord clippedSecondRead) {\n        if ( clippedFirstRead == null ) throw new IllegalArgumentException(\"clippedFirstRead cannot be null\");\n        if ( clippedSecondRead == null ) throw new IllegalArgumentException(\"clippedSecondRead cannot be null\");\n        if ( ! clippedFirstRead.getReadName().equals(clippedSecondRead.getReadName()) ) throw new IllegalArgumentException(\"attempting to merge two reads with different names \" + clippedFirstRead + \" and \" + clippedSecondRead);\n\n        // don't adjust fragments that do not overlap\n        if ( clippedFirstRead.getAlignmentEnd() < clippedSecondRead.getAlignmentStart() || !clippedFirstRead.getReferenceIndex().equals(clippedSecondRead.getReferenceIndex()) )\n            return;\n\n        final Pair<Integer, Boolean> pair = ReadUtils.getReadCoordinateForReferenceCoordinate(clippedFirstRead, clippedSecondRead.getAlignmentStart());\n        final int firstReadStop = ( pair.getSecond() ? pair.getFirst() + 1 : pair.getFirst() );\n        final int numOverlappingBases = Math.min(clippedFirstRead.getReadLength() - firstReadStop, clippedSecondRead.getReadLength());\n\n        final byte[] firstReadBases = clippedFirstRead.getReadBases();\n        final byte[] firstReadQuals = clippedFirstRead.getBaseQualities();\n        final byte[] secondReadBases = clippedSecondRead.getReadBases();\n        final byte[] secondReadQuals = clippedSecondRead.getBaseQualities();\n\n        for ( int i = 0; i < numOverlappingBases; i++ ) {\n            final int firstReadIndex = firstReadStop + i;\n            final byte firstReadBase = firstReadBases[firstReadIndex];\n            final byte secondReadBase = secondReadBases[i];\n\n            if ( firstReadBase == secondReadBase ) {\n                firstReadQuals[firstReadIndex] = (byte) Math.min(firstReadQuals[firstReadIndex], HALF_OF_DEFAULT_PCR_ERROR_QUAL);\n                secondReadQuals[i] = (byte) Math.min(secondReadQuals[i], HALF_OF_DEFAULT_PCR_ERROR_QUAL);\n            } else {\n                // TODO -- use the proper statistical treatment of the quals from DiploidSNPGenotypeLikelihoods.java\n                firstReadQuals[firstReadIndex] = 0;\n                secondReadQuals[i] = 0;\n            }\n        }\n\n        clippedFirstRead.setBaseQualities(firstReadQuals);\n        clippedSecondRead.setBaseQualities(secondReadQuals);\n    }","commit_id":"2911a5180c3609eebcf6656cdf86bb88d979221b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void blockReductionsForOutput(SNode inputNode, SNode outputNode) {\n      String inputNodeId = inputNode.getSNodeId().toString();\n      String outputNodeId = outputNode.getSNodeId().toString();\n      Object o = myInputReductionsData.get(inputNodeId);\n      if (o == null) return;\n      myBlockedReductionData.put(outputNodeId, o);\n    }","id":42326,"modified_method":"public void blockReductionsForOutput(SNode inputNode, SNode outputNode) {\n      SNodeId inputNodeId = inputNode.getSNodeId();\n      SNodeId outputNodeId = outputNode.getSNodeId();\n      Object o = myInputReductionsData.get(inputNodeId);\n      if (o == null) return;\n      myBlockedReductionData.put(outputNodeId, o);\n    }","commit_id":"4bd26ded0718e35670ec95fd2d675bf712c89691","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @return true if the input wasn't already blocked\n     */\n    public boolean startReductionBlockingForInput(SNode inputNode) {\n      return myBlockedInput.add(inputNode.getSNodeId().toString());\n    }","id":42327,"modified_method":"/**\n     * @return true if the input wasn't already blocked\n     */\n    public boolean startReductionBlockingForInput(SNode inputNode) {\n      return myBlockedInput.add(inputNode.getSNodeId());\n    }","commit_id":"4bd26ded0718e35670ec95fd2d675bf712c89691","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isReductionBlocked(String nodeId, Reduction_MappingRule rule, Map<String, Object> reductionBlockingData) {\n      Object o = reductionBlockingData.get(nodeId);\n      if (o == null) return false;\n      if (o == rule) return true;\n      if (o instanceof List) {\n        return ((List) o).contains(rule);\n      }\n      return false;\n    }","id":42328,"modified_method":"private boolean isReductionBlocked(SNodeId nodeId, Reduction_MappingRule rule, Map<SNodeId, Object> reductionBlockingData) {\n      Object o = reductionBlockingData.get(nodeId);\n      if (o == null) return false;\n      if (o == rule) return true;\n      if (o instanceof List) {\n        return ((List) o).contains(rule);\n      }\n      return false;\n    }","commit_id":"4bd26ded0718e35670ec95fd2d675bf712c89691","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void registerInputReduction(SNode inputNode, Reduction_MappingRule rule) {\n      String nodeId = inputNode.getSNodeId().toString();\n      Object o = myInputReductionsData.get(nodeId);\n      if (o == rule) return;\n\n      if (o == null) {\n        myInputReductionsData.put(nodeId, rule);\n      } else if (o instanceof Reduction_MappingRule) {\n        List<Reduction_MappingRule> list = new ArrayList<Reduction_MappingRule>(2);\n        list.add((Reduction_MappingRule) o);\n        list.add(rule);\n        myInputReductionsData.put(nodeId, list);\n      } else {\n        ((List) o).add(rule);\n      }\n    }","id":42329,"modified_method":"public void registerInputReduction(SNode inputNode, Reduction_MappingRule rule) {\n      SNodeId nodeId = inputNode.getSNodeId();\n      Object o = myInputReductionsData.get(nodeId);\n      if (o == rule) return;\n\n      if (o == null) {\n        myInputReductionsData.put(nodeId, rule);\n      } else if (o instanceof Reduction_MappingRule) {\n        List<Reduction_MappingRule> list = new ArrayList<Reduction_MappingRule>(2);\n        list.add((Reduction_MappingRule) o);\n        list.add(rule);\n        myInputReductionsData.put(nodeId, list);\n      } else {\n        ((List) o).add(rule);\n      }\n    }","commit_id":"4bd26ded0718e35670ec95fd2d675bf712c89691","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void stopReductionBlockingForInput(SNode inputNode) {\n      String id = inputNode.getSNodeId().toString();\n      assert myBlockedInput.contains(id) : \"input wasn't blocked\";\n      myBlockedInput.remove(id);\n    }","id":42330,"modified_method":"public void stopReductionBlockingForInput(SNode inputNode) {\n      SNodeId id = inputNode.getSNodeId();\n      assert myBlockedInput.contains(id) : \"input wasn't blocked\";\n      myBlockedInput.remove(id);\n    }","commit_id":"4bd26ded0718e35670ec95fd2d675bf712c89691","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isReductionBlocked(SNode node, Reduction_MappingRule rule) {\n      String nodeId = node.getSNodeId().toString();\n      boolean b = isReductionBlocked(nodeId, rule, myBlockedReductionData);\n      if (!b) {\n        if (myBlockedInput.contains(nodeId)) {\n          return isReductionBlocked(nodeId, rule, myInputReductionsData);\n        }\n      }\n      return b;\n    }","id":42331,"modified_method":"public boolean isReductionBlocked(SNode node, Reduction_MappingRule rule) {\n      SNodeId nodeId = node.getSNodeId();\n      boolean b = isReductionBlocked(nodeId, rule, myBlockedReductionData);\n      if (!b) {\n        if (myBlockedInput.contains(nodeId)) {\n          return isReductionBlocked(nodeId, rule, myInputReductionsData);\n        }\n      }\n      return b;\n    }","commit_id":"4bd26ded0718e35670ec95fd2d675bf712c89691","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode cloneInt(SNode node, SModel outputModel, IScope scope, boolean keepOldId) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    if (keepOldId) {\n      result.setId(node.getSNodeId());\n    }\n    result.putProperties(node);\n    for (SReference reference : node.getReferences()) {\n      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n      if (targetModelUID == null) {\n        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n      } else {\n        result.addReference(SReference.create(reference.getRole(),\n                result,\n                targetModelUID,\n                SNodeId.fromString(reference.getTargetNodeId()),\n                reference.getResolveInfo()));\n      }\n    }\n    for (SNode child : node.getChildren()) {\n      String role = child.getRole_();\n      assert role != null;\n      result.addChild(role, clone(child, outputModel, scope));\n    }\n    return result;\n  }","id":42332,"modified_method":"private static SNode cloneInt(SNode node, SModel outputModel, IScope scope, boolean keepOldId) {\n    SNode result = SModelUtil_new.instantiateConceptDeclaration(node.getConceptFqName(), outputModel, scope, false);\n    assert result != null;\n    if (keepOldId) {\n      result.setId(node.getSNodeId());\n    }\n    result.putProperties(node);\n    for (SReference reference : node.getReferences()) {\n      SModelUID targetModelUID = reference.isExternal() ? reference.getTargetModelUID() : outputModel.getUID();\n      if (targetModelUID == null) {\n        LOG.warning(\"broken reference '\" + reference.getRole() + \"' in \" + node.getDebugText(), node);\n      } else {\n        result.addReference(SReference.create(reference.getRole(),\n                result,\n                targetModelUID,\n                reference.getTargetNodeId(),\n                reference.getResolveInfo()));\n      }\n    }\n    for (SNode child : node.getChildren()) {\n      String role = child.getRole_();\n      assert role != null;\n      result.addChild(role, clone(child, outputModel, scope));\n    }\n    return result;\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void fireReferenceTargetReadAccessed(SReference reference) {\n    if (myEventsBlocked) return;\n    if(!reference.getSourceNode().isRegistered()) return;\n    if(reference.getTargetNodeId() == null) return; // tmp: old refs to java_stub has no id\n    if (ourReadAccessListener != null) ourReadAccessListener.addRefTargetToDependOn(new SNodePointer(reference.getTargetModelUID().toString(), reference.getTargetNodeId()));\n  }","id":42333,"modified_method":"public static void fireReferenceTargetReadAccessed(SReference reference) {\n    if (myEventsBlocked) return;\n    if(!reference.getSourceNode().isRegistered()) return;\n    if(reference.getTargetNodeId() == null) return; // tmp: old refs to java_stub has no id\n    if (ourReadAccessListener != null) ourReadAccessListener.addRefTargetToDependOn(new SNodePointer(reference.getTargetModelUID(), reference.getTargetNodeId()));\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void saveReference(Element parentElement, SReference reference, boolean useUIDs, VisibleModelElements visibleModelElements) {\n    assert useUIDs || visibleModelElements != null;\n    SNode node = reference.getSourceNode();\n    Element linkElement = new Element(ModelPersistence.LINK);\n    parentElement.addContent(linkElement);\n    linkElement.setAttribute(ModelPersistence.ROLE, reference.getRole());\n\n    if (reference.isExternal()) {//external reference\n      SModelUID targetModelUID = reference.getTargetModelUID();\n      String targetModelInfo = \"\";\n      if (!useUIDs) {\n        SModel.ImportElement importElement = node.getModel().getImportElement(targetModelUID);\n        if (importElement != null) {\n          int importIndex = importElement.getReferenceID();\n          targetModelInfo = importIndex + \".\";\n        } else {\n          int visibleIndex = visibleModelElements.getVisibleModelIndex(targetModelUID);\n          targetModelInfo = visibleIndex + \"v.\";\n        }\n      } else {\n        targetModelInfo = targetModelUID.toString() + \"#\";\n      }\n      linkElement.setAttribute(ModelPersistence.TARGET_NODE_ID, targetModelInfo + reference.getTargetNodeId());\n      String resolveInfo = reference.getResolveInfo();\n      if (resolveInfo != null) linkElement.setAttribute(ModelPersistence.RESOLVE_INFO, resolveInfo);\n\n    } else {//internal reference\n      String targetNodeId = reference.getTargetNodeId();\n      if (targetNodeId != null) linkElement.setAttribute(ModelPersistence.TARGET_NODE_ID, targetNodeId);\n      String resolveInfo = reference.getResolveInfo();\n      if (resolveInfo != null) linkElement.setAttribute(ModelPersistence.RESOLVE_INFO, resolveInfo);\n    }\n  }","id":42334,"modified_method":"public static void saveReference(Element parentElement, SReference reference, boolean useUIDs, VisibleModelElements visibleModelElements) {\n    assert useUIDs || visibleModelElements != null;\n    SNode node = reference.getSourceNode();\n    Element linkElement = new Element(ModelPersistence.LINK);\n    parentElement.addContent(linkElement);\n    linkElement.setAttribute(ModelPersistence.ROLE, reference.getRole());\n\n    if (reference.isExternal()) {//external reference\n      SModelUID targetModelUID = reference.getTargetModelUID();\n      String targetModelInfo = \"\";\n      if (!useUIDs) {\n        SModel.ImportElement importElement = node.getModel().getImportElement(targetModelUID);\n        if (importElement != null) {\n          int importIndex = importElement.getReferenceID();\n          targetModelInfo = importIndex + \".\";\n        } else {\n          int visibleIndex = visibleModelElements.getVisibleModelIndex(targetModelUID);\n          targetModelInfo = visibleIndex + \"v.\";\n        }\n      } else {\n        targetModelInfo = targetModelUID.toString() + \"#\";\n      }\n      linkElement.setAttribute(ModelPersistence.TARGET_NODE_ID, targetModelInfo + reference.getTargetNodeId());\n      String resolveInfo = reference.getResolveInfo();\n      if (resolveInfo != null) linkElement.setAttribute(ModelPersistence.RESOLVE_INFO, resolveInfo);\n\n    } else {//internal reference\n      SNodeId targetNodeId = reference.getTargetNodeId();\n      if (targetNodeId != null) linkElement.setAttribute(ModelPersistence.TARGET_NODE_ID, targetNodeId.toString());\n      String resolveInfo = reference.getResolveInfo();\n      if (resolveInfo != null) linkElement.setAttribute(ModelPersistence.RESOLVE_INFO, resolveInfo);\n    }\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * todo: remove. It makes no sence for dynamic references\n   */\n  public abstract String getTargetNodeId();","id":42335,"modified_method":"/**\n   * todo: remove. It makes no sence for dynamic references\n   */\n  public abstract SNodeId getTargetNodeId();","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * todo: remove. It makes no sence for dynamic references\n   */\n  public abstract void setTargetNodeId(String targetNodeId);","id":42336,"modified_method":"/**\n   * todo: remove. It makes no sence for dynamic references\n   */\n  public abstract void setTargetNodeId(SNodeId targetNodeId);","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"StaticReference(String role, SNode sourceNode, SModelUID modelUID, SNodeId nodeId, String resolveInfo) {\n    // 'mature' reference\n    super(role, sourceNode, modelUID, nodeId.toString());\n    setResolveInfo(resolveInfo);\n    myMature = true;\n  }","id":42337,"modified_method":"StaticReference(String role, SNode sourceNode, SModelUID modelUID, SNodeId nodeId, String resolveInfo) {\n    // 'mature' reference\n    super(role, sourceNode, modelUID, nodeId);\n    setResolveInfo(resolveInfo);\n    myMature = true;\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getTargetNodeId() {\n    if (mature()) {\n      return super.getTargetNodeId();\n    } else if (myTargetNode != null) {\n      return myTargetNode.getSNodeId().toString();\n    }\n    return null;\n  }","id":42338,"modified_method":"public SNodeId getTargetNodeId() {\n    if (mature()) {\n      return super.getTargetNodeId();\n    } else if (myTargetNode != null) {\n      return myTargetNode.getSNodeId();\n    }\n    return null;\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setTargetNodeId(String nodeId) {\n    if (!mature()) makeMature();\n    super.setTargetNodeId(nodeId);\n  }","id":42339,"modified_method":"public void setTargetNodeId(SNodeId nodeId) {\n    if (!mature()) makeMature();\n    super.setTargetNodeId(nodeId);\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void makeMature() {\n    SNode targetNode = myTargetNode;\n    myMature = true;\n    myTargetNode = null;\n    setTargetModelUID(targetNode.getModel().getUID());\n    setTargetNodeId(targetNode.getSNodeId().toString());\n    setResolveInfo(targetNode.getName());\n  }","id":42340,"modified_method":"private void makeMature() {\n    SNode targetNode = myTargetNode;\n    myMature = true;\n    myTargetNode = null;\n    setTargetModelUID(targetNode.getModel().getUID());\n    setTargetNodeId(targetNode.getSNodeId());\n    setResolveInfo(targetNode.getName());\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getTargetNode_impl() {\n    if (mature()) {\n      SModel targetModel = getTargetModel();\n      if (targetModel == null) {\n        SReference.error(this, GetTargetNodeErrorState.NO_MODEL);\n        return null;\n      }\n      SNode node = targetModel.getNodeById(getTargetNodeId());\n      if (node == null) {\n        node = UnregisteredNodes.instance().get(getTargetModelUID(), getTargetNodeId());\n        if (node == null) {\n          SReference.error(this, GetTargetNodeErrorState.CANT_RESOLVE_BY_ID);\n        }\n      }\n      return node;\n    }\n\n    return myTargetNode;\n  }","id":42341,"modified_method":"public SNode getTargetNode_impl() {\n    if (mature()) {\n      SModel targetModel = getTargetModel();\n      if (targetModel == null) {\n        SReference.error(this, GetTargetNodeErrorState.NO_MODEL);\n        return null;\n      }\n      SNode node = targetModel.getNodeById(getTargetNodeId());\n      if (node == null) {\n        node = UnregisteredNodes.instance().get(getTargetModelUID(), getTargetNodeId().toString());\n        if (node == null) {\n          SReference.error(this, GetTargetNodeErrorState.CANT_RESOLVE_BY_ID);\n        }\n      }\n      return node;\n    }\n\n    return myTargetNode;\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected StaticReferenceBase(String role, SNode sourceNode, SModelUID targetModelUID, String targetNodeId) {\n    super(role, sourceNode);\n    myTargetNodeId = InternUtil.intern(targetNodeId);\n    if (sourceNode.getModel().getUID().equals(targetModelUID)) {\n      myLocal = true;\n    } else {\n      myTargetModelUID = targetModelUID;\n    }\n  }","id":42342,"modified_method":"protected StaticReferenceBase(String role, SNode sourceNode, SModelUID targetModelUID, SNodeId targetNodeId) {\n    super(role, sourceNode);\n    myTargetNodeId = targetNodeId;\n    if (sourceNode.getModel().getUID().equals(targetModelUID)) {\n      myLocal = true;\n    } else {\n      myTargetModelUID = targetModelUID;\n    }\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getTargetNodeId() {\n    return myTargetNodeId;\n  }","id":42343,"modified_method":"public SNodeId getTargetNodeId() {\n    return myTargetNodeId;\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setTargetNodeId(String nodeId) {\n    myTargetNodeId = InternUtil.intern(nodeId);\n  }","id":42344,"modified_method":"public void setTargetNodeId(SNodeId nodeId) {\n    myTargetNodeId = nodeId;\n  }","commit_id":"2c0da73a96b598218c8878247fb7cc3972c6dd8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void testUnsignedId()\n    {\n        try\n        {\n            PropertyKeyTokenRecordFormat recordFormat = new PropertyKeyTokenRecordFormat();\n            IdGeneratorImpl.createGenerator( fs, idGeneratorFile(), 0, false );\n            IdGenerator idGenerator = new IdGeneratorImpl( fs, idGeneratorFile(), 1,\n                    recordFormat.getMaxId(), false, 0 );\n            idGenerator.setHighId( recordFormat.getMaxId() - 1 );\n            long id = idGenerator.nextId();\n            assertEquals( recordFormat.getMaxId() - 1, id );\n            idGenerator.freeId( id );\n            try\n            {\n                idGenerator.nextId();\n                fail( \"Shouldn't be able to get next ID\" );\n            }\n            catch ( StoreFailureException e )\n            { // good, capacity exceeded\n            }\n            closeIdGenerator( idGenerator );\n            idGenerator = new IdGeneratorImpl( fs, idGeneratorFile(), 1, recordFormat.getMaxId(), false, 0 );\n            assertEquals( recordFormat.getMaxId() + 1, idGenerator.getHighId() );\n            id = idGenerator.nextId();\n            assertEquals( recordFormat.getMaxId() - 1, id );\n            try\n            {\n                idGenerator.nextId();\n            }\n            catch ( StoreFailureException e )\n            { // good, capacity exceeded\n            }\n            closeIdGenerator( idGenerator );\n        }\n        finally\n        {\n            File file = idGeneratorFile();\n            if ( file.exists() )\n            {\n                assertTrue( file.delete() );\n            }\n        }\n    }","id":42345,"modified_method":"@Test\n    public void testUnsignedId()\n    {\n        try\n        {\n            PropertyKeyTokenRecordFormat recordFormat = new PropertyKeyTokenRecordFormat();\n            IdGeneratorImpl.createGenerator( fs, idGeneratorFile(), 0, false );\n            IdGenerator idGenerator = new IdGeneratorImpl( fs, idGeneratorFile(), 1,\n                    recordFormat.getMaxId(), false, 0 );\n            idGenerator.setHighId( recordFormat.getMaxId() );\n            long id = idGenerator.nextId();\n            assertEquals( recordFormat.getMaxId(), id );\n            idGenerator.freeId( id );\n            try\n            {\n                idGenerator.nextId();\n                fail( \"Shouldn't be able to get next ID\" );\n            }\n            catch ( StoreFailureException e )\n            { // good, capacity exceeded\n            }\n            closeIdGenerator( idGenerator );\n            idGenerator = new IdGeneratorImpl( fs, idGeneratorFile(), 1, recordFormat.getMaxId(), false, 0 );\n            assertEquals( recordFormat.getMaxId() + 1, idGenerator.getHighId() );\n            id = idGenerator.nextId();\n            assertEquals( recordFormat.getMaxId(), id );\n            try\n            {\n                idGenerator.nextId();\n            }\n            catch ( StoreFailureException e )\n            { // good, capacity exceeded\n            }\n            closeIdGenerator( idGenerator );\n        }\n        finally\n        {\n            File file = idGeneratorFile();\n            if ( file.exists() )\n            {\n                assertTrue( file.delete() );\n            }\n        }\n    }","commit_id":"23c75c53c92fb41b8d83000985a6900ace353398","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void initMaxTokenKeyIds( RecordFormats recordFormats )\n    {\n        maxKeyId[PROPERTY_KEY_TOKEN] = recordFormats.propertyKeyToken().getMaxId();\n        maxKeyId[LABEL_TOKEN] = recordFormats.labelToken().getMaxId();\n        maxKeyId[RELATIONSHIP_TYPE_TOKEN] = recordFormats.relationshipTypeToken().getMaxId();\n        maxKeyId[GROUP_TOKEN] = recordFormats.relationshipGroup().getMaxId();\n    }","id":42346,"modified_method":"private void initMaxTokenKeyIds( RecordFormats recordFormats )\n    {\n        maxKeyId[PROPERTY_KEY_TOKEN] = getMaxAcceptableTokenId( recordFormats.propertyKeyToken().getMaxId() );\n        maxKeyId[LABEL_TOKEN] = getMaxAcceptableTokenId( recordFormats.labelToken().getMaxId() );\n        maxKeyId[RELATIONSHIP_TYPE_TOKEN] = getMaxAcceptableTokenId( recordFormats.relationshipTypeToken().getMaxId() );\n        maxKeyId[GROUP_TOKEN] = getMaxAcceptableTokenId( recordFormats.relationshipGroup().getMaxId() );\n    }","commit_id":"23c75c53c92fb41b8d83000985a6900ace353398","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void encodeValue( PropertyBlock block, int keyId, Object value,\n            DynamicRecordAllocator stringAllocator, DynamicRecordAllocator arrayAllocator )\n    {\n        if ( value instanceof String )\n        {   // Try short string first, i.e. inlined in the property block\n            String string = (String) value;\n            if ( LongerShortString.encode( keyId, string, block, PropertyType.getPayloadSize() ) )\n            {\n                return;\n            }\n\n            // Fall back to dynamic string store\n            byte[] encodedString = encodeString( string );\n            List<DynamicRecord> valueRecords = new ArrayList<>();\n            allocateStringRecords( valueRecords, encodedString, stringAllocator );\n            setSingleBlockValue( block, keyId, PropertyType.STRING, Iterables.first( valueRecords ).getId() );\n            for ( DynamicRecord valueRecord : valueRecords )\n            {\n                valueRecord.setType( PropertyType.STRING.intValue() );\n            }\n            block.setValueRecords( valueRecords );\n        }\n        else if ( value instanceof Integer )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.INT, ((Integer) value).longValue() );\n        }\n        else if ( value instanceof Boolean )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.BOOL, ((Boolean) value ? 1L : 0L) );\n        }\n        else if ( value instanceof Float )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.FLOAT, Float.floatToRawIntBits( (Float) value ) );\n        }\n        else if ( value instanceof Long )\n        {\n            long keyAndType = keyId | (((long) PropertyType.LONG.intValue()) << 24);\n            if ( ShortArray.LONG.getRequiredBits( (Long) value ) <= 35 )\n            {   // We only need one block for this value, special layout compared to, say, an integer\n                block.setSingleBlock( keyAndType | (1L << 28) | ((Long) value << 29) );\n            }\n            else\n            {   // We need two blocks for this value\n                block.setValueBlocks( new long[]{keyAndType, (Long) value} );\n            }\n        }\n        else if ( value instanceof Double )\n        {\n            block.setValueBlocks( new long[]{\n                    keyId | (((long) PropertyType.DOUBLE.intValue()) << 24),\n                    Double.doubleToRawLongBits( (Double) value )} );\n        }\n        else if ( value instanceof Byte )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.BYTE, ((Byte) value).longValue() );\n        }\n        else if ( value instanceof Character )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.CHAR, (Character) value );\n        }\n        else if ( value instanceof Short )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.SHORT, ((Short) value).longValue() );\n        }\n        else if ( value.getClass().isArray() )\n        {   // Try short array first, i.e. inlined in the property block\n            if ( ShortArray.encode( keyId, value, block, PropertyType.getPayloadSize() ) )\n            {\n                return;\n            }\n\n            // Fall back to dynamic array store\n            List<DynamicRecord> arrayRecords = new ArrayList<>();\n            allocateArrayRecords( arrayRecords, value, arrayAllocator );\n            setSingleBlockValue( block, keyId, PropertyType.ARRAY, Iterables.first( arrayRecords ).getId() );\n            for ( DynamicRecord valueRecord : arrayRecords )\n            {\n                valueRecord.setType( PropertyType.ARRAY.intValue() );\n            }\n            block.setValueRecords( arrayRecords );\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Unknown property type on: \" + value + \", \" + value.getClass() );\n        }\n    }","id":42347,"modified_method":"public static void encodeValue( PropertyBlock block, int keyId, Object value,\n            DynamicRecordAllocator stringAllocator, DynamicRecordAllocator arrayAllocator )\n    {\n        if ( value instanceof String )\n        {   // Try short string first, i.e. inlined in the property block\n            String string = (String) value;\n            if ( LongerShortString.encode( keyId, string, block, PropertyType.getPayloadSize() ) )\n            {\n                return;\n            }\n\n            // Fall back to dynamic string store\n            byte[] encodedString = encodeString( string );\n            List<DynamicRecord> valueRecords = new ArrayList<>();\n            allocateStringRecords( valueRecords, encodedString, stringAllocator );\n            setSingleBlockValue( block, keyId, PropertyType.STRING, Iterables.first( valueRecords ).getId() );\n            for ( DynamicRecord valueRecord : valueRecords )\n            {\n                valueRecord.setType( PropertyType.STRING.intValue() );\n            }\n            block.setValueRecords( valueRecords );\n        }\n        else if ( value instanceof Integer )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.INT, ((Integer) value).longValue() );\n        }\n        else if ( value instanceof Boolean )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.BOOL, ((Boolean) value ? 1L : 0L) );\n        }\n        else if ( value instanceof Float )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.FLOAT, Float.floatToRawIntBits( (Float) value ) );\n        }\n        else if ( value instanceof Long )\n        {\n\n            long keyAndType = keyId | (((long) PropertyType.LONG.intValue()) <<\n                                       StandardFormatSettings.PROPERTY_TOKEN_MAXIMUM_ID_BITS);\n            if ( ShortArray.LONG.getRequiredBits( (Long) value ) <= 35 )\n            {   // We only need one block for this value, special layout compared to, say, an integer\n                block.setSingleBlock( keyAndType | (1L << 28) | ((Long) value << 29) );\n            }\n            else\n            {   // We need two blocks for this value\n                block.setValueBlocks( new long[]{keyAndType, (Long) value} );\n            }\n        }\n        else if ( value instanceof Double )\n        {\n            block.setValueBlocks( new long[]{ keyId |\n                    (((long) PropertyType.DOUBLE.intValue()) << StandardFormatSettings.PROPERTY_TOKEN_MAXIMUM_ID_BITS),\n                    Double.doubleToRawLongBits( (Double) value )} );\n        }\n        else if ( value instanceof Byte )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.BYTE, ((Byte) value).longValue() );\n        }\n        else if ( value instanceof Character )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.CHAR, (Character) value );\n        }\n        else if ( value instanceof Short )\n        {\n            setSingleBlockValue( block, keyId, PropertyType.SHORT, ((Short) value).longValue() );\n        }\n        else if ( value.getClass().isArray() )\n        {   // Try short array first, i.e. inlined in the property block\n            if ( ShortArray.encode( keyId, value, block, PropertyType.getPayloadSize() ) )\n            {\n                return;\n            }\n\n            // Fall back to dynamic array store\n            List<DynamicRecord> arrayRecords = new ArrayList<>();\n            allocateArrayRecords( arrayRecords, value, arrayAllocator );\n            setSingleBlockValue( block, keyId, PropertyType.ARRAY, Iterables.first( arrayRecords ).getId() );\n            for ( DynamicRecord valueRecord : arrayRecords )\n            {\n                valueRecord.setType( PropertyType.ARRAY.intValue() );\n            }\n            block.setValueRecords( arrayRecords );\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Unknown property type on: \" + value + \", \" + value.getClass() );\n        }\n    }","commit_id":"23c75c53c92fb41b8d83000985a6900ace353398","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static long singleBlockLongValue( int keyId, PropertyType type, long longValue )\n    {\n        return keyId | (((long) type.intValue()) << 24) | (longValue << 28);\n    }","id":42348,"modified_method":"public static long singleBlockLongValue( int keyId, PropertyType type, long longValue )\n    {\n        return keyId | (((long) type.intValue()) << StandardFormatSettings.PROPERTY_TOKEN_MAXIMUM_ID_BITS) | (longValue << 28);\n    }","commit_id":"23c75c53c92fb41b8d83000985a6900ace353398","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void execute() throws MojoExecutionException\n    {\n        String projectType = project.getPackaging();\n\n        // ignore unsupported project types, useful when bundleplugin is configured in parent pom\n        if ( !supportedProjectTypes.contains( projectType ) )\n        {\n            getLog().warn( \"Ignoring project type \" + projectType +\n                           \" - supportedProjectTypes = \" + supportedProjectTypes );\n            return;\n        }\n        else if ( \"NONE\".equalsIgnoreCase( remoteOBR ) || \"false\".equalsIgnoreCase( remoteOBR ) )\n        {\n            getLog().info( \"Remote OBR update disabled (enable with -DremoteOBR)\" );\n            return;\n        }\n\n        // check for any attached sources or docs\n        for ( Iterator i = attachedArtifacts.iterator(); i.hasNext(); )\n        {\n            Artifact artifact = ( Artifact ) i.next();\n            if ( \"sources\".equals( artifact.getClassifier() ) )\n            {\n                m_sourceArtifact = artifact;\n            }\n            else if ( \"javadoc\".equals( artifact.getClassifier() ) )\n            {\n                m_docArtifact = artifact;\n            }\n        }\n\n        // if the user doesn't supply an explicit name for the remote OBR file, use the local name instead\n        if ( null == remoteOBR || remoteOBR.trim().length() == 0 || \"true\".equalsIgnoreCase( remoteOBR ) )\n        {\n            remoteOBR = obrRepository;\n        }\n\n        URI tempURI = ObrUtils.findRepositoryXml( \"\", remoteOBR );\n        String repositoryPath = tempURI.isOpaque() ? tempURI.getSchemeSpecificPart() : tempURI.getPath();\n        String repositoryName = new File( repositoryPath ).getName();\n\n        Log log = getLog();\n        ObrUpdate update;\n\n        RemoteFileManager remoteFile = new RemoteFileManager( m_wagonManager, settings, log );\n        openRepositoryConnection( remoteFile );\n\n        // ======== LOCK REMOTE OBR ========\n        log.info( \"LOCK \" + remoteFile + '/' + repositoryName );\n        remoteFile.lockFile( repositoryName, ignoreLock );\n        File downloadedRepositoryXml = null;\n\n        try\n        {\n            // ======== DOWNLOAD REMOTE OBR ========\n            log.info( \"Downloading \" + repositoryName );\n            downloadedRepositoryXml = remoteFile.get( repositoryName, \".xml\" );\n\n            String mavenRepository = localRepository.getBasedir();\n\n            URI repositoryXml = downloadedRepositoryXml.toURI();\n            URI obrXmlFile = ObrUtils.findObrXml( project.getResources() );\n\n            Config userConfig = new Config();\n            userConfig.setRemoteFile( true );\n\n            update = new ObrUpdate( repositoryXml, obrXmlFile, project, mavenRepository, userConfig, log );\n            update.parseRepositoryXml();\n\n            updateRemoteBundleMetadata( project.getArtifact(), update );\n            for ( Iterator i = attachedArtifacts.iterator(); i.hasNext(); )\n            {\n                updateRemoteBundleMetadata( ( Artifact ) i.next(), update );\n            }\n\n            update.writeRepositoryXml();\n\n            if ( downloadedRepositoryXml.exists() )\n            {\n                // ======== UPLOAD MODIFIED OBR ========\n                log.info( \"Uploading \" + repositoryName );\n                remoteFile.put( downloadedRepositoryXml, repositoryName );\n            }\n        }\n        catch ( Exception e )\n        {\n            log.warn( \"Exception while updating remote OBR: \" + e.getLocalizedMessage(), e );\n        }\n        finally\n        {\n            // ======== UNLOCK REMOTE OBR ========\n            log.info( \"UNLOCK \" + remoteFile + '/' + repositoryName );\n            remoteFile.unlockFile( repositoryName );\n            remoteFile.disconnect();\n\n            if ( null != downloadedRepositoryXml )\n            {\n                downloadedRepositoryXml.delete();\n            }\n        }\n    }","id":42349,"modified_method":"public void execute() throws MojoExecutionException\n    {\n        String projectType = project.getPackaging();\n\n        // ignore unsupported project types, useful when bundleplugin is configured in parent pom\n        if ( !supportedProjectTypes.contains( projectType ) )\n        {\n            getLog().warn( \"Ignoring project type \" + projectType +\n                           \" - supportedProjectTypes = \" + supportedProjectTypes );\n            return;\n        }\n        else if ( \"NONE\".equalsIgnoreCase( remoteOBR ) || \"false\".equalsIgnoreCase( remoteOBR ) )\n        {\n            getLog().info( \"Remote OBR update disabled (enable with -DremoteOBR)\" );\n            return;\n        }\n\n        // check for any attached sources or docs\n        for ( Iterator i = attachedArtifacts.iterator(); i.hasNext(); )\n        {\n            Artifact artifact = ( Artifact ) i.next();\n            if ( \"sources\".equals( artifact.getClassifier() ) )\n            {\n                m_sourceArtifact = artifact;\n            }\n            else if ( \"javadoc\".equals( artifact.getClassifier() ) )\n            {\n                m_docArtifact = artifact;\n            }\n        }\n\n        // if the user doesn't supply an explicit name for the remote OBR file, use the local name instead\n        if ( null == remoteOBR || remoteOBR.trim().length() == 0 || \"true\".equalsIgnoreCase( remoteOBR ) )\n        {\n            remoteOBR = obrRepository;\n        }\n\n        URI tempURI = ObrUtils.findRepositoryXml( \"\", remoteOBR );\n        String repositoryName = new File( tempURI.getSchemeSpecificPart() ).getName();\n\n        Log log = getLog();\n        ObrUpdate update;\n\n        RemoteFileManager remoteFile = new RemoteFileManager( m_wagonManager, settings, log );\n        openRepositoryConnection( remoteFile );\n\n        // ======== LOCK REMOTE OBR ========\n        log.info( \"LOCK \" + remoteFile + '/' + repositoryName );\n        remoteFile.lockFile( repositoryName, ignoreLock );\n        File downloadedRepositoryXml = null;\n\n        try\n        {\n            // ======== DOWNLOAD REMOTE OBR ========\n            log.info( \"Downloading \" + repositoryName );\n            downloadedRepositoryXml = remoteFile.get( repositoryName, \".xml\" );\n\n            String mavenRepository = localRepository.getBasedir();\n\n            URI repositoryXml = downloadedRepositoryXml.toURI();\n            URI obrXmlFile = ObrUtils.findObrXml( project.getResources() );\n\n            Config userConfig = new Config();\n            userConfig.setRemoteFile( true );\n\n            update = new ObrUpdate( repositoryXml, obrXmlFile, project, mavenRepository, userConfig, log );\n            update.parseRepositoryXml();\n\n            updateRemoteBundleMetadata( project.getArtifact(), update );\n            for ( Iterator i = attachedArtifacts.iterator(); i.hasNext(); )\n            {\n                updateRemoteBundleMetadata( ( Artifact ) i.next(), update );\n            }\n\n            update.writeRepositoryXml();\n\n            if ( downloadedRepositoryXml.exists() )\n            {\n                // ======== UPLOAD MODIFIED OBR ========\n                log.info( \"Uploading \" + repositoryName );\n                remoteFile.put( downloadedRepositoryXml, repositoryName );\n            }\n        }\n        catch ( Exception e )\n        {\n            log.warn( \"Exception while updating remote OBR: \" + e.getLocalizedMessage(), e );\n        }\n        finally\n        {\n            // ======== UNLOCK REMOTE OBR ========\n            log.info( \"UNLOCK \" + remoteFile + '/' + repositoryName );\n            remoteFile.unlockFile( repositoryName );\n            remoteFile.disconnect();\n\n            if ( null != downloadedRepositoryXml )\n            {\n                downloadedRepositoryXml.delete();\n            }\n        }\n    }","commit_id":"435f3907cf86984dab8969c717bf309e3a364c22","url":"https://github.com/apache/felix"},{"original_method":"public void execute() throws MojoExecutionException\n    {\n        MavenProject project = getProject();\n        String projectType = project.getPackaging();\n\n        // ignore unsupported project types, useful when bundleplugin is configured in parent pom\n        if ( !supportedProjectTypes.contains( projectType ) )\n        {\n            getLog().warn( \"Ignoring project type \" + projectType +\n                           \" - supportedProjectTypes = \" + supportedProjectTypes );\n            return;\n        }\n        else if ( \"NONE\".equalsIgnoreCase( remoteOBR ) || \"false\".equalsIgnoreCase( remoteOBR ) )\n        {\n            getLog().info( \"Remote OBR update disabled (enable with -DremoteOBR)\" );\n            return;\n        }\n\n        // if the user doesn't supply an explicit name for the remote OBR file, use the local name instead\n        if ( null == remoteOBR || remoteOBR.trim().length() == 0 || \"true\".equalsIgnoreCase( remoteOBR ) )\n        {\n            remoteOBR = obrRepository;\n        }\n\n        URI tempURI = ObrUtils.findRepositoryXml( \"\", remoteOBR );\n        String repositoryPath = tempURI.isOpaque() ? tempURI.getSchemeSpecificPart() : tempURI.getPath();\n        String repositoryName = new File( repositoryPath ).getName();\n\n        Log log = getLog();\n        ObrUpdate update;\n\n        RemoteFileManager remoteFile = new RemoteFileManager( m_wagonManager, settings, log );\n        remoteFile.connect( repositoryId, url );\n\n        // ======== LOCK REMOTE OBR ========\n        log.info( \"LOCK \" + remoteFile + '/' + repositoryName );\n        remoteFile.lockFile( repositoryName, ignoreLock );\n        File downloadedRepositoryXml = null;\n\n        try\n        {\n            // ======== DOWNLOAD REMOTE OBR ========\n            log.info( \"Downloading \" + repositoryName );\n            downloadedRepositoryXml = remoteFile.get( repositoryName, \".xml\" );\n\n            String mavenRepository = localRepository.getBasedir();\n\n            URI repositoryXml = downloadedRepositoryXml.toURI();\n            URI obrXmlFile = ObrUtils.toFileURI( obrXml );\n            URI bundleJar;\n\n            if ( null == file )\n            {\n                bundleJar = ObrUtils.getArtifactURI( localRepository, project.getArtifact() );\n            }\n            else\n            {\n                bundleJar = file.toURI();\n            }\n\n            Config userConfig = new Config();\n            userConfig.setRemoteFile( true );\n\n            if ( null != bundleUrl )\n            {\n                // public URL differs from the bundle file location\n                userConfig.setRemoteBundle( URI.create( bundleUrl ) );\n            }\n            else if ( null != file )\n            {\n                // assume file will be deployed in remote repository, so find the remote relative location\n                userConfig.setRemoteBundle( URI.create( localRepository.pathOf( project.getArtifact() ) ) );\n            }\n\n            update = new ObrUpdate( repositoryXml, obrXmlFile, project, mavenRepository, userConfig, log );\n            update.parseRepositoryXml();\n\n            update.updateRepository( bundleJar, null, null );\n\n            update.writeRepositoryXml();\n\n            if ( downloadedRepositoryXml.exists() )\n            {\n                // ======== UPLOAD MODIFIED OBR ========\n                log.info( \"Uploading \" + repositoryName );\n                remoteFile.put( downloadedRepositoryXml, repositoryName );\n            }\n        }\n        catch ( Exception e )\n        {\n            log.warn( \"Exception while updating remote OBR: \" + e.getLocalizedMessage(), e );\n        }\n        finally\n        {\n            // ======== UNLOCK REMOTE OBR ========\n            log.info( \"UNLOCK \" + remoteFile + '/' + repositoryName );\n            remoteFile.unlockFile( repositoryName );\n            remoteFile.disconnect();\n\n            if ( null != downloadedRepositoryXml )\n            {\n                downloadedRepositoryXml.delete();\n            }\n        }\n    }","id":42350,"modified_method":"public void execute() throws MojoExecutionException\n    {\n        MavenProject project = getProject();\n        String projectType = project.getPackaging();\n\n        // ignore unsupported project types, useful when bundleplugin is configured in parent pom\n        if ( !supportedProjectTypes.contains( projectType ) )\n        {\n            getLog().warn( \"Ignoring project type \" + projectType +\n                           \" - supportedProjectTypes = \" + supportedProjectTypes );\n            return;\n        }\n        else if ( \"NONE\".equalsIgnoreCase( remoteOBR ) || \"false\".equalsIgnoreCase( remoteOBR ) )\n        {\n            getLog().info( \"Remote OBR update disabled (enable with -DremoteOBR)\" );\n            return;\n        }\n\n        // if the user doesn't supply an explicit name for the remote OBR file, use the local name instead\n        if ( null == remoteOBR || remoteOBR.trim().length() == 0 || \"true\".equalsIgnoreCase( remoteOBR ) )\n        {\n            remoteOBR = obrRepository;\n        }\n\n        URI tempURI = ObrUtils.findRepositoryXml( \"\", remoteOBR );\n        String repositoryName = new File( tempURI.getSchemeSpecificPart() ).getName();\n\n        Log log = getLog();\n        ObrUpdate update;\n\n        RemoteFileManager remoteFile = new RemoteFileManager( m_wagonManager, settings, log );\n        remoteFile.connect( repositoryId, url );\n\n        // ======== LOCK REMOTE OBR ========\n        log.info( \"LOCK \" + remoteFile + '/' + repositoryName );\n        remoteFile.lockFile( repositoryName, ignoreLock );\n        File downloadedRepositoryXml = null;\n\n        try\n        {\n            // ======== DOWNLOAD REMOTE OBR ========\n            log.info( \"Downloading \" + repositoryName );\n            downloadedRepositoryXml = remoteFile.get( repositoryName, \".xml\" );\n\n            String mavenRepository = localRepository.getBasedir();\n\n            URI repositoryXml = downloadedRepositoryXml.toURI();\n            URI obrXmlFile = ObrUtils.toFileURI( obrXml );\n            URI bundleJar;\n\n            if ( null == file )\n            {\n                bundleJar = ObrUtils.getArtifactURI( localRepository, project.getArtifact() );\n            }\n            else\n            {\n                bundleJar = file.toURI();\n            }\n\n            Config userConfig = new Config();\n            userConfig.setRemoteFile( true );\n\n            if ( null != bundleUrl )\n            {\n                // public URL differs from the bundle file location\n                userConfig.setRemoteBundle( URI.create( bundleUrl ) );\n            }\n            else if ( null != file )\n            {\n                // assume file will be deployed in remote repository, so find the remote relative location\n                userConfig.setRemoteBundle( URI.create( localRepository.pathOf( project.getArtifact() ) ) );\n            }\n\n            update = new ObrUpdate( repositoryXml, obrXmlFile, project, mavenRepository, userConfig, log );\n            update.parseRepositoryXml();\n\n            update.updateRepository( bundleJar, null, null );\n\n            update.writeRepositoryXml();\n\n            if ( downloadedRepositoryXml.exists() )\n            {\n                // ======== UPLOAD MODIFIED OBR ========\n                log.info( \"Uploading \" + repositoryName );\n                remoteFile.put( downloadedRepositoryXml, repositoryName );\n            }\n        }\n        catch ( Exception e )\n        {\n            log.warn( \"Exception while updating remote OBR: \" + e.getLocalizedMessage(), e );\n        }\n        finally\n        {\n            // ======== UNLOCK REMOTE OBR ========\n            log.info( \"UNLOCK \" + remoteFile + '/' + repositoryName );\n            remoteFile.unlockFile( repositoryName );\n            remoteFile.disconnect();\n\n            if ( null != downloadedRepositoryXml )\n            {\n                downloadedRepositoryXml.delete();\n            }\n        }\n    }","commit_id":"435f3907cf86984dab8969c717bf309e3a364c22","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        return new CxfInvokeEndpoint(getAddress(remaining), this, getQueryAsProperties(new URI(remaining)));\n    }","id":42351,"modified_method":"@Override\n    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        return new CxfInvokeEndpoint(remaining, this, createProperties(parameters));\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        // TODO Add support for sending message inputstream.  Currently, we only handle\n        // method invocation with pojo.\n\n        // TODO Add support for endpoints associated with a WSDL\n        if (client == null) {\n            ClientFactoryBean cfBean = new ClientFactoryBean();\n            cfBean.setAddress(getEndpoint().getEndpointUri());\n            cfBean.setBus(endpoint.getBus());\n            cfBean.setServiceClass(Class.forName(endpoint.getProperty(CxfConstants.SEI)));\n            client = cfBean.create();\n        }\n    }","id":42352,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        // TODO Add support for sending message inputstream.  Currently, we only handle\n        // method invocation with pojo.\n\n        // TODO Add support for endpoints associated with a WSDL\n        if (client == null) {\n            ClientFactoryBean cfBean = new ClientFactoryBean();\n            cfBean.setAddress(getEndpoint().getEndpointUri());\n            cfBean.setBus(endpoint.getBus());\n            String className = endpoint.getProperty(CxfConstants.SEI);\n            Class type = ObjectHelper.loadClass(className);\n            cfBean.setServiceClass(type);\n            client = cfBean.create();\n        }\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"public Endpoint<E> createEndpoint(String uri) throws Exception {\n        ObjectHelper.notNull(getCamelContext(), \"camelContext\");        \n        URI u = new URI(uri);\n        String path = u.getHost();\n        if (path == null) {\n            path = u.getSchemeSpecificPart();\n        }\n        Map parameters = URISupport.parseParamters(u);\n\n        Endpoint<E> endpoint = createEndpoint(uri, path, parameters);\n        if (endpoint == null) {\n            return null;\n        }\n        if (parameters != null) {\n            if (endpoint instanceof ScheduledPollEndpoint) {\n                ScheduledPollEndpoint scheduledPollEndpoint = (ScheduledPollEndpoint) endpoint;\n                scheduledPollEndpoint.configureProperties(parameters);\n            }\n            IntrospectionSupport.setProperties(endpoint, parameters);\n        }\n        return endpoint;\n    }","id":42353,"modified_method":"public Endpoint<E> createEndpoint(String uri) throws Exception {\n        ObjectHelper.notNull(getCamelContext(), \"camelContext\");        \n        URI u = new URI(uri);\n        String path = u.getSchemeSpecificPart();\n        \n        // lets trim off any query arguments\n        if (path.startsWith(\"//\")) {\n            path = path.substring(2);\n        }\n        int idx = path.indexOf('?');\n        if (idx > 0) {\n            path = path.substring(0, idx);\n        }\n        Map parameters = URISupport.parseParamters(u);\n\n        Endpoint<E> endpoint = createEndpoint(uri, path, parameters);\n        if (endpoint == null) {\n            return null;\n        }\n        if (parameters != null) {\n            if (endpoint instanceof ScheduledPollEndpoint) {\n                ScheduledPollEndpoint scheduledPollEndpoint = (ScheduledPollEndpoint) endpoint;\n                scheduledPollEndpoint.configureProperties(parameters);\n            }\n            IntrospectionSupport.setProperties(endpoint, parameters);\n        }\n        return endpoint;\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        URI u = new URI(uri);\n        String schemeSpecificPart = u.getSchemeSpecificPart();\n        File file = new File(schemeSpecificPart);\n        FileEndpoint result = new FileEndpoint(file, uri, this);\n        IntrospectionSupport.setProperties(result, parameters);\n        return result;\n    }","id":42354,"modified_method":"protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        File file = new File(remaining);\n        FileEndpoint result = new FileEndpoint(file, uri, this);\n        IntrospectionSupport.setProperties(result, parameters);\n        return result;\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"protected void pollFile(final File file) {\n        if (file.exists() && file.lastModified() > lastPollTime) {\n            if (isValidFile(file)) {\n                processFile(file);\n                deleteOrMoveFile(file);\n            }\n        }\n    }","id":42355,"modified_method":"protected void pollFile(final File file) {\n        if (file.exists() && file.lastModified() > lastPollTime) {\n            if (isValidFile(file)) {\n                FileStrategy strategy = endpoint.getFileStrategy();\n                FileExchange exchange = endpoint.createExchange(file);\n\n                try {\n                    if (strategy.begin(endpoint, exchange, file)) {\n                        getProcessor().process(exchange);\n                        strategy.commit(endpoint, exchange, file);\n                    }\n                    else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(endpoint + \" cannot process file: \" + file);\n                        }\n                    }\n                }\n                catch (Throwable e) {\n                    handleException(e);\n                }\n            }\n        }\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"protected boolean isMatched(File file) {\n        boolean result = true;\n        if (regexPattern != null && regexPattern.length() > 0) {\n            result = file.getName().matches(getRegexPattern());\n        }\n        return result;\n    }","id":42356,"modified_method":"protected boolean isMatched(File file) {\n        String name = file.getName();\n        if (regexPattern != null && regexPattern.length() > 0) {\n            if (!name.matches(getRegexPattern())) {\n                return false;\n            }\n        }\n        String[] prefixes = endpoint.getExcludedNamePrefixes();\n        for (String prefix : prefixes) {\n            if (name.startsWith(prefix)) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"protected boolean isValidFile(File file) {\n        boolean result = false;\n        if (file != null && file.exists()) {\n            if (isMatched(file)) {\n                if (isAttemptFileLock()) {\n                    FileChannel fc = null;\n                    try {\n                        fc = new RandomAccessFile(file, \"rw\").getChannel();\n                        fc.lock();\n                        result = true;\n                    }\n                    catch (Throwable e) {\n                        log.debug(\"Failed to get the lock on file: \" + file, e);\n                    }\n                    finally {\n                        if (fc != null) {\n                            try {\n                                fc.close();\n                            }\n                            catch (IOException e) {\n                            }\n                        }\n                    }\n                }\n                else {\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }","id":42357,"modified_method":"protected boolean isValidFile(File file) {\n        boolean result = false;\n        if (file != null && file.exists()) {\n            if (isMatched(file)) {\n                result = true;\n            }\n        }\n        return result;\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"protected void pollFileOrDirectory(File fileOrDirectory, boolean processDir) {\n        if (!fileOrDirectory.isDirectory()) {\n            pollFile(fileOrDirectory); // process the file\n        }\n        else if (processDir) {\n            log.debug(\"Polling directory \" + fileOrDirectory);\n            File[] files = fileOrDirectory.listFiles();\n            for (int i = 0; i < files.length; i++) {\n                pollFileOrDirectory(files[i], isRecursive()); // self-recursion\n            }\n        }\n        else {\n            log.debug(\"Skipping directory \" + fileOrDirectory);\n        }\n    }","id":42358,"modified_method":"protected void pollFileOrDirectory(File fileOrDirectory, boolean processDir) {\n        if (!fileOrDirectory.isDirectory()) {\n            pollFile(fileOrDirectory); // process the file\n        }\n        else if (processDir) {\n            if (isValidFile(fileOrDirectory)) {\n                log.debug(\"Polling directory \" + fileOrDirectory);\n                File[] files = fileOrDirectory.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    pollFileOrDirectory(files[i], isRecursive()); // self-recursion\n                }\n            }\n        }\n        else {\n            log.debug(\"Skipping directory \" + fileOrDirectory);\n        }\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {\n        resultEndpoint.expectedBodiesReceived(\"Guillaume\", \"Hiram\", \"James\", \"Rob\");\n\n        sendBodies(\"direct:a\", \"Rob\", \"Hiram\", \"Guillaume\", \"James\");\n\n        resultEndpoint.assertIsSatisfied();\n        List<Exchange> list = resultEndpoint.getReceivedExchanges();\n        for (Exchange exchange : list) {\n            log.info(\"Received: \" + exchange);\n        }\n    }","id":42359,"modified_method":"public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {\n        resultEndpoint.expectedBodiesReceived(\"Guillaume\", \"Hiram\", \"James\", \"Rob\");\n\n        sendBodies(\"direct:a\", \"Rob\", \"Hiram\", \"Guillaume\", \"James\");\n\n        resultEndpoint.assertIsSatisfied();\n        List<Exchange> list = resultEndpoint.getReceivedExchanges();\n        for (Exchange exchange : list) {\n            log.debug(\"Received: \" + exchange);\n        }\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        if (producer == null) {\n            throw new IllegalStateException(\"No producer, this processor has not been started!\");\n        }\n        producer.process(exchange);\n    }","id":42360,"modified_method":"public void process(Exchange exchange) throws Exception {\n        if (producer == null) {\n            if (isStopped()) {\n                log.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\n            }\n            else {\n                throw new IllegalStateException(\"No producer, this processor has not been started!\");\n            }\n        }\n        else {\n            producer.process(exchange);\n        }\n    }","commit_id":"90f0194d184a435b766508a5a298c3dc12414382","url":"https://github.com/apache/camel"},{"original_method":"/**\n\t * geo:latitude,longitude<BR>\n\t * geo:latitude,longitude?z=zoom<BR>\n\t * geo:0,0?q=my+street+address<BR>\n\t * geo:0,0?q=business+near+city\n\t * \n\t * @param data\n\t * @return\n\t */\n\tprivate MyService extract(Uri data) {\n\t\tif (\"http\".equalsIgnoreCase(data.getScheme()) && \"maps.google.com\".equals(data.getHost()) && \"/go\".equals(data.getPath())) {\n\t\t\tString q = data.getQueryParameter(\"q\");\n\t\t\tif (q.indexOf(',') != -1) {\n\t\t\t\tint i = q.indexOf(',');\n\t\t\t\tString lat = q.substring(0, i);\n\t\t\t\tString lon = q.substring(i + 1);\n\t\t\t\ttry {\n\t\t\t\t\tdouble llat = Double.parseDouble(lat.trim());\n\t\t\t\t\tdouble llon = Double.parseDouble(lon.trim());\n\t\t\t\t\treturn new GeoPointSearch(llat, llon);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tshowErrorMessage(q);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshowErrorMessage(q);\n\t\t\t}\n\t\t} else if (data.getSchemeSpecificPart().indexOf(\"0,0?\") != -1) {\n\t\t\t// it is 0,0? that means a search\n\t\t\treturn new GeoAddressSearch(data.getQuery());\n\t\t} else {\n\t\t\tString geo = data.getSchemeSpecificPart();\n\t\t\tint latIndex = geo.indexOf(',');\n\t\t\tint lonIndex = geo.indexOf('?');\n\t\t\tlonIndex = lonIndex > 0 ? lonIndex : geo.length();\n\t\t\tif (latIndex > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tdouble lat = Double.parseDouble(geo.substring(0, latIndex).trim());\n\t\t\t\t\tdouble lon = Double.parseDouble(geo.substring(latIndex + 1, lonIndex).trim());\n\t\t\t\t\treturn new GeoPointSearch(lat, lon);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tshowErrorMessage(geo);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshowErrorMessage(geo);\n\t\t\t}\n\t\t}\n\t\treturn new Empty();\n\t}","id":42361,"modified_method":"/**\n\t * geo:latitude,longitude<BR>\n\t * geo:latitude,longitude?z=zoom<BR>\n\t * geo:0,0?q=my+street+address<BR>\n\t * geo:0,0?q=business+near+city\n\t * \n\t * @param data\n\t * @return\n\t */\n\tprivate MyService extract(Uri data) {\n\t\tif (\"http\".equalsIgnoreCase(data.getScheme()) && \"maps.google.com\".equals(data.getHost())) {\n\t\t\tString q = data.getQueryParameter(\"q\");\n\t\t\tif (q.indexOf(',') != -1) {\n\t\t\t\tint i = q.indexOf(',');\n\t\t\t\tString lat = q.substring(0, i);\n\t\t\t\tString lon = q.substring(i + 1);\n\t\t\t\ttry {\n\t\t\t\t\tdouble llat = Double.parseDouble(lat.trim());\n\t\t\t\t\tdouble llon = Double.parseDouble(lon.trim());\n\t\t\t\t\treturn new GeoPointSearch(llat, llon);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\tshowErrorMessage(q);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshowErrorMessage(q);\n\t\t\t}\n\t\t} else if (data.getSchemeSpecificPart().indexOf(\"0,0?\") != -1) {\n\t\t\t// it is 0,0? that means a search\n\t\t\treturn new GeoAddressSearch(data.getQuery());\n\t\t} else {\n\t\t\tshowErrorMessage(data.getSchemeSpecificPart());\n\t\t}\n\t\treturn new Empty();\n\t}","commit_id":"7e529baf9a13833752891b8f35c2c56aa031ce6c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override public void visitClass(@NotNull PsiClass aClass) {\n            // no call to super, so it doesn't drill down\n            final PsiReferenceList implementsList = aClass.getImplementsList();\n            if (implementsList == null) {\n                return;\n            }\n            final PsiJavaCodeReferenceElement[] references =\n                    implementsList.getReferenceElements();\n            for (final PsiJavaCodeReferenceElement reference : references) {\n                final PsiClass iface = (PsiClass)reference.resolve();\n                if (iface != null) {\n                    if (interfaceContainsOnlyConstants(iface, new HashSet())) {\n                        registerError(reference);\n                    }\n                }\n            }\n        }","id":42362,"modified_method":"@Override public void visitClass(@NotNull PsiClass aClass) {\n            // no call to super, so it doesn't drill down\n            final PsiReferenceList implementsList = aClass.getImplementsList();\n            if (implementsList == null) {\n                return;\n            }\n            final PsiJavaCodeReferenceElement[] references =\n                    implementsList.getReferenceElements();\n            for (final PsiJavaCodeReferenceElement reference : references) {\n                final PsiClass iface = (PsiClass)reference.resolve();\n                if (iface != null) {\n                    if (interfaceContainsOnlyConstants(iface, new HashSet<PsiClass>())) {\n                        registerError(reference);\n                    }\n                }\n            }\n        }","commit_id":"bbb84666bdfeca74d53dc56377b3473e4d28c076","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n        public String getName() {\n            return InspectionGadgetsBundle.message(\n                    \"static.inheritance.replace.quickfix\");\n        }","id":42363,"modified_method":"@NotNull\n        public String getName() {\n        String scope = myReplaceInWholeProject ? InspectionGadgetsBundle.message(\"the.whole.project\") : InspectionGadgetsBundle.message(\"this.class\");\n        return InspectionGadgetsBundle.message(\"static.inheritance.replace.quickfix\", scope);\n        }","commit_id":"bbb84666bdfeca74d53dc56377b3473e4d28c076","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected InspectionGadgetsFix buildFix(Object... infos) {\n        return new StaticInheritanceFix();\n    }","id":42364,"modified_method":"@NotNull\n  @Override\n  protected InspectionGadgetsFix[] buildFixes(Object... infos) {\n    return new InspectionGadgetsFix[]{new StaticInheritanceFix(false), new StaticInheritanceFix(true)};\n  }","commit_id":"bbb84666bdfeca74d53dc56377b3473e4d28c076","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiJavaCodeReferenceElement referenceElement =\n                    (PsiJavaCodeReferenceElement)descriptor.getPsiElement();\n            final PsiClass iface = (PsiClass)referenceElement.resolve();\n            assert iface != null;\n            final PsiField[] allFields = iface.getAllFields();\n\n            final PsiClass implementingClass =\n                    ClassUtils.getContainingClass(referenceElement);\n            final PsiManager manager = referenceElement.getManager();\n            assert implementingClass != null;\n            final SearchScope searchScope = implementingClass.getUseScope();\n            final Map<PsiReferenceExpression, PsiField> refsToRebind =\n                    new HashMap<PsiReferenceExpression, PsiField>();\n            for (final PsiField field : allFields) {\n                final Query<PsiReference> search =\n                        ReferencesSearch.search(field, searchScope, false);\n                for (PsiReference reference : search) {\n                    if (!(reference instanceof PsiReferenceExpression)) {\n                        continue;\n                    }\n                    final PsiReferenceExpression referenceExpression =\n                            (PsiReferenceExpression)reference;\n                    if(isQuickFixOnReadOnlyFile(referenceExpression)){\n                        continue;\n                    }\n                    refsToRebind.put(referenceExpression, field);\n                }\n            }\n            deleteElement(referenceElement);\n            for (PsiReferenceExpression reference : refsToRebind.keySet()) {\n                final PsiField field = refsToRebind.get(reference);\n              final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n                final PsiReferenceExpression qualified = (PsiReferenceExpression)\n                        elementFactory.createExpressionFromText(\"xxx.\" +\n                                reference.getText(), reference);\n                final PsiReferenceExpression newReference =\n                        (PsiReferenceExpression)reference.replace(qualified);\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)\n                                newReference.getQualifierExpression();\n                if (referenceExpression != null) {\n                    final PsiClass containingClass = field.getContainingClass();\n                    referenceExpression.bindToElement(containingClass);\n                }\n            }\n        }","id":42365,"modified_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiJavaCodeReferenceElement referenceElement =\n                    (PsiJavaCodeReferenceElement)descriptor.getPsiElement();\n            final PsiClass iface = (PsiClass)referenceElement.resolve();\n            assert iface != null;\n            final PsiField[] allFields = iface.getAllFields();\n\n            final PsiClass implementingClass =\n                    ClassUtils.getContainingClass(referenceElement);\n            final PsiManager manager = referenceElement.getManager();\n            assert implementingClass != null;\n            final SearchScope searchScope = myReplaceInWholeProject ? implementingClass.getUseScope() : new LocalSearchScope(implementingClass);\n            final Map<PsiReferenceExpression, PsiField> refsToRebind =\n                    new HashMap<PsiReferenceExpression, PsiField>();\n            for (final PsiField field : allFields) {\n                final Query<PsiReference> search =\n                        ReferencesSearch.search(field, searchScope, false);\n                for (PsiReference reference : search) {\n                    if (!(reference instanceof PsiReferenceExpression)) {\n                        continue;\n                    }\n                    final PsiReferenceExpression referenceExpression =\n                            (PsiReferenceExpression)reference;\n                    if(isQuickFixOnReadOnlyFile(referenceExpression)){\n                        continue;\n                    }\n                    refsToRebind.put(referenceExpression, field);\n                }\n            }\n            deleteElement(referenceElement);\n            for (PsiReferenceExpression reference : refsToRebind.keySet()) {\n                final PsiField field = refsToRebind.get(reference);\n              final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n                final PsiReferenceExpression qualified = (PsiReferenceExpression)\n                        elementFactory.createExpressionFromText(\"xxx.\" +\n                                reference.getText(), reference);\n                final PsiReferenceExpression newReference =\n                        (PsiReferenceExpression)reference.replace(qualified);\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)\n                                newReference.getQualifierExpression();\n                if (referenceExpression != null) {\n                    final PsiClass containingClass = field.getContainingClass();\n                    referenceExpression.bindToElement(containingClass);\n                }\n            }\n        }","commit_id":"bbb84666bdfeca74d53dc56377b3473e4d28c076","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void contributeSearchTargets(@NotNull final PsiElement refElement,\n                                              @NotNull FindUsagesOptions options,\n                                              @NotNull SearchRequestCollector collector,\n                                              final boolean ignoreAccessScope,\n                                              final SearchScope scope) {\n    if (!options.isUsages) {\n      return;\n    }\n\n    String text = null;\n    if (refElement instanceof PsiFile) {\n      final VirtualFile vFile = ((PsiFile)refElement).getVirtualFile();\n      if (vFile != null) {\n        text = vFile.getNameWithoutExtension();\n      }\n    }\n    else if (refElement instanceof PsiNamedElement) {\n      text = ((PsiNamedElement)refElement).getName();\n      if (refElement instanceof PsiMetaOwner) {\n        final PsiMetaData metaData = ((PsiMetaOwner)refElement).getMetaData();\n        if (metaData != null) text = metaData.getName();\n      }\n    }\n\n    if (text == null && refElement instanceof PsiMetaOwner) {\n      final PsiMetaData metaData = ((PsiMetaOwner)refElement).getMetaData();\n      if (metaData != null) text = metaData.getName();\n    }\n    if (StringUtil.isNotEmpty(text)) {\n      final SearchScope searchScope = ignoreAccessScope ? scope : refElement.getUseScope().intersectWith(scope);\n      assert text != null;\n      collector.searchWord(text, searchScope, refElement.getLanguage().isCaseSensitive(), refElement);\n    }\n  }","id":42366,"modified_method":"private static void contributeSearchTargets(@NotNull final PsiElement refElement,\n                                              @NotNull FindUsagesOptions options,\n                                              @NotNull SearchRequestCollector collector,\n                                              final boolean ignoreAccessScope,\n                                              final SearchScope scope) {\n    if (!options.isUsages) {\n      return;\n    }\n\n    String text = null;\n    if (refElement instanceof PsiFile) {\n      final VirtualFile vFile = ((PsiFile)refElement).getVirtualFile();\n      if (vFile != null) {\n        text = vFile.getNameWithoutExtension();\n      }\n    }\n    else if (refElement instanceof PsiNamedElement) {\n      text = ((PsiNamedElement)refElement).getName();\n      if (refElement instanceof PsiMetaOwner) {\n        final PsiMetaData metaData = ((PsiMetaOwner)refElement).getMetaData();\n        if (metaData != null) text = metaData.getName();\n      }\n    }\n\n    if (text == null && refElement instanceof PsiMetaOwner) {\n      final PsiMetaData metaData = ((PsiMetaOwner)refElement).getMetaData();\n      if (metaData != null) text = metaData.getName();\n    }\n    if (StringUtil.isNotEmpty(text)) {\n      final SearchScope searchScope = ignoreAccessScope ? scope : refElement.getManager().getSearchHelper().getUseScope(refElement).intersectWith(scope);\n      assert text != null;\n      collector.searchWord(text, searchScope, refElement.getLanguage().isCaseSensitive(), refElement);\n    }\n  }","commit_id":"ae08f78db11d9e265ab7b9d88c9b73bc4890fd56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public SearchScope getUseScope(@NotNull PsiElement element) {\n    return element.getUseScope();\n  }","id":42367,"modified_method":"@NotNull\n  public SearchScope getUseScope(@NotNull PsiElement element) {\n    SearchScope scope = element.getUseScope();\n    for (UseScopeEnlarger enlarger : UseScopeEnlarger.EP_NAME.getExtensions()) {\n      final SearchScope additionalScope = enlarger.getAdditionalUseScope(element);\n      if (additionalScope != null) {\n        scope = scope.union(additionalScope);\n      }\n    }\n    return scope;\n  }","commit_id":"ae08f78db11d9e265ab7b9d88c9b73bc4890fd56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processUsagesInNonJavaFiles(@Nullable final PsiElement originalElement,\n                                          @NotNull String qName,\n                                          @NotNull final PsiNonJavaFileReferenceProcessor processor,\n                                          @NotNull GlobalSearchScope searchScope) {\n    if (qName.length() == 0) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    ProgressManager progressManager = ProgressManager.getInstance();\n    final ProgressIndicator progress = progressManager.getProgressIndicator();\n\n    int dotIndex = qName.lastIndexOf('.');\n    int dollarIndex = qName.lastIndexOf('$');\n    int maxIndex = Math.max(dotIndex, dollarIndex);\n    final String wordToSearch = maxIndex >= 0 ? qName.substring(maxIndex + 1) : qName;\n    if (originalElement != null && myManager.isInProject(originalElement) && searchScope.isSearchInLibraries()) {\n      searchScope = searchScope.intersectWith(GlobalSearchScope.projectScope(myManager.getProject()));\n    }\n    final GlobalSearchScope theSearchScope = searchScope;\n    PsiFile[] files = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n      public PsiFile[] compute() {\n        return myManager.getCacheManager().getFilesWithWord(wordToSearch, UsageSearchContext.IN_PLAIN_TEXT, theSearchScope, true);\n      }\n    });\n\n    final StringSearcher searcher = new StringSearcher(qName, true, true);\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.search.in.non.java.files.progress\"));\n    }\n\n    final Ref<Boolean> cancelled = new Ref<Boolean>(Boolean.FALSE);\n    final GlobalSearchScope finalScope = searchScope;\n    for (int i = 0; i < files.length; i++) {\n      if (progress != null) progress.checkCanceled();\n\n      final PsiFile psiFile = files[i];\n\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          CharSequence text = psiFile.getViewProvider().getContents();\n          for (int index = LowLevelSearchUtil.searchWord(text, 0, text.length(), searcher, progress); index >= 0;) {\n            PsiReference referenceAt = psiFile.findReferenceAt(index);\n            if (referenceAt == null || originalElement == null ||\n                !PsiSearchScopeUtil.isInScope(getUseScope(originalElement).intersectWith(finalScope), psiFile)) {\n              if (!processor.process(psiFile, index, index + searcher.getPattern().length())) {\n                cancelled.set(Boolean.TRUE);\n                return;\n              }\n            }\n\n            index = LowLevelSearchUtil.searchWord(text, index + searcher.getPattern().length(), text.length(), searcher, progress);\n          }\n        }\n      });\n      if (cancelled.get()) break;\n      if (progress != null) {\n        progress.setFraction((double)(i + 1) / files.length);\n      }\n    }\n\n    if (progress != null) {\n      progress.popState();\n    }\n  }","id":42368,"modified_method":"public void processUsagesInNonJavaFiles(@Nullable final PsiElement originalElement,\n                                          @NotNull String qName,\n                                          @NotNull final PsiNonJavaFileReferenceProcessor processor,\n                                          @NotNull GlobalSearchScope searchScope) {\n    if (qName.length() == 0) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    ProgressManager progressManager = ProgressManager.getInstance();\n    final ProgressIndicator progress = progressManager.getProgressIndicator();\n\n    int dotIndex = qName.lastIndexOf('.');\n    int dollarIndex = qName.lastIndexOf('$');\n    int maxIndex = Math.max(dotIndex, dollarIndex);\n    final String wordToSearch = maxIndex >= 0 ? qName.substring(maxIndex + 1) : qName;\n    if (originalElement != null && myManager.isInProject(originalElement) && searchScope.isSearchInLibraries()) {\n      searchScope = searchScope.intersectWith(GlobalSearchScope.projectScope(myManager.getProject()));\n    }\n    final GlobalSearchScope theSearchScope = searchScope;\n    PsiFile[] files = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n      public PsiFile[] compute() {\n        return myManager.getCacheManager().getFilesWithWord(wordToSearch, UsageSearchContext.IN_PLAIN_TEXT, theSearchScope, true);\n      }\n    });\n\n    final StringSearcher searcher = new StringSearcher(qName, true, true);\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.search.in.non.java.files.progress\"));\n    }\n\n    final SearchScope useScope = new ReadAction<SearchScope>() {\n      protected void run(final Result<SearchScope> result) {\n        if (originalElement != null) {\n          result.setResult(getUseScope(originalElement));\n        }\n      }\n    }.execute().getResultObject();\n\n    final Ref<Boolean> cancelled = new Ref<Boolean>(Boolean.FALSE);\n    final GlobalSearchScope finalScope = searchScope;\n    for (int i = 0; i < files.length; i++) {\n      if (progress != null) progress.checkCanceled();\n\n      final PsiFile psiFile = files[i];\n\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          CharSequence text = psiFile.getViewProvider().getContents();\n          for (int index = LowLevelSearchUtil.searchWord(text, 0, text.length(), searcher, progress); index >= 0;) {\n            PsiReference referenceAt = psiFile.findReferenceAt(index);\n            if (referenceAt == null || useScope == null ||\n                !PsiSearchScopeUtil.isInScope(useScope.intersectWith(finalScope), psiFile)) {\n              if (!processor.process(psiFile, index, index + searcher.getPattern().length())) {\n                cancelled.set(Boolean.TRUE);\n                return;\n              }\n            }\n\n            index = LowLevelSearchUtil.searchWord(text, index + searcher.getPattern().length(), text.length(), searcher, progress);\n          }\n        }\n      });\n      if (cancelled.get()) break;\n      if (progress != null) {\n        progress.setFraction((double)(i + 1) / files.length);\n      }\n    }\n\n    if (progress != null) {\n      progress.popState();\n    }\n  }","commit_id":"ae08f78db11d9e265ab7b9d88c9b73bc4890fd56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SearchScope getEffectiveSearchScope () {\n      if (!myIgnoreAccessScope) {\n        SearchScope accessScope = myElementToSearch.getUseScope();\n        return myScope.intersectWith(accessScope);\n      }\n      else {\n        return myScope;\n      }\n    }","id":42369,"modified_method":"public SearchScope getEffectiveSearchScope () {\n      if (!myIgnoreAccessScope) {\n        SearchScope accessScope = myElementToSearch.getManager().getSearchHelper().getUseScope(myElementToSearch);\n        return myScope.intersectWith(accessScope);\n      }\n      else {\n        return myScope;\n      }\n    }","commit_id":"ae08f78db11d9e265ab7b9d88c9b73bc4890fd56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean processUsagesInStringsAndComments(@NotNull final PsiElement element,\n                                                          @NotNull final String stringToSearch,\n                                                          final boolean ignoreReferences,\n                                                          @NotNull final PairProcessor<PsiElement, TextRange> processor) {\n    PsiManager manager = element.getManager();\n    PsiSearchHelper helper = manager.getSearchHelper();\n    SearchScope scope = element.getUseScope();\n    scope = scope.intersectWith(GlobalSearchScope.projectScope(manager.getProject()));\n    Processor<PsiElement> commentOrLiteralProcessor = new Processor<PsiElement>() {\n      public boolean process(PsiElement literal) {\n        return processTextIn(literal, stringToSearch, ignoreReferences, processor);\n      }\n    };\n    return processStringLiteralsContainingIdentifier(stringToSearch, scope, helper, commentOrLiteralProcessor) &&\n           helper.processCommentsContainingIdentifier(stringToSearch, scope, commentOrLiteralProcessor);\n  }","id":42370,"modified_method":"public static boolean processUsagesInStringsAndComments(@NotNull final PsiElement element,\n                                                          @NotNull final String stringToSearch,\n                                                          final boolean ignoreReferences,\n                                                          @NotNull final PairProcessor<PsiElement, TextRange> processor) {\n    PsiManager manager = element.getManager();\n    PsiSearchHelper helper = manager.getSearchHelper();\n    SearchScope scope = element.getManager().getSearchHelper().getUseScope(element);\n    scope = scope.intersectWith(GlobalSearchScope.projectScope(manager.getProject()));\n    Processor<PsiElement> commentOrLiteralProcessor = new Processor<PsiElement>() {\n      public boolean process(PsiElement literal) {\n        return processTextIn(literal, stringToSearch, ignoreReferences, processor);\n      }\n    };\n    return processStringLiteralsContainingIdentifier(stringToSearch, scope, helper, commentOrLiteralProcessor) &&\n           helper.processCommentsContainingIdentifier(stringToSearch, scope, commentOrLiteralProcessor);\n  }","commit_id":"ae08f78db11d9e265ab7b9d88c9b73bc4890fd56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean performInplaceRename() {\n    if (InjectedLanguageUtil.isInInjectedLanguagePrefixSuffix(myElementToRename)) {\n      return false;\n    }\n    \n    final Collection<PsiReference> refs = ReferencesSearch.search(myElementToRename).findAll();\n\n    PsiFile myEditorFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument());\n    // Note, that myEditorFile can be different from myElement.getContainingFile() e.g. in injections: myElement declaration in one \n    // file / usage in another !\n    final PsiReference reference = (myEditorFile != null ? \n      myEditorFile:myElementToRename.getContainingFile()).findReferenceAt(myEditor.getCaretModel().getOffset());\n    if (reference != null && !refs.contains(reference)) {\n      refs.add(reference);\n    }\n\n    final FileViewProvider fileViewProvider = myElementToRename.getContainingFile().getViewProvider();\n    VirtualFile file = getTopLevelVirtualFile(fileViewProvider);\n\n    for (PsiReference ref : refs) {\n      final FileViewProvider usageViewProvider = ref.getElement().getContainingFile().getViewProvider();\n\n      if (getTopLevelVirtualFile(usageViewProvider) != file) {\n        return false;\n      }\n    }\n\n    while (!ourRenamersStack.isEmpty()) {\n      ourRenamersStack.peek().finish();\n    }\n\n    ourRenamersStack.push(this);\n\n    final Map<TextRange, TextAttributes> rangesToHighlight = new THashMap<TextRange, TextAttributes>();\n    //it is crucial to highlight AFTER the template is started, so we collect ranges first\n    collectElementsToHighlight(rangesToHighlight, refs);\n\n    final HighlightManager highlightManager = HighlightManager.getInstance(myProject);\n\n    PsiElement scope = null;\n    final SearchScope searchScope = myElementToRename.getUseScope();\n    if (searchScope instanceof LocalSearchScope) {\n      final PsiElement[] elements = ((LocalSearchScope)searchScope).getScope();\n      scope = PsiTreeUtil.findCommonParent(elements);\n    }\n\n    if (scope == null) {\n      return false; // Should have valid local search scope for inplace rename\n    }\n\n    final PsiFile containingFile = scope.getContainingFile();\n    if (containingFile == null){\n      return false; // Should have valid local search scope for inplace rename\n    }\n    final PsiElement context = containingFile.getContext();\n    if (context != null) {\n      scope = context.getContainingFile();\n    }\n\n    String stringToSearch = myElementToRename.getName();\n    if (stringToSearch != null &&\n        !TextOccurrencesUtil.processUsagesInStringsAndComments(myElementToRename, stringToSearch, true, new PairProcessor<PsiElement, TextRange>() {\n            public boolean process(PsiElement psiElement, TextRange textRange) {\n              return false;\n            }\n          })) {\n      return false;\n    }\n\n    ResolveSnapshotProvider resolveSnapshotProvider = INSTANCE.forLanguage(scope.getLanguage());\n    final ResolveSnapshotProvider.ResolveSnapshot snapshot = resolveSnapshotProvider != null ?\n      resolveSnapshotProvider.createSnapshot(scope):null;\n    final TemplateBuilderImpl builder = new TemplateBuilderImpl(scope);\n\n    final PsiElement nameIdentifier = myElementToRename.getNameIdentifier();\n    PsiElement selectedElement = getSelectedInEditorElement(nameIdentifier, refs, myEditor.getCaretModel().getOffset());\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject, myElementToRename)) return true;\n\n    if (nameIdentifier != null) addVariable(nameIdentifier, selectedElement, builder);\n    for (PsiReference ref : refs) {\n      addVariable(ref, selectedElement, builder);\n    }\n    \n    final PsiElement scope1 = scope;\n    final int renameOffset = myElementToRename.getTextOffset();\n    CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            int offset = myEditor.getCaretModel().getOffset();\n            Template template = builder.buildInlineTemplate();\n            template.setToShortenLongNames(false);\n            TextRange range = scope1.getTextRange();\n            assert range != null;\n            myHighlighters = new ArrayList<RangeHighlighter>();\n            Editor topLevelEditor = InjectedLanguageUtil.getTopLevelEditor(myEditor);\n            topLevelEditor.getCaretModel().moveToOffset(range.getStartOffset());\n            TemplateManager.getInstance(myProject).startTemplate(topLevelEditor, template, new TemplateEditingAdapter() {\n              private String myNewName = null;\n              public void beforeTemplateFinished(final TemplateState templateState, Template template) {\n                finish();\n\n                if (snapshot != null) {\n                  TextResult value = templateState.getVariableValue(PRIMARY_VARIABLE_NAME);\n                  if (value != null) {\n                    myNewName = value.toString();\n                    if (LanguageNamesValidation.INSTANCE.forLanguage(scope1.getLanguage()).isIdentifier(myNewName, myProject)) {\n                      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                        public void run() {\n                          snapshot.apply(myNewName);\n                        }\n                      });\n                    }\n                  }\n                }\n              }\n\n              @Override\n              public void templateFinished(Template template, boolean brokenOff) {\n                super.templateFinished(template, brokenOff);\n                if (myNewName != null) {\n                  performAutomaticRename(myNewName, PsiTreeUtil.getParentOfType(containingFile.findElementAt(renameOffset), PsiNameIdentifierOwner.class));\n                }\n              }\n\n              public void templateCancelled(Template template) {\n                finish();\n              }\n            });\n\n            //move to old offset\n            final LookupImpl lookup = (LookupImpl)LookupManager.getActiveLookup(myEditor);\n            final boolean lookupShown = lookup != null && lookup.getLookupStart() < offset;\n            if (lookupShown) {\n              lookup.setAdditionalPrefix(myEditor.getDocument().getCharsSequence().subSequence(lookup.getLookupStart(), offset).toString());\n            }\n            myEditor.getCaretModel().moveToOffset(offset);\n            if (lookupShown) {\n              lookup.setAdditionalPrefix(\"\");\n            }\n\n            //add highlights\n            addHighlights(rangesToHighlight, topLevelEditor, myHighlighters, highlightManager);\n          }\n        });\n      }\n    }, RefactoringBundle.message(\"rename.title\"), null);\n\n    return true;\n  }","id":42371,"modified_method":"public boolean performInplaceRename() {\n    if (InjectedLanguageUtil.isInInjectedLanguagePrefixSuffix(myElementToRename)) {\n      return false;\n    }\n    \n    final Collection<PsiReference> refs = ReferencesSearch.search(myElementToRename).findAll();\n\n    PsiFile myEditorFile = PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument());\n    // Note, that myEditorFile can be different from myElement.getContainingFile() e.g. in injections: myElement declaration in one \n    // file / usage in another !\n    final PsiReference reference = (myEditorFile != null ? \n      myEditorFile:myElementToRename.getContainingFile()).findReferenceAt(myEditor.getCaretModel().getOffset());\n    if (reference != null && !refs.contains(reference)) {\n      refs.add(reference);\n    }\n\n    final FileViewProvider fileViewProvider = myElementToRename.getContainingFile().getViewProvider();\n    VirtualFile file = getTopLevelVirtualFile(fileViewProvider);\n\n    for (PsiReference ref : refs) {\n      final FileViewProvider usageViewProvider = ref.getElement().getContainingFile().getViewProvider();\n\n      if (getTopLevelVirtualFile(usageViewProvider) != file) {\n        return false;\n      }\n    }\n\n    while (!ourRenamersStack.isEmpty()) {\n      ourRenamersStack.peek().finish();\n    }\n\n    ourRenamersStack.push(this);\n\n    final Map<TextRange, TextAttributes> rangesToHighlight = new THashMap<TextRange, TextAttributes>();\n    //it is crucial to highlight AFTER the template is started, so we collect ranges first\n    collectElementsToHighlight(rangesToHighlight, refs);\n\n    final HighlightManager highlightManager = HighlightManager.getInstance(myProject);\n\n    PsiElement scope = null;\n    final SearchScope searchScope = myElementToRename.getManager().getSearchHelper().getUseScope(myElementToRename);\n    if (searchScope instanceof LocalSearchScope) {\n      final PsiElement[] elements = ((LocalSearchScope)searchScope).getScope();\n      scope = PsiTreeUtil.findCommonParent(elements);\n    }\n\n    if (scope == null) {\n      return false; // Should have valid local search scope for inplace rename\n    }\n\n    final PsiFile containingFile = scope.getContainingFile();\n    if (containingFile == null){\n      return false; // Should have valid local search scope for inplace rename\n    }\n    final PsiElement context = containingFile.getContext();\n    if (context != null) {\n      scope = context.getContainingFile();\n    }\n\n    String stringToSearch = myElementToRename.getName();\n    if (stringToSearch != null &&\n        !TextOccurrencesUtil.processUsagesInStringsAndComments(myElementToRename, stringToSearch, true, new PairProcessor<PsiElement, TextRange>() {\n            public boolean process(PsiElement psiElement, TextRange textRange) {\n              return false;\n            }\n          })) {\n      return false;\n    }\n\n    ResolveSnapshotProvider resolveSnapshotProvider = INSTANCE.forLanguage(scope.getLanguage());\n    final ResolveSnapshotProvider.ResolveSnapshot snapshot = resolveSnapshotProvider != null ?\n      resolveSnapshotProvider.createSnapshot(scope):null;\n    final TemplateBuilderImpl builder = new TemplateBuilderImpl(scope);\n\n    final PsiElement nameIdentifier = myElementToRename.getNameIdentifier();\n    PsiElement selectedElement = getSelectedInEditorElement(nameIdentifier, refs, myEditor.getCaretModel().getOffset());\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject, myElementToRename)) return true;\n\n    if (nameIdentifier != null) addVariable(nameIdentifier, selectedElement, builder);\n    for (PsiReference ref : refs) {\n      addVariable(ref, selectedElement, builder);\n    }\n    \n    final PsiElement scope1 = scope;\n    final int renameOffset = myElementToRename.getTextOffset();\n    CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            int offset = myEditor.getCaretModel().getOffset();\n            Template template = builder.buildInlineTemplate();\n            template.setToShortenLongNames(false);\n            TextRange range = scope1.getTextRange();\n            assert range != null;\n            myHighlighters = new ArrayList<RangeHighlighter>();\n            Editor topLevelEditor = InjectedLanguageUtil.getTopLevelEditor(myEditor);\n            topLevelEditor.getCaretModel().moveToOffset(range.getStartOffset());\n            TemplateManager.getInstance(myProject).startTemplate(topLevelEditor, template, new TemplateEditingAdapter() {\n              private String myNewName = null;\n              public void beforeTemplateFinished(final TemplateState templateState, Template template) {\n                finish();\n\n                if (snapshot != null) {\n                  TextResult value = templateState.getVariableValue(PRIMARY_VARIABLE_NAME);\n                  if (value != null) {\n                    myNewName = value.toString();\n                    if (LanguageNamesValidation.INSTANCE.forLanguage(scope1.getLanguage()).isIdentifier(myNewName, myProject)) {\n                      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                        public void run() {\n                          snapshot.apply(myNewName);\n                        }\n                      });\n                    }\n                  }\n                }\n              }\n\n              @Override\n              public void templateFinished(Template template, boolean brokenOff) {\n                super.templateFinished(template, brokenOff);\n                if (myNewName != null) {\n                  performAutomaticRename(myNewName, PsiTreeUtil.getParentOfType(containingFile.findElementAt(renameOffset), PsiNameIdentifierOwner.class));\n                }\n              }\n\n              public void templateCancelled(Template template) {\n                finish();\n              }\n            });\n\n            //move to old offset\n            final LookupImpl lookup = (LookupImpl)LookupManager.getActiveLookup(myEditor);\n            final boolean lookupShown = lookup != null && lookup.getLookupStart() < offset;\n            if (lookupShown) {\n              lookup.setAdditionalPrefix(myEditor.getDocument().getCharsSequence().subSequence(lookup.getLookupStart(), offset).toString());\n            }\n            myEditor.getCaretModel().moveToOffset(offset);\n            if (lookupShown) {\n              lookup.setAdditionalPrefix(\"\");\n            }\n\n            //add highlights\n            addHighlights(rangesToHighlight, topLevelEditor, myHighlighters, highlightManager);\n          }\n        });\n      }\n    }, RefactoringBundle.message(\"rename.title\"), null);\n\n    return true;\n  }","commit_id":"ae08f78db11d9e265ab7b9d88c9b73bc4890fd56","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public SearchScope getUseScope() {\n        KtElement enclosingBlock = KtPsiUtil.getEnclosingElementForLocalDeclaration(this, false);\n        if (enclosingBlock != null) return new LocalSearchScope(enclosingBlock);\n\n        if (hasModifier(KtTokens.PRIVATE_KEYWORD)) {\n            KtElement containingClass = PsiTreeUtil.getParentOfType(this, KtClassOrObject.class);\n            if (containingClass instanceof KtObjectDeclaration && ((KtObjectDeclaration) containingClass).isCompanion()) {\n                KtElement companionObjectClass = PsiTreeUtil.getParentOfType(containingClass, KtClassOrObject.class);\n                if (companionObjectClass != null) {\n                    containingClass = companionObjectClass;\n                }\n            }\n            if (containingClass != null) {\n                return new LocalSearchScope(containingClass);\n            }\n        }\n\n        return super.getUseScope();\n    }","id":42372,"modified_method":"@NotNull\n    @Override\n    public SearchScope getUseScope() {\n        KtElement enclosingBlock = KtPsiUtil.getEnclosingElementForLocalDeclaration(this, false);\n        if (enclosingBlock != null) return new LocalSearchScope(enclosingBlock);\n\n        if (hasModifier(KtTokens.PRIVATE_KEYWORD)) {\n            KtElement containingClass = PsiTreeUtil.getParentOfType(this, KtClassOrObject.class);\n            if (containingClass instanceof KtObjectDeclaration && ((KtObjectDeclaration) containingClass).isCompanion()) {\n                KtElement companionObjectClass = PsiTreeUtil.getParentOfType(containingClass, KtClassOrObject.class);\n                if (companionObjectClass != null) {\n                    containingClass = companionObjectClass;\n                }\n            }\n            if (containingClass != null) {\n                return new LocalSearchScope(containingClass);\n            }\n        }\n\n        SearchScope scope = super.getUseScope();\n\n        KtClassOrObject classOrObject = KtPsiUtilKt.getContainingClassOrObject(this);\n        if (classOrObject != null) {\n            scope = scope.intersectWith(classOrObject.getUseScope());\n        }\n\n        return scope;\n    }","commit_id":"d9698dfa4d42cdd6a22c09d90e730b53bfeb0ef0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public CallHierarchyBrowserBase(final Project project, final PsiElement method) {\n    super(project, method);\n\n    for (String type : myType2TreeMap.keySet()) {\n      myType2ScopeMap.put(type, SCOPE_ALL);\n    }\n  }","id":42373,"modified_method":"public CallHierarchyBrowserBase(final Project project, final PsiElement method) {\n    super(project, method);\n\n\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final Object[] buildChildren(final HierarchyNodeDescriptor descriptor) {\n    final PsiMember enclosingElement = ((CallHierarchyNodeDescriptor)descriptor).getEnclosingElement();\n    if (!(enclosingElement instanceof PsiMethod)) {\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n    final PsiMethod method = (PsiMethod)enclosingElement;\n\n    SearchScope searchScope = GlobalSearchScope.allScope(myProject);\n    if (CallHierarchyBrowser.SCOPE_CLASS.equals(myScopeType)) {\n      final PsiMethod baseMethod = (PsiMethod)((CallHierarchyNodeDescriptor)getBaseDescriptor()).getTargetElement();\n      final PsiClass containingClass = baseMethod.getContainingClass();\n      searchScope = new LocalSearchScope(containingClass);\n    }\n    else if (CallHierarchyBrowser.SCOPE_PROJECT.equals(myScopeType)) {\n      searchScope = GlobalSearchScope.projectProductionScope(myProject);\n    }\n    else if (CallHierarchyBrowser.SCOPE_TEST.equals(myScopeType)) {\n      searchScope = GlobalSearchScope.projectTestScope(myProject);\n    }\n\n    final PsiClass originalClass = method.getContainingClass();\n    assert originalClass != null;\n    final PsiClassType originalType = JavaPsiFacade.getElementFactory(myProject).createType(originalClass);\n    final Set<PsiMethod> methodsToFind = new HashSet<PsiMethod>();\n    methodsToFind.add(method);\n    methodsToFind.addAll(Arrays.asList(method.findDeepestSuperMethods()));\n\n    final Map<PsiMember,CallHierarchyNodeDescriptor> methodToDescriptorMap = new HashMap<PsiMember, CallHierarchyNodeDescriptor>();\n    for (final PsiMethod methodToFind : methodsToFind) {\n      MethodReferencesSearch.search(methodToFind, searchScope, true).forEach(new Processor<PsiReference>() {\n        public boolean process(final PsiReference reference) {\n          if (reference instanceof PsiReferenceExpression) {\n            final PsiExpression qualifier = ((PsiReferenceExpression)reference).getQualifierExpression();\n            if (qualifier instanceof PsiSuperExpression) { // filter super.foo() call inside foo() and similar cases (bug 8411)\n              final PsiClass superClass = PsiUtil.resolveClassInType(qualifier.getType());\n              if (originalClass.isInheritor(superClass, true)) {\n                return true;\n              }\n            } if (qualifier != null) {\n              final PsiType qualifierType = qualifier.getType();\n              if (qualifierType == null) return true;\n              if (!TypeConversionUtil.isAssignable(qualifierType, originalType)) {\n                return true;\n              }\n            }\n          }\n          else {\n            if (!(reference instanceof PsiElement)) {\n              return true;\n            }\n\n            final PsiElement parent = ((PsiElement)reference).getParent();\n            if (parent instanceof PsiNewExpression) {\n              if (((PsiNewExpression)parent).getClassReference() != reference) {\n                return true;\n              }\n            }\n            else if (parent instanceof PsiAnonymousClass) {\n              if (((PsiAnonymousClass)parent).getBaseClassReference() != reference) {\n                return true;\n              }\n            }\n            else {\n              return true;\n            }\n          }\n\n          final PsiElement element = reference.getElement();\n          final PsiMember key = CallHierarchyNodeDescriptor.getEnclosingElement(element);\n\n          synchronized (methodToDescriptorMap) {\n            CallHierarchyNodeDescriptor d = methodToDescriptorMap.get(key);\n            if (d == null) {\n              d = new CallHierarchyNodeDescriptor(myProject, descriptor, element, false, true);\n              methodToDescriptorMap.put(key, d);\n            }\n            else {\n              d.incrementUsageCount();\n            }\n            d.addReference(reference);\n          }\n          return true;\n        }\n      });\n    }\n\n    return methodToDescriptorMap.values().toArray(new Object[methodToDescriptorMap.size()]);\n  }","id":42374,"modified_method":"protected final Object[] buildChildren(final HierarchyNodeDescriptor descriptor) {\n    final PsiMember enclosingElement = ((CallHierarchyNodeDescriptor)descriptor).getEnclosingElement();\n    if (!(enclosingElement instanceof PsiMethod)) {\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n    final PsiMethod method = (PsiMethod)enclosingElement;\n    final PsiMethod baseMethod = (PsiMethod)((CallHierarchyNodeDescriptor)getBaseDescriptor()).getTargetElement();\n    final SearchScope searchScope = getSearchScope(myScopeType, baseMethod.getContainingClass());\n\n    final PsiClass originalClass = method.getContainingClass();\n    assert originalClass != null;\n    final PsiClassType originalType = JavaPsiFacade.getElementFactory(myProject).createType(originalClass);\n    final Set<PsiMethod> methodsToFind = new HashSet<PsiMethod>();\n    methodsToFind.add(method);\n    methodsToFind.addAll(Arrays.asList(method.findDeepestSuperMethods()));\n\n    final Map<PsiMember,CallHierarchyNodeDescriptor> methodToDescriptorMap = new HashMap<PsiMember, CallHierarchyNodeDescriptor>();\n    for (final PsiMethod methodToFind : methodsToFind) {\n      MethodReferencesSearch.search(methodToFind, searchScope, true).forEach(new Processor<PsiReference>() {\n        public boolean process(final PsiReference reference) {\n          if (reference instanceof PsiReferenceExpression) {\n            final PsiExpression qualifier = ((PsiReferenceExpression)reference).getQualifierExpression();\n            if (qualifier instanceof PsiSuperExpression) { // filter super.foo() call inside foo() and similar cases (bug 8411)\n              final PsiClass superClass = PsiUtil.resolveClassInType(qualifier.getType());\n              if (originalClass.isInheritor(superClass, true)) {\n                return true;\n              }\n            } if (qualifier != null) {\n              final PsiType qualifierType = qualifier.getType();\n              if (qualifierType == null) return true;\n              if (!TypeConversionUtil.isAssignable(qualifierType, originalType)) {\n                return true;\n              }\n            }\n          }\n          else {\n            if (!(reference instanceof PsiElement)) {\n              return true;\n            }\n\n            final PsiElement parent = ((PsiElement)reference).getParent();\n            if (parent instanceof PsiNewExpression) {\n              if (((PsiNewExpression)parent).getClassReference() != reference) {\n                return true;\n              }\n            }\n            else if (parent instanceof PsiAnonymousClass) {\n              if (((PsiAnonymousClass)parent).getBaseClassReference() != reference) {\n                return true;\n              }\n            }\n            else {\n              return true;\n            }\n          }\n\n          final PsiElement element = reference.getElement();\n          final PsiMember key = CallHierarchyNodeDescriptor.getEnclosingElement(element);\n\n          synchronized (methodToDescriptorMap) {\n            CallHierarchyNodeDescriptor d = methodToDescriptorMap.get(key);\n            if (d == null) {\n              d = new CallHierarchyNodeDescriptor(myProject, descriptor, element, false, true);\n              methodToDescriptorMap.put(key, d);\n            }\n            else {\n              d.incrementUsageCount();\n            }\n            d.addReference(reference);\n          }\n          return true;\n        }\n      });\n    }\n\n    return methodToDescriptorMap.values().toArray(new Object[methodToDescriptorMap.size()]);\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HierarchyBrowserBaseEx(final Project project, final PsiElement element) {\n    super(project);\n\n    setHierarchyBase(element);\n\n    myCardLayout = new CardLayout();\n    myTreePanel = new JPanel(myCardLayout);\n\n    createTrees(myType2TreeMap);\n\n    final Enumeration<String> keys = myType2TreeMap.keys();\n    while (keys.hasMoreElements()) {\n      final String key = keys.nextElement();\n      final JTree tree = myType2TreeMap.get(key);\n      myOccurrenceNavigators.put(key, new OccurenceNavigatorSupport(tree) {\n        @Nullable\n        protected Navigatable createDescriptorForNode(DefaultMutableTreeNode node) {\n          final HierarchyNodeDescriptor descriptor = getDescriptor(node);\n          if (descriptor == null) return null;\n          PsiElement psiElement = getOpenFileElementFromDescriptor(descriptor);\n          if (psiElement == null || !psiElement.isValid()) return null;\n          final VirtualFile virtualFile = psiElement.getContainingFile().getVirtualFile();\n          if (virtualFile == null) return null;\n          return new OpenFileDescriptor(psiElement.getProject(), virtualFile, psiElement.getTextOffset());\n        }\n\n        public String getNextOccurenceActionName() {\n          return HierarchyBrowserBaseEx.this.getNextOccurenceActionNameImpl();\n        }\n\n        public String getPreviousOccurenceActionName() {\n          return HierarchyBrowserBaseEx.this.getPrevOccurenceActionNameImpl();\n        }\n      });\n      myTreePanel.add(new JScrollPane(tree), key);\n    }\n\n    final JPanel legendPanel = createLegendPanel();\n    final JPanel contentPanel;\n    if (legendPanel != null) {\n      contentPanel = new JPanel(new BorderLayout());\n      contentPanel.add(myTreePanel, BorderLayout.CENTER);\n      contentPanel.add(legendPanel, BorderLayout.SOUTH);\n    }\n    else {\n      contentPanel = myTreePanel;\n    }\n    buildUi(createToolbar(getActionPlace(), HELP_ID).getComponent(), contentPanel);\n  }","id":42375,"modified_method":"public HierarchyBrowserBaseEx(final Project project, final PsiElement element) {\n    super(project);\n\n    setHierarchyBase(element);\n\n    myCardLayout = new CardLayout();\n    myTreePanel = new JPanel(myCardLayout);\n\n    createTrees(myType2TreeMap);\n\n    for (String type : myType2TreeMap.keySet()) {\n      myType2ScopeMap.put(type, SCOPE_ALL);\n    }\n\n    final Enumeration<String> keys = myType2TreeMap.keys();\n    while (keys.hasMoreElements()) {\n      final String key = keys.nextElement();\n      final JTree tree = myType2TreeMap.get(key);\n      myOccurrenceNavigators.put(key, new OccurenceNavigatorSupport(tree) {\n        @Nullable\n        protected Navigatable createDescriptorForNode(DefaultMutableTreeNode node) {\n          final HierarchyNodeDescriptor descriptor = getDescriptor(node);\n          if (descriptor == null) return null;\n          PsiElement psiElement = getOpenFileElementFromDescriptor(descriptor);\n          if (psiElement == null || !psiElement.isValid()) return null;\n          final VirtualFile virtualFile = psiElement.getContainingFile().getVirtualFile();\n          if (virtualFile == null) return null;\n          return new OpenFileDescriptor(psiElement.getProject(), virtualFile, psiElement.getTextOffset());\n        }\n\n        public String getNextOccurenceActionName() {\n          return HierarchyBrowserBaseEx.this.getNextOccurenceActionNameImpl();\n        }\n\n        public String getPreviousOccurenceActionName() {\n          return HierarchyBrowserBaseEx.this.getPrevOccurenceActionNameImpl();\n        }\n      });\n      myTreePanel.add(new JScrollPane(tree), key);\n    }\n\n    final JPanel legendPanel = createLegendPanel();\n    final JPanel contentPanel;\n    if (legendPanel != null) {\n      contentPanel = new JPanel(new BorderLayout());\n      contentPanel.add(myTreePanel, BorderLayout.CENTER);\n      contentPanel.add(legendPanel, BorderLayout.SOUTH);\n    }\n    else {\n      contentPanel = myTreePanel;\n    }\n    buildUi(createToolbar(getActionPlace(), HELP_ID).getComponent(), contentPanel);\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected SubtypesHierarchyTreeStructure(final Project project, final HierarchyNodeDescriptor descriptor) {\n    super(project, descriptor);\n  }","id":42376,"modified_method":"protected SubtypesHierarchyTreeStructure(final Project project, final HierarchyNodeDescriptor descriptor, String currentScopeType) {\n    super(project, descriptor);\n    myCurrentScopeType = currentScopeType;\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SubtypesHierarchyTreeStructure(final Project project, final PsiClass psiClass) {\n    super(project, new TypeHierarchyNodeDescriptor(project, null, psiClass, true));\n  }","id":42377,"modified_method":"public SubtypesHierarchyTreeStructure(Project project, PsiClass psiClass, String currentScopeType) {\n    super(project, new TypeHierarchyNodeDescriptor(project, null, psiClass, true));\n    myCurrentScopeType = currentScopeType;\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final Object[] buildChildren(final HierarchyNodeDescriptor descriptor) {\n    final PsiClass psiClass = ((TypeHierarchyNodeDescriptor)descriptor).getPsiClass();\n    if (\"java.lang.Object\".equals(psiClass.getQualifiedName())) {\n      return new Object[]{IdeBundle.message(\"node.hierarchy.java.lang.object\")};\n    }\n    if (psiClass instanceof PsiAnonymousClass) return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    if (psiClass.hasModifierProperty(PsiModifier.FINAL)) return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    final List<PsiClass> classes = new ArrayList<PsiClass>(ClassInheritorsSearch.search(psiClass, psiClass.getUseScope(), false).findAll());\n    final HierarchyNodeDescriptor[] descriptors = new HierarchyNodeDescriptor[classes.size()];\n    for (int i = 0; i < classes.size(); i++) {\n      descriptors[i] = new TypeHierarchyNodeDescriptor(myProject, descriptor, classes.get(i), false);\n    }\n    return descriptors;\n  }","id":42378,"modified_method":"protected final Object[] buildChildren(final HierarchyNodeDescriptor descriptor) {\n    final PsiClass psiClass = ((TypeHierarchyNodeDescriptor)descriptor).getPsiClass();\n    if (\"java.lang.Object\".equals(psiClass.getQualifiedName())) {\n      return new Object[]{IdeBundle.message(\"node.hierarchy.java.lang.object\")};\n    }\n    if (psiClass instanceof PsiAnonymousClass) return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    if (psiClass.hasModifierProperty(PsiModifier.FINAL)) return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    final List<PsiClass> classes = new ArrayList<PsiClass>(ClassInheritorsSearch.search(psiClass, psiClass.getUseScope().intersectWith(getSearchScope(myCurrentScopeType, psiClass)), false).findAll());\n    final HierarchyNodeDescriptor[] descriptors = new HierarchyNodeDescriptor[classes.size()];\n    for (int i = 0; i < classes.size(); i++) {\n      descriptors[i] = new TypeHierarchyNodeDescriptor(myProject, descriptor, classes.get(i), false);\n    }\n    return descriptors;\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected HierarchyTreeStructure createHierarchyTreeStructure(@NotNull final String typeName, @NotNull final PsiElement psiElement) {\n    if (SUPERTYPES_HIERARCHY_TYPE.equals(typeName)) {\n      return new SupertypesHierarchyTreeStructure(myProject, (PsiClass)psiElement);\n    }\n    else if (SUBTYPES_HIERARCHY_TYPE.equals(typeName)) {\n      return new SubtypesHierarchyTreeStructure(myProject, (PsiClass)psiElement);\n    }\n    else if (TYPE_HIERARCHY_TYPE.equals(typeName)) {\n      return new TypeHierarchyTreeStructure(myProject, (PsiClass)psiElement);\n    }\n    else {\n      LOG.error(\"unexpected type: \" + typeName);\n      return null;\n    }\n  }","id":42379,"modified_method":"protected HierarchyTreeStructure createHierarchyTreeStructure(@NotNull final String typeName, @NotNull final PsiElement psiElement) {\n    if (SUPERTYPES_HIERARCHY_TYPE.equals(typeName)) {\n      return new SupertypesHierarchyTreeStructure(myProject, (PsiClass)psiElement);\n    }\n    else if (SUBTYPES_HIERARCHY_TYPE.equals(typeName)) {\n      return new SubtypesHierarchyTreeStructure(myProject, (PsiClass)psiElement, getCurrentScopeType());\n    }\n    else if (TYPE_HIERARCHY_TYPE.equals(typeName)) {\n      return new TypeHierarchyTreeStructure(myProject, (PsiClass)psiElement, getCurrentScopeType());\n    }\n    else {\n      LOG.error(\"unexpected type: \" + typeName);\n      return null;\n    }\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TypeHierarchyTreeStructure(final Project project, final PsiClass aClass) {\n    super(project, buildHierarchyElement(project, aClass));\n    setBaseElement(myBaseDescriptor); //to set myRoot\n  }","id":42380,"modified_method":"public TypeHierarchyTreeStructure(final Project project, final PsiClass aClass, String currentScopeType) {\n    super(project, buildHierarchyElement(project, aClass), currentScopeType);\n    setBaseElement(myBaseDescriptor); //to set myRoot\n  }","commit_id":"f9e3d4789791ec663b06a71990def3db9d841b19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testCatalog() throws Exception {\n        OASISCatalogManager catalogManager = new OASISCatalogManager();\n\n        URL jaxwscatalog = getClass().getResource(\"/META-INF/jax-ws-catalog.xml\");\n        assertNotNull(jaxwscatalog);\n\n        catalogManager.loadCatalog(jaxwscatalog);\n\n        Catalog catalogResolver = catalogManager.getCatalog();\n        assertNotNull(catalogResolver);\n\n        String xsd = \"http://www.w3.org/2005/08/addressing/ws-addr.xsd\";\n        String resolvedSchemaLocation = catalogResolver.resolveSystem(xsd);\n        assertEquals(\"classpath:/schemas/wsdl/ws-addr.xsd\", resolvedSchemaLocation);\n\n        ExtendedURIResolver resolver = new ExtendedURIResolver();\n        InputSource in = resolver.resolve(resolvedSchemaLocation, null);\n        assertTrue(in.getSystemId().indexOf(\"common\") != -1);\n        assertTrue(in.getSystemId().indexOf(\"/schemas/wsdl/ws-addr.xsd\") != -1);\n    }","id":42381,"modified_method":"@Test\n    public void testCatalog() throws Exception {\n        OASISCatalogManager catalogManager = new OASISCatalogManager();\n\n        URL jaxwscatalog = getClass().getResource(\"/META-INF/jax-ws-catalog.xml\");\n        assertNotNull(jaxwscatalog);\n\n        catalogManager.loadCatalog(jaxwscatalog);\n\n        String xsd = \"http://www.w3.org/2005/08/addressing/ws-addr.xsd\";\n        String resolvedSchemaLocation = catalogManager.resolveSystem(xsd);\n        assertEquals(\"classpath:/schemas/wsdl/ws-addr.xsd\", resolvedSchemaLocation);\n\n        ExtendedURIResolver resolver = new ExtendedURIResolver();\n        InputSource in = resolver.resolve(resolvedSchemaLocation, null);\n        assertTrue(in.getSystemId().indexOf(\"common\") != -1);\n        assertTrue(in.getSystemId().indexOf(\"/schemas/wsdl/ws-addr.xsd\") != -1);\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public CatalogWSDLLocator(String wsdlUrl, OASISCatalogManager catalogManager) {\n        this.baseUri = wsdlUrl;\n        this.catalogResolver = catalogManager.getCatalog();\n        this.resolver = new ExtendedURIResolver();\n    }","id":42382,"modified_method":"public CatalogWSDLLocator(String wsdlUrl, OASISCatalogManager catalogManager) {\n        this.baseUri = wsdlUrl;\n        this.manager = catalogManager;\n        this.resolver = new ExtendedURIResolver();\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public InputSource getImportInputSource(String parent, String importLocation) {\n        String resolvedImportLocation = null;\n        if (catalogResolver != null) {\n            try {\n                resolvedImportLocation = this.catalogResolver.resolveSystem(importLocation);\n                if (resolvedImportLocation == null) {\n                    resolvedImportLocation = catalogResolver.resolveURI(importLocation);\n                }\n                if (resolvedImportLocation == null) {\n                    resolvedImportLocation = catalogResolver.resolvePublic(importLocation, parent);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Catalog resolution failed\", e);\n            }\n        }\n\n        InputSource in = null;\n        if (resolvedImportLocation == null) {\n            in = this.resolver.resolve(importLocation, parent);\n        } else {\n            in = this.resolver.resolve(resolvedImportLocation, null);\n        }\n\n        // XXX: If we return null (as per javadoc), a NPE is raised in WSDL4J code.\n        // So let's return new InputSource() and let WSDL4J fail. Optionally, \n        // we can throw a similar exception as in CatalogXmlSchemaURIResolver.\n        if (in == null) {\n            in = new InputSource();\n        }\n\n        return in;\n    }","id":42383,"modified_method":"public InputSource getImportInputSource(String parent, String importLocation) {\n        String resolvedImportLocation = null;\n        if (manager != null) {\n            try {\n                resolvedImportLocation = this.manager.resolveSystem(importLocation);\n                if (resolvedImportLocation == null) {\n                    resolvedImportLocation = manager.resolveURI(importLocation);\n                }\n                if (resolvedImportLocation == null) {\n                    resolvedImportLocation = manager.resolvePublic(importLocation, parent);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Catalog resolution failed\", e);\n            }\n        }\n\n        InputSource in = null;\n        if (resolvedImportLocation == null) {\n            in = this.resolver.resolve(importLocation, parent);\n        } else {\n            in = this.resolver.resolve(resolvedImportLocation, null);\n        }\n\n        // XXX: If we return null (as per javadoc), a NPE is raised in WSDL4J code.\n        // So let's return new InputSource() and let WSDL4J fail. Optionally, \n        // we can throw a similar exception as in CatalogXmlSchemaURIResolver.\n        if (in == null) {\n            in = new InputSource();\n        }\n\n        return in;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public CatalogWSDLLocator(String wsdlUrl, Bus b) {\n        this.baseUri = wsdlUrl;\n        this.catalogResolver = OASISCatalogManager.getCatalogManager(b).getCatalog();\n        this.resolver = new TransportURIResolver(b);\n    }","id":42384,"modified_method":"public CatalogWSDLLocator(String wsdlUrl, Bus b) {\n        this.baseUri = wsdlUrl;\n        this.manager = OASISCatalogManager.getCatalogManager(b);\n        this.resolver = new TransportURIResolver(b);\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public InputSource getBaseInputSource() {\n        InputSource result = null;\n        if (catalogResolver != null) {\n            try {\n                String s = catalogResolver.resolveSystem(baseUri);\n                if (s != null) {\n                    result = resolver.resolve(s, null);\n                }\n            } catch (MalformedURLException e) {\n                //ignore\n            } catch (IOException e) {\n                //ignore\n            }\n        }\n        if (result == null) {\n            result = resolver.resolve(baseUri, null);\n        }\n        if (wsdlUrl == null\n            && result != null) {\n            wsdlUrl = result.getSystemId();\n        }\n        baseUri = resolver.getURI();\n        return result;\n    }","id":42385,"modified_method":"public InputSource getBaseInputSource() {\n        InputSource result = null;\n        if (manager != null) {\n            try {\n                String s = manager.resolveSystem(baseUri);\n                if (s != null) {\n                    result = resolver.resolve(s, null);\n                }\n            } catch (MalformedURLException e) {\n                //ignore\n            } catch (IOException e) {\n                //ignore\n            }\n        }\n        if (result == null) {\n            result = resolver.resolve(baseUri, null);\n        }\n        if (wsdlUrl == null\n            && result != null) {\n            wsdlUrl = result.getSystemId();\n        }\n        baseUri = resolver.getURI();\n        return result;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public CatalogXmlSchemaURIResolver(Bus bus) {\n        this(OASISCatalogManager.getCatalogManager(bus));\n        this.resolver = new TransportURIResolver(bus);\n        this.catalogResolver = OASISCatalogManager.getCatalogManager(bus).getCatalog();\n    }","id":42386,"modified_method":"public CatalogXmlSchemaURIResolver(Bus bus) {\n        this(OASISCatalogManager.getCatalogManager(bus));\n        this.resolver = new TransportURIResolver(bus);\n        this.catalogResolver = OASISCatalogManager.getCatalogManager(bus);\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public CatalogXmlSchemaURIResolver(OASISCatalogManager catalogManager) {\n        this.resolver = new ExtendedURIResolver();\n        this.catalogResolver = catalogManager.getCatalog();\n    }","id":42387,"modified_method":"public CatalogXmlSchemaURIResolver(OASISCatalogManager catalogManager) {\n        this.resolver = new ExtendedURIResolver();\n        this.catalogResolver = catalogManager;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public InputSource resolveEntity(String targetNamespace, String schemaLocation, String baseUri) {\n        String resolvedSchemaLocation = null;\n        try {\n            resolvedSchemaLocation = this.catalogResolver.resolveSystem(schemaLocation);\n            \n            if (resolvedSchemaLocation == null) {\n                resolvedSchemaLocation = catalogResolver.resolveURI(schemaLocation);\n            }\n            if (resolvedSchemaLocation == null) {\n                resolvedSchemaLocation = catalogResolver.resolvePublic(schemaLocation, baseUri);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Catalog resolution failed\", e);\n        }\n\n        InputSource in = null;\n        if (resolvedSchemaLocation == null) {\n            in = this.resolver.resolve(schemaLocation, baseUri);\n        } else {\n            resolved.put(schemaLocation, resolvedSchemaLocation);\n            in = this.resolver.resolve(resolvedSchemaLocation, baseUri);\n        }\n\n        // XXX: If we return null, a NPE is raised in SchemaBuilder.\n        // If we return new InputSource(), a XmlSchemaException is raised\n        // but without any nice error message. So let's just throw a nice error here.\n        if (in == null) {\n            throw new XmlSchemaException(\"Unable to locate imported document \"\n                                         + \"at '\" + schemaLocation + \"'\"\n                                         + (baseUri == null\n                                            ? \".\"\n                                            : \", relative to '\" + baseUri + \"'.\"));\n        } else if (in.getByteStream() != null\n            && !(in.getByteStream() instanceof ByteArrayInputStream)) {\n            //workaround bug in XmlSchema - XmlSchema is not closing the InputStreams\n            //that are returned for imports.  Thus, with a lot of services starting up \n            //or a lot of schemas imported or similar, it's easy to run out of\n            //file handles.  We'll just load the file into a byte[] and return that.\n            try {\n                InputStream ins = IOUtils.loadIntoBAIS(in.getByteStream());\n                in.setByteStream(ins);\n            } catch (IOException e) {\n                throw new XmlSchemaException(\"Unable to load imported document \"\n                                             + \"at '\" + schemaLocation + \"'\"\n                                             + (baseUri == null\n                                                ? \".\"\n                                                : \", relative to '\" + baseUri + \"'.\"),\n                                                e);\n            }\n        }\n\n        return in;\n    }","id":42388,"modified_method":"public InputSource resolveEntity(String targetNamespace, String schemaLocation, String baseUri) {\n        \n        String resolvedSchemaLocation = null;\n        if (this.catalogResolver != null) {\n            try {\n                resolvedSchemaLocation = this.catalogResolver.resolveSystem(schemaLocation);\n                \n                if (resolvedSchemaLocation == null) {\n                    resolvedSchemaLocation = catalogResolver.resolveURI(schemaLocation);\n                }\n                if (resolvedSchemaLocation == null) {\n                    resolvedSchemaLocation = catalogResolver.resolvePublic(schemaLocation, baseUri);\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Catalog resolution failed\", e);\n            }\n        }\n        InputSource in = null;\n        if (resolvedSchemaLocation == null) {\n            in = this.resolver.resolve(schemaLocation, baseUri);\n        } else {\n            resolved.put(schemaLocation, resolvedSchemaLocation);\n            in = this.resolver.resolve(resolvedSchemaLocation, baseUri);\n        }\n\n        // XXX: If we return null, a NPE is raised in SchemaBuilder.\n        // If we return new InputSource(), a XmlSchemaException is raised\n        // but without any nice error message. So let's just throw a nice error here.\n        if (in == null) {\n            throw new XmlSchemaException(\"Unable to locate imported document \"\n                                         + \"at '\" + schemaLocation + \"'\"\n                                         + (baseUri == null\n                                            ? \".\"\n                                            : \", relative to '\" + baseUri + \"'.\"));\n        } else if (in.getByteStream() != null\n            && !(in.getByteStream() instanceof ByteArrayInputStream)) {\n            //workaround bug in XmlSchema - XmlSchema is not closing the InputStreams\n            //that are returned for imports.  Thus, with a lot of services starting up \n            //or a lot of schemas imported or similar, it's easy to run out of\n            //file handles.  We'll just load the file into a byte[] and return that.\n            try {\n                InputStream ins = IOUtils.loadIntoBAIS(in.getByteStream());\n                in.setByteStream(ins);\n            } catch (IOException e) {\n                throw new XmlSchemaException(\"Unable to load imported document \"\n                                             + \"at '\" + schemaLocation + \"'\"\n                                             + (baseUri == null\n                                                ? \".\"\n                                                : \", relative to '\" + baseUri + \"'.\"),\n                                                e);\n            }\n        }\n\n        return in;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"private String resolveByCatalog(String url) {\n        if (StringUtils.isEmpty(url)) {\n            return null;\n        }\n        Bus bus = (Bus)env.get(Bus.class);\n        Catalog catalogResolver = OASISCatalogManager.getCatalogManager(bus).getCatalog();\n        if (catalogResolver == null) {\n            return null;\n        }\n        String resolvedLocation;\n        try {\n            resolvedLocation = catalogResolver.resolveSystem(url);\n            if (resolvedLocation == null) {\n                resolvedLocation = catalogResolver.resolveURI(url);\n            }\n        } catch (Exception e1) {\n            Message msg = new Message(\"FAILED_RESOLVE_CATALOG\", LOG, url);\n            throw new ToolException(msg, e1);\n        }\n        return resolvedLocation;\n    }","id":42389,"modified_method":"private String resolveByCatalog(String url) {\n        if (StringUtils.isEmpty(url)) {\n            return null;\n        }\n        Bus bus = (Bus)env.get(Bus.class);\n        OASISCatalogManager catalogResolver = OASISCatalogManager.getCatalogManager(bus);\n        if (catalogResolver == null) {\n            return null;\n        }\n        String resolvedLocation;\n        try {\n            resolvedLocation = catalogResolver.resolveSystem(url);\n            if (resolvedLocation == null) {\n                resolvedLocation = catalogResolver.resolveURI(url);\n            }\n        } catch (Exception e1) {\n            Message msg = new Message(\"FAILED_RESOLVE_CATALOG\", LOG, url);\n            throw new ToolException(msg, e1);\n        }\n        return resolvedLocation;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public void setCatalogResolver(final Catalog cr) {\n        this.catalogResolver = cr;\n    }","id":42390,"modified_method":"public void setCatalogResolver(final OASISCatalogManager cr) {\n        this.catalogResolver = cr;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"private Definition buildCustomizedDefinition() throws Exception {      \n        Map<String, Element> eleMap = cusParser.getCustomizedWSDLElements();        \n        String wsdlUrl = URIParserUtil.getAbsoluteURI((String)context.get(ToolConstants.CFG_WSDLURL));\n        CustomizedWSDLLocator wsdlLocator = new CustomizedWSDLLocator(wsdlUrl, eleMap);\n        wsdlLocator.setCatalogResolver(OASISCatalogManager.getCatalogManager(bus).getCatalog());\n        \n        WSDLManager mgr = bus.getExtension(WSDLManager.class);\n        WSDLReader reader = mgr.getWSDLFactory().newWSDLReader();\n        reader.setFeature(\"javax.wsdl.verbose\", false);\n        reader.setExtensionRegistry(mgr.getExtensionRegistry());       \n\n        return reader.readWSDL(wsdlLocator);\n    }","id":42391,"modified_method":"private Definition buildCustomizedDefinition() throws Exception {      \n        Map<String, Element> eleMap = cusParser.getCustomizedWSDLElements();        \n        String wsdlUrl = URIParserUtil.getAbsoluteURI((String)context.get(ToolConstants.CFG_WSDLURL));\n        CustomizedWSDLLocator wsdlLocator = new CustomizedWSDLLocator(wsdlUrl, eleMap);\n        wsdlLocator.setCatalogResolver(OASISCatalogManager.getCatalogManager(bus));\n        \n        WSDLManager mgr = bus.getExtension(WSDLManager.class);\n        WSDLReader reader = mgr.getWSDLFactory().newWSDLReader();\n        reader.setFeature(\"javax.wsdl.verbose\", false);\n        reader.setExtensionRegistry(mgr.getExtensionRegistry());       \n\n        return reader.readWSDL(wsdlLocator);\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public void loadCatalogs(ClassLoader classLoader, String name) throws IOException {\n        if (classLoader == null) {\n            return;\n        }\n\n        Enumeration<URL> catalogs = classLoader.getResources(name);\n        while (catalogs.hasMoreElements()) {\n            URL catalogURL = catalogs.nextElement();\n            if (!loadedCatalogs.contains(catalogURL)) {\n                this.resolver.parseCatalog(catalogURL);\n                loadedCatalogs.add(catalogURL);\n            }\n        }\n    }","id":42392,"modified_method":"public void loadCatalogs(ClassLoader classLoader, String name) throws IOException {\n        if (classLoader == null || resolver == null) {\n            return;\n        }\n\n        Enumeration<URL> catalogs = classLoader.getResources(name);\n        while (catalogs.hasMoreElements()) {\n            URL catalogURL = catalogs.nextElement();\n            if (!loadedCatalogs.contains(catalogURL)) {\n                ((Catalog)resolver).parseCatalog(catalogURL);\n                loadedCatalogs.add(catalogURL);\n            }\n        }\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public static OASISCatalogManager getCatalogManager(Bus bus) {\n        if (bus == null) {\n            return getContextCatalog();\n        }\n        OASISCatalogManager catalog = bus.getExtension(OASISCatalogManager.class);\n        if (catalog == null) {\n            return getContextCatalog();\n        } else {\n            return catalog;\n        }\n    }","id":42393,"modified_method":"public static OASISCatalogManager getCatalogManager(Bus bus) {\n        if (bus == null) {\n            return getContextCatalog();\n        }\n        OASISCatalogManager catalog = bus.getExtension(OASISCatalogManager.class);\n        if (catalog == null) {\n            catalog = getContextCatalog();\n            if (catalog != null) {\n                bus.setExtension(catalog, OASISCatalogManager.class);\n            }\n        } \n        return catalog;\n        \n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public OASISCatalogManager() {\n        CatalogManager catalogManager = new CatalogManager();\n        if (DEBUG_LEVEL != null) {\n            catalogManager.debug.setDebug(Integer.parseInt(DEBUG_LEVEL));\n        }\n        catalogManager.setUseStaticCatalog(false);\n        catalogManager.setIgnoreMissingProperties(true);\n        CatalogResolver catalogResolver = new CatalogResolver(catalogManager);\n        this.resolver = catalogResolver.getCatalog();\n    }","id":42394,"modified_method":"public OASISCatalogManager() {\n        resolver = getResolver();\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"public void loadCatalog(URL catalogURL) throws IOException {\n        if (!loadedCatalogs.contains(catalogURL)) {\n            if (\"file\".equals(catalogURL.getProtocol())) {\n                try {\n                    File file = new File(catalogURL.toURI());\n                    if (!file.exists()) {\n                        throw new FileNotFoundException(file.getAbsolutePath());\n                    }\n                } catch (URISyntaxException e) {\n                    //just process as is\n                }\n            }\n\n            this.resolver.parseCatalog(catalogURL);\n\n            loadedCatalogs.add(catalogURL);\n        }\n    }","id":42395,"modified_method":"public void loadCatalog(URL catalogURL) throws IOException {\n        if (!loadedCatalogs.contains(catalogURL) && resolver != null) {\n            if (\"file\".equals(catalogURL.getProtocol())) {\n                try {\n                    File file = new File(catalogURL.toURI());\n                    if (!file.exists()) {\n                        throw new FileNotFoundException(file.getAbsolutePath());\n                    }\n                } catch (URISyntaxException e) {\n                    //just process as is\n                }\n            }\n\n            ((Catalog)resolver).parseCatalog(catalogURL);\n\n            loadedCatalogs.add(catalogURL);\n        }\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"private static OASISCatalogManager getContextCatalog() {\n        OASISCatalogManager oasisCatalog = new OASISCatalogManager();\n        oasisCatalog.loadContextCatalogs();\n        return oasisCatalog;\n    }","id":42396,"modified_method":"private static OASISCatalogManager getContextCatalog() {\n        try {\n            OASISCatalogManager oasisCatalog = new OASISCatalogManager();\n            oasisCatalog.loadContextCatalogs();\n            return oasisCatalog;\n        } catch (Throwable ex) {\n            return null;\n        }\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"private Document getWSDLDoc(String wsdl) {\n        LOG.log(Level.FINE, new Message(\"VALIDATE_WSDL\", LOG, wsdl).toString());\n        try {\n            Catalog catalogResolver = OASISCatalogManager.getCatalogManager(this.getBus()).getCatalog();\n\n            String nw = catalogResolver.resolveSystem(wsdl);\n            if (nw == null) {\n                nw = catalogResolver.resolveURI(wsdl);\n            }\n            if (nw == null) {\n                nw = catalogResolver.resolvePublic(wsdl, null);\n            }\n            if (nw == null) {\n                nw = wsdl;\n            }\n            return new Stax2DOM().getDocument(URIParserUtil.getAbsoluteURI(nw));\n        } catch (FileNotFoundException fe) {\n            LOG.log(Level.WARNING, \"Cannot find the wsdl \" + wsdl + \"to validate\");\n            return null;\n        } catch (Exception e) {\n            throw new ToolException(e);\n        }\n    }","id":42397,"modified_method":"private Document getWSDLDoc(String wsdl) {\n        LOG.log(Level.FINE, new Message(\"VALIDATE_WSDL\", LOG, wsdl).toString());\n        try {\n            OASISCatalogManager catalogResolver = OASISCatalogManager.getCatalogManager(this.getBus());\n\n            String nw = catalogResolver.resolveSystem(wsdl);\n            if (nw == null) {\n                nw = catalogResolver.resolveURI(wsdl);\n            }\n            if (nw == null) {\n                nw = catalogResolver.resolvePublic(wsdl, null);\n            }\n            if (nw == null) {\n                nw = wsdl;\n            }\n            return new Stax2DOM().getDocument(URIParserUtil.getAbsoluteURI(nw));\n        } catch (FileNotFoundException fe) {\n            LOG.log(Level.WARNING, \"Cannot find the wsdl \" + wsdl + \"to validate\");\n            return null;\n        } catch (Exception e) {\n            throw new ToolException(e);\n        }\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"static String resolveWithCatalogs(OASISCatalogManager catalogs, String start, String base) {\n        String resolvedSchemaLocation = null;\n        try {\n            resolvedSchemaLocation = catalogs.getCatalog().resolveSystem(start);\n            if (resolvedSchemaLocation == null) {\n                resolvedSchemaLocation = catalogs.getCatalog().resolveURI(start);\n            }\n            if (resolvedSchemaLocation == null) {\n                resolvedSchemaLocation = catalogs.getCatalog().resolvePublic(start, base);\n            }\n        } catch (Exception ex) {\n            //ignore\n        }\n        return resolvedSchemaLocation;\n    }","id":42398,"modified_method":"static String resolveWithCatalogs(OASISCatalogManager catalogs, String start, String base) {\n        if (catalogs == null) {\n            return null;\n        }\n        String resolvedSchemaLocation = null;\n        try {\n            resolvedSchemaLocation = catalogs.resolveSystem(start);\n            if (resolvedSchemaLocation == null) {\n                resolvedSchemaLocation = catalogs.resolveURI(start);\n            }\n            if (resolvedSchemaLocation == null) {\n                resolvedSchemaLocation = catalogs.resolvePublic(start, base);\n            }\n        } catch (Exception ex) {\n            //ignore\n        }\n        return resolvedSchemaLocation;\n    }","commit_id":"77535e4928803bbdd718efb7541dbd07d318848b","url":"https://github.com/apache/cxf"},{"original_method":"private List translateDependencies( List v3Deps )\n    {\n        List deps = new ArrayList();\n\n        if ( notEmpty( v3Deps ) )\n        {\n            for ( Iterator it = v3Deps.iterator(); it.hasNext(); )\n            {\n                org.apache.maven.model.v3_0_0.Dependency v3Dep = (org.apache.maven.model.v3_0_0.Dependency) it.next();\n\n                String groupId = format( v3Dep.getGroupId() );\n                String artifactId = format( v3Dep.getArtifactId() );\n\n                String id = v3Dep.getId();\n\n                if ( StringUtils.isNotEmpty( id ) )\n                {\n                    if ( StringUtils.isEmpty( groupId ) )\n                    {\n                        int plusIdx = id.indexOf( \"+\" );\n\n                        if ( plusIdx > -1 )\n                        {\n                            groupId = id.substring( 0, plusIdx );\n                        }\n                        else\n                        {\n                            groupId = id;\n                        }\n                    }\n\n                    if ( StringUtils.isEmpty( artifactId ) )\n                    {\n                        artifactId = format( id );\n                    }\n                }\n\n                String type = v3Dep.getType();\n                if ( \"plugin\".equals( type ) )\n                {\n                    if ( \"maven\".equals( groupId ) )\n                    {\n                        groupId = \"org.apache.maven.plugins\";\n                    }\n\n                    Plugin plugin = new Plugin();\n                    plugin.setGroupId( groupId );\n                    plugin.setArtifactId( artifactId );\n                    plugin.setVersion( format( v3Dep.getVersion() ) );\n\n                    Xpp3Dom config = new Xpp3Dom( \"configuration\" );\n\n                    Properties props = v3Dep.getProperties();\n\n                    if ( !props.isEmpty() )\n                    {\n                        for ( Iterator propertyIterator = props.keySet().iterator(); propertyIterator.hasNext(); )\n                        {\n                            String key = (String) propertyIterator.next();\n                            String value = props.getProperty( key );\n\n                            Xpp3Dom child = new Xpp3Dom( key );\n                            child.setValue( value );\n\n                            config.addChild( child );\n                        }\n                    }\n\n                    plugin.setConfiguration( config );\n\n                    this.discoveredPlugins.add( plugin );\n                }\n                else\n                {\n                    Dependency dep = new Dependency();\n\n                    dep.setGroupId( groupId );\n                    dep.setArtifactId( artifactId );\n                    dep.setVersion( v3Dep.getVersion() );\n                    dep.setType( v3Dep.getType() );\n\n                    String scope = v3Dep.getProperty( \"scope\" );\n                    if ( StringUtils.isNotEmpty( scope ) )\n                    {\n                        dep.setScope( scope );\n                    }\n\n                    String optional = v3Dep.getProperty( \"optional\" );\n                    if ( StringUtils.isNotEmpty( optional ) )\n                    {\n                        dep.setOptional( Boolean.parseBoolean( optional ) );\n                    }\n\n                    deps.add( dep );\n                }\n            }\n        }\n\n        return deps;\n    }","id":42399,"modified_method":"private List translateDependencies( List v3Deps )\n    {\n        List deps = new ArrayList();\n\n        if ( notEmpty( v3Deps ) )\n        {\n            for ( Iterator it = v3Deps.iterator(); it.hasNext(); )\n            {\n                org.apache.maven.model.v3_0_0.Dependency v3Dep = (org.apache.maven.model.v3_0_0.Dependency) it.next();\n\n                String groupId = format( v3Dep.getGroupId() );\n                String artifactId = format( v3Dep.getArtifactId() );\n\n                String id = v3Dep.getId();\n\n                if ( StringUtils.isNotEmpty( id ) )\n                {\n                    if ( StringUtils.isEmpty( groupId ) )\n                    {\n                        int plusIdx = id.indexOf( \"+\" );\n\n                        if ( plusIdx > -1 )\n                        {\n                            groupId = id.substring( 0, plusIdx );\n                        }\n                        else\n                        {\n                            groupId = id;\n                        }\n                    }\n\n                    if ( StringUtils.isEmpty( artifactId ) )\n                    {\n                        artifactId = format( id );\n                    }\n                }\n\n                String type = v3Dep.getType();\n                if ( \"plugin\".equals( type ) )\n                {\n                    if ( \"maven\".equals( groupId ) )\n                    {\n                        groupId = \"org.apache.maven.plugins\";\n                    }\n\n                    Plugin plugin = new Plugin();\n                    plugin.setGroupId( groupId );\n                    plugin.setArtifactId( artifactId );\n                    plugin.setVersion( format( v3Dep.getVersion() ) );\n\n                    Xpp3Dom config = new Xpp3Dom( \"configuration\" );\n\n                    Properties props = v3Dep.getProperties();\n\n                    if ( !props.isEmpty() )\n                    {\n                        for ( Iterator propertyIterator = props.keySet().iterator(); propertyIterator.hasNext(); )\n                        {\n                            String key = (String) propertyIterator.next();\n                            String value = props.getProperty( key );\n\n                            Xpp3Dom child = new Xpp3Dom( key );\n                            child.setValue( value );\n\n                            config.addChild( child );\n                        }\n                    }\n\n                    plugin.setConfiguration( config );\n\n                    this.discoveredPlugins.add( plugin );\n                }\n                else\n                {\n                    Dependency dep = new Dependency();\n\n                    dep.setGroupId( groupId );\n                    dep.setArtifactId( artifactId );\n                    dep.setVersion( v3Dep.getVersion() );\n                    dep.setType( v3Dep.getType() );\n\n                    String scope = v3Dep.getProperty( \"scope\" );\n                    if ( StringUtils.isNotEmpty( scope ) )\n                    {\n                        dep.setScope( scope );\n                    }\n\n                    String optional = v3Dep.getProperty( \"optional\" );\n                    if ( StringUtils.isNotEmpty( optional ) )\n                    {\n                        dep.setOptional( Boolean.valueOf( optional ).booleanValue() );\n                    }\n\n                    deps.add( dep );\n                }\n            }\n        }\n\n        return deps;\n    }","commit_id":"1b54300da4c5e7e7a2c86fd8279a9dd59b6470c0","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Retrieve a property as a boolan.\n     *\n     * @param properties the properties to retrieve the value from\n     * @param property the name of the property to retrieve\n     * @param dflt the default value\n     * @return the property as a boolean or the default value\n     */\n    boolean getBoolean(Dictionary properties, String property, boolean dflt)\n    {\n        String value = (String) properties.get(property);\n        if (value != null)\n        {\n            return Boolean.parseBoolean(value);\n        }\n        return dflt;\n    }","id":42400,"modified_method":"/**\n     * Retrieve a property as a boolan.\n     *\n     * @param properties the properties to retrieve the value from\n     * @param property the name of the property to retrieve\n     * @param dflt the default value\n     * @return the property as a boolean or the default value\n     */\n    boolean getBoolean(Dictionary properties, String property, boolean dflt)\n    {\n        String value = (String) properties.get(property);\n        if (value != null)\n        {\n            return Boolean.valueOf(value).booleanValue();\n        }\n        return dflt;\n    }","commit_id":"540f6af94f5972babb500da79c0545c34df79816","url":"https://github.com/apache/felix"},{"original_method":"private Bundle update(Artifact artifact)\n    {\n        Bundle bundle = null;\n        try\n        {\n            File path = artifact.getPath();\n            // If the listener is an installer, ask for an update\n            if (artifact.getListener() instanceof ArtifactInstaller)\n            {\n                ((ArtifactInstaller) artifact.getListener()).update(path);\n            }\n            // else we need to ask for an update on the bundle\n            else if (artifact.getListener() instanceof ArtifactTransformer)\n            {\n                File transformed = artifact.getTransformed();\n                bundle = context.getBundle(artifact.getBundleId());\n                if (bundle == null)\n                {\n                    log(\"Failed to update bundle: \"\n                        + path + \" with ID \"\n                        + artifact.getBundleId()\n                        + \". The bundle has been uninstalled\", null);\n                    return null;\n                }\n                InputStream in = new FileInputStream(transformed != null ? transformed : path);\n                try\n                {\n                    bundle.update(in);\n                }\n                finally\n                {\n                    in.close();\n                }\n            }\n            artifact.setLastModified(Util.getLastModified(path));\n            log(\"Updated \" + path, null);\n        }\n        catch (Exception e)\n        {\n            log(\"Failed to update artifact \" + artifact.getPath(), e);\n        }\n        return bundle;\n    }","id":42401,"modified_method":"private Bundle update(Artifact artifact)\n    {\n        Bundle bundle = null;\n        try\n        {\n            File path = artifact.getPath();\n            // If the listener is an installer, ask for an update\n            if (artifact.getListener() instanceof ArtifactInstaller)\n            {\n                ((ArtifactInstaller) artifact.getListener()).update(path);\n            }\n            // else we need to ask for an update on the bundle\n            else if (artifact.getListener() instanceof ArtifactTransformer)\n            {\n                File transformed = artifact.getTransformed();\n                bundle = context.getBundle(artifact.getBundleId());\n                if (bundle == null)\n                {\n                    log(\"Failed to update bundle: \"\n                        + path + \" with ID \"\n                        + artifact.getBundleId()\n                        + \". The bundle has been uninstalled\", null);\n                    return null;\n                }\n                InputStream in = new FileInputStream(transformed != null ? transformed : path);\n                try\n                {\n                    bundle.update(in);\n                }\n                finally\n                {\n                    in.close();\n                }\n            }\n            artifact.setLastModified(Util.getLastModified(path));\n            log(\"Updated \" + path, null);\n        }\n        catch (Throwable t)\n        {\n            log(\"Failed to update artifact \" + artifact.getPath(), t);\n        }\n        return bundle;\n    }","commit_id":"540f6af94f5972babb500da79c0545c34df79816","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Initialize the list of known files.\n     * This should be called before the first scan to initialize\n     * the list of known files.  The purpose is to be able to detect\n     * files that have been deleted while the scanner was inactive.\n     *\n     * @param files a list of known files\n     */\n    public void initialize(Collection/*<File>*/ files)\n    {\n        for (Iterator it = files.iterator(); it.hasNext();)\n        {\n            storedChecksums.put(it.next(), Long.valueOf(0));\n        }\n    }","id":42402,"modified_method":"/**\n     * Initialize the list of known files.\n     * This should be called before the first scan to initialize\n     * the list of known files.  The purpose is to be able to detect\n     * files that have been deleted while the scanner was inactive.\n     *\n     * @param files a list of known files\n     */\n    public void initialize(Collection/*<File>*/ files)\n    {\n        for (Iterator it = files.iterator(); it.hasNext();)\n        {\n            storedChecksums.put(it.next(), new Long(0));\n        }\n    }","commit_id":"540f6af94f5972babb500da79c0545c34df79816","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Report a set of new, modified or deleted files.\n     * Modifications are checked against a computed checksum on some file\n     * attributes to detect any modification.\n     * Upon restart, such checksums are not known so that all files will\n     * be reported as modified. \n     *\n     * @param reportImmediately report all files immediately without waiting for the checksum to be stable\n     * @return a list of changes on the files included in the directory\n     */\n    public Set/*<File>*/ scan(boolean reportImmediately)\n    {\n        File[] list = directory.listFiles(filter);\n        if (list == null)\n        {\n            return null;\n        }\n        Set/*<File>*/ files = new HashSet/*<File>*/();\n        Set/*<File>*/ removed = new HashSet/*<File>*/(storedChecksums.keySet());\n        for (int i = 0; i < list.length; i++)\n        {\n            File file  = list[i];\n            long lastChecksum = lastChecksums.get(file) != null ? ((Long) lastChecksums.get(file)).longValue() : 0;\n            long storedChecksum = storedChecksums.get(file) != null ? ((Long) storedChecksums.get(file)).longValue() : 0;\n            long newChecksum = checksum(file);\n            lastChecksums.put(file, Long.valueOf(newChecksum));\n            // Only handle file when it does not change anymore and it has changed since last reported\n            if ((newChecksum == lastChecksum || reportImmediately) && newChecksum != storedChecksum)\n            {\n                storedChecksums.put(file, Long.valueOf(newChecksum));\n                files.add(file);\n            }\n            removed.remove(file);\n        }\n        for (Iterator it = removed.iterator(); it.hasNext();)\n        {\n            File file = (File) it.next();\n            // Make sure we'll handle a file that has been deleted\n            files.addAll(removed);\n            // Remove no longer used checksums\n            lastChecksums.remove(file);\n            storedChecksums.remove(file);\n        }\n        return files;\n    }","id":42403,"modified_method":"/**\n     * Report a set of new, modified or deleted files.\n     * Modifications are checked against a computed checksum on some file\n     * attributes to detect any modification.\n     * Upon restart, such checksums are not known so that all files will\n     * be reported as modified. \n     *\n     * @param reportImmediately report all files immediately without waiting for the checksum to be stable\n     * @return a list of changes on the files included in the directory\n     */\n    public Set/*<File>*/ scan(boolean reportImmediately)\n    {\n        File[] list = directory.listFiles(filter);\n        if (list == null)\n        {\n            return null;\n        }\n        Set/*<File>*/ files = new HashSet/*<File>*/();\n        Set/*<File>*/ removed = new HashSet/*<File>*/(storedChecksums.keySet());\n        for (int i = 0; i < list.length; i++)\n        {\n            File file  = list[i];\n            long lastChecksum = lastChecksums.get(file) != null ? ((Long) lastChecksums.get(file)).longValue() : 0;\n            long storedChecksum = storedChecksums.get(file) != null ? ((Long) storedChecksums.get(file)).longValue() : 0;\n            long newChecksum = checksum(file);\n            lastChecksums.put(file, new Long(newChecksum));\n            // Only handle file when it does not change anymore and it has changed since last reported\n            if ((newChecksum == lastChecksum || reportImmediately) && newChecksum != storedChecksum)\n            {\n                storedChecksums.put(file, new Long(newChecksum));\n                files.add(file);\n            }\n            removed.remove(file);\n        }\n        for (Iterator it = removed.iterator(); it.hasNext();)\n        {\n            File file = (File) it.next();\n            // Make sure we'll handle a file that has been deleted\n            files.addAll(removed);\n            // Remove no longer used checksums\n            lastChecksums.remove(file);\n            storedChecksums.remove(file);\n        }\n        return files;\n    }","commit_id":"540f6af94f5972babb500da79c0545c34df79816","url":"https://github.com/apache/felix"},{"original_method":"private void init(Properties config) {\n        boolean newInstance = Boolean.parseBoolean( config.getProperty( NEW_INSTANCE, \"false\" ) );\n        int secondsToRefresh = Integer.parseInt( config.getProperty( POLL_INTERVAL, \"-1\" ) );\n\n        providers = new ArrayList();\n\n        for ( Iterator iter = config.keySet().iterator(); iter.hasNext(); ) {\n            String key = (String) iter.next();\n            PackageProvider prov = getProvider( key, config );\n            if (prov != null) {\n                providers.add( prov ) ;\n            }\n        }\n\n        configure( newInstance, providers, secondsToRefresh );\n    }","id":42404,"modified_method":"private void init(Properties config) {\n        \n        boolean newInstance = Boolean.valueOf( config.getProperty( NEW_INSTANCE, \"false\" ) ).booleanValue();\n        int secondsToRefresh = Integer.parseInt( config.getProperty( POLL_INTERVAL, \"-1\" ) );\n\n        providers = new ArrayList();\n\n        for ( Iterator iter = config.keySet().iterator(); iter.hasNext(); ) {\n            String key = (String) iter.next();\n            PackageProvider prov = getProvider( key, config );\n            if (prov != null) {\n                providers.add( prov ) ;\n            }\n        }\n\n        configure( newInstance, providers, secondsToRefresh );\n    }","commit_id":"cd8036d88f5fc979569b5a6bab66b39969387fbd","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Modifies the release and expire date of a resource, and changes the notification interval. <p>\n     * \n     * @return true, if the operation was performed, otherwise false\n     * @throws CmsException if modification is not successful\n     */\n    protected boolean performDialogOperation() throws CmsException {\n\n        // check if the current resource is a folder for single operation\n        boolean isFolder = isOperationOnFolder();\n        // on folder deletion or multi operation display \"please wait\" screen, not for simple file deletion\n        if ((isMultiOperation() || isFolder) && !DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // get the new release date for the resource(s) from request parameter\n        long releaseDate = CmsResource.DATE_RELEASED_DEFAULT;\n        boolean resetReleaseDate = Boolean.valueOf(getParamResetrelease()).booleanValue();\n        boolean leaveReleaseDate = false;\n        if (!resetReleaseDate) {\n            try {\n                if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(getParamReleasedate()))\n                    && (!getParamReleasedate().startsWith(CmsTouch.DEFAULT_DATE_STRING))) {\n                    releaseDate = CmsCalendarWidget.getCalendarDate(getMessages(), getParamReleasedate(), true);\n                } else {\n                    leaveReleaseDate = true;\n                }\n            } catch (ParseException e) {\n                throw new CmsException(\n                    Messages.get().container(Messages.ERR_PARSE_RELEASEDATE_1, getParamReleasedate()),\n                    e);\n            }\n        }\n\n        // get the new expire date for the resource(s) from request parameter\n        long expireDate = CmsResource.DATE_EXPIRED_DEFAULT;\n        boolean resetExpireDate = Boolean.valueOf(getParamResetexpire()).booleanValue();\n        boolean leaveExpireDate = false;\n        if (!resetExpireDate) {\n            try {\n                if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(getParamExpiredate()))\n                    && (!getParamExpiredate().startsWith(CmsTouch.DEFAULT_DATE_STRING))) {\n                    expireDate = CmsCalendarWidget.getCalendarDate(getMessages(), getParamExpiredate(), true);\n                } else {\n                    leaveExpireDate = true;\n                }\n            } catch (ParseException e) {\n                throw new CmsException(\n                    Messages.get().container(Messages.ERR_PARSE_EXPIREDATE_1, getParamExpiredate()),\n                    e);\n            }\n        }\n\n        // get the flag if the operation is recursive from request parameter\n        boolean modifyRecursive = Boolean.valueOf(getParamRecursive()).booleanValue();\n\n        // now iterate the resource(s)\n        Iterator i = getResourceList().iterator();\n        while (i.hasNext()) {\n            String resName = (String)i.next();\n            try {\n                performSingleResourceAvailability(\n                    resName,\n                    releaseDate,\n                    expireDate,\n                    leaveReleaseDate,\n                    leaveExpireDate,\n                    modifyRecursive);\n            } catch (CmsException e) {\n                // collect exceptions to create a detailed output\n                addMultiOperationException(e);\n            }\n        }\n\n        boolean notificationEnabled = Boolean.parseBoolean(getParamEnablenotification());\n        int notificationInterval = 0;\n        try {\n            notificationInterval = Integer.parseInt(getParamNotificationinterval());\n        } catch (Throwable e) {\n            // ignore\n        }\n\n        // get the flag if the operation should be executed on resource siblings, too\n        boolean modifySiblings = Boolean.valueOf(getParamModifysiblings()).booleanValue();\n\n        // now iterate the resource(s)\n        i = getResourceList().iterator();\n        while (i.hasNext()) {\n            String resName = (String)i.next();\n            try {\n                performSingleResourceNotification(resName, notificationEnabled, notificationInterval, modifySiblings);\n            } catch (CmsException e) {\n                // collect exceptions to create a detailed output\n                addMultiOperationException(e);\n            }\n        }\n        checkMultiOperationException(Messages.get(), Messages.ERR_AVAILABILITY_MULTI_0);\n\n        return true;\n    }","id":42405,"modified_method":"/**\n     * Modifies the release and expire date of a resource, and changes the notification interval. <p>\n     * \n     * @return true, if the operation was performed, otherwise false\n     * @throws CmsException if modification is not successful\n     */\n    protected boolean performDialogOperation() throws CmsException {\n\n        // check if the current resource is a folder for single operation\n        boolean isFolder = isOperationOnFolder();\n        // on folder deletion or multi operation display \"please wait\" screen, not for simple file deletion\n        if ((isMultiOperation() || isFolder) && !DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // get the new release date for the resource(s) from request parameter\n        long releaseDate = CmsResource.DATE_RELEASED_DEFAULT;\n        boolean resetReleaseDate = Boolean.valueOf(getParamResetrelease()).booleanValue();\n        boolean leaveReleaseDate = false;\n        if (!resetReleaseDate) {\n            try {\n                if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(getParamReleasedate()))\n                    && (!getParamReleasedate().startsWith(CmsTouch.DEFAULT_DATE_STRING))) {\n                    releaseDate = CmsCalendarWidget.getCalendarDate(getMessages(), getParamReleasedate(), true);\n                } else {\n                    leaveReleaseDate = true;\n                }\n            } catch (ParseException e) {\n                throw new CmsException(\n                    Messages.get().container(Messages.ERR_PARSE_RELEASEDATE_1, getParamReleasedate()),\n                    e);\n            }\n        }\n\n        // get the new expire date for the resource(s) from request parameter\n        long expireDate = CmsResource.DATE_EXPIRED_DEFAULT;\n        boolean resetExpireDate = Boolean.valueOf(getParamResetexpire()).booleanValue();\n        boolean leaveExpireDate = false;\n        if (!resetExpireDate) {\n            try {\n                if ((CmsStringUtil.isNotEmptyOrWhitespaceOnly(getParamExpiredate()))\n                    && (!getParamExpiredate().startsWith(CmsTouch.DEFAULT_DATE_STRING))) {\n                    expireDate = CmsCalendarWidget.getCalendarDate(getMessages(), getParamExpiredate(), true);\n                } else {\n                    leaveExpireDate = true;\n                }\n            } catch (ParseException e) {\n                throw new CmsException(\n                    Messages.get().container(Messages.ERR_PARSE_EXPIREDATE_1, getParamExpiredate()),\n                    e);\n            }\n        }\n\n        // get the flag if the operation is recursive from request parameter\n        boolean modifyRecursive = Boolean.valueOf(getParamRecursive()).booleanValue();\n\n        // now iterate the resource(s)\n        Iterator i = getResourceList().iterator();\n        while (i.hasNext()) {\n            String resName = (String)i.next();\n            try {\n                performSingleResourceAvailability(\n                    resName,\n                    releaseDate,\n                    expireDate,\n                    leaveReleaseDate,\n                    leaveExpireDate,\n                    modifyRecursive);\n            } catch (CmsException e) {\n                // collect exceptions to create a detailed output\n                addMultiOperationException(e);\n            }\n        }\n\n        boolean notificationEnabled = Boolean.valueOf(getParamEnablenotification()).booleanValue();\n        int notificationInterval = 0;\n        try {\n            notificationInterval = Integer.parseInt(getParamNotificationinterval());\n        } catch (Throwable e) {\n            // ignore\n        }\n\n        // get the flag if the operation should be executed on resource siblings, too\n        boolean modifySiblings = Boolean.valueOf(getParamModifysiblings()).booleanValue();\n\n        // now iterate the resource(s)\n        i = getResourceList().iterator();\n        while (i.hasNext()) {\n            String resName = (String)i.next();\n            try {\n                performSingleResourceNotification(resName, notificationEnabled, notificationInterval, modifySiblings);\n            } catch (CmsException e) {\n                // collect exceptions to create a detailed output\n                addMultiOperationException(e);\n            }\n        }\n        checkMultiOperationException(Messages.get(), Messages.ERR_AVAILABILITY_MULTI_0);\n\n        return true;\n    }","commit_id":"7cd55383218f82a07dc7472116b37293899f047a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the path under which the resource is accessable.\n     *  \n     * @return the path under which the resource is accessable\n     */\n    public String getResourceUrl() {\n\n        boolean secure = Boolean.parseBoolean(readProperty(I_CmsConstants.C_PROPERTY_SECURE));\n        StringBuffer result = new StringBuffer();\n        CmsSite currentSite = CmsSiteManager.getCurrentSite(getCms());\n        if (currentSite == OpenCms.getSiteManager().getDefaultSite()) {\n            result.append(OpenCms.getSiteManager().getWorkplaceServer());\n        } else {\n            if (secure) {\n                result.append(currentSite.getSecureUrl());\n            } else {\n                result.append(currentSite.getUrl());\n            }\n        }\n        result.append(OpenCms.getLinkManager().substituteLink(getCms(), getParamResource()));\n\n        return result.toString();\n    }","id":42406,"modified_method":"/**\n     * Returns the path under which the resource is accessable.\n     *  \n     * @return the path under which the resource is accessable\n     */\n    public String getResourceUrl() {\n\n        boolean secure = Boolean.valueOf(readProperty(I_CmsConstants.C_PROPERTY_SECURE)).booleanValue();\n        StringBuffer result = new StringBuffer();\n        CmsSite currentSite = CmsSiteManager.getCurrentSite(getCms());\n        if (currentSite == OpenCms.getSiteManager().getDefaultSite()) {\n            result.append(OpenCms.getSiteManager().getWorkplaceServer());\n        } else {\n            if (secure) {\n                result.append(currentSite.getSecureUrl());\n            } else {\n                result.append(currentSite.getUrl());\n            }\n        }\n        result.append(OpenCms.getLinkManager().substituteLink(getCms(), getParamResource()));\n\n        return result.toString();\n    }","commit_id":"61f479fc074b96019aeb4438b6dcd8e052eba5df","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void populateMetaData(ItemAuthorBean itemauthorbean, ItemFacade itemfacade, ItemBean bean)  {\n\n\n    Set itemtextSet = itemfacade.getItemMetaDataSet();\n    Iterator iter = itemtextSet.iterator();\n    while (iter.hasNext()){\n       ItemMetaData meta= (ItemMetaData) iter.next();\n       if (meta.getLabel().equals(ItemMetaDataIfc.OBJECTIVE)){\n\t bean.setObjective(meta.getEntry());\n       }\n       if (meta.getLabel().equals(ItemMetaDataIfc.KEYWORD)){\n\t bean.setKeyword(meta.getEntry());\n       }\n       if (meta.getLabel().equals(ItemMetaDataIfc.RUBRIC)){\n\t bean.setRubric(meta.getEntry());\n       }\n       if (meta.getLabel().equals(ItemMetaDataIfc.RANDOMIZE)){\n\t bean.setRandomized(meta.getEntry());\n       }\n\n       // for Multiple Choice Survey get survey type \n       // use PREDEFINED_SCALE\n       if (meta.getLabel().equals(ItemMetaDataIfc.PREDEFINED_SCALE)){\n\t bean.setScaleName(meta.getEntry());\n       }\n\n       // lydial (2/19/2006): for backward compatibility only. We used to use SCALENAME as the metadata key, while import/export used PREDEFINED_SCALE, now everything is using PREDEFINED_SCALE \n       if (meta.getLabel().equals(ItemMetaDataIfc.SCALENAME)){\n\t bean.setScaleName(meta.getEntry());\n         // now converting old metadata value to new ones, so that both manually created and imported assessments use the same metadata values. \n         if (ItemMetaDataIfc.SURVEY_YESNO.equals(meta.getEntry())) {\n\t   bean.setScaleName(ItemMetaDataIfc.SURVEY_YES);\n         } \n         if (ItemMetaDataIfc.SURVEY_SCALEFIVE.equals(meta.getEntry())) {\n\t   bean.setScaleName(ItemMetaDataIfc.SURVEY_5);\n         } \n         if (ItemMetaDataIfc.SURVEY_SCALETEN.equals(meta.getEntry())) {\n\t   bean.setScaleName(ItemMetaDataIfc.SURVEY_10);\n         } \n       }\n\n\t// get settings for case sensitivity for fib \n        // If metadata doesn't exist, by default it is false. \n       if (meta.getLabel().equals(ItemMetaDataIfc.CASE_SENSITIVE_FOR_FIB)){\n\t //bean.setCaseSensitiveForFib((new Boolean(meta.getEntry())).booleanValue());\n\t bean.setCaseSensitiveForFib(Boolean.parseBoolean(meta.getEntry()));\n       }\n\n\t// get settings for mutually exclusive for fib. \n        // If metadata doesn't exist, by default it is false. \n       if (meta.getLabel().equals(ItemMetaDataIfc.MUTUALLY_EXCLUSIVE_FOR_FIB)){\n\t //bean.setMutuallyExclusiveForFib((new Boolean(meta.getEntry())).booleanValue());\n\t bean.setMutuallyExclusiveForFib(Boolean.parseBoolean(meta.getEntry()));\n       }\n       \n       \n\n\t// get part id for the item\n       if (meta.getLabel().equals(ItemMetaDataIfc.PARTID)){\n\t bean.setSelectedSection(meta.getEntry());\n\t bean.setOrigSection(meta.getEntry());\n       }\n\n\t// get pool id for the item\n       if (meta.getLabel().equals(ItemMetaDataIfc.POOLID)){\n\t bean.setSelectedPool(meta.getEntry());\n\t bean.setOrigPool(meta.getEntry());\n       }\n\n\t// get timeallowed for audio recording item\n       if (meta.getLabel().equals(ItemMetaDataIfc.TIMEALLOWED)){\n\t bean.setTimeAllowed(meta.getEntry());\n       }\n\n\t// get number of attempts for audio recording item\n       if (meta.getLabel().equals(ItemMetaDataIfc.NUMATTEMPTS)){\n\t bean.setNumAttempts(meta.getEntry());\n       }\n\n\n     }\n  }","id":42407,"modified_method":"private void populateMetaData(ItemAuthorBean itemauthorbean, ItemFacade itemfacade, ItemBean bean)  {\n\n\n    Set itemtextSet = itemfacade.getItemMetaDataSet();\n    Iterator iter = itemtextSet.iterator();\n    while (iter.hasNext()){\n       ItemMetaData meta= (ItemMetaData) iter.next();\n       if (meta.getLabel().equals(ItemMetaDataIfc.OBJECTIVE)){\n\t bean.setObjective(meta.getEntry());\n       }\n       if (meta.getLabel().equals(ItemMetaDataIfc.KEYWORD)){\n\t bean.setKeyword(meta.getEntry());\n       }\n       if (meta.getLabel().equals(ItemMetaDataIfc.RUBRIC)){\n\t bean.setRubric(meta.getEntry());\n       }\n       if (meta.getLabel().equals(ItemMetaDataIfc.RANDOMIZE)){\n\t bean.setRandomized(meta.getEntry());\n       }\n\n       // for Multiple Choice Survey get survey type \n       // use PREDEFINED_SCALE\n       if (meta.getLabel().equals(ItemMetaDataIfc.PREDEFINED_SCALE)){\n\t bean.setScaleName(meta.getEntry());\n       }\n\n       // lydial (2/19/2006): for backward compatibility only. We used to use SCALENAME as the metadata key, while import/export used PREDEFINED_SCALE, now everything is using PREDEFINED_SCALE \n       if (meta.getLabel().equals(ItemMetaDataIfc.SCALENAME)){\n\t bean.setScaleName(meta.getEntry());\n         // now converting old metadata value to new ones, so that both manually created and imported assessments use the same metadata values. \n         if (ItemMetaDataIfc.SURVEY_YESNO.equals(meta.getEntry())) {\n\t   bean.setScaleName(ItemMetaDataIfc.SURVEY_YES);\n         } \n         if (ItemMetaDataIfc.SURVEY_SCALEFIVE.equals(meta.getEntry())) {\n\t   bean.setScaleName(ItemMetaDataIfc.SURVEY_5);\n         } \n         if (ItemMetaDataIfc.SURVEY_SCALETEN.equals(meta.getEntry())) {\n\t   bean.setScaleName(ItemMetaDataIfc.SURVEY_10);\n         } \n       }\n\n\t// get settings for case sensitivity for fib \n        // If metadata doesn't exist, by default it is false. \n       if (meta.getLabel().equals(ItemMetaDataIfc.CASE_SENSITIVE_FOR_FIB)){\n\t //bean.setCaseSensitiveForFib((new Boolean(meta.getEntry())).booleanValue());\n\t bean.setCaseSensitiveForFib(Boolean.valueOf(meta.getEntry()).booleanValue());\n       }\n\n\t// get settings for mutually exclusive for fib. \n        // If metadata doesn't exist, by default it is false. \n       if (meta.getLabel().equals(ItemMetaDataIfc.MUTUALLY_EXCLUSIVE_FOR_FIB)){\n\t //bean.setMutuallyExclusiveForFib((new Boolean(meta.getEntry())).booleanValue());\n\t bean.setMutuallyExclusiveForFib(Boolean.valueOf(meta.getEntry()).booleanValue());\n       }\n       \n       \n\n\t// get part id for the item\n       if (meta.getLabel().equals(ItemMetaDataIfc.PARTID)){\n\t bean.setSelectedSection(meta.getEntry());\n\t bean.setOrigSection(meta.getEntry());\n       }\n\n\t// get pool id for the item\n       if (meta.getLabel().equals(ItemMetaDataIfc.POOLID)){\n\t bean.setSelectedPool(meta.getEntry());\n\t bean.setOrigPool(meta.getEntry());\n       }\n\n\t// get timeallowed for audio recording item\n       if (meta.getLabel().equals(ItemMetaDataIfc.TIMEALLOWED)){\n\t bean.setTimeAllowed(meta.getEntry());\n       }\n\n\t// get number of attempts for audio recording item\n       if (meta.getLabel().equals(ItemMetaDataIfc.NUMATTEMPTS)){\n\t bean.setNumAttempts(meta.getEntry());\n       }\n\n\n     }\n  }","commit_id":"c31bb2369ebac759a8ee89b13478c19affd800ce","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Processes the component tag.\n\t * @param tag Tag to modify\n\t * @see wicket.Component#handleComponentTag(ComponentTag)\n\t */\n\tprotected void handleComponentTag(final ComponentTag tag)\n\t{\n\t\tcheckTag(tag, \"input\");\n\t\tcheckAttribute(tag, \"type\", \"checkbox\");\n\t\tsuper.handleComponentTag(tag);\n\n\t\tObject value = getModelObject();\n\n\t\tif (value != null)\n\t\t{\n\t\t\tfinal boolean tagValue;\n\t\t\tif(value instanceof String) // probably was formatted or straight from request\n\t\t\t{\n\t\t\t\ttagValue = Boolean.parseBoolean((String)value);\n\t\t\t}\n\t\t\telse if(value instanceof Boolean)\n\t\t\t{\n\t\t\t\ttagValue = ((Boolean)value).booleanValue();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"Model objects for checkboxes have to be of type Boolean\");\n\t\t\t}\n\t\t\tif(tagValue) tag.put(\"checked\", \"checked\");\n\t\t\telse tag.remove(\"checked\"); // in case the was a design time attrib\n\t\t}\n\t}","id":42408,"modified_method":"/**\n\t * Processes the component tag.\n\t * @param tag Tag to modify\n\t * @see wicket.Component#handleComponentTag(ComponentTag)\n\t */\n\tprotected void handleComponentTag(final ComponentTag tag)\n\t{\n\t\tcheckTag(tag, \"input\");\n\t\tcheckAttribute(tag, \"type\", \"checkbox\");\n\t\tsuper.handleComponentTag(tag);\n\n\t\tObject value = getModelObject();\n\n\t\tif (value != null)\n\t\t{\n\t\t\tfinal boolean tagValue;\n\t\t\tif(value instanceof String) // probably was formatted or straight from request\n\t\t\t{\n\t\t\t\ttagValue = Boolean.valueOf((String)value).booleanValue();\n\t\t\t}\n\t\t\telse if(value instanceof Boolean)\n\t\t\t{\n\t\t\t\ttagValue = ((Boolean)value).booleanValue();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"Model objects for checkboxes have to be of type Boolean\");\n\t\t\t}\n\t\t\tif(tagValue) tag.put(\"checked\", \"checked\");\n\t\t\telse tag.remove(\"checked\"); // in case the was a design time attrib\n\t\t}\n\t}","commit_id":"cb24085ccdda5ed6c0f90ba2a0c50f53a8d34c48","url":"https://github.com/apache/wicket"},{"original_method":"public RequirementImpl parseRequire(XmlPullParser reader) throws Exception\n    {\n        RequirementImpl requirement = new RequirementImpl();\n        for (int i = 0, nb = reader.getAttributeCount(); i < nb; i++)\n        {\n            String name = reader.getAttributeName(i);\n            String value = reader.getAttributeValue(i);\n            if (NAME.equals(name))\n            {\n                requirement.setName(value);\n            }\n            else if (FILTER.equals(name))\n            {\n                requirement.setFilter(value);\n            }\n            else if (EXTEND.equals(name))\n            {\n                requirement.setExtend(Boolean.parseBoolean(value));\n            }\n            else if (MULTIPLE.equals(name))\n            {\n                requirement.setMultiple(Boolean.parseBoolean(value));\n            }\n            else if (OPTIONAL.equals(name))\n            {\n                requirement.setOptional(Boolean.parseBoolean(value));\n            }\n        }\n        int event;\n        StringBuffer sb = null;\n        while ((event = reader.next()) != XmlPullParser.END_TAG)\n        {\n            switch (event)\n            {\n                case XmlPullParser.START_TAG:\n                    throw new Exception(\"Unexpected element inside <require/> element\");\n                case XmlPullParser.TEXT:\n                    if (sb == null)\n                    {\n                        sb = new StringBuffer();\n                    }\n                    sb.append(reader.getText());\n                    break;\n            }\n        }\n        if (sb != null)\n        {\n            requirement.addText(sb.toString());\n        }\n        // Sanity check\n        sanityCheckEndElement(reader, event, REQUIRE);\n        return requirement;\n    }","id":42409,"modified_method":"public RequirementImpl parseRequire(XmlPullParser reader) throws Exception\n    {\n        RequirementImpl requirement = new RequirementImpl();\n        for (int i = 0, nb = reader.getAttributeCount(); i < nb; i++)\n        {\n            String name = reader.getAttributeName(i);\n            String value = reader.getAttributeValue(i);\n            if (NAME.equals(name))\n            {\n                requirement.setName(value);\n            }\n            else if (FILTER.equals(name))\n            {\n                requirement.setFilter(value);\n            }\n            else if (EXTEND.equals(name))\n            {\n                requirement.setExtend(Boolean.valueOf(value).booleanValue());\n            }\n            else if (MULTIPLE.equals(name))\n            {\n                requirement.setMultiple(Boolean.valueOf(value).booleanValue());\n            }\n            else if (OPTIONAL.equals(name))\n            {\n                requirement.setOptional(Boolean.valueOf(value).booleanValue());\n            }\n        }\n        int event;\n        StringBuffer sb = null;\n        while ((event = reader.next()) != XmlPullParser.END_TAG)\n        {\n            switch (event)\n            {\n                case XmlPullParser.START_TAG:\n                    throw new Exception(\"Unexpected element inside <require/> element\");\n                case XmlPullParser.TEXT:\n                    if (sb == null)\n                    {\n                        sb = new StringBuffer();\n                    }\n                    sb.append(reader.getText());\n                    break;\n            }\n        }\n        if (sb != null)\n        {\n            requirement.addText(sb.toString());\n        }\n        // Sanity check\n        sanityCheckEndElement(reader, event, REQUIRE);\n        return requirement;\n    }","commit_id":"26a8b3db50e4f43d6984d56347a98aa0343beaab","url":"https://github.com/apache/felix"},{"original_method":"public DefaultUrlMappingData(String urlPattern) {\n        if(StringUtils.isBlank(urlPattern)) throw new IllegalArgumentException(\"Argument [urlPattern] cannot be null or blank\");\n        if(!urlPattern.startsWith(SLASH)) throw new IllegalArgumentException(\"Argument [urlPattern] is not a valid URL. It must start with '/' !\");\n\n        this.urlPattern = urlPattern.replace(\"(*)**\", CAPTURED_DOUBLE_WILDCARD); // remove starting /\n        this.tokens = this.urlPattern.substring(1).split(SLASH);\n        List urls = new ArrayList();\n\n        parseUrls(urls);\n\n        this.logicalUrls = (String[])urls.toArray(new String[urls.size()]);\n    }","id":42410,"modified_method":"public DefaultUrlMappingData(String urlPattern) {\n        if(StringUtils.isBlank(urlPattern)) throw new IllegalArgumentException(\"Argument [urlPattern] cannot be null or blank\");\n        if(!urlPattern.startsWith(SLASH)) throw new IllegalArgumentException(\"Argument [urlPattern] is not a valid URL. It must start with '/' !\");\n\n        this.urlPattern = StringUtils.replace(urlPattern, \"(*)**\", CAPTURED_DOUBLE_WILDCARD); // remove starting /\n        this.tokens = this.urlPattern.substring(1).split(SLASH);\n        List urls = new ArrayList();\n\n        parseUrls(urls);\n\n        this.logicalUrls = (String[])urls.toArray(new String[urls.size()]);\n    }","commit_id":"f2b25c6b6d111f7f35a8368aa56e0ff125d51de1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * <p>Remove all apparently Grails-internal trace entries from the exception instance<p>\n     * <p>This modifies the original instance and returns it, it does not clone<\/p>\n     * @param t\n     * @return The exception passed in, after cleaning the stack trace\n     */\n    public static Throwable sanitize(Throwable t) {\n        // Note that this getProperty access may well be synced...\n        if (!Boolean.parseBoolean(System.getProperty(\"grails.full.stacktrace\"))) {\n            StackTraceElement[] trace = t.getStackTrace();\n            List newTrace = new ArrayList();\n            for (int i = 0; i < trace.length; i++) {\n                StackTraceElement stackTraceElement = trace[i];\n                if (isApplicationClass(stackTraceElement.getClassName())) {\n                    newTrace.add( stackTraceElement);\n                }\n            }\n\n            // Only trim the trace if there was some application trace on the stack\n            // if not we will just skip sanitizing and leave it as is\n            if (newTrace.size() > 0) {\n                // We don't want to lose anything, so log it\n                STACK_LOG.error(\"Sanitizing stacktrace:\", t);\n                StackTraceElement[] clean = new StackTraceElement[newTrace.size()];\n                newTrace.toArray(clean);\n                t.setStackTrace(clean);\n            }\n        }\n        return t;\n    }","id":42411,"modified_method":"/**\n     * <p>Remove all apparently Grails-internal trace entries from the exception instance<p>\n     * <p>This modifies the original instance and returns it, it does not clone<\/p>\n     * @param t\n     * @return The exception passed in, after cleaning the stack trace\n     */\n    public static Throwable sanitize(Throwable t) {\n        // Note that this getProperty access may well be synced...\n        if (!Boolean.valueOf(System.getProperty(\"grails.full.stacktrace\")).booleanValue()) {\n            StackTraceElement[] trace = t.getStackTrace();\n            List newTrace = new ArrayList();\n            for (int i = 0; i < trace.length; i++) {\n                StackTraceElement stackTraceElement = trace[i];\n                if (isApplicationClass(stackTraceElement.getClassName())) {\n                    newTrace.add( stackTraceElement);\n                }\n            }\n\n            // Only trim the trace if there was some application trace on the stack\n            // if not we will just skip sanitizing and leave it as is\n            if (newTrace.size() > 0) {\n                // We don't want to lose anything, so log it\n                STACK_LOG.error(\"Sanitizing stacktrace:\", t);\n                StackTraceElement[] clean = new StackTraceElement[newTrace.size()];\n                newTrace.toArray(clean);\n                t.setStackTrace(clean);\n            }\n        }\n        return t;\n    }","commit_id":"f2b25c6b6d111f7f35a8368aa56e0ff125d51de1","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Attempts to invokes a dynamic tag\n     *\n     * @param tagName The name of the tag\n     * @param tagNamespace The taglib's namespace\n     * @param attrs The tags attributes\n     * @param body  The body of the tag as a closure\n     */\n    public void invokeTag(String tagName, String tagNamespace, Map attrs, Closure body) {\n\n        final GrailsWebRequest webRequest = (GrailsWebRequest)getBinding().getVariable(WEB_REQUEST);\n        final Writer out = webRequest.getOut();\n\n        try {\n\t        if(this.application == null)\n\t            initPageState();\n\n\n            if( getTagLibForNamespace(tagNamespace) != null ) {\n                GroovyObject tagLib = getTagLib(tagName,tagNamespace);\n                if(tagLib != null) {\n                    Object tagLibProp;\n                    BeanWrapper bean = getTagLibraryBean(tagLib, webRequest);\n                    if(bean.isReadableProperty(tagName)) {\n                        tagLibProp = tagLib.getProperty(tagName);\n                    } else {\n                        throw new GrailsTagException(\"Tag [\"+tagName+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n                    }\n                    if(tagLibProp instanceof Closure) {\n                        Closure tag = setupTagClosure(tagLibProp);\n\n                        if(tag.getParameterTypes().length == 1) {\n                            tag.call( new Object[]{ attrs });\n                            if(body != null) {\n                                body.call();\n                            }\n                        }\n                        if(tag.getParameterTypes().length == 2) {\n                            tag.call( new Object[] { attrs, body });\n                        }\n                    }else {\n                       throw new GrailsTagException(\"Tag [\"+tagName+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n                    }\n                }\n                else {\n                    throw new GrailsTagException(\"Tag [\"+tagName+\"] does not exist. No tag library found for namespace: \" + tagNamespace);\n                }\n            } else {\n                StringBuilder plainTag = new StringBuilder();\n                String fullTagName = tagNamespace + \":\" + tagName;\n                plainTag.append(\"<\").append(fullTagName);\n                for(Iterator iterator = attrs.entrySet().iterator(); iterator.hasNext();) {\n                    Map.Entry entry = (Map.Entry) iterator.next();\n                    plainTag.append(\" \").append(entry.getKey()).append(\"=\\\"\").append(entry.getValue()).append(\"\\\"\");\n                }\n                plainTag.append(\">\");\n                try {\n                    out.write(plainTag.toString());\n                    if(body != null) {\n                        Object bodyOutput = body.call();\n                        if(bodyOutput != null) out.write(bodyOutput.toString());\n                    }\n                    out.write(\"<\/\" + fullTagName + \">\");\n                } catch(IOException e) {\n                    throw new GrailsTagException(\"I/O error invoking tag library closure as method\");\n                }\n            }\n\t\t}\n\t\tfinally {       \n\t\t\tgetBinding().setVariable(OUT,out);\n\t\t\twebRequest.setOut(out);\n\t\t}\t\t\n    }","id":42412,"modified_method":"/**\n     * Attempts to invokes a dynamic tag\n     *\n     * @param tagName The name of the tag\n     * @param tagNamespace The taglib's namespace\n     * @param attrs The tags attributes\n     * @param body  The body of the tag as a closure\n     */\n    public void invokeTag(String tagName, String tagNamespace, Map attrs, Closure body) {\n\n        final GrailsWebRequest webRequest = (GrailsWebRequest)getBinding().getVariable(WEB_REQUEST);\n        final Writer out = webRequest.getOut();\n\n        try {\n\t        if(this.application == null)\n\t            initPageState();\n\n\n            if( getTagLibForNamespace(tagNamespace) != null ) {\n                GroovyObject tagLib = getTagLib(tagName,tagNamespace);\n                if(tagLib != null) {\n                    Object tagLibProp;\n                    BeanWrapper bean = getTagLibraryBean(tagLib, webRequest);\n                    if(bean.isReadableProperty(tagName)) {\n                        tagLibProp = tagLib.getProperty(tagName);\n                    } else {\n                        throw new GrailsTagException(\"Tag [\"+tagName+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n                    }\n                    if(tagLibProp instanceof Closure) {\n                        Closure tag = setupTagClosure(tagLibProp);\n\n                        if(tag.getParameterTypes().length == 1) {\n                            tag.call( new Object[]{ attrs });\n                            if(body != null) {\n                                body.call();\n                            }\n                        }\n                        if(tag.getParameterTypes().length == 2) {\n                            tag.call( new Object[] { attrs, body });\n                        }\n                    }else {\n                       throw new GrailsTagException(\"Tag [\"+tagName+\"] does not exist in tag library [\"+tagLib.getClass().getName()+\"]\");\n                    }\n                }\n                else {\n                    throw new GrailsTagException(\"Tag [\"+tagName+\"] does not exist. No tag library found for namespace: \" + tagNamespace);\n                }\n            } else {\n                StringBuffer plainTag = new StringBuffer();\n                String fullTagName = tagNamespace + \":\" + tagName;\n                plainTag.append(\"<\").append(fullTagName);\n                for(Iterator iterator = attrs.entrySet().iterator(); iterator.hasNext();) {\n                    Map.Entry entry = (Map.Entry) iterator.next();\n                    plainTag.append(\" \").append(entry.getKey()).append(\"=\\\"\").append(entry.getValue()).append(\"\\\"\");\n                }\n                plainTag.append(\">\");\n                try {\n                    out.write(plainTag.toString());\n                    if(body != null) {\n                        Object bodyOutput = body.call();\n                        if(bodyOutput != null) out.write(bodyOutput.toString());\n                    }\n                    out.write(\"<\/\" + fullTagName + \">\");\n                } catch(IOException e) {\n                    throw new GrailsTagException(\"I/O error invoking tag library closure as method\");\n                }\n            }\n\t\t}\n\t\tfinally {       \n\t\t\tgetBinding().setVariable(OUT,out);\n\t\t\twebRequest.setOut(out);\n\t\t}\t\t\n    }","commit_id":"f2b25c6b6d111f7f35a8368aa56e0ff125d51de1","url":"https://github.com/grails/grails-core"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    List subElements = element.getChildren(OPTIONS_SETTING);\n    for (Object o : subElements) {\n      if (o instanceof Element) {\n        final Element subElement = ((Element)o);\n        final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n        final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n        if (id != null && value != null) {\n          try {\n            final boolean booleanValue = Boolean.parseBoolean(value);\n            getOrCreateOption(id).setValue(booleanValue);\n          }\n          catch (Exception e) {\n            //ignore\n          }\n        }\n      }\n    }\n    myReadValue.clear();\n    subElements = element.getChildren(CONFIRMATIONS_SETTING);\n    for (Object o : subElements) {\n      if (o instanceof Element) {\n        final Element subElement = ((Element)o);\n        final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n        final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n        if (id != null && value != null) {\n          try {\n            myReadValue.put(id, VcsShowConfirmationOption.Value.fromString(value));\n          }\n          catch (Exception e) {\n            //ignore\n          }\n        }\n      }\n    }\n\n  }","id":42413,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    List subElements = element.getChildren(OPTIONS_SETTING);\n    for (Object o : subElements) {\n      if (o instanceof Element) {\n        final Element subElement = ((Element)o);\n        final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n        final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n        if (id != null && value != null) {\n          try {\n            final boolean booleanValue = Boolean.valueOf(value).booleanValue();\n            getOrCreateOption(id).setValue(booleanValue);\n          }\n          catch (Exception e) {\n            //ignore\n          }\n        }\n      }\n    }\n    myReadValue.clear();\n    subElements = element.getChildren(CONFIRMATIONS_SETTING);\n    for (Object o : subElements) {\n      if (o instanceof Element) {\n        final Element subElement = ((Element)o);\n        final String id = subElement.getAttributeValue(ID_ATTRIBUTE);\n        final String value = subElement.getAttributeValue(VALUE_ATTTIBUTE);\n        if (id != null && value != null) {\n          try {\n            myReadValue.put(id, VcsShowConfirmationOption.Value.fromString(value));\n          }\n          catch (Exception e) {\n            //ignore\n          }\n        }\n      }\n    }\n\n  }","commit_id":"2a09a1c9a02684edd61691accf9721c81810edc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean trasesEnabled( final HttpServletRequest req )\n    {\n        String traces = req.getParameter(\"traces\"); //$NON-NLS-1$\n        return null == traces ? false : Boolean.parseBoolean(traces);\n    }","id":42414,"modified_method":"private static boolean trasesEnabled( final HttpServletRequest req )\n    {\n        String traces = req.getParameter(\"traces\"); //$NON-NLS-1$\n        return null == traces ? false : Boolean.valueOf( traces ).booleanValue();\n    }","commit_id":"371ba2bbd189ac276b5f8e4a87d49b69ea2f7803","url":"https://github.com/apache/felix"},{"original_method":"public ChunkContextUi(TextEditingTarget target, Scope chunk, \n         CommandWithArg<LineWidget> onRemoved)\n   {\n      target_ = target;\n      int preambleRow = chunk.getPreamble().getRow();\n      toolbar_ = new ChunkContextToolbar(this, false, \n            !isSetupChunk(preambleRow), isRunnableChunk(preambleRow));\n      toolbar_.setHeight(\"0px\"); \n      lineWidget_ = new PinnedLineWidget(\n            ChunkContextToolbar.LINE_WIDGET_TYPE, target_.getDocDisplay(), \n            toolbar_, preambleRow, null, onRemoved);\n   }","id":42415,"modified_method":"public ChunkContextUi(TextEditingTarget target, Scope chunk, \n         PinnedLineWidget.Host lineWidgetHost)\n   {\n      target_ = target;\n      int preambleRow = chunk.getPreamble().getRow();\n      toolbar_ = new ChunkContextToolbar(this, false, \n            !isSetupChunk(preambleRow), isRunnableChunk(preambleRow));\n      toolbar_.setHeight(\"0px\"); \n      lineWidget_ = new PinnedLineWidget(\n            ChunkContextToolbar.LINE_WIDGET_TYPE, target_.getDocDisplay(), \n            toolbar_, preambleRow, null, lineWidgetHost);\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void remove()\n   {\n      if (!attached_)\n         return;\n      attached_ = false;\n\n      startAnchor_.detach();\n      endAnchor_.detach();\n      \n      // note that this triggers an event which causes us to clean up the line\n      // widget if we haven't already, so it's important that remove() can't\n      // be reentrant.\n      display_.removeLineWidget(lineWidget_);\n   }","id":42416,"modified_method":"public void remove()\n   {\n      if (!attached_)\n         return;\n      attached_ = false;\n\n      // note that this triggers an event which causes us to clean up the line\n      // widget if we haven't already, so it's important that remove() can't\n      // be reentrant.\n      lineWidget_.detach();\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public LineWidget getLineWidget()\n   {\n      return lineWidget_;\n   }","id":42417,"modified_method":"public LineWidget getLineWidget()\n   {\n      return lineWidget_.getLineWidget();\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public boolean moving()\n   {\n      return moving_;\n   }","id":42418,"modified_method":"public boolean moving()\n   {\n      return lineWidget_.moving();\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public ChunkOutputUi(String docId, DocDisplay display, ChunkDefinition def)\n   {\n      display_ = display;\n      chunkId_ = def.getChunkId();\n      docId_ = docId;\n      def_ = def;\n      startAnchor_ = display_.createAnchor(\n            Position.create(def.getRow(), 0));\n      createEndAnchor();\n\n      outputWidget_ = new ChunkOutputWidget(def.getChunkId(), \n            def.getExpansionState(),\n            new CommandWithArg<Integer>()\n      {\n         @Override\n         public void execute(Integer arg)\n         {\n            int height = \n                  outputWidget_.getExpansionState() == ChunkOutputWidget.COLLAPSED ?\n                     CHUNK_COLLAPSED_HEIGHT :\n                     Math.max(MIN_CHUNK_HEIGHT, \n                       Math.min(arg.intValue(), MAX_CHUNK_HEIGHT));\n            outputWidget_.getElement().getStyle().setHeight(height, Unit.PX);\n            display_.onLineWidgetChanged(lineWidget_);\n         }\n      },\n      new Command()\n      {\n         @Override\n         public void execute()\n         {\n            RStudioGinjector.INSTANCE.getEventBus().fireEvent(\n                  new ChunkChangeEvent(docId_, chunkId_, 0, \n                                       ChunkChangeEvent.CHANGE_REMOVE));\n         }\n      });\n      \n      // sync the widget's expanded/collapsed state to the underlying chunk\n      // definition (which is persisted)\n      outputWidget_.addExpansionStateChangeHandler(\n            new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            def_.setExpansionState(event.getValue());\n         }\n      });\n      \n      Element ele = outputWidget_.getElement();\n      ele.addClassName(ThemeStyles.INSTANCE.selectableText());\n      ele.getStyle().setHeight(MIN_CHUNK_HEIGHT, Unit.PX);\n      \n      lineWidget_ = LineWidget.create(ChunkDefinition.LINE_WIDGET_TYPE, \n            def.getRow(), ele, def);\n      lineWidget_.setFixedWidth(true);\n      display_.addLineWidget(lineWidget_);\n      \n      attached_ = true;\n   }","id":42419,"modified_method":"public ChunkOutputUi(String docId, DocDisplay display, ChunkDefinition def,\n         PinnedLineWidget.Host lineWidgetHost)\n   {\n      display_ = display;\n      chunkId_ = def.getChunkId();\n      docId_ = docId;\n      def_ = def;\n\n      outputWidget_ = new ChunkOutputWidget(def.getChunkId(), \n            def.getExpansionState(),\n            new CommandWithArg<Integer>()\n      {\n         @Override\n         public void execute(Integer arg)\n         {\n            int height = \n                  outputWidget_.getExpansionState() == ChunkOutputWidget.COLLAPSED ?\n                     CHUNK_COLLAPSED_HEIGHT :\n                     Math.max(MIN_CHUNK_HEIGHT, \n                       Math.min(arg.intValue(), MAX_CHUNK_HEIGHT));\n            outputWidget_.getElement().getStyle().setHeight(height, Unit.PX);\n            display_.onLineWidgetChanged(lineWidget_.getLineWidget());\n         }\n      },\n      new Command()\n      {\n         @Override\n         public void execute()\n         {\n            RStudioGinjector.INSTANCE.getEventBus().fireEvent(\n                  new ChunkChangeEvent(docId_, chunkId_, 0, \n                                       ChunkChangeEvent.CHANGE_REMOVE));\n         }\n      });\n      \n      // sync the widget's expanded/collapsed state to the underlying chunk\n      // definition (which is persisted)\n      outputWidget_.addExpansionStateChangeHandler(\n            new ValueChangeHandler<Integer>()\n      {\n         @Override\n         public void onValueChange(ValueChangeEvent<Integer> event)\n         {\n            def_.setExpansionState(event.getValue());\n         }\n      });\n      \n      Element ele = outputWidget_.getElement();\n      ele.addClassName(ThemeStyles.INSTANCE.selectableText());\n      ele.getStyle().setHeight(MIN_CHUNK_HEIGHT, Unit.PX);\n      \n      lineWidget_ = new PinnedLineWidget(ChunkDefinition.LINE_WIDGET_TYPE, \n            display_, outputWidget_, def.getRow(), def, lineWidgetHost);\n      \n      attached_ = true;\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void onFoldChange(FoldChangeEvent event)\n   {\n      LineWidget w = display_.getLineWidgetForRow(lineWidget_.getRow());\n      if (w == null)\n      {\n         // ensure widget is detached\n         widget_.getElement().removeFromParent();\n         detachAnchors();\n         onRemoved_.execute(lineWidget_);\n      }\n   }","id":42420,"modified_method":"@Override\n   public void onFoldChange(FoldChangeEvent event)\n   {\n      // the FoldChangeEvent is fired at the moment that Ace removes the line\n      // widget, but before our anchors are updated. set a flag so we know to\n      // check for an attached widget next time.\n      checkForRemove_ = true;\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void syncEndAnchor()\n   {\n      int delta = endAnchor_.getRow() - startAnchor_.getRow();\n      if (delta == 0)\n      {\n         // this happens if the line beneath the chunk output is deleted; when\n         // it happens, our anchors wind up on the same line, so reset the\n         // end anchor\n         endAnchor_.detach();\n         createEndAnchor();\n      }\n      else if (delta > 1)\n      {\n         // this happens if a line is inserted between the chunk and the \n         // output; when it happens, we need to move the output so it remains\n         // glued to the end of the chunk.\n         \n         // mark the chunk as moving (so we don't process this as an actual\n         // chunk remove when events are triggered)\n         moving_ = true;\n\n         // move the chunk to the start anchor\n         endAnchor_.detach();\n         display_.removeLineWidget(lineWidget_);\n         lineWidget_.setRow(startAnchor_.getRow());\n         display_.addLineWidget(lineWidget_);\n         createEndAnchor();\n\n         // restore state\n         moving_ = false;\n      }\n   }","id":42421,"modified_method":"private void syncEndAnchor()\n   {\n      if (checkForRemove_)\n      {\n         checkForRemove_ = false;\n         if (checkForRemoval())\n            return;\n      }\n\n      int delta = endAnchor_.getRow() - startAnchor_.getRow();\n      if (delta == 0)\n      {\n         // this happens if the line beneath the chunk output is deleted; when\n         // it happens, our anchors wind up on the same line, so reset the\n         // end anchor\n         endAnchor_.detach();\n         createEndAnchor();\n      }\n      else if (delta > 1)\n      {\n         // this happens if a line is inserted between the chunk and the \n         // output; when it happens, we need to move the output so it remains\n         // glued to the end of the chunk.\n         \n         // mark the chunk as moving (so we don't process this as an actual\n         // chunk remove when events are triggered)\n         moving_ = true;\n\n         // move the chunk to the start anchor\n         endAnchor_.detach();\n         display_.removeLineWidget(lineWidget_);\n         lineWidget_.setRow(startAnchor_.getRow());\n         display_.addLineWidget(lineWidget_);\n         createEndAnchor();\n\n         // restore state\n         moving_ = false;\n      }\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public PinnedLineWidget(String type, DocDisplay display, Widget widget, \n         int row, JavaScriptObject data, CommandWithArg<LineWidget> onRemoved)\n   {\n      display_ = display;\n      widget_ = widget;\n      moving_ = false;\n      onRemoved_ = onRemoved;\n\n      lineWidget_ = LineWidget.create(type, row, widget_.getElement(), data);\n      lineWidget_.setFixedWidth(true); \n      display_.addLineWidget(lineWidget_);\n\n      registrations_ = new HandlerRegistrations(\n         display_.addFoldChangeHandler(this));\n\n      startAnchor_ = display_.createAnchor(Position.create(row, 0));\n\n      createEndAnchor();\n   }","id":42422,"modified_method":"public PinnedLineWidget(String type, DocDisplay display, Widget widget, \n         int row, JavaScriptObject data, Host host)\n   {\n      display_ = display;\n      widget_ = widget;\n      moving_ = false;\n      host_ = host;\n\n      lineWidget_ = LineWidget.create(type, row, widget_.getElement(), data);\n      lineWidget_.setFixedWidth(true); \n      display_.addLineWidget(lineWidget_);\n\n      // the Ace line widget manage emits a 'changeFold' event when a line\n      // widget is destroyed; this is our only signal that it's been\n      // removed, so when it happens, we need check to see if the widget\n      // has been removed\n      registrations_ = new HandlerRegistrations(\n         display_.addFoldChangeHandler(this));\n\n      startAnchor_ = display_.createAnchor(Position.create(row, 0));\n\n      createEndAnchor();\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void insertChunkToolbar(Scope chunk)\n   {\n      // see if we've already drawn a toolbar for this chunk\n      boolean hasToolbar = false;\n      for (ChunkContextUi toolbar: toolbars_)\n      {\n         if (toolbar.getPreambleRow() == chunk.getPreamble().getRow())\n         {\n            hasToolbar = true; \n            break;\n         }\n      }\n      if (hasToolbar)\n         return;\n         \n      ChunkContextUi ui = new ChunkContextUi(target_, chunk, \n            new CommandWithArg<LineWidget>()\n      {\n         @Override\n         public void execute(LineWidget widget)\n         {\n            onWidgetRemoved(widget);\n         }\n      });\n      toolbars_.add(ui);\n   }","id":42423,"modified_method":"private void insertChunkToolbar(Scope chunk)\n   {\n      // see if we've already drawn a toolbar for this chunk\n      boolean hasToolbar = false;\n      for (ChunkContextUi toolbar: toolbars_)\n      {\n         if (toolbar.getPreambleRow() == chunk.getPreamble().getRow())\n         {\n            hasToolbar = true; \n            break;\n         }\n      }\n      if (hasToolbar)\n         return;\n         \n      ChunkContextUi ui = new ChunkContextUi(target_, chunk, this);\n      toolbars_.add(ui);\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void onWidgetRemoved(LineWidget widget)\n   {\n      // remove the widget from our internal list\n      for (ChunkContextUi toolbar: toolbars_)\n      {\n         if (toolbar.getLineWidget() == widget)\n         {\n            toolbars_.remove(toolbar);\n            break;\n         }\n      }\n   }","id":42424,"modified_method":"@Override\n   public void onLineWidgetRemoved(LineWidget widget)\n   {\n      // remove the widget from our internal list\n      for (ChunkContextUi toolbar: toolbars_)\n      {\n         if (toolbar.getLineWidget() == widget)\n         {\n            toolbars_.remove(toolbar);\n            break;\n         }\n      }\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void createChunkOutput(ChunkDefinition def)\n   {\n      outputs_.put(def.getChunkId(), \n                   new ChunkOutputUi(docUpdateSentinel_.getId(), docDisplay_,\n                                     def));\n   }","id":42425,"modified_method":"private void createChunkOutput(ChunkDefinition def)\n   {\n      outputs_.put(def.getChunkId(), \n                   new ChunkOutputUi(docUpdateSentinel_.getId(), docDisplay_,\n                                     def, this));\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void loadInitialChunkOutput()\n   {\n      if (state_ != STATE_NONE)\n         return;\n      \n      // start listening for fold change events \n      docDisplay_.addFoldChangeHandler(new FoldChangeEvent.Handler()\n      {\n         @Override\n         public void onFoldChange(FoldChangeEvent event)\n         {\n            // the Ace line widget manage emits a 'changeFold' event when a line\n            // widget is destroyed; this is our only signal that it's been\n            // removed, so when it happens, we need to synchronize the notebook\n            // state in this class with the state in the document.\n            syncLineWidgets();\n         }\n      });\n\n      state_ = STATE_INITIALIZING;\n      requestId_ = nextRequestId_++;\n      server_.refreshChunkOutput(\n            docUpdateSentinel_.getPath(),\n            docUpdateSentinel_.getId(), \n            contextId_,\n            Integer.toHexString(requestId_), \n            new VoidServerRequestCallback());\n   }","id":42426,"modified_method":"private void loadInitialChunkOutput()\n   {\n      if (state_ != STATE_NONE)\n         return;\n      \n      state_ = STATE_INITIALIZING;\n      requestId_ = nextRequestId_++;\n      server_.refreshChunkOutput(\n            docUpdateSentinel_.getPath(),\n            docUpdateSentinel_.getId(), \n            contextId_,\n            Integer.toHexString(requestId_), \n            new VoidServerRequestCallback());\n   }","commit_id":"168eb76571b5d6ab2345bacd44a35e177c8b7cfb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public Builder add(long part) {\n      add(Bytes.toBytes(part));\n      return this;\n    }","id":42427,"modified_method":"public Builder add(long part) {\n      key = Bytes.add(key, Bytes.toBytes(part));\n      return this;\n    }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"private MDSKey(byte[] key) {\n    this.key = key;\n  }","id":42428,"modified_method":"public MDSKey(byte[] key) {\n    this.key = key;\n  }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Splits the keys into the parts that comprise this.\n   */\n  public List<byte[]> split() {\n    List<byte[]> bytes = Lists.newArrayList();\n    int offset = 0;\n    while (offset < key.length) {\n      int length = Bytes.toInt(key, offset);\n      offset += Ints.BYTES;\n      bytes.add(Arrays.copyOfRange(key, offset, offset + length));\n      offset += length;\n    }\n    return bytes;\n  }","id":42429,"modified_method":"/**\n   * Splits the keys into the parts that comprise this.\n   */\n  public Splitter split() {\n    return new Splitter(key);\n  }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void simpleStringKeySplit() {\n    // Tests key: [ \"part1\", \"part2\", \"part3\" ]\n    List<String> originalKeyParts = ImmutableList.of(\"part1\", \"part2\", \"part3\");\n    MDSKey.Builder builder = new MDSKey.Builder();\n    for (String part : originalKeyParts) {\n      builder.add(part);\n    }\n    MDSKey mdsKey = builder.build();\n\n    List<String> splitKeyParts = Lists.newArrayList();\n    List<byte[]> splittedBytes = mdsKey.split();\n    for (byte[] bytes : splittedBytes) {\n      splitKeyParts.add(Bytes.toString(bytes));\n    }\n    Assert.assertEquals(originalKeyParts, splitKeyParts);\n  }","id":42430,"modified_method":"@Test\n  public void simpleStringKeySplit() {\n    // Tests key: [ \"part1\", \"part2\", \"part3\" ]\n    List<String> originalKeyParts = ImmutableList.of(\"part1\", \"part2\", \"part3\");\n    MDSKey.Builder builder = new MDSKey.Builder();\n    for (String part : originalKeyParts) {\n      builder.add(part);\n    }\n    MDSKey mdsKey = builder.build();\n\n    MDSKey.Splitter splitter = mdsKey.split();\n    for (String originalKeyPart : originalKeyParts) {\n      Assert.assertEquals(originalKeyPart, splitter.getString());\n    }\n  }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testComplexKeySplit() {\n    // Tests key: [ \"part1\", \"part2\", \"\", 4l, byte[] { 0x5 } ]\n    List<String> firstParts = ImmutableList.of(\"part1\", \"part2\", \"\");\n    long fourthPart = 4L;\n    byte[] fifthPart = new byte[] { 0x5 };\n\n    MDSKey.Builder builder = new MDSKey.Builder();\n    // intentionally testing the MDSKey.Builder#add(String... parts) method.\n    builder.add(firstParts.get(0), firstParts.get(1), firstParts.get(2));\n\n    builder.add(fourthPart);\n    builder.add(fifthPart);\n    MDSKey mdsKey = builder.build();\n\n    List<byte[]> splittedBytes = mdsKey.split();\n    List<String> splitKeyParts = Lists.newArrayList();\n\n    int i = 0;\n    for (; i < firstParts.size(); i++) {\n      splitKeyParts.add(Bytes.toString(splittedBytes.get(i)));\n    }\n    Assert.assertEquals(firstParts, splitKeyParts);\n\n    Assert.assertEquals(fourthPart, Bytes.toLong(splittedBytes.get(3)));\n    Assert.assertTrue(Bytes.equals(fifthPart, splittedBytes.get(4)));\n  }","id":42431,"modified_method":"@Test\n  public void testComplexKeySplit() {\n    // Tests key: [ \"part1\", \"part2\", \"\", 4l, byte[] { 0x5 } ]\n    List<String> firstParts = ImmutableList.of(\"part1\", \"part2\", \"\");\n    long fourthPart = 4L;\n    byte[] fifthPart = new byte[] { 0x5 };\n\n    MDSKey.Builder builder = new MDSKey.Builder();\n    // intentionally testing the MDSKey.Builder#add(String... parts) method.\n    builder.add(firstParts.get(0), firstParts.get(1), firstParts.get(2));\n\n    builder.add(fourthPart);\n    builder.add(fifthPart);\n    MDSKey mdsKey = builder.build();\n\n    MDSKey.Splitter splitter = mdsKey.split();\n    for (String part : firstParts) {\n      Assert.assertEquals(part, splitter.getString());\n    }\n    Assert.assertEquals(fourthPart, splitter.getLong());\n    Assert.assertTrue(Bytes.equals(fifthPart, splitter.getBytes()));\n  }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Multimap<Id.Namespace, StreamSpecification> listStreams() throws Exception {\n    return txnl.executeUnchecked(\n      new TransactionExecutor.Function<StreamMds, Multimap<Id.Namespace, StreamSpecification>>() {\n        @Override\n        public Multimap<Id.Namespace, StreamSpecification> apply(StreamMds mds) throws Exception {\n          ImmutableMultimap.Builder<Id.Namespace, StreamSpecification> builder = ImmutableMultimap.builder();\n          Map<MDSKey, StreamSpecification> streamSpecs =\n            mds.streams.listKV(new MDSKey.Builder().add(TYPE_STREAM).build(),\n                               StreamSpecification.class);\n          for (Map.Entry<MDSKey, StreamSpecification> streamSpecEntry : streamSpecs.entrySet()) {\n            List<byte[]> keyParts = streamSpecEntry.getKey().split();\n            // Namespace id is the key part with index 1.\n            String namespaceId = Bytes.toString(keyParts.get(1));\n            builder.put(Id.Namespace.from(namespaceId), streamSpecEntry.getValue());\n          }\n          return builder.build();\n        }\n      });\n  }","id":42432,"modified_method":"@Override\n  public Multimap<Id.Namespace, StreamSpecification> listStreams() throws Exception {\n    return txnl.executeUnchecked(\n      new TransactionExecutor.Function<StreamMds, Multimap<Id.Namespace, StreamSpecification>>() {\n        @Override\n        public Multimap<Id.Namespace, StreamSpecification> apply(StreamMds mds) throws Exception {\n          ImmutableMultimap.Builder<Id.Namespace, StreamSpecification> builder = ImmutableMultimap.builder();\n          Map<MDSKey, StreamSpecification> streamSpecs =\n            mds.streams.listKV(new MDSKey.Builder().add(TYPE_STREAM).build(),\n                               StreamSpecification.class);\n          for (Map.Entry<MDSKey, StreamSpecification> streamSpecEntry : streamSpecs.entrySet()) {\n            MDSKey.Splitter splitter = streamSpecEntry.getKey().split();\n            // skip the first name (\"stream\")\n            splitter.skipString();\n            // Namespace id is the next part.\n            String namespaceId = splitter.getString();\n            builder.put(Id.Namespace.from(namespaceId), streamSpecEntry.getValue());\n          }\n          return builder.build();\n        }\n      });\n  }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"public <T> Map<MDSKey, T> listKV(MDSKey startId, @Nullable MDSKey stopId, Class<T> classOfT, int limit,\n                                   Predicate<T> filter) {\n    byte[] startKey = startId.getKey();\n    byte[] stopKey = stopId == null ? Bytes.stopKeyForPrefix(startKey) : stopId.getKey();\n\n    try {\n      Map<MDSKey, T> map = Maps.newLinkedHashMap();\n      Scanner scan = table.scan(startKey, stopKey);\n      Row next;\n      while ((limit-- > 0) && (next = scan.next()) != null) {\n        byte[] columnValue = next.get(COLUMN);\n        if (columnValue == null) {\n          continue;\n        }\n        T value = deserialize(columnValue, classOfT);\n\n        if (filter.apply(value)) {\n          MDSKey key = new MDSKey.Builder().add(next.getRow()).build();\n          map.put(key, value);\n        }\n      }\n      return map;\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":42433,"modified_method":"public <T> Map<MDSKey, T> listKV(MDSKey startId, @Nullable MDSKey stopId, Class<T> classOfT, int limit,\n                                   Predicate<T> filter) {\n    byte[] startKey = startId.getKey();\n    byte[] stopKey = stopId == null ? Bytes.stopKeyForPrefix(startKey) : stopId.getKey();\n\n    try {\n      Map<MDSKey, T> map = Maps.newLinkedHashMap();\n      Scanner scan = table.scan(startKey, stopKey);\n      Row next;\n      while ((limit-- > 0) && (next = scan.next()) != null) {\n        byte[] columnValue = next.get(COLUMN);\n        if (columnValue == null) {\n          continue;\n        }\n        T value = deserialize(columnValue, classOfT);\n\n        if (filter.apply(value)) {\n          MDSKey key = new MDSKey(next.getRow());\n          map.put(key, value);\n        }\n      }\n      return map;\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"649795449ae09e48ab38fffc04347cf7d3600432","url":"https://github.com/caskdata/cdap"},{"original_method":"private org.graylog2.dashboards.Dashboard createDashboard(final Dashboard dashboardDescription, final String userName)\n            throws ValidationException, org.graylog2.dashboards.widgets.DashboardWidget.NoSuchWidgetTypeException, InvalidRangeParametersException, InvalidWidgetConfigurationException {\n        // Create dashboard.\n        Map<String, Object> dashboardData = ImmutableMap.<String, Object>of(\n                \"title\", dashboardDescription.getTitle(),\n                \"description\", dashboardDescription.getDescription(),\n                \"creator_user_id\", userName,\n                \"created_at\", DateTime.now(DateTimeZone.UTC));\n\n        final org.graylog2.dashboards.Dashboard dashboard = new DashboardImpl(dashboardData);\n        final String dashboardId = dashboardService.save(dashboard);\n\n        final ImmutableList.Builder<WidgetPositionRequest> widgetPositions = ImmutableList.builder();\n        for (DashboardWidget dashboardWidget : dashboardDescription.getDashboardWidgets()) {\n            final org.graylog2.dashboards.widgets.DashboardWidget widget = createDashboardWidget(dashboardWidget, userName);\n            dashboardService.addWidget(dashboard, widget);\n\n            // Please, kill me...\n            final WidgetPositionRequest positionRequest = new WidgetPositionRequest();\n            positionRequest.id = widget.getId();\n            positionRequest.row = dashboardWidget.getRow();\n            positionRequest.col = dashboardWidget.getCol();\n            widgetPositions.add(positionRequest);\n        }\n\n        dashboardService.updateWidgetPositions(dashboard, widgetPositions.build());\n        dashboardRegistry.add(dashboard);\n\n        return dashboard;\n    }","id":42434,"modified_method":"private org.graylog2.dashboards.Dashboard createDashboard(final Dashboard dashboardDescription, final String userName)\n            throws ValidationException, org.graylog2.dashboards.widgets.DashboardWidget.NoSuchWidgetTypeException, InvalidRangeParametersException, InvalidWidgetConfigurationException {\n        // Create dashboard.\n        Map<String, Object> dashboardData = ImmutableMap.<String, Object>of(\n                \"title\", dashboardDescription.getTitle(),\n                \"description\", dashboardDescription.getDescription(),\n                \"creator_user_id\", userName,\n                \"created_at\", DateTime.now(DateTimeZone.UTC));\n\n        final org.graylog2.dashboards.Dashboard dashboard = new DashboardImpl(dashboardData);\n        final String dashboardId = dashboardService.save(dashboard);\n\n        final ImmutableList.Builder<WidgetPositionRequest> widgetPositions = ImmutableList.builder();\n        for (DashboardWidget dashboardWidget : dashboardDescription.getDashboardWidgets()) {\n            final org.graylog2.dashboards.widgets.DashboardWidget widget = createDashboardWidget(dashboardWidget, userName);\n            dashboardService.addWidget(dashboard, widget);\n\n            final WidgetPositionRequest widgetPosition = new WidgetPositionRequest(widget.getId(),\n                    dashboardWidget.getRow(), dashboardWidget.getCol());\n            widgetPositions.add(widgetPosition);\n        }\n\n        dashboardService.updateWidgetPositions(dashboard, widgetPositions.build());\n        dashboardRegistry.add(dashboard);\n\n        return dashboard;\n    }","commit_id":"f274f175d99fd7baa890cf678d0db59ce78c1607","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public ImmutablePair<byte[], Map<byte[], byte[]>> next() {\n      //From the current iterator do one of the following:\n      // a) get all columns for current visible row if it is not the endRow\n      // b) return null if we have reached endRow\n      // c) return null if there are no more entries\n\n      long lastDelete = -1;\n      long undeleted = -1;\n      byte[] lastRow = new byte[0];\n      byte[] lastCol = new byte[0];\n      byte[] curCol = new byte[0];\n\n      Map<byte[], byte[]> columnValues = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n\n      while (iterator.hasNext()) {\n        Map.Entry<byte[], byte[]> entry = iterator.peekNext();\n        KeyValue keyValue = createKeyValue(entry.getKey(), entry.getValue());\n        byte[] row = keyValue.getRow();\n        System.out.println(\"----- main loop, looking at row -----\");\n        printRow(row);\n\n        if (endRow != null && Bytes.compareTo(row, endRow) >= 0) {\n          //already reached the end. So break.\n          break;\n        }\n\n        if (!Bytes.equals(lastRow, row)) {\n          lastDelete = -1;\n          undeleted = -1;\n          lastCol = new byte[0];\n          curCol = new byte[0];\n          if (columnValues.size() > 0){\n            //If we have reached here. We have read all columns for a single row - since current row is not the same\n            // as previous row and we have collected atleast one valid value in the columnValues collection. Break.\n            break;\n          }\n\n          org.apache.hadoop.hbase.KeyValue currKV = convert(keyValue);\n          Filter.ReturnCode rc = filter.filterKeyValue(currKV);\n\n          switch (rc) {\n            case INCLUDE:\n            case INCLUDE_AND_NEXT_COL:\n              System.out.println(\" INCLUDE!\");\n              printRow(row);\n              break;\n            case SEEK_NEXT_USING_HINT:\n              KeyValue nextKV = convert(filter.getNextKeyHint(currKV), keyValue);\n              byte[] nextKey = nextKV.getKey();\n              iterator.seek(nextKey);\n              lastRow = row;\n              continue;\n            case SKIP:\n            case NEXT_COL:\n            case NEXT_ROW:\n            default:\n              break;\n          }\n        }\n\n        lastRow = keyValue.getRow();\n        iterator.next();\n\n        if (filter.filterAllRemaining()) {\n          break;\n        }\n\n        if (!isVisible(keyValue)) {\n          continue;\n        }\n\n        if (Bytes.equals(lastCol, keyValue.getQualifier())) {\n          continue;\n        }\n\n        if (!Bytes.equals(curCol, keyValue.getQualifier())) {\n          curCol = keyValue.getQualifier();\n          lastDelete = -1;\n          undeleted = -1;\n        }\n\n        long curVersion = keyValue.getTimestamp();\n        KeyValue.Type type = KeyValue.Type.codeToType(keyValue.getType());\n\n        if (type == KeyValue.Type.Delete) {\n          lastDelete = curVersion;\n          continue;\n        }\n        if (curVersion == lastDelete) {\n          continue;\n        }\n\n        if (type == KeyValue.Type.UndeleteColumn) {\n          undeleted = curVersion;\n          continue;\n        }\n\n        if (type == KeyValue.Type.DeleteColumn) {\n          if (undeleted == curVersion) {\n            continue;\n          } else {\n            lastCol = keyValue.getQualifier();\n            continue;\n          }\n        }\n\n        if (type == KeyValue.Type.Put) {\n          if (curVersion != lastDelete) {\n            columnValues.put(keyValue.getQualifier(), keyValue.getValue());\n            lastCol = keyValue.getQualifier();\n          }\n        }\n      }\n      if (columnValues.size() == 0) {\n        return null;\n      } else {\n        return new ImmutablePair<byte[], Map<byte[], byte[]>>(lastRow, columnValues);\n\n      }\n    }","id":42435,"modified_method":"@Override\n    public ImmutablePair<byte[], Map<byte[], byte[]>> next() {\n      //From the current iterator do one of the following:\n      // a) get all columns for current visible row if it is not the endRow\n      // b) return null if we have reached endRow\n      // c) return null if there are no more entries\n\n      long lastDelete = -1;\n      long undeleted = -1;\n      byte[] lastRow = new byte[0];\n      byte[] lastCol = new byte[0];\n      byte[] curCol = new byte[0];\n\n      Map<byte[], byte[]> columnValues = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n\n      while (iterator.hasNext()) {\n        Map.Entry<byte[], byte[]> entry = iterator.peekNext();\n        KeyValue keyValue = createKeyValue(entry.getKey(), entry.getValue());\n        byte[] row = keyValue.getRow();\n        //System.out.println(\"----- main loop, looking at row -----\");\n        //printRow(row);\n\n        if (endRow != null && Bytes.compareTo(row, endRow) >= 0) {\n          //already reached the end. So break.\n          break;\n        }\n\n        if (!Bytes.equals(lastRow, row)) {\n          lastDelete = -1;\n          undeleted = -1;\n          lastCol = new byte[0];\n          curCol = new byte[0];\n          if (columnValues.size() > 0){\n            //If we have reached here. We have read all columns for a single row - since current row is not the same\n            // as previous row and we have collected atleast one valid value in the columnValues collection. Break.\n            break;\n          }\n        }\n\n\n        org.apache.hadoop.hbase.KeyValue currKV = convert(keyValue);\n        Filter.ReturnCode rc = filter.filterKeyValue(currKV);\n\n        switch (rc) {\n          case SEEK_NEXT_USING_HINT:\n            KeyValue nextKV = convert(filter.getNextKeyHint(currKV));\n            iterator.seek(nextKV.getKey());\n            lastRow = row;\n            continue;\n          case SKIP:\n          case NEXT_COL:\n          case NEXT_ROW:\n            lastRow = row;\n            iterator.next();\n            continue;\n          case INCLUDE:\n          case INCLUDE_AND_NEXT_COL:\n          default:\n            break;\n        }\n\n        lastRow = row;\n        iterator.next();\n\n        if (filter.filterAllRemaining()) {\n          break;\n        }\n\n        if (!isVisible(keyValue)) {\n          continue;\n        }\n\n        if (Bytes.equals(lastCol, keyValue.getQualifier())) {\n          continue;\n        }\n\n        if (!Bytes.equals(curCol, keyValue.getQualifier())) {\n          curCol = keyValue.getQualifier();\n          lastDelete = -1;\n          undeleted = -1;\n        }\n\n        long curVersion = keyValue.getTimestamp();\n        KeyValue.Type type = KeyValue.Type.codeToType(keyValue.getType());\n\n        if (type == KeyValue.Type.Delete) {\n          lastDelete = curVersion;\n          continue;\n        }\n        if (curVersion == lastDelete) {\n          continue;\n        }\n\n        if (type == KeyValue.Type.UndeleteColumn) {\n          undeleted = curVersion;\n          continue;\n        }\n\n        if (type == KeyValue.Type.DeleteColumn) {\n          if (undeleted == curVersion) {\n            continue;\n          } else {\n            lastCol = keyValue.getQualifier();\n            continue;\n          }\n        }\n\n        if (type == KeyValue.Type.Put) {\n          if (curVersion != lastDelete) {\n            columnValues.put(keyValue.getQualifier(), keyValue.getValue());\n            lastCol = keyValue.getQualifier();\n          }\n        }\n      }\n      if (columnValues.size() == 0) {\n        return null;\n      } else {\n        return new ImmutablePair<byte[], Map<byte[], byte[]>>(lastRow, columnValues);\n\n      }\n    }","commit_id":"01b214d1080f3b4d19ecee32318122361a09b0f5","url":"https://github.com/caskdata/cdap"},{"original_method":"public static KeyValue convert(org.apache.hadoop.hbase.KeyValue nextKV, KeyValue currKV) {\n    KeyValue.Type type = KeyValue.Type.codeToType(nextKV.getType());\n    // should be in the filter logic, but hbase fuzzy doesn't look at family, qualifier, value, will return empty bytes.\n    return new KeyValue(nextKV.getRow(), currKV.getFamily(), currKV.getQualifier(),\n                        currKV.getTimestamp(), type, currKV.getValue());\n  }","id":42436,"modified_method":"public static KeyValue convert(org.apache.hadoop.hbase.KeyValue kv) {\n    KeyValue.Type type = KeyValue.Type.codeToType(kv.getType());\n    return new KeyValue(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n                        kv.getTimestamp(), type, kv.getValue());\n  }","commit_id":"01b214d1080f3b4d19ecee32318122361a09b0f5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public KeyValue getNextKeyHint(KeyValue currentKV) {\n    KeyValue next = filter.getNextKeyHint(currentKV);\n    byte[] nextRow = next.getRow();\n    //System.out.println(\"----- propose skip to row -----\");\n    //printRow(nextRow);\n    return next;\n  }","id":42437,"modified_method":"@Override\n  public KeyValue getNextKeyHint(KeyValue currentKV) {\n    KeyValue next = filter.getNextKeyHint(currentKV);\n    KeyValue.Type type = KeyValue.Type.codeToType(next.getType());\n    // using the currentKV's family, qualifier, timestamp, and value, otherwise they will\n    // be empty byte arrays which will cause level db's KeyValue implementation to represent\n    // the actual key it uses with fewer bytes, which will mess with the seeking.\n    KeyValue output = new KeyValue(next.getRow(), currentKV.getFamily(), currentKV.getQualifier(),\n                                   currentKV.getTimestamp(), type, currentKV.getValue());\n    //System.out.println(\"----- propose skip to row -----\");\n    //printRow(nextRow);\n    return output;\n  }","commit_id":"01b214d1080f3b4d19ecee32318122361a09b0f5","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void main(String[] args) throws Exception {\n    init();\n    TimeSeriesTable tsTable = tableFactory.createTimeSeries(MetricsScope.REACTOR.name(), 1);\n    //long end = TimeUnit.SECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    long end = 1377300420;\n    long begin = end - 60;\n    MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n      .setContext(null)\n      .setMetric(\"store.ops\")\n      .build(begin, end);\n\n    JniDBFactory.pushMemoryPool(1024 * 1024 * 100);\n    try {\n\n    int i = 0;\n    int rows;\n    long start, dur;\n    //while (true) {\n      i++;\n      MetricsScanner scanner = tsTable.scan(scanQuery);\n      start = System.currentTimeMillis();\n      rows = 0;\n      while (scanner.hasNext()) {\n        MetricsScanResult res = scanner.next();\n        System.out.println(\"context = \" + res.getContext() + \" metric = \" + res.getMetric() +\n                             \" tag = \" + res.getTag());\n        rows++;\n      }\n      dur = System.currentTimeMillis() - start;\n      System.out.println(\"scan #\" + i + \" took \" + dur + \" ms, scanned \" + rows + \" rows\");\n    //}\n    } finally {\n      JniDBFactory.popMemoryPool();\n    }\n  }","id":42438,"modified_method":"public static void main(String[] args) throws Exception {\n    init();\n    TimeSeriesTable tsTable = tableFactory.createTimeSeries(MetricsScope.REACTOR.name(), 1);\n    //long end = TimeUnit.SECONDS.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);\n    long end = 1377300420;\n    long begin = end - 60;\n    MetricsScanQuery scanQuery = new MetricsScanQueryBuilder()\n      .setContext(null)\n      .setMetric(\"store.ops\")\n      .build(begin, end);\n\n    JniDBFactory.pushMemoryPool(1024 * 1024 * 100);\n    try {\n\n    int i = 0;\n    int rows;\n    long start, dur;\n    //while (true) {\n      i++;\n      MetricsScanner scanner = tsTable.scan(scanQuery);\n      start = System.currentTimeMillis();\n      rows = 0;\n      while (scanner.hasNext()) {\n        MetricsScanResult res = scanner.next();\n        System.out.println(\"context = \" + res.getContext() + \" metric = \" + res.getMetric() +\n                             \" tag = \" + res.getTag());\n        for (TimeValue tv : res) {\n          System.out.println(\"time = \" + tv.getTime() + \" val = \" + tv.getValue());\n        }\n        rows++;\n      }\n      dur = System.currentTimeMillis() - start;\n      System.out.println(\"scan #\" + i + \" took \" + dur + \" ms, scanned \" + rows + \" rows\");\n    //}\n    } finally {\n      JniDBFactory.popMemoryPool();\n    }\n  }","commit_id":"01b214d1080f3b4d19ecee32318122361a09b0f5","url":"https://github.com/caskdata/cdap"},{"original_method":"public MetricsScanner scan(MetricsScanQuery query) {\n    int startTimeBase = getTimeBase(query.getStartTime());\n    int endTimeBase = getTimeBase(query.getEndTime());\n\n    byte[][] columns = null;\n    if (startTimeBase == endTimeBase) {\n      // If on the same timebase, we only need subset of columns\n      int startCol = (int) (query.getStartTime() - startTimeBase) / resolution;\n      int endCol = (int) (query.getEndTime() - endTimeBase) / resolution;\n      columns = new byte[endCol - startCol + 1][];\n\n      for (int i = 0; i < columns.length; i++) {\n        columns[i] = Bytes.toBytes((short) (startCol + i));\n      }\n    }\n\n    byte[] startRow = getPaddedKey(query.getContextPrefix(), query.getRunId(),\n                                   query.getMetricPrefix(), query.getTagPrefix(), startTimeBase, 0);\n    byte[] endRow = getPaddedKey(query.getContextPrefix(), query.getRunId(),\n                                 query.getMetricPrefix(), query.getTagPrefix(), endTimeBase + 1, 0xff);\n\n    Scanner scanner;\n    if (timeSeriesTable instanceof HBaseFilterableOVCTable) {\n      scanner = timeSeriesTable.scan(startRow, endRow, columns,\n                                                            MemoryReadPointer.DIRTY_READ,\n                                                            getFilter(query, startTimeBase, endTimeBase));\n    } else if (timeSeriesTable instanceof LevelDBFilterableOVCTable) {\n      LevelDBFuzzyRowFilter f = new LevelDBFuzzyRowFilter(getFilter(query, startTimeBase, endTimeBase));\n      f.setCodec(entityCodec);\n      scanner = timeSeriesTable.scan(startRow, endRow, columns, MemoryReadPointer.DIRTY_READ, f);\n    }\n    /*if (isFilterable && ((FilterableOVCTable) timeSeriesTable).isFilterSupported(FuzzyRowFilter.class)) {\n      scanner = ((FilterableOVCTable) timeSeriesTable).scan(startRow, endRow, columns,\n                                                        MemoryReadPointer.DIRTY_READ,\n                                                        getFilter(query, startTimeBase, endTimeBase));\n    } else {\n      scanner = timeSeriesTable.scan(startRow, endRow, columns, MemoryReadPointer.DIRTY_READ);\n    }*/\n    return new MetricsScanner(query, scanner, entityCodec, resolution);\n  }","id":42439,"modified_method":"public MetricsScanner scan(MetricsScanQuery query) {\n    int startTimeBase = getTimeBase(query.getStartTime());\n    int endTimeBase = getTimeBase(query.getEndTime());\n\n    byte[][] columns = null;\n    if (startTimeBase == endTimeBase) {\n      // If on the same timebase, we only need subset of columns\n      int startCol = (int) (query.getStartTime() - startTimeBase) / resolution;\n      int endCol = (int) (query.getEndTime() - endTimeBase) / resolution;\n      columns = new byte[endCol - startCol + 1][];\n\n      for (int i = 0; i < columns.length; i++) {\n        columns[i] = Bytes.toBytes((short) (startCol + i));\n      }\n    }\n\n    byte[] startRow = getPaddedKey(query.getContextPrefix(), query.getRunId(),\n                                   query.getMetricPrefix(), query.getTagPrefix(), startTimeBase, 0);\n    byte[] endRow = getPaddedKey(query.getContextPrefix(), query.getRunId(),\n                                 query.getMetricPrefix(), query.getTagPrefix(), endTimeBase + 1, 0xff);\n\n    Scanner scanner;\n    if (timeSeriesTable instanceof HBaseFilterableOVCTable &&\n      ((FilterableOVCTable) timeSeriesTable).isFilterSupported(FuzzyRowFilter.class)) {\n      scanner = timeSeriesTable.scan(startRow, endRow, columns,\n                                                            MemoryReadPointer.DIRTY_READ,\n                                                            getFilter(query, startTimeBase, endTimeBase));\n    } else if (timeSeriesTable instanceof LevelDBFilterableOVCTable) {\n      LevelDBFuzzyRowFilter f = new LevelDBFuzzyRowFilter(getFilter(query, startTimeBase, endTimeBase));\n      f.setCodec(entityCodec);\n      scanner = timeSeriesTable.scan(startRow, endRow, columns, MemoryReadPointer.DIRTY_READ, f);\n    } else {\n      scanner = timeSeriesTable.scan(startRow, endRow, columns, MemoryReadPointer.DIRTY_READ);\n    }\n\n    return new MetricsScanner(query, scanner, entityCodec, resolution);\n  }","commit_id":"01b214d1080f3b4d19ecee32318122361a09b0f5","url":"https://github.com/caskdata/cdap"},{"original_method":"/** \r\n   * Finalize a row mutation and release any resources associated with the update.\r\n   * \r\n   * @param lockid lock id returned from startUpdate\r\n   * @param timestamp time to associate with the change\r\n   * @throws IOException\r\n   */\r\n  public synchronized void commit(long lockid, long timestamp)\r\n  throws IOException {\r\n    checkClosed();\r\n    updateInProgress(true);\r\n    if (batch.get().getLockid() != lockid) {\r\n      throw new IllegalArgumentException(\"invalid lock id \" + lockid);\r\n    }\r\n    \r\n    try {\r\n      for (int tries = 0; tries < numRetries; tries++) {\r\n        HRegionLocation r = getRegionLocation(batch.get().getRow());\r\n        HRegionInterface server =\r\n          connection.getHRegionConnection(r.getServerAddress());\r\n        try {\r\n          server.batchUpdate(r.getRegionInfo().getRegionName(), timestamp,\r\n            batch.get());\r\n          break;\r\n        } catch (IOException e) {\r\n          if (e instanceof RemoteException) {\r\n            e = RemoteExceptionHandler.decodeRemoteException(\r\n                (RemoteException) e);\r\n          }\r\n          if (tries < numRetries - 1) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n            }\r\n            r = getRegionLocation(batch.get().getRow(), true);\r\n          } else {\r\n            throw e;\r\n          }\r\n        }\r\n        try {\r\n          Thread.sleep(pause);\r\n        } catch (InterruptedException e) {\r\n          // continue\r\n        }\r\n      }\r\n    } finally {\r\n      batch.set(null);\r\n    }\r\n  }","id":42440,"modified_method":"/** \r\n   * Finalize a row mutation and release any resources associated with the update.\r\n   * \r\n   * @param lockid lock id returned from startUpdate\r\n   * @param timestamp time to associate with the change\r\n   * @throws IOException\r\n   */\r\n  public synchronized void commit(long lockid, final long timestamp)\r\n  throws IOException {\r\n    checkClosed();\r\n    updateInProgress(true);\r\n    if (batch.get().getLockid() != lockid) {\r\n      throw new IllegalArgumentException(\"invalid lock id \" + lockid);\r\n    }\r\n    \r\n    try {\r\n      getRegionServerWithRetries(\r\n        new ServerCallable<Boolean>(batch.get().getRow()){\r\n          public Boolean call() throws IOException {\r\n            server.batchUpdate(location.getRegionInfo().getRegionName(), \r\n              timestamp, batch.get());\r\n            return null;\r\n          }\r\n        }\r\n      );\r\n    } finally {\r\n      batch.set(null);\r\n    }\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * Delete all cells for a row with matching column family with timestamps\r\n   * less than or equal to <i>timestamp<\/i>.\r\n   *\r\n   * @param row The row to operate on\r\n   * @param family The column family to match\r\n   * @param timestamp Timestamp to match\r\n   * @throws IOException\r\n   */\r\n  public void deleteFamily(final Text row, final Text family, long timestamp)\r\n  throws IOException {\r\n    checkClosed();\r\n    for(int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server =\r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      try {\r\n        server.deleteFamily(r.getRegionInfo().getRegionName(), row, family, timestamp);\r\n        break;\r\n\r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n  }","id":42441,"modified_method":"/**\r\n   * Delete all cells for a row with matching column family with timestamps\r\n   * less than or equal to <i>timestamp<\/i>.\r\n   *\r\n   * @param row The row to operate on\r\n   * @param family The column family to match\r\n   * @param timestamp Timestamp to match\r\n   * @throws IOException\r\n   */\r\n  public void deleteFamily(final Text row, final Text family, \r\n    final long timestamp)\r\n  throws IOException {\r\n    checkClosed();\r\n    \r\n    getRegionServerWithRetries(new ServerCallable<Boolean>(row){\r\n      public Boolean call() throws IOException {\r\n        server.deleteFamily(location.getRegionInfo().getRegionName(), row, \r\n          family, timestamp);\r\n        return null;\r\n      }\r\n    });\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * Completely delete the row's cells of the same timestamp or older.\r\n   *\r\n   * @param row Key of the row you want to completely delete.\r\n   * @param ts Timestamp of cells to delete\r\n   * @throws IOException\r\n   */\r\n  public void deleteAll(final Text row, long ts) throws IOException {\r\n    checkClosed();\r\n    for(int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server =\r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      try {\r\n        server.deleteAll(r.getRegionInfo().getRegionName(), row, ts);\r\n        break;\r\n\r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n  }","id":42442,"modified_method":"/**\r\n   * Completely delete the row's cells of the same timestamp or older.\r\n   *\r\n   * @param row Key of the row you want to completely delete.\r\n   * @param ts Timestamp of cells to delete\r\n   * @throws IOException\r\n   */\r\n  public void deleteAll(final Text row, final long ts) throws IOException {\r\n    checkClosed();\r\n    \r\n    getRegionServerWithRetries(new ServerCallable<Boolean>(row){\r\n      public Boolean call() throws IOException {\r\n        server.deleteAll(location.getRegionInfo().getRegionName(), row, ts);\r\n        return null;\r\n      }\r\n    });\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/** \r\n   * Get the specified number of versions of the specified row and column with\r\n   * the specified timestamp.\r\n   *\r\n   * @param row         - row key\r\n   * @param column      - column name\r\n   * @param timestamp   - timestamp\r\n   * @param numVersions - number of versions to retrieve\r\n   * @return            - array of values that match the above criteria\r\n   * @throws IOException\r\n   */\r\n  public byte[][] get(Text row, Text column, long timestamp, int numVersions)\r\n  throws IOException {\r\n    checkClosed();\r\n    byte [][] values = null;\r\n    for (int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server =\r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      \r\n      try {\r\n        values = server.get(r.getRegionInfo().getRegionName(), row, column,\r\n            timestamp, numVersions);\r\n        \r\n        break;\r\n    \r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          // No more tries\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n\r\n    if (values != null) {\r\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\r\n      for (int i = 0 ; i < values.length; i++) {\r\n        bytes.add(values[i]);\r\n      }\r\n      return bytes.toArray(new byte[values.length][]);\r\n    }\r\n    return null;\r\n  }","id":42443,"modified_method":"/** \r\n   * Get the specified number of versions of the specified row and column with\r\n   * the specified timestamp.\r\n   *\r\n   * @param row         - row key\r\n   * @param column      - column name\r\n   * @param timestamp   - timestamp\r\n   * @param numVersions - number of versions to retrieve\r\n   * @return            - array of values that match the above criteria\r\n   * @throws IOException\r\n   */\r\n  public byte[][] get(final Text row, final Text column, final long timestamp, \r\n    final int numVersions)\r\n  throws IOException {\r\n    checkClosed();\r\n    byte [][] values = null;\r\n\r\n    values = getRegionServerWithRetries(new ServerCallable<byte[][]>(row) {\r\n      public byte [][] call() throws IOException {\r\n        return server.get(location.getRegionInfo().getRegionName(), row, \r\n          column, timestamp, numVersions);\r\n      }\r\n    });\r\n\r\n    if (values != null) {\r\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\r\n      for (int i = 0 ; i < values.length; i++) {\r\n        bytes.add(values[i]);\r\n      }\r\n      return bytes.toArray(new byte[values.length][]);\r\n    }\r\n    return null;\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/** \r\n   * Delete all cells that match the passed row and column and whose\r\n   * timestamp is equal-to or older than the passed timestamp.\r\n   * @param row Row to update\r\n   * @param column name of column whose value is to be deleted\r\n   * @param ts Delete all cells of the same timestamp or older.\r\n   * @throws IOException \r\n   */\r\n  public void deleteAll(final Text row, final Text column, final long ts)\r\n  throws IOException {\r\n    checkClosed();\r\n    for(int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server =\r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      try {\r\n        server.deleteAll(r.getRegionInfo().getRegionName(), row, column, ts);\r\n        break;\r\n        \r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n  }","id":42444,"modified_method":"/** \r\n   * Delete all cells that match the passed row and column and whose\r\n   * timestamp is equal-to or older than the passed timestamp.\r\n   * @param row Row to update\r\n   * @param column name of column whose value is to be deleted\r\n   * @param ts Delete all cells of the same timestamp or older.\r\n   * @throws IOException \r\n   */\r\n  public void deleteAll(final Text row, final Text column, final long ts)\r\n  throws IOException {\r\n    checkClosed();\r\n          \r\n    getRegionServerWithRetries(new ServerCallable<Boolean>(row) {\r\n      public Boolean call() throws IOException {\r\n        server.deleteAll(location.getRegionInfo().getRegionName(), row, \r\n          column, ts);\r\n        return null;\r\n      }\r\n    });\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/** \r\n   * Get a single value for the specified row and column\r\n   *\r\n   * @param row row key\r\n   * @param column column name\r\n   * @return value for specified row/column\r\n   * @throws IOException\r\n   */\r\n  public byte[] get(Text row, Text column) throws IOException {\r\n    checkClosed();\r\n    byte [] value = null;\r\n    for(int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server =\r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      \r\n      try {\r\n        value = server.get(r.getRegionInfo().getRegionName(), row, column);\r\n        break;\r\n        \r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n    return value;\r\n  }","id":42445,"modified_method":"/** \r\n   * Get a single value for the specified row and column\r\n   *\r\n   * @param row row key\r\n   * @param column column name\r\n   * @return value for specified row/column\r\n   * @throws IOException\r\n   */\r\n   public byte[] get(Text row, final Text column) throws IOException {\r\n     checkClosed();\r\n     \r\n     return getRegionServerWithRetries(new ServerCallable<byte[]>(row){\r\n       public byte[] call() throws IOException {\r\n         return server.get(location.getRegionInfo().getRegionName(), row, column);\r\n       }\r\n     });\r\n   }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/** \r\n   * Get all the data for the specified row at a specified timestamp\r\n   * \r\n   * @param row row key\r\n   * @param ts timestamp\r\n   * @return Map of columns to values.  Map is empty if row does not exist.\r\n   * @throws IOException\r\n   */\r\n  public SortedMap<Text, byte[]> getRow(Text row, long ts) throws IOException {\r\n    checkClosed();\r\n    HbaseMapWritable value = null;\r\n    for (int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server =\r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      \r\n      try {\r\n        value = server.getRow(r.getRegionInfo().getRegionName(), row, ts);\r\n        break;\r\n        \r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          // No more tries\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n    SortedMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\r\n    if (value != null && value.size() != 0) {\r\n      for (Map.Entry<Writable, Writable> e: value.entrySet()) {\r\n        HStoreKey key = (HStoreKey) e.getKey();\r\n        results.put(key.getColumn(),\r\n            ((ImmutableBytesWritable) e.getValue()).get());\r\n      }\r\n    }\r\n    return results;\r\n  }","id":42446,"modified_method":"/** \r\n   * Get all the data for the specified row at a specified timestamp\r\n   * \r\n   * @param row row key\r\n   * @param ts timestamp\r\n   * @return Map of columns to values.  Map is empty if row does not exist.\r\n   * @throws IOException\r\n   */\r\n  public SortedMap<Text, byte[]> getRow(final Text row, final long ts) \r\n  throws IOException {\r\n    checkClosed();\r\n    HbaseMapWritable value = null;\r\n         \r\n    value = getRegionServerWithRetries(new ServerCallable<HbaseMapWritable>(row) {\r\n      public HbaseMapWritable call() throws IOException {\r\n        return server.getRow(location.getRegionInfo().getRegionName(), row, ts);\r\n      }\r\n    });\r\n    \r\n    SortedMap<Text, byte[]> results = new TreeMap<Text, byte[]>();\r\n    if (value != null && value.size() != 0) {\r\n      for (Map.Entry<Writable, Writable> e: value.entrySet()) {\r\n        HStoreKey key = (HStoreKey) e.getKey();\r\n        results.put(key.getColumn(),\r\n            ((ImmutableBytesWritable) e.getValue()).get());\r\n      }\r\n    }\r\n    return results;\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"/** \r\n   * Get the specified number of versions of the specified row and column\r\n   * \r\n   * @param row         - row key\r\n   * @param column      - column name\r\n   * @param numVersions - number of versions to retrieve\r\n   * @return            - array byte values\r\n   * @throws IOException\r\n   */\r\n  public byte[][] get(Text row, Text column, int numVersions) throws IOException {\r\n    checkClosed();\r\n    byte [][] values = null;\r\n    for (int tries = 0; tries < numRetries; tries++) {\r\n      HRegionLocation r = getRegionLocation(row);\r\n      HRegionInterface server = \r\n        connection.getHRegionConnection(r.getServerAddress());\r\n      \r\n      try {\r\n        values = server.get(r.getRegionInfo().getRegionName(), row, column,\r\n            numVersions);\r\n        \r\n        break;\r\n        \r\n      } catch (IOException e) {\r\n        if (e instanceof RemoteException) {\r\n          e = RemoteExceptionHandler.decodeRemoteException((RemoteException) e);\r\n        }\r\n        if (tries == numRetries - 1) {\r\n          // No more tries\r\n          throw e;\r\n        }\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"reloading table servers because: \" + e.getMessage());\r\n        }\r\n        r = getRegionLocation(row, true);\r\n      }\r\n      try {\r\n        Thread.sleep(this.pause);\r\n      } catch (InterruptedException x) {\r\n        // continue\r\n      }\r\n    }\r\n\r\n    if (values != null) {\r\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\r\n      for (int i = 0 ; i < values.length; i++) {\r\n        bytes.add(values[i]);\r\n      }\r\n      return bytes.toArray(new byte[values.length][]);\r\n    }\r\n    return null;\r\n  }","id":42447,"modified_method":"/** \r\n   * Get the specified number of versions of the specified row and column\r\n   * \r\n   * @param row         - row key\r\n   * @param column      - column name\r\n   * @param numVersions - number of versions to retrieve\r\n   * @return            - array byte values\r\n   * @throws IOException\r\n   */\r\n  public byte[][] get(final Text row, final Text column, final int numVersions) \r\n  throws IOException {\r\n    checkClosed();\r\n    byte [][] values = null;\r\n\r\n    values = getRegionServerWithRetries(new ServerCallable<byte[][]>(row) {\r\n      public byte [][] call() throws IOException {\r\n        return server.get(location.getRegionInfo().getRegionName(), row, \r\n          column, numVersions);\r\n      }\r\n    });\r\n\r\n    if (values != null) {\r\n      ArrayList<byte[]> bytes = new ArrayList<byte[]>();\r\n      for (int i = 0 ; i < values.length; i++) {\r\n        bytes.add(values[i]);\r\n      }\r\n      return bytes.toArray(new byte[values.length][]);\r\n    }\r\n    return null;\r\n  }","commit_id":"5a033b71f43e90e60b869e59492357589a1aef0e","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    return context.triggers.attach(name, context.session);\n  }","id":42448,"modified_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    if(context.triggers.attach(name, context.session)) {\n      return info(TRIGGERATT, name);\n    }\n    return error(TRIGGERNO, name);\n  }","commit_id":"09f65124c1227c46129a3104a69c17ddf3d53b0a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor, specifying the server host:port combination and the\r\n   * login and password.\r\n   * @param host server name\r\n   * @param port server port\r\n   * @param user user name\r\n   * @param pw password\r\n   * @param output client output; if set to {@code null}, results will\r\n   * be returned as strings.\r\n   * @throws IOException I/O exception\r\n   */\r\n  public ClientSession(final String host, final int port, final String user,\r\n      final String pw, final OutputStream output) throws IOException {\r\n\r\n    super(output);\r\n\r\n    // initialize trigger notifications\r\n    tn = new HashMap<String, List<TriggerNotification>>();\r\n\r\n    // 5 seconds timeout\r\n    socket = new Socket();\r\n    socket.connect(new InetSocketAddress(host, port), 5000);\r\n    sin = socket.getInputStream();\r\n\r\n    // receive timestamp\r\n    final BufferInput bi = new BufferInput(sin);\r\n    final String ts = bi.readString();\r\n\r\n    // send user name and hashed password/timestamp\r\n    sout = PrintOutput.get(socket.getOutputStream());\r\n    send(user);\r\n    send(Token.md5(Token.md5(pw) + ts));\r\n    sout.flush();\r\n\r\n    // receive success flag\r\n    if(!ok(bi)) throw new LoginException();\r\n\r\n    // final OutputStream o = new FileOutputStream(\"out_\" + user + \".txt\");\r\n    new Thread(\"ClientSession \" + user + \": Input Thread\"\r\n        + Thread.activeCount()) {\r\n\r\n      /*\r\n       * (non-Javadoc)\r\n       * @see java.lang.Thread#run()\r\n       */\r\n      @Override\r\n      public void run() {\r\n        super.run();\r\n\r\n        try {\r\n          while(true) {\r\n//            System.out.println(\"Prepare buffer for user \" + user + \"\\n\");\r\n\r\n            final ArrayOutput o = new ArrayOutput();\r\n\r\n            int l;\r\n            while((l = bi.read()) != 0)\r\n              if (sink != null)\r\n                sink.write(l);\r\n              else\r\n                o.write(l);\r\n\r\n            info = bi.readString();\r\n            boolean ok = bi.read() == 0 ? true : false;\r\n            if(!ok) {\r\n              final String inf = info();\r\n              if(!inf.isEmpty()) {\r\n                if (sink != null)\r\n                  sink.write(inf.getBytes());\r\n                else\r\n                  o.write(inf.getBytes());\r\n              }\r\n            }\r\n\r\n            // Set sink as unset.\r\n            if (sink != null) {\r\n              sink.flush();\r\n              sink = null;\r\n            } else {\r\n              String res = o.toString();\r\n\r\n              if(!\"\".equals(res)) {\r\n                int idx = res.indexOf(' ');\r\n                String name = res.substring(0, idx);\r\n                String val = res.substring(idx + 1);\r\n                if(tn.size() > 0) for(TriggerNotification t : tn.get(name))\r\n                  t.update(val);\r\n              }\r\n            }\r\n\r\n            synchronized(lock) {\r\n              lock.notifyAll();\r\n//              System.out.println(\"UNLOCKED\");\r\n            }\r\n\r\n            o.close();\r\n          }\r\n\r\n        } catch(IOException e) {\r\n          if (!SOCKET_CLOSED.equals(e.getMessage()))\r\n            e.printStackTrace();\r\n        }\r\n      }\r\n    }.start();\r\n  }","id":42449,"modified_method":"/**\r\n   * Constructor, specifying the server host:port combination and the\r\n   * login and password.\r\n   * @param host server name\r\n   * @param port server port\r\n   * @param user user name\r\n   * @param pw password\r\n   * @param output client output; if set to {@code null}, results will\r\n   * be returned as strings.\r\n   * @throws IOException I/O exception\r\n   */\r\n  public ClientSession(final String host, final int port, final String user,\r\n      final String pw, final OutputStream output) throws IOException {\r\n\r\n    super(output);\r\n\r\n    // initialize trigger notifications\r\n    tn = new HashMap<String, List<TriggerNotification>>();\r\n\r\n    // 5 seconds timeout\r\n    socket = new Socket();\r\n    socket.connect(new InetSocketAddress(host, port), 5000);\r\n    sin = socket.getInputStream();\r\n\r\n    // receive timestamp\r\n    final BufferInput bi = new BufferInput(sin);\r\n    final String ts = bi.readString();\r\n\r\n    // send user name and hashed password/timestamp\r\n    sout = PrintOutput.get(socket.getOutputStream());\r\n    send(user);\r\n    send(Token.md5(Token.md5(pw) + ts));\r\n    sout.flush();\r\n\r\n    // receive success flag\r\n    if(!ok(bi)) throw new LoginException();\r\n    startListener();\r\n  }","commit_id":"09f65124c1227c46129a3104a69c17ddf3d53b0a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Detaches from a trigger.\r\n   * @param name trigger name\r\n   * @throws BaseXException exception\r\n   */\r\n  public void detachTrigger(final String name) throws BaseXException {\r\n\r\n    // empty trigger notification list.\r\n    tn.put(name, null);\r\n\r\n    execute(\"detach trigger \" + name);\r\n  }","id":42450,"modified_method":"/**\r\n   * Detaches from a trigger.\r\n   * @param name trigger name\r\n   * @throws BaseXException exception\r\n   */\r\n  public void detachTrigger(final String name) throws BaseXException {\r\n    // remove trigger notification.\r\n    tn.remove(name);\r\n    execute(\"detach trigger \" + name);\r\n  }","commit_id":"09f65124c1227c46129a3104a69c17ddf3d53b0a","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    return context.triggers.drop(name);\n  }","id":42451,"modified_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    if(context.triggers.detach(name, context.session)) {\n      return info(TRIGGERDET, name);\n    }\n    return error(TRIGGERNO, name);\n  }","commit_id":"09f65124c1227c46129a3104a69c17ddf3d53b0a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Drops triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void drop() throws BaseXException {\n    // Create triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    // Drop triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"drop trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    // Query must not return any trigger.\n    assertEquals(\"\", triggers);\n  }","id":42452,"modified_method":"/**\n   * Drops triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void drop() throws BaseXException {\n    // Create triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    // Drop triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"drop trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n    // Query must not return any trigger.\n    assertEquals(\"0\", triggers.substring(0, 1));\n  }","commit_id":"09f65124c1227c46129a3104a69c17ddf3d53b0a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void create() throws BaseXException {\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    String[] triggerNames = triggers.split(\"\\n\");\n    Arrays.sort(triggerNames);\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      assertEquals(TRIGGER_NAME + i, triggerNames[i]);\n    }\n  }","id":42453,"modified_method":"/**\n   * Creates triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void create() throws BaseXException {\n    for(int i = 1; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    String[] triggerNames = triggers.split(\"\\n\");\n    Arrays.sort(triggerNames);\n    for(int i = 1; i < TRIGGER_COUNT; i++) {\n      assertEquals(TRIGGER_NAME + i, triggerNames[i]);\n    }\n  }","commit_id":"09f65124c1227c46129a3104a69c17ddf3d53b0a","url":"https://github.com/BaseXdb/basex"},{"original_method":"public static void attach(@NotNull Process process, @NotNull Consumer<Integer> callback) {\n    ourQueue.put(process, callback);\n  }","id":42454,"modified_method":"public static void attach(@NotNull Process process, @NotNull Consumer<Integer> callback) {\n    synchronized (ourQueue) {\n      ourQueue.putValue(process, callback);\n    }\n  }","commit_id":"c26e6fc8a0766984e954dfcb074ebd6457a1ac26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processQueue() {\n    for (Process process : ourQueue.keySet()) {\n      try {\n        int value = process.exitValue();\n\n        Consumer<Integer> callback = ourQueue.remove(process);\n        if (callback != null) {\n          callback.consume(value);\n        }\n      }\n      catch (IllegalThreadStateException ignore) { }\n      catch (RuntimeException e) {\n        LOG.debug(e);\n      }\n    }\n  }","id":42455,"modified_method":"private static void processQueue() {\n    synchronized (ourQueue) {\n      for (Iterator<Process> iterator = ourQueue.keySet().iterator(); iterator.hasNext(); ) {\n        Process process = iterator.next();\n        try {\n          int value = process.exitValue();\n\n          Collection<Consumer<Integer>> callbacks = ourQueue.get(process);\n          for (Consumer<Integer> callback : callbacks) {\n            callback.consume(value);\n          }\n\n          iterator.remove();\n        }\n        catch (IllegalThreadStateException ignore) { }\n        catch (RuntimeException e) {\n          LOG.debug(e);\n        }\n      }\n    }\n  }","commit_id":"c26e6fc8a0766984e954dfcb074ebd6457a1ac26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void detach(@NotNull Process process) {\n    ourQueue.remove(process);\n  }","id":42456,"modified_method":"public static void detach(@NotNull Process process) {\n    synchronized (ourQueue) {\n      ourQueue.remove(process);\n    }\n  }","commit_id":"c26e6fc8a0766984e954dfcb074ebd6457a1ac26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test(timeout = 10000)\n  public void notification() throws IOException, InterruptedException {\n    File jvm = new File(System.getProperty(\"java.home\"), \"bin/java\");\n    assertTrue(jvm.canExecute());\n\n    final Semaphore semaphore = new Semaphore();\n    semaphore.down();\n\n    Process process = new ProcessBuilder(jvm.getPath(), \"-version\").redirectErrorStream(true).start();\n    ProcessWaitFor.attach(process, new Consumer<Integer>() {\n      @Override\n      public void consume(Integer exitCode) {\n        semaphore.up();\n      }\n    });\n    process.waitFor();\n\n    assertTrue(semaphore.waitFor(5000));\n  }","id":42457,"modified_method":"@Test(timeout = 10000)\n  public void notification() throws IOException, InterruptedException {\n    File jvm = new File(System.getProperty(\"java.home\"), \"bin/java\");\n    assertTrue(jvm.canExecute());\n\n    final Semaphore semaphore1 = new Semaphore();\n    semaphore1.down();\n    Process process1 = new ProcessBuilder(jvm.getPath(), \"-help\").redirectErrorStream(true).start();\n    ProcessWaitFor.attach(process1, new Consumer<Integer>() {\n      @Override\n      public void consume(Integer exitCode) {\n        semaphore1.up();\n      }\n    });\n\n    final Semaphore semaphore2 = new Semaphore();\n    semaphore2.down();\n    Process process2 = new ProcessBuilder(jvm.getPath(), \"-version\").redirectErrorStream(true).start();\n    ProcessWaitFor.attach(process2, new Consumer<Integer>() {\n      @Override\n      public void consume(Integer exitCode) {\n        semaphore2.up();\n      }\n    });\n\n    assertTrue(semaphore1.waitFor(5000));\n    assertTrue(semaphore2.waitFor(5000));\n  }","commit_id":"c26e6fc8a0766984e954dfcb074ebd6457a1ac26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected OSProcessHandler startProcess() throws ExecutionException {\n    OSProcessHandler handler;\n    if (SystemInfo.isWindows) {\n      handler = super.startProcess();\n    }\n    else {\n      handler = KillableColoredProcessHandler.create(createCommandLine());\n      ProcessTerminatedListener.attach(handler);\n    }\n\n    RunnerSettings runnerSettings = getRunnerSettings();\n    JavaRunConfigurationExtensionManager.getInstance().attachExtensionsToProcess(getConfiguration(), handler, runnerSettings);\n    return handler;\n  }","id":42458,"modified_method":"@NotNull\n  @Override\n  protected OSProcessHandler startProcess() throws ExecutionException {\n    OSProcessHandler handler = new KillableColoredProcessHandler(createCommandLine());\n    ProcessTerminatedListener.attach(handler);\n    JavaRunConfigurationExtensionManager.getInstance().attachExtensionsToProcess(getConfiguration(), handler, getRunnerSettings());\n    return handler;\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doDestroyProcess() {\n    boolean gracefulTerminationAttempted = false;\n    if (canKillProcessSoftly() && shouldKillProcessSoftly()) {\n      gracefulTerminationAttempted = destroyProcessGracefully();\n    }\n    if (!gracefulTerminationAttempted) {\n      // execute default process destroy\n      super.doDestroyProcess();\n    }\n  }","id":42459,"modified_method":"@Override\n  protected void doDestroyProcess() {\n    boolean gracefulTerminationAttempted = shouldKillProcessSoftly() && canKillProcessSoftly() && destroyProcessGracefully();\n    if (!gracefulTerminationAttempted) {\n      // execute default process destroy\n      super.doDestroyProcess();\n    }\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * This method shouldn't be overridden, see shouldKillProcessSoftly\n   *\n   * @return\n   */\n  private boolean canKillProcessSoftly() {\n    if (processCanBeKilledByOS(myProcess)) {\n      if (SystemInfo.isWindows) {\n        // runnerw.exe can send Ctrl+C events to a wrapped process\n        return myProcess instanceof RunnerWinProcess;\n      }\n      else if (SystemInfo.isUnix) {\n        // 'kill -SIGINT <pid>' will be executed\n        return true;\n      }\n    }\n    return false;\n  }","id":42460,"modified_method":"/**\n   * This method shouldn't be overridden, see shouldKillProcessSoftly\n   */\n  private boolean canKillProcessSoftly() {\n    if (processCanBeKilledByOS(myProcess)) {\n      if (SystemInfo.isWindows) {\n        // runnerw.exe can send Ctrl+C events to a wrapped process\n        return myMediatedProcess;\n      }\n      else if (SystemInfo.isUnix) {\n        // 'kill -SIGINT <pid>' will be executed\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean destroyProcessGracefully() {\n    if (SystemInfo.isWindows) {\n      if (myProcess instanceof RunnerWinProcess) {\n        RunnerWinProcess runnerWinProcess = (RunnerWinProcess) myProcess;\n        runnerWinProcess.destroyGracefully(true);\n        return true;\n      }\n    }\n    else if (SystemInfo.isUnix) {\n      return UnixProcessManager.sendSigIntToProcessTree(myProcess);\n    }\n    return false;\n  }","id":42461,"modified_method":"protected boolean destroyProcessGracefully() {\n    if (SystemInfo.isWindows && myMediatedProcess) {\n      return RunnerMediator.destroyProcess(myProcess, true);\n    }\n    else if (SystemInfo.isUnix) {\n      return UnixProcessManager.sendSigIntToProcessTree(myProcess);\n    }\n    return false;\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static KillableColoredProcessHandler create(@NotNull GeneralCommandLine commandLine) throws ExecutionException {\n    final Process process;\n    if (SystemInfo.isWindows) {\n      process = RunnerWinProcess.create(commandLine);\n    }\n    else {\n      process = commandLine.createProcess();\n    }\n    return new KillableColoredProcessHandler(process,\n                                             commandLine.getCommandLineString(),\n                                             commandLine.getCharset());\n  }","id":42462,"modified_method":"/** @deprecated use {@link #KillableColoredProcessHandler(GeneralCommandLine, boolean)} (to be removed in IDEA 17) */\n  @SuppressWarnings(\"unused\")\n  public static KillableColoredProcessHandler create(@NotNull GeneralCommandLine commandLine) throws ExecutionException {\n    return new KillableColoredProcessHandler(commandLine, true);\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static WinProcess createWinProcess(@NotNull Process process) {\n    if (process instanceof RunnerWinProcess) {\n      RunnerWinProcess runnerWinProcess = (RunnerWinProcess) process;\n      return new WinProcess(runnerWinProcess.getOriginalProcess());\n    }\n    return new WinProcess(process);\n  }","id":42463,"modified_method":"@SuppressWarnings(\"deprecation\")\n  @NotNull\n  private static WinProcess createWinProcess(@NotNull Process process) {\n    if (process instanceof RunnerWinProcess) process = ((RunnerWinProcess)process).getOriginalProcess();\n    return new WinProcess(process);\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @deprecated use CustomDestroyProcessHandler(GeneralCommandLine commandLine, boolean softKill)\n     * @deprecated remove in IDEA 16\n     */\n    public CustomDestroyProcessHandler(@NotNull Process process, @NotNull GeneralCommandLine commandLine, final boolean softKill) {\n      super(process, commandLine.getCommandLineString());\n      mySoftKill = softKill;\n    }","id":42464,"modified_method":"/** @deprecated use CustomDestroyProcessHandler(GeneralCommandLine commandLine, boolean softKill) (to remove in IDEA 16) */\n    public CustomDestroyProcessHandler(@NotNull Process process, @NotNull GeneralCommandLine commandLine, boolean softKill) {\n      super(process, commandLine.getCommandLineString());\n      mySoftKill = softKill;\n    }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @deprecated use CustomDestroyProcessHandler(GeneralCommandLine commandLine)\n     * @deprecated remove in IDEA 16\n     */\n    public CustomDestroyProcessHandler(@NotNull Process process, @NotNull GeneralCommandLine commandLine) {\n      this(process, commandLine, false);\n    }","id":42465,"modified_method":"/** @deprecated use CustomDestroyProcessHandler(GeneralCommandLine commandLine) (to remove in IDEA 16) */\n    public CustomDestroyProcessHandler(@NotNull Process process, @NotNull GeneralCommandLine commandLine) {\n      super(process, commandLine.getCommandLineString());\n      mySoftKill = false;\n    }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static Process create(@NotNull GeneralCommandLine commandLine) throws ExecutionException {\n    if (!SystemInfo.isWindows) {\n      throw new RuntimeException(RunnerWinProcess.class.getSimpleName() + \" works on Windows only!\");\n    }\n    boolean success = RunnerMediator.injectRunnerCommand(commandLine);\n    Process process = commandLine.createProcess();\n    return success ? new RunnerWinProcess(process) : process;\n  }","id":42466,"modified_method":"@NotNull\n  public static Process create(@NotNull GeneralCommandLine commandLine) throws ExecutionException {\n    if (!SystemInfo.isWindows) {\n      throw new RuntimeException(\"RunnerWinProcess works on Windows only!\");\n    }\n    boolean success = RunnerMediator.injectRunnerCommand(commandLine);\n    Process process = commandLine.createProcess();\n    return success ? new RunnerWinProcess(process) : process;\n  }","commit_id":"d7ea9c4e9093520511b7bb39630c70db6489e5e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    return context.triggers.attach(name, context.session);\n  }","id":42467,"modified_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    if(context.triggers.attach(name, context.session)) {\n      return info(TRIGGERATT, name);\n    }\n    return error(TRIGGERNO, name);\n  }","commit_id":"5fb4f8b14113f0d6d506f5c4b9de5ee54aea17db","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    return context.triggers.drop(name);\n  }","id":42468,"modified_method":"@Override\n  protected boolean run() {\n    final String name = args[0];\n    if(context.triggers.detach(name, context.session)) {\n      return info(TRIGGERDET, name);\n    }\n    return error(TRIGGERNO, name);\n  }","commit_id":"5fb4f8b14113f0d6d506f5c4b9de5ee54aea17db","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void create() throws BaseXException {\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    String[] triggerNames = triggers.split(\"\\n\");\n    Arrays.sort(triggerNames);\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      assertEquals(TRIGGER_NAME + i, triggerNames[i]);\n    }\n  }","id":42469,"modified_method":"/**\n   * Creates triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void create() throws BaseXException {\n    for(int i = 1; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    String[] triggerNames = triggers.split(\"\\n\");\n    Arrays.sort(triggerNames);\n    for(int i = 1; i < TRIGGER_COUNT; i++) {\n      assertEquals(TRIGGER_NAME + i, triggerNames[i]);\n    }\n  }","commit_id":"5fb4f8b14113f0d6d506f5c4b9de5ee54aea17db","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Drops triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void drop() throws BaseXException {\n    // Create triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    // Drop triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"drop trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    // Query must not return any trigger.\n    assertEquals(\"\", triggers);\n  }","id":42470,"modified_method":"/**\n   * Drops triggers.\n   * @throws BaseXException command exception\n   */\n  @Test\n  public void drop() throws BaseXException {\n    // Create triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"create trigger \" + TRIGGER_NAME + i);\n    }\n\n    // Drop triggers.\n    for(int i = 0; i < TRIGGER_COUNT; i++) {\n      cs.execute(\"drop trigger \" + TRIGGER_NAME + i);\n    }\n\n    String triggers = cs.execute(\"show triggers\");\n\n    // Query must not return any trigger.\n    assertEquals(\"0\", triggers.substring(0, 1));\n  }","commit_id":"5fb4f8b14113f0d6d506f5c4b9de5ee54aea17db","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Patches the command line parameters applying patchers from first to last, and then runs it.\n   *\n   * @param patchers any number of patchers; any patcher may be null, and the whole argument may be null.\n   * @return handler of the started process\n   * @throws ExecutionException\n   */\n  protected ProcessHandler startProcess(CommandLinePatcher... patchers) throws ExecutionException {\n\n\n    GeneralCommandLine commandLine = generateCommandLine(patchers);\n\n    // Extend command line\n    RunnerSettings runnerSettings = getRunnerSettings();\n    PythonRunConfigurationExtensionsManager.getInstance()\n      .patchCommandLine(myConfig, runnerSettings, commandLine, getConfigurationSettings().getRunnerId());\n\n    Sdk sdk = PythonSdkType.findSdkByPath(myConfig.getInterpreterPath());\n\n\n    final ProcessHandler processHandler;\n    if (PySdkUtil.isRemote(sdk)) {\n      processHandler = startRemoteProcess(sdk, commandLine);\n    }\n    else {\n      processHandler = doCreateProcess(commandLine);\n      ProcessTerminatedListener.attach(processHandler);\n    }\n\n    // attach extensions\n    PythonRunConfigurationExtensionsManager.getInstance().attachExtensionsToProcess(myConfig, processHandler, getRunnerSettings());\n\n    return processHandler;\n  }","id":42471,"modified_method":"/**\n   * Patches the command line parameters applying patchers from first to last, and then runs it.\n   *\n   * @param patchers any number of patchers; any patcher may be null, and the whole argument may be null.\n   * @return handler of the started process\n   * @throws ExecutionException\n   */\n  protected ProcessHandler startProcess(CommandLinePatcher... patchers) throws ExecutionException {\n\n\n    GeneralCommandLine commandLine = generateCommandLine(patchers);\n\n    // Extend command line\n    RunnerSettings runnerSettings = getRunnerSettings();\n    PythonRunConfigurationExtensionsManager.getInstance()\n      .patchCommandLine(myConfig, runnerSettings, commandLine, getConfigurationSettings().getRunnerId());\n\n    Sdk sdk = PythonSdkType.findSdkByPath(myConfig.getInterpreterPath());\n\n\n    final ProcessHandler processHandler;\n    if (PySdkUtil.isRemote(sdk)) {\n      assert sdk != null;\n      processHandler =\n        createRemoteProcessStarter().startRemoteProcess(sdk, commandLine, myConfig.getProject(), myConfig.getMappingSettings());\n    }\n    else {\n      processHandler = doCreateProcess(commandLine);\n      ProcessTerminatedListener.attach(processHandler);\n    }\n\n    // attach extensions\n    PythonRunConfigurationExtensionsManager.getInstance().attachExtensionsToProcess(myConfig, processHandler, getRunnerSettings());\n\n    return processHandler;\n  }","commit_id":"ffc180d5600d0ddfaf2d13242b1220214d643033","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GeneralCommandLine createCommandLine() {\n    GeneralCommandLine cmd = new GeneralCommandLine();\n\n    if (myWorkingDirectory != null) {\n      cmd.setWorkDirectory(myWorkingDirectory);\n    }\n\n    String homePath = mySdk.getHomePath();\n    if (homePath != null) {\n      homePath = FileUtil.toSystemDependentName(homePath);\n    }\n\n    PythonCommandLineState.createStandardGroupsIn(cmd);\n    ParamsGroup scriptParams = cmd.getParametersList().getParamsGroup(PythonCommandLineState.GROUP_SCRIPT);\n    assert scriptParams != null;\n    cmd.setPassParentEnvs(true);\n    Map<String, String> envs = new HashMap<String, String>();\n    if (!SystemInfo.isWindows) {\n      cmd.setExePath(\"bash\");\n      ParamsGroup bashParams = cmd.getParametersList().addParamsGroupAt(0, \"Bash\");\n      bashParams.addParameter(\"-cl\");\n\n      NotNullFunction<String, String> escaperFunction = StringUtil.escaper(false, \"|>$\\\"'& \");\n      StringBuilder paramString = new StringBuilder(escaperFunction.fun(homePath) + \" \" + escaperFunction.fun(myRunnerScript));\n\n      for (String p : myParameters) {\n        paramString.append(\" \").append(p);\n      }\n      bashParams.addParameter(paramString.toString());\n    }\n    else {\n      final String PATH_KEY = OSUtil.getPATHenvVariableName();\n      String sysPath = System.getenv().get(PATH_KEY);\n      if (!StringUtil.isEmpty(sysPath)) {\n        final String path = envs.get(PATH_KEY);\n        envs.put(PATH_KEY, OSUtil.appendToPATHenvVariable(path, sysPath));\n      }\n\n      cmd.setExePath(homePath);\n      scriptParams.addParameter(myRunnerScript);\n      scriptParams.addParameters(myParameters);\n    }\n\n    PythonEnvUtil.setPythonUnbuffered(envs);\n    cmd.setEnvParams(envs);\n\n    List<String> pythonPath = setupPythonPath();\n    PythonCommandLineState.initPythonPath(cmd, true, pythonPath, homePath);\n\n    PythonSdkType.patchCommandLineForVirtualenv(cmd, homePath, true);\n    BuildoutFacet facet = BuildoutFacet.getInstance(myModule);\n    if (facet != null) {\n      facet.patchCommandLineForBuildout(cmd);\n    }\n\n    return cmd;\n  }","id":42472,"modified_method":"public GeneralCommandLine createCommandLine() {\n    GeneralCommandLine cmd = new GeneralCommandLine();\n\n    if (myWorkingDirectory != null) {\n      cmd.setWorkDirectory(myWorkingDirectory);\n    }\n\n    String homePath = mySdk.getHomePath();\n    if (homePath != null) {\n      homePath = FileUtil.toSystemDependentName(homePath);\n    }\n\n    PythonCommandLineState.createStandardGroupsIn(cmd);\n    ParamsGroup scriptParams = cmd.getParametersList().getParamsGroup(PythonCommandLineState.GROUP_SCRIPT);\n    assert scriptParams != null;\n    cmd.setPassParentEnvs(true);\n    Map<String, String> envs = new HashMap<String, String>();\n    if (!SystemInfo.isWindows && !PySdkUtil.isRemote(mySdk)) {\n      cmd.setExePath(\"bash\");\n      ParamsGroup bashParams = cmd.getParametersList().addParamsGroupAt(0, \"Bash\");\n      bashParams.addParameter(\"-cl\");\n\n      NotNullFunction<String, String> escaperFunction = StringUtil.escaper(false, \"|>$\\\"'& \");\n      StringBuilder paramString = new StringBuilder(escaperFunction.fun(homePath) + \" \" + escaperFunction.fun(myRunnerScript));\n\n      for (String p : myParameters) {\n        paramString.append(\" \").append(p);\n      }\n      bashParams.addParameter(paramString.toString());\n    }\n    else {\n      final String PATH_KEY = OSUtil.getPATHenvVariableName();\n      String sysPath = System.getenv().get(PATH_KEY);\n      if (!StringUtil.isEmpty(sysPath)) {\n        final String path = envs.get(PATH_KEY);\n        envs.put(PATH_KEY, OSUtil.appendToPATHenvVariable(path, sysPath));\n      }\n\n      cmd.setExePath(homePath);\n      scriptParams.addParameter(myRunnerScript);\n      scriptParams.addParameters(myParameters);\n    }\n\n    PythonEnvUtil.setPythonUnbuffered(envs);\n    cmd.setEnvParams(envs);\n\n    List<String> pythonPath = setupPythonPath();\n    PythonCommandLineState.initPythonPath(cmd, true, pythonPath, homePath);\n\n    PythonSdkType.patchCommandLineForVirtualenv(cmd, homePath, true);\n    BuildoutFacet facet = BuildoutFacet.getInstance(myModule);\n    if (facet != null) {\n      facet.patchCommandLineForBuildout(cmd);\n    }\n\n    return cmd;\n  }","commit_id":"ffc180d5600d0ddfaf2d13242b1220214d643033","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProcessHandler createProcess() throws ExecutionException {\n    GeneralCommandLine commandLine = createCommandLine();\n\n    ProcessHandler handler = PythonProcessRunner.createProcessHandlingCtrlC(commandLine);\n\n    ProcessTerminatedListener.attach(handler);\n    return handler;\n  }","id":42473,"modified_method":"public ProcessHandler createProcess() throws ExecutionException {\n    GeneralCommandLine commandLine = createCommandLine();\n\n    ProcessHandler handler;\n    if (PySdkUtil.isRemote(mySdk)) {\n      assert mySdk != null;\n      handler = new PyRemoteProcessStarter().startRemoteProcess(mySdk, commandLine, myModule.getProject(), null);\n    }\n    else {\n      handler = PythonProcessRunner.createProcessHandlingCtrlC(commandLine);\n\n      ProcessTerminatedListener.attach(handler);\n    }\n    return handler;\n  }","commit_id":"ffc180d5600d0ddfaf2d13242b1220214d643033","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#resolveMapping(org.opencms.file.CmsObject, org.opencms.xml.content.CmsXmlContent, org.opencms.xml.types.I_CmsXmlContentValue)\n     */\n    public void resolveMapping(CmsObject cms, CmsXmlContent content, I_CmsXmlContentValue value) throws CmsException {\n\n        if (!value.isSimpleType()) {\n            // no mappings for a nested schema are possible\n            // note that the sub-elements of the nested schema ARE mapped by the node visitor,\n            // it's just the nested schema value itself that does not support mapping\n            return;\n        }\n\n        // get the original VFS file from the content\n        CmsFile file = content.getFile();\n        if (file == null) {\n            throw new CmsXmlException(Messages.get().container(Messages.ERR_XMLCONTENT_RESOLVE_FILE_NOT_FOUND_0));\n        }\n\n        // get the mappings for the element name        \n        List<String> mappings = getMappings(value.getPath());\n        if (mappings == null) {\n            // nothing to do if we have no mappings at all\n            return;\n        }\n        // create OpenCms user context initialized with \"/\" as site root to read all siblings\n        CmsObject rootCms = OpenCms.initCmsObject(cms);\n        Object logEntry = cms.getRequestContext().getAttribute(CmsLogEntry.ATTR_LOG_ENTRY);\n        if (logEntry != null) {\n            rootCms.getRequestContext().setAttribute(CmsLogEntry.ATTR_LOG_ENTRY, logEntry);\n        }\n        rootCms.getRequestContext().setSiteRoot(\"/\");\n        // read all siblings of the file\n        List<CmsResource> siblings = rootCms.readSiblings(\n            content.getFile().getRootPath(),\n            CmsResourceFilter.IGNORE_EXPIRATION);\n\n        Set<CmsResource> urlNameMappingResources = new HashSet<CmsResource>();\n        boolean mapToUrlName = false;\n        urlNameMappingResources.add(content.getFile());\n        // since 7.0.2 multiple mappings are possible\n        for (String mapping : mappings) {\n\n            // for multiple language mappings, we need to ensure \n            // a) all siblings are handled\n            // b) only the \"right\" locale is mapped to a sibling\n            if (CmsStringUtil.isNotEmpty(mapping)) {\n                for (int i = (siblings.size() - 1); i >= 0; i--) {\n                    // get filename\n                    String filename = (siblings.get(i)).getRootPath();\n                    Locale locale = OpenCms.getLocaleManager().getDefaultLocale(rootCms, filename);\n                    if (mapping.startsWith(MAPTO_URLNAME)) {\n                        // should be written regardless of whether there is a sibling with the correct locale \n                        mapToUrlName = true;\n                    }\n                    if (!locale.equals(value.getLocale())) {\n                        // only map property if the locale fits\n                        continue;\n                    }\n\n                    // make sure the file is locked\n                    CmsLock lock = rootCms.getLock(filename);\n                    if (lock.isUnlocked()) {\n                        rootCms.lockResource(filename);\n                    } else if (!lock.isDirectlyOwnedInProjectBy(rootCms)) {\n                        rootCms.changeLock(filename);\n                    }\n\n                    // get the string value of the current node\n                    String stringValue = value.getStringValue(rootCms);\n                    if (mapping.startsWith(MAPTO_PERMISSION) && (value.getIndex() == 0)) {\n\n                        // map value to a permission\n                        // example of a mapping: mapto=\"permission:GROUP:+r+v|GROUP.ALL_OTHERS:|GROUP.Projectmanagers:+r+v+w+c\"\n\n                        // get permission(s) to set\n                        String permissionMappings = mapping.substring(MAPTO_PERMISSION.length());\n                        String mainMapping = permissionMappings;\n                        Map<String, String> permissionsToSet = new HashMap<String, String>();\n\n                        // separate permission to set for element value from other permissions to set\n                        int sepIndex = permissionMappings.indexOf('|');\n                        if (sepIndex != -1) {\n                            mainMapping = permissionMappings.substring(0, sepIndex);\n                            permissionMappings = permissionMappings.substring(sepIndex + 1);\n                            permissionsToSet = CmsStringUtil.splitAsMap(permissionMappings, \"|\", \":\");\n                        }\n\n                        // determine principal type and permission string to set\n                        String principalType = I_CmsPrincipal.PRINCIPAL_GROUP;\n                        String permissionString = mainMapping;\n                        sepIndex = mainMapping.indexOf(':');\n                        if (sepIndex != -1) {\n                            principalType = mainMapping.substring(0, sepIndex);\n                            permissionString = mainMapping.substring(sepIndex + 1);\n                        }\n                        if (permissionString.toLowerCase().indexOf('o') == -1) {\n                            permissionString += \"+o\";\n                        }\n\n                        // remove all existing permissions from the file\n                        List<CmsAccessControlEntry> aces = rootCms.getAccessControlEntries(filename, false);\n                        for (Iterator<CmsAccessControlEntry> j = aces.iterator(); j.hasNext();) {\n                            CmsAccessControlEntry ace = j.next();\n                            if (ace.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID)) {\n                                // remove the entry \"All others\", which has to be treated in a special way\n                                rootCms.rmacc(\n                                    filename,\n                                    CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME,\n                                    CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString());\n                            } else {\n                                // this is a group or user principal\n                                I_CmsPrincipal principal = CmsPrincipal.readPrincipal(rootCms, ace.getPrincipal());\n                                if (principal.isGroup()) {\n                                    rootCms.rmacc(filename, I_CmsPrincipal.PRINCIPAL_GROUP, principal.getName());\n                                } else if (principal.isUser()) {\n                                    rootCms.rmacc(filename, I_CmsPrincipal.PRINCIPAL_USER, principal.getName());\n                                }\n                            }\n                        }\n\n                        // set additional permissions that are defined in mapping\n                        for (Iterator<Map.Entry<String, String>> j = permissionsToSet.entrySet().iterator(); j.hasNext();) {\n                            Map.Entry<String, String> entry = j.next();\n                            sepIndex = entry.getKey().indexOf('.');\n                            if (sepIndex != -1) {\n                                String type = entry.getKey().substring(0, sepIndex);\n                                String name = entry.getKey().substring(sepIndex + 1);\n                                String permissions = entry.getValue();\n                                if (permissions.toLowerCase().indexOf('o') == -1) {\n                                    permissions += \"+o\";\n                                }\n                                try {\n                                    rootCms.chacc(filename, type, name, permissions);\n                                } catch (CmsException e) {\n                                    // setting permission did not work\n                                    LOG.error(e);\n                                }\n                            }\n                        }\n\n                        // set permission(s) using the element value(s)\n                        String path = CmsXmlUtils.removeXpathIndex(value.getPath());\n                        List<I_CmsXmlContentValue> values = content.getValues(path, locale);\n                        Iterator<I_CmsXmlContentValue> j = values.iterator();\n                        while (j.hasNext()) {\n                            I_CmsXmlContentValue val = j.next();\n                            String principalName = val.getStringValue(rootCms);\n                            rootCms.chacc(filename, principalType, principalName, permissionString);\n\n                        }\n                        // special case: permissions are written only to one sibling, end loop\n                        i = 0;\n                    } else if (mapping.startsWith(MAPTO_PROPERTY_LIST) && (value.getIndex() == 0)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)\n                        if (mapping.startsWith(MAPTO_PROPERTY_LIST_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_LIST_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_LIST_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST.length();\n                        }\n\n                        // this is a property list mapping\n                        String property = mapping.substring(prefixLength);\n\n                        String path = CmsXmlUtils.removeXpathIndex(value.getPath());\n                        List<I_CmsXmlContentValue> values = content.getValues(path, locale);\n                        Iterator<I_CmsXmlContentValue> j = values.iterator();\n                        StringBuffer result = new StringBuffer(values.size() * 64);\n                        while (j.hasNext()) {\n                            I_CmsXmlContentValue val = j.next();\n                            result.append(val.getStringValue(rootCms));\n                            if (j.hasNext()) {\n                                result.append(CmsProperty.VALUE_LIST_DELIMITER);\n                            }\n                        }\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, result.toString());\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, result.toString(), null);\n                        }\n                        // write the created list string value in the selected property\n                        rootCms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n\n                    } else if (mapping.startsWith(MAPTO_PROPERTY)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)                        \n                        if (mapping.startsWith(MAPTO_PROPERTY_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY.length();\n                        }\n\n                        // this is a property mapping\n                        String property = mapping.substring(prefixLength);\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, stringValue);\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, stringValue, null);\n                        }\n                        // just store the string value in the selected property\n                        rootCms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n                    } else if (mapping.startsWith(MAPTO_URLNAME)) {\n                        // we write the actual mappings later \n                        urlNameMappingResources.add(siblings.get(i));\n                    } else if (mapping.startsWith(MAPTO_ATTRIBUTE)) {\n\n                        // this is an attribute mapping                        \n                        String attribute = mapping.substring(MAPTO_ATTRIBUTE.length());\n                        switch (ATTRIBUTES.indexOf(attribute)) {\n                            case 0: // date released\n                                long date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_RELEASED_DEFAULT;\n                                }\n                                // set the sibling release date\n                                rootCms.setDateReleased(filename, date, false);\n                                // set current file release date\n                                if (filename.equals(rootCms.getSitePath(file))) {\n                                    file.setDateReleased(date);\n                                }\n                                break;\n                            case 1: // date expired\n                                date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_EXPIRED_DEFAULT;\n                                }\n                                // set the sibling expired date\n                                rootCms.setDateExpired(filename, date, false);\n                                // set current file expired date\n                                if (filename.equals(rootCms.getSitePath(file))) {\n                                    file.setDateExpired(date);\n                                }\n                                break;\n                            default:\n                                // ignore invalid / other mappings                                \n                        }\n                    }\n                }\n            }\n        }\n        if (mapToUrlName) {\n            // now actually write the URL name mappings \n            for (CmsResource resourceForUrlNameMapping : urlNameMappingResources) {\n                if (!CmsResource.isTemporaryFileName(resourceForUrlNameMapping.getRootPath())) {\n                    I_CmsFileNameGenerator nameGen = OpenCms.getResourceManager().getNameGenerator();\n                    Iterator<String> nameSeq = nameGen.getUrlNameSequence(value.getStringValue(cms));\n                    cms.writeUrlNameMapping(\n                        nameSeq,\n                        resourceForUrlNameMapping.getStructureId(),\n                        value.getLocale().toString());\n                }\n            }\n        }\n\n        // make sure the original is locked\n        CmsLock lock = rootCms.getLock(file);\n        if (lock.isUnlocked()) {\n            rootCms.lockResource(file.getRootPath());\n        } else if (!lock.isExclusiveOwnedBy(rootCms.getRequestContext().getCurrentUser())) {\n            rootCms.changeLock(file.getRootPath());\n        }\n    }","id":42474,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#resolveMapping(org.opencms.file.CmsObject, org.opencms.xml.content.CmsXmlContent, org.opencms.xml.types.I_CmsXmlContentValue)\n     */\n    public void resolveMapping(CmsObject cms, CmsXmlContent content, I_CmsXmlContentValue value) throws CmsException {\n\n        if (!value.isSimpleType()) {\n            // no mappings for a nested schema are possible\n            // note that the sub-elements of the nested schema ARE mapped by the node visitor,\n            // it's just the nested schema value itself that does not support mapping\n            return;\n        }\n\n        // get the original VFS file from the content\n        CmsFile file = content.getFile();\n        if (file == null) {\n            throw new CmsXmlException(Messages.get().container(Messages.ERR_XMLCONTENT_RESOLVE_FILE_NOT_FOUND_0));\n        }\n\n        // get the mappings for the element name        \n        List<String> mappings = getMappings(value.getPath());\n        if (mappings == null) {\n            // nothing to do if we have no mappings at all\n            return;\n        }\n        // create OpenCms user context initialized with \"/\" as site root to read all siblings\n        CmsObject rootCms = OpenCms.initCmsObject(cms);\n        Object logEntry = cms.getRequestContext().getAttribute(CmsLogEntry.ATTR_LOG_ENTRY);\n        if (logEntry != null) {\n            rootCms.getRequestContext().setAttribute(CmsLogEntry.ATTR_LOG_ENTRY, logEntry);\n        }\n        rootCms.getRequestContext().setSiteRoot(\"/\");\n        // read all siblings of the file\n        List<CmsResource> siblings = rootCms.readSiblings(\n            content.getFile().getRootPath(),\n            CmsResourceFilter.IGNORE_EXPIRATION);\n\n        Set<CmsResource> urlNameMappingResources = new HashSet<CmsResource>();\n        boolean mapToUrlName = false;\n        urlNameMappingResources.add(content.getFile());\n        // since 7.0.2 multiple mappings are possible\n        for (String mapping : mappings) {\n\n            // for multiple language mappings, we need to ensure \n            // a) all siblings are handled\n            // b) only the \"right\" locale is mapped to a sibling\n            if (CmsStringUtil.isNotEmpty(mapping)) {\n                for (int i = (siblings.size() - 1); i >= 0; i--) {\n                    // get filename\n                    String filename = (siblings.get(i)).getRootPath();\n                    Locale locale = OpenCms.getLocaleManager().getDefaultLocale(rootCms, filename);\n                    if (mapping.startsWith(MAPTO_URLNAME)) {\n                        // should be written regardless of whether there is a sibling with the correct locale \n                        mapToUrlName = true;\n                    }\n                    if (!locale.equals(value.getLocale())) {\n                        // only map property if the locale fits\n                        continue;\n                    }\n\n                    // make sure the file is locked\n                    CmsLock lock = rootCms.getLock(filename);\n                    if (lock.isUnlocked()) {\n                        rootCms.lockResource(filename);\n                    } else if (!lock.isDirectlyOwnedInProjectBy(rootCms)) {\n                        rootCms.changeLock(filename);\n                    }\n\n                    // get the string value of the current node\n                    String stringValue = value.getStringValue(rootCms);\n                    if (mapping.startsWith(MAPTO_PERMISSION) && (value.getIndex() == 0)) {\n\n                        // map value to a permission\n                        // example of a mapping: mapto=\"permission:GROUP:+r+v|GROUP.ALL_OTHERS:|GROUP.Projectmanagers:+r+v+w+c\"\n\n                        // get permission(s) to set\n                        String permissionMappings = mapping.substring(MAPTO_PERMISSION.length());\n                        String mainMapping = permissionMappings;\n                        Map<String, String> permissionsToSet = new HashMap<String, String>();\n\n                        // separate permission to set for element value from other permissions to set\n                        int sepIndex = permissionMappings.indexOf('|');\n                        if (sepIndex != -1) {\n                            mainMapping = permissionMappings.substring(0, sepIndex);\n                            permissionMappings = permissionMappings.substring(sepIndex + 1);\n                            permissionsToSet = CmsStringUtil.splitAsMap(permissionMappings, \"|\", \":\");\n                        }\n\n                        // determine principal type and permission string to set\n                        String principalType = I_CmsPrincipal.PRINCIPAL_GROUP;\n                        String permissionString = mainMapping;\n                        sepIndex = mainMapping.indexOf(':');\n                        if (sepIndex != -1) {\n                            principalType = mainMapping.substring(0, sepIndex);\n                            permissionString = mainMapping.substring(sepIndex + 1);\n                        }\n                        if (permissionString.toLowerCase().indexOf('o') == -1) {\n                            permissionString += \"+o\";\n                        }\n\n                        // remove all existing permissions from the file\n                        List<CmsAccessControlEntry> aces = rootCms.getAccessControlEntries(filename, false);\n                        for (Iterator<CmsAccessControlEntry> j = aces.iterator(); j.hasNext();) {\n                            CmsAccessControlEntry ace = j.next();\n                            if (ace.getPrincipal().equals(CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID)) {\n                                // remove the entry \"All others\", which has to be treated in a special way\n                                rootCms.rmacc(\n                                    filename,\n                                    CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_NAME,\n                                    CmsAccessControlEntry.PRINCIPAL_ALL_OTHERS_ID.toString());\n                            } else {\n                                // this is a group or user principal\n                                I_CmsPrincipal principal = CmsPrincipal.readPrincipal(rootCms, ace.getPrincipal());\n                                if (principal.isGroup()) {\n                                    rootCms.rmacc(filename, I_CmsPrincipal.PRINCIPAL_GROUP, principal.getName());\n                                } else if (principal.isUser()) {\n                                    rootCms.rmacc(filename, I_CmsPrincipal.PRINCIPAL_USER, principal.getName());\n                                }\n                            }\n                        }\n\n                        // set additional permissions that are defined in mapping\n                        for (Iterator<Map.Entry<String, String>> j = permissionsToSet.entrySet().iterator(); j.hasNext();) {\n                            Map.Entry<String, String> entry = j.next();\n                            sepIndex = entry.getKey().indexOf('.');\n                            if (sepIndex != -1) {\n                                String type = entry.getKey().substring(0, sepIndex);\n                                String name = entry.getKey().substring(sepIndex + 1);\n                                String permissions = entry.getValue();\n                                if (permissions.toLowerCase().indexOf('o') == -1) {\n                                    permissions += \"+o\";\n                                }\n                                try {\n                                    rootCms.chacc(filename, type, name, permissions);\n                                } catch (CmsException e) {\n                                    // setting permission did not work\n                                    LOG.error(e);\n                                }\n                            }\n                        }\n\n                        // set permission(s) using the element value(s)\n                        // the set with all selected principals\n                        TreeSet<String> allPrincipals = new TreeSet<String>();\n                        String path = CmsXmlUtils.removeXpathIndex(value.getPath());\n                        List<I_CmsXmlContentValue> values = content.getValues(path, locale);\n                        Iterator<I_CmsXmlContentValue> j = values.iterator();\n                        while (j.hasNext()) {\n                            I_CmsXmlContentValue val = j.next();\n                            String principalName = val.getStringValue(rootCms);\n                            // the prinicipal name can be a principal list\n                            List<String> principalNames = CmsStringUtil.splitAsList(\n                                principalName,\n                                PRINCIPAL_LIST_SEPARATOR);\n                            // iterate over the principals\n                            Iterator<String> iterPrincipals = principalNames.iterator();\n                            while (iterPrincipals.hasNext()) {\n                                // get the next principal\n                                String principal = iterPrincipals.next();\n                                allPrincipals.add(principal);\n                            }\n                        }\n                        // iterate over the set with all principals and set the permissions\n                        Iterator<String> iterAllPricinipals = allPrincipals.iterator();\n                        while (iterAllPricinipals.hasNext()) {\n                            // get the next principal\n                            String principal = iterAllPricinipals.next();\n                            rootCms.chacc(filename, principalType, principal, permissionString);\n                        }\n                        // special case: permissions are written only to one sibling, end loop\n                        i = 0;\n                    } else if (mapping.startsWith(MAPTO_PROPERTY_LIST) && (value.getIndex() == 0)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)\n                        if (mapping.startsWith(MAPTO_PROPERTY_LIST_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_LIST_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_LIST_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_LIST.length();\n                        }\n\n                        // this is a property list mapping\n                        String property = mapping.substring(prefixLength);\n\n                        String path = CmsXmlUtils.removeXpathIndex(value.getPath());\n                        List<I_CmsXmlContentValue> values = content.getValues(path, locale);\n                        Iterator<I_CmsXmlContentValue> j = values.iterator();\n                        StringBuffer result = new StringBuffer(values.size() * 64);\n                        while (j.hasNext()) {\n                            I_CmsXmlContentValue val = j.next();\n                            result.append(val.getStringValue(rootCms));\n                            if (j.hasNext()) {\n                                result.append(CmsProperty.VALUE_LIST_DELIMITER);\n                            }\n                        }\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, result.toString());\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, result.toString(), null);\n                        }\n                        // write the created list string value in the selected property\n                        rootCms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n\n                    } else if (mapping.startsWith(MAPTO_PROPERTY)) {\n\n                        boolean mapToShared;\n                        int prefixLength;\n                        // check which mapping is used (shared or individual)                        \n                        if (mapping.startsWith(MAPTO_PROPERTY_SHARED)) {\n                            mapToShared = true;\n                            prefixLength = MAPTO_PROPERTY_SHARED.length();\n                        } else if (mapping.startsWith(MAPTO_PROPERTY_INDIVIDUAL)) {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY_INDIVIDUAL.length();\n                        } else {\n                            mapToShared = false;\n                            prefixLength = MAPTO_PROPERTY.length();\n                        }\n\n                        // this is a property mapping\n                        String property = mapping.substring(prefixLength);\n\n                        CmsProperty p;\n                        if (mapToShared) {\n                            // map to shared value\n                            p = new CmsProperty(property, null, stringValue);\n                        } else {\n                            // map to individual value\n                            p = new CmsProperty(property, stringValue, null);\n                        }\n                        // just store the string value in the selected property\n                        rootCms.writePropertyObject(filename, p);\n                        if (mapToShared) {\n                            // special case: shared mappings must be written only to one sibling, end loop\n                            i = 0;\n                        }\n                    } else if (mapping.startsWith(MAPTO_URLNAME)) {\n                        // we write the actual mappings later \n                        urlNameMappingResources.add(siblings.get(i));\n                    } else if (mapping.startsWith(MAPTO_ATTRIBUTE)) {\n\n                        // this is an attribute mapping                        \n                        String attribute = mapping.substring(MAPTO_ATTRIBUTE.length());\n                        switch (ATTRIBUTES.indexOf(attribute)) {\n                            case 0: // date released\n                                long date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_RELEASED_DEFAULT;\n                                }\n                                // set the sibling release date\n                                rootCms.setDateReleased(filename, date, false);\n                                // set current file release date\n                                if (filename.equals(rootCms.getSitePath(file))) {\n                                    file.setDateReleased(date);\n                                }\n                                break;\n                            case 1: // date expired\n                                date = 0;\n                                try {\n                                    date = Long.valueOf(stringValue).longValue();\n                                } catch (NumberFormatException e) {\n                                    // ignore, value can be a macro\n                                }\n                                if (date == 0) {\n                                    date = CmsResource.DATE_EXPIRED_DEFAULT;\n                                }\n                                // set the sibling expired date\n                                rootCms.setDateExpired(filename, date, false);\n                                // set current file expired date\n                                if (filename.equals(rootCms.getSitePath(file))) {\n                                    file.setDateExpired(date);\n                                }\n                                break;\n                            default:\n                                // ignore invalid / other mappings                                \n                        }\n                    }\n                }\n            }\n        }\n        if (mapToUrlName) {\n            // now actually write the URL name mappings \n            for (CmsResource resourceForUrlNameMapping : urlNameMappingResources) {\n                if (!CmsResource.isTemporaryFileName(resourceForUrlNameMapping.getRootPath())) {\n                    I_CmsFileNameGenerator nameGen = OpenCms.getResourceManager().getNameGenerator();\n                    Iterator<String> nameSeq = nameGen.getUrlNameSequence(value.getStringValue(cms));\n                    cms.writeUrlNameMapping(\n                        nameSeq,\n                        resourceForUrlNameMapping.getStructureId(),\n                        value.getLocale().toString());\n                }\n            }\n        }\n\n        // make sure the original is locked\n        CmsLock lock = rootCms.getLock(file);\n        if (lock.isUnlocked()) {\n            rootCms.lockResource(file.getRootPath());\n        } else if (!lock.isExclusiveOwnedBy(rootCms.getRequestContext().getCurrentUser())) {\n            rootCms.changeLock(file.getRootPath());\n        }\n    }","commit_id":"7269f7bac902d42d222df02ffed9826f669bbcf6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#getDialogWidget(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    public String getDialogWidget(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param) {\n\n        String id = param.getId();\n        StringBuffer result = new StringBuffer(16);\n\n        List<CmsSelectWidgetOption> options = parseSelectOptions(cms, widgetDialog, param);\n        result.append(\"<td class=\\\"xmlTd\\\">\");\n        if (!m_asCheckBoxes) {\n            result.append(\"<select multiple size='\");\n            result.append(options.size());\n            result.append(\"' class=\\\"xmlInput\");\n            if (param.hasError()) {\n                result.append(\" xmlInputError\");\n            }\n            result.append(\"\\\" name=\\\"\");\n            result.append(id);\n            result.append(\"\\\" id=\\\"\");\n            result.append(id);\n            result.append(\"\\\">\");\n        }\n\n        // get select box options from default value String\n        List<String> selected = getSelectedValues(cms, param);\n        Iterator<CmsSelectWidgetOption> i = options.iterator();\n        while (i.hasNext()) {\n            CmsSelectWidgetOption option = i.next();\n            // create the option\n            if (!m_asCheckBoxes) {\n                result.append(\"<option value=\\\"\");\n                result.append(option.getValue());\n                result.append(\"\\\"\");\n                if (selected.contains(option.getValue())) {\n                    result.append(\" selected=\\\"selected\\\"\");\n                }\n                result.append(\">\");\n                result.append(option.getOption());\n                result.append(\"<\/option>\");\n            } else {\n                result.append(\"<input type='checkbox' name='\");\n                result.append(id);\n                result.append(\"' value='\");\n                result.append(option.getValue());\n                result.append(\"'\");\n                if (selected.contains(option.getValue())) {\n                    result.append(\" checked\");\n                }\n                result.append(\">\");\n                result.append(option.getOption());\n                result.append(\"<br>\");\n            }\n        }\n        if (!m_asCheckBoxes) {\n            result.append(\"<\/select>\");\n        }\n        result.append(\"<\/td>\");\n\n        return result.toString();\n    }","id":42475,"modified_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#getDialogWidget(org.opencms.file.CmsObject, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    public String getDialogWidget(CmsObject cms, I_CmsWidgetDialog widgetDialog, I_CmsWidgetParameter param) {\n\n        return getMultiSelectDialogWidget(cms, widgetDialog, param, this, m_asCheckBoxes, null);\n    }","commit_id":"7269f7bac902d42d222df02ffed9826f669bbcf6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#setEditorValue(org.opencms.file.CmsObject, java.util.Map, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    @Override\n    public void setEditorValue(\n        CmsObject cms,\n        Map<String, String[]> formParameters,\n        I_CmsWidgetDialog widgetDialog,\n        I_CmsWidgetParameter param) {\n\n        String[] values = formParameters.get(param.getId());\n        if ((values != null) && (values.length > 0)) {\n            StringBuffer value = new StringBuffer(128);\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    value.append(',');\n                }\n                value.append(values[i]);\n            }\n            // set the value\n            param.setStringValue(cms, value.toString());\n        } else {\n            // erase:\n            param.setStringValue(cms, \"\");\n        }\n    }","id":42476,"modified_method":"/**\n     * @see org.opencms.widgets.I_CmsWidget#setEditorValue(org.opencms.file.CmsObject, java.util.Map, org.opencms.widgets.I_CmsWidgetDialog, org.opencms.widgets.I_CmsWidgetParameter)\n     */\n    @Override\n    public void setEditorValue(\n        CmsObject cms,\n        Map<String, String[]> formParameters,\n        I_CmsWidgetDialog widgetDialog,\n        I_CmsWidgetParameter param) {\n\n        setMultiSelectEditorValue(cms, formParameters, widgetDialog, param);\n    }","commit_id":"7269f7bac902d42d222df02ffed9826f669bbcf6","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Tests the inheritance of permissions.<p>\n     * \n     * @throws Throwable if something goes wrong\n     */\n    public void testPermissionInheritance() throws Throwable {\n        \n        CmsObject cms = getCmsObject();     \n        echo(\"Testing inheritance of permissions\");\n        \n        String foldername = \"testPermissionInheritance\";\n        String resourcename = foldername + \"/test.txt\";\n        cms.createResource(foldername, CmsResourceTypeFolder.C_RESOURCE_TYPE_ID);\n        cms.createResource(resourcename, CmsResourceTypePlain.C_RESOURCE_TYPE_ID);\n        \n        assertEquals(\"+r+w+v+c\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"Users\", \"+o\");\n        assertEquals(\"+r+w+v+c\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"Users\", \"+o+i\");\n        assertEquals(\"\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.createGroup(\"GroupA\", \"\", 0, \"\");\n        cms.addUserToGroup(\"testUser\", \"GroupA\");\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupA\", \"+r+i\");\n        assertEquals(\"+r\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_USER, \"testUser\", \"+w+i\");\n        assertEquals(\"+r+w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.createGroup(\"GroupB\", \"\", 0, \"\");\n        cms.addUserToGroup(\"testUser\", \"GroupB\");\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupB\", \"-r+i\");\n        assertEquals(\"-r+w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_USER, \"testUser\", \"-w+i\");\n        assertEquals(\"-r-w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n    }","id":42477,"modified_method":"/**\n     * Tests the inheritance of permissions.<p>\n     * \n     * @throws Throwable if something goes wrong\n     */\n    public void testPermissionInheritance() throws Throwable {\n        \n        CmsObject cms = getCmsObject();     \n        echo(\"Testing inheritance of permissions\");\n        \n        String foldername = \"testPermissionInheritance\";\n        String subfoldername = foldername + \"/\" + \"subfolder\";\n        String resourcename = foldername + \"/test.txt\";\n        String subresourcename = subfoldername + \"/subtest.txt\";\n        \n        cms.createResource(foldername, CmsResourceTypeFolder.C_RESOURCE_TYPE_ID);\n        cms.createResource(subfoldername, CmsResourceTypeFolder.C_RESOURCE_TYPE_ID);\n        cms.createResource(resourcename, CmsResourceTypePlain.C_RESOURCE_TYPE_ID);\n        cms.createResource(subresourcename, CmsResourceTypePlain.C_RESOURCE_TYPE_ID);\n        \n        assertEquals(\"+r+w+v+c\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"Users\", \"+o\");\n        /* Folder settings are now valid for immediate resources, even if they are not inherited */\n        assertEquals(\"\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"+r+w+v+c\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"Users\", \"+o+i\");\n        assertEquals(\"\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.createGroup(\"GroupA\", \"\", 0, \"\");\n        cms.createGroup(\"GroupB\", \"\", 0, \"\");\n        cms.createGroup(\"GroupC\", \"\", 0, \"\");\n        cms.createGroup(\"GroupD\", \"\", 0, \"\");\n        \n        cms.addUserToGroup(\"testUser\", \"GroupA\");\n        cms.addUserToGroup(\"testUser\", \"GroupB\");\n        cms.addUserToGroup(\"testUser\", \"GroupC\");\n        cms.addUserToGroup(\"testUser\", \"GroupD\");\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupA\", \"+r\");\n        assertEquals(\"+r\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupA\", \"+r+i\");\n        assertEquals(\"+r\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"+r\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupB\", \"+w\");\n        assertEquals(\"+r+w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"+r\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupB\", \"+w+i\");\n        assertEquals(\"+r+w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"+r+w\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupC\", \"-r\");\n        assertEquals(\"-r+w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"+r+w\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupC\", \"-r+i\");\n        assertEquals(\"-r+w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"-r+w\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupD\", \"-w\");\n        assertEquals(\"-r-w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"-r+w\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n        \n        cms.chacc(foldername, I_CmsPrincipal.C_PRINCIPAL_GROUP, \"GroupD\", \"-w+i\");\n        assertEquals(\"-r-w\", cms.getPermissions(resourcename, \"testUser\").getPermissionString());\n        assertEquals(\"-r-w\", cms.getPermissions(subresourcename, \"testUser\").getPermissionString());\n    }","commit_id":"639710118bc6a2c16a1c274de15abbb9331c9aca","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a temporary file which is needed while working in an editor with preview option.<p>\n     * \n     * @return the file name of the temporary file\n     * @throws CmsException if something goes wrong\n     */\n    protected String createTempFile() throws CmsException {\n\n        // read the selected file\n        CmsResource file = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n\n        // create the filename of the temporary file\n        String temporaryFilename = CmsResource.getFolderPath(getCms().getSitePath(file))\n            + CmsWorkplace.TEMP_FILE_PREFIX\n            + file.getName();\n\n        // check if the temporary file is already present\n        if (getCms().existsResource(temporaryFilename, CmsResourceFilter.ALL)) {\n            // delete old temporary file\n            if (!getCms().getLock(temporaryFilename).equals(CmsLock.getNullLock())) {\n                // steal lock\n                getCms().changeLock(temporaryFilename);\n            } else {\n                // lock resource to current user\n                getCms().lockResource(temporaryFilename);\n            }\n            getCms().deleteResource(temporaryFilename, CmsResource.DELETE_PRESERVE_SIBLINGS);\n        }\n\n        // switch to the temporary file project\n        switchToTempProject();\n\n        // copy the file to edit to a temporary file\n        try {\n            getCms().copyResource(getCms().getSitePath(file), temporaryFilename, CmsResource.COPY_AS_NEW);\n            getCms().setDateLastModified(temporaryFilename, System.currentTimeMillis(), false);\n            // set the temporary file flag\n            int flags = getCms().readResource(temporaryFilename, CmsResourceFilter.ALL).getFlags();\n            if ((flags & CmsResource.FLAG_TEMPFILE) == 0) {\n                flags += CmsResource.FLAG_TEMPFILE;\n            }\n            getCms().chflags(temporaryFilename, flags);\n            // remove eventual release & expiration date from temporary file to make preview in editor work\n            getCms().setDateReleased(temporaryFilename, CmsResource.DATE_RELEASED_DEFAULT, false);\n            getCms().setDateExpired(temporaryFilename, CmsResource.DATE_EXPIRED_DEFAULT, false);\n            // remove visibility permissions for users and projectmanagers on temporary file\n            getCms().chacc(\n                temporaryFilename,\n                I_CmsPrincipal.PRINCIPAL_GROUP,\n                OpenCms.getDefaultUsers().getGroupUsers(),\n                \"-v\");\n            getCms().chacc(\n                temporaryFilename,\n                I_CmsPrincipal.PRINCIPAL_GROUP,\n                OpenCms.getDefaultUsers().getGroupProjectmanagers(),\n                \"-v\");\n        } catch (CmsException e) {\n            switchToCurrentProject();\n            throw e;\n        }\n\n        // switch back to current project\n        switchToCurrentProject();\n\n        return temporaryFilename;\n    }","id":42478,"modified_method":"/**\n     * Creates a temporary file which is needed while working in an editor with preview option.<p>\n     * \n     * @return the file name of the temporary file\n     * @throws CmsException if something goes wrong\n     */\n    protected String createTempFile() throws CmsException {\n\n        // read the selected file\n        CmsResource file = getCms().readResource(getParamResource(), CmsResourceFilter.ALL);\n\n        // create the filename of the temporary file\n        String temporaryFilename = CmsResource.getFolderPath(getCms().getSitePath(file))\n            + CmsWorkplace.TEMP_FILE_PREFIX\n            + file.getName();\n\n        // check if the temporary file is already present\n        if (getCms().existsResource(temporaryFilename, CmsResourceFilter.ALL)) {\n            // delete old temporary file\n            if (!getCms().getLock(temporaryFilename).equals(CmsLock.getNullLock())) {\n                // steal lock\n                getCms().changeLock(temporaryFilename);\n            } else {\n                // lock resource to current user\n                getCms().lockResource(temporaryFilename);\n            }\n            getCms().deleteResource(temporaryFilename, CmsResource.DELETE_PRESERVE_SIBLINGS);\n        }\n\n        // switch to the temporary file project\n        switchToTempProject();\n\n        // copy the file to edit to a temporary file\n        try {\n            getCms().copyResource(getCms().getSitePath(file), temporaryFilename, CmsResource.COPY_AS_NEW);\n            getCms().setDateLastModified(temporaryFilename, System.currentTimeMillis(), false);\n            // set the temporary file flag\n            int flags = getCms().readResource(temporaryFilename, CmsResourceFilter.ALL).getFlags();\n            if ((flags & CmsResource.FLAG_TEMPFILE) == 0) {\n                flags += CmsResource.FLAG_TEMPFILE;\n            }\n            getCms().chflags(temporaryFilename, flags);\n            // remove eventual release & expiration date from temporary file to make preview in editor work\n            getCms().setDateReleased(temporaryFilename, CmsResource.DATE_RELEASED_DEFAULT, false);\n            getCms().setDateExpired(temporaryFilename, CmsResource.DATE_EXPIRED_DEFAULT, false);\n            // remove visibility permissions for users and projectmanagers on temporary file\n            CmsResource tempFile = getCms().readResource(temporaryFilename, CmsResourceFilter.ALL);\n            if (getCms().hasPermissions(tempFile, CmsPermissionSet.ACCESS_CONTROL)) {\n                getCms().chacc(\n                    temporaryFilename,\n                    I_CmsPrincipal.PRINCIPAL_GROUP,\n                    OpenCms.getDefaultUsers().getGroupUsers(),\n                    \"-v\");\n                getCms().chacc(\n                    temporaryFilename,\n                    I_CmsPrincipal.PRINCIPAL_GROUP,\n                    OpenCms.getDefaultUsers().getGroupProjectmanagers(),\n                    \"-v\");\n            }\n        } catch (CmsException e) {\n            switchToCurrentProject();\n            throw e;\n        }\n\n        // switch back to current project\n        switchToCurrentProject();\n\n        return temporaryFilename;\n    }","commit_id":"5176426902d1dc7ce6a081149e8230083205e814","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    final Module module = e.getData(LangDataKeys.MODULE);\n    if (project == null) {\n      return;\n    }\n    AnalysisScope scope = getInspectionScope(dataContext);\n    LOG.assertTrue(scope != null);\n    /*if (scope.getScopeType() == AnalysisScope.VIRTUAL_FILES){\n    FileDocumentManager.getInstance().saveAllDocuments();\n    analyze(project, scope);\n    return;\n  }*/\n    final boolean rememberScope = e.getPlace().equals(ActionPlaces.MAIN_MENU);\n    final AnalysisUIOptions uiOptions = AnalysisUIOptions.getInstance(project);\n    BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(AnalysisScopeBundle.message(\"specify.analysis.scope\", myTitle),\n                                                                AnalysisScopeBundle.message(\"analysis.scope.title\", myAnalysisNoon),\n                                                                project,\n                                                                scope,\n                                                                module != null && scope.getScopeType() != AnalysisScope.MODULE ? ModuleUtil\n                                                                  .getModuleNameInReadAction(module) : null,\n                                                                rememberScope, AnalysisUIOptions.getInstance(project)){\n      @Nullable\n      protected JComponent getAdditionalActionSettings(final Project project) {\n        return BaseAnalysisAction.this.getAdditionalActionSettings(project, this);\n      }\n\n\n      protected void doHelpAction() {\n        HelpManager.getInstance().invokeHelp(getHelpTopic());\n      }\n\n      protected Action[] createActions() {\n        return new Action[]{getOKAction(), getCancelAction(), getHelpAction()};\n      }\n    };\n    dlg.show();\n    if (!dlg.isOK()) {\n      canceled();\n      return;\n    }\n    final int oldScopeType = uiOptions.SCOPE_TYPE;\n    scope = dlg.getScope(uiOptions, scope, project, module);\n    if (!rememberScope){\n      uiOptions.SCOPE_TYPE = oldScopeType;\n    }\n    uiOptions.ANALYZE_TEST_SOURCES = dlg.isInspectTestSources();\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    analyze(project, scope);\n  }","id":42479,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    final Module module = e.getData(LangDataKeys.MODULE);\n    if (project == null) {\n      return;\n    }\n    AnalysisScope scope = getInspectionScope(dataContext);\n    LOG.assertTrue(scope != null);\n    /*if (scope.getScopeType() == AnalysisScope.VIRTUAL_FILES){\n    FileDocumentManager.getInstance().saveAllDocuments();\n    analyze(project, scope);\n    return;\n  }*/\n    final boolean rememberScope = e.getPlace().equals(ActionPlaces.MAIN_MENU);\n    final AnalysisUIOptions uiOptions = AnalysisUIOptions.getInstance(project);\n    PsiElement element = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n    BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(AnalysisScopeBundle.message(\"specify.analysis.scope\", myTitle),\n                                                                AnalysisScopeBundle.message(\"analysis.scope.title\", myAnalysisNoon),\n                                                                project,\n                                                                scope,\n                                                                module != null && scope.getScopeType() != AnalysisScope.MODULE ? ModuleUtil\n                                                                  .getModuleNameInReadAction(module) : null,\n                                                                rememberScope, AnalysisUIOptions.getInstance(project), element){\n      @Nullable\n      protected JComponent getAdditionalActionSettings(final Project project) {\n        return BaseAnalysisAction.this.getAdditionalActionSettings(project, this);\n      }\n\n\n      protected void doHelpAction() {\n        HelpManager.getInstance().invokeHelp(getHelpTopic());\n      }\n\n      protected Action[] createActions() {\n        return new Action[]{getOKAction(), getCancelAction(), getHelpAction()};\n      }\n    };\n    dlg.show();\n    if (!dlg.isOK()) {\n      canceled();\n      return;\n    }\n    final int oldScopeType = uiOptions.SCOPE_TYPE;\n    scope = dlg.getScope(uiOptions, scope, project, module);\n    if (!rememberScope){\n      uiOptions.SCOPE_TYPE = oldScopeType;\n    }\n    uiOptions.ANALYZE_TEST_SOURCES = dlg.isInspectTestSources();\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    analyze(project, scope);\n  }","commit_id":"ff60f61465ddb636bc34941d532dd603b5807cbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    myTitledSeparator.setText(myAnalysisNoon);\n\n    //include test option\n    myInspectTestSource.setSelected(myAnalysisOptions.ANALYZE_TEST_SOURCES);\n\n    //module scope if applicable\n    myModuleButton.setText(AnalysisScopeBundle.message(\"scope.option.module.with.mnemonic\", myModuleName));\n    boolean useModuleScope = false;\n    if (myModuleName != null) {\n      useModuleScope = myAnalysisOptions.SCOPE_TYPE == AnalysisScope.MODULE;\n      myModuleButton.setSelected(myRememberScope && useModuleScope);\n    }\n\n    myModuleButton.setVisible(myModuleName != null && ModuleManager.getInstance(myProject).getModules().length > 1);\n\n    boolean useUncommitedFiles = false;\n    final ChangeListManager changeListManager = ChangeListManager.getInstance(myProject);\n    final boolean hasVCS = !changeListManager.getAffectedFiles().isEmpty();\n    if (hasVCS){\n      useUncommitedFiles = myAnalysisOptions.SCOPE_TYPE == AnalysisScope.UNCOMMITED_FILES;\n      myUncommitedFilesButton.setSelected(myRememberScope && useUncommitedFiles);\n    }\n    myUncommitedFilesButton.setVisible(hasVCS);\n\n    DefaultComboBoxModel model = new DefaultComboBoxModel();\n    model.addElement(ALL);\n    final List<? extends ChangeList> changeLists = changeListManager.getChangeListsCopy();\n    for (ChangeList changeList : changeLists) {\n      model.addElement(changeList.getName());\n    }\n    myChangeLists.setModel(model);\n    myChangeLists.setEnabled(myUncommitedFilesButton.isSelected());\n    myChangeLists.setVisible(hasVCS);\n\n    //file/package/directory/module scope\n    myFileButton.setText(myFileName);\n    myFileButton.setMnemonic(myFileName.charAt(0));\n\n    //custom scope\n    myCustomScopeButton.setSelected(myRememberScope && myAnalysisOptions.SCOPE_TYPE == AnalysisScope.CUSTOM);\n\n    myScopeCombo.init(myProject, myAnalysisOptions.CUSTOM_SCOPE_NAME.length() > 0 ? myAnalysisOptions.CUSTOM_SCOPE_NAME : FindSettings.getInstance().getDefaultScopeName());\n\n    //correct selection\n    myProjectButton.setSelected(myRememberScope && myAnalysisOptions.SCOPE_TYPE == AnalysisScope.PROJECT);\n    myFileButton.setSelected(!myRememberScope ||\n                             myAnalysisOptions.SCOPE_TYPE != AnalysisScope.PROJECT && !useModuleScope && myAnalysisOptions.SCOPE_TYPE != AnalysisScope.CUSTOM && !useUncommitedFiles);\n\n    myScopeCombo.setEnabled(myCustomScopeButton.isSelected());\n\n    final ActionListener radioButtonPressed = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        onScopeRadioButtonPressed();\n      }\n    };\n    final Enumeration<AbstractButton> enumeration = myGroup.getElements();\n    while (enumeration.hasMoreElements()) {\n      enumeration.nextElement().addActionListener(radioButtonPressed);\n    }\n\n    //additional panel - inspection profile chooser\n    JPanel wholePanel = new JPanel(new BorderLayout());\n    wholePanel.add(myPanel, BorderLayout.NORTH);\n    final JComponent additionalPanel = getAdditionalActionSettings(myProject);\n    if (additionalPanel!= null){\n      wholePanel.add(additionalPanel, BorderLayout.CENTER);\n    }\n    return wholePanel;\n  }","id":42480,"modified_method":"protected JComponent createCenterPanel() {\n    myTitledSeparator.setText(myAnalysisNoon);\n\n    //include test option\n    myInspectTestSource.setSelected(myAnalysisOptions.ANALYZE_TEST_SOURCES);\n\n    //module scope if applicable\n    myModuleButton.setText(AnalysisScopeBundle.message(\"scope.option.module.with.mnemonic\", myModuleName));\n    boolean useModuleScope = false;\n    if (myModuleName != null) {\n      useModuleScope = myAnalysisOptions.SCOPE_TYPE == AnalysisScope.MODULE;\n      myModuleButton.setSelected(myRememberScope && useModuleScope);\n    }\n\n    myModuleButton.setVisible(myModuleName != null && ModuleManager.getInstance(myProject).getModules().length > 1);\n\n    boolean useUncommitedFiles = false;\n    final ChangeListManager changeListManager = ChangeListManager.getInstance(myProject);\n    final boolean hasVCS = !changeListManager.getAffectedFiles().isEmpty();\n    if (hasVCS){\n      useUncommitedFiles = myAnalysisOptions.SCOPE_TYPE == AnalysisScope.UNCOMMITED_FILES;\n      myUncommitedFilesButton.setSelected(myRememberScope && useUncommitedFiles);\n    }\n    myUncommitedFilesButton.setVisible(hasVCS);\n\n    DefaultComboBoxModel model = new DefaultComboBoxModel();\n    model.addElement(ALL);\n    final List<? extends ChangeList> changeLists = changeListManager.getChangeListsCopy();\n    for (ChangeList changeList : changeLists) {\n      model.addElement(changeList.getName());\n    }\n    myChangeLists.setModel(model);\n    myChangeLists.setEnabled(myUncommitedFilesButton.isSelected());\n    myChangeLists.setVisible(hasVCS);\n\n    //file/package/directory/module scope\n    myFileButton.setText(myFileName);\n    myFileButton.setMnemonic(myFileName.charAt(0));\n\n    VirtualFile file = PsiUtilBase.getVirtualFile(myContext);\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n    boolean searchInLib = file != null && (fileIndex.isInLibraryClasses(file) || fileIndex.isInLibrarySource(file));\n\n\n    String preselect = !StringUtil.isEmptyOrSpaces(myAnalysisOptions.CUSTOM_SCOPE_NAME)\n                       ? myAnalysisOptions.CUSTOM_SCOPE_NAME\n                       : FindSettings.getInstance().getDefaultScopeName();\n    if (searchInLib && GlobalSearchScope.projectScope(myProject).getDisplayName().equals(preselect)) {\n      myAnalysisOptions.SCOPE_TYPE = AnalysisScope.CUSTOM;\n      myAnalysisOptions.CUSTOM_SCOPE_NAME = preselect = GlobalSearchScope.allScope(myProject).getDisplayName();\n    }\n\n    //custom scope\n    myCustomScopeButton.setSelected(myRememberScope && myAnalysisOptions.SCOPE_TYPE == AnalysisScope.CUSTOM);\n\n    myScopeCombo.init(myProject, searchInLib, true, preselect);\n\n    //correct selection\n    myProjectButton.setSelected(myRememberScope && myAnalysisOptions.SCOPE_TYPE == AnalysisScope.PROJECT);\n    myFileButton.setSelected(!myRememberScope ||\n                             myAnalysisOptions.SCOPE_TYPE != AnalysisScope.PROJECT && !useModuleScope && myAnalysisOptions.SCOPE_TYPE != AnalysisScope.CUSTOM && !useUncommitedFiles);\n\n    myScopeCombo.setEnabled(myCustomScopeButton.isSelected());\n\n    final ActionListener radioButtonPressed = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        onScopeRadioButtonPressed();\n      }\n    };\n    final Enumeration<AbstractButton> enumeration = myGroup.getElements();\n    while (enumeration.hasMoreElements()) {\n      enumeration.nextElement().addActionListener(radioButtonPressed);\n    }\n\n    //additional panel - inspection profile chooser\n    JPanel wholePanel = new JPanel(new BorderLayout());\n    wholePanel.add(myPanel, BorderLayout.NORTH);\n    final JComponent additionalPanel = getAdditionalActionSettings(myProject);\n    if (additionalPanel!= null){\n      wholePanel.add(additionalPanel, BorderLayout.CENTER);\n    }\n    return wholePanel;\n  }","commit_id":"ff60f61465ddb636bc34941d532dd603b5807cbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BaseAnalysisActionDialog(@NotNull String title,\n                                  @NotNull String analysisNoon,\n                                  @NotNull Project project,\n                                  @NotNull final AnalysisScope scope,\n                                  final String moduleName,\n                                  final boolean rememberScope,\n                                  @NotNull AnalysisUIOptions analysisUIOptions) {\n    super(true);\n    myAnalysisOptions = analysisUIOptions;\n    if (!analysisUIOptions.ANALYZE_TEST_SOURCES) {\n      myAnalysisOptions.ANALYZE_TEST_SOURCES = scope.isAnalyzeTestsByDefault();\n    }\n    myProject = project;\n    myFileName = scope.getShortenName();\n    myModuleName = moduleName;\n    myRememberScope = rememberScope;\n    myAnalysisNoon = analysisNoon;\n    init();\n    setTitle(title);\n    onScopeRadioButtonPressed();\n  }","id":42481,"modified_method":"public BaseAnalysisActionDialog(@NotNull String title,\n                                  @NotNull String analysisNoon,\n                                  @NotNull Project project,\n                                  @NotNull final AnalysisScope scope,\n                                  final String moduleName,\n                                  final boolean rememberScope,\n                                  @NotNull AnalysisUIOptions analysisUIOptions,\n                                  @Nullable PsiElement context) {\n    super(true);\n    myAnalysisOptions = analysisUIOptions;\n    myContext = context;\n    if (!analysisUIOptions.ANALYZE_TEST_SOURCES) {\n      myAnalysisOptions.ANALYZE_TEST_SOURCES = scope.isAnalyzeTestsByDefault();\n    }\n    myProject = project;\n    myFileName = scope.getShortenName();\n    myModuleName = moduleName;\n    myRememberScope = rememberScope;\n    myAnalysisNoon = analysisNoon;\n    init();\n    setTitle(title);\n    onScopeRadioButtonPressed();\n  }","commit_id":"ff60f61465ddb636bc34941d532dd603b5807cbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiElement element = file.findElementAt(offset);\n    final PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n    if (method == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"locate.caret.inside.a.method\"));\n      showErrorMessage(message, project, editor);\n      return;\n    }\n    if (method.isConstructor()) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"replace.with.method.call.does.not.work.for.constructors\"));\n      showErrorMessage(message, project, editor);\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.does.not.have.a.body\", method.getName()));\n      showErrorMessage(message, project, editor);\n      return;\n    }\n    final PsiStatement[] statements = body.getStatements();\n    if (statements.length == 0) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.has.an.empty.body\", method.getName()));\n\n      showErrorMessage(message, project, editor);\n      return;\n    }\n    final AnalysisScope scope = new AnalysisScope(file);\n    final Module module = ModuleUtil.findModuleForPsiElement(file);\n    final BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(RefactoringBundle.message(\"replace.method.duplicates.scope.chooser.title\", REFACTORING_NAME),\n                                                                RefactoringBundle.message(\"replace.method.duplicates.scope.chooser.message\"),\n                                                                project, scope, module != null ? module.getName() : null, false,\n                                                                AnalysisUIOptions.getInstance(project));\n    dlg.show();\n    if (dlg.isOK()) {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        public void run() {\n          ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n          invokeOnScope(project, method, dlg.getScope(AnalysisUIOptions.getInstance(project), scope, project, module));\n        }\n      }, \"Locate method duplicates\", true, project) ;\n    }\n  }","id":42482,"modified_method":"public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiElement element = file.findElementAt(offset);\n    final PsiMethod method = PsiTreeUtil.getParentOfType(element, PsiMethod.class);\n    if (method == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"locate.caret.inside.a.method\"));\n      showErrorMessage(message, project, editor);\n      return;\n    }\n    if (method.isConstructor()) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"replace.with.method.call.does.not.work.for.constructors\"));\n      showErrorMessage(message, project, editor);\n    }\n    final PsiCodeBlock body = method.getBody();\n    if (body == null) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.does.not.have.a.body\", method.getName()));\n      showErrorMessage(message, project, editor);\n      return;\n    }\n    final PsiStatement[] statements = body.getStatements();\n    if (statements.length == 0) {\n      String message = RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message(\"method.has.an.empty.body\", method.getName()));\n\n      showErrorMessage(message, project, editor);\n      return;\n    }\n    final AnalysisScope scope = new AnalysisScope(file);\n    final Module module = ModuleUtil.findModuleForPsiElement(file);\n    final BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(RefactoringBundle.message(\"replace.method.duplicates.scope.chooser.title\", REFACTORING_NAME),\n                                                                RefactoringBundle.message(\"replace.method.duplicates.scope.chooser.message\"),\n                                                                project, scope, module != null ? module.getName() : null, false,\n                                                                AnalysisUIOptions.getInstance(project), element);\n    dlg.show();\n    if (dlg.isOK()) {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        public void run() {\n          ProgressManager.getInstance().getProgressIndicator().setIndeterminate(true);\n          invokeOnScope(project, method, dlg.getScope(AnalysisUIOptions.getInstance(project), scope, project, module));\n        }\n      }, \"Locate method duplicates\", true, project) ;\n    }\n  }","commit_id":"ff60f61465ddb636bc34941d532dd603b5807cbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManagerEx.getInstance(project);\n    final Module module = ModuleUtil.findModuleForPsiElement(file);\n    final BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(AnalysisScopeBundle.message(\"specify.analysis.scope\", InspectionsBundle.message(\"inspection.action.title\")),\n                                                                      AnalysisScopeBundle.message(\"analysis.scope.title\", InspectionsBundle.message(\"inspection.action.noun\")),\n                                                                      project,\n                                                                      new AnalysisScope(file),\n                                                                      module != null ? module.getName() : null,\n                                                                      true, AnalysisUIOptions.getInstance(project));\n    AnalysisScope scope = new AnalysisScope(file);\n    dlg.show();\n    if (!dlg.isOK()) return;\n    final AnalysisUIOptions uiOptions = AnalysisUIOptions.getInstance(project);\n    scope = dlg.getScope(uiOptions, scope, project, module);\n    final InspectionProfileEntry baseTool =\n        InspectionProjectProfileManager.getInstance(project).getInspectionProfile().getInspectionTool(myShortName, file);\n    rerunInspection(baseTool, managerEx, scope, file);\n  }","id":42483,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManagerEx.getInstance(project);\n    final Module module = ModuleUtil.findModuleForPsiElement(file);\n    final BaseAnalysisActionDialog dlg = new BaseAnalysisActionDialog(AnalysisScopeBundle.message(\"specify.analysis.scope\", InspectionsBundle.message(\"inspection.action.title\")),\n                                                                      AnalysisScopeBundle.message(\"analysis.scope.title\", InspectionsBundle.message(\"inspection.action.noun\")),\n                                                                      project,\n                                                                      new AnalysisScope(file),\n                                                                      module != null ? module.getName() : null,\n                                                                      true, AnalysisUIOptions.getInstance(project), file);\n    AnalysisScope scope = new AnalysisScope(file);\n    dlg.show();\n    if (!dlg.isOK()) return;\n    final AnalysisUIOptions uiOptions = AnalysisUIOptions.getInstance(project);\n    scope = dlg.getScope(uiOptions, scope, project, module);\n    final InspectionProfileEntry baseTool =\n        InspectionProjectProfileManager.getInstance(project).getInspectionProfile().getInspectionTool(myShortName, file);\n    rerunInspection(baseTool, managerEx, scope, file);\n  }","commit_id":"ff60f61465ddb636bc34941d532dd603b5807cbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<SearchScope> getPredefinedScopes(@NotNull final Project project,\n                                                      @Nullable final DataContext dataContext,\n                                                      boolean suggestSearchInLibs,\n                                                      boolean prevSearchFiles,\n                                                      boolean currentSelection,\n                                                      boolean usageView) {\n    ArrayList<SearchScope> result = new ArrayList<SearchScope>();\n    result.add(GlobalSearchScope.projectScope(project));\n    if (suggestSearchInLibs) {\n      result.add(GlobalSearchScope.allScope(project));\n    }\n    result.add(GlobalSearchScope.projectProductionScope(project));\n    result.add(GlobalSearchScope.projectTestScope(project));\n\n    if (dataContext != null) {\n      PsiElement dataContextElement = LangDataKeys.PSI_FILE.getData(dataContext);\n\n      if (dataContextElement == null) {\n        dataContextElement = LangDataKeys.PSI_ELEMENT.getData(dataContext);\n      }\n\n      if (dataContextElement != null) {\n        Module module = ModuleUtil.findModuleForPsiElement(dataContextElement);\n        if (module == null) {\n          module = LangDataKeys.MODULE.getData(dataContext);\n        }\n        if (module != null) {\n          result.add(module.getModuleScope());\n        }\n        if (dataContextElement.getContainingFile() != null) {\n          result.add(new LocalSearchScope(dataContextElement, IdeBundle.message(\"scope.current.file\")));\n        }\n      }\n    }\n\n    if (currentSelection) {\n      FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n      final Editor selectedTextEditor = fileEditorManager.getSelectedTextEditor();\n      if (selectedTextEditor != null) {\n        final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(selectedTextEditor.getDocument());\n        if (psiFile != null) {\n          if (selectedTextEditor.getSelectionModel().hasSelection()) {\n            final PsiElement startElement = psiFile.findElementAt(selectedTextEditor.getSelectionModel().getSelectionStart());\n            if (startElement != null) {\n              final PsiElement endElement = psiFile.findElementAt(selectedTextEditor.getSelectionModel().getSelectionEnd());\n              if (endElement != null) {\n                final PsiElement parent = PsiTreeUtil.findCommonParent(startElement, endElement);\n                if (parent != null) {\n                  final List<PsiElement> elements = new ArrayList<PsiElement>();\n                  final PsiElement[] children = parent.getChildren();\n                  for (PsiElement child : children) {\n                    if (!(child instanceof PsiWhiteSpace)) {\n                      elements.add(child);\n                    }\n                  }\n                  if (!elements.isEmpty()) {\n                    SearchScope local = new LocalSearchScope(elements.toArray(new PsiElement[elements.size()]), IdeBundle.message(\"scope.selection\"));\n                    result.add(local);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (!ChangeListManager.getInstance(project).getAffectedFiles().isEmpty()) {\n      GlobalSearchScope modified = new GlobalSearchScope(project) {\n        public String getDisplayName() {\n          return IdeBundle.message(\"scope.modified.files\");\n        }\n\n        public boolean contains(VirtualFile file) {\n          return ChangeListManager.getInstance(project).getChange(file) != null;\n        }\n\n        public int compare(VirtualFile file1, VirtualFile file2) {\n          return 0;\n        }\n\n        public boolean isSearchInModuleContent(@NotNull Module aModule) {\n          return true;\n        }\n\n        public boolean isSearchInLibraries() {\n          return false;\n        }\n      };\n\n      result.add(modified);\n    }\n\n    if (usageView) {\n      UsageView selectedUsageView = UsageViewManager.getInstance(project).getSelectedUsageView();\n      if (selectedUsageView != null && !selectedUsageView.isSearchInProgress()) {\n        final Set<Usage> usages = selectedUsageView.getUsages();\n        final List<PsiElement> results = new ArrayList<PsiElement>(usages.size());\n\n        if (prevSearchFiles) {\n          final Set<VirtualFile> files = new HashSet<VirtualFile>();\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              PsiElement psiElement = ((PsiElementUsage)usage).getElement();\n              if (psiElement != null && psiElement.isValid()) {\n                PsiFile psiFile = psiElement.getContainingFile();\n                if (psiFile != null) {\n                  VirtualFile file = psiFile.getVirtualFile();\n                  if (file != null) files.add(file);\n                }\n              }\n            }\n          }\n          if (!files.isEmpty()) {\n            GlobalSearchScope prev = new GlobalSearchScope(project) {\n              public String getDisplayName() {\n                return IdeBundle.message(\"scope.files.in.previous.search.result\");\n              }\n\n              public boolean contains(VirtualFile file) {\n                return files.contains(file);\n              }\n\n              public int compare(VirtualFile file1, VirtualFile file2) {\n                return 0;\n              }\n\n              public boolean isSearchInModuleContent(@NotNull Module aModule) {\n                return true;\n              }\n\n              public boolean isSearchInLibraries() {\n                return true;\n              }\n            };\n            result.add(prev);\n          }\n        }\n        else {\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              final PsiElement element = ((PsiElementUsage)usage).getElement();\n              if (element != null && element.isValid()) {\n                results.add(element);\n              }\n            }\n          }\n\n          if (!results.isEmpty()) {\n            result.add(new LocalSearchScope(results.toArray(new PsiElement[results.size()]), IdeBundle.message(\"scope.previous.search.results\")));\n          }\n        }\n      }\n    }\n\n    final FavoritesManager favoritesManager = FavoritesManager.getInstance(project);\n    String[] favoritesLists = favoritesManager == null ? ArrayUtil.EMPTY_STRING_ARRAY : favoritesManager.getAvailableFavoritesLists();\n    for (final String favorite : favoritesLists) {\n      result.add(new GlobalSearchScope(project) {\n        @Override\n        public String getDisplayName() {\n          return \"Favorite \\'\" + favorite + \"\\'\";\n        }\n\n        @Override\n        public boolean contains(final VirtualFile file) {\n          return favoritesManager.contains(favorite, file);\n        }\n\n        @Override\n        public int compare(final VirtualFile file1, final VirtualFile file2) {\n          return 0;\n        }\n\n        @Override\n        public boolean isSearchInModuleContent(@NotNull final Module aModule) {\n          return true;\n        }\n\n        @Override\n        public boolean isSearchInLibraries() {\n          return true;\n        }\n      });\n    }\n    return result;\n  }","id":42484,"modified_method":"public static List<SearchScope> getPredefinedScopes(@NotNull final Project project,\n                                                      @Nullable final DataContext dataContext,\n                                                      boolean suggestSearchInLibs,\n                                                      boolean prevSearchFiles,\n                                                      boolean currentSelection,\n                                                      boolean usageView) {\n    ArrayList<SearchScope> result = new ArrayList<SearchScope>();\n    result.add(GlobalSearchScope.projectScope(project));\n    if (suggestSearchInLibs) {\n      result.add(GlobalSearchScope.allScope(project));\n    }\n    result.add(GlobalSearchScope.projectProductionScope(project));\n    result.add(GlobalSearchScope.projectTestScope(project));\n\n    if (dataContext != null) {\n      PsiElement dataContextElement = getDataContextElement(dataContext);\n\n      if (dataContextElement != null) {\n        Module module = ModuleUtil.findModuleForPsiElement(dataContextElement);\n        if (module == null) {\n          module = LangDataKeys.MODULE.getData(dataContext);\n        }\n        if (module != null) {\n          result.add(module.getModuleScope());\n        }\n        if (dataContextElement.getContainingFile() != null) {\n          result.add(new LocalSearchScope(dataContextElement, IdeBundle.message(\"scope.current.file\")));\n        }\n      }\n    }\n\n    if (currentSelection) {\n      FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n      final Editor selectedTextEditor = fileEditorManager.getSelectedTextEditor();\n      if (selectedTextEditor != null) {\n        final PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(selectedTextEditor.getDocument());\n        if (psiFile != null) {\n          if (selectedTextEditor.getSelectionModel().hasSelection()) {\n            final PsiElement startElement = psiFile.findElementAt(selectedTextEditor.getSelectionModel().getSelectionStart());\n            if (startElement != null) {\n              final PsiElement endElement = psiFile.findElementAt(selectedTextEditor.getSelectionModel().getSelectionEnd());\n              if (endElement != null) {\n                final PsiElement parent = PsiTreeUtil.findCommonParent(startElement, endElement);\n                if (parent != null) {\n                  final List<PsiElement> elements = new ArrayList<PsiElement>();\n                  final PsiElement[] children = parent.getChildren();\n                  for (PsiElement child : children) {\n                    if (!(child instanceof PsiWhiteSpace)) {\n                      elements.add(child);\n                    }\n                  }\n                  if (!elements.isEmpty()) {\n                    SearchScope local = new LocalSearchScope(elements.toArray(new PsiElement[elements.size()]), IdeBundle.message(\"scope.selection\"));\n                    result.add(local);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (!ChangeListManager.getInstance(project).getAffectedFiles().isEmpty()) {\n      GlobalSearchScope modified = new GlobalSearchScope(project) {\n        public String getDisplayName() {\n          return IdeBundle.message(\"scope.modified.files\");\n        }\n\n        public boolean contains(VirtualFile file) {\n          return ChangeListManager.getInstance(project).getChange(file) != null;\n        }\n\n        public int compare(VirtualFile file1, VirtualFile file2) {\n          return 0;\n        }\n\n        public boolean isSearchInModuleContent(@NotNull Module aModule) {\n          return true;\n        }\n\n        public boolean isSearchInLibraries() {\n          return false;\n        }\n      };\n\n      result.add(modified);\n    }\n\n    if (usageView) {\n      UsageView selectedUsageView = UsageViewManager.getInstance(project).getSelectedUsageView();\n      if (selectedUsageView != null && !selectedUsageView.isSearchInProgress()) {\n        final Set<Usage> usages = selectedUsageView.getUsages();\n        final List<PsiElement> results = new ArrayList<PsiElement>(usages.size());\n\n        if (prevSearchFiles) {\n          final Set<VirtualFile> files = new HashSet<VirtualFile>();\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              PsiElement psiElement = ((PsiElementUsage)usage).getElement();\n              if (psiElement != null && psiElement.isValid()) {\n                PsiFile psiFile = psiElement.getContainingFile();\n                if (psiFile != null) {\n                  VirtualFile file = psiFile.getVirtualFile();\n                  if (file != null) files.add(file);\n                }\n              }\n            }\n          }\n          if (!files.isEmpty()) {\n            GlobalSearchScope prev = new GlobalSearchScope(project) {\n              public String getDisplayName() {\n                return IdeBundle.message(\"scope.files.in.previous.search.result\");\n              }\n\n              public boolean contains(VirtualFile file) {\n                return files.contains(file);\n              }\n\n              public int compare(VirtualFile file1, VirtualFile file2) {\n                return 0;\n              }\n\n              public boolean isSearchInModuleContent(@NotNull Module aModule) {\n                return true;\n              }\n\n              public boolean isSearchInLibraries() {\n                return true;\n              }\n            };\n            result.add(prev);\n          }\n        }\n        else {\n          for (Usage usage : usages) {\n            if (usage instanceof PsiElementUsage) {\n              final PsiElement element = ((PsiElementUsage)usage).getElement();\n              if (element != null && element.isValid()) {\n                results.add(element);\n              }\n            }\n          }\n\n          if (!results.isEmpty()) {\n            result.add(new LocalSearchScope(results.toArray(new PsiElement[results.size()]), IdeBundle.message(\"scope.previous.search.results\")));\n          }\n        }\n      }\n    }\n\n    final FavoritesManager favoritesManager = FavoritesManager.getInstance(project);\n    String[] favoritesLists = favoritesManager == null ? ArrayUtil.EMPTY_STRING_ARRAY : favoritesManager.getAvailableFavoritesLists();\n    for (final String favorite : favoritesLists) {\n      result.add(new GlobalSearchScope(project) {\n        @Override\n        public String getDisplayName() {\n          return \"Favorite \\'\" + favorite + \"\\'\";\n        }\n\n        @Override\n        public boolean contains(final VirtualFile file) {\n          return favoritesManager.contains(favorite, file);\n        }\n\n        @Override\n        public int compare(final VirtualFile file1, final VirtualFile file2) {\n          return 0;\n        }\n\n        @Override\n        public boolean isSearchInModuleContent(@NotNull final Module aModule) {\n          return true;\n        }\n\n        @Override\n        public boolean isSearchInLibraries() {\n          return true;\n        }\n      });\n    }\n    return result;\n  }","commit_id":"ff60f61465ddb636bc34941d532dd603b5807cbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Ctor.\n   *\n   * @param localFileSystem in instance of {@link LocalFileSystem}\n   */\n  public AbstractFrameworkInstanceManager(LocalFileSystem localFileSystem) {\n    myLocalFileSystem = localFileSystem;\n  }","id":42485,"modified_method":"public AbstractFrameworkInstanceManager(LocalFileSystem localFileSystem) {\n    myLocalFileSystem = localFileSystem;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    if (frameworkInstanceDefinition.isDownloadedByPaxRunner()) {\n      return checkDownloadedFolderStructure(frameworkInstanceDefinition);\n    }\n\n    VirtualFile installFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (installFolder == null || !installFolder.isDirectory()) {\n      return OsmorcBundle\n        .getTranslation(\"concierge.folder.does.not.exist\", frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile bundlesFolder = installFolder.findChild(\"bundles\");\n    if (bundlesFolder == null || !bundlesFolder.isDirectory()) {\n      return OsmorcBundle.getTranslation(\"concierge.folder.bundles.missing\", installFolder.getPath());\n    }\n\n    return null;\n  }","id":42486,"modified_method":"public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    VirtualFile installFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (installFolder == null || !installFolder.isDirectory()) {\n      return OsmorcBundle\n        .getTranslation(\"concierge.folder.does.not.exist\", frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile bundlesFolder = installFolder.findChild(\"bundles\");\n    if (bundlesFolder == null || !bundlesFolder.isDirectory()) {\n      return OsmorcBundle.getTranslation(\"concierge.folder.bundles.missing\", installFolder.getPath());\n    }\n\n    return null;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public JComponent getPreferredFocusedComponent() {\n    // OSMORC-111 - focus the name field\n    return myNameTextField;\n  }","id":42487,"modified_method":"@Override\n  public JComponent getPreferredFocusedComponent() {\n    return myIntegratorComboBox;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void updateUiState() {\n    boolean isDownload = isDownload();\n    myBaseFolderLabel.setEnabled(!isDownload);\n    myBaseFolderChooser.setEnabled(!isDownload);\n\n    myTargetFolder.setEnabled(isDownload);\n    myFolderLabel.setEnabled(isDownload);\n    myComboBox1.setEnabled(isDownload);\n    myProfilesLabel.setEnabled(isDownload);\n    myClearFolderBeforeDownloadCheckBox.setEnabled(isDownload);\n\n\n    final FrameworkIntegrator integrator = (FrameworkIntegrator)myIntegratorComboBox.getSelectedItem();\n    boolean hasFolderSelected = !StringUtil.isEmpty(getBaseFolder());\n    boolean hasIntegratorSelected = integrator != null;\n\n    myDownloadButton.setEnabled(isDownload && hasFolderSelected && hasIntegratorSelected);\n\n\n    boolean isFrameworkDefinitionValid = false;\n    if (integrator != null /* && baseFolderChooser.getText().length() > 0 */) {\n      FrameworkInstanceDefinition definition = new FrameworkInstanceDefinition();\n      definition.setName(getName());\n      definition.setFrameworkIntegratorName(getIntegratorName());\n      definition.setBaseFolder(getBaseFolder());\n      definition.setVersion(getVersion());\n      definition.setDownloadedByPaxRunner(isDownload());\n      String errorInfoText = integrator.getFrameworkInstanceManager().checkValidity(definition);\n      ((MyErrorText)myErrorText).setError(errorInfoText);\n      isFrameworkDefinitionValid = (errorInfoText == null || errorInfoText.length() == 0);\n    }\n    setOKActionEnabled(myNameTextField.getText().length() > 0 && integrator != null &&\n                       isFrameworkDefinitionValid);\n  }","id":42488,"modified_method":"private void updateUiState() {\n    FrameworkIntegrator integrator = (FrameworkIntegrator)myIntegratorComboBox.getSelectedItem();\n    if (integrator != null) {\n      FrameworkInstanceDefinition definition = createDefinition();\n      String errorInfoText = integrator.getFrameworkInstanceManager().checkValidity(definition);\n      ((MyErrorText)myErrorText).setError(errorInfoText);\n      setOKActionEnabled(!StringUtil.isEmptyOrSpaces(myNameTextField.getText()) && StringUtil.isEmpty(errorInfoText));\n    }\n    else {\n      setOKActionEnabled(false);\n    }\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public CreateFrameworkInstanceDialog(FrameworkIntegratorRegistry frameworkIntegratorRegistry, String frameworkInstanceName) {\n    super(true);\n    setTitle(\"OSGi Framework Instance\");\n    setModal(true);\n\n    if (frameworkInstanceName != null) {\n      myNameTextField.setText(frameworkInstanceName);\n    }\n\n    FrameworkIntegrator[] integrators = frameworkIntegratorRegistry.getFrameworkIntegrators();\n    myIntegratorComboBox.removeAllItems();\n    for (FrameworkIntegrator integrator : integrators) {\n      myIntegratorComboBox.addItem(integrator);\n    }\n\n    myIntegratorComboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (myIntegratorComboBox.getSelectedItem() != null && myNameTextField.getText().length() == 0) {\n          myNameTextField.setText(((FrameworkIntegrator)myIntegratorComboBox.getSelectedItem()).getDisplayName());\n        }\n      }\n    });\n\n    myNameTextField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        updateUiState();\n      }\n    });\n\n    myIntegratorComboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateUiState();\n      }\n    });\n\n    myUseLocallyInstalledFrameworkRadioButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        updateUiState();\n      }\n    });\n\n    myDownloadAFrameworkWithRadioButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        updateUiState();\n      }\n    });\n\n    myDownloadButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        downloadFramework();\n      }\n    });\n\n    FileChooserDescriptor fileChooserDescriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    myBaseFolderChooser.addBrowseFolderListener(\"Choose framework instance base folder\", \"\", null,\n                                                fileChooserDescriptor);\n    myBaseFolderChooser.getTextField().setEditable(false);\n    myBaseFolderChooser.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        updateUiState();\n      }\n    });\n\n    myTargetFolder.addBrowseFolderListener(\"Choose folder where to download the framework to\", \"\", null, fileChooserDescriptor);\n    myTargetFolder.getTextField().setEditable(false);\n    myTargetFolder.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateUiState();\n      }\n    });\n    init();\n\n    // add a check right here!\n    updateUiState();\n\n    setAnchor(myBaseFolderLabel);\n  }","id":42489,"modified_method":"public CreateFrameworkInstanceDialog(@NotNull FrameworkIntegratorRegistry registry, @Nullable FrameworkInstanceDefinition framework) {\n    super(true);\n\n    setTitle(\"OSGi Framework Instance\");\n    setModal(true);\n\n    //noinspection unchecked\n    myIntegratorComboBox.setModel(new DefaultComboBoxModel(registry.getFrameworkIntegrators()));\n    myIntegratorComboBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        FrameworkIntegrator integrator = (FrameworkIntegrator)myIntegratorComboBox.getSelectedItem();\n        if (integrator != null && StringUtil.isEmptyOrSpaces(myNameTextField.getText())) {\n          myNameTextField.setText(integrator.getDisplayName());\n        }\n        updateUiState();\n      }\n    });\n\n    myNameTextField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateUiState();\n      }\n    });\n\n    FileChooserDescriptor fileChooserDescriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    myBaseFolderChooser.addBrowseFolderListener(\"Choose framework instance base folder\", \"\", null, fileChooserDescriptor);\n    myBaseFolderChooser.getTextField().setEditable(false);\n    myBaseFolderChooser.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        updateUiState();\n      }\n    });\n\n    if (framework != null) {\n      myNameTextField.setText(framework.getName());\n      myIntegratorComboBox.setSelectedItem(FrameworkIntegratorRegistry.getInstance().findIntegratorByName(framework.getName()));\n      myBaseFolderChooser.setText(framework.getBaseFolder());\n      myVersionField.setText(framework.getVersion());\n    }\n\n    init();\n    updateUiState();\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    if (frameworkInstanceDefinition.isDownloadedByPaxRunner()) {\n      return checkDownloadedFolderStructure(frameworkInstanceDefinition);\n    }\n\n    VirtualFile equinoxFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (equinoxFolder == null || !equinoxFolder.isDirectory()) {\n      return MessageFormat.format(FOLDER_DOES_NOT_EXIST, frameworkInstanceDefinition.getBaseFolder());\n    }\n    VirtualFile pluginsFolder = equinoxFolder.findChild(\"plugins\");\n    if (pluginsFolder == null || !pluginsFolder.isDirectory()) {\n      return MessageFormat.format(NO_PLUGINS_FOLDER, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    return null;\n  }","id":42490,"modified_method":"@Nullable\n  public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    VirtualFile equinoxFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (equinoxFolder == null || !equinoxFolder.isDirectory()) {\n      return MessageFormat.format(FOLDER_DOES_NOT_EXIST, frameworkInstanceDefinition.getBaseFolder());\n    }\n    VirtualFile pluginsFolder = equinoxFolder.findChild(\"plugins\");\n    if (pluginsFolder == null || !pluginsFolder.isDirectory()) {\n      return MessageFormat.format(NO_PLUGINS_FOLDER, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    return null;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    if (frameworkInstanceDefinition.isDownloadedByPaxRunner()) {\n      return checkDownloadedFolderStructure(frameworkInstanceDefinition);\n    }\n\n    VirtualFile installFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (installFolder == null || !installFolder.isDirectory()) {\n      return MessageFormat.format(FOLDER_DOES_NOT_EXIST, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile binFolder = installFolder.findChild(\"bin\");\n    if (binFolder == null || !binFolder.isDirectory()) {\n      return MessageFormat.format(NO_BIN_FOLDER, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile bundleFolder = installFolder.findChild(\"bundle\");\n    if (bundleFolder == null || !bundleFolder.isDirectory()) {\n      return MessageFormat.format(NO_BUNDLE_FOLDER, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    return null;\n  }","id":42491,"modified_method":"public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    VirtualFile installFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (installFolder == null || !installFolder.isDirectory()) {\n      return MessageFormat.format(FOLDER_DOES_NOT_EXIST, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile binFolder = installFolder.findChild(\"bin\");\n    if (binFolder == null || !binFolder.isDirectory()) {\n      return MessageFormat.format(NO_BIN_FOLDER, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile bundleFolder = installFolder.findChild(\"bundle\");\n    if (bundleFolder == null || !bundleFolder.isDirectory()) {\n      return MessageFormat.format(NO_BUNDLE_FOLDER, frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    return null;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void applyTo(ApplicationSettings settings) {\n    int instances = myModel.getSize();\n    ArrayList<FrameworkInstanceDefinition> definitions = new ArrayList<FrameworkInstanceDefinition>(instances);\n    for (int i = 0; i < instances; i++) {\n      definitions.add((FrameworkInstanceDefinition)myFrameworkInstances.getModel().getElementAt(i));\n    }\n\n    settings.setFrameworkInstanceDefinitions(definitions);\n    myModified = false;\n  }","id":42492,"modified_method":"public void applyTo(@NotNull ApplicationSettings settings) {\n    int instances = myModel.getSize();\n    List<FrameworkInstanceDefinition> definitions = new ArrayList<FrameworkInstanceDefinition>(instances);\n    for (int i = 0; i < instances; i++) {\n      definitions.add((FrameworkInstanceDefinition)myModel.getElementAt(i));\n    }\n    settings.setFrameworkInstanceDefinitions(definitions);\n    myModified = false;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void editFrameworkInstance() {\n    FrameworkInstanceDefinition frameworkInstanceDefinition = mySelectedFrameworkInstance;\n    if (frameworkInstanceDefinition == null) {\n      return; // usually should not happen, but you never know.\n    }\n\n    CreateFrameworkInstanceDialog dialog =\n      new CreateFrameworkInstanceDialog(myFrameworkIntegratorRegistry, frameworkInstanceDefinition.getName());\n    dialog.setIntegratorName(frameworkInstanceDefinition.getFrameworkIntegratorName());\n    dialog.setBaseFolder(frameworkInstanceDefinition.getBaseFolder());\n    dialog.setVersion(frameworkInstanceDefinition.getVersion());\n    dialog.pack();\n    dialog.show();\n\n    if (dialog.isOK()) {\n      int index = myModel.indexOf(mySelectedFrameworkInstance);\n      myModel.removeElement(mySelectedFrameworkInstance);\n\n      frameworkInstanceDefinition = new FrameworkInstanceDefinition();\n      // set new properties\n      frameworkInstanceDefinition.setName(dialog.getName());\n      frameworkInstanceDefinition.setFrameworkIntegratorName(dialog.getIntegratorName());\n      frameworkInstanceDefinition.setBaseFolder(dialog.getBaseFolder());\n      frameworkInstanceDefinition.setVersion(dialog.getVersion());\n      //noinspection unchecked\n      myModel.add(index, frameworkInstanceDefinition);\n      // fire settings change.\n      myModified = true;\n      myFrameworkInstances.setSelectedValue(frameworkInstanceDefinition, true);\n    }\n  }","id":42493,"modified_method":"private void editFrameworkInstance() {\n    FrameworkInstanceDefinition selectedFrameworkInstance = this.mySelectedFrameworkInstance;\n    if (selectedFrameworkInstance != null) {\n      CreateFrameworkInstanceDialog dialog = new CreateFrameworkInstanceDialog(myFrameworkIntegratorRegistry, selectedFrameworkInstance);\n      dialog.pack();\n      dialog.show();\n\n      if (dialog.isOK()) {\n        int index = myModel.indexOf(mySelectedFrameworkInstance);\n        myModel.removeElement(mySelectedFrameworkInstance);\n        selectedFrameworkInstance = dialog.createDefinition();\n        //noinspection unchecked\n        myModel.add(index, selectedFrameworkInstance);\n        myModified = true;\n        myFrameworkInstances.setSelectedValue(selectedFrameworkInstance, true);\n      }\n    }\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void addFrameworkInstance() {\n    CreateFrameworkInstanceDialog dialog = new CreateFrameworkInstanceDialog(myFrameworkIntegratorRegistry, null);\n    dialog.pack();\n    dialog.show();\n\n    if (dialog.isOK()) {\n      FrameworkInstanceDefinition instanceDefinition = new FrameworkInstanceDefinition();\n      instanceDefinition.setName(dialog.getName());\n      instanceDefinition.setFrameworkIntegratorName(dialog.getIntegratorName());\n      instanceDefinition.setBaseFolder(dialog.getBaseFolder());\n      instanceDefinition.setVersion(dialog.getVersion());\n      //noinspection unchecked\n      myModel.addElement(instanceDefinition);\n      myModified = true;\n      myFrameworkInstances.setSelectedValue(instanceDefinition, true);\n    }\n  }","id":42494,"modified_method":"private void addFrameworkInstance() {\n    CreateFrameworkInstanceDialog dialog = new CreateFrameworkInstanceDialog(myFrameworkIntegratorRegistry, null);\n    dialog.pack();\n    dialog.show();\n\n    if (dialog.isOK()) {\n      FrameworkInstanceDefinition instanceDefinition = dialog.createDefinition();\n      //noinspection unchecked\n      myModel.addElement(instanceDefinition);\n      myModified = true;\n      myFrameworkInstances.setSelectedValue(instanceDefinition, true);\n    }\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    if (frameworkInstanceDefinition.isDownloadedByPaxRunner()) {\n      return checkDownloadedFolderStructure(frameworkInstanceDefinition);\n    }\n\n    VirtualFile installFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (installFolder == null || !installFolder.isDirectory()) {\n      return OsmorcBundle\n        .getTranslation(\"knopflerfish.folder.does.not.exist\", frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile knopflerfishOrgFolder = installFolder.findChild(\"knopflerfish.org\");\n    if (knopflerfishOrgFolder == null || !knopflerfishOrgFolder.isDirectory()) {\n      return OsmorcBundle\n        .getTranslation(\"knopflerfish.folder.knopflerfish.org.missing\", frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile osgiFolder = knopflerfishOrgFolder.findChild(\"osgi\");\n    if (osgiFolder == null || !osgiFolder.isDirectory()) {\n      return OsmorcBundle.getTranslation(\"knopflerfish.folder.osgi.missing\", knopflerfishOrgFolder.getPath());\n    }\n\n    VirtualFile jarsFolder = osgiFolder.findChild(\"jars\");\n    if (jarsFolder == null || !jarsFolder.isDirectory()) {\n      return OsmorcBundle.getTranslation(\"knopflerfish.folder.jars.missing\", osgiFolder.getPath());\n    }\n\n    return null;\n  }","id":42495,"modified_method":"public String checkValidity(@NotNull FrameworkInstanceDefinition frameworkInstanceDefinition) {\n    if (frameworkInstanceDefinition.getName() == null || frameworkInstanceDefinition.getName().trim().length() == 0) {\n      return \"A name for the framework instance needs to be given.\";\n    }\n\n    VirtualFile installFolder = getLocalFileSystem().findFileByPath(frameworkInstanceDefinition.getBaseFolder());\n\n    if (installFolder == null || !installFolder.isDirectory()) {\n      return OsmorcBundle\n        .getTranslation(\"knopflerfish.folder.does.not.exist\", frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile knopflerfishOrgFolder = installFolder.findChild(\"knopflerfish.org\");\n    if (knopflerfishOrgFolder == null || !knopflerfishOrgFolder.isDirectory()) {\n      return OsmorcBundle\n        .getTranslation(\"knopflerfish.folder.knopflerfish.org.missing\", frameworkInstanceDefinition.getBaseFolder());\n    }\n\n    VirtualFile osgiFolder = knopflerfishOrgFolder.findChild(\"osgi\");\n    if (osgiFolder == null || !osgiFolder.isDirectory()) {\n      return OsmorcBundle.getTranslation(\"knopflerfish.folder.osgi.missing\", knopflerfishOrgFolder.getPath());\n    }\n\n    VirtualFile jarsFolder = osgiFolder.findChild(\"jars\");\n    if (jarsFolder == null || !jarsFolder.isDirectory()) {\n      return OsmorcBundle.getTranslation(\"knopflerfish.folder.jars.missing\", osgiFolder.getPath());\n    }\n\n    return null;\n  }","commit_id":"b71e6381c736b2967a5243ec08ee70726ede8719","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void handleSuccess(CommandExecutor executor) {\n    // could be situations when exit code = 0, but there is info \"warning\" in error stream for instance, for \"svn status\"\n    // on non-working copy folder\n    if (executor.getErrorOutput().length() > 0) {\n      // here exitCode == 0, but some warnings are in error stream\n      LOG.info(\"Detected warning - \" + executor.getErrorOutput());\n    }\n  }","id":42496,"modified_method":"private static void handleSuccess(@NotNull CommandExecutor executor) {\n    // could be situations when exit code = 0, but there is info \"warning\" in error stream for instance, for \"svn status\"\n    // on non-working copy folder\n    if (!StringUtil.isEmptyOrSpaces(executor.getErrorOutput())) {\n      // here exitCode == 0, but some warnings are in error stream\n      LOG.info(\"Detected warning - \" + executor.getErrorOutput());\n    }\n  }","commit_id":"4d86643acaa00aa8344f6ca5895014c08a286d26","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void redirectOutputsAndInput(StartParameter startParameter) throws IOException {\n        PrintStream originalOut = System.out;\n        PrintStream originalErr = System.err;\n//        InputStream originalIn = System.in;\n        File logOutputFile = new File(startParameter.getGradleUserHomeDir(), String.format(\"daemon/%s/daemon.out.log\", GradleVersion.current().getVersion()));\n        logOutputFile.getParentFile().mkdirs();\n        PrintStream printStream = new PrintStream(new FileOutputStream(logOutputFile), true);\n        System.setOut(printStream);\n        System.setErr(printStream);\n        System.setIn(new ByteArrayInputStream(new byte[0]));\n        originalOut.close();\n        originalErr.close();\n        // TODO - make this work on windows\n//        originalIn.close();\n    }","id":42497,"modified_method":"private static void redirectOutputsAndInput(StartParameter startParameter) throws IOException {\n        PrintStream originalOut = System.out;\n        PrintStream originalErr = System.err;\n//        InputStream originalIn = System.in;\n        DaemonDir daemonDir = new DaemonDir(startParameter.getGradleUserHomeDir());\n        File logOutputFile = daemonDir.getLog(); //TODO SF each daemon needs his own log file (or potentially his own folder)\n        logOutputFile.getParentFile().mkdirs();\n        PrintStream printStream = new PrintStream(new FileOutputStream(logOutputFile), true);\n        System.setOut(printStream);\n        System.setErr(printStream);\n        System.setIn(new ByteArrayInputStream(new byte[0]));\n        originalOut.close();\n        originalErr.close();\n        // TODO - make this work on windows\n//        originalIn.close();\n    }","commit_id":"70c2499e8b08d15974270f8adf38b9af89c5d2cd","url":"https://github.com/gradle/gradle"},{"original_method":"public DaemonRegistry(File registryFolder) {\n        this.registryFolder = new File(registryFolder, String.format(\"daemon/%s\", GradleVersion.current().getVersion()));\n    }","id":42498,"modified_method":"public DaemonRegistry(File baseFolder) {\n        this.daemonDir = new DaemonDir(baseFolder);\n        this.registryFolder = daemonDir.getFile();\n    }","commit_id":"70c2499e8b08d15974270f8adf38b9af89c5d2cd","url":"https://github.com/gradle/gradle"},{"original_method":"private static LibC loadLibC() {\n        try {\n            return (LibC) Native.loadLibrary(\"c\", LibC.class);\n        } catch (LinkageError e) {\n            LOGGER.debug(\"Unable to load LibC library. Continuing with fallback filesystem implementations.\");\n            return null;\n        }\n    }","id":42499,"modified_method":"private static LibC loadLibC() {\n        try {\n            return (LibC) Native.loadLibrary(\"c\", LibC.class);\n        } catch (LinkageError e) {\n            LOGGER.debug(\"Unable to load LibC library. Continuing with fallback filesystem implementations.\", e);\n            return null;\n        }\n    }","commit_id":"7668771c68dca17620fa3b6aa4ddc321bd0cdb07","url":"https://github.com/gradle/gradle"},{"original_method":"protected OutputEventRenderer createOutputEventRenderer() {\n        TerminalDetector terminalDetector;\n        if (detectConsole) {\n            StartParameter startParameter = new StartParameter();\n            JnaBootPathConfigurer jnaConfigurer = new JnaBootPathConfigurer(startParameter.getGradleUserHomeDir());\n            terminalDetector = new TerminalDetectorFactory().create(jnaConfigurer);\n        } else {\n            terminalDetector = new NoOpTerminalDetector();\n        }\n        return new OutputEventRenderer(terminalDetector).addStandardOutputAndError();\n    }","id":42500,"modified_method":"protected OutputEventRenderer createOutputEventRenderer() {\n        TerminalDetector terminalDetector;\n        if (detectConsole) {\n            StartParameter startParameter = new StartParameter();\n            NativeServices.initialize(startParameter.getGradleUserHomeDir());\n            terminalDetector = NativeServices.getInstance().get(TerminalDetector.class);\n        } else {\n            terminalDetector = new NoOpTerminalDetector();\n        }\n        return new OutputEventRenderer(terminalDetector).addStandardOutputAndError();\n    }","commit_id":"7668771c68dca17620fa3b6aa4ddc321bd0cdb07","url":"https://github.com/gradle/gradle"},{"original_method":"protected TerminalDetector createTerminalDetector() {\n        try {\n            if (get(OperatingSystem.class).isWindows()) {\n                return new WindowsTerminalDetector();\n            }\n            return new LibCBackedTerminalDetector(get(LibC.class));\n        } catch (LinkageError e) {\n            // Thrown when jna cannot initialize the native stuff\n            return new NoOpTerminalDetector();\n        }\n    }","id":42501,"modified_method":"protected TerminalDetector createTerminalDetector() {\n        try {\n            if (get(OperatingSystem.class).isWindows()) {\n                return new WindowsTerminalDetector();\n            }\n            return new LibCBackedTerminalDetector(get(LibC.class));\n        } catch (LinkageError e) {\n            // Thrown when jna cannot initialize the native stuff\n            LOGGER.debug(\"Unable to load native library. Continuing with fallback.\", e);\n            return new NoOpTerminalDetector();\n        }\n    }","commit_id":"7668771c68dca17620fa3b6aa4ddc321bd0cdb07","url":"https://github.com/gradle/gradle"},{"original_method":"protected ProcessEnvironment createProcessEnvironment() {\n        try {\n            if (OperatingSystem.current().isUnix()) {\n                return new LibCBackedProcessEnvironment(get(LibC.class));\n            } else if (OperatingSystem.current().isWindows()) {\n                return new WindowsProcessEnvironment();\n            } else {\n                return new UnsupportedEnvironment();\n            }\n        } catch (LinkageError e) {\n            // Thrown when jna cannot initialize the native stuff\n            return new UnsupportedEnvironment();\n        }\n    }","id":42502,"modified_method":"protected ProcessEnvironment createProcessEnvironment() {\n        try {\n            if (OperatingSystem.current().isUnix()) {\n                return new LibCBackedProcessEnvironment(get(LibC.class));\n            } else if (OperatingSystem.current().isWindows()) {\n                return new WindowsProcessEnvironment();\n            } else {\n                return new UnsupportedEnvironment();\n            }\n        } catch (LinkageError e) {\n            // Thrown when jna cannot initialize the native stuff\n            LOGGER.debug(\"Unable to load native library. Continuing with fallback.\", e);\n            return new UnsupportedEnvironment();\n        }\n    }","commit_id":"7668771c68dca17620fa3b6aa4ddc321bd0cdb07","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Waits until stopped, or timeout.\n     *\n     * @return true if stopped, false if timeout\n     */\n    public boolean awaitStopOrIdleTimeout(int timeout) {\n        lock.lock();\n        try {\n            while (running || (!stopped && lastActivityAt < (System.currentTimeMillis() - timeout))) {\n                try {\n                    if (running) {\n                        condition.await();\n                    } else {\n                        condition.awaitUntil(new Date(lastActivityAt + timeout));\n                    }\n                } catch (InterruptedException e) {\n                    throw UncheckedException.asUncheckedException(e);\n                }\n            }\n            assert !running;\n            return stopped;\n        } finally {\n            lock.unlock();\n        }\n    }","id":42503,"modified_method":"/**\n     * Waits until stopped, or timeout.\n     *\n     * @return true if stopped, false if timeout\n     */\n    public boolean awaitStopOrIdleTimeout(int timeout) {\n        lock.lock();\n        try {\n            while ((running || !isStarted()) || (!stopped && !hasBeenIdleFor(timeout))) {\n                try {\n                    if (running || !isStarted()) {\n                        condition.await();\n                    } else {\n                        condition.awaitUntil(new Date(lastActivityAt + timeout));\n                    }\n                } catch (InterruptedException e) {\n                    throw UncheckedException.asUncheckedException(e);\n                }\n            }\n            assert !running;\n            return stopped;\n        } finally {\n            lock.unlock();\n        }\n    }","commit_id":"3d9b3831392a7bf183e58a28a1e59833aa7d8ab4","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Starts the daemon, receiving connections asynchronously (i.e. returns immediately).\n     * \n     * @throws IllegalStateException if this daemon is already running, or has already been stopped.\n     */\n    public void start() {\n        lifecycleLock.lock();\n        try {\n            if (stopped) {\n                throw new IllegalStateException(\"cannot start daemon as it has already been used\");\n            }\n            if (started) {\n                throw new IllegalStateException(\"cannot start daemon as it is already running\");\n            }\n\n            // Get ready to accept connections, but we are assuming that no connections will be established\n            // because we have not yet advertised that we are open for business by entering our address into\n            // the registry, which happens a little further down in this method.\n            connectorAddress = connector.start(new IncomingConnectionHandler() {\n                public void handle(final Connection<Object> connection) {\n\n                    //we're spinning a thread to do work to avoid blocking the connection\n                    //This means that the Daemon potentially can have multiple jobs running.\n                    //We only allow 2 threads max - one for the build, second for potential Stop request\n                    handlersExecutor.execute(new Runnable() {\n                        public void run() {\n                            Command command = null;\n                            try {\n                                command = lockAndReceive(connection, control);\n                                if (command == null || command instanceof Stop) {\n                                    if (command == null) {\n                                        LOGGER.warn(\"It seems the client dropped the connection before sending any command. Stopping connection.\");\n                                    }\n                                    unlock(control);  //TODO SF - if receiving is first we don't need this really\n                                    connection.stop();\n                                    stopLatch.countDown();\n                                    return;\n                                }\n                            } catch (BusyException e) {\n                                connection.dispatch(new CommandComplete(e));\n                                return;\n                            }\n                            try {\n                                doRun(connection, control, command);\n                            } finally {\n                                unlock(control);\n                                connection.stop();\n                            }\n                        }\n                    });\n                }\n            });\n\n            control.setActivityListener(new CompletionHandler.ActivityListener() {\n                public void onStart() {\n                    daemonRegistry.markBusy(connectorAddress);\n                }\n\n                public void onComplete() {\n                    daemonRegistry.markIdle(connectorAddress);\n                }\n            });\n\n            // Start a new thread to watch the stop latch\n            stopperExecutor.execute(new Runnable() {\n                public void run() {\n                    try {\n                        stopLatch.await();\n                    } catch (InterruptedException e) {\n                        // unsure what we can really do here, it shouldn't happen anyway.\n                        return;\n                    }\n                    \n                    daemonRegistry.remove(connectorAddress); // remove our presence to clients\n                    connector.stop(); // stop accepting new connections\n                    handlersExecutor.stop(); // wait for any connection handlers to stop (though connector.stop() will have already waited for this)\n                    control.stop(); // wake up anyone waiting on our completion (i.e. )\n                }\n            });\n            \n            // Advertise that the daemon is now ready to accept connections\n            daemonRegistry.store(connectorAddress);\n            started = true;\n        } finally {\n            lifecycleLock.unlock();\n        }\n    }","id":42504,"modified_method":"/**\n     * Starts the daemon, receiving connections asynchronously (i.e. returns immediately).\n     * \n     * @throws IllegalStateException if this daemon is already running, or has already been stopped.\n     */\n    public void start() {\n        lifecycleLock.lock();\n        try {\n            if (stopped) {\n                throw new IllegalStateException(\"cannot start daemon as it has already been used\");\n            }\n            if (started) {\n                throw new IllegalStateException(\"cannot start daemon as it is already running\");\n            }\n\n            // Get ready to accept connections, but we are assuming that no connections will be established\n            // because we have not yet advertised that we are open for business by entering our address into\n            // the registry, which happens a little further down in this method.\n            connectorAddress = connector.start(new IncomingConnectionHandler() {\n                public void handle(final Connection<Object> connection) {\n\n                    //we're spinning a thread to do work to avoid blocking the connection\n                    //This means that the Daemon potentially can have multiple jobs running.\n                    //We only allow 2 threads max - one for the build, second for potential Stop request\n                    handlersExecutor.execute(new Runnable() {\n                        public void run() {\n                            Command command = null;\n                            try {\n                                command = lockAndReceive(connection, control);\n                                if (command == null) {\n                                    LOGGER.warn(\"It seems the client dropped the connection before sending any command. Stopping connection.\");\n                                    unlock(control);  //TODO SF - if receiving is first we don't need this really\n                                    connection.stop();\n                                    return;\n                                }\n                            } catch (BusyException e) {\n                                connection.dispatch(new CommandComplete(e));\n                                return;\n                            }\n                            try {\n                                doRun(connection, control, command);\n                            } finally {\n                                unlock(control);\n                                connection.stop();\n                            }\n                        }\n                    });\n                }\n            });\n\n            control.setActivityListener(new CompletionHandler.ActivityListener() {\n                public void onStart() {\n                    daemonRegistry.markBusy(connectorAddress);\n                }\n\n                public void onComplete() {\n                    daemonRegistry.markIdle(connectorAddress);\n                }\n            });\n\n            // Start a new thread to watch the stop latch\n            stopperExecutor.execute(new Runnable() {\n                public void run() {\n                    try {\n                        stopLatch.await();\n                    } catch (InterruptedException e) {\n                        // unsure what we can really do here, it shouldn't happen anyway.\n                        return;\n                    }\n                    \n                    daemonRegistry.remove(connectorAddress); // remove our presence to clients\n                    connector.stop(); // stop accepting new connections\n                    handlersExecutor.stop(); // wait for any connection handlers to stop (though connector.stop() will have already waited for this)\n                    control.stop(); // wake up anyone waiting on our completion (i.e. )\n                }\n            });\n            \n            // Advertise that the daemon is now ready to accept connections\n            daemonRegistry.store(connectorAddress);\n            control.start();\n            started = true;\n            LOGGER.lifecycle(\"Daemon started at: \" + new Date() + \", with address: \" + connectorAddress);\n        } catch (Exception e) {\n            LOGGER.warn(\"exception starting daemon\", e);\n            stopLatch.countDown();\n        } finally {\n            lifecycleLock.unlock();\n        }\n    }","commit_id":"3d9b3831392a7bf183e58a28a1e59833aa7d8ab4","url":"https://github.com/gradle/gradle"},{"original_method":"private CommandComplete doRunWithExceptionHandling(Command command, Stoppable serverControl) {\n        LOGGER.info(\"Executing {}\", command);\n        if (command instanceof Stop) {\n            LOGGER.lifecycle(\"Stopping\");\n            serverControl.stop();\n            return new CommandComplete(null);\n        }\n\n        return build((Build) command);\n    }","id":42505,"modified_method":"private CommandComplete doRunWithExceptionHandling(Command command, Stoppable serverControl) {\n        LOGGER.info(\"Executing {}\", command);\n        if (command instanceof Stop) {\n            LOGGER.lifecycle(\"Stopping\");\n            stopLatch.countDown();\n            return new CommandComplete(null);\n        }\n\n        return build((Build) command);\n    }","commit_id":"3d9b3831392a7bf183e58a28a1e59833aa7d8ab4","url":"https://github.com/gradle/gradle"},{"original_method":"public static void main(String[] args) throws IOException {\n        StartParameter startParameter = new DefaultCommandLineConverter().convert(Arrays.asList(args));\n        redirectOutputsAndInput(startParameter);\n        \n        LoggingServiceRegistry loggingServices = LoggingServiceRegistry.newChildProcessLogging();\n        DaemonServerConnector connector = new DaemonServerConnector();\n        DaemonRegistry daemonRegistry = new PersistentDaemonRegistry(startParameter.getGradleUserHomeDir());\n        \n        int idleTimeout = getIdleTimeout(startParameter);\n        LOGGER.info(\"Daemon idle timeout is configured to: \" + idleTimeout / 1000 + \" secs\");\n        \n        Daemon daemon = new Daemon(loggingServices, connector, daemonRegistry);\n        \n        daemon.start();\n        boolean wasStopped = daemon.awaitStopOrIdleTimeout(idleTimeout);\n        if (wasStopped) {\n            LOGGER.info(\"Daemon stopping due to stop request\");\n        } else {\n            LOGGER.info(\"Daemon hit idle timeout (\" + idleTimeout / 1000 + \" secs), stopping\");\n            daemon.stop();\n        }\n    }","id":42506,"modified_method":"public static void main(String[] args) throws IOException {\n        StartParameter startParameter = new DefaultCommandLineConverter().convert(Arrays.asList(args));\n        redirectOutputsAndInput(startParameter);\n        \n        LoggingServiceRegistry loggingServices = LoggingServiceRegistry.newChildProcessLogging();\n        DaemonServerConnector connector = new DaemonServerConnector();\n        \n        File registryDir = startParameter.getGradleUserHomeDir();\n        DaemonRegistry daemonRegistry = new PersistentDaemonRegistry(registryDir);\n        \n        int idleTimeout = getIdleTimeout(startParameter);\n        float idleTimeoutSecs = idleTimeout / 1000;\n        \n        LOGGER.lifecycle(\"Starting daemon (at {}) with settings: idleTimeout = {} secs, registryDir = {}\", new Date(), idleTimeoutSecs, registryDir);\n        Daemon daemon = new Daemon(loggingServices, connector, daemonRegistry);\n        \n        daemon.start();\n        boolean wasStopped = daemon.awaitStopOrIdleTimeout(idleTimeout);\n        if (wasStopped) {\n            LOGGER.info(\"Daemon stopping due to stop request\");\n        } else {\n            LOGGER.info(\"Daemon hit idle timeout (\" + idleTimeoutSecs + \" secs), stopping\");\n            daemon.stop();\n        }\n    }","commit_id":"3d9b3831392a7bf183e58a28a1e59833aa7d8ab4","url":"https://github.com/gradle/gradle"},{"original_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        User user =  requestContext.getLoggedInUser();\n        \n        \n        String org = user.getOrg().getId().toString();\n        String urlStr;\n        try {                        \n            URL url = new URL(\n                    requestContext.getRequest().getRequestURL().toString());            \n            urlStr = \"ks=\" + url.getProtocol() + \"://\" + url.getHost() + \n            \"/ks/org/\" + org + \"x\" + \n            SessionSwap.generateSwapKey(org) + \"/mode/ip_range\";                        \n        }\n        catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Bad argument when creating URL for \" +\n                    \"Kickstart IP Ranges\");\n        }\n        String urlRange = \n            LocalizationService.getInstance().getMessage(\"kickstart.iprange.url\", urlStr);\n        request.setAttribute(\"urlrange\", urlRange);\n        \n        request.setAttribute(ListTagHelper.PARENT_URL, request.getRequestURI());\n        \n        request.setAttribute(\"pageList\", getDataResult(requestContext, null));\n        \n        return mapping.findForward(\"default\");\n\n    }","id":42507,"modified_method":"/** {@inheritDoc} */\n    public ActionForward execute(ActionMapping mapping,\n            ActionForm formIn,\n            HttpServletRequest request,\n            HttpServletResponse response) {\n\n        RequestContext requestContext = new RequestContext(request);\n        User user =  requestContext.getLoggedInUser();\n        \n        String urlStr;\n        try {                        \n            URL url = new URL(\n                    requestContext.getRequest().getRequestURL().toString());            \n            urlStr = \"ks=\" + \n            KickstartUrlHelper.getKickstartFileUrlIpRange(user.getOrg(),\n                    url.getHost(), url.getProtocol());                        \n        }\n        catch (MalformedURLException e) {\n            throw new IllegalArgumentException(\"Bad argument when creating URL for \" +\n                    \"Kickstart IP Ranges\");\n        }\n        String urlRange = \n            LocalizationService.getInstance().getMessage(\"kickstart.iprange.url\", urlStr);\n        request.setAttribute(\"urlrange\", urlRange);\n        \n        request.setAttribute(ListTagHelper.PARENT_URL, request.getRequestURI());\n        \n        request.setAttribute(\"pageList\", getDataResult(requestContext, null));\n        \n        return mapping.findForward(\"default\");\n\n    }","commit_id":"206f1577eeea4ee86cb03a8c3b6b95d220a3a091","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * The base for a kickstart URL including the org:\n     * \n     * http://spacewalk.example.com/kickstart/ks/org/1/ \n     * \n     * @return String url to kickstart file\n     */\n    public String getKickstartFileUrlBase() {\n        \n        StringBuilder urlBase = new StringBuilder();\n        urlBase.append(protocol);\n        if (!protocol.endsWith(\"://\")) {\n            urlBase.append(\"://\");    \n        }\n        urlBase.append(host);\n        urlBase.append(KS_CFG + \"/org/\"); \n        urlBase.append(ksData.getOrg().getId().toString());        \n        return urlBase.toString();\n    }","id":42508,"modified_method":"/**\n     * The base for a kickstart URL including the org:\n     * \n     * http://spacewalk.example.com/kickstart/ks/org/1/ \n     * \n     * @return String url to kickstart file\n     */\n    public String getKickstartFileUrlBase() {\n        return getKickstartFileUrlBase(ksData.getOrg(), host, protocol);\n    }","commit_id":"206f1577eeea4ee86cb03a8c3b6b95d220a3a091","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Get the URL for the ip_range file server. Example:\n     * \n     * http://spacewalk.example.com/kickstart/ks/org/1/mode/ip_range\n     * \n     * The above URL examines the requesters IP address to determine what ks profile\n     * they should get.\n     * \n     * @return String URL \n     */\n    public String getKickstartFileUrlIpRange() {\n        return getKickstartFileUrlBase() + \"/mode/ip_range\";\n    }","id":42509,"modified_method":"/**\n     * Get the URL for the ip_range file server. Example:\n     * \n     * http://spacewalk.example.com/kickstart/ks/org/1/mode/ip_range\n     * \n     * The above URL examines the requesters IP address to determine what ks profile\n     * they should get.\n     * \n     * @return String URL \n     */\n    public String getKickstartFileUrlIpRange() {\n        return getKickstartFileUrlIpRange(ksData.getOrg(), host, protocol);\n    }","commit_id":"206f1577eeea4ee86cb03a8c3b6b95d220a3a091","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Migrate a set of servers to the organization specified\n     * @param user Org admin that is performing the migration\n     * @param fromOrg The origination org\n     * @param toOrg The destination org\n     * @param servers List of servers to be migrated\n     * @return the list of server ids successfully migrated.\n     */\n    public static List<Long> migrateServers(User user, Org fromOrg, Org toOrg, \n            List<Server> servers) {\n        \n        List<Long> serversMigrated = new ArrayList<Long>();\n        \n        for (Server server : servers) {\n        \n            MigrationManager.removeOrgRelationships(user, server);\n            MigrationManager.updateAdminRelationships(fromOrg, toOrg, server);\n            MigrationManager.moveServerToOrg(fromOrg, toOrg, server);\n            serversMigrated.add(server.getId());\n            OrgFactory.save(toOrg);\n            OrgFactory.save(fromOrg);\n            ServerFactory.save(server);\n            \n            // update server history to record the migration.\n            ServerHistoryEvent event = new ServerHistoryEvent();\n            event.setCreated(new Date());\n            event.setServer(server);\n            event.setSummary(\"System migration\");\n            String details = \"From organization: \" + fromOrg.getName();\n            details += \", To organization: \" + toOrg.getName();\n            event.setDetails(details);\n            server.getHistory().add(event);\n\n            SystemMigration migration = SystemMigrationFactory.createSystemMigration();\n            migration.setToOrg(toOrg);\n            migration.setFromOrg(fromOrg);\n            migration.setServer(server);\n            migration.setMigrated(new Date());\n            SystemMigrationFactory.save(migration);\n        }\n        return serversMigrated;\n    }","id":42510,"modified_method":"/**\n     * Migrate a set of servers to the organization specified\n     * @param user Org admin that is performing the migration\n     * @param toOrg The destination org\n     * @param servers List of servers to be migrated\n     * @return the list of server ids successfully migrated.\n     */\n    public static List<Long> migrateServers(User user, Org toOrg, List<Server> servers) {\n        \n        List<Long> serversMigrated = new ArrayList<Long>();\n        \n        for (Server server : servers) {\n        \n            Org fromOrg = server.getOrg();\n            \n            MigrationManager.removeOrgRelationships(user, server);\n            MigrationManager.updateAdminRelationships(fromOrg, toOrg, server);\n            MigrationManager.moveServerToOrg(toOrg, server);\n            serversMigrated.add(server.getId());\n            OrgFactory.save(toOrg);\n            OrgFactory.save(fromOrg);\n            ServerFactory.save(server);\n            \n            // update server history to record the migration.\n            ServerHistoryEvent event = new ServerHistoryEvent();\n            event.setCreated(new Date());\n            event.setServer(server);\n            event.setSummary(\"System migration\");\n            String details = \"From organization: \" + fromOrg.getName();\n            details += \", To organization: \" + toOrg.getName();\n            event.setDetails(details);\n            server.getHistory().add(event);\n\n            SystemMigration migration = SystemMigrationFactory.createSystemMigration();\n            migration.setToOrg(toOrg);\n            migration.setFromOrg(fromOrg);\n            migration.setServer(server);\n            migration.setMigrated(new Date());\n            SystemMigrationFactory.save(migration);\n        }\n        return serversMigrated;\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Move the server from the originating org to the destination org.\n     *\n     * @param fromOrg originating org where the server currently exists\n     * @param toOrg destination org where the server will be migrated to\n     * @param server Server to be migrated.\n     */\n    public static void moveServerToOrg(Org fromOrg, Org toOrg, Server server) {\n        \n        // Move the server\n        server.setOrg(toOrg);\n    }","id":42511,"modified_method":"/**\n     * Move the server to the destination org.\n     *\n     * @param toOrg destination org where the server will be migrated to\n     * @param server Server to be migrated.\n     */\n    public static void moveServerToOrg(Org toOrg, Server server) {\n        \n        // Move the server\n        server.setOrg(toOrg);\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testMigrateServers() throws Exception {\n \n        assertEquals(server.getOrg(), origOrg);\n        assertEquals(server2.getOrg(), origOrg);\n        \n        List<Server> servers = new ArrayList<Server>();\n        servers.add(server);\n        servers.add(server2);\n        User origOrgAdmin = origOrgAdmins.iterator().next();\n        MigrationManager.migrateServers(origOrgAdmin, origOrgAdmin.getOrg(), destOrg, \n                servers);\n        \n        assertEquals(server.getOrg(), destOrg);\n        assertEquals(server2.getOrg(), destOrg);\n        \n        assertNotNull(server.getHistory());\n        assertTrue(server.getHistory().size() > 0);\n        boolean migrationRecorded = false;\n        for (ServerHistoryEvent event : (Set<ServerHistoryEvent>) server.getHistory()) {\n            if (event.getSummary().equals(\"System migration\") &&\n                event.getDetails().contains(\"From organization: \" + origOrg.getName()) &&\n                event.getDetails().contains(\"To organization: \" + destOrg.getName()) &&\n                (event.getCreated() != null)) {\n                migrationRecorded = true;\n            }\n        }\n        assertTrue(migrationRecorded);\n        \n        List<SystemMigration> s1Migrations = SystemMigrationFactory.lookupByServer(server);\n        List<SystemMigration> s2Migrations = SystemMigrationFactory.lookupByServer(\n                server2);\n        assertNotNull(s1Migrations);\n        assertNotNull(s2Migrations);\n        assertEquals(1, s1Migrations.size());\n        assertEquals(1, s2Migrations.size());\n    }","id":42512,"modified_method":"public void testMigrateServers() throws Exception {\n \n        assertEquals(server.getOrg(), origOrg);\n        assertEquals(server2.getOrg(), origOrg);\n        \n        List<Server> servers = new ArrayList<Server>();\n        servers.add(server);\n        servers.add(server2);\n        User origOrgAdmin = origOrgAdmins.iterator().next();\n        MigrationManager.migrateServers(origOrgAdmin, destOrg, servers);\n        \n        assertEquals(server.getOrg(), destOrg);\n        assertEquals(server2.getOrg(), destOrg);\n        \n        assertNotNull(server.getHistory());\n        assertTrue(server.getHistory().size() > 0);\n        boolean migrationRecorded = false;\n        for (ServerHistoryEvent event : (Set<ServerHistoryEvent>) server.getHistory()) {\n            if (event.getSummary().equals(\"System migration\") &&\n                event.getDetails().contains(\"From organization: \" + origOrg.getName()) &&\n                event.getDetails().contains(\"To organization: \" + destOrg.getName()) &&\n                (event.getCreated() != null)) {\n                migrationRecorded = true;\n            }\n        }\n        assertTrue(migrationRecorded);\n        \n        List<SystemMigration> s1Migrations = SystemMigrationFactory.lookupByServer(server);\n        List<SystemMigration> s2Migrations = SystemMigrationFactory.lookupByServer(\n                server2);\n        assertNotNull(s1Migrations);\n        assertNotNull(s2Migrations);\n        assertEquals(1, s1Migrations.size());\n        assertEquals(1, s2Migrations.size());\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor\n     * @param org inolved in the migration\n     * @param cause the cause\n     */\n    public MigrationToSameOrgException(Org org, Throwable cause) {\n        super(1069, \"MigrationToSameOrg\" , LocalizationService.getInstance().\n                getMessage(\"api.org.migrationtosameorg\", \n                        new Object [] {org.getId()}), cause);\n    }","id":42513,"modified_method":"/**\n     * Constructor\n     * @param server inolved in the migration\n     * @param cause the cause\n     */\n    public MigrationToSameOrgException(Server server, Throwable cause) {\n        super(2853, \"MigrationToSameOrg\" , LocalizationService.getInstance().\n                getMessage(\"api.org.migrationtosameorg\", \n                        server.getOrg().getId().toString(),\n                        server.getId().toString()), cause);\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor\n     * @param org involved in the migration\n     */\n    public MigrationToSameOrgException(Org org) {\n        super(1069, \"MigrationToSameOrg\" , LocalizationService.getInstance().\n                getMessage(\"api.org.migrationtosameorg\", \n                        new Object [] {org.getId()}));\n    }","id":42514,"modified_method":"/**\n     * Constructor\n     * @param server involved in the migration\n     */\n    public MigrationToSameOrgException(Server server) {\n        super(2853, \"MigrationToSameOrg\" , LocalizationService.getInstance().\n                getMessage(\"api.org.migrationtosameorg\", \n                        server.getOrg().getId().toString(),\n                        server.getId().toString()));\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Migrate systems from one organization to another.  The systems \n     * must currently exist in the organization specified by the fromOrgId\n     * and will be migrated to the organization specified by the toOrgId.  The \n     * Satellite administrator may migrate systems from any organization; however,\n     * organization administrators may only migrate systems from their organization.\n     * In any scenario, the originating organization must be defined within the\n     * destination organization's trust.\n     *  \n     * @param sessionKey User's session key.\n     * @param fromOrgId originating organization ID.\n     * @param toOrgId destination organization ID.\n     * @param sids System IDs.\n     * @return list of systems migrated.\n     * @throws FaultException A FaultException is thrown if:\n     *   - The user performing the request is not an organization administrator\n     *   - The user performing the request is not a satellite administrator, but the\n     *     from org id is different than the user's org id.\n     *   - The from and to org id provided are the same.\n     *   - One or more of the servers provides do not exist\n     *   - The origination or destination organization does not exist\n     *   - The user is not defined in the destination organization's trust\n     * \n     * @xmlrpc.doc Migrate systems from one organization to another.  The systems \n     * must currently exist in the organization specified by the fromOrgId\n     * and will be migrated to the organization specified by the toOrgId.  The \n     * Satellite administrator may migrate systems from any organization; however,\n     * organization administrators may only migrate systems from their organization.\n     * In any scenario, the originating organization must be defined within the\n     * destination organization's trust. \n     * @xmlrpc.param #param(\"string\", \"sessionKey\")\n     * @xmlrpc.param #param_desc(\"int\", \"fromOrgId\", \"ID of the organization where the\n     * system(s) currently exist.\")\n     * @xmlrpc.param #param_desc(\"int\", \"toOrgId\", \"ID of the organization where the\n     * system(s) will be migrated to.\")\n     * @xmlrpc.param #array_single(\"int\", \"systemId\")\n     * @xmlrpc.returntype\n     * #array_single(\"int\", \"serverIdMigrated\")\n     */\n    public Object[] migrateSystems(String sessionKey, Integer fromOrgId, Integer toOrgId, \n            List<Integer> sids) throws FaultException {\n\n        // the user executing the request must at least be an org admin to perform\n        // a system migration\n        User admin = getOrgAdmin(sessionKey);\n        \n        // unless the user is a satellite admin, they are not permitted to migrate\n        // systems from an org that they do not belong to\n        if ((!admin.hasRole(RoleFactory.SAT_ADMIN)) && \n            (!admin.getOrg().getId().equals(fromOrgId.longValue()))) {\n            throw new PermissionCheckFailureException();\n        }\n        \n        Org toOrg = verifyOrgExists(toOrgId);\n        Org fromOrg = verifyOrgExists(fromOrgId);\n\n        // do not allow the user to migrate systems to/from the same org.  doing so\n        // would essentially remove entitlements, channels...etc from the systems\n        // being migrated.\n        if (fromOrg.equals(toOrg)) {\n            throw new MigrationToSameOrgException(fromOrg);\n        }\n        \n        // if the originating org is not defined within the destination org' trust\n        // the migration should not be permitted.\n        if (!toOrg.getTrustedOrgs().contains(fromOrg)) {\n            throw new OrgNotInTrustException(fromOrgId);\n        }\n        \n        List<Server> servers = new LinkedList<Server>();\n        for (Integer sid : sids) {\n            Long serverId = new Long(sid.longValue());\n            Server server = null;\n            try {\n                server = ServerFactory.lookupByIdAndOrg(serverId, fromOrg);\n            \n                // throw a no_such_system exception if the server was not found.\n                if (server == null) {\n                    throw new NoSuchSystemException(\n                            \"No such system - sid[\" + sid + \"] in org[\" +\n                            fromOrg.getId() + \"]\");\n                }\n            }\n            catch (LookupException e) {\n                throw new NoSuchSystemException(\n                        \"No such system - sid[\" + sid + \"] in org[\" +\n                        fromOrg.getId() + \"]\");\n            }\n            servers.add(server);\n        }\n            \n        List<Long> serversMigrated = MigrationManager.migrateServers(admin, fromOrg,\n                toOrg, servers);\n        return serversMigrated.toArray();\n    }","id":42515,"modified_method":"/**\n     * Migrate systems from one organization to another.  If executed by\n     * a Satellite administrator, the systems will be migrated from their current\n     * organization to the organization specified by the toOrgId.  If executed by\n     * an organization administrator, the systems must exist in the same organization\n     * as that administrator and the systems will be migrated to the organization \n     * specified by the toOrgId. In any scenario, the origination and destination \n     * organizations must be defined in a trust.\n     *  \n     * @param sessionKey User's session key.\n     * @param toOrgId destination organization ID.\n     * @param sids System IDs.\n     * @return list of systems migrated.\n     * @throws FaultException A FaultException is thrown if:\n     *   - The user performing the request is not an organization administrator\n     *   - The user performing the request is not a satellite administrator, but the\n     *     from org id is different than the user's org id.\n     *   - The from and to org id provided are the same.\n     *   - One or more of the servers provides do not exist\n     *   - The origination or destination organization does not exist\n     *   - The user is not defined in the destination organization's trust\n     * \n     * @xmlrpc.doc Migrate systems from one organization to another.  If executed by\n     * a Satellite administrator, the systems will be migrated from their current\n     * organization to the organization specified by the toOrgId.  If executed by\n     * an organization administrator, the systems must exist in the same organization\n     * as that administrator and the systems will be migrated to the organization \n     * specified by the toOrgId. In any scenario, the origination and destination \n     * organizations must be defined in a trust.\n     * @xmlrpc.param #param(\"string\", \"sessionKey\")\n     * @xmlrpc.param #param_desc(\"int\", \"toOrgId\", \"ID of the organization where the\n     * system(s) will be migrated to.\")\n     * @xmlrpc.param #array_single(\"int\", \"systemId\")\n     * @xmlrpc.returntype\n     * #array_single(\"int\", \"serverIdMigrated\")\n     */\n    public Object[] migrateSystems(String sessionKey, Integer toOrgId, \n            List<Integer> sids) throws FaultException {\n\n        // the user executing the request must at least be an org admin to perform\n        // a system migration\n        User admin = getOrgAdmin(sessionKey);\n        \n        Org toOrg = verifyOrgExists(toOrgId);\n\n        List<Server> servers = new LinkedList<Server>();\n        \n        for (Integer sid : sids) {\n            Long serverId = new Long(sid.longValue());\n            Server server = null;\n            try {\n                server = ServerFactory.lookupById(serverId);\n            \n                // throw a no_such_system exception if the server was not found.\n                if (server == null) {\n                    throw new NoSuchSystemException(\"No such system - sid[\" + sid + \"]\");\n                }\n            }\n            catch (LookupException e) {\n                throw new NoSuchSystemException(\"No such system - sid[\" + sid + \"]\");\n            }\n            servers.add(server);\n            \n            // As a pre-requisite to performing the actual migration, verify that each\n            // server that is planned for migration passes the criteria that follows.\n            // If any of the servers fails that criteria, none will be migrated.\n            \n            // unless the user is a satellite admin, they are not permitted to migrate\n            // systems from an org that they do not belong to\n            if ((!admin.hasRole(RoleFactory.SAT_ADMIN)) && \n                (!admin.getOrg().equals(server.getOrg()))) {\n                throw new PermissionCheckFailureException(server);\n            }\n            \n            // do not allow the user to migrate systems to/from the same org.  doing so\n            // would essentially remove entitlements, channels...etc from the systems\n            // being migrated.\n            if (toOrg.equals(server.getOrg())) {\n                throw new MigrationToSameOrgException(server);\n            }\n            \n            // if the originating org is not defined within the destination org's trust\n            // the migration should not be permitted.\n            if (!toOrg.getTrustedOrgs().contains(server.getOrg())) {\n                throw new OrgNotInTrustException(server);\n            }\n        }\n        \n        List<Long> serversMigrated = MigrationManager.migrateServers(admin, \n                toOrg, servers);\n        return serversMigrated.toArray();\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testMigrateSystem() throws Exception {\n        User newOrgAdmin = UserTestUtils.findNewUser(\"newAdmin\", \"newOrg\", true);\n        newOrgAdmin.getOrg().getTrustedOrgs().add(admin.getOrg());\n        OrgFactory.save(newOrgAdmin.getOrg());\n\n        Server server = ServerTestUtils.createTestSystem(admin);\n        List<Integer> servers = new LinkedList<Integer>();\n        servers.add(new Integer(server.getId().intValue()));\n        // Actual migration is tested internally, just make sure the API call doesn't\n        // error out:\n        handler.migrateSystems(adminKey, admin.getOrg().getId().intValue(),\n                newOrgAdmin.getOrg().getId().intValue(), servers); \n    }","id":42516,"modified_method":"public void testMigrateSystem() throws Exception {\n        User newOrgAdmin = UserTestUtils.findNewUser(\"newAdmin\", \"newOrg\", true);\n        newOrgAdmin.getOrg().getTrustedOrgs().add(admin.getOrg());\n        OrgFactory.save(newOrgAdmin.getOrg());\n\n        Server server = ServerTestUtils.createTestSystem(admin);\n        List<Integer> servers = new LinkedList<Integer>();\n        servers.add(new Integer(server.getId().intValue()));\n        // Actual migration is tested internally, just make sure the API call doesn't\n        // error out:\n        handler.migrateSystems(adminKey, newOrgAdmin.getOrg().getId().intValue(), servers); \n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public void testMigrateInvalid() throws Exception {\n        \n        User orgAdmin1 = UserTestUtils.findNewUser(\"orgAdmin1\", \"org1\", true);\n        orgAdmin1.getOrg().getTrustedOrgs().add(admin.getOrg());\n\n        User orgAdmin2 = UserTestUtils.findNewUser(\"orgAdmin2\", \"org2\", true);\n        String orgAdmin2Key = XmlRpcTestUtils.getSessionKey(orgAdmin2);\n\n        Server server = ServerTestUtils.createTestSystem(admin);\n        List<Integer> servers = new LinkedList<Integer>();\n        servers.add(new Integer(server.getId().intValue()));\n\n        // attempt migration where user is not a satellite admin and orginating\n        // org is not the same as the user's.\n        try {\n            handler.migrateSystems(orgAdmin2Key, admin.getOrg().getId().intValue(),\n                    orgAdmin1.getOrg().getId().intValue(), servers);\n            fail();\n        }\n        catch (PermissionCheckFailureException e) {\n            // expected\n        }\n        \n        // attempt to migrate systems from an org that does not exist\n        try {\n            handler.migrateSystems(adminKey, admin.getOrg().getId().intValue(),\n                    new Integer(-1), servers); \n            fail();\n        }\n        catch (NoSuchOrgException e) {\n            // expected\n        }\n        \n        // attempt to migrate systems to an org that does not exist\n        try {\n            handler.migrateSystems(adminKey, new Integer(-1),\n                    admin.getOrg().getId().intValue(), servers); \n            fail();\n        }\n        catch (NoSuchOrgException e) {\n            // expected\n        }\n        \n        // attempt to migrate systems from/to the same org\n        try {\n            handler.migrateSystems(adminKey, orgAdmin1.getOrg().getId().intValue(),\n                    orgAdmin1.getOrg().getId().intValue(), servers);\n            fail();\n        }\n        catch (MigrationToSameOrgException e) {\n            // expected\n        }   \n        \n        // attempt to migrate systems to an org that isn't defined in trust\n        try {\n            handler.migrateSystems(adminKey, orgAdmin1.getOrg().getId().intValue(),\n                    orgAdmin2.getOrg().getId().intValue(), servers);\n            fail();\n        }\n        catch (OrgNotInTrustException e) {\n            // expected\n        }   \n        \n        // attempt to migrate systems that do not exist\n        List<Integer> invalidServers = new LinkedList<Integer>();\n        invalidServers.add(new Integer(-1));\n        try {\n            handler.migrateSystems(adminKey, admin.getOrg().getId().intValue(),\n                    orgAdmin1.getOrg().getId().intValue(), invalidServers);\n            fail();\n        }\n        catch (NoSuchSystemException e) {\n            // expected\n        }\n    }","id":42517,"modified_method":"public void testMigrateInvalid() throws Exception {\n        \n        User orgAdmin1 = UserTestUtils.findNewUser(\"orgAdmin1\", \"org1\", true);\n        orgAdmin1.getOrg().getTrustedOrgs().add(admin.getOrg());\n\n        User orgAdmin2 = UserTestUtils.findNewUser(\"orgAdmin2\", \"org2\", true);\n        String orgAdmin2Key = XmlRpcTestUtils.getSessionKey(orgAdmin2);\n\n        Server server = ServerTestUtils.createTestSystem(admin);\n        List<Integer> servers = new LinkedList<Integer>();\n        servers.add(new Integer(server.getId().intValue()));\n\n        // attempt migration where user is not a satellite admin and orginating\n        // org is not the same as the user's.\n        try {\n            handler.migrateSystems(orgAdmin2Key, orgAdmin1.getOrg().getId().intValue(), \n                    servers);\n            fail();\n        }\n        catch (PermissionCheckFailureException e) {\n            // expected\n        }\n        \n        // attempt to migrate systems to an org that does not exist\n        try {\n            handler.migrateSystems(adminKey, new Integer(-1), servers); \n            fail();\n        }\n        catch (NoSuchOrgException e) {\n            // expected\n        }\n        \n        // attempt to migrate systems from/to the same org\n        try {\n            handler.migrateSystems(adminKey, admin.getOrg().getId().intValue(), servers);\n            fail();\n        }\n        catch (MigrationToSameOrgException e) {\n            // expected\n        }   \n        \n        // attempt to migrate systems to an org that isn't defined in trust\n        try {\n            handler.migrateSystems(adminKey, orgAdmin2.getOrg().getId().intValue(), \n                    servers);\n            fail();\n        }\n        catch (OrgNotInTrustException e) {\n            // expected\n        }   \n        \n        // attempt to migrate systems that do not exist\n        List<Integer> invalidServers = new LinkedList<Integer>();\n        invalidServers.add(new Integer(-1));\n        try {\n            handler.migrateSystems(adminKey, orgAdmin1.getOrg().getId().intValue(), \n                    invalidServers);\n            fail();\n        }\n        catch (NoSuchSystemException e) {\n            // expected\n        }\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor\n     * @param value The org id not defined in trust\n     * @param cause the cause\n     */\n    public OrgNotInTrustException(Integer value, Throwable cause) {\n        super(1065, \"Organization Not In Trust\" , LocalizationService.getInstance().\n                getMessage(\"api.org.notintrust\", new Object [] {value}), \n                cause);\n    }","id":42518,"modified_method":"/**\n     * Constructor\n     * @param value The org id not defined in trust.\n     * @param cause the cause\n     */\n    public OrgNotInTrustException(Integer value, Throwable cause) {\n        super(2854, \"Organization Not In Trust\" , LocalizationService.getInstance().\n                getMessage(\"api.org.notintrust\", new Object [] {value}), \n                cause);\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * Constructor\n     * @param value The org id not defined in trust\n     */\n    public OrgNotInTrustException(Integer value) {\n        super(1065, \"Organization Not In Trust\" , LocalizationService.getInstance().\n                getMessage(\"api.org.notintrust\", new Object [] {value}));\n    }","id":42519,"modified_method":"/**\n     * Constructor\n     * @param value The org id not defined in trust.\n     */\n    public OrgNotInTrustException(Integer value) {\n        super(2854, \"Organization Not In Trust\" , LocalizationService.getInstance().\n                getMessage(\"api.org.notintrust\", new Object [] {value}));\n    }","commit_id":"b9a1df560006f54f05c369b364e3271a46443c01","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"public boolean equals(Object o) {\n    if (!(o instanceof DefaultCellInfo)) return false;\n    DefaultCellInfo cellInfo = (DefaultCellInfo) o;\n    if (!EqualUtil.equals(cellInfo.myParentInfo, myParentInfo)) return false;\n    if (cellInfo.myNodePointer == null) return false;\n    boolean idsBothNull = false;\n    if (cellInfo.myCellId == null && myCellId == null) idsBothNull = true;\n    return (cellInfo.myCellId == null ? idsBothNull : cellInfo.myCellId.equals(myCellId))\n      && (cellInfo.myNodePointer.equals(myNodePointer))\n      && cellInfo.myCellNumber == myCellNumber;\n  }","id":42520,"modified_method":"public boolean equals(Object o) {\n    if (!(o instanceof DefaultCellInfo)) return false;\n    DefaultCellInfo cellInfo = (DefaultCellInfo) o;\n    if (!EqualUtil.equals(cellInfo.myParentInfo, myParentInfo)) return false;\n    if (cellInfo.myNodeReference == null) return false;\n    return (cellInfo.myCellId == null ?\n        myCellId == null :\n        cellInfo.myCellId.equals(myCellId)) && (cellInfo.myNodeReference.equals(myNodeReference)) && cellInfo.myCellNumber == myCellNumber;\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static DefaultCellInfo loadFrom(Element e) {\n    String cellId;\n    int cellNumber;\n    boolean isInList;\n    final String ref;\n    DefaultCellInfo parentInfo = null;\n    cellId = e.getAttributeValue(CELL_ID);\n    String num = e.getAttributeValue(CELL_NUMBER);\n    if (num == null) return null;\n    try {\n      cellNumber = Integer.parseInt(num);\n    } catch (NumberFormatException ex) {\n      return null;\n    }\n    isInList = \"true\".equals(e.getAttributeValue(IS_IN_LIST));\n    Element nodeElem = e.getChild(NODE);\n    if (nodeElem == null) return null;\n    ref = nodeElem.getAttributeValue(NODE_REF);\n    if (ref == null) return null;\n    Element parentElem = e.getChild(PARENT);\n    if (parentElem != null) {\n      parentInfo = loadFrom(parentElem);\n      if (parentInfo == null) return null;\n    }\n    final DefaultCellInfo result = new DefaultCellInfo();\n    result.myNodePointer = jetbrains.mps.smodel.SNodePointer.deserialize(ref);\n    result.myCellId = cellId;\n    result.myParentInfo = parentInfo;\n    result.myIsInList = isInList;\n    result.myCellNumber = cellNumber;\n    return result;\n  }","id":42521,"modified_method":"public static DefaultCellInfo loadFrom(Element e) {\n    String cellId;\n    int cellNumber;\n    boolean isInList;\n    final String nodeReference;\n    DefaultCellInfo parentInfo = null;\n    cellId = e.getAttributeValue(CELL_ID);\n    String num = e.getAttributeValue(CELL_NUMBER);\n    if (num == null) return null;\n    try {\n      cellNumber = Integer.parseInt(num);\n    } catch (NumberFormatException ex) {\n      return null;\n    }\n    isInList = \"true\".equals(e.getAttributeValue(IS_IN_LIST));\n    Element nodeElem = e.getChild(NODE);\n    if (nodeElem == null) return null;\n    nodeReference = nodeElem.getAttributeValue(NODE_REFERENCE);\n    if (nodeReference == null) return null;\n    Element parentElem = e.getChild(PARENT);\n    if (parentElem != null) {\n      parentInfo = loadFrom(parentElem);\n      if (parentInfo == null) return null;\n    }\n    final DefaultCellInfo result = new DefaultCellInfo();\n    result.myNodeReference = PersistenceFacade.getInstance().createNodeReference(nodeReference);\n    result.myCellId = cellId;\n    result.myParentInfo = parentInfo;\n    result.myIsInList = isInList;\n    result.myCellNumber = cellNumber;\n    return result;\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int hashCode() {\n    return (myParentInfo == null ? 0 : myParentInfo.hashCode()) +\n      (myNodePointer == null ? 0 : myNodePointer.hashCode()) + (myCellId == null ? 0 : myCellId.hashCode()) + myCellNumber;\n  }","id":42522,"modified_method":"public int hashCode() {\n    return (myParentInfo == null ? 0 : myParentInfo.hashCode()) +\n        (myNodeReference == null ? 0 : myNodeReference.hashCode()) + (myCellId == null ? 0 : myCellId.hashCode()) + myCellNumber;\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public DefaultCellInfo(final EditorCell cell) {\n    ModelAccess.instance().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        SNode n = cell.getSNode();\n        myNodePointer = (n == null || n.getModel() == null) ? null : new jetbrains.mps.smodel.SNodePointer(n);\n      }\n    });\n\n    myCellId = cell.getCellId();\n\n    EditorCell_Collection parent = (EditorCell_Collection) cell.getParent();\n    if (parent != null && myCellId == null) {\n      myParentInfo = parent.getCellInfo();\n      myIsInList = parent.hasCellListHandler();\n      if (myIsInList || myCellId == null) {\n        myCellNumber = parent.getCellNumber(cell);\n      }\n    }\n  }","id":42523,"modified_method":"public DefaultCellInfo(final EditorCell cell) {\n    ModelAccess.instance().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        SNode node = cell.getSNode();\n        myNodeReference = (node == null || node.getModel() == null) ? null : node.getReference();\n      }\n    });\n\n    myCellId = cell.getCellId();\n\n    EditorCell_Collection parent = (EditorCell_Collection) cell.getParent();\n    if (parent != null && myCellId == null) {\n      myParentInfo = parent.getCellInfo();\n      myIsInList = parent.hasCellListHandler();\n      if (myIsInList || myCellId == null) {\n        myCellNumber = parent.getCellNumber(cell);\n      }\n    }\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public EditorCell findCell(final EditorComponent editorComponent) {\n    if (myCellId != null) {\n      if (myNodePointer == null) return null;\n      return ModelAccess.instance().runReadAction(new Computable<EditorCell>() {\n        @Override\n        public EditorCell compute() {\n          // This is needed while merging: if node pointer points to node from current model,\n          // it should be used instead of model in model repository.\n          SNode node;\n          assert myNodePointer != null;\n          if (editorComponent.getEditedNode() != null &&\n            EqualUtil.equals(myNodePointer.getModelReference(),\n              editorComponent.getEditedNode().getModel().getReference())) {\n            node = editorComponent.getEditedNode().getModel().getNode(((SNodePointer) myNodePointer).getNodeId());\n          } else {\n            node = myNodePointer.resolve(MPSModuleRepository.getInstance());\n          }\n          return editorComponent.findCellWithId(node, myCellId);\n        }\n      });\n    } else if (myParentInfo != null) {\n      EditorCell_Collection parent = (EditorCell_Collection) myParentInfo.findCell(editorComponent);\n      if (parent == null) {\n        return null;\n      }\n      if (myCellNumber < parent.getChildCount()) {\n        EditorCell editorCell = parent.getChildAt(myCellNumber);\n        // Cell should have same cellId, and myCellId is null.\n        if (editorCell.getCellId() != null) {\n          return null;\n        }\n        return editorCell;\n      } else {\n        return null;\n      }\n\n    }\n    return null;\n  }","id":42524,"modified_method":"@Override\n  public EditorCell findCell(final EditorComponent editorComponent) {\n    if (myCellId != null) {\n      final EditorContext editorContext = editorComponent.getEditorContext();\n      if (myNodeReference == null || editorContext == null) return null;\n\n      final EditorCell[] cell = new EditorCell[]{null};\n      editorContext.getRepository().getModelAccess().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          cell[0] = editorComponent.findCellWithId(myNodeReference.resolve(editorContext.getRepository()), myCellId);\n        }\n      });\n      return cell[0];\n    } else if (myParentInfo != null) {\n      EditorCell parentCell = myParentInfo.findCell(editorComponent);\n      if (!(parentCell instanceof EditorCell_Collection)) {\n        return null;\n      }\n      EditorCell_Collection parentCollection = (EditorCell_Collection) parentCell;\n      if (myCellNumber >= parentCollection.getCellsCount()) {\n        return null;\n      }\n      EditorCell editorCell = parentCollection.getChildAt(myCellNumber);\n      // This editorCell should not have any cellId due to corresponding conditions in constructor\n      return editorCell.getCellId() == null ? editorCell : null;\n    }\n    return null;\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public String toString() {\n    return \"DefaultCellInfo[\" +\n      \"myNodePointer=\" + (myNodePointer == null ? null : myNodePointer.toString()) +\n      \", myCellId='\" + myCellId + '\\'' +\n      \", myCellNumber=\" + myCellNumber +\n      \", myIsInList=\" + myIsInList +\n      \", myParentInfo=\" + myParentInfo +\n      ']';\n  }","id":42525,"modified_method":"@Override\n  public String toString() {\n    return \"DefaultCellInfo[\" +\n        \"myNodePointer=\" + (myNodeReference == null ? null : myNodeReference.toString()) +\n        \", myCellId='\" + myCellId + '\\'' +\n        \", myCellNumber=\" + myCellNumber +\n        \", myIsInList=\" + myIsInList +\n        \", myParentInfo=\" + myParentInfo +\n        ']';\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void saveTo(Element e) {\n    if (myCellId != null) {\n      e.setAttribute(CELL_ID, myCellId);\n    }\n    e.setAttribute(CELL_NUMBER, \"\" + myCellNumber);\n    e.setAttribute(IS_IN_LIST, \"\" + myIsInList);\n    Element nodeElement = new Element(NODE);\n    assert myNodePointer != null;\n    nodeElement.setAttribute(NODE_REF, jetbrains.mps.smodel.SNodePointer.serialize(myNodePointer));\n    e.addContent(nodeElement);\n    if (myParentInfo instanceof DefaultCellInfo) {\n      Element parentElement = new Element(PARENT);\n      ((DefaultCellInfo) myParentInfo).saveTo(parentElement);\n      e.addContent(parentElement);\n    }\n  }","id":42526,"modified_method":"public void saveTo(Element e) {\n    if (myCellId != null) {\n      e.setAttribute(CELL_ID, myCellId);\n    }\n    e.setAttribute(CELL_NUMBER, \"\" + myCellNumber);\n    e.setAttribute(IS_IN_LIST, \"\" + myIsInList);\n    Element nodeElement = new Element(NODE);\n    assert myNodeReference != null;\n    nodeElement.setAttribute(NODE_REFERENCE, myNodeReference.toString());\n    e.addContent(nodeElement);\n    if (myParentInfo instanceof DefaultCellInfo) {\n      Element parentElement = new Element(PARENT);\n      ((DefaultCellInfo) myParentInfo).saveTo(parentElement);\n      e.addContent(parentElement);\n    }\n  }","commit_id":"6f97a0a8b1f2773eb357a6c4a1e8a4a50d836ac0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell findCell(EditorComponent editorComponent) {\n    if (myNodePointer == null) {\n      return null;\n    }\n    if (myCellId != null) {\n      return editorComponent.findCellWithId(myNodePointer.getNode(), myCellId);\n    } else if (myParentInfo != null) {\n      EditorCell parent = myParentInfo.findCell(editorComponent);\n      return ((EditorCell_Collection)parent).getChildAt(myCellNumber);\n    }\n    return null;\n  }","id":42527,"modified_method":"public EditorCell findCell(EditorComponent editorComponent) {\n    if (myNodePointer == null) {\n      return null;\n    }\n    if (myCellId != null) {\n      return editorComponent.findCellWithId(myNodePointer.getNode(), myCellId);\n    } else if (myParentInfo != null) {\n      EditorCell_Collection parent = (EditorCell_Collection) myParentInfo.findCell(editorComponent);\n      if (myCellNumber < parent.getChildCount()) {\n        return parent.getChildAt(myCellNumber);\n      } else {\n        return null;\n      }\n\n    }\n    return null;\n  }","commit_id":"7b8935008b158588ea8b45de3caf21ce712da4b6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean restoreErrors(EditorComponent editor) {\n    boolean needsRelayout = false;\n    for (EditorCell cell : new ArrayList<EditorCell>(editor.getCellTracker().getErrorCells())) {\n      if (cell instanceof EditorCell_Label && cell.getStyle().get(StyleAttributes.EDITABLE)) {\n        EditorCell_Label label = (EditorCell_Label) cell;\n        label.synchronizeViewWithModel();\n        needsRelayout = true;\n      }\n    }\n\n    for (Entry<CellInfo, String> entry : myErrorTexts.entrySet()) {\n      EditorCell_Label cell = (EditorCell_Label) entry.getKey().findCell(editor);\n      if (cell != null) {\n        String text = cell.getText();\n        String oldText = entry.getValue();\n        if (!EqualUtil.equals(text, oldText) && (!cell.isValidText(oldText) || !cell.isEditable())) {\n          cell.changeText(oldText);\n          needsRelayout = true;\n        }\n      }\n    }\n    return needsRelayout;\n  }","id":42528,"modified_method":"private boolean restoreErrors(EditorComponent editor) {\n    boolean needsRelayout = false;\n    for (EditorCell cell : new ArrayList<EditorCell>(editor.getCellTracker().getErrorCells())) {\n      if (cell instanceof EditorCell_Label && cell.getStyle().get(StyleAttributes.EDITABLE)) {\n        EditorCell_Label label = (EditorCell_Label) cell;\n        label.synchronizeViewWithModel();\n        needsRelayout = true;\n      }\n    }\n\n    for (Entry<CellInfo, String> entry : myErrorTexts.entrySet()) {\n      EditorCell cell = entry.getKey().findCell(editor);\n      if (cell instanceof EditorCell_Label) {\n        EditorCell_Label cellLabel = (EditorCell_Label) cell;\n        String text = cellLabel.getText();\n        String oldText = entry.getValue();\n        if (!EqualUtil.equals(text, oldText) && (!cellLabel.isValidText(oldText) || !cellLabel.isEditable())) {\n          cellLabel.changeText(oldText);\n          needsRelayout = true;\n        }\n      }\n    }\n    return needsRelayout;\n  }","commit_id":"d170e8f22dd99e2bdb5189f445371da2d7c8af9e","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void reloadRepositories(ActionRequest req) throws Exception {\n\t\tRepositoryReport report = PluginUtil.reloadRepositories();\n\t\treq.getPortletSession().setAttribute(\n\t\t\t\tWebKeys.PLUGIN_REPOSITORY_REPORT, report);\n\t}","id":42529,"modified_method":"protected void reloadRepositories(ActionRequest req) throws Exception {\n\t\tPortletSession ses = req.getPortletSession();\n\n\t\tRepositoryReport report = PluginUtil.reloadRepositories();\n\n\t\treq.setAttribute(WebKeys.PLUGIN_REPOSITORY_REPORT, report);\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void hotDeploy(ActionRequest req) throws Exception {\n\t\tUploadPortletRequest uploadReq =\n\t\t\tPortalUtil.getUploadPortletRequest(req);\n\t\tString recommendedWARName =\n\t\t\t\tParamUtil.getString(req, \"recommendedWARName\");\n\n\t\tFile file = uploadReq.getFile(\"file\");\n\t\tString fileName = recommendedWARName;\n\t\tif (Validator.isNull(fileName)) {\n\t\t\tfileName = uploadReq.getFileName(\"file\");\n\t\t}\n\n\t\tbyte[] bytes = FileUtil.getBytes(file);\n\n\t\tif ((bytes != null) && (bytes.length > 0)) {\n\t\t\tString source = file.toString();\n\t\t\tString destination =\n\t\t\t\tPrefsPropsUtil.getString(PropsUtil.AUTO_DEPLOY_DEPLOY_DIR) +\n\t\t\t\t\tStringPool.SLASH + fileName;\n\n\t\t\tFileUtil.copyFile(source, destination);\n\t\t\tSessionMessages.add(req, \"pluginUploaded\");\n\t\t}\n\t\telse {\n\t\t\tSessionErrors.add(req, UploadException.class.getName());\n\t\t}\n\t}","id":42530,"modified_method":"protected void localDeploy(ActionRequest req) throws Exception {\n\t\tUploadPortletRequest uploadReq =\n\t\t\tPortalUtil.getUploadPortletRequest(req);\n\n\t\tString recommendedWARName = ParamUtil.getString(\n\t\t\treq, \"localDeployWARName\");\n\n\t\tFile file = uploadReq.getFile(\"file\");\n\n\t\tString fileName = recommendedWARName;\n\n\t\tif (Validator.isNull(fileName)) {\n\t\t\tfileName = uploadReq.getFileName(\"file\");\n\t\t}\n\n\t\tbyte[] bytes = FileUtil.getBytes(file);\n\n\t\tif ((bytes != null) && (bytes.length > 0)) {\n\t\t\tString source = file.toString();\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\tPropsUtil.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\t\tString destination = deployDir + StringPool.SLASH + fileName;\n\n\t\t\tFileUtil.copyFile(source, destination);\n\n\t\t\tSessionMessages.add(req, \"pluginUploaded\");\n\t\t}\n\t\telse {\n\t\t\tSessionErrors.add(req, UploadException.class.getName());\n\t\t}\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tif (!OmniadminUtil.isOmniadmin(req.getRemoteUser())) {\n\t\t\tSessionErrors.add(req, PrincipalException.class.getName());\n\n\t\t\tsetForward(req, \"portlet.admin.error\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (cmd.equals(\"autoDeploy\")) {\n\t\t\tautoDeploy(req);\n\t\t}\n\t\telse if (cmd.equals(\"cacheDb\")) {\n\t\t\tcacheDb();\n\t\t}\n\t\telse if (cmd.equals(\"cacheMulti\")) {\n\t\t\tcacheMulti();\n\t\t}\n\t\telse if (cmd.equals(\"cacheSingle\")) {\n\t\t\tcacheSingle();\n\t\t}\n\t\telse if (cmd.equals(\"gc\")) {\n\t\t\tgc();\n\t\t}\n\t\telse if (cmd.equals(\"hotDeploy\")) {\n\t\t\thotDeploy(req);\n\t\t}\n\t\telse if (cmd.equals(\"precompile\")) {\n\t\t\tprecompile(req, res);\n\t\t}\n\t\telse if (cmd.equals(\"reloadRepositories\")) {\n\t\t\treloadRepositories(req);\n\t\t}\n\t\telse if (cmd.equals(\"remoteDeploy\")) {\n\t\t\tremoteDeploy(req);\n\t\t}\n\t\telse if (cmd.equals(\"shutdown\")) {\n\t\t\tshutdown(req);\n\t\t}\n\t\telse if (cmd.equals(\"updateLogLevels\")) {\n\t\t\tupdateLogLevels(req);\n\t\t}\n\n\t\tsendRedirect(req, res);\n\t}","id":42531,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tif (!OmniadminUtil.isOmniadmin(req.getRemoteUser())) {\n\t\t\tSessionErrors.add(req, PrincipalException.class.getName());\n\n\t\t\tsetForward(req, \"portlet.admin.error\");\n\n\t\t\treturn;\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (cmd.equals(\"cacheDb\")) {\n\t\t\tcacheDb();\n\t\t}\n\t\telse if (cmd.equals(\"cacheMulti\")) {\n\t\t\tcacheMulti();\n\t\t}\n\t\telse if (cmd.equals(\"cacheSingle\")) {\n\t\t\tcacheSingle();\n\t\t}\n\t\telse if (cmd.equals(\"deployConfiguration\")) {\n\t\t\tdeployConfiguration(req);\n\t\t}\n\t\telse if (cmd.equals(\"gc\")) {\n\t\t\tgc();\n\t\t}\n\t\telse if (cmd.equals(\"localDeploy\")) {\n\t\t\tlocalDeploy(req);\n\t\t}\n\t\telse if (cmd.equals(\"precompile\")) {\n\t\t\tprecompile(req, res);\n\t\t}\n\t\telse if (cmd.equals(\"reloadRepositories\")) {\n\t\t\treloadRepositories(req);\n\t\t}\n\t\telse if (cmd.equals(\"remoteDeploy\")) {\n\t\t\tremoteDeploy(req);\n\t\t}\n\t\telse if (cmd.equals(\"shutdown\")) {\n\t\t\tshutdown(req);\n\t\t}\n\t\telse if (cmd.equals(\"updateLogLevels\")) {\n\t\t\tupdateLogLevels(req);\n\t\t}\n\n\t\tsendRedirect(req, res);\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void remoteDeploy(ActionRequest req) throws Exception {\n\n\t\tString url = ParamUtil.getString(req, \"url\");\n\t\tString recommendedWARName =\n\t\t\t\tParamUtil.getString(req, \"recommendedWARName\");\n\t\tString progressId = ParamUtil.getString(req, Constants.PROGRESS_ID);\n\n\t\tURL urlObj = new URL(url);\n\t\tGetMethod getFileMethod = new GetMethod(urlObj.toString());\n\n\t\ttry {\n\t\t\tint responseCode = _client.executeMethod(getFileMethod);\n\t\t\tif (responseCode != 200) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\treq, \"errorResponseFromServer\",\n\t\t\t\t\t\tnew Object[]{Integer.toString(responseCode)});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong contentLength = getFileMethod.getResponseContentLength();\n\n\t\t\tString fileName = url.substring(\n\t\t\t\t\turl.lastIndexOf(StringPool.SLASH) + 1);\n\n\t\t\tString destFileName = _getDestFileName(\n\t\t\t\t\trecommendedWARName, url, fileName);\n\n\t\t\tProgressInputStream pis = new ProgressInputStream(\n\t\t\t\t\treq, getFileMethod.getResponseBodyAsStream(),\n\t\t\t\t\tcontentLength, progressId);\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\t\tPropsUtil.AUTO_DEPLOY_DEPLOY_DIR);\n\t\t\tString tmpFilePath = deployDir + StringPool.SLASH + _DOWNLOAD_DIR +\n\t\t\t\t\tStringPool.SLASH + destFileName;\n\t\t\tFile tmpFile = new File(tmpFilePath);\n\t\t\tif (!tmpFile.getParentFile().exists()) {\n\t\t\t\ttmpFile.getParentFile().mkdirs();\n\t\t\t}\n\n\t\t\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\t\t\ttry {\n\t\t\t\tpis.readAll(fos);\n\t\t\t\t_log.info(\"Downloaded plugin from \" + urlObj + \" (\" +\n\t\t\t\t\t\tpis.getTotalRead() + \" bytes)\");\n\t\t\t} finally {\n\t\t\t\tpis.clearProgress();\n\t\t\t}\n\n\t\t\tgetFileMethod.releaseConnection();\n\n\t\t\tif (pis.getTotalRead() > 0) {\n\t\t\t\tString destination = PrefsPropsUtil.getString(\n\t\t\t\t\t\tPropsUtil.AUTO_DEPLOY_DEPLOY_DIR) + StringPool.SLASH +\n\t\t\t\t\t\tdestFileName;\n\n\t\t\t\tFile destinationFile = new File(destination);\n\t\t\t\tboolean moved = FileUtil.move(tmpFile, destinationFile);\n\n\t\t\t\tif (!moved) {\n\t\t\t\t\tFileUtil.copyFile(tmpFile, destinationFile);\n\t\t\t\t\tFileUtil.delete(tmpFile);\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(req, \"pluginDownloaded\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSessionErrors.add(req, UploadException.class.getName());\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException mue) {\n\t\t\tgetFileMethod.releaseConnection();\n\t\t\tSessionErrors.add(req, \"invalidUrl\", url); // Inform user of bad URL\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tgetFileMethod.releaseConnection();\n\t\t\tSessionErrors.add(req, \"errorConnectingToServer\", ioe);\n\t\t}\n\n}","id":42532,"modified_method":"protected void remoteDeploy(ActionRequest req) throws Exception {\n\t\tGetMethod getFileMethod = null;\n\n\t\ttry {\n\t\t\tString url = ParamUtil.getString(req, \"url\");\n\n\t\t\tURL urlObj = new URL(url);\n\n\t\t\tString recommendedWARName = ParamUtil.getString(\n\t\t\t\treq, \"remoteDeployWARName\");\n\n\t\t\tString progressId = ParamUtil.getString(req, Constants.PROGRESS_ID);\n\n\t\t\tHttpClient client = new HttpClient();\n\n\t\t\tint timeout = GetterUtil.getInteger(\n\t\t\t\tPropsUtil.get(PropsUtil.PLUGIN_TIMEOUT_ARTIFACT));\n\n\t\t\tclient.getHttpConnectionManager().getParams().setConnectionTimeout(\n\t\t\t\ttimeout);\n\n\t\t\tgetFileMethod = new GetMethod(urlObj.toString());\n\n\t\t\tint responseCode = client.executeMethod(getFileMethod);\n\n\t\t\tif (responseCode != 200) {\n\t\t\t\tSessionErrors.add(\n\t\t\t\t\treq, \"errorResponseFromServer\",\n\t\t\t\t\tnew Object[] {String.valueOf(responseCode)});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlong contentLength = getFileMethod.getResponseContentLength();\n\n\t\t\tString fileName = url.substring(\n\t\t\t\turl.lastIndexOf(StringPool.SLASH) + 1);\n\n\t\t\tString destFileName = _getDestFileName(\n\t\t\t\trecommendedWARName, url, fileName);\n\n\t\t\tProgressInputStream pis = new ProgressInputStream(\n\t\t\t\treq, getFileMethod.getResponseBodyAsStream(), contentLength,\n\t\t\t\tprogressId);\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\tPropsUtil.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\t\tString tmpFilePath =\n\t\t\t\tdeployDir + StringPool.SLASH + _DOWNLOAD_DIR +\n\t\t\t\t\tStringPool.SLASH + destFileName;\n\n\t\t\tFile tmpFile = new File(tmpFilePath);\n\n\t\t\tif (!tmpFile.getParentFile().exists()) {\n\t\t\t\ttmpFile.getParentFile().mkdirs();\n\t\t\t}\n\n\t\t\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\n\t\t\ttry {\n\t\t\t\tpis.readAll(fos);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Downloaded plugin from \" + urlObj + \" has \" +\n\t\t\t\t\t\t\tpis.getTotalRead() + \" bytes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tpis.clearProgress();\n\t\t\t}\n\n\t\t\tgetFileMethod.releaseConnection();\n\n\t\t\tif (pis.getTotalRead() > 0) {\n\t\t\t\tString destination =\n\t\t\t\t\tdeployDir + StringPool.SLASH + destFileName;\n\n\t\t\t\tFile destinationFile = new File(destination);\n\n\t\t\t\tboolean moved = FileUtil.move(tmpFile, destinationFile);\n\n\t\t\t\tif (!moved) {\n\t\t\t\t\tFileUtil.copyFile(tmpFile, destinationFile);\n\t\t\t\t\tFileUtil.delete(tmpFile);\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(req, \"pluginDownloaded\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSessionErrors.add(req, UploadException.class.getName());\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException murle) {\n\t\t\tif (getFileMethod != null) {\n\t\t\t\tgetFileMethod.releaseConnection();\n\t\t\t}\n\n\t\t\tSessionErrors.add(req, \"invalidUrl\", murle);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (getFileMethod != null) {\n\t\t\t\tgetFileMethod.releaseConnection();\n\t\t\t}\n\n\t\t\tSessionErrors.add(req, \"errorConnectingToServer\", ioe);\n\t\t}\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void autoDeploy(ActionRequest req) throws Exception {\n\t\tboolean enabled = ParamUtil.getBoolean(req, \"enabled\");\n\t\tString deployDir = ParamUtil.getString(req, \"deployDir\");\n\t\tString destDir = ParamUtil.getString(req, \"destDir\");\n\t\tlong interval = ParamUtil.getLong(req, \"interval\");\n\t\tboolean unpackWar = ParamUtil.getBoolean(req, \"unpackWar\");\n\t\tString tomcatLibDir = ParamUtil.getString(req, \"tomcatLibDir\");\n\t\tString pluginRepositories =\n\t\t\t\tParamUtil.getString(req, \"pluginRepositories\");\n\n\t\tPortletPreferences prefs = PrefsPropsUtil.getPreferences();\n\n\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_ENABLED, String.valueOf(enabled));\n\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_DEPLOY_DIR, deployDir);\n\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_DEST_DIR, destDir);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTO_DEPLOY_INTERVAL, String.valueOf(interval));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTO_DEPLOY_UNPACK_WAR, String.valueOf(unpackWar));\n\n\t\tif (Validator.isNotNull(tomcatLibDir)) {\n\t\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_TOMCAT_LIB_DIR, tomcatLibDir);\n\t\t}\n\n\t\tString oldPluginRepositories =\n\t\t\t\tPrefsPropsUtil.getString(PropsUtil.AUTO_DEPLOY_DEPLOY_DIR);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.PLUGIN_REPOSITORIES, pluginRepositories);\n\n\t\tprefs.store();\n\n\t\tif (!pluginRepositories.equals(oldPluginRepositories)) {\n\t\t\treloadRepositories(req);\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Unregistering auto deploy directories\");\n\t\t}\n\n\t\tAutoDeployUtil.unregisterDir(\"defaultAutoDeployDir\");\n\n\t\tif (enabled) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Registering auto deploy directories\");\n\t\t\t}\n\n\t\t\tList autoDeployListeners = new ArrayList();\n\n\t\t\tautoDeployListeners.add(new AutoDeployLayoutTemplateListener());\n\t\t\tautoDeployListeners.add(new AutoDeployPortletListener());\n\t\t\tautoDeployListeners.add(new AutoDeployThemeListener());\n\n\t\t\tAutoDeployDir autoDeployDir = new AutoDeployDir(\n\t\t\t\t\"defaultAutoDeployDir\", new File(deployDir), new File(destDir),\n\t\t\t\tinterval, autoDeployListeners);\n\n\t\t\tAutoDeployUtil.registerDir(autoDeployDir);\n\t\t}\n\t\telse {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Not registering auto deploy directories\");\n\t\t\t}\n\t\t}\n\t}","id":42533,"modified_method":"protected void deployConfiguration(ActionRequest req) throws Exception {\n\t\tboolean enabled = ParamUtil.getBoolean(req, \"enabled\");\n\t\tString deployDir = ParamUtil.getString(req, \"deployDir\");\n\t\tString destDir = ParamUtil.getString(req, \"destDir\");\n\t\tlong interval = ParamUtil.getLong(req, \"interval\");\n\t\tboolean unpackWar = ParamUtil.getBoolean(req, \"unpackWar\");\n\t\tString tomcatLibDir = ParamUtil.getString(req, \"tomcatLibDir\");\n\t\tString pluginRepositories = ParamUtil.getString(\n\t\t\treq, \"pluginRepositories\");\n\n\t\tPortletPreferences prefs = PrefsPropsUtil.getPreferences();\n\n\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_ENABLED, String.valueOf(enabled));\n\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_DEPLOY_DIR, deployDir);\n\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_DEST_DIR, destDir);\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTO_DEPLOY_INTERVAL, String.valueOf(interval));\n\t\tprefs.setValue(\n\t\t\tPropsUtil.AUTO_DEPLOY_UNPACK_WAR, String.valueOf(unpackWar));\n\n\t\tif (Validator.isNotNull(tomcatLibDir)) {\n\t\t\tprefs.setValue(PropsUtil.AUTO_DEPLOY_TOMCAT_LIB_DIR, tomcatLibDir);\n\t\t}\n\n\t\tString oldPluginRepositories = PrefsPropsUtil.getString(\n\t\t\tPropsUtil.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\tprefs.setValue(PropsUtil.PLUGIN_REPOSITORIES, pluginRepositories);\n\n\t\tprefs.store();\n\n\t\tif (!pluginRepositories.equals(oldPluginRepositories)) {\n\t\t\treloadRepositories(req);\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Unregistering auto deploy directories\");\n\t\t}\n\n\t\tAutoDeployUtil.unregisterDir(\"defaultAutoDeployDir\");\n\n\t\tif (enabled) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Registering auto deploy directories\");\n\t\t\t}\n\n\t\t\tList autoDeployListeners = new ArrayList();\n\n\t\t\tautoDeployListeners.add(new AutoDeployLayoutTemplateListener());\n\t\t\tautoDeployListeners.add(new AutoDeployPortletListener());\n\t\t\tautoDeployListeners.add(new AutoDeployThemeListener());\n\n\t\t\tAutoDeployDir autoDeployDir = new AutoDeployDir(\n\t\t\t\t\"defaultAutoDeployDir\", new File(deployDir), new File(destDir),\n\t\t\t\tinterval, autoDeployListeners);\n\n\t\t\tAutoDeployUtil.registerDir(autoDeployDir);\n\t\t}\n\t\telse {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Not registering auto deploy directories\");\n\t\t\t}\n\t\t}\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List search(String type, String tags, String repositoryURL)\n\t\tthrows PluginException {\n\n\t\tSortedMap plugins = new TreeMap();\n\n\t\tString[] repositoryURLs = null;\n\n\t\tif (Validator.isNull(repositoryURL)) {\n\t\t\trepositoryURLs = getRepositoryURLs();\n\t\t}\n\t\telse {\n\t\t\trepositoryURLs = new String[] {repositoryURL};\n\t\t}\n\n\t\tfor (int i = 0; i < repositoryURLs.length; i++) {\n\t\t\ttry {\n\t\t\t\tPluginRepository repository = getRepository(repositoryURLs[i]);\n\n\t\t\t\tCollection repoPlugins = repository.search(type, tags);\n\n\t\t\t\tIterator itr = repoPlugins.iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tPlugin plugin = (Plugin)itr.next();\n\n\t\t\t\t\t// If the plugin was in another repository keep the\n\t\t\t\t\t// latest version\n\n\t\t\t\t\tPlugin previous = (Plugin)plugins.get(plugin);\n\n\t\t\t\t\tif ((previous != null) &&\n\t\t\t\t\t\tplugin.isLaterVersionThan(previous)) {\n\n\t\t\t\t\t\tplugins.remove(previous);\n\t\t\t\t\t}\n\n\t\t\t\t\tplugins.put(plugin, plugin);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(PluginException pe) {\n\t\t\t\t_log.info(\"Error loading repository \" + repositoryURL, pe);\n\t\t\t}\n\t\t}\n\n\t\treturn new ArrayList(plugins.keySet());\n\t}","id":42534,"modified_method":"public static List search(String type, String tags, String repositoryURL)\n\t\tthrows PluginException {\n\n\t\tSortedMap plugins = new TreeMap();\n\n\t\tString[] repositoryURLs = null;\n\n\t\tif (Validator.isNull(repositoryURL)) {\n\t\t\trepositoryURLs = getRepositoryURLs();\n\t\t}\n\t\telse {\n\t\t\trepositoryURLs = new String[] {repositoryURL};\n\t\t}\n\n\t\tfor (int i = 0; i < repositoryURLs.length; i++) {\n\t\t\ttry {\n\t\t\t\tPluginRepository repository = getRepository(repositoryURLs[i]);\n\n\t\t\t\tCollection repoPlugins = repository.search(type, tags);\n\n\t\t\t\tIterator itr = repoPlugins.iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tPlugin plugin = (Plugin)itr.next();\n\n\t\t\t\t\t// If the plugin was in another repository keep the\n\t\t\t\t\t// latest version\n\n\t\t\t\t\tPlugin previous = (Plugin)plugins.get(plugin);\n\n\t\t\t\t\tif ((previous != null) &&\n\t\t\t\t\t\tplugin.isLaterVersionThan(previous)) {\n\n\t\t\t\t\t\tplugins.remove(previous);\n\t\t\t\t\t}\n\n\t\t\t\t\tplugins.put(plugin, plugin);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(PluginException pe) {\n\t\t\t\t_log.error(\"Unable to load repository \" + repositoryURL, pe);\n\t\t\t}\n\t\t}\n\n\t\treturn new ArrayList(plugins.keySet());\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static PluginRepository _loadRepository(String repositoryURL)\n\t\tthrows PluginException {\n\n\t\tPluginRepository repository = null;\n\n\t\tString pluginsXmlURL =\n\t\t\trepositoryURL + StringPool.SLASH + _PLUGINS_XML_FILENAME;\n\n\t\ttry {\n\t\t\tHttpClient client = new HttpClient();\n\n\t\t\tint timeout = GetterUtil.getInteger(\n\t\t\t\tPropsUtil.get(PropsUtil.PLUGIN_TIMEOUT_LIST));\n\n\t\t\tclient.getHttpConnectionManager().getParams().setConnectionTimeout(\n\t\t\t\ttimeout);\n\n\t\t\tGetMethod getFile = new GetMethod(pluginsXmlURL);\n\n\t\t\tint responseCode = client.executeMethod(getFile);\n\n\t\t\tif (responseCode != 200) {\n\t\t\t\tthrow new PluginException(\n\t\t\t\t\t\"Cannot download file \" + pluginsXmlURL +\n\t\t\t\t\t\t\" because of response code \" + responseCode);\n\t\t\t}\n\n\t\t\tbyte[] bytes = getFile.getResponseBody();\n\n\t\t\tgetFile.releaseConnection();\n\n\t\t\tif ((bytes != null) && (bytes.length > 0)) {\n\t\t\t\trepository = _parsePluginsXml(new String(bytes), repositoryURL);\n\n\t\t\t\t_repositoryCache.put(repositoryURL, repository);\n\t\t\t\t_availableTagsCache.addAll(repository.getTags());\n\t\t\t\t_lastUpdateDate = new Date();\n\n\t\t\t\treturn repository;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_lastUpdateDate = new Date();\n\n\t\t\t\tthrow new PluginException(\"Download returned 0 bytes\");\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException mue) {\n\t\t\t_repositoryCache.remove(repositoryURL);\n\n\t\t\tthrow new PluginException(\"Invalid URL \" + pluginsXmlURL, mue);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_repositoryCache.remove(repositoryURL);\n\n\t\t\tthrow new PluginException(\n\t\t\t\t\"Error communicating with repository \" + repositoryURL, ioe);\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\t_repositoryCache.remove(repositoryURL);\n\n\t\t\tthrow new PluginException(\n\t\t\t\t\"Error parsing plugin list for repository \" + repositoryURL,\n\t\t\t\tde);\n\t\t}\n\t}","id":42535,"modified_method":"private static PluginRepository _loadRepository(String repositoryURL)\n\t\tthrows PluginException {\n\n\t\tPluginRepository repository = null;\n\n\t\tString pluginsXmlURL =\n\t\t\trepositoryURL + StringPool.SLASH + _PLUGINS_XML_FILENAME;\n\n\t\ttry {\n\t\t\tHttpClient client = new HttpClient();\n\n\t\t\tint timeout = GetterUtil.getInteger(\n\t\t\t\tPropsUtil.get(PropsUtil.PLUGIN_TIMEOUT_LIST));\n\n\t\t\tclient.getHttpConnectionManager().getParams().setConnectionTimeout(\n\t\t\t\ttimeout);\n\n\t\t\tGetMethod getFile = new GetMethod(pluginsXmlURL);\n\n\t\t\tint responseCode = client.executeMethod(getFile);\n\n\t\t\tif (responseCode != 200) {\n\t\t\t\tthrow new PluginException(\n\t\t\t\t\t\"Unable to download file \" + pluginsXmlURL +\n\t\t\t\t\t\t\" because of response code \" + responseCode);\n\t\t\t}\n\n\t\t\tbyte[] bytes = getFile.getResponseBody();\n\n\t\t\tgetFile.releaseConnection();\n\n\t\t\tif ((bytes != null) && (bytes.length > 0)) {\n\t\t\t\trepository = _parsePluginsXml(new String(bytes), repositoryURL);\n\n\t\t\t\t_repositoryCache.put(repositoryURL, repository);\n\t\t\t\t_availableTagsCache.addAll(repository.getTags());\n\t\t\t\t_lastUpdateDate = new Date();\n\n\t\t\t\treturn repository;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_lastUpdateDate = new Date();\n\n\t\t\t\tthrow new PluginException(\"Download returned 0 bytes\");\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException mue) {\n\t\t\t_repositoryCache.remove(repositoryURL);\n\n\t\t\tthrow new PluginException(\"Invalid URL \" + pluginsXmlURL, mue);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_repositoryCache.remove(repositoryURL);\n\n\t\t\tthrow new PluginException(\n\t\t\t\t\"Unable to communicate with repository \" + repositoryURL, ioe);\n\t\t}\n\t\tcatch (DocumentException de) {\n\t\t\t_repositoryCache.remove(repositoryURL);\n\n\t\t\tthrow new PluginException(\n\t\t\t\t\"Unable to parse plugin list for repository \" + repositoryURL,\n\t\t\t\tde);\n\t\t}\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static RepositoryReport reloadRepositories() throws PluginException {\n\t\tRepositoryReport report = new RepositoryReport();\n\n\t\tString[] repositoryURLs = getRepositoryURLs();\n\n\t\tfor (int i = 0; i < repositoryURLs.length; i++) {\n\t\t\tString repositoryURL = repositoryURLs[i];\n\n\t\t\ttry {\n\t\t\t\t_loadRepository(repositoryURL);\n\n\t\t\t\treport.addSuccess(repositoryURL);\n\t\t\t}\n\t\t\tcatch(PluginException pe) {\n\t\t\t\treport.addError(repositoryURL, pe);\n\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Error loading repository \" + repositoryURL + \" \" +\n\t\t\t\t\t\tpe.toString());\n\t\t\t}\n\t\t}\n\t\treturn report;\n\t}","id":42536,"modified_method":"public static RepositoryReport reloadRepositories() throws PluginException {\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reloading repositories\");\n\t\t}\n\n\t\tRepositoryReport report = new RepositoryReport();\n\n\t\tString[] repositoryURLs = getRepositoryURLs();\n\n\t\tfor (int i = 0; i < repositoryURLs.length; i++) {\n\t\t\tString repositoryURL = repositoryURLs[i];\n\n\t\t\ttry {\n\t\t\t\t_loadRepository(repositoryURL);\n\n\t\t\t\treport.addSuccess(repositoryURL);\n\t\t\t}\n\t\t\tcatch(PluginException pe) {\n\t\t\t\treport.addError(repositoryURL, pe);\n\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Unable to load repository \" + repositoryURL + \" \" +\n\t\t\t\t\t\tpe.toString());\n\t\t\t}\n\t\t}\n\t\treturn report;\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String[] getRepositoryURLs() throws PluginException {\n\t\ttry {\n\t\t\treturn PrefsPropsUtil.getStringArray(PropsUtil.PLUGIN_REPOSITORIES);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PluginException(\"Could not read repository list\", e);\n\t\t}\n\t}","id":42537,"modified_method":"public static String[] getRepositoryURLs() throws PluginException {\n\t\ttry {\n\t\t\treturn PrefsPropsUtil.getStringArray(PropsUtil.PLUGIN_REPOSITORIES);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new PluginException(\"Unable to read repository list\", e);\n\t\t}\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Plugin getPluginByURL(String url) throws PluginException {\n\t\tString[] repositoryURLs = getRepositoryURLs();\n\n\t\tfor (int i = 0; i < repositoryURLs.length; i++) {\n\t\t\tString repositoryURL = repositoryURLs[i];\n\n\t\t\ttry {\n\t\t\t\tPluginRepository repository =  getRepository(repositoryURL);\n\n\t\t\t\treturn repository.findPluginByArtifactURL(url);\n\t\t\t}\n\t\t\tcatch (PluginException pe) {\n\t\t\t\t_log.info(\"Error loading repository \" + repositoryURL, pe);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":42538,"modified_method":"public static Plugin getPluginByURL(String url) throws PluginException {\n\t\tString[] repositoryURLs = getRepositoryURLs();\n\n\t\tfor (int i = 0; i < repositoryURLs.length; i++) {\n\t\t\tString repositoryURL = repositoryURLs[i];\n\n\t\t\ttry {\n\t\t\t\tPluginRepository repository =  getRepository(repositoryURL);\n\n\t\t\t\treturn repository.findPluginByArtifactURL(url);\n\t\t\t}\n\t\t\tcatch (PluginException pe) {\n\t\t\t\t_log.error(\"Unable to load repository \" + repositoryURL, pe);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"6d2edb51d0b1a47c36f569d507ebd57dbca842f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object onCall(UMOEventContext eventContext) throws Exception {\n\n        UMOMessage requestMessage = eventContext.getMessage();;\n\n        UMOMessage responseMessage = requestMessage;\n        UMOEventContext c = RequestContext.getEventContext();\n        Object builtMessage;\n        if(descriptor.getOutboundRouter().hasEndpoints() ) {\n            List endpoints = new ArrayList();\n            for (Iterator iterator = descriptor.getOutboundRouter().getRouters().iterator(); iterator.hasNext();) {\n                UMOOutboundRouter router = (UMOOutboundRouter) iterator.next();\n                endpoints.addAll(router.getEndpoints());\n            }\n            for (Iterator iterator = endpoints.iterator(); iterator.hasNext();) {\n                UMOEndpoint endpoint = (UMOEndpoint) iterator.next();\n                responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                builtMessage = buildMessage(requestMessage, responseMessage);\n                responseMessage = new MuleMessage(builtMessage, responseMessage.getProperties());\n                requestMessage = responseMessage;\n            }\n        } else {\n            logger.info(\"There are currently no endpoints configured on component: \" + descriptor.getName());\n        }\n        eventContext.setStopFurtherProcessing(true);\n        return responseMessage;\n    }","id":42539,"modified_method":"public Object onCall(UMOEventContext eventContext) throws Exception {\n\n        UMOMessage requestMessage = eventContext.getMessage();;\n\n        UMOMessage responseMessage = requestMessage;\n        UMOEventContext c = RequestContext.getEventContext();\n        Object builtMessage;\n        if(descriptor.getOutboundRouter().hasEndpoints() ) {\n            List endpoints = new ArrayList();\n            for (Iterator iterator = descriptor.getOutboundRouter().getRouters().iterator(); iterator.hasNext();) {\n                UMOOutboundRouter router = (UMOOutboundRouter) iterator.next();\n                endpoints.addAll(router.getEndpoints());\n            }\n            for (Iterator iterator = endpoints.iterator(); iterator.hasNext();) {\n                UMOEndpoint endpoint = (UMOEndpoint) iterator.next();\n                if(!endpoint.isRemoteSync()) {\n                    logger.info(\"Endpoint: \" + endpoint + \" is not remoteSync enabled. Message builder finishing\");\n                    if(endpoint.isSynchronous()) {\n                        responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    } else {\n                        eventContext.dispatchEvent(requestMessage, endpoint);\n                        responseMessage=null;\n                    }\n                    break;\n                } else {\n                    responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    builtMessage = buildMessage(requestMessage, responseMessage);\n                    responseMessage = new MuleMessage(builtMessage, responseMessage.getProperties());\n                    requestMessage = responseMessage;\n                }\n            }\n        } else {\n            logger.info(\"There are currently no endpoints configured on component: \" + descriptor.getName());\n        }\n        eventContext.setStopFurtherProcessing(true);\n        return responseMessage;\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public String toString()\n    {\n        return \"AbstractTransformer{\" + \"name='\" + name + \"'\" + \", returnClass=\" + ignoreBadInput + \", returnClass=\" +\n                ignoreBadInput + \", sourceTypes=\" + sourceTypes + \"}\";\n    }","id":42540,"modified_method":"public String toString()\n    {\n        return \"Transformer{\" + \"name='\" + name + \"'\" + \", returnClass=\" + ignoreBadInput + \", returnClass=\" +\n                ignoreBadInput + \", sourceTypes=\" + sourceTypes + \"}\";\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage route(UMOMessage message, UMOSession session, boolean synchronous) throws RoutingException\n    {\n        UMOMessage result = null;\n        if (endpoints == null || endpoints.size() == 0) {\n            throw new RoutePathNotFoundException(new Message(Messages.NO_ENDPOINTS_FOR_ROUTER), message, null);\n        }\n        try {\n\n            if (synchronous) {\n                result = message;\n                for (int i = 0; i < endpoints.size(); i++) {\n                    result = send(session, result, (UMOEndpoint) endpoints.get(i));\n                }\n\n            } else {\n                logger.info(\"Invocation is asynchronous no result will be returned for any further invocations\");\n                dispatch(session, message, (UMOEndpoint) endpoints.get(0));\n            }\n        } catch (UMOException e) {\n            throw new CouldNotRouteOutboundMessageException(message, (UMOEndpoint) endpoints.get(0), e);\n        }\n        return result;\n    }","id":42541,"modified_method":"public UMOMessage route(UMOMessage message, UMOSession session, boolean synchronous) throws RoutingException\n    {\n        UMOMessage result = null;\n        if (endpoints == null || endpoints.size() == 0) {\n            throw new RoutePathNotFoundException(new Message(Messages.NO_ENDPOINTS_FOR_ROUTER), message, null);\n        }\n        try {\n\n            result = message;\n            UMOEndpoint ep = null;\n\n            for (int i = 0; i < endpoints.size(); i++) {\n                ep = (UMOEndpoint) endpoints.get(i);\n                if(ep.isSynchronous()) {\n                    result = send(session, result, ep);\n                    if(result==null) {\n                        logger.warn(\"There was no result returned from endpoint invocation: \" + ep + \" Chaining router cannot process any further endpoints\");\n                        break;\n                    }\n                } else {\n                    logger.info(\"Invocation is asynchronous no result will be returned for any further invocations\");\n                    dispatch(session, result, ep);\n                    break;\n                }\n            }\n\n        } catch (UMOException e) {\n            throw new CouldNotRouteOutboundMessageException(message, (UMOEndpoint) endpoints.get(0), e);\n        }\n        return result;\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doDispatch(UMOEvent event) throws Exception\n    {\n        HttpMethod httpMethod = execute(event, true);\n        if(httpMethod!=null) {\n            httpMethod.releaseConnection();\n        }\n    }","id":42542,"modified_method":"public void doDispatch(UMOEvent event) throws Exception\n    {\n        HttpMethod httpMethod = execute(event, true);\n        if(httpMethod!=null) {\n            httpMethod.releaseConnection();\n            if(httpMethod.getStatusCode() >= 400 ) {\n                throw new DispatchException(event.getMessage(), event.getEndpoint(),\n                        new Exception(\"Http call returned a status of: \" + httpMethod.getStatusCode() + \" \" + httpMethod.getStatusText()));\n            }\n        }\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage doSend(UMOEvent event) throws Exception\n    {\n        HttpMethod httpMethod = execute(event, false);\n        try {\n            Properties h = new Properties();\n            Header[] headers = httpMethod.getRequestHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                h.setProperty(headers[i].getName(), headers[i].getValue());\n            }\n            String status = String.valueOf(httpMethod.getStatusCode());\n            h.setProperty(HttpConnector.HTTP_STATUS_PROPERTY, status);\n            logger.debug(\"Http response is: \" + status);\n            return new MuleMessage(httpMethod.getResponseBodyAsString(), h);\n        } catch (Exception e) {\n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        } finally {\n            if (httpMethod != null)\n                httpMethod.releaseConnection();\n        }\n    }","id":42543,"modified_method":"public UMOMessage doSend(UMOEvent event) throws Exception\n    {\n        HttpMethod httpMethod = execute(event, false);\n        try {\n            Properties h = new Properties();\n            Header[] headers = httpMethod.getRequestHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                h.setProperty(headers[i].getName(), headers[i].getValue());\n            }\n            String status = String.valueOf(httpMethod.getStatusCode());\n            h.setProperty(HttpConnector.HTTP_STATUS_PROPERTY, status);\n            logger.debug(\"Http response is: \" + status);\n            ExceptionPayload ep = null;\n            if(httpMethod.getStatusCode() >= 400 ) {\n                throw new DispatchException(event.getMessage(), event.getEndpoint(),\n                        new Exception(\"Http call returned a status of: \" + httpMethod.getStatusCode() + \" \" + httpMethod.getStatusText()));\n            }\n            UMOMessage m = new MuleMessage(httpMethod.getResponseBodyAsString(), h);\n            m.setExceptionPayload(ep);\n            return m;\n        } catch (Exception e) {\n            throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n        } finally {\n            if (httpMethod != null)\n                httpMethod.releaseConnection();\n        }\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doConnect() throws Exception {\n        httpServer = new Server();\n        SocketListener socketListener = new SocketListener(new InetAddrPort(endpoint.getEndpointURI().getPort()));\n// Todo\n//        socketListener.setMaxIdleTimeMs();\n//        socketListener.setMaxThreads();\n//        socketListener.setMinThreads();\n        httpServer.addListener(socketListener);\n\n        String path = endpoint.getEndpointURI().getPath();\n        if(path == null || \"\".equals(path)) {\n            path =\"/\";\n        }\n\n        HttpContext context = httpServer.getContext(path);\n        context.setRequestLog(null);\n\n        ServletHandler handler = new ServletHandler();\n        if(\"jetty:rest\".equals(endpoint.getEndpointURI().getSchemeMetaInfo())) {\n            handler.addServlet(\"MuleRESTReceiverServlet\", path + \"*\", MuleRESTReceiverServlet.class.getName());\n        } else {\n            handler.addServlet(\"JettyReceiverServlet\", path + \"*\", JettyReceiverServlet.class.getName());\n        }\n\n        context.addHandler(handler);\n        context.setAttribute(\"messageReceiver\", this);\n\n    }","id":42544,"modified_method":"public void doConnect() throws Exception {\n        httpServer = new Server();\n        SocketListener socketListener = new SocketListener(new InetAddrPort(endpoint.getEndpointURI().getPort()));\n// Todo\n//        socketListener.setMaxIdleTimeMs();\n//        socketListener.setMaxThreads();\n//        socketListener.setMinThreads();\n        httpServer.addListener(socketListener);\n\n        String path = endpoint.getEndpointURI().getPath();\n        if(path == null || \"\".equals(path)) {\n            path =\"/\";\n        }\n\n        if(!path.endsWith(\"/\")) path += \"/\";\n\n        HttpContext context = httpServer.getContext(path);\n        context.setRequestLog(null);\n\n        ServletHandler handler = new ServletHandler();\n        if(\"rest\".equals(endpoint.getEndpointURI().getScheme())) {\n            handler.addServlet(\"MuleRESTReceiverServlet\", path + \"*\", MuleRESTReceiverServlet.class.getName());\n        } else {\n            handler.addServlet(\"JettyReceiverServlet\", path + \"*\", JettyReceiverServlet.class.getName());\n        }\n\n        context.addHandler(handler);\n        context.setAttribute(\"messageReceiver\", this);\n\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"protected UMOEndpoint lookupEndpoint(String uri) throws UMOException {\n        UMODescriptor axis = MuleManager.getInstance().getModel().getDescriptor(AxisConnector.AXIS_SERVICE_COMPONENT_NAME);\n        UMOEndpointURI endpoint = new MuleEndpointURI(uri);\n        UMOEndpoint ep;\n        if(axis!=null) {\n            ep = (UMOEndpoint)endpointsCache.get(endpoint.getAddress());\n            if(ep==null) {\n                updateEndpointCache(axis.getOutboundRouter());\n                ep = (UMOEndpoint)endpointsCache.get(endpoint.getAddress());\n                if(ep==null) {\n                    logger.info(\"Dispatch Endpoint uri: \" + uri + \" not found on the AxisServiceComponent. Creating the endpoint instead.\");\n                    ep = new MuleEndpoint(uri, false);\n                } else {\n                    logger.info(\"Found endpoint: \" + uri + \" on the Axis service component\");\n                }\n            } else {\n                logger.info(\"Found endpoint: \" + uri + \" on the Axis service component\");\n            }\n        } else {\n            ep = new MuleEndpoint(uri, false);\n        }\n        return ep;\n    }","id":42545,"modified_method":"protected UMOEndpoint lookupEndpoint(String uri) throws UMOException {\n        UMODescriptor axis = MuleManager.getInstance().getModel().getDescriptor(AxisConnector.AXIS_SERVICE_COMPONENT_NAME);\n        UMOEndpointURI endpoint = new MuleEndpointURI(uri);\n        UMOEndpoint ep;\n        if(axis!=null) {\n            ep = (UMOEndpoint)endpointsCache.get(endpoint.getAddress());\n            if(ep==null) {\n                updateEndpointCache(axis.getOutboundRouter());\n                ep = (UMOEndpoint)endpointsCache.get(endpoint.getAddress());\n                if(ep==null) {\n                    logger.debug(\"Dispatch Endpoint uri: \" + uri + \" not found on the cache. Creating the endpoint instead.\");\n                    ep = new MuleEndpoint(uri, false);\n                } else {\n                    logger.info(\"Found endpoint: \" + uri + \" on the Axis service component\");\n                }\n            } else {\n                logger.info(\"Found endpoint: \" + uri + \" on the Axis service component\");\n            }\n        } else {\n            ep = new MuleEndpoint(uri, false);\n        }\n        return ep;\n    }","commit_id":"838271dbbf45bebe36ed615b1487bcf271ca49f7","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // type \"issue\"\n    NewIndex.NewIndexType issueMapping = index.createType(TYPE_ISSUE);\n    issueMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", TYPE_AUTHORIZATION));\n    issueMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", \"true\"));\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ASSIGNEE).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ATTRIBUTES).docValues().disableNorms().disableSearch().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_AUTHOR_LOGIN).disableNorms().docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_COMPONENT_UUID).disableNorms().docValues().build();\n    issueMapping.createLongField(FIELD_ISSUE_EFFORT);\n    issueMapping.createDoubleField(FIELD_ISSUE_GAP);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_FILE_PATH).enableSorting().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CREATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_UPDATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CLOSED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_KEY).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_LANGUAGE).disableNorms().build();\n    issueMapping.createIntegerField(FIELD_ISSUE_LINE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MESSAGE).disableNorms().docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MODULE_UUID).disableNorms().docValues().build();\n    issueMapping.createUuidPathField(FIELD_ISSUE_MODULE_PATH);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_PROJECT_UUID).disableNorms().enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_DIRECTORY_PATH).disableNorms().docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RESOLUTION).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RULE_KEY).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_SEVERITY).disableNorms().build();\n    issueMapping.createByteField(FIELD_ISSUE_SEVERITY_VALUE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_STATUS).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TAGS).disableNorms().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_TECHNICAL_UPDATED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TYPE).disableNorms().build();\n\n    // type \"authorization\"\n    NewIndex.NewIndexType authorizationMapping = index.createType(TYPE_AUTHORIZATION);\n    authorizationMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", \"true\"));\n    authorizationMapping.createDateTimeField(FIELD_AUTHORIZATION_UPDATED_AT);\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_PROJECT_UUID).disableNorms().build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_GROUPS).disableNorms().build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_USERS).disableNorms().build();\n  }","id":42546,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // type \"issue\"\n    NewIndex.NewIndexType issueMapping = index.createType(TYPE_ISSUE);\n    issueMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", TYPE_AUTHORIZATION));\n    issueMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", \"true\"));\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ASSIGNEE).disableNorms().enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ATTRIBUTES).disableNorms().disableSearch().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_AUTHOR_LOGIN).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_COMPONENT_UUID).disableNorms().build();\n    issueMapping.createLongField(FIELD_ISSUE_EFFORT);\n    issueMapping.createDoubleField(FIELD_ISSUE_GAP);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_FILE_PATH).disableNorms().enableSorting().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CREATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_UPDATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CLOSED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_KEY).disableNorms().enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_LANGUAGE).disableNorms().build();\n    issueMapping.createIntegerField(FIELD_ISSUE_LINE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MESSAGE).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MODULE_UUID).disableNorms().build();\n    issueMapping.createUuidPathField(FIELD_ISSUE_MODULE_PATH);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_PROJECT_UUID).disableNorms().enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_DIRECTORY_PATH).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RESOLUTION).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RULE_KEY).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_SEVERITY).disableNorms().build();\n    issueMapping.createByteField(FIELD_ISSUE_SEVERITY_VALUE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_STATUS).disableNorms().enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TAGS).disableNorms().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_TECHNICAL_UPDATED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TYPE).disableNorms().build();\n\n    // type \"authorization\"\n    NewIndex.NewIndexType authorizationMapping = index.createType(TYPE_AUTHORIZATION);\n    authorizationMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", \"true\"));\n    authorizationMapping.createDateTimeField(FIELD_AUTHORIZATION_UPDATED_AT);\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_PROJECT_UUID).disableNorms().build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_GROUPS).disableNorms().build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_USERS).disableNorms().build();\n  }","commit_id":"b0c6009dc9c4052aaaa4cda6a139330923240d85","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Add a sub-field. A {@code SortedMap} is required for consistency of the index settings hash.\n     * @see IndexDefinitionHash\n     */\n    public StringFieldBuilder addSubField(String fieldName, SortedMap<String, String> fieldDefinition) {\n      subFields.put(fieldName, fieldDefinition);\n      hasAnalyzedField |= \"analyzed\".equals(fieldDefinition.get(\"index\"));\n      return this;\n    }","id":42547,"modified_method":"/**\n     * Add a sub-field. A {@code SortedMap} is required for consistency of the index settings hash.\n     * @see IndexDefinitionHash\n     */\n    public StringFieldBuilder addSubField(String fieldName, SortedMap<String, String> fieldDefinition) {\n      subFields.put(fieldName, fieldDefinition);\n      return this;\n    }","commit_id":"b0c6009dc9c4052aaaa4cda6a139330923240d85","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void build() {\n      validate();\n      Map<String, Object> hash = new TreeMap<>();\n      if (subFields.isEmpty()) {\n        hash.putAll(ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", disableSearch ? \"no\" : \"not_analyzed\",\n          \"norms\", ImmutableMap.of(\"enabled\", String.valueOf(!disableNorms)),\n          \"doc_values\", docValues));\n      } else {\n        hash.put(\"type\", \"multi_field\");\n        Map<String, Object> multiFields = new TreeMap<>(subFields);\n        multiFields.put(fieldName, ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", \"not_analyzed\",\n          \"norms\", ImmutableMap.of(\"enabled\", \"false\"),\n          \"doc_values\", docValues));\n        hash.put(\"fields\", multiFields);\n      }\n\n      indexType.setProperty(fieldName, hash);\n    }","id":42548,"modified_method":"public void build() {\n      Map<String, Object> hash = new TreeMap<>();\n      if (subFields.isEmpty()) {\n        hash.putAll(ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", disableSearch ? \"no\" : \"not_analyzed\",\n          \"norms\", ImmutableMap.of(\"enabled\", String.valueOf(!disableNorms))));\n      } else {\n        hash.put(\"type\", \"multi_field\");\n        Map<String, Object> multiFields = new TreeMap<>(subFields);\n        multiFields.put(fieldName, ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", \"not_analyzed\",\n          \"norms\", ImmutableMap.of(\"enabled\", \"false\")));\n        hash.put(\"fields\", multiFields);\n      }\n\n      indexType.setProperty(fieldName, hash);\n    }","commit_id":"b0c6009dc9c4052aaaa4cda6a139330923240d85","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void string_doc_values() {\n    NewIndex index = new NewIndex(\"issues\");\n    NewIndex.NewIndexType mapping = index.createType(\"issue\");\n    mapping.stringFieldBuilder(\"the_doc_value\").docValues().build();\n\n    Map<String, Object> props = (Map) mapping.getProperty(\"the_doc_value\");\n    assertThat(props.get(\"type\")).isEqualTo(\"string\");\n    assertThat(props.get(\"index\")).isEqualTo(\"not_analyzed\");\n    assertThat(props.get(\"doc_values\")).isEqualTo(Boolean.TRUE);\n    assertThat(props.get(\"fields\")).isNull();\n  }","id":42549,"modified_method":"@Test\n  public void use_default_doc_values() {\n    NewIndex index = new NewIndex(\"issues\");\n    NewIndex.NewIndexType mapping = index.createType(\"issue\");\n    mapping.stringFieldBuilder(\"the_doc_value\").build();\n\n    Map<String, Object> props = (Map) mapping.getProperty(\"the_doc_value\");\n    assertThat(props.get(\"type\")).isEqualTo(\"string\");\n    assertThat(props.get(\"doc_values\")).isNull();\n  }","commit_id":"b0c6009dc9c4052aaaa4cda6a139330923240d85","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // Active rule type\n    NewIndex.NewIndexType activeRuleMapping = index.createType(RuleIndexDefinition.TYPE_ACTIVE_RULE);\n    activeRuleMapping.setEnableSource(false);\n    activeRuleMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", RuleIndexDefinition.TYPE_RULE));\n\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY).build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_PROFILE_KEY).disableNorms().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_INHERITANCE).disableNorms().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_SEVERITY).disableNorms().docValues().build();\n\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_CREATED_AT);\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_UPDATED_AT);\n\n    // Rule type\n    NewIndex.NewIndexType ruleMapping = index.createType(TYPE_RULE);\n    ruleMapping.setEnableSource(false);\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_REPOSITORY).build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_INTERNAL_KEY).disableNorms().disableSearch().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_NAME).enableSorting().enableWordSearch().build();\n    ruleMapping.setProperty(FIELD_RULE_HTML_DESCRIPTION, ImmutableSortedMap.of(\n      \"type\", \"string\",\n      \"index\", \"analyzed\",\n      \"doc_values\", \"false\",\n      \"analyzer\", \"html_analyzer\",\n      \"search_analyzer\", \"html_analyzer\"\n      ));\n    ruleMapping.stringFieldBuilder(FIELD_RULE_SEVERITY).disableNorms().docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_STATUS).disableNorms().docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_LANGUAGE).disableNorms().build();\n\n    ruleMapping.createBooleanField(FIELD_RULE_IS_TEMPLATE);\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TEMPLATE_KEY).disableNorms().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_ALL_TAGS).enableGramSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TYPE).disableNorms().build();\n\n    ruleMapping.createLongField(FIELD_RULE_CREATED_AT);\n    ruleMapping.createLongField(FIELD_RULE_UPDATED_AT);\n  }","id":42550,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // Active rule type\n    NewIndex.NewIndexType activeRuleMapping = index.createType(RuleIndexDefinition.TYPE_ACTIVE_RULE);\n    activeRuleMapping.setEnableSource(false);\n    activeRuleMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", RuleIndexDefinition.TYPE_RULE));\n\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY).build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_PROFILE_KEY).disableNorms().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_INHERITANCE).disableNorms().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_SEVERITY).disableNorms().build();\n\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_CREATED_AT);\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_UPDATED_AT);\n\n    // Rule type\n    NewIndex.NewIndexType ruleMapping = index.createType(TYPE_RULE);\n    ruleMapping.setEnableSource(false);\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_REPOSITORY).build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_INTERNAL_KEY).disableNorms().disableSearch().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_NAME).enableSorting().enableWordSearch().build();\n    ruleMapping.setProperty(FIELD_RULE_HTML_DESCRIPTION, ImmutableSortedMap.of(\n      \"type\", \"string\",\n      \"index\", \"analyzed\",\n      \"analyzer\", \"html_analyzer\",\n      \"search_analyzer\", \"html_analyzer\"\n      ));\n    ruleMapping.stringFieldBuilder(FIELD_RULE_SEVERITY).disableNorms().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_STATUS).disableNorms().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_LANGUAGE).disableNorms().build();\n\n    ruleMapping.createBooleanField(FIELD_RULE_IS_TEMPLATE);\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TEMPLATE_KEY).disableNorms().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_ALL_TAGS).enableGramSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TYPE).disableNorms().build();\n\n    ruleMapping.createLongField(FIELD_RULE_CREATED_AT);\n    ruleMapping.createLongField(FIELD_RULE_UPDATED_AT);\n  }","commit_id":"b0c6009dc9c4052aaaa4cda6a139330923240d85","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n    index.getSettings().put(\"analysis.analyzer.default.type\", \"keyword\");\n    index.configureShards(settings);\n    index.refreshHandledByIndexer();\n\n    // type \"activity\"\n    NewIndex.NewIndexType mapping = index.createType(TYPE);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_KEY));\n    mapping.stringFieldBuilder(FIELD_KEY).build();\n    mapping.stringFieldBuilder(FIELD_TYPE).build();\n    mapping.stringFieldBuilder(FIELD_ACTION).build();\n    mapping.stringFieldBuilder(FIELD_LOGIN).build();\n    mapping.createDynamicNestedField(FIELD_DETAILS);\n    mapping.stringFieldBuilder(FIELD_MESSAGE).build();\n    mapping.createDateTimeField(FIELD_CREATED_AT);\n  }","id":42551,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n    index.getSettings().put(\"analysis.analyzer.default.type\", \"keyword\");\n    index.configureShards(settings);\n    index.refreshHandledByIndexer();\n\n    // type \"activity\"\n    NewIndex.NewIndexType mapping = index.createType(TYPE);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_KEY));\n    mapping.stringFieldBuilder(FIELD_KEY).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_TYPE).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_ACTION).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_LOGIN).disableNorms().build();\n    mapping.createDynamicNestedField(FIELD_DETAILS);\n    mapping.stringFieldBuilder(FIELD_MESSAGE).disableNorms().build();\n    mapping.createDateTimeField(FIELD_CREATED_AT);\n  }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // type \"authorization\"\n    NewIndex.NewIndexType authorizationMapping = index.createType(TYPE_AUTHORIZATION);\n    authorizationMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_AUTHORIZATION_PROJECT_UUID));\n    authorizationMapping.createDateTimeField(FIELD_AUTHORIZATION_UPDATED_AT);\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_PROJECT_UUID).build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_GROUPS).build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_USERS).build();\n\n    // type \"issue\"\n    NewIndex.NewIndexType issueMapping = index.createType(TYPE_ISSUE);\n    issueMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_ISSUE_KEY));\n    issueMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", TYPE_AUTHORIZATION));\n    issueMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", FIELD_ISSUE_PROJECT_UUID));\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ASSIGNEE).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ATTRIBUTES).docValues().disableSearch().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_AUTHOR_LOGIN).docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_COMPONENT_UUID).docValues().build();\n    issueMapping.createLongField(FIELD_ISSUE_EFFORT);\n    issueMapping.createDoubleField(FIELD_ISSUE_GAP);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_FILE_PATH).enableSorting().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CREATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_UPDATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CLOSED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_KEY).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_LANGUAGE).build();\n    issueMapping.createIntegerField(FIELD_ISSUE_LINE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MESSAGE).docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MODULE_UUID).docValues().build();\n    issueMapping.createUuidPathField(FIELD_ISSUE_MODULE_PATH);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_PROJECT_UUID).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_DIRECTORY_PATH).docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RESOLUTION).build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RULE_KEY).build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_SEVERITY).build();\n    issueMapping.createByteField(FIELD_ISSUE_SEVERITY_VALUE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_STATUS).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TAGS).build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_TECHNICAL_UPDATED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TYPE).build();\n  }","id":42552,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // type \"authorization\"\n    NewIndex.NewIndexType authorizationMapping = index.createType(TYPE_AUTHORIZATION);\n    authorizationMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_AUTHORIZATION_PROJECT_UUID));\n    authorizationMapping.createDateTimeField(FIELD_AUTHORIZATION_UPDATED_AT);\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_PROJECT_UUID).disableNorms().build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_GROUPS).disableNorms().build();\n    authorizationMapping.stringFieldBuilder(FIELD_AUTHORIZATION_USERS).disableNorms().build();\n\n    // type \"issue\"\n    NewIndex.NewIndexType issueMapping = index.createType(TYPE_ISSUE);\n    issueMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_ISSUE_KEY));\n    issueMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", TYPE_AUTHORIZATION));\n    issueMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", FIELD_ISSUE_PROJECT_UUID));\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ASSIGNEE).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_ATTRIBUTES).docValues().disableNorms().disableSearch().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_AUTHOR_LOGIN).disableNorms().docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_COMPONENT_UUID).disableNorms().docValues().build();\n    issueMapping.createLongField(FIELD_ISSUE_EFFORT);\n    issueMapping.createDoubleField(FIELD_ISSUE_GAP);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_FILE_PATH).enableSorting().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CREATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_UPDATED_AT);\n    issueMapping.createDateTimeField(FIELD_ISSUE_FUNC_CLOSED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_KEY).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_LANGUAGE).disableNorms().build();\n    issueMapping.createIntegerField(FIELD_ISSUE_LINE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MESSAGE).disableNorms().docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_MODULE_UUID).disableNorms().docValues().build();\n    issueMapping.createUuidPathField(FIELD_ISSUE_MODULE_PATH);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_PROJECT_UUID).disableNorms().enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_DIRECTORY_PATH).disableNorms().docValues().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RESOLUTION).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_RULE_KEY).disableNorms().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_SEVERITY).disableNorms().build();\n    issueMapping.createByteField(FIELD_ISSUE_SEVERITY_VALUE);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_STATUS).enableSorting().build();\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TAGS).disableNorms().build();\n    issueMapping.createDateTimeField(FIELD_ISSUE_TECHNICAL_UPDATED_AT);\n    issueMapping.stringFieldBuilder(FIELD_ISSUE_TYPE).disableNorms().build();\n  }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void build() {\n      validate();\n      Map<String, Object> hash = new TreeMap<>();\n      if (subFields.isEmpty()) {\n        hash.putAll(ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", disableSearch ? \"no\" : \"not_analyzed\",\n          \"omit_norms\", \"true\",\n          \"doc_values\", docValues));\n      } else {\n        hash.put(\"type\", \"multi_field\");\n        Map<String, Object> multiFields = new TreeMap<>(subFields);\n        multiFields.put(fieldName, ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", \"not_analyzed\",\n          \"omit_norms\", \"true\",\n          \"doc_values\", docValues));\n        hash.put(\"fields\", multiFields);\n      }\n\n      indexType.setProperty(fieldName, hash);\n    }","id":42553,"modified_method":"public void build() {\n      validate();\n      Map<String, Object> hash = new TreeMap<>();\n      if (subFields.isEmpty()) {\n        hash.putAll(ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", disableSearch ? \"no\" : \"not_analyzed\",\n          \"norms\", ImmutableMap.of(\"enabled\", String.valueOf(!disableNorms)),\n          \"doc_values\", docValues));\n      } else {\n        hash.put(\"type\", \"multi_field\");\n        Map<String, Object> multiFields = new TreeMap<>(subFields);\n        multiFields.put(fieldName, ImmutableMap.of(\n          \"type\", \"string\",\n          \"index\", \"not_analyzed\",\n          \"norms\", ImmutableMap.of(\"enabled\", \"false\"),\n          \"doc_values\", docValues));\n        hash.put(\"fields\", multiFields);\n      }\n\n      indexType.setProperty(fieldName, hash);\n    }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // Rule type\n    NewIndex.NewIndexType ruleMapping = index.createType(TYPE_RULE);\n    ruleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_RULE_KEY));\n    ruleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_RULE_REPOSITORY));\n    ruleMapping.setEnableSource(false);\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_REPOSITORY).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_INTERNAL_KEY).disableSearch().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_NAME).enableSorting().enableWordSearch().build();\n    ruleMapping.setProperty(FIELD_RULE_HTML_DESCRIPTION, ImmutableSortedMap.of(\n      \"type\", \"string\",\n      \"index\", \"analyzed\",\n      \"doc_values\", \"false\",\n      \"index_analyzer\", \"html_analyzer\",\n      \"search_analyzer\", \"html_analyzer\"\n      ));\n    ruleMapping.stringFieldBuilder(FIELD_RULE_SEVERITY).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_STATUS).docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_LANGUAGE).build();\n\n    ruleMapping.createBooleanField(FIELD_RULE_IS_TEMPLATE);\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TEMPLATE_KEY).docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_ALL_TAGS).enableGramSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TYPE).build();\n\n    ruleMapping.createLongField(FIELD_RULE_CREATED_AT);\n    ruleMapping.createLongField(FIELD_RULE_UPDATED_AT);\n\n    // Active rule type\n    NewIndex.NewIndexType activeRuleMapping = index.createType(RuleIndexDefinition.TYPE_ACTIVE_RULE);\n    activeRuleMapping.setEnableSource(false);\n    activeRuleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY));\n    activeRuleMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", RuleIndexDefinition.TYPE_RULE));\n    activeRuleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY));\n\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_RULE_KEY).disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY).disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_PROFILE_KEY).docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_INHERITANCE).docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_SEVERITY).docValues().build();\n\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_CREATED_AT);\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_UPDATED_AT);\n  }","id":42554,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    // Rule type\n    NewIndex.NewIndexType ruleMapping = index.createType(TYPE_RULE);\n    ruleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_RULE_KEY));\n    ruleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_RULE_REPOSITORY));\n    ruleMapping.setEnableSource(false);\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_RULE_KEY).enableSorting().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_REPOSITORY).disableNorms().docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_INTERNAL_KEY).disableNorms().disableSearch().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_NAME).enableSorting().enableWordSearch().build();\n    ruleMapping.setProperty(FIELD_RULE_HTML_DESCRIPTION, ImmutableSortedMap.of(\n      \"type\", \"string\",\n      \"index\", \"analyzed\",\n      \"doc_values\", \"false\",\n      \"index_analyzer\", \"html_analyzer\",\n      \"search_analyzer\", \"html_analyzer\"\n      ));\n    ruleMapping.stringFieldBuilder(FIELD_RULE_SEVERITY).disableNorms().docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_STATUS).disableNorms().docValues().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_LANGUAGE).disableNorms().build();\n\n    ruleMapping.createBooleanField(FIELD_RULE_IS_TEMPLATE);\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TEMPLATE_KEY).disableNorms().docValues().build();\n\n    ruleMapping.stringFieldBuilder(FIELD_RULE_ALL_TAGS).enableGramSearch().build();\n    ruleMapping.stringFieldBuilder(FIELD_RULE_TYPE).disableNorms().build();\n\n    ruleMapping.createLongField(FIELD_RULE_CREATED_AT);\n    ruleMapping.createLongField(FIELD_RULE_UPDATED_AT);\n\n    // Active rule type\n    NewIndex.NewIndexType activeRuleMapping = index.createType(RuleIndexDefinition.TYPE_ACTIVE_RULE);\n    activeRuleMapping.setEnableSource(false);\n    activeRuleMapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY));\n    activeRuleMapping.setAttribute(\"_parent\", ImmutableMap.of(\"type\", RuleIndexDefinition.TYPE_RULE));\n    activeRuleMapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY));\n\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_KEY).enableSorting().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_RULE_KEY).disableNorms().disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_REPOSITORY).disableNorms().disableSearch().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_PROFILE_KEY).disableNorms().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_INHERITANCE).disableNorms().docValues().build();\n    activeRuleMapping.stringFieldBuilder(RuleIndexDefinition.FIELD_ACTIVE_RULE_SEVERITY).disableNorms().docValues().build();\n\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_CREATED_AT);\n    activeRuleMapping.createLongField(RuleIndexDefinition.FIELD_ACTIVE_RULE_UPDATED_AT);\n  }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    NewIndex.NewIndexType nestedMapping = index.createType(TYPE);\n    nestedMapping.stringFieldBuilder(FIELD_COVERED_FILE_UUID).build();\n    nestedMapping.createIntegerField(FIELD_COVERED_FILE_LINES);\n\n    NewIndex.NewIndexType mapping = index.createType(TYPE);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_TEST_UUID));\n    mapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", FIELD_PROJECT_UUID));\n    mapping.stringFieldBuilder(FIELD_PROJECT_UUID).build();\n    mapping.stringFieldBuilder(FIELD_FILE_UUID).build();\n    mapping.stringFieldBuilder(FIELD_TEST_UUID).build();\n    mapping.stringFieldBuilder(FIELD_NAME).disableSearch().build();\n    mapping.stringFieldBuilder(FIELD_STATUS).disableSearch().build();\n    mapping.createLongField(FIELD_DURATION_IN_MS);\n    mapping.stringFieldBuilder(FIELD_MESSAGE).disableSearch().build();\n    mapping.stringFieldBuilder(FIELD_STACKTRACE).disableSearch().build();\n    mapping.nestedObjectBuilder(FIELD_COVERED_FILES, nestedMapping).build();\n    mapping.createDateTimeField(FIELD_UPDATED_AT);\n  }","id":42555,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.refreshHandledByIndexer();\n    index.configureShards(settings);\n\n    NewIndex.NewIndexType nestedMapping = index.createType(TYPE);\n    nestedMapping.stringFieldBuilder(FIELD_COVERED_FILE_UUID).build();\n    nestedMapping.createIntegerField(FIELD_COVERED_FILE_LINES);\n\n    NewIndex.NewIndexType mapping = index.createType(TYPE);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_TEST_UUID));\n    mapping.setAttribute(\"_routing\", ImmutableMap.of(\"required\", true, \"path\", FIELD_PROJECT_UUID));\n    mapping.stringFieldBuilder(FIELD_PROJECT_UUID).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_FILE_UUID).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_TEST_UUID).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_NAME).disableNorms().disableSearch().build();\n    mapping.stringFieldBuilder(FIELD_STATUS).disableNorms().disableSearch().build();\n    mapping.createLongField(FIELD_DURATION_IN_MS);\n    mapping.stringFieldBuilder(FIELD_MESSAGE).disableNorms().disableSearch().build();\n    mapping.stringFieldBuilder(FIELD_STACKTRACE).disableNorms().disableSearch().build();\n    mapping.nestedObjectBuilder(FIELD_COVERED_FILES, nestedMapping).build();\n    mapping.createDateTimeField(FIELD_UPDATED_AT);\n  }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.configureShards(settings);\n\n    index.getSettings()\n      // NGram filter (not edge) for logins and names\n      .put(\"index.analysis.filter.ngram_filter.type\", \"nGram\")\n      .put(\"index.analysis.filter.ngram_filter.min_gram\", 2)\n      .put(\"index.analysis.filter.ngram_filter.max_gram\", 15)\n      .putArray(\"index.analysis.filter.ngram_filter.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n      // NGram index analyzer\n      .put(\"index.analysis.analyzer.index_ngrams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_ngrams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.index_ngrams.filter\", \"trim\", \"lowercase\", \"ngram_filter\")\n\n      // NGram search analyzer\n      .put(\"index.analysis.analyzer.search_ngrams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_ngrams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.search_ngrams.filter\", \"trim\", \"lowercase\");\n\n    // type \"user\"\n    NewIndex.NewIndexType mapping = index.createType(TYPE_USER);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_LOGIN));\n\n    mapping.stringFieldBuilder(FIELD_LOGIN).addSubField(SEARCH_SUB_SUFFIX, buildGramSearchField()).build();\n    mapping.stringFieldBuilder(FIELD_NAME).addSubField(SEARCH_SUB_SUFFIX, buildGramSearchField()).build();\n    mapping.stringFieldBuilder(FIELD_EMAIL).enableSorting().build();\n    mapping.createDateTimeField(FIELD_CREATED_AT);\n    mapping.createDateTimeField(FIELD_UPDATED_AT);\n    mapping.createBooleanField(FIELD_ACTIVE);\n    mapping.stringFieldBuilder(FIELD_SCM_ACCOUNTS).build();\n  }","id":42556,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.configureShards(settings);\n\n    index.getSettings()\n      // NGram filter (not edge) for logins and names\n      .put(\"index.analysis.filter.ngram_filter.type\", \"nGram\")\n      .put(\"index.analysis.filter.ngram_filter.min_gram\", 2)\n      .put(\"index.analysis.filter.ngram_filter.max_gram\", 15)\n      .putArray(\"index.analysis.filter.ngram_filter.token_chars\", \"letter\", \"digit\", \"punctuation\", \"symbol\")\n\n      // NGram index analyzer\n      .put(\"index.analysis.analyzer.index_ngrams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.index_ngrams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.index_ngrams.filter\", \"trim\", \"lowercase\", \"ngram_filter\")\n\n      // NGram search analyzer\n      .put(\"index.analysis.analyzer.search_ngrams.type\", \"custom\")\n      .put(\"index.analysis.analyzer.search_ngrams.tokenizer\", \"whitespace\")\n      .putArray(\"index.analysis.analyzer.search_ngrams.filter\", \"trim\", \"lowercase\");\n\n    // type \"user\"\n    NewIndex.NewIndexType mapping = index.createType(TYPE_USER);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_LOGIN));\n\n    mapping.stringFieldBuilder(FIELD_LOGIN).addSubField(SEARCH_SUB_SUFFIX, buildGramSearchField()).build();\n    mapping.stringFieldBuilder(FIELD_NAME).addSubField(SEARCH_SUB_SUFFIX, buildGramSearchField()).build();\n    mapping.stringFieldBuilder(FIELD_EMAIL).enableSorting().build();\n    mapping.createDateTimeField(FIELD_CREATED_AT);\n    mapping.createDateTimeField(FIELD_UPDATED_AT);\n    mapping.createBooleanField(FIELD_ACTIVE);\n    mapping.stringFieldBuilder(FIELD_SCM_ACCOUNTS).disableNorms().build();\n  }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.configureShards(settings);\n\n    // type \"view\"\n    NewIndex.NewIndexType mapping = index.createType(TYPE_VIEW);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_UUID));\n    mapping.stringFieldBuilder(FIELD_UUID).build();\n    mapping.stringFieldBuilder(FIELD_PROJECTS).build();\n  }","id":42557,"modified_method":"@Override\n  public void define(IndexDefinitionContext context) {\n    NewIndex index = context.create(INDEX);\n\n    index.configureShards(settings);\n\n    // type \"view\"\n    NewIndex.NewIndexType mapping = index.createType(TYPE_VIEW);\n    mapping.setAttribute(\"_id\", ImmutableMap.of(\"path\", FIELD_UUID));\n    mapping.stringFieldBuilder(FIELD_UUID).disableNorms().build();\n    mapping.stringFieldBuilder(FIELD_PROJECTS).disableNorms().build();\n  }","commit_id":"af1d7ef12bb3502225c6e8275f1925bf80776999","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (MySQLBulkLoaderMeta) smi;\n    data = (MySQLBulkLoaderData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      if ( Const.isEmpty( meta.getEnclosure() ) ) {\n        data.quote = new byte[] {};\n      } else {\n        data.quote = meta.getEnclosure().getBytes();\n      }\n      if ( Const.isEmpty( meta.getDelimiter() ) ) {\n        data.separator = \"\\t\".getBytes();\n      } else {\n        data.separator = meta.getDelimiter().getBytes();\n      }\n      data.newline = Const.CR.getBytes();\n\n      data.bulkTimestampMeta = new ValueMeta( \"timestampMeta\", ValueMetaInterface.TYPE_DATE );\n      data.bulkTimestampMeta.setConversionMask( \"yyyy-MM-dd HH:mm:ss\" );\n      data.bulkTimestampMeta.setStringEncoding( meta.getEncoding() );\n\n      data.bulkDateMeta = new ValueMeta( \"dateMeta\", ValueMetaInterface.TYPE_DATE );\n      data.bulkDateMeta.setConversionMask( \"yyyy-MM-dd\" );\n      data.bulkDateMeta.setStringEncoding( meta.getEncoding() );\n\n      data.bulkNumberMeta = new ValueMeta( \"numberMeta\", ValueMetaInterface.TYPE_NUMBER );\n      data.bulkNumberMeta.setConversionMask( \"#.#\" );\n      data.bulkNumberMeta.setGroupingSymbol( \",\" );\n      data.bulkNumberMeta.setDecimalSymbol( \".\" );\n      data.bulkNumberMeta.setStringEncoding( meta.getEncoding() );\n\n      data.bulkSize = Const.toLong( environmentSubstitute( meta.getBulkSize() ), -1L );\n\n      // Schema-table combination...\n      data.schemaTable =\n          meta.getDatabaseMeta().getQuotedSchemaTableCombination( environmentSubstitute( meta.getSchemaName() ),\n              environmentSubstitute( meta.getTableName() ) );\n\n      return true;\n    }\n    return false;\n  }","id":42558,"modified_method":"public boolean init( StepMetaInterface smi, StepDataInterface sdi ) {\n    meta = (MySQLBulkLoaderMeta) smi;\n    data = (MySQLBulkLoaderData) sdi;\n\n    if ( super.init( smi, sdi ) ) {\n      if ( Const.isEmpty( meta.getEnclosure() ) ) {\n        data.quote = new byte[] {};\n      } else {\n        data.quote = environmentSubstitute( meta.getEnclosure() ).getBytes();\n      }\n      if ( Const.isEmpty( meta.getDelimiter() ) ) {\n        data.separator = \"\\t\".getBytes();\n      } else {\n        data.separator = environmentSubstitute( meta.getDelimiter() ).getBytes();\n      }\n      data.newline = Const.CR.getBytes();\n\n      String realEncoding = environmentSubstitute( meta.getEncoding() );\n      data.bulkTimestampMeta = new ValueMeta( \"timestampMeta\", ValueMetaInterface.TYPE_DATE );\n      data.bulkTimestampMeta.setConversionMask( \"yyyy-MM-dd HH:mm:ss\" );\n      data.bulkTimestampMeta.setStringEncoding( realEncoding );\n\n      data.bulkDateMeta = new ValueMeta( \"dateMeta\", ValueMetaInterface.TYPE_DATE );\n      data.bulkDateMeta.setConversionMask( \"yyyy-MM-dd\" );\n      data.bulkDateMeta.setStringEncoding( realEncoding );\n\n      data.bulkNumberMeta = new ValueMeta( \"numberMeta\", ValueMetaInterface.TYPE_NUMBER );\n      data.bulkNumberMeta.setConversionMask( \"#.#\" );\n      data.bulkNumberMeta.setGroupingSymbol( \",\" );\n      data.bulkNumberMeta.setDecimalSymbol( \".\" );\n      data.bulkNumberMeta.setStringEncoding( realEncoding );\n\n      data.bulkSize = Const.toLong( environmentSubstitute( meta.getBulkSize() ), -1L );\n\n      // Schema-table combination...\n      data.schemaTable =\n          meta.getDatabaseMeta().getQuotedSchemaTableCombination( environmentSubstitute( meta.getSchemaName() ),\n              environmentSubstitute( meta.getTableName() ) );\n\n      return true;\n    }\n    return false;\n  }","commit_id":"40b892f9507a0fbc03f4b90ecbf1686451b877bb","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n   * Get the contents of the control file as specified in the meta object\n   *\n   * @param meta\n   *          the meta object to model the control file after\n   *\n   * @return a string containing the control file contents\n   */\n  public String getCopyCommand( RowMetaInterface rm, Object[] r ) throws KettleException {\n    DatabaseMeta dm = meta.getDatabaseMeta();\n\n    String loadAction = meta.getLoadAction();\n\n    StringBuffer contents = new StringBuffer( 500 );\n\n    String tableName =\n      dm.getQuotedSchemaTableCombination(\n        environmentSubstitute( meta.getSchemaName() ), environmentSubstitute( meta.getTableName() ) );\n\n    // Set the date style...\n    //\n    // contents.append(\"SET DATESTYLE ISO;\"); // This is the default but we set it anyway...\n    // contents.append(Const.CR);\n\n    // Create a Postgres / Greenplum COPY string for use with a psql client\n    if ( loadAction.equalsIgnoreCase( \"truncate\" ) ) {\n      contents.append( \"TRUNCATE TABLE \" );\n      contents.append( tableName + \";\" );\n      contents.append( Const.CR );\n    }\n    contents.append( \"COPY \" );\n    // Table name\n\n    contents.append( tableName );\n\n    // Names of columns\n\n    contents.append( \" ( \" );\n\n    String[] streamFields = meta.getFieldStream();\n    String[] tableFields = meta.getFieldTable();\n\n    if ( streamFields == null || streamFields.length == 0 ) {\n      throw new KettleException( \"No fields defined to load to database\" );\n    }\n\n    for ( int i = 0; i < streamFields.length; i++ ) {\n      if ( i != 0 ) {\n        contents.append( \", \" );\n      }\n      contents.append( dm.quoteField( tableFields[i] ) );\n    }\n\n    contents.append( \" ) \" );\n\n    // The \"FROM\" filename\n    contents.append( \" FROM STDIN\" ); // FIFO file\n\n    // The \"FORMAT\" clause\n    contents.append( \" WITH CSV DELIMITER AS '\" ).append( meta.getDelimiter() ).append( \"' QUOTE AS '\" ).append(\n      meta.getEnclosure() ).append( \"'\" );\n    contents.append( \";\" ).append( Const.CR );\n\n    return contents.toString();\n  }","id":42559,"modified_method":"/**\n   * Get the contents of the control file as specified in the meta object\n   *\n   * @param meta\n   *          the meta object to model the control file after\n   *\n   * @return a string containing the control file contents\n   */\n  public String getCopyCommand( RowMetaInterface rm, Object[] r ) throws KettleException {\n    DatabaseMeta dm = meta.getDatabaseMeta();\n\n    String loadAction = environmentSubstitute( meta.getLoadAction() );\n\n    StringBuffer contents = new StringBuffer( 500 );\n\n    String tableName =\n      dm.getQuotedSchemaTableCombination(\n        environmentSubstitute( meta.getSchemaName() ), environmentSubstitute( meta.getTableName() ) );\n\n    // Set the date style...\n    //\n    // contents.append(\"SET DATESTYLE ISO;\"); // This is the default but we set it anyway...\n    // contents.append(Const.CR);\n\n    // Create a Postgres / Greenplum COPY string for use with a psql client\n    if ( loadAction.equalsIgnoreCase( \"truncate\" ) ) {\n      contents.append( \"TRUNCATE TABLE \" );\n      contents.append( tableName + \";\" );\n      contents.append( Const.CR );\n    }\n    contents.append( \"COPY \" );\n    // Table name\n\n    contents.append( tableName );\n\n    // Names of columns\n\n    contents.append( \" ( \" );\n\n    String[] streamFields = meta.getFieldStream();\n    String[] tableFields = meta.getFieldTable();\n\n    if ( streamFields == null || streamFields.length == 0 ) {\n      throw new KettleException( \"No fields defined to load to database\" );\n    }\n\n    for ( int i = 0; i < streamFields.length; i++ ) {\n      if ( i != 0 ) {\n        contents.append( \", \" );\n      }\n      contents.append( dm.quoteField( tableFields[i] ) );\n    }\n\n    contents.append( \" ) \" );\n\n    // The \"FROM\" filename\n    contents.append( \" FROM STDIN\" ); // FIFO file\n\n    // The \"FORMAT\" clause\n    contents.append( \" WITH CSV DELIMITER AS '\" ).append( environmentSubstitute( meta.getDelimiter() ) )\n        .append( \"' QUOTE AS '\" ).append(\n      environmentSubstitute( meta.getEnclosure() ) ).append( \"'\" );\n    contents.append( \";\" ).append( Const.CR );\n\n    return contents.toString();\n  }","commit_id":"e41002b9a6fef6bb4cb5921d8f035119631731d3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getCSV() {\n    InputStream inputStream = null;\n    try {\n      CsvInputMeta meta = new CsvInputMeta();\n      getInfo( meta );\n\n      String filename = transMeta.environmentSubstitute( meta.getFilename() );\n      String delimiter = transMeta.environmentSubstitute( meta.getDelimiter() );\n\n      FileObject fileObject = KettleVFS.getFileObject( filename );\n      if ( !( fileObject instanceof LocalFile ) ) {\n        // We can only use NIO on local files at the moment, so that's what we\n        // limit ourselves to.\n        //\n        throw new KettleException( BaseMessages.getString( PKG, \"CsvInput.Log.OnlyLocalFilesAreSupported\" ) );\n      }\n\n      wFields.table.removeAll();\n\n      inputStream = KettleVFS.getInputStream( fileObject );\n\n      String realEncoding = transMeta.environmentSubstitute( meta.getEncoding() );\n      InputStreamReader reader;\n      if ( Const.isEmpty( realEncoding ) ) {\n        reader = new InputStreamReader( inputStream );\n      } else {\n        reader = new InputStreamReader( inputStream, realEncoding );\n      }\n\n      EncodingType encodingType = EncodingType.guessEncodingType( reader.getEncoding() );\n\n      // Read a line of data to determine the number of rows...\n      //\n      String line =\n        TextFileInput.getLine(\n          log, reader, encodingType, TextFileInputMeta.FILE_FORMAT_MIXED, new StringBuilder( 1000 ) );\n\n      // Split the string, header or data into parts...\n      //\n      String[] fieldNames =\n        CsvInput.guessStringsFromLine( log, line, delimiter, meta.getEnclosure(), meta.getEscapeCharacter() );\n\n      if ( !meta.isHeaderPresent() ) {\n        // Don't use field names from the header...\n        // Generate field names F1 ... F10\n        //\n        DecimalFormat df = new DecimalFormat( \"000\" );\n        for ( int i = 0; i < fieldNames.length; i++ ) {\n          fieldNames[i] = \"Field_\" + df.format( i );\n        }\n      } else {\n        if ( !Const.isEmpty( meta.getEnclosure() ) ) {\n          for ( int i = 0; i < fieldNames.length; i++ ) {\n            if ( fieldNames[i].startsWith( meta.getEnclosure() )\n              && fieldNames[i].endsWith( meta.getEnclosure() ) && fieldNames[i].length() > 1 ) {\n              fieldNames[i] = fieldNames[i].substring( 1, fieldNames[i].length() - 1 );\n            }\n          }\n        }\n      }\n\n      // Trim the names to make sure...\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        fieldNames[i] = Const.trim( fieldNames[i] );\n      }\n\n      // Update the GUI\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        TableItem item = new TableItem( wFields.table, SWT.NONE );\n        item.setText( 1, fieldNames[i] );\n        item.setText( 2, ValueMeta.getTypeDesc( ValueMetaInterface.TYPE_STRING ) );\n      }\n      wFields.removeEmptyRows();\n      wFields.setRowNums();\n      wFields.optWidth( true );\n\n      // Now we can continue reading the rows of data and we can guess the\n      // Sample a few lines to determine the correct type of the fields...\n      //\n      String shellText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogTitle\" );\n      String lineText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogMessage\" );\n      EnterNumberDialog end = new EnterNumberDialog( shell, 100, shellText, lineText );\n      int samples = end.open();\n      if ( samples >= 0 ) {\n        getInfo( meta );\n\n        TextFileCSVImportProgressDialog pd =\n          new TextFileCSVImportProgressDialog( shell, meta, transMeta, reader, samples, true );\n        String message = pd.open();\n        if ( message != null ) {\n          wFields.removeAll();\n\n          // OK, what's the result of our search?\n          getData( meta, false );\n          wFields.removeEmptyRows();\n          wFields.setRowNums();\n          wFields.optWidth( true );\n\n          EnterTextDialog etd =\n            new EnterTextDialog(\n              shell, BaseMessages.getString( PKG, \"CsvInputDialog.ScanResults.DialogTitle\" ), BaseMessages\n                .getString( PKG, \"CsvInputDialog.ScanResults.DialogMessage\" ), message, true );\n          etd.setReadOnly();\n          etd.open();\n\n          // asyncUpdatePreview();\n        }\n      }\n    } catch ( IOException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"CsvInputDialog.IOError.DialogTitle\" ), BaseMessages\n        .getString( PKG, \"CsvInputDialog.IOError.DialogMessage\" ), e );\n    } catch ( KettleException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"System.Dialog.Error.Title\" ), BaseMessages.getString(\n        PKG, \"CsvInputDialog.ErrorGettingFileDesc.DialogMessage\" ), e );\n    } finally {\n      try {\n        inputStream.close();\n      } catch ( Exception e ) {\n        // Ignore close errors\n      }\n    }\n  }","id":42560,"modified_method":"private void getCSV() {\n    InputStream inputStream = null;\n    try {\n      CsvInputMeta meta = new CsvInputMeta();\n      getInfo( meta );\n\n      String filename = transMeta.environmentSubstitute( meta.getFilename() );\n      String delimiter = transMeta.environmentSubstitute( meta.getDelimiter() );\n      String enclosure = transMeta.environmentSubstitute( meta.getEnclosure() );\n\n      FileObject fileObject = KettleVFS.getFileObject( filename );\n      if ( !( fileObject instanceof LocalFile ) ) {\n        // We can only use NIO on local files at the moment, so that's what we\n        // limit ourselves to.\n        //\n        throw new KettleException( BaseMessages.getString( PKG, \"CsvInput.Log.OnlyLocalFilesAreSupported\" ) );\n      }\n\n      wFields.table.removeAll();\n\n      inputStream = KettleVFS.getInputStream( fileObject );\n\n      String realEncoding = transMeta.environmentSubstitute( meta.getEncoding() );\n      InputStreamReader reader;\n      if ( Const.isEmpty( realEncoding ) ) {\n        reader = new InputStreamReader( inputStream );\n      } else {\n        reader = new InputStreamReader( inputStream, realEncoding );\n      }\n\n      EncodingType encodingType = EncodingType.guessEncodingType( reader.getEncoding() );\n\n      // Read a line of data to determine the number of rows...\n      //\n      String line =\n        TextFileInput.getLine(\n          log, reader, encodingType, TextFileInputMeta.FILE_FORMAT_MIXED, new StringBuilder( 1000 ) );\n\n      // Split the string, header or data into parts...\n      //\n      String[] fieldNames =\n        CsvInput.guessStringsFromLine( log, line, delimiter, enclosure, meta.getEscapeCharacter() );\n\n      if ( !meta.isHeaderPresent() ) {\n        // Don't use field names from the header...\n        // Generate field names F1 ... F10\n        //\n        DecimalFormat df = new DecimalFormat( \"000\" );\n        for ( int i = 0; i < fieldNames.length; i++ ) {\n          fieldNames[i] = \"Field_\" + df.format( i );\n        }\n      } else {\n        if ( !Const.isEmpty( meta.getEnclosure() ) ) {\n          for ( int i = 0; i < fieldNames.length; i++ ) {\n            if ( fieldNames[i].startsWith( meta.getEnclosure() )\n              && fieldNames[i].endsWith( meta.getEnclosure() ) && fieldNames[i].length() > 1 ) {\n              fieldNames[i] = fieldNames[i].substring( 1, fieldNames[i].length() - 1 );\n            }\n          }\n        }\n      }\n\n      // Trim the names to make sure...\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        fieldNames[i] = Const.trim( fieldNames[i] );\n      }\n\n      // Update the GUI\n      //\n      for ( int i = 0; i < fieldNames.length; i++ ) {\n        TableItem item = new TableItem( wFields.table, SWT.NONE );\n        item.setText( 1, fieldNames[i] );\n        item.setText( 2, ValueMeta.getTypeDesc( ValueMetaInterface.TYPE_STRING ) );\n      }\n      wFields.removeEmptyRows();\n      wFields.setRowNums();\n      wFields.optWidth( true );\n\n      // Now we can continue reading the rows of data and we can guess the\n      // Sample a few lines to determine the correct type of the fields...\n      //\n      String shellText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogTitle\" );\n      String lineText = BaseMessages.getString( PKG, \"CsvInputDialog.LinesToSample.DialogMessage\" );\n      EnterNumberDialog end = new EnterNumberDialog( shell, 100, shellText, lineText );\n      int samples = end.open();\n      if ( samples >= 0 ) {\n        getInfo( meta );\n\n        TextFileCSVImportProgressDialog pd =\n          new TextFileCSVImportProgressDialog( shell, meta, transMeta, reader, samples, true );\n        String message = pd.open();\n        if ( message != null ) {\n          wFields.removeAll();\n\n          // OK, what's the result of our search?\n          getData( meta, false );\n          wFields.removeEmptyRows();\n          wFields.setRowNums();\n          wFields.optWidth( true );\n\n          EnterTextDialog etd =\n            new EnterTextDialog(\n              shell, BaseMessages.getString( PKG, \"CsvInputDialog.ScanResults.DialogTitle\" ), BaseMessages\n                .getString( PKG, \"CsvInputDialog.ScanResults.DialogMessage\" ), message, true );\n          etd.setReadOnly();\n          etd.open();\n\n          // asyncUpdatePreview();\n        }\n      }\n    } catch ( IOException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"CsvInputDialog.IOError.DialogTitle\" ), BaseMessages\n        .getString( PKG, \"CsvInputDialog.IOError.DialogMessage\" ), e );\n    } catch ( KettleException e ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"System.Dialog.Error.Title\" ), BaseMessages.getString(\n        PKG, \"CsvInputDialog.ErrorGettingFileDesc.DialogMessage\" ), e );\n    } finally {\n      try {\n        inputStream.close();\n      } catch ( Exception e ) {\n        // Ignore close errors\n      }\n    }\n  }","commit_id":"5fbc6b2fac6727fff6f966b4452f01d3cb03b3f9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean writeHeader()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tRowMetaInterface r=data.outputRowMeta;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// If we have fields specified: list them in this order!\r\n\t\t\tif (meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t{\r\n\t\t\t\tString header = \"\";\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n                    String fieldName = meta.getOutputFields()[i].getName();\r\n                    ValueMetaInterface v = r.searchValueMeta(fieldName);\r\n                    \r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\theader+=meta.getSeparator();\r\n\t\t\t\t\t}\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v!=null && v.isString())\r\n                    {\r\n                        header+=meta.getEnclosure();\r\n                    }\r\n\t\t\t\t\theader+=fieldName;\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v!=null && v.isString())\r\n                    {\r\n                        header+=meta.getEnclosure();\r\n                    }\r\n\t\t\t\t}\r\n\t\t\t\theader+=meta.getNewline();\r\n                data.writer.write(getBinaryString(header));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif (r!=null)  // Just put all field names in the header/footer\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<r.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\t\t\t\tValueMetaInterface v = r.getValueMeta(i);\r\n\t\t\t\t\t\r\n                    // Header-value contains the name of the value\r\n\t\t\t\t\tValueMetaInterface header_value = new ValueMeta(v.getName(), ValueMetaInterface.TYPE_STRING);\r\n\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n                    data.writer.write(getBinaryString(header_value.getName()));\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n                data.writer.write(getBinaryString(\"no rows selected\"+Const.CR));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing header line: \"+e.toString());\r\n            logError(Const.getStackTracker(e));\r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tlinesOutput++;\r\n\t\treturn retval;\r\n\t}","id":42561,"modified_method":"private boolean writeHeader()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tRowMetaInterface r=data.outputRowMeta;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\t// If we have fields specified: list them in this order!\r\n\t\t\tif (meta.getOutputFields()!=null && meta.getOutputFields().length>0)\r\n\t\t\t{\r\n\t\t\t\tString header = \"\";\r\n\t\t\t\tfor (int i=0;i<meta.getOutputFields().length;i++)\r\n\t\t\t\t{\r\n                    String fieldName = meta.getOutputFields()[i].getName();\r\n                    ValueMetaInterface v = r.searchValueMeta(fieldName);\r\n                    \r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\theader+=environmentSubstitute(meta.getSeparator());\r\n\t\t\t\t\t}\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v!=null && v.isString())\r\n                    {\r\n                        header+=environmentSubstitute(meta.getEnclosure());\r\n                    }\r\n\t\t\t\t\theader+=fieldName;\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v!=null && v.isString())\r\n                    {\r\n                        header+=environmentSubstitute(meta.getEnclosure());\r\n                    }\r\n\t\t\t\t}\r\n\t\t\t\theader+=meta.getNewline();\r\n                data.writer.write(getBinaryString(header));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\tif (r!=null)  // Just put all field names in the header/footer\r\n\t\t\t{\r\n\t\t\t\tfor (int i=0;i<r.size();i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (i>0 && meta.getSeparator()!=null && meta.getSeparator().length()>0)\r\n\t\t\t\t\t\tdata.writer.write(data.binarySeparator);\r\n\t\t\t\t\tValueMetaInterface v = r.getValueMeta(i);\r\n\t\t\t\t\t\r\n                    // Header-value contains the name of the value\r\n\t\t\t\t\tValueMetaInterface header_value = new ValueMeta(v.getName(), ValueMetaInterface.TYPE_STRING);\r\n\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n                    data.writer.write(getBinaryString(header_value.getName()));\r\n                    if (meta.isEnclosureForced() && meta.getEnclosure()!=null && v.isString())\r\n                    {\r\n                        data.writer.write(data.binaryEnclosure);\r\n                    }\r\n\t\t\t\t}\r\n                data.writer.write(data.binaryNewline);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n                data.writer.write(getBinaryString(\"no rows selected\"+Const.CR));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error writing header line: \"+e.toString());\r\n            logError(Const.getStackTracker(e));\r\n\t\t\tretval=true;\r\n\t\t}\r\n\t\tlinesOutput++;\r\n\t\treturn retval;\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public synchronized boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tboolean result=true;\r\n\t\tboolean bEndedLineWrote=false;\r\n\t\tObject[] r=getRow();       // This also waits for a row to be finished.\r\n\r\n        if (r!=null && first)\r\n        {\r\n            first=false;\r\n            data.outputRowMeta = getInputRowMeta().clone();\r\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n            \r\n            if(meta.isDoNotOpenNewFileInit())\r\n            {\r\n            \t// Open a new file here\r\n            \tif (openNewFile())\r\n\t\t\t\t{\r\n            \t\tdata.oneFileOpened=true;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tsetSettings();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\t\t\t\tlogError(\"Encoding problem: \"+e.toString());\r\n\t\t\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\r\n            \t\r\n            }\r\n            \r\n            if (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) // See if we have to write a header-line)\r\n            {\r\n                if (meta.isHeaderEnabled() && data.outputRowMeta!=null)\r\n                {\r\n                    writeHeader();\r\n                }\r\n            }\r\n            \r\n            data.fieldnrs=new int[meta.getOutputFields().length];\r\n            for (int i=0;i<meta.getOutputFields().length;i++)\r\n            {\r\n                data.fieldnrs[i]=data.outputRowMeta.indexOfValue(meta.getOutputFields()[i].getName());\r\n                if (data.fieldnrs[i]<0)\r\n                {\r\n                    throw new KettleStepException(\"Field [\"+meta.getOutputFields()[i].getName()+\"] couldn't be found in the input stream!\");\r\n                }\r\n            }\r\n        }\r\n\r\n\t\tif ( ( r==null && data.outputRowMeta!=null && meta.isFooterEnabled() ) ||\r\n\t\t     ( r!=null && linesOutput>0 && meta.getSplitEvery()>0 && ((linesOutput+1)%meta.getSplitEvery())==0)\r\n\t\t   )\r\n\t\t{\r\n\t\t\tif (data.outputRowMeta!=null) \r\n\t\t\t{\r\n\t\t\t   if ( meta.isFooterEnabled() )\r\n\t\t\t   {\r\n\t\t\t      writeHeader();\r\n\t\t\t   }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (r==null)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t// Done with this part or with everything.\r\n\t\t\tcloseFile();\r\n\t\t\t\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (meta.isHeaderEnabled() && data.outputRowMeta!=null) if (writeHeader()) linesOutput++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tif (false==bEndedLineWrote)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\twriteRowToFile(data.outputRowMeta, r);\r\n\t\tputRow(data.outputRowMeta, r);       // in case we want it to go further...\r\n\t\t\r\n        if (checkFeedback(linesOutput)) logBasic(\"linenr \"+linesOutput);\r\n\t\t\r\n\t\treturn result;\r\n\t}","id":42562,"modified_method":"public synchronized boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tboolean result=true;\r\n\t\tboolean bEndedLineWrote=false;\r\n\t\tObject[] r=getRow();       // This also waits for a row to be finished.\r\n\r\n        if (r!=null && first)\r\n        {\r\n            first=false;\r\n            data.outputRowMeta = getInputRowMeta().clone();\r\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\r\n            \r\n            //if file name in field is enabled then set field name and open file\r\n          if(meta.isFileNameInField()){\r\n            \t\r\n\t\t\t\t// get the first input row set (assume only one)\r\n\t\t\t\tRowSet zero = (RowSet)inputRowSets.get(0);\r\n\t\t\t\tRowMetaInterface inputRowMeta = zero.getRowMeta();\r\n\t\t\t\t//find and set index of file name field in input stream\r\n\t\t\t\tdata.fileNameFieldIndex = inputRowMeta.indexOfValue(meta.getFileNameField());\t\r\n\t\t\t\t//set the file name for this row\r\n\t\t\t\tString fileName = \"\";\r\n\t\t\t\tif(data.fileNameFieldIndex != -1){\r\n\t\t\t\t\tfileName = (String) r[data.fileNameFieldIndex];\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t throw new KettleStepException(\"File name field [\"+meta.getFileNameField()+\"] couldn't be found in the input stream!\");\r\n\t\t\t\t}\r\n            \t\r\n            \t//open new file only if new file name\r\n            \tmeta.setFileName(fileName);\r\n            \r\n            \t// Open a new file here\r\n            \tif (openNewFile())\r\n\t\t\t\t{\r\n            \t\tdata.oneFileOpened=true;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tsetSettings();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\t\t\t\tlogError(\"Encoding problem: \"+e.toString());\r\n\t\t\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//mark file as previously opened\r\n\t            \tdata.previouslyOpenedFiles.add(buildFilename(true));\r\n\t\t\t\t}\r\n            \t\r\n            }\r\n          \r\n          if(meta.isDoNotOpenNewFileInit()&& !meta.isFileNameInField())\r\n          {\r\n        \t  // Open a new file here\r\n        \t  if (openNewFile())\r\n        \t  {\r\n        \t\t  data.oneFileOpened=true;\r\n        \t\t  try {\r\n        \t\t\t  setSettings();\r\n\t\t\t\r\n        \t\t  } catch (UnsupportedEncodingException e) {\r\n        \t\t\t  logError(\"Encoding problem: \"+e.toString());\r\n        \t\t\t  logError(Const.getStackTracker(e));\r\n        \t\t\t  return false;\r\n        \t\t  }\r\n        \t  }\t\r\n          }\t\r\n            \r\n            if (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) // See if we have to write a header-line)\r\n            {\r\n                if (meta.isHeaderEnabled() && data.outputRowMeta!=null)\r\n                {\r\n                    writeHeader();\r\n                }\r\n            }\r\n            \r\n            data.fieldnrs=new int[meta.getOutputFields().length];\r\n            for (int i=0;i<meta.getOutputFields().length;i++)\r\n            {\r\n                data.fieldnrs[i]=data.outputRowMeta.indexOfValue(meta.getOutputFields()[i].getName());\r\n                if (data.fieldnrs[i]<0)\r\n                {\r\n                    throw new KettleStepException(\"Field [\"+meta.getOutputFields()[i].getName()+\"] couldn't be found in the input stream!\");\r\n                }\r\n            }\r\n        }\r\n\r\n\t\tif ( ( r==null && data.outputRowMeta!=null && meta.isFooterEnabled() ) ||\r\n\t\t     ( r!=null && linesOutput>0 && meta.getSplitEvery()>0 && ((linesOutput+1)%meta.getSplitEvery())==0)\r\n\t\t   )\r\n\t\t{\r\n\t\t\tif (data.outputRowMeta!=null) \r\n\t\t\t{\r\n\t\t\t   if ( meta.isFooterEnabled() )\r\n\t\t\t   {\r\n\t\t\t      writeHeader();\r\n\t\t\t   }\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (r==null)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t// Done with this part or with everything.\r\n\t\t\tcloseFile();\r\n\t\t\t\r\n\t\t\t// Not finished: open another file...\r\n\t\t\tif (r!=null)\r\n\t\t\t{\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file (split #\"+data.splitnr+\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (meta.isHeaderEnabled() && data.outputRowMeta!=null) if (writeHeader()) linesOutput++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (r==null)  // no more input to be expected...\r\n\t\t{\r\n\t\t\tif (false==bEndedLineWrote)\r\n\t\t\t{\r\n\t\t\t\t//add tag to last line if needed\r\n\t\t\t\twriteEndedLine();\r\n\t\t\t\tbEndedLineWrote=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsetOutputDone();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t//first handle if file name in field\r\n\t\tif(meta.isFileNameInField()){\r\n\t\t\tString fileName = (String) r[data.fileNameFieldIndex];\r\n\t\t\t\r\n\t\t\tif (! meta.getFileName().equals(fileName)){\r\n\t\t\t\t//close current file\r\n\t\t\t\tcloseFile();\r\n\t\t\t\tmeta.setFileName(fileName);\r\n\t\t\t\tif (!openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Unable to open new file \"+ fileName +\"...\");\r\n\t\t\t\t\tsetErrors(1);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif(!checkPreviouslyOpened(buildFilename(true))){\r\n\t\t\t\t\tdata.previouslyOpenedFiles.add(buildFilename(true));\r\n\t\t\t\t\tif (!meta.isFileAppended() && ( meta.isHeaderEnabled() || meta.isFooterEnabled())) if (writeHeader()) linesOutput++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteRowToFile(data.outputRowMeta, r);\r\n\t\tputRow(data.outputRowMeta, r);       // in case we want it to go further...\r\n\t\t\r\n        if (checkFeedback(linesOutput)) logBasic(\"linenr \"+linesOutput);\r\n\t\t\r\n\t\treturn result;\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean openNewFile()\r\n\t{\r\n\t\tboolean retval=false;\r\n\t\tdata.writer=null;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n            if (meta.isFileAsCommand())\r\n            {\r\n            \tif(log.isDebug()) logDebug(\"Spawning external process\");\r\n            \tif (data.cmdProc != null)\r\n            \t{\r\n            \t\tlogError(\"Previous command not correctly terminated\");\r\n            \t\tsetErrors(1);\r\n            \t}\r\n            \tString cmdstr = environmentSubstitute(meta.getFileName());\r\n            \tif (Const.getOS().equals(\"Windows 95\"))\r\n                {\r\n            \t\tcmdstr = \"command.com /C \" + cmdstr;\r\n                }\r\n            \telse\r\n                {\r\n                    if (Const.getOS().startsWith(\"Windows\"))\r\n                    {\r\n                        cmdstr = \"cmd.exe /C \" + cmdstr;\r\n                    }\r\n                }\r\n            \tif(log.isDebug()) logDetailed(\"Starting: \" + cmdstr);\r\n            \tRuntime r = Runtime.getRuntime();\r\n            \tdata.cmdProc = r.exec(cmdstr, EnvUtil.getEnvironmentVariablesForRuntimeExec());\r\n            \tdata.writer = data.cmdProc.getOutputStream();\r\n            \tStreamLogger stdoutLogger = new StreamLogger( data.cmdProc.getInputStream(), \"(stdout)\" );\r\n            \tStreamLogger stderrLogger = new StreamLogger( data.cmdProc.getErrorStream(), \"(stderr)\" );\r\n            \tnew Thread(stdoutLogger).start();\r\n            \tnew Thread(stderrLogger).start();\r\n            \tretval = true;\r\n            }\r\n            else\r\n            {\r\n                String filename = buildFilename(true);\r\n                if(meta.isAddToResultFiles())\r\n                {\r\n\t\t\t\t\t// Add this to the result file names...\r\n\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename), getTransMeta().getName(), getStepname());\r\n\t\t\t\t\tresultFile.setComment(\"This file was created with a text file output step\");\r\n\t\t            addResultFile(resultFile);\r\n                }\r\n\t\r\n\t            OutputStream outputStream;\r\n                \r\n                if (!Const.isEmpty(meta.getFileCompression()) && !meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_NONE))\r\n                {\r\n    \t\t\t\tif (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_ZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in zipped mode\");\r\n                        \r\n                        data.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n                        data.zip = new ZipOutputStream(data.fos);\r\n    \t\t\t\t\tFile entry = new File(buildFilename(false));\r\n    \t\t\t\t\tZipEntry zipentry = new ZipEntry(entry.getName());\r\n    \t\t\t\t\tzipentry.setComment(\"Compressed by Kettle\");\r\n    \t\t\t\t\tdata.zip.putNextEntry(zipentry);\r\n    \t\t\t\t\toutputStream=data.zip;\r\n    \t\t\t\t}\r\n    \t\t\t\telse if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_GZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in gzipped mode\");\r\n                        data.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n                        data.gzip = new GZIPOutputStream(data.fos);\r\n    \t\t\t\t\toutputStream=data.gzip;\r\n    \t\t\t\t}\r\n                    else\r\n                    {\r\n                        throw new KettleFileException(\"No compression method specified!\");\r\n                    }\r\n                }\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in nocompress mode\");\r\n                    data.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n                    outputStream=data.fos;\r\n\t\t\t\t}\r\n                \r\n\t            if (!Const.isEmpty(meta.getEncoding()))\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in encoding: \"+meta.getEncoding());\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t            else\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in default encoding\");\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t\r\n\t            if(log.isDetailed()) logDetailed(\"Opened new file with name [\"+filename+\"]\");\r\n\t\t\t\t\r\n\t\t\t\tretval=true;\r\n            }\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error opening new file : \"+e.toString());\r\n\t\t}\r\n\t\t// System.out.println(\"end of newFile(), splitnr=\"+splitnr);\r\n\r\n\t\tdata.splitnr++;\r\n\r\n\t\treturn retval;\r\n\t}","id":42563,"modified_method":"public boolean openNewFile()\r\n\t{\r\n\t\t//No need to run if first line and File name in field is set\r\n\t\tif(first && meta.isFileNameInField()) return false;\r\n\t\t\r\n\t\tboolean retval=false;\r\n\t\tdata.writer=null;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n            if (meta.isFileAsCommand())\r\n            {\r\n            \tif(log.isDebug()) logDebug(\"Spawning external process\");\r\n            \tif (data.cmdProc != null)\r\n            \t{\r\n            \t\tlogError(\"Previous command not correctly terminated\");\r\n            \t\tsetErrors(1);\r\n            \t}\r\n            \tString cmdstr = environmentSubstitute(meta.getFileName());\r\n            \tif (Const.getOS().equals(\"Windows 95\"))\r\n                {\r\n            \t\tcmdstr = \"command.com /C \" + cmdstr;\r\n                }\r\n            \telse\r\n                {\r\n                    if (Const.getOS().startsWith(\"Windows\"))\r\n                    {\r\n                        cmdstr = \"cmd.exe /C \" + cmdstr;\r\n                    }\r\n                }\r\n            \tif(log.isDebug()) logDetailed(\"Starting: \" + cmdstr);\r\n            \tRuntime r = Runtime.getRuntime();\r\n            \tdata.cmdProc = r.exec(cmdstr, EnvUtil.getEnvironmentVariablesForRuntimeExec());\r\n            \tdata.writer = data.cmdProc.getOutputStream();\r\n            \tStreamLogger stdoutLogger = new StreamLogger( data.cmdProc.getInputStream(), \"(stdout)\" );\r\n            \tStreamLogger stderrLogger = new StreamLogger( data.cmdProc.getErrorStream(), \"(stderr)\" );\r\n            \tnew Thread(stdoutLogger).start();\r\n            \tnew Thread(stderrLogger).start();\r\n            \tretval = true;\r\n            }\r\n            else\r\n            {\r\n                String filename = buildFilename(true);\r\n                if(meta.isAddToResultFiles())\r\n                {\r\n\t\t\t\t\t// Add this to the result file names...\r\n\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(filename), getTransMeta().getName(), getStepname());\r\n\t\t\t\t\tresultFile.setComment(\"This file was created with a text file output step\");\r\n\t\t            addResultFile(resultFile);\r\n                }\r\n\t\r\n\t            OutputStream outputStream;\r\n                \r\n                if (!Const.isEmpty(meta.getFileCompression()) && !meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_NONE))\r\n                {\r\n    \t\t\t\tif (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_ZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in zipped mode\");\r\n                        \r\n    \t\t            if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                        data.zip = new ZipOutputStream(data.fos);\r\n    \t\t\t\t\tFile entry = new File(buildFilename(false));\r\n    \t\t\t\t\tZipEntry zipentry = new ZipEntry(entry.getName());\r\n    \t\t\t\t\tzipentry.setComment(\"Compressed by Kettle\");\r\n    \t\t\t\t\tdata.zip.putNextEntry(zipentry);\r\n    \t\t\t\t\toutputStream=data.zip;\r\n    \t\t\t\t}\r\n    \t\t\t\telse if (meta.getFileCompression().equals(FILE_COMPRESSION_TYPE_GZIP))\r\n    \t\t\t\t{\r\n    \t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in gzipped mode\");\r\n    \t\t            if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                        data.gzip = new GZIPOutputStream(data.fos);\r\n    \t\t\t\t\toutputStream=data.gzip;\r\n    \t\t\t\t}\r\n                    else\r\n                    {\r\n                        throw new KettleFileException(\"No compression method specified!\");\r\n                    }\r\n                }\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"Opening output stream in nocompress mode\");\r\n                    if(checkPreviouslyOpened(filename)){\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, true);\r\n    \t\t            }else{\r\n    \t\t            \tdata.fos = KettleVFS.getOutputStream(filename, meta.isFileAppended());\r\n    \t\t            }\r\n                    outputStream=data.fos;\r\n\t\t\t\t}\r\n                \r\n\t            if (!Const.isEmpty(meta.getEncoding()))\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in encoding: \"+meta.getEncoding());\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t            else\r\n\t            {\r\n\t            \tif(log.isBasic()) log.logBasic(toString(), \"Opening output stream in default encoding\");\r\n\t                data.writer = new BufferedOutputStream(outputStream, 5000);\r\n\t            }\r\n\t\r\n\t            if(log.isDetailed()) logDetailed(\"Opened new file with name [\"+filename+\"]\");\r\n\t\t\t\t\r\n\t\t\t\tretval=true;\r\n            }\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(\"Error opening new file : \"+e.toString());\r\n\t\t}\r\n\t\t// System.out.println(\"end of newFile(), splitnr=\"+splitnr);\r\n\r\n\t\tdata.splitnr++;\r\n\r\n\t\treturn retval;\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\tdata.splitnr=0;\r\n\t\t\t// In case user want to create file at first row\r\n\t\t\t// In that case, DO NOT create file at Init\r\n\t\t\tif(!meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\tif (openNewFile())\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.oneFileOpened=true;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tsetSettings();\r\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\t\t\t\tlogError(\"Encoding problem: \"+e.toString());\r\n\t\t\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Couldn't open file \"+meta.getFileName());\r\n\t\t\t\t\tsetErrors(1L);\r\n\t\t\t\t\tstopAll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\r\n\t\treturn false;\r\n\t}","id":42564,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\r\n\t{\r\n\t\tmeta=(TextFileOutputMeta)smi;\r\n\t\tdata=(TextFileOutputData)sdi;\r\n\r\n\t\tif (super.init(smi, sdi))\r\n\t\t{\r\n\t\t\tdata.splitnr=0;\r\n\t\t\t// In case user want to create file at first row\r\n\t\t\t// In that case, DO NOT create file at Init\r\n\t\t\tif(!meta.isDoNotOpenNewFileInit())\r\n\t\t\t{\r\n\t\t\t\tif (openNewFile()||meta.isFileNameInField())\r\n\t\t\t\t{\r\n\t\t\t\t\tdata.oneFileOpened=true;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tsetSettings();\r\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\t\t\t\tlogError(\"Encoding problem: \"+e.toString());\r\n\t\t\t\t\t\tlogError(Const.getStackTracker(e));\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\t\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlogError(\"Couldn't open file \"+meta.getFileName());\r\n\t\t\t\t\tsetErrors(1L);\r\n\t\t\t\t\tstopAll();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\r\n\t\treturn false;\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * \r\n\t */\r\n\tpublic TextFileOutputData()\r\n\t{\r\n\t\tsuper();\r\n\t\t\r\n\t\tnf = NumberFormat.getInstance();\r\n\t\tdf = (DecimalFormat)nf;\r\n\t\tdfs=new DecimalFormatSymbols();\r\n\r\n\t\tdaf = new SimpleDateFormat();\r\n\t\tdafs= new DateFormatSymbols();\r\n        \r\n        defaultDecimalFormat = (DecimalFormat)NumberFormat.getInstance();\r\n        defaultDecimalFormatSymbols =  new DecimalFormatSymbols();\r\n\r\n        defaultDateFormat = new SimpleDateFormat();\r\n        defaultDateFormatSymbols = new DateFormatSymbols();\r\n\r\n        cmdProc = null;\r\n        oneFileOpened=false;\r\n\t}","id":42565,"modified_method":"/**\r\n\t * \r\n\t */\r\n\tpublic TextFileOutputData()\r\n\t{\r\n\t\tsuper();\r\n\t\t\r\n\t\tnf = NumberFormat.getInstance();\r\n\t\tdf = (DecimalFormat)nf;\r\n\t\tdfs=new DecimalFormatSymbols();\r\n\r\n\t\tdaf = new SimpleDateFormat();\r\n\t\tdafs= new DateFormatSymbols();\r\n        \r\n        defaultDecimalFormat = (DecimalFormat)NumberFormat.getInstance();\r\n        defaultDecimalFormatSymbols =  new DecimalFormatSymbols();\r\n\r\n        defaultDateFormat = new SimpleDateFormat();\r\n        defaultDateFormatSymbols = new DateFormatSymbols();\r\n        \r\n        previouslyOpenedFiles = new ArrayList<String>();\r\n        fileNameFieldIndex = -1;\r\n\r\n        cmdProc = null;\r\n        oneFileOpened=false;\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getInfo(TextFileOutputMeta tfoi)\r\n\t{\r\n\t\ttfoi.setFileName(   wFilename.getText() );\r\n\t\ttfoi.setFileAsCommand( wFileIsCommand.getSelection() );\r\n\t\ttfoi.setDoNotOpenNewFileInit(wDoNotOpenNewFileInit.getSelection() );\r\n\t\ttfoi.setFileFormat( wFormat.getText() );\r\n\t\ttfoi.setFileCompression( wCompression.getText() );\r\n        tfoi.setEncoding( wEncoding.getText() );\r\n\t\ttfoi.setSeparator(  wSeparator.getText() );\r\n\t\ttfoi.setEnclosure(  wEnclosure.getText() );\r\n\t\ttfoi.setExtension(  wExtension.getText() );\r\n\t\ttfoi.setSplitEvery( Const.toInt(wSplitEvery.getText(), 0) );\r\n\t\ttfoi.setEndedLine( wEndedLine.getText() );\r\n\r\n        tfoi.setEnclosureForced( wEnclForced.getSelection() ); \r\n\t\ttfoi.setHeaderEnabled( wHeader.getSelection() ); \r\n\t\ttfoi.setFooterEnabled( wFooter.getSelection() );\r\n\t\ttfoi.setFileAppended( wAppend.getSelection() );\r\n\t\ttfoi.setStepNrInFilename( wAddStepnr.getSelection() );\r\n\t\ttfoi.setPartNrInFilename( wAddPartnr.getSelection() );\r\n\t\ttfoi.setDateInFilename( wAddDate.getSelection() );\r\n\t\ttfoi.setTimeInFilename( wAddTime.getSelection() );\r\n\t\ttfoi.setDateTimeFormat(wDateTimeFormat.getText());\r\n\t\ttfoi.setSpecifyFormat(wSpecifyFormat.getSelection());\r\n\t\ttfoi.setPadded( wPad.getSelection() );\r\n\t\ttfoi.setAddToResultFiles( wAddToResult.getSelection() );\r\n\t\ttfoi.setFastDump( wFastDump.getSelection() );\r\n\r\n\t\tint i;\r\n\t\t//Table table = wFields.table;\r\n\t\t\r\n\t\tint nrfields = wFields.nrNonEmpty();\r\n\r\n\t\ttfoi.allocate(nrfields);\r\n\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t    TextFileField field = new TextFileField();\r\n\t\t    \r\n\t\t\tTableItem item = wFields.getNonEmpty(i);\r\n\t\t\tfield.setName( item.getText(1) );\r\n\t\t\tfield.setType( item.getText(2) );\r\n\t\t\tfield.setFormat( item.getText(3) );\r\n\t\t\tfield.setLength( Const.toInt(item.getText(4), -1) );\r\n\t\t\tfield.setPrecision( Const.toInt(item.getText(5), -1) );\r\n\t\t\tfield.setCurrencySymbol( item.getText(6) );\r\n\t\t\tfield.setDecimalSymbol( item.getText(7) );\r\n\t\t\tfield.setGroupingSymbol( item.getText(8) );\r\n\t\t\tfield.setTrimType( ValueMeta.getTrimTypeByDesc(item.getText(9)));\r\n\t\t\tfield.setNullString( item.getText(10) );\r\n\t\t\ttfoi.getOutputFields()[i]  = field;\r\n\t\t}\r\n\t}","id":42566,"modified_method":"private void getInfo(TextFileOutputMeta tfoi)\r\n\t{\r\n\t\ttfoi.setFileName(   wFilename.getText() );\r\n\t\ttfoi.setFileAsCommand( wFileIsCommand.getSelection() );\r\n\t\ttfoi.setDoNotOpenNewFileInit(wDoNotOpenNewFileInit.getSelection() );\r\n\t\ttfoi.setFileFormat( wFormat.getText() );\r\n\t\ttfoi.setFileCompression( wCompression.getText() );\r\n        tfoi.setEncoding( wEncoding.getText() );\r\n\t\ttfoi.setSeparator(  wSeparator.getText() );\r\n\t\ttfoi.setEnclosure(  wEnclosure.getText() );\r\n\t\ttfoi.setExtension(  wExtension.getText() );\r\n\t\ttfoi.setSplitEvery( Const.toInt(wSplitEvery.getText(), 0) );\r\n\t\ttfoi.setEndedLine( wEndedLine.getText() );\r\n\t\t\r\n\t\ttfoi.setFileNameField(   wFileNameField.getText() );\r\n\t\ttfoi.setFileNameInField( wFileNameInField.getSelection() );\r\n\r\n        tfoi.setEnclosureForced( wEnclForced.getSelection() ); \r\n\t\ttfoi.setHeaderEnabled( wHeader.getSelection() ); \r\n\t\ttfoi.setFooterEnabled( wFooter.getSelection() );\r\n\t\ttfoi.setFileAppended( wAppend.getSelection() );\r\n\t\ttfoi.setStepNrInFilename( wAddStepnr.getSelection() );\r\n\t\ttfoi.setPartNrInFilename( wAddPartnr.getSelection() );\r\n\t\ttfoi.setDateInFilename( wAddDate.getSelection() );\r\n\t\ttfoi.setTimeInFilename( wAddTime.getSelection() );\r\n\t\ttfoi.setDateTimeFormat(wDateTimeFormat.getText());\r\n\t\ttfoi.setSpecifyFormat(wSpecifyFormat.getSelection());\r\n\t\ttfoi.setPadded( wPad.getSelection() );\r\n\t\ttfoi.setAddToResultFiles( wAddToResult.getSelection() );\r\n\t\ttfoi.setFastDump( wFastDump.getSelection() );\r\n\r\n\t\tint i;\r\n\t\t//Table table = wFields.table;\r\n\t\t\r\n\t\tint nrfields = wFields.nrNonEmpty();\r\n\r\n\t\ttfoi.allocate(nrfields);\r\n\t\t\r\n\t\tfor (i=0;i<nrfields;i++)\r\n\t\t{\r\n\t\t    TextFileField field = new TextFileField();\r\n\t\t    \r\n\t\t\tTableItem item = wFields.getNonEmpty(i);\r\n\t\t\tfield.setName( item.getText(1) );\r\n\t\t\tfield.setType( item.getText(2) );\r\n\t\t\tfield.setFormat( item.getText(3) );\r\n\t\t\tfield.setLength( Const.toInt(item.getText(4), -1) );\r\n\t\t\tfield.setPrecision( Const.toInt(item.getText(5), -1) );\r\n\t\t\tfield.setCurrencySymbol( item.getText(6) );\r\n\t\t\tfield.setDecimalSymbol( item.getText(7) );\r\n\t\t\tfield.setGroupingSymbol( item.getText(8) );\r\n\t\t\tfield.setTrimType( ValueMeta.getTrimTypeByDesc(item.getText(9)));\r\n\t\t\tfield.setNullString( item.getText(10) );\r\n\t\t\ttfoi.getOutputFields()[i]  = field;\r\n\t\t}\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * Copy information from the meta-data input to the dialog fields.\r\n\t */ \r\n\tpublic void getData()\r\n\t{\r\n\t\tif (input.getFileName()  != null) wFilename.setText(input.getFileName());\r\n\t\twFileIsCommand.setSelection(input.isFileAsCommand());\r\n\t\twDoNotOpenNewFileInit.setSelection(input.isDoNotOpenNewFileInit());\r\n\t\tif (input.getExtension() != null) wExtension.setText(input.getExtension());\r\n\t\tif (input.getSeparator() !=null) wSeparator.setText(input.getSeparator());\r\n\t\tif (input.getEnclosure() !=null) wEnclosure.setText(input.getEnclosure());\r\n\t\tif (input.getFileFormat()!=null) wFormat.setText(input.getFileFormat());\r\n\t\tif (input.getFileCompression()!=null) wCompression.setText(input.getFileCompression());\r\n        if (input.getEncoding()  !=null) wEncoding.setText(input.getEncoding());\r\n        if (input.getEndedLine() !=null) wEndedLine.setText(input.getEndedLine());\r\n        \r\n\t\twSplitEvery.setText(\"\"+input.getSplitEvery());\r\n\r\n        wEnclForced.setSelection(input.isEnclosureForced());\r\n\t\twHeader.setSelection(input.isHeaderEnabled());\r\n\t\twFooter.setSelection(input.isFooterEnabled());\r\n\t\twAddDate.setSelection(input.isDateInFilename());\r\n\t\twAddTime.setSelection(input.isTimeInFilename());\r\n\t\tif (input.getDateTimeFormat()!= null) wDateTimeFormat.setText( input.getDateTimeFormat() );\r\n\t\twSpecifyFormat.setSelection(input.isSpecifyFormat());\r\n\t\t\r\n\t\twAppend.setSelection(input.isFileAppended());\r\n\t\twAddStepnr.setSelection(input.isStepNrInFilename());\r\n\t\twAddPartnr.setSelection(input.isPartNrInFilename());\r\n\t\twPad.setSelection(input.isPadded());\r\n\t\twFastDump.setSelection(input.isFastDump());\r\n\t\twAddToResult.setSelection(input.isAddToResultFiles());\r\n\t\t\t\t\r\n\t\tlog.logDebug(toString(), \"getting fields info...\");\r\n\t\t\r\n\t\tfor (int i=0;i<input.getOutputFields().length;i++)\r\n\t\t{\r\n\t\t    TextFileField field = input.getOutputFields()[i];\r\n\t\t    \r\n\t\t\tTableItem item = wFields.table.getItem(i);\r\n\t\t\tif (field.getName()!=null) item.setText(1, field.getName());\r\n\t\t\titem.setText(2, field.getTypeDesc());\r\n\t\t\tif (field.getFormat()!=null) item.setText(3, field.getFormat());\r\n\t\t\tif (field.getLength()!=-1) item.setText(4, \"\"+field.getLength());\r\n\t\t\tif (field.getPrecision()!=-1) item.setText(5, \"\"+field.getPrecision());\r\n\t\t\tif (field.getCurrencySymbol()!=null) item.setText(6, field.getCurrencySymbol());\r\n\t\t\tif (field.getDecimalSymbol()!=null) item.setText(7, field.getDecimalSymbol());\r\n\t\t\tif (field.getGroupingSymbol()!=null) item.setText(8, field.getGroupingSymbol());\r\n\t\t\tString trim = field.getTrimTypeDesc();\r\n\t\t\tif (trim != null) item.setText(9, trim);\r\n\t\t\tif (field.getNullString()!=null) item.setText(10, field.getNullString());\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\twFields.optWidth(true);\r\n\t\twStepname.selectAll();\r\n\t}","id":42567,"modified_method":"/**\r\n\t * Copy information from the meta-data input to the dialog fields.\r\n\t */ \r\n\tpublic void getData()\r\n\t{\r\n\t\tif (input.getFileName()  != null) wFilename.setText(input.getFileName());\r\n\t\twFileIsCommand.setSelection(input.isFileAsCommand());\r\n\t\twDoNotOpenNewFileInit.setSelection(input.isDoNotOpenNewFileInit());\r\n\t\tif (input.getExtension() != null) wExtension.setText(input.getExtension());\r\n\t\tif (input.getSeparator() !=null) wSeparator.setText(input.getSeparator());\r\n\t\tif (input.getEnclosure() !=null) wEnclosure.setText(input.getEnclosure());\r\n\t\tif (input.getFileFormat()!=null) wFormat.setText(input.getFileFormat());\r\n\t\tif (input.getFileCompression()!=null) wCompression.setText(input.getFileCompression());\r\n        if (input.getEncoding()  !=null) wEncoding.setText(input.getEncoding());\r\n        if (input.getEndedLine() !=null) wEndedLine.setText(input.getEndedLine());\r\n        \r\n        wFileNameInField.setSelection(input.isFileNameInField());\r\n        if (input.getFileNameField() !=null) wFileNameField.setText(input.getFileNameField());\r\n        if(input.isFileNameInField()){\r\n        \twFileNameField.setEnabled(true);\r\n        \twbFilename.setEnabled(false);\r\n    \t\twFilename.setEnabled(false);\r\n    \t\twFileIsCommand.setEnabled(false);\r\n    \t\twbShowFiles.setEnabled(false);\r\n        }\r\n        \r\n\t\twSplitEvery.setText(\"\"+input.getSplitEvery());\r\n\r\n        wEnclForced.setSelection(input.isEnclosureForced());\r\n\t\twHeader.setSelection(input.isHeaderEnabled());\r\n\t\twFooter.setSelection(input.isFooterEnabled());\r\n\t\twAddDate.setSelection(input.isDateInFilename());\r\n\t\twAddTime.setSelection(input.isTimeInFilename());\r\n\t\tif (input.getDateTimeFormat()!= null) wDateTimeFormat.setText( input.getDateTimeFormat() );\r\n\t\twSpecifyFormat.setSelection(input.isSpecifyFormat());\r\n\t\t\r\n\t\twAppend.setSelection(input.isFileAppended());\r\n\t\twAddStepnr.setSelection(input.isStepNrInFilename());\r\n\t\twAddPartnr.setSelection(input.isPartNrInFilename());\r\n\t\twPad.setSelection(input.isPadded());\r\n\t\twFastDump.setSelection(input.isFastDump());\r\n\t\twAddToResult.setSelection(input.isAddToResultFiles());\r\n\t\t\t\t\r\n\t\tlog.logDebug(toString(), \"getting fields info...\");\r\n\t\t\r\n\t\tfor (int i=0;i<input.getOutputFields().length;i++)\r\n\t\t{\r\n\t\t    TextFileField field = input.getOutputFields()[i];\r\n\t\t    \r\n\t\t\tTableItem item = wFields.table.getItem(i);\r\n\t\t\tif (field.getName()!=null) item.setText(1, field.getName());\r\n\t\t\titem.setText(2, field.getTypeDesc());\r\n\t\t\tif (field.getFormat()!=null) item.setText(3, field.getFormat());\r\n\t\t\tif (field.getLength()!=-1) item.setText(4, \"\"+field.getLength());\r\n\t\t\tif (field.getPrecision()!=-1) item.setText(5, \"\"+field.getPrecision());\r\n\t\t\tif (field.getCurrencySymbol()!=null) item.setText(6, field.getCurrencySymbol());\r\n\t\t\tif (field.getDecimalSymbol()!=null) item.setText(7, field.getDecimalSymbol());\r\n\t\t\tif (field.getGroupingSymbol()!=null) item.setText(8, field.getGroupingSymbol());\r\n\t\t\tString trim = field.getTrimTypeDesc();\r\n\t\t\tif (trim != null) item.setText(9, trim);\r\n\t\t\tif (field.getNullString()!=null) item.setText(10, field.getNullString());\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\twFields.optWidth(true);\r\n\t\twStepname.selectAll();\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n\t{\r\n        Shell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\t\t\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(Messages.getString(\"TextFileOutputDialog.DialogTitle\"));\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Stepname line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left  = new FormAttachment(0, 0);\r\n\t\tfdlStepname.top   = new FormAttachment(0, margin);\r\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n \t\twTabFolder.setSimple(false);\r\n \t\t\t\t\r\n\t\t//////////////////////////\r\n\t\t// START OF FILE TAB///\r\n\t\t///\r\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFileTab.setText(Messages.getString(\"TextFileOutputDialog.FileTab.TabTitle\"));\r\n\t\t\r\n\t\tComposite wFileComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wFileComp);\r\n\r\n\t\tFormLayout fileLayout = new FormLayout();\r\n\t\tfileLayout.marginWidth  = 3;\r\n\t\tfileLayout.marginHeight = 3;\r\n\t\twFileComp.setLayout(fileLayout);\r\n\r\n\t\t// Filename line\r\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFilename.setText(Messages.getString(\"TextFileOutputDialog.Filename.Label\"));\r\n \t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename=new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\r\n\t\tfdbFilename=new FormData();\r\n\t\tfdbFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\r\n\t\twFilename=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wFilename);\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename=new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\r\n\t\t// Run this as a command instead?\r\n\t\twlFileIsCommand=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFileIsCommand.setText(Messages.getString(\"TextFileOutputDialog.FileIsCommand.Label\"));\r\n \t\tprops.setLook(wlFileIsCommand);\r\n\t\tfdlFileIsCommand=new FormData();\r\n\t\tfdlFileIsCommand.left = new FormAttachment(0, 0);\r\n\t\tfdlFileIsCommand.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdlFileIsCommand.right= new FormAttachment(middle, -margin);\r\n\t\twlFileIsCommand.setLayoutData(fdlFileIsCommand);\r\n\t\twFileIsCommand=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wFileIsCommand);\r\n\t\tfdFileIsCommand=new FormData();\r\n\t\tfdFileIsCommand.left = new FormAttachment(middle, 0);\r\n\t\tfdFileIsCommand.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdFileIsCommand.right= new FormAttachment(100, 0);\r\n\t\twFileIsCommand.setLayoutData(fdFileIsCommand);\r\n\t\twFileIsCommand.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t// Open new File at Init\r\n\t\twlDoNotOpenNewFileInit=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlDoNotOpenNewFileInit.setText(Messages.getString(\"TextFileOutputDialog.DoNotOpenNewFileInit.Label\"));\r\n \t\tprops.setLook(wlDoNotOpenNewFileInit);\r\n\t\tfdlDoNotOpenNewFileInit=new FormData();\r\n\t\tfdlDoNotOpenNewFileInit.left = new FormAttachment(0, 0);\r\n\t\tfdlDoNotOpenNewFileInit.top  = new FormAttachment(wFileIsCommand, margin);\r\n\t\tfdlDoNotOpenNewFileInit.right= new FormAttachment(middle, -margin);\r\n\t\twlDoNotOpenNewFileInit.setLayoutData(fdlDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit=new Button(wFileComp, SWT.CHECK );\r\n\t\twDoNotOpenNewFileInit.setToolTipText(Messages.getString(\"TextFileOutputDialog.DoNotOpenNewFileInit.Tooltip\"));\r\n \t\tprops.setLook(wDoNotOpenNewFileInit);\r\n\t\tfdDoNotOpenNewFileInit=new FormData();\r\n\t\tfdDoNotOpenNewFileInit.left = new FormAttachment(middle, 0);\r\n\t\tfdDoNotOpenNewFileInit.top  = new FormAttachment(wFileIsCommand, margin);\r\n\t\tfdDoNotOpenNewFileInit.right= new FormAttachment(100, 0);\r\n\t\twDoNotOpenNewFileInit.setLayoutData(fdDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t// Extension line\r\n\t\twlExtension=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlExtension.setText(Messages.getString(\"System.Label.Extension\"));\r\n \t\tprops.setLook(wlExtension);\r\n\t\tfdlExtension=new FormData();\r\n\t\tfdlExtension.left = new FormAttachment(0, 0);\r\n\t\tfdlExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdlExtension.right= new FormAttachment(middle, -margin);\r\n\t\twlExtension.setLayoutData(fdlExtension);\r\n\t\twExtension=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twExtension.setText(\"\");\r\n \t\tprops.setLook(wExtension);\r\n\t\twExtension.addModifyListener(lsMod);\r\n\t\tfdExtension=new FormData();\r\n\t\tfdExtension.left = new FormAttachment(middle, 0);\r\n\t\tfdExtension.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n\t\tfdExtension.right= new FormAttachment(100, 0);\r\n\t\twExtension.setLayoutData(fdExtension);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddStepnr=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddStepnr.setText(Messages.getString(\"TextFileOutputDialog.AddStepnr.Label\"));\r\n \t\tprops.setLook(wlAddStepnr);\r\n\t\tfdlAddStepnr=new FormData();\r\n\t\tfdlAddStepnr.left = new FormAttachment(0, 0);\r\n\t\tfdlAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdlAddStepnr.right= new FormAttachment(middle, -margin);\r\n\t\twlAddStepnr.setLayoutData(fdlAddStepnr);\r\n\t\twAddStepnr=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddStepnr);\r\n\t\tfdAddStepnr=new FormData();\r\n\t\tfdAddStepnr.left = new FormAttachment(middle, 0);\r\n\t\tfdAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdAddStepnr.right= new FormAttachment(100, 0);\r\n\t\twAddStepnr.setLayoutData(fdAddStepnr);\r\n\t\twAddStepnr.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddPartnr=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddPartnr.setText(Messages.getString(\"TextFileOutputDialog.AddPartnr.Label\"));\r\n \t\tprops.setLook(wlAddPartnr);\r\n\t\tfdlAddPartnr=new FormData();\r\n\t\tfdlAddPartnr.left = new FormAttachment(0, 0);\r\n\t\tfdlAddPartnr.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdlAddPartnr.right= new FormAttachment(middle, -margin);\r\n\t\twlAddPartnr.setLayoutData(fdlAddPartnr);\r\n\t\twAddPartnr=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddPartnr);\r\n\t\tfdAddPartnr=new FormData();\r\n\t\tfdAddPartnr.left = new FormAttachment(middle, 0);\r\n\t\tfdAddPartnr.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdAddPartnr.right= new FormAttachment(100, 0);\r\n\t\twAddPartnr.setLayoutData(fdAddPartnr);\r\n\t\twAddPartnr.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddDate=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddDate.setText(Messages.getString(\"TextFileOutputDialog.AddDate.Label\"));\r\n \t\tprops.setLook(wlAddDate);\r\n\t\tfdlAddDate=new FormData();\r\n\t\tfdlAddDate.left = new FormAttachment(0, 0);\r\n\t\tfdlAddDate.top  = new FormAttachment(wAddPartnr, margin);\r\n\t\tfdlAddDate.right= new FormAttachment(middle, -margin);\r\n\t\twlAddDate.setLayoutData(fdlAddDate);\r\n\t\twAddDate=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddDate);\r\n\t\tfdAddDate=new FormData();\r\n\t\tfdAddDate.left = new FormAttachment(middle, 0);\r\n\t\tfdAddDate.top  = new FormAttachment(wAddPartnr, margin);\r\n\t\tfdAddDate.right= new FormAttachment(100, 0);\r\n\t\twAddDate.setLayoutData(fdAddDate);\r\n\t\twAddDate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\t// System.out.println(\"wAddDate.getSelection()=\"+wAddDate.getSelection());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Create multi-part file?\r\n\t\twlAddTime=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddTime.setText(Messages.getString(\"TextFileOutputDialog.AddTime.Label\"));\r\n \t\tprops.setLook(wlAddTime);\r\n\t\tfdlAddTime=new FormData();\r\n\t\tfdlAddTime.left = new FormAttachment(0, 0);\r\n\t\tfdlAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdlAddTime.right= new FormAttachment(middle, -margin);\r\n\t\twlAddTime.setLayoutData(fdlAddTime);\r\n\t\twAddTime=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddTime);\r\n\t\tfdAddTime=new FormData();\r\n\t\tfdAddTime.left = new FormAttachment(middle, 0);\r\n\t\tfdAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdAddTime.right= new FormAttachment(100, 0);\r\n\t\twAddTime.setLayoutData(fdAddTime);\r\n\t\twAddTime.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Specify date time format?\r\n\t\twlSpecifyFormat=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlSpecifyFormat.setText(Messages.getString(\"TextFileOutputDialog.SpecifyFormat.Label\"));\r\n\t\tprops.setLook(wlSpecifyFormat);\r\n\t\tfdlSpecifyFormat=new FormData();\r\n\t\tfdlSpecifyFormat.left = new FormAttachment(0, 0);\r\n\t\tfdlSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdlSpecifyFormat.right= new FormAttachment(middle, -margin);\r\n\t\twlSpecifyFormat.setLayoutData(fdlSpecifyFormat);\r\n\t\twSpecifyFormat=new Button(wFileComp, SWT.CHECK);\r\n\t\tprops.setLook(wSpecifyFormat);\r\n\t\twSpecifyFormat.setToolTipText(Messages.getString(\"TextFileOutputDialog.SpecifyFormat.Tooltip\"));\r\n\t    fdSpecifyFormat=new FormData();\r\n\t\tfdSpecifyFormat.left = new FormAttachment(middle, 0);\r\n\t\tfdSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdSpecifyFormat.right= new FormAttachment(100, 0);\r\n\t\twSpecifyFormat.setLayoutData(fdSpecifyFormat);\r\n\t\twSpecifyFormat.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\tsetDateTimeFormat();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n \t\t// DateTimeFormat\r\n\t\twlDateTimeFormat=new Label(wFileComp, SWT.RIGHT);\r\n        wlDateTimeFormat.setText(Messages.getString(\"TextFileOutputDialog.DateTimeFormat.Label\"));\r\n        props.setLook(wlDateTimeFormat);\r\n        fdlDateTimeFormat=new FormData();\r\n        fdlDateTimeFormat.left = new FormAttachment(0, 0);\r\n        fdlDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdlDateTimeFormat.right= new FormAttachment(middle, -margin);\r\n        wlDateTimeFormat.setLayoutData(fdlDateTimeFormat);\r\n        wDateTimeFormat=new CCombo(wFileComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wDateTimeFormat.setEditable(true);\r\n        props.setLook(wDateTimeFormat);\r\n        wDateTimeFormat.addModifyListener(lsMod);\r\n        fdDateTimeFormat=new FormData();\r\n        fdDateTimeFormat.left = new FormAttachment(middle, 0);\r\n        fdDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdDateTimeFormat.right= new FormAttachment(100, 0);\r\n        wDateTimeFormat.setLayoutData(fdDateTimeFormat);\r\n\t\tString dats[] = Const.getDateFormats();\r\n        for (int x=0;x<dats.length;x++) wDateTimeFormat.add(dats[x]);\r\n        \r\n\r\n\r\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbShowFiles);\r\n\t\twbShowFiles.setText(Messages.getString(\"TextFileOutputDialog.ShowFiles.Button\"));\r\n\t\tfdbShowFiles=new FormData();\r\n\t\tfdbShowFiles.left = new FormAttachment(middle, 0);\r\n\t\tfdbShowFiles.top  = new FormAttachment(wDateTimeFormat, margin*2);\r\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\r\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tTextFileOutputMeta tfoi = new TextFileOutputMeta();\r\n\t\t\t\t\tgetInfo(tfoi);\r\n\t\t\t\t\tString files[] = tfoi.getFiles(transMeta);\r\n\t\t\t\t\tif (files!=null && files.length>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, Messages.getString(\"TextFileOutputDialog.SelectOutputFiles.DialogTitle\"), Messages.getString(\"TextFileOutputDialog.SelectOutputFiles.DialogMessage\"));\r\n\t\t\t\t\t\tesd.setViewOnly();\r\n\t\t\t\t\t\tesd.open();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t\t\t\t\tmb.setMessage(Messages.getString(\"TextFileOutputDialog.NoFilesFound.DialogMessage\"));\r\n\t\t\t\t\t\tmb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\r\n\t\t\t\t\t\tmb.open(); \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddToResult.setText(Messages.getString(\"TextFileOutputDialog.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(wFileComp, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(Messages.getString(\"TextFileOutputDialog.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\r\n\t\t\r\n\t\tfdFileComp=new FormData();\r\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFileComp.right = new FormAttachment(100, 0);\r\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\r\n\t\twFileComp.setLayoutData(fdFileComp);\r\n\t\r\n\t\twFileComp.layout();\r\n\t\twFileTab.setControl(wFileComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF FILE TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t//////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t///\r\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(Messages.getString(\"TextFileOutputDialog.ContentTab.TabTitle\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout ();\r\n\t\tcontentLayout.marginWidth  = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\t\t\r\n\t\tComposite wContentComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wContentComp);\r\n\t\twContentComp.setLayout(contentLayout);\r\n\r\n\r\n\t\t// Append to end of file?\r\n\t\twlAppend=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlAppend.setText(Messages.getString(\"TextFileOutputDialog.Append.Label\"));\r\n \t\tprops.setLook(wlAppend);\r\n\t\tfdlAppend=new FormData();\r\n\t\tfdlAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdlAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlAppend.setLayoutData(fdlAppend);\r\n\t\twAppend=new Button(wContentComp, SWT.CHECK);\r\n \t\tprops.setLook(wAppend);\r\n\t\tfdAppend=new FormData();\r\n\t\tfdAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdAppend.right= new FormAttachment(100, 0);\r\n\t\twAppend.setLayoutData(fdAppend);\r\n\t\twAppend.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\twlSeparator=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlSeparator.setText(Messages.getString(\"TextFileOutputDialog.Separator.Label\"));\r\n \t\tprops.setLook(wlSeparator);\r\n\t\tfdlSeparator=new FormData();\r\n\t\tfdlSeparator.left = new FormAttachment(0, 0);\r\n\t\tfdlSeparator.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdlSeparator.right= new FormAttachment(middle, -margin);\r\n\t\twlSeparator.setLayoutData(fdlSeparator);\r\n\r\n\t\twbSeparator=new Button(wContentComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbSeparator);\r\n\t\twbSeparator.setText(Messages.getString(\"TextFileOutputDialog.Separator.Button\"));\r\n\t\tfdbSeparator=new FormData();\r\n\t\tfdbSeparator.right= new FormAttachment(100, 0);\r\n\t\tfdbSeparator.top  = new FormAttachment(wAppend, 0);\r\n\t\twbSeparator.setLayoutData(fdbSeparator);\r\n\t\twbSeparator.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t\t{\r\n\t\t\t\t\twSeparator.insert(\"\\t\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twSeparator=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wSeparator);\r\n\t\twSeparator.addModifyListener(lsMod);\r\n\t\tfdSeparator=new FormData();\r\n\t\tfdSeparator.left = new FormAttachment(middle, 0);\r\n\t\tfdSeparator.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdSeparator.right= new FormAttachment(wbSeparator, -margin);\r\n\t\twSeparator.setLayoutData(fdSeparator);\r\n\r\n\t\t// Enclosure line...\r\n\t\twlEnclosure=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlEnclosure.setText(Messages.getString(\"TextFileOutputDialog.Enclosure.Label\"));\r\n \t\tprops.setLook(wlEnclosure);\r\n\t\tfdlEnclosure=new FormData();\r\n\t\tfdlEnclosure.left = new FormAttachment(0, 0);\r\n\t\tfdlEnclosure.top  = new FormAttachment(wSeparator, margin);\r\n\t\tfdlEnclosure.right= new FormAttachment(middle, -margin);\r\n\t\twlEnclosure.setLayoutData(fdlEnclosure);\r\n\t\twEnclosure=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wEnclosure);\r\n\t\twEnclosure.addModifyListener(lsMod);\r\n\t\tfdEnclosure=new FormData();\r\n\t\tfdEnclosure.left = new FormAttachment(middle, 0);\r\n\t\tfdEnclosure.top  = new FormAttachment(wSeparator, margin);\r\n\t\tfdEnclosure.right= new FormAttachment(100, 0);\r\n\t\twEnclosure.setLayoutData(fdEnclosure);\r\n\r\n        wlEnclForced=new Label(wContentComp, SWT.RIGHT);\r\n        wlEnclForced.setText(Messages.getString(\"TextFileOutputDialog.EnclForced.Label\"));\r\n        props.setLook(wlEnclForced);\r\n        fdlEnclForced=new FormData();\r\n        fdlEnclForced.left = new FormAttachment(0, 0);\r\n        fdlEnclForced.top  = new FormAttachment(wEnclosure, margin);\r\n        fdlEnclForced.right= new FormAttachment(middle, -margin);\r\n        wlEnclForced.setLayoutData(fdlEnclForced);\r\n        wEnclForced=new Button(wContentComp, SWT.CHECK );\r\n        props.setLook(wEnclForced);\r\n        fdEnclForced=new FormData();\r\n        fdEnclForced.left = new FormAttachment(middle, 0);\r\n        fdEnclForced.top  = new FormAttachment(wEnclosure, margin);\r\n        fdEnclForced.right= new FormAttachment(100, 0);\r\n        wEnclForced.setLayoutData(fdEnclForced);\r\n        wEnclForced.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                    input.setChanged();\r\n                }\r\n            }\r\n        );\r\n\r\n\t\twlHeader=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlHeader.setText(Messages.getString(\"TextFileOutputDialog.Header.Label\"));\r\n \t\tprops.setLook(wlHeader);\r\n\t\tfdlHeader=new FormData();\r\n\t\tfdlHeader.left = new FormAttachment(0, 0);\r\n\t\tfdlHeader.top  = new FormAttachment(wEnclForced, margin);\r\n\t\tfdlHeader.right= new FormAttachment(middle, -margin);\r\n\t\twlHeader.setLayoutData(fdlHeader);\r\n\t\twHeader=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wHeader);\r\n\t\tfdHeader=new FormData();\r\n\t\tfdHeader.left = new FormAttachment(middle, 0);\r\n\t\tfdHeader.top  = new FormAttachment(wEnclForced, margin);\r\n\t\tfdHeader.right= new FormAttachment(100, 0);\r\n\t\twHeader.setLayoutData(fdHeader);\r\n\t\twHeader.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twlFooter=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFooter.setText(Messages.getString(\"TextFileOutputDialog.Footer.Label\"));\r\n \t\tprops.setLook(wlFooter);\r\n\t\tfdlFooter=new FormData();\r\n\t\tfdlFooter.left = new FormAttachment(0, 0);\r\n\t\tfdlFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdlFooter.right= new FormAttachment(middle, -margin);\r\n\t\twlFooter.setLayoutData(fdlFooter);\r\n\t\twFooter=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wFooter);\r\n\t\tfdFooter=new FormData();\r\n\t\tfdFooter.left = new FormAttachment(middle, 0);\r\n\t\tfdFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdFooter.right= new FormAttachment(100, 0);\r\n\t\twFooter.setLayoutData(fdFooter);\r\n\t\twFooter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twlFormat=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFormat.setText(Messages.getString(\"TextFileOutputDialog.Format.Label\"));\r\n \t\tprops.setLook(wlFormat);\r\n\t\tfdlFormat=new FormData();\r\n\t\tfdlFormat.left = new FormAttachment(0, 0);\r\n\t\tfdlFormat.top  = new FormAttachment(wFooter, margin);\r\n\t\tfdlFormat.right= new FormAttachment(middle, -margin);\r\n\t\twlFormat.setLayoutData(fdlFormat);\r\n\t\twFormat=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n\t\twFormat.setText(Messages.getString(\"TextFileOutputDialog.Format.Label\"));\r\n \t\tprops.setLook(wFormat);\r\n\r\n\t\twFormat.add(\"DOS\");\r\n\t\twFormat.add(\"Unix\");\r\n\t\twFormat.select(0);\r\n\t\twFormat.addModifyListener(lsMod);\r\n\t\tfdFormat=new FormData();\r\n\t\tfdFormat.left = new FormAttachment(middle, 0);\r\n\t\tfdFormat.top  = new FormAttachment(wFooter, margin);\r\n\t\tfdFormat.right= new FormAttachment(100, 0);\r\n\t\twFormat.setLayoutData(fdFormat);\r\n\r\n\t\twlCompression=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlCompression.setText(Messages.getString(\"TextFileOutputDialog.Compression.Label\"));\r\n \t\tprops.setLook(wlCompression);\r\n\t\tfdlCompression=new FormData();\r\n\t\tfdlCompression.left = new FormAttachment(0, 0);\r\n\t\tfdlCompression.top  = new FormAttachment(wFormat, margin);\r\n\t\tfdlCompression.right= new FormAttachment(middle, -margin);\r\n\t\twlCompression.setLayoutData(fdlCompression);\r\n\t\twCompression=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n\t\twCompression.setText(Messages.getString(\"TextFileOutputDialog.Compression.Label\"));\r\n \t\tprops.setLook(wCompression);\r\n\r\n\t\twCompression.setItems(TextFileOutputMeta.fileCompressionTypeCodes);\r\n\t\twCompression.addModifyListener(lsMod);\r\n\t\tfdCompression=new FormData();\r\n\t\tfdCompression.left = new FormAttachment(middle, 0);\r\n\t\tfdCompression.top  = new FormAttachment(wFormat, margin);\r\n\t\tfdCompression.right= new FormAttachment(100, 0);\r\n\t\twCompression.setLayoutData(fdCompression);\r\n\r\n        wlEncoding=new Label(wContentComp, SWT.RIGHT);\r\n        wlEncoding.setText(Messages.getString(\"TextFileOutputDialog.Encoding.Label\"));\r\n        props.setLook(wlEncoding);\r\n        fdlEncoding=new FormData();\r\n        fdlEncoding.left = new FormAttachment(0, 0);\r\n        fdlEncoding.top  = new FormAttachment(wCompression, margin);\r\n        fdlEncoding.right= new FormAttachment(middle, -margin);\r\n        wlEncoding.setLayoutData(fdlEncoding);\r\n        wEncoding=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wEncoding.setEditable(true);\r\n        props.setLook(wEncoding);\r\n        wEncoding.addModifyListener(lsMod);\r\n        fdEncoding=new FormData();\r\n        fdEncoding.left = new FormAttachment(middle, 0);\r\n        fdEncoding.top  = new FormAttachment(wCompression, margin);\r\n        fdEncoding.right= new FormAttachment(100, 0);\r\n        wEncoding.setLayoutData(fdEncoding);\r\n        wEncoding.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    setEncodings();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n        \r\n\t\twlPad=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlPad.setText(Messages.getString(\"TextFileOutputDialog.Pad.Label\"));\r\n \t\tprops.setLook(wlPad);\r\n\t\tfdlPad=new FormData();\r\n\t\tfdlPad.left = new FormAttachment(0, 0);\r\n\t\tfdlPad.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdlPad.right= new FormAttachment(middle, -margin);\r\n\t\twlPad.setLayoutData(fdlPad);\r\n\t\twPad=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wPad);\r\n\t\tfdPad=new FormData();\r\n\t\tfdPad.left = new FormAttachment(middle, 0);\r\n\t\tfdPad.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdPad.right= new FormAttachment(100, 0);\r\n\t\twPad.setLayoutData(fdPad);\r\n\t\twPad.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\r\n\t\twlFastDump=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFastDump.setText(Messages.getString(\"TextFileOutputDialog.FastDump.Label\"));\r\n \t\tprops.setLook(wlFastDump);\r\n\t\tfdlFastDump=new FormData();\r\n\t\tfdlFastDump.left = new FormAttachment(0, 0);\r\n\t\tfdlFastDump.top  = new FormAttachment(wPad, margin);\r\n\t\tfdlFastDump.right= new FormAttachment(middle, -margin);\r\n\t\twlFastDump.setLayoutData(fdlFastDump);\r\n\t\twFastDump=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wFastDump);\r\n\t\tfdFastDump=new FormData();\r\n\t\tfdFastDump.left = new FormAttachment(middle, 0);\r\n\t\tfdFastDump.top  = new FormAttachment(wPad, margin);\r\n\t\tfdFastDump.right= new FormAttachment(100, 0);\r\n\t\twFastDump.setLayoutData(fdFastDump);\r\n\t\twFastDump.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\r\n\t\twlSplitEvery=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlSplitEvery.setText(Messages.getString(\"TextFileOutputDialog.SplitEvery.Label\"));\r\n \t\tprops.setLook(wlSplitEvery);\r\n\t\tfdlSplitEvery=new FormData();\r\n\t\tfdlSplitEvery.left = new FormAttachment(0, 0);\r\n\t\tfdlSplitEvery.top  = new FormAttachment(wFastDump, margin);\r\n\t\tfdlSplitEvery.right= new FormAttachment(middle, -margin);\r\n\t\twlSplitEvery.setLayoutData(fdlSplitEvery);\r\n\t\twSplitEvery=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wSplitEvery);\r\n\t\twSplitEvery.addModifyListener(lsMod);\r\n\t\tfdSplitEvery=new FormData();\r\n\t\tfdSplitEvery.left = new FormAttachment(middle, 0);\r\n\t\tfdSplitEvery.top  = new FormAttachment(wFastDump, margin);\r\n\t\tfdSplitEvery.right= new FormAttachment(100, 0);\r\n\t\twSplitEvery.setLayoutData(fdSplitEvery);\r\n\r\n\t\t//Bruise:\r\n\t\twlEndedLine=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlEndedLine.setText(Messages.getString(\"TextFileOutputDialog.EndedLine.Label\"));\r\n \t\tprops.setLook(wlEndedLine);\r\n\t\tfdlEndedLine=new FormData();\r\n\t\tfdlEndedLine.left = new FormAttachment(0, 0);\r\n\t\tfdlEndedLine.top  = new FormAttachment(wSplitEvery, margin);\r\n\t\tfdlEndedLine.right= new FormAttachment(middle, -margin);\r\n\t\twlEndedLine.setLayoutData(fdlEndedLine);\r\n\t\twEndedLine=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wEndedLine);\r\n \t\twEndedLine.addModifyListener(lsMod);\r\n\t\tfdEndedLine=new FormData();\r\n\t\tfdEndedLine.left = new FormAttachment(middle, 0);\r\n\t\tfdEndedLine.top  = new FormAttachment(wSplitEvery, margin);\r\n\t\tfdEndedLine.right= new FormAttachment(100, 0);\r\n\t\twEndedLine.setLayoutData(fdEndedLine);\r\n\t\t\r\n\t\tfdContentComp = new FormData();\r\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\r\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\r\n\t\tfdContentComp.right = new FormAttachment(100, 0);\r\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\r\n\t\twContentComp.setLayoutData(fdContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF CONTENT TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t// Fields tab...\r\n\t\t//\r\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFieldsTab.setText(Messages.getString(\"TextFileOutputDialog.FieldsTab.TabTitle\"));\r\n\t\t\r\n\t\tFormLayout fieldsLayout = new FormLayout ();\r\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tComposite wFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twFieldsComp.setLayout(fieldsLayout);\r\n \t\tprops.setLook(wFieldsComp);\r\n\r\n\t\twGet=new Button(wFieldsComp, SWT.PUSH);\r\n\t\twGet.setText(Messages.getString(\"System.Button.GetFields\"));\r\n\t\twGet.setToolTipText(Messages.getString(\"System.Tooltip.GetFields\"));\r\n\r\n\t\twMinWidth =new Button(wFieldsComp, SWT.PUSH);\r\n\t\twMinWidth.setText(Messages.getString(\"TextFileOutputDialog.MinWidth.Button\"));\r\n\t\twMinWidth.setToolTipText(Messages.getString(\"TextFileOutputDialog.MinWidth.Tooltip\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wGet, wMinWidth}, margin, null);\r\n\r\n\t\tfinal int FieldsCols=10;\r\n\t\tfinal int FieldsRows=input.getOutputFields().length;\r\n\t\t\r\n\t\t// Prepare a list of possible formats...\r\n\t\tString nums[] = Const.getNumberFormats();\r\n\t\tint totsize = dats.length + nums.length;\r\n\t\tString formats[] = new String[totsize];\r\n\t\tfor (int x=0;x<dats.length;x++) formats[x] = dats[x];\r\n\t\tfor (int x=0;x<nums.length;x++) formats[dats.length+x] = nums[x];\r\n\t\t\r\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\r\n\t\tcolinf[0]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.NameColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[1]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes() );\r\n\t\tcolinf[2]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, formats);\r\n\t\tcolinf[3]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.LengthColumn.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[4]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.PrecisionColumn.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[5]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.CurrencyColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[6]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.DecimalColumn.Column\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[7]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.GroupColumn.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[8]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.TrimTypeColumn.Column\"),  ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.trimTypeDesc, true );\r\n\t\tcolinf[9]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.NullColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\t\r\n\t\twFields=new TableView(transMeta, wFieldsComp, \r\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t\t\t\t      colinf, \r\n\t\t\t\t\t\t      FieldsRows,  \r\n\t\t\t\t\t\t      lsMod,\r\n\t\t\t\t\t\t\t  props\r\n\t\t\t\t\t\t      );\r\n\r\n\t\tfdFields=new FormData();\r\n\t\tfdFields.left  = new FormAttachment(0, 0);\r\n\t\tfdFields.top   = new FormAttachment(0, 0);\r\n\t\tfdFields.right = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom= new FormAttachment(wGet, -margin);\r\n\t\twFields.setLayoutData(fdFields);\r\n\r\n\t\tfdFieldsComp=new FormData();\r\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\r\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\r\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\r\n\r\n\t\twFieldsComp.layout();\r\n\t\twFieldsTab.setControl(wFieldsComp);\r\n\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\t\t\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n\t\t// Add listeners\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();       } };\r\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\r\n\t\tlsMinWidth    = new Listener() { public void handleEvent(Event e) { setMinimalWidth(); } };\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();   } };\r\n\t\t\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\twGet.addListener   (SWT.Selection, lsGet   );\r\n\t\twMinWidth.addListener (SWT.Selection, lsMinWidth );\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\twFilename.addSelectionListener( lsDef );\r\n\t\twSeparator.addSelectionListener( lsDef );\r\n\r\n\t\t// Whenever something changes, set the tooltip to the expanded version:\r\n\t\twFilename.addModifyListener(new ModifyListener()\r\n\t\t\t{\r\n\t\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t\t{\r\n\t\t\t\t\twFilename.setToolTipText(transMeta.environmentSubstitute( wFilename.getText() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\twbFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.txt\", \"*.csv\", \"*\"});\r\n\t\t\t\t\tif (wFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.CSVFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tString extension = wExtension.getText();\r\n\t\t\t\t\t\tif ( extension != null && dialog.getFileName() != null &&\r\n\t\t\t\t\t\t\t\tdialog.getFileName().endsWith(\".\" + extension) )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// The extension is filled in and matches the end \r\n\t\t\t\t\t\t\t// of the selected file => Strip off the extension.\r\n\t\t\t\t\t\t\tString fileName = dialog.getFileName();\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+\r\n\t\t\t\t\t\t    \t\t          fileName.substring(0, fileName.length() - (extension.length()+1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\t\tlsResize = new Listener() \r\n\t\t{\r\n\t\t\tpublic void handleEvent(Event event) \r\n\t\t\t{\r\n\t\t\t\tPoint size = shell.getSize();\r\n\t\t\t\twFields.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.table.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.redraw();\r\n\t\t\t}\r\n\t\t};\r\n\t\tshell.addListener(SWT.Resize, lsResize);\r\n\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\tinput.setChanged(changed);\r\n\t\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","id":42568,"modified_method":"public String open()\r\n\t{\r\n        Shell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MAX | SWT.MIN);\r\n \t\tprops.setLook(shell);\r\n        setShellImage(shell, input);\r\n\r\n\t\tModifyListener lsMod = new ModifyListener() \r\n\t\t{\r\n\t\t\tpublic void modifyText(ModifyEvent e) \r\n\t\t\t{\r\n\t\t\t\tinput.setChanged();\r\n\t\t\t}\r\n\t\t};\r\n\t\tchanged = input.hasChanged();\r\n\t\t\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(Messages.getString(\"TextFileOutputDialog.DialogTitle\"));\r\n\t\t\r\n\t\tint middle = props.getMiddlePct();\r\n\t\tint margin = Const.MARGIN;\r\n\r\n\t\t// Stepname line\r\n\t\twlStepname=new Label(shell, SWT.RIGHT);\r\n\t\twlStepname.setText(Messages.getString(\"System.Label.StepName\"));\r\n \t\tprops.setLook(wlStepname);\r\n\t\tfdlStepname=new FormData();\r\n\t\tfdlStepname.left  = new FormAttachment(0, 0);\r\n\t\tfdlStepname.top   = new FormAttachment(0, margin);\r\n\t\tfdlStepname.right = new FormAttachment(middle, -margin);\r\n\t\twlStepname.setLayoutData(fdlStepname);\r\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twStepname.setText(stepname);\r\n \t\tprops.setLook(wStepname);\r\n\t\twStepname.addModifyListener(lsMod);\r\n\t\tfdStepname=new FormData();\r\n\t\tfdStepname.left = new FormAttachment(middle, 0);\r\n\t\tfdStepname.top  = new FormAttachment(0, margin);\r\n\t\tfdStepname.right= new FormAttachment(100, 0);\r\n\t\twStepname.setLayoutData(fdStepname);\r\n\r\n\t\twTabFolder = new CTabFolder(shell, SWT.BORDER);\r\n \t\tprops.setLook(wTabFolder, Props.WIDGET_STYLE_TAB);\r\n \t\twTabFolder.setSimple(false);\r\n \t\t\t\t\r\n\t\t//////////////////////////\r\n\t\t// START OF FILE TAB///\r\n\t\t///\r\n\t\twFileTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFileTab.setText(Messages.getString(\"TextFileOutputDialog.FileTab.TabTitle\"));\r\n\t\t\r\n\t\tComposite wFileComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wFileComp);\r\n\r\n\t\tFormLayout fileLayout = new FormLayout();\r\n\t\tfileLayout.marginWidth  = 3;\r\n\t\tfileLayout.marginHeight = 3;\r\n\t\twFileComp.setLayout(fileLayout);\r\n\r\n\t\t// Filename line\r\n\t\twlFilename=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFilename.setText(Messages.getString(\"TextFileOutputDialog.Filename.Label\"));\r\n \t\tprops.setLook(wlFilename);\r\n\t\tfdlFilename=new FormData();\r\n\t\tfdlFilename.left = new FormAttachment(0, 0);\r\n\t\tfdlFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\r\n\t\twlFilename.setLayoutData(fdlFilename);\r\n\r\n\t\twbFilename=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbFilename);\r\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\r\n\t\tfdbFilename=new FormData();\r\n\t\tfdbFilename.right= new FormAttachment(100, 0);\r\n\t\tfdbFilename.top  = new FormAttachment(0, 0);\r\n\t\twbFilename.setLayoutData(fdbFilename);\r\n\r\n\t\twFilename=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wFilename);\r\n\t\twFilename.addModifyListener(lsMod);\r\n\t\tfdFilename=new FormData();\r\n\t\tfdFilename.left = new FormAttachment(middle, 0);\r\n\t\tfdFilename.top  = new FormAttachment(0, margin);\r\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\r\n\t\twFilename.setLayoutData(fdFilename);\r\n\r\n\t\t// Run this as a command instead?\r\n\t\twlFileIsCommand=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFileIsCommand.setText(Messages.getString(\"TextFileOutputDialog.FileIsCommand.Label\"));\r\n \t\tprops.setLook(wlFileIsCommand);\r\n\t\tfdlFileIsCommand=new FormData();\r\n\t\tfdlFileIsCommand.left = new FormAttachment(0, 0);\r\n\t\tfdlFileIsCommand.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdlFileIsCommand.right= new FormAttachment(middle, -margin);\r\n\t\twlFileIsCommand.setLayoutData(fdlFileIsCommand);\r\n\t\twFileIsCommand=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wFileIsCommand);\r\n\t\tfdFileIsCommand=new FormData();\r\n\t\tfdFileIsCommand.left = new FormAttachment(middle, 0);\r\n\t\tfdFileIsCommand.top  = new FormAttachment(wFilename, margin);\r\n\t\tfdFileIsCommand.right= new FormAttachment(100, 0);\r\n\t\twFileIsCommand.setLayoutData(fdFileIsCommand);\r\n\t\twFileIsCommand.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\r\n\t\t// Open new File at Init\r\n\t\twlDoNotOpenNewFileInit=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlDoNotOpenNewFileInit.setText(Messages.getString(\"TextFileOutputDialog.DoNotOpenNewFileInit.Label\"));\r\n \t\tprops.setLook(wlDoNotOpenNewFileInit);\r\n\t\tfdlDoNotOpenNewFileInit=new FormData();\r\n\t\tfdlDoNotOpenNewFileInit.left = new FormAttachment(0, 0);\r\n\t\tfdlDoNotOpenNewFileInit.top  = new FormAttachment(wFileIsCommand, margin);\r\n\t\tfdlDoNotOpenNewFileInit.right= new FormAttachment(middle, -margin);\r\n\t\twlDoNotOpenNewFileInit.setLayoutData(fdlDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit=new Button(wFileComp, SWT.CHECK );\r\n\t\twDoNotOpenNewFileInit.setToolTipText(Messages.getString(\"TextFileOutputDialog.DoNotOpenNewFileInit.Tooltip\"));\r\n \t\tprops.setLook(wDoNotOpenNewFileInit);\r\n\t\tfdDoNotOpenNewFileInit=new FormData();\r\n\t\tfdDoNotOpenNewFileInit.left = new FormAttachment(middle, 0);\r\n\t\tfdDoNotOpenNewFileInit.top  = new FormAttachment(wFileIsCommand, margin);\r\n\t\tfdDoNotOpenNewFileInit.right= new FormAttachment(100, 0);\r\n\t\twDoNotOpenNewFileInit.setLayoutData(fdDoNotOpenNewFileInit);\r\n\t\twDoNotOpenNewFileInit.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t/*next Lines*/\r\n\t\t// FileNameInField line\r\n        wlFileNameInField=new Label(wFileComp, SWT.RIGHT);\r\n        wlFileNameInField.setText(Messages.getString(\"TextFileOutputDialog.FileNameInField.Label\"));\r\n        props.setLook(wlFileNameInField);\r\n        fdlFileNameInField=new FormData();\r\n        fdlFileNameInField.left = new FormAttachment(0, 0);\r\n        fdlFileNameInField.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n        fdlFileNameInField.right= new FormAttachment(middle, -margin);\r\n        wlFileNameInField.setLayoutData(fdlFileNameInField);\r\n        wFileNameInField=new Button(wFileComp, SWT.CHECK );\r\n        props.setLook(wFileNameInField);\r\n        fdFileNameInField=new FormData();\r\n        fdFileNameInField.left = new FormAttachment(middle, 0);\r\n        fdFileNameInField.top  = new FormAttachment(wDoNotOpenNewFileInit, margin);\r\n        fdFileNameInField.right= new FormAttachment(100, 0);\r\n        wFileNameInField.setLayoutData(fdFileNameInField);\r\n        wFileNameInField.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                \tinput.setChanged();\r\n                \t\r\n                \tif(wFileNameInField.getSelection()){\r\n                \t\twFileNameField.setEnabled(true);\r\n                \t\twbFilename.setEnabled(false);\r\n                \t\twFilename.setEnabled(false);\r\n                \t\twFileIsCommand.setEnabled(false);\r\n                \t\twbShowFiles.setEnabled(false);\r\n                \t}\r\n                \telse{\r\n                \t\twFileNameField.setEnabled(false);\r\n                \t\twbFilename.setEnabled(true);\r\n                \t\twFilename.setEnabled(true);\r\n                \t\twFileIsCommand.setEnabled(true);\r\n                \t\twbShowFiles.setEnabled(true);\r\n                \t}              \r\n                }\r\n            }\r\n        );\r\n\r\n\t\t// FileNameField Line\r\n\t\twlFileNameField=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlFileNameField.setText(Messages.getString(\"TextFileOutputDialog.FileNameField.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlFileNameField);\r\n\t\tfdlFileNameField=new FormData();\r\n\t\tfdlFileNameField.left = new FormAttachment(0, 0);\r\n\t\tfdlFileNameField.right= new FormAttachment(middle, -margin);\r\n\t\tfdlFileNameField.top  = new FormAttachment(wFileNameInField, margin);\r\n\t\twlFileNameField.setLayoutData(fdlFileNameField);\r\n\r\n    \twFileNameField=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\tprops.setLook(wFileNameField);\r\n\t\twFileNameField.addModifyListener(lsMod);\r\n\t\tfdFileNameField=new FormData();\r\n\t\tfdFileNameField.left = new FormAttachment(middle, 0);\r\n\t\tfdFileNameField.top  = new FormAttachment(wFileNameInField, margin);\r\n\t\tfdFileNameField.right= new FormAttachment(100, 0);\r\n\t\twFileNameField.setLayoutData(fdFileNameField);\r\n\t\twFileNameField.setEnabled(false);\r\n\t\t/*End*/\r\n\r\n\t\t// Extension line\r\n\t\twlExtension=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlExtension.setText(Messages.getString(\"System.Label.Extension\"));\r\n \t\tprops.setLook(wlExtension);\r\n\t\tfdlExtension=new FormData();\r\n\t\tfdlExtension.left = new FormAttachment(0, 0);\r\n\t\tfdlExtension.top  = new FormAttachment(wFileNameField, margin);\r\n\t\tfdlExtension.right= new FormAttachment(middle, -margin);\r\n\t\twlExtension.setLayoutData(fdlExtension);\r\n\t\twExtension=new TextVar(transMeta, wFileComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twExtension.setText(\"\");\r\n \t\tprops.setLook(wExtension);\r\n\t\twExtension.addModifyListener(lsMod);\r\n\t\tfdExtension=new FormData();\r\n\t\tfdExtension.left = new FormAttachment(middle, 0);\r\n\t\tfdExtension.top  = new FormAttachment(wFileNameField, margin);\r\n\t\tfdExtension.right= new FormAttachment(100, 0);\r\n\t\twExtension.setLayoutData(fdExtension);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddStepnr=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddStepnr.setText(Messages.getString(\"TextFileOutputDialog.AddStepnr.Label\"));\r\n \t\tprops.setLook(wlAddStepnr);\r\n\t\tfdlAddStepnr=new FormData();\r\n\t\tfdlAddStepnr.left = new FormAttachment(0, 0);\r\n\t\tfdlAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdlAddStepnr.right= new FormAttachment(middle, -margin);\r\n\t\twlAddStepnr.setLayoutData(fdlAddStepnr);\r\n\t\twAddStepnr=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddStepnr);\r\n\t\tfdAddStepnr=new FormData();\r\n\t\tfdAddStepnr.left = new FormAttachment(middle, 0);\r\n\t\tfdAddStepnr.top  = new FormAttachment(wExtension, margin);\r\n\t\tfdAddStepnr.right= new FormAttachment(100, 0);\r\n\t\twAddStepnr.setLayoutData(fdAddStepnr);\r\n\t\twAddStepnr.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddPartnr=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddPartnr.setText(Messages.getString(\"TextFileOutputDialog.AddPartnr.Label\"));\r\n \t\tprops.setLook(wlAddPartnr);\r\n\t\tfdlAddPartnr=new FormData();\r\n\t\tfdlAddPartnr.left = new FormAttachment(0, 0);\r\n\t\tfdlAddPartnr.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdlAddPartnr.right= new FormAttachment(middle, -margin);\r\n\t\twlAddPartnr.setLayoutData(fdlAddPartnr);\r\n\t\twAddPartnr=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddPartnr);\r\n\t\tfdAddPartnr=new FormData();\r\n\t\tfdAddPartnr.left = new FormAttachment(middle, 0);\r\n\t\tfdAddPartnr.top  = new FormAttachment(wAddStepnr, margin);\r\n\t\tfdAddPartnr.right= new FormAttachment(100, 0);\r\n\t\twAddPartnr.setLayoutData(fdAddPartnr);\r\n\t\twAddPartnr.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Create multi-part file?\r\n\t\twlAddDate=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddDate.setText(Messages.getString(\"TextFileOutputDialog.AddDate.Label\"));\r\n \t\tprops.setLook(wlAddDate);\r\n\t\tfdlAddDate=new FormData();\r\n\t\tfdlAddDate.left = new FormAttachment(0, 0);\r\n\t\tfdlAddDate.top  = new FormAttachment(wAddPartnr, margin);\r\n\t\tfdlAddDate.right= new FormAttachment(middle, -margin);\r\n\t\twlAddDate.setLayoutData(fdlAddDate);\r\n\t\twAddDate=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddDate);\r\n\t\tfdAddDate=new FormData();\r\n\t\tfdAddDate.left = new FormAttachment(middle, 0);\r\n\t\tfdAddDate.top  = new FormAttachment(wAddPartnr, margin);\r\n\t\tfdAddDate.right= new FormAttachment(100, 0);\r\n\t\twAddDate.setLayoutData(fdAddDate);\r\n\t\twAddDate.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\t// System.out.println(\"wAddDate.getSelection()=\"+wAddDate.getSelection());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Create multi-part file?\r\n\t\twlAddTime=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddTime.setText(Messages.getString(\"TextFileOutputDialog.AddTime.Label\"));\r\n \t\tprops.setLook(wlAddTime);\r\n\t\tfdlAddTime=new FormData();\r\n\t\tfdlAddTime.left = new FormAttachment(0, 0);\r\n\t\tfdlAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdlAddTime.right= new FormAttachment(middle, -margin);\r\n\t\twlAddTime.setLayoutData(fdlAddTime);\r\n\t\twAddTime=new Button(wFileComp, SWT.CHECK);\r\n \t\tprops.setLook(wAddTime);\r\n\t\tfdAddTime=new FormData();\r\n\t\tfdAddTime.left = new FormAttachment(middle, 0);\r\n\t\tfdAddTime.top  = new FormAttachment(wAddDate, margin);\r\n\t\tfdAddTime.right= new FormAttachment(100, 0);\r\n\t\twAddTime.setLayoutData(fdAddTime);\r\n\t\twAddTime.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Specify date time format?\r\n\t\twlSpecifyFormat=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlSpecifyFormat.setText(Messages.getString(\"TextFileOutputDialog.SpecifyFormat.Label\"));\r\n\t\tprops.setLook(wlSpecifyFormat);\r\n\t\tfdlSpecifyFormat=new FormData();\r\n\t\tfdlSpecifyFormat.left = new FormAttachment(0, 0);\r\n\t\tfdlSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdlSpecifyFormat.right= new FormAttachment(middle, -margin);\r\n\t\twlSpecifyFormat.setLayoutData(fdlSpecifyFormat);\r\n\t\twSpecifyFormat=new Button(wFileComp, SWT.CHECK);\r\n\t\tprops.setLook(wSpecifyFormat);\r\n\t\twSpecifyFormat.setToolTipText(Messages.getString(\"TextFileOutputDialog.SpecifyFormat.Tooltip\"));\r\n\t    fdSpecifyFormat=new FormData();\r\n\t\tfdSpecifyFormat.left = new FormAttachment(middle, 0);\r\n\t\tfdSpecifyFormat.top  = new FormAttachment(wAddTime, margin);\r\n\t\tfdSpecifyFormat.right= new FormAttachment(100, 0);\r\n\t\twSpecifyFormat.setLayoutData(fdSpecifyFormat);\r\n\t\twSpecifyFormat.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t\tsetDateTimeFormat();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n \t\t// DateTimeFormat\r\n\t\twlDateTimeFormat=new Label(wFileComp, SWT.RIGHT);\r\n        wlDateTimeFormat.setText(Messages.getString(\"TextFileOutputDialog.DateTimeFormat.Label\"));\r\n        props.setLook(wlDateTimeFormat);\r\n        fdlDateTimeFormat=new FormData();\r\n        fdlDateTimeFormat.left = new FormAttachment(0, 0);\r\n        fdlDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdlDateTimeFormat.right= new FormAttachment(middle, -margin);\r\n        wlDateTimeFormat.setLayoutData(fdlDateTimeFormat);\r\n        wDateTimeFormat=new CCombo(wFileComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wDateTimeFormat.setEditable(true);\r\n        props.setLook(wDateTimeFormat);\r\n        wDateTimeFormat.addModifyListener(lsMod);\r\n        fdDateTimeFormat=new FormData();\r\n        fdDateTimeFormat.left = new FormAttachment(middle, 0);\r\n        fdDateTimeFormat.top  = new FormAttachment(wSpecifyFormat, margin);\r\n        fdDateTimeFormat.right= new FormAttachment(100, 0);\r\n        wDateTimeFormat.setLayoutData(fdDateTimeFormat);\r\n\t\tString dats[] = Const.getDateFormats();\r\n        for (int x=0;x<dats.length;x++) wDateTimeFormat.add(dats[x]);\r\n        \r\n\r\n\r\n\t\twbShowFiles=new Button(wFileComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbShowFiles);\r\n\t\twbShowFiles.setText(Messages.getString(\"TextFileOutputDialog.ShowFiles.Button\"));\r\n\t\tfdbShowFiles=new FormData();\r\n\t\tfdbShowFiles.left = new FormAttachment(middle, 0);\r\n\t\tfdbShowFiles.top  = new FormAttachment(wDateTimeFormat, margin*2);\r\n\t\twbShowFiles.setLayoutData(fdbShowFiles);\r\n\t\twbShowFiles.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tTextFileOutputMeta tfoi = new TextFileOutputMeta();\r\n\t\t\t\t\tgetInfo(tfoi);\r\n\t\t\t\t\tString files[] = tfoi.getFiles(transMeta);\r\n\t\t\t\t\tif (files!=null && files.length>0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(shell, files, Messages.getString(\"TextFileOutputDialog.SelectOutputFiles.DialogTitle\"), Messages.getString(\"TextFileOutputDialog.SelectOutputFiles.DialogMessage\"));\r\n\t\t\t\t\t\tesd.setViewOnly();\r\n\t\t\t\t\t\tesd.open();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\r\n\t\t\t\t\t\tmb.setMessage(Messages.getString(\"TextFileOutputDialog.NoFilesFound.DialogMessage\"));\r\n\t\t\t\t\t\tmb.setText(Messages.getString(\"System.Dialog.Error.Title\"));\r\n\t\t\t\t\t\tmb.open(); \r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\r\n\t\t// Add File to the result files name\r\n\t\twlAddToResult=new Label(wFileComp, SWT.RIGHT);\r\n\t\twlAddToResult.setText(Messages.getString(\"TextFileOutputDialog.AddFileToResult.Label\"));\r\n\t\tprops.setLook(wlAddToResult);\r\n\t\tfdlAddToResult=new FormData();\r\n\t\tfdlAddToResult.left  = new FormAttachment(0, 0);\r\n\t\tfdlAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdlAddToResult.right = new FormAttachment(middle, -margin);\r\n\t\twlAddToResult.setLayoutData(fdlAddToResult);\r\n\t\twAddToResult=new Button(wFileComp, SWT.CHECK);\r\n\t\twAddToResult.setToolTipText(Messages.getString(\"TextFileOutputDialog.AddFileToResult.Tooltip\"));\r\n \t\tprops.setLook(wAddToResult);\r\n\t\tfdAddToResult=new FormData();\r\n\t\tfdAddToResult.left  = new FormAttachment(middle, 0);\r\n\t\tfdAddToResult.top   = new FormAttachment(wbShowFiles, 2*margin);\r\n\t\tfdAddToResult.right = new FormAttachment(100, 0);\r\n\t\twAddToResult.setLayoutData(fdAddToResult);\r\n\t\tSelectionAdapter lsSelR = new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent arg0)\r\n            {\r\n                input.setChanged();\r\n            }\r\n        };\r\n\t\twAddToResult.addSelectionListener(lsSelR);\r\n\r\n\t\t\r\n\t\tfdFileComp=new FormData();\r\n\t\tfdFileComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFileComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFileComp.right = new FormAttachment(100, 0);\r\n\t\tfdFileComp.bottom= new FormAttachment(100, 0);\r\n\t\twFileComp.setLayoutData(fdFileComp);\r\n\t\r\n\t\twFileComp.layout();\r\n\t\twFileTab.setControl(wFileComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF FILE TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t//////////////////////////\r\n\t\t// START OF CONTENT TAB///\r\n\t\t///\r\n\t\twContentTab=new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twContentTab.setText(Messages.getString(\"TextFileOutputDialog.ContentTab.TabTitle\"));\r\n\r\n\t\tFormLayout contentLayout = new FormLayout ();\r\n\t\tcontentLayout.marginWidth  = 3;\r\n\t\tcontentLayout.marginHeight = 3;\r\n\t\t\r\n\t\tComposite wContentComp = new Composite(wTabFolder, SWT.NONE);\r\n \t\tprops.setLook(wContentComp);\r\n\t\twContentComp.setLayout(contentLayout);\r\n\r\n\r\n\t\t// Append to end of file?\r\n\t\twlAppend=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlAppend.setText(Messages.getString(\"TextFileOutputDialog.Append.Label\"));\r\n \t\tprops.setLook(wlAppend);\r\n\t\tfdlAppend=new FormData();\r\n\t\tfdlAppend.left = new FormAttachment(0, 0);\r\n\t\tfdlAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdlAppend.right= new FormAttachment(middle, -margin);\r\n\t\twlAppend.setLayoutData(fdlAppend);\r\n\t\twAppend=new Button(wContentComp, SWT.CHECK);\r\n \t\tprops.setLook(wAppend);\r\n\t\tfdAppend=new FormData();\r\n\t\tfdAppend.left = new FormAttachment(middle, 0);\r\n\t\tfdAppend.top  = new FormAttachment(0, 0);\r\n\t\tfdAppend.right= new FormAttachment(100, 0);\r\n\t\twAppend.setLayoutData(fdAppend);\r\n\t\twAppend.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\twlSeparator=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlSeparator.setText(Messages.getString(\"TextFileOutputDialog.Separator.Label\"));\r\n \t\tprops.setLook(wlSeparator);\r\n\t\tfdlSeparator=new FormData();\r\n\t\tfdlSeparator.left = new FormAttachment(0, 0);\r\n\t\tfdlSeparator.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdlSeparator.right= new FormAttachment(middle, -margin);\r\n\t\twlSeparator.setLayoutData(fdlSeparator);\r\n\r\n\t\twbSeparator=new Button(wContentComp, SWT.PUSH| SWT.CENTER);\r\n \t\tprops.setLook(wbSeparator);\r\n\t\twbSeparator.setText(Messages.getString(\"TextFileOutputDialog.Separator.Button\"));\r\n\t\tfdbSeparator=new FormData();\r\n\t\tfdbSeparator.right= new FormAttachment(100, 0);\r\n\t\tfdbSeparator.top  = new FormAttachment(wAppend, 0);\r\n\t\twbSeparator.setLayoutData(fdbSeparator);\r\n\t\twbSeparator.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent se) \r\n\t\t\t\t{\r\n\t\t\t\t\t//wSeparator.insert(\"\\t\");\r\n\t\t\t\t\twSeparator.getTextWidget().insert(\"\\t\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twSeparator=new TextVar(transMeta,wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wSeparator);\r\n\t\twSeparator.addModifyListener(lsMod);\r\n\t\tfdSeparator=new FormData();\r\n\t\tfdSeparator.left = new FormAttachment(middle, 0);\r\n\t\tfdSeparator.top  = new FormAttachment(wAppend, margin);\r\n\t\tfdSeparator.right= new FormAttachment(wbSeparator, -margin);\r\n\t\twSeparator.setLayoutData(fdSeparator);\r\n\r\n\t\t// Enclosure line...\r\n\t\twlEnclosure=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlEnclosure.setText(Messages.getString(\"TextFileOutputDialog.Enclosure.Label\"));\r\n \t\tprops.setLook(wlEnclosure);\r\n\t\tfdlEnclosure=new FormData();\r\n\t\tfdlEnclosure.left = new FormAttachment(0, 0);\r\n\t\tfdlEnclosure.top  = new FormAttachment(wSeparator, margin);\r\n\t\tfdlEnclosure.right= new FormAttachment(middle, -margin);\r\n\t\twlEnclosure.setLayoutData(fdlEnclosure);\r\n\t\twEnclosure=new TextVar(transMeta, wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wEnclosure);\r\n\t\twEnclosure.addModifyListener(lsMod);\r\n\t\tfdEnclosure=new FormData();\r\n\t\tfdEnclosure.left = new FormAttachment(middle, 0);\r\n\t\tfdEnclosure.top  = new FormAttachment(wSeparator, margin);\r\n\t\tfdEnclosure.right= new FormAttachment(100, 0);\r\n\t\twEnclosure.setLayoutData(fdEnclosure);\r\n\r\n        wlEnclForced=new Label(wContentComp, SWT.RIGHT);\r\n        wlEnclForced.setText(Messages.getString(\"TextFileOutputDialog.EnclForced.Label\"));\r\n        props.setLook(wlEnclForced);\r\n        fdlEnclForced=new FormData();\r\n        fdlEnclForced.left = new FormAttachment(0, 0);\r\n        fdlEnclForced.top  = new FormAttachment(wEnclosure, margin);\r\n        fdlEnclForced.right= new FormAttachment(middle, -margin);\r\n        wlEnclForced.setLayoutData(fdlEnclForced);\r\n        wEnclForced=new Button(wContentComp, SWT.CHECK );\r\n        props.setLook(wEnclForced);\r\n        fdEnclForced=new FormData();\r\n        fdEnclForced.left = new FormAttachment(middle, 0);\r\n        fdEnclForced.top  = new FormAttachment(wEnclosure, margin);\r\n        fdEnclForced.right= new FormAttachment(100, 0);\r\n        wEnclForced.setLayoutData(fdEnclForced);\r\n        wEnclForced.addSelectionListener(new SelectionAdapter() \r\n            {\r\n                public void widgetSelected(SelectionEvent e) \r\n                {\r\n                    input.setChanged();\r\n                }\r\n            }\r\n        );\r\n\r\n\t\twlHeader=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlHeader.setText(Messages.getString(\"TextFileOutputDialog.Header.Label\"));\r\n \t\tprops.setLook(wlHeader);\r\n\t\tfdlHeader=new FormData();\r\n\t\tfdlHeader.left = new FormAttachment(0, 0);\r\n\t\tfdlHeader.top  = new FormAttachment(wEnclForced, margin);\r\n\t\tfdlHeader.right= new FormAttachment(middle, -margin);\r\n\t\twlHeader.setLayoutData(fdlHeader);\r\n\t\twHeader=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wHeader);\r\n\t\tfdHeader=new FormData();\r\n\t\tfdHeader.left = new FormAttachment(middle, 0);\r\n\t\tfdHeader.top  = new FormAttachment(wEnclForced, margin);\r\n\t\tfdHeader.right= new FormAttachment(100, 0);\r\n\t\twHeader.setLayoutData(fdHeader);\r\n\t\twHeader.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twlFooter=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFooter.setText(Messages.getString(\"TextFileOutputDialog.Footer.Label\"));\r\n \t\tprops.setLook(wlFooter);\r\n\t\tfdlFooter=new FormData();\r\n\t\tfdlFooter.left = new FormAttachment(0, 0);\r\n\t\tfdlFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdlFooter.right= new FormAttachment(middle, -margin);\r\n\t\twlFooter.setLayoutData(fdlFooter);\r\n\t\twFooter=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wFooter);\r\n\t\tfdFooter=new FormData();\r\n\t\tfdFooter.left = new FormAttachment(middle, 0);\r\n\t\tfdFooter.top  = new FormAttachment(wHeader, margin);\r\n\t\tfdFooter.right= new FormAttachment(100, 0);\r\n\t\twFooter.setLayoutData(fdFooter);\r\n\t\twFooter.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\twlFormat=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFormat.setText(Messages.getString(\"TextFileOutputDialog.Format.Label\"));\r\n \t\tprops.setLook(wlFormat);\r\n\t\tfdlFormat=new FormData();\r\n\t\tfdlFormat.left = new FormAttachment(0, 0);\r\n\t\tfdlFormat.top  = new FormAttachment(wFooter, margin);\r\n\t\tfdlFormat.right= new FormAttachment(middle, -margin);\r\n\t\twlFormat.setLayoutData(fdlFormat);\r\n\t\twFormat=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n\t\twFormat.setText(Messages.getString(\"TextFileOutputDialog.Format.Label\"));\r\n \t\tprops.setLook(wFormat);\r\n\r\n\t\twFormat.add(\"DOS\");\r\n\t\twFormat.add(\"Unix\");\r\n\t\twFormat.select(0);\r\n\t\twFormat.addModifyListener(lsMod);\r\n\t\tfdFormat=new FormData();\r\n\t\tfdFormat.left = new FormAttachment(middle, 0);\r\n\t\tfdFormat.top  = new FormAttachment(wFooter, margin);\r\n\t\tfdFormat.right= new FormAttachment(100, 0);\r\n\t\twFormat.setLayoutData(fdFormat);\r\n\r\n\t\twlCompression=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlCompression.setText(Messages.getString(\"TextFileOutputDialog.Compression.Label\"));\r\n \t\tprops.setLook(wlCompression);\r\n\t\tfdlCompression=new FormData();\r\n\t\tfdlCompression.left = new FormAttachment(0, 0);\r\n\t\tfdlCompression.top  = new FormAttachment(wFormat, margin);\r\n\t\tfdlCompression.right= new FormAttachment(middle, -margin);\r\n\t\twlCompression.setLayoutData(fdlCompression);\r\n\t\twCompression=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n\t\twCompression.setText(Messages.getString(\"TextFileOutputDialog.Compression.Label\"));\r\n \t\tprops.setLook(wCompression);\r\n\r\n\t\twCompression.setItems(TextFileOutputMeta.fileCompressionTypeCodes);\r\n\t\twCompression.addModifyListener(lsMod);\r\n\t\tfdCompression=new FormData();\r\n\t\tfdCompression.left = new FormAttachment(middle, 0);\r\n\t\tfdCompression.top  = new FormAttachment(wFormat, margin);\r\n\t\tfdCompression.right= new FormAttachment(100, 0);\r\n\t\twCompression.setLayoutData(fdCompression);\r\n\r\n        wlEncoding=new Label(wContentComp, SWT.RIGHT);\r\n        wlEncoding.setText(Messages.getString(\"TextFileOutputDialog.Encoding.Label\"));\r\n        props.setLook(wlEncoding);\r\n        fdlEncoding=new FormData();\r\n        fdlEncoding.left = new FormAttachment(0, 0);\r\n        fdlEncoding.top  = new FormAttachment(wCompression, margin);\r\n        fdlEncoding.right= new FormAttachment(middle, -margin);\r\n        wlEncoding.setLayoutData(fdlEncoding);\r\n        wEncoding=new CCombo(wContentComp, SWT.BORDER | SWT.READ_ONLY);\r\n        wEncoding.setEditable(true);\r\n        props.setLook(wEncoding);\r\n        wEncoding.addModifyListener(lsMod);\r\n        fdEncoding=new FormData();\r\n        fdEncoding.left = new FormAttachment(middle, 0);\r\n        fdEncoding.top  = new FormAttachment(wCompression, margin);\r\n        fdEncoding.right= new FormAttachment(100, 0);\r\n        wEncoding.setLayoutData(fdEncoding);\r\n        wEncoding.addFocusListener(new FocusListener()\r\n            {\r\n                public void focusLost(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                }\r\n            \r\n                public void focusGained(org.eclipse.swt.events.FocusEvent e)\r\n                {\r\n                    Cursor busy = new Cursor(shell.getDisplay(), SWT.CURSOR_WAIT);\r\n                    shell.setCursor(busy);\r\n                    setEncodings();\r\n                    shell.setCursor(null);\r\n                    busy.dispose();\r\n                }\r\n            }\r\n        );\r\n\r\n        \r\n\t\twlPad=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlPad.setText(Messages.getString(\"TextFileOutputDialog.Pad.Label\"));\r\n \t\tprops.setLook(wlPad);\r\n\t\tfdlPad=new FormData();\r\n\t\tfdlPad.left = new FormAttachment(0, 0);\r\n\t\tfdlPad.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdlPad.right= new FormAttachment(middle, -margin);\r\n\t\twlPad.setLayoutData(fdlPad);\r\n\t\twPad=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wPad);\r\n\t\tfdPad=new FormData();\r\n\t\tfdPad.left = new FormAttachment(middle, 0);\r\n\t\tfdPad.top  = new FormAttachment(wEncoding, margin);\r\n\t\tfdPad.right= new FormAttachment(100, 0);\r\n\t\twPad.setLayoutData(fdPad);\r\n\t\twPad.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\r\n\t\twlFastDump=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlFastDump.setText(Messages.getString(\"TextFileOutputDialog.FastDump.Label\"));\r\n \t\tprops.setLook(wlFastDump);\r\n\t\tfdlFastDump=new FormData();\r\n\t\tfdlFastDump.left = new FormAttachment(0, 0);\r\n\t\tfdlFastDump.top  = new FormAttachment(wPad, margin);\r\n\t\tfdlFastDump.right= new FormAttachment(middle, -margin);\r\n\t\twlFastDump.setLayoutData(fdlFastDump);\r\n\t\twFastDump=new Button(wContentComp, SWT.CHECK );\r\n \t\tprops.setLook(wFastDump);\r\n\t\tfdFastDump=new FormData();\r\n\t\tfdFastDump.left = new FormAttachment(middle, 0);\r\n\t\tfdFastDump.top  = new FormAttachment(wPad, margin);\r\n\t\tfdFastDump.right= new FormAttachment(100, 0);\r\n\t\twFastDump.setLayoutData(fdFastDump);\r\n\t\twFastDump.addSelectionListener(new SelectionAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tinput.setChanged();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\r\n\t\twlSplitEvery=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlSplitEvery.setText(Messages.getString(\"TextFileOutputDialog.SplitEvery.Label\"));\r\n \t\tprops.setLook(wlSplitEvery);\r\n\t\tfdlSplitEvery=new FormData();\r\n\t\tfdlSplitEvery.left = new FormAttachment(0, 0);\r\n\t\tfdlSplitEvery.top  = new FormAttachment(wFastDump, margin);\r\n\t\tfdlSplitEvery.right= new FormAttachment(middle, -margin);\r\n\t\twlSplitEvery.setLayoutData(fdlSplitEvery);\r\n\t\twSplitEvery=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wSplitEvery);\r\n\t\twSplitEvery.addModifyListener(lsMod);\r\n\t\tfdSplitEvery=new FormData();\r\n\t\tfdSplitEvery.left = new FormAttachment(middle, 0);\r\n\t\tfdSplitEvery.top  = new FormAttachment(wFastDump, margin);\r\n\t\tfdSplitEvery.right= new FormAttachment(100, 0);\r\n\t\twSplitEvery.setLayoutData(fdSplitEvery);\r\n\r\n\t\t//Bruise:\r\n\t\twlEndedLine=new Label(wContentComp, SWT.RIGHT);\r\n\t\twlEndedLine.setText(Messages.getString(\"TextFileOutputDialog.EndedLine.Label\"));\r\n \t\tprops.setLook(wlEndedLine);\r\n\t\tfdlEndedLine=new FormData();\r\n\t\tfdlEndedLine.left = new FormAttachment(0, 0);\r\n\t\tfdlEndedLine.top  = new FormAttachment(wSplitEvery, margin);\r\n\t\tfdlEndedLine.right= new FormAttachment(middle, -margin);\r\n\t\twlEndedLine.setLayoutData(fdlEndedLine);\r\n\t\twEndedLine=new Text(wContentComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wEndedLine);\r\n \t\twEndedLine.addModifyListener(lsMod);\r\n\t\tfdEndedLine=new FormData();\r\n\t\tfdEndedLine.left = new FormAttachment(middle, 0);\r\n\t\tfdEndedLine.top  = new FormAttachment(wSplitEvery, margin);\r\n\t\tfdEndedLine.right= new FormAttachment(100, 0);\r\n\t\twEndedLine.setLayoutData(fdEndedLine);\r\n\t\t\r\n\t\tfdContentComp = new FormData();\r\n\t\tfdContentComp.left  = new FormAttachment(0, 0);\r\n\t\tfdContentComp.top   = new FormAttachment(0, 0);\r\n\t\tfdContentComp.right = new FormAttachment(100, 0);\r\n\t\tfdContentComp.bottom= new FormAttachment(100, 0);\r\n\t\twContentComp.setLayoutData(fdContentComp);\r\n\r\n\t\twContentComp.layout();\r\n\t\twContentTab.setControl(wContentComp);\r\n\r\n\t\t/////////////////////////////////////////////////////////////\r\n\t\t/// END OF CONTENT TAB\r\n\t\t/////////////////////////////////////////////////////////////\r\n\r\n\t\t// Fields tab...\r\n\t\t//\r\n\t\twFieldsTab = new CTabItem(wTabFolder, SWT.NONE);\r\n\t\twFieldsTab.setText(Messages.getString(\"TextFileOutputDialog.FieldsTab.TabTitle\"));\r\n\t\t\r\n\t\tFormLayout fieldsLayout = new FormLayout ();\r\n\t\tfieldsLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tfieldsLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\t\r\n\t\tComposite wFieldsComp = new Composite(wTabFolder, SWT.NONE);\r\n\t\twFieldsComp.setLayout(fieldsLayout);\r\n \t\tprops.setLook(wFieldsComp);\r\n\r\n\t\twGet=new Button(wFieldsComp, SWT.PUSH);\r\n\t\twGet.setText(Messages.getString(\"System.Button.GetFields\"));\r\n\t\twGet.setToolTipText(Messages.getString(\"System.Tooltip.GetFields\"));\r\n\r\n\t\twMinWidth =new Button(wFieldsComp, SWT.PUSH);\r\n\t\twMinWidth.setText(Messages.getString(\"TextFileOutputDialog.MinWidth.Button\"));\r\n\t\twMinWidth.setToolTipText(Messages.getString(\"TextFileOutputDialog.MinWidth.Tooltip\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wGet, wMinWidth}, margin, null);\r\n\r\n\t\tfinal int FieldsCols=10;\r\n\t\tfinal int FieldsRows=input.getOutputFields().length;\r\n\t\t\r\n\t\t// Prepare a list of possible formats...\r\n\t\tString nums[] = Const.getNumberFormats();\r\n\t\tint totsize = dats.length + nums.length;\r\n\t\tString formats[] = new String[totsize];\r\n\t\tfor (int x=0;x<dats.length;x++) formats[x] = dats[x];\r\n\t\tfor (int x=0;x<nums.length;x++) formats[dats.length+x] = nums[x];\r\n\t\t\r\n\t\tColumnInfo[] colinf=new ColumnInfo[FieldsCols];\r\n\t\tcolinf[0]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.NameColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[1]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.TypeColumn.Column\"),       ColumnInfo.COLUMN_TYPE_CCOMBO, ValueMeta.getTypes() );\r\n\t\tcolinf[2]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.FormatColumn.Column\"),     ColumnInfo.COLUMN_TYPE_CCOMBO, formats);\r\n\t\tcolinf[3]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.LengthColumn.Column\"),     ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[4]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.PrecisionColumn.Column\"),  ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[5]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.CurrencyColumn.Column\"),   ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[6]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.DecimalColumn.Column\"),    ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[7]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.GroupColumn.Column\"),      ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\tcolinf[8]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.TrimTypeColumn.Column\"),  ColumnInfo.COLUMN_TYPE_CCOMBO,  ValueMeta.trimTypeDesc, true );\r\n\t\tcolinf[9]=new ColumnInfo(Messages.getString(\"TextFileOutputDialog.NullColumn.Column\"),       ColumnInfo.COLUMN_TYPE_TEXT,   false);\r\n\t\t\r\n\t\twFields=new TableView(transMeta, wFieldsComp, \r\n\t\t\t\t\t\t      SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, \r\n\t\t\t\t\t\t      colinf, \r\n\t\t\t\t\t\t      FieldsRows,  \r\n\t\t\t\t\t\t      lsMod,\r\n\t\t\t\t\t\t\t  props\r\n\t\t\t\t\t\t      );\r\n\r\n\t\tfdFields=new FormData();\r\n\t\tfdFields.left  = new FormAttachment(0, 0);\r\n\t\tfdFields.top   = new FormAttachment(0, 0);\r\n\t\tfdFields.right = new FormAttachment(100, 0);\r\n\t\tfdFields.bottom= new FormAttachment(wGet, -margin);\r\n\t\twFields.setLayoutData(fdFields);\r\n\r\n\t\tfdFieldsComp=new FormData();\r\n\t\tfdFieldsComp.left  = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.top   = new FormAttachment(0, 0);\r\n\t\tfdFieldsComp.right = new FormAttachment(100, 0);\r\n\t\tfdFieldsComp.bottom= new FormAttachment(100, 0);\r\n\t\twFieldsComp.setLayoutData(fdFieldsComp);\r\n\r\n\t\twFieldsComp.layout();\r\n\t\twFieldsTab.setControl(wFieldsComp);\r\n\r\n\t\tfdTabFolder = new FormData();\r\n\t\tfdTabFolder.left  = new FormAttachment(0, 0);\r\n\t\tfdTabFolder.top   = new FormAttachment(wStepname, margin);\r\n\t\tfdTabFolder.right = new FormAttachment(100, 0);\r\n\t\tfdTabFolder.bottom= new FormAttachment(100, -50);\r\n\t\twTabFolder.setLayoutData(fdTabFolder);\r\n\t\t\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\twOK.setText(Messages.getString(\"System.Button.OK\"));\r\n\r\n\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\"));\r\n\r\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, wTabFolder);\r\n\r\n\t\t// Add listeners\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();       } };\r\n\t\tlsGet      = new Listener() { public void handleEvent(Event e) { get();      } };\r\n\t\tlsMinWidth    = new Listener() { public void handleEvent(Event e) { setMinimalWidth(); } };\r\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel();   } };\r\n\t\t\r\n\t\twOK.addListener    (SWT.Selection, lsOK    );\r\n\t\twGet.addListener   (SWT.Selection, lsGet   );\r\n\t\twMinWidth.addListener (SWT.Selection, lsMinWidth );\r\n\t\twCancel.addListener(SWT.Selection, lsCancel);\r\n\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\r\n\t\twStepname.addSelectionListener( lsDef );\r\n\t\twFilename.addSelectionListener( lsDef );\r\n\t\twSeparator.addSelectionListener( lsDef );\r\n\r\n\t\t// Whenever something changes, set the tooltip to the expanded version:\r\n\t\twFilename.addModifyListener(new ModifyListener()\r\n\t\t\t{\r\n\t\t\t\tpublic void modifyText(ModifyEvent e)\r\n\t\t\t\t{\r\n\t\t\t\t\twFilename.setToolTipText(transMeta.environmentSubstitute( wFilename.getText() ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\twbFilename.addSelectionListener\r\n\t\t(\r\n\t\t\tnew SelectionAdapter()\r\n\t\t\t{\r\n\t\t\t\tpublic void widgetSelected(SelectionEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\r\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*.txt\", \"*.csv\", \"*\"});\r\n\t\t\t\t\tif (wFilename.getText()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdialog.setFileName(transMeta.environmentSubstitute(wFilename.getText()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdialog.setFilterNames(new String[] {Messages.getString(\"System.FileType.TextFiles\"), Messages.getString(\"System.FileType.CSVFiles\"), Messages.getString(\"System.FileType.AllFiles\")});\r\n\t\t\t\t\tif (dialog.open()!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tString extension = wExtension.getText();\r\n\t\t\t\t\t\tif ( extension != null && dialog.getFileName() != null &&\r\n\t\t\t\t\t\t\t\tdialog.getFileName().endsWith(\".\" + extension) )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// The extension is filled in and matches the end \r\n\t\t\t\t\t\t\t// of the selected file => Strip off the extension.\r\n\t\t\t\t\t\t\tString fileName = dialog.getFileName();\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+\r\n\t\t\t\t\t\t    \t\t          fileName.substring(0, fileName.length() - (extension.length()+1)));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t    wFilename.setText(dialog.getFilterPath()+System.getProperty(\"file.separator\")+dialog.getFileName());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// Detect X or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\t\tlsResize = new Listener() \r\n\t\t{\r\n\t\t\tpublic void handleEvent(Event event) \r\n\t\t\t{\r\n\t\t\t\tPoint size = shell.getSize();\r\n\t\t\t\twFields.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.table.setSize(size.x-10, size.y-50);\r\n\t\t\t\twFields.redraw();\r\n\t\t\t}\r\n\t\t};\r\n\t\tshell.addListener(SWT.Resize, lsResize);\r\n\r\n\t\twTabFolder.setSelection(0);\r\n\t\t\r\n\t\t// Set the shell size, based upon previous time...\r\n\t\tsetSize();\r\n\t\t\r\n\t\tgetData();\r\n\t\tinput.setChanged(changed);\r\n\t\t\r\n\t\tshell.open();\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn stepname;\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator = XMLHandler.getTagValue(stepnode, \"separator\");\r\n\t\t\tif (separator==null) separator=\"\";\r\n\t\t\t\r\n\t\t\tenclosure=XMLHandler.getTagValue(stepnode, \"enclosure\");\r\n\t\t\tif (enclosure==null) enclosure=\"\";\r\n\r\n            enclosureForced = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"enclosure_forced\"));\r\n\r\n\t\t\theaderEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\r\n\t\t\tfooterEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"footer\"));\r\n\t\t\tfileFormat       = XMLHandler.getTagValue(stepnode, \"format\");\r\n\t\t\tfileCompression  = XMLHandler.getTagValue(stepnode, \"compression\");\r\n\t\t\tif (fileCompression == null) \r\n            {\r\n\t\t\t  if (\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"zipped\")))\r\n              {\r\n\t\t\t      fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n              }\r\n\t\t\t  else\r\n              {\r\n\t\t\t\t  fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n              }\r\n\t\t\t}\r\n            encoding = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\r\n            endedLine = XMLHandler.getTagValue(stepnode, \"endedLine\");\r\n\t\t\tif (endedLine==null) endedLine=\"\";\r\n\r\n\t\t\tfileName              = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\tfileAsCommand         = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"is_command\"));\r\n\t\t\tdoNotOpenNewFileInit  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"do_not_open_new_file_init\"));\r\n\t\t\textension             = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\tfileAppended          = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"append\"));\r\n\t\t\tstepNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tpartNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"haspartno\"));\r\n\t\t\tdateInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tSpecifyFormat        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"SpecifyFormat\"));\r\n\t\t\tdate_time_format             = XMLHandler.getTagValue(stepnode, \"file\", \"date_time_format\");\r\n\t\t\t\r\n\t\t\tString AddToResultFiles= XMLHandler.getTagValue(stepnode, \"file\", \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames  = \"Y\".equalsIgnoreCase(AddToResultFiles);\r\n\t\t\t\r\n\t\t\tpadded       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"pad\"));\r\n\t\t\tfastDump     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"fast_dump\"));\r\n\t\t\tsplitEvery   = Const.toInt(XMLHandler.getTagValue(stepnode, \"file\", \"splitevery\"), 0);\r\n\t\t\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\t\tNode fields  = XMLHandler.getSubNode(stepnode, \"fields\");\r\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\r\n\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\r\n\t\t\t\r\n\t\t\t\toutputFields[i] = new TextFileField();\r\n\t\t\t\toutputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\r\n\t\t\t\toutputFields[i].setType( XMLHandler.getTagValue(fnode, \"type\") );\r\n\t\t\t\toutputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\r\n\t\t\t\toutputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\r\n\t\t\t\toutputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\r\n\t\t\t\toutputFields[i].setGroupingSymbol( XMLHandler.getTagValue(fnode, \"group\") );\r\n\t\t\t    outputFields[i].setTrimType( ValueMeta.getTrimTypeByCode(XMLHandler.getTagValue(fnode, \"trim_type\")) );\r\n\t\t\t\toutputFields[i].setNullString( XMLHandler.getTagValue(fnode, \"nullif\") );\r\n\t\t\t\toutputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\r\n\t\t\t\toutputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\r\n\t\t}\r\n\t}","id":42569,"modified_method":"private void readData(Node stepnode)\r\n\t\tthrows KettleXMLException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator = XMLHandler.getTagValue(stepnode, \"separator\");\r\n\t\t\tif (separator==null) separator=\"\";\r\n\t\t\t\r\n\t\t\tenclosure=XMLHandler.getTagValue(stepnode, \"enclosure\");\r\n\t\t\tif (enclosure==null) enclosure=\"\";\r\n\r\n            enclosureForced = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"enclosure_forced\"));\r\n\r\n\t\t\theaderEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"header\"));\r\n\t\t\tfooterEnabled    = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"footer\"));\r\n\t\t\tfileFormat       = XMLHandler.getTagValue(stepnode, \"format\");\r\n\t\t\tfileCompression  = XMLHandler.getTagValue(stepnode, \"compression\");\r\n\t\t\tif (fileCompression == null) \r\n            {\r\n\t\t\t  if (\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"zipped\")))\r\n              {\r\n\t\t\t      fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n              }\r\n\t\t\t  else\r\n              {\r\n\t\t\t\t  fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n              }\r\n\t\t\t}\r\n            encoding = XMLHandler.getTagValue(stepnode, \"encoding\");\r\n\r\n            endedLine = XMLHandler.getTagValue(stepnode, \"endedLine\");\r\n\t\t\tif (endedLine==null) endedLine=\"\";\r\n\r\n\t\t\tfileName              = XMLHandler.getTagValue(stepnode, \"file\", \"name\");\r\n\t\t\tfileAsCommand         = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"is_command\"));\r\n\t\t\tdoNotOpenNewFileInit  = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"do_not_open_new_file_init\"));\r\n\t\t\textension             = XMLHandler.getTagValue(stepnode, \"file\", \"extention\");\r\n\t\t\tfileAppended          = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"append\"));\r\n\t\t\tstepNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"split\"));\r\n\t\t\tpartNrInFilename      = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"haspartno\"));\r\n\t\t\tdateInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_date\"));\r\n\t\t\ttimeInFilename        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"add_time\"));\r\n\t\t\tSpecifyFormat        = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"SpecifyFormat\"));\r\n\t\t\tdate_time_format             = XMLHandler.getTagValue(stepnode, \"file\", \"date_time_format\");\r\n\t\t\t\r\n\t\t\tString AddToResultFiles= XMLHandler.getTagValue(stepnode, \"file\", \"add_to_result_filenames\");\r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames  = \"Y\".equalsIgnoreCase(AddToResultFiles);\r\n\t\t\t\r\n\t\t\tpadded       = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"pad\"));\r\n\t\t\tfastDump     = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"file\", \"fast_dump\"));\r\n\t\t\tsplitEvery   = Const.toInt(XMLHandler.getTagValue(stepnode, \"file\", \"splitevery\"), 0);\r\n\t\t\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\r\n\t\t\tfileNameInField=\"Y\".equalsIgnoreCase(XMLHandler.getTagValue(stepnode, \"fileNameInField\"));\r\n\t\t\tfileNameField       = XMLHandler.getTagValue(stepnode, \"fileNameField\");\r\n\t\t\t\t\t\t\r\n\t\t\tNode fields  = XMLHandler.getSubNode(stepnode, \"fields\");\r\n\t\t\tint nrfields = XMLHandler.countNodes(fields, \"field\");\r\n\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t\tNode fnode = XMLHandler.getSubNodeByNr(fields, \"field\", i);\r\n\t\t\t\r\n\t\t\t\toutputFields[i] = new TextFileField();\r\n\t\t\t\toutputFields[i].setName( XMLHandler.getTagValue(fnode, \"name\") );\r\n\t\t\t\toutputFields[i].setType( XMLHandler.getTagValue(fnode, \"type\") );\r\n\t\t\t\toutputFields[i].setFormat( XMLHandler.getTagValue(fnode, \"format\") );\r\n\t\t\t\toutputFields[i].setCurrencySymbol( XMLHandler.getTagValue(fnode, \"currency\") );\r\n\t\t\t\toutputFields[i].setDecimalSymbol( XMLHandler.getTagValue(fnode, \"decimal\") );\r\n\t\t\t\toutputFields[i].setGroupingSymbol( XMLHandler.getTagValue(fnode, \"group\") );\r\n\t\t\t    outputFields[i].setTrimType( ValueMeta.getTrimTypeByCode(XMLHandler.getTagValue(fnode, \"trim_type\")) );\r\n\t\t\t\toutputFields[i].setNullString( XMLHandler.getTagValue(fnode, \"nullif\") );\r\n\t\t\t\toutputFields[i].setLength( Const.toInt(XMLHandler.getTagValue(fnode, \"length\"), -1) );\r\n\t\t\t\toutputFields[i].setPrecision( Const.toInt(XMLHandler.getTagValue(fnode, \"precision\"), -1) );\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleXMLException(\"Unable to load step info from XML\", e);\r\n\t\t}\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator       =      rep.getStepAttributeString (id_step, \"separator\");\r\n\t\t\tenclosure       =      rep.getStepAttributeString (id_step, \"enclosure\");\r\n            enclosureForced =      rep.getStepAttributeBoolean(id_step, \"enclosure_forced\");\r\n\t\t\theaderEnabled   =      rep.getStepAttributeBoolean(id_step, \"header\");\r\n\t\t\tfooterEnabled   =      rep.getStepAttributeBoolean(id_step, \"footer\");   \r\n\t\t\tfileFormat      =      rep.getStepAttributeString (id_step, \"format\");  \r\n\t\t\tfileCompression =      rep.getStepAttributeString (id_step, \"compression\");\r\n\t\t\tif (fileCompression == null)\r\n\t\t\t{\r\n\t\t\t\tif (rep.getStepAttributeBoolean(id_step, \"zipped\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tfileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n\t\t\t\t}\r\n                else\r\n                {\r\n                    fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n                }\r\n\t\t\t}\r\n            encoding        =      rep.getStepAttributeString (id_step, \"encoding\");\r\n            \r\n\t\t\tfileName        =      rep.getStepAttributeString (id_step, \"file_name\");  \r\n\t\t\tfileAsCommand        =      rep.getStepAttributeBoolean (id_step, \"file_is_command\");  \r\n\t\t\tdoNotOpenNewFileInit =      rep.getStepAttributeBoolean(id_step, \"do_not_open_new_file_init\");\r\n\t\t\textension       =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\tfileAppended          =      rep.getStepAttributeBoolean(id_step, \"file_append\");\r\n\t\t\tsplitEvery      = (int)rep.getStepAttributeInteger(id_step, \"file_split\");\r\n\t\t\tstepNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tpartNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_partnr\");\r\n\t\t\tdateInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tSpecifyFormat        =      rep.getStepAttributeBoolean(id_step, \"SpecifyFormat\");\r\n\t\t\tdate_time_format       =      rep.getStepAttributeString (id_step, \"date_time_format\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tString AddToResultFiles = rep.getStepAttributeString (id_step, \"add_to_result_filenames\");  \r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames   =      rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tpadded             =      rep.getStepAttributeBoolean(id_step, \"file_pad\");\r\n\t\t\tfastDump             =      rep.getStepAttributeBoolean(id_step, \"file_fast_dump\");\r\n\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\t\t\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t    outputFields[i] = new TextFileField();\r\n\r\n\t\t\t    outputFields[i].setName(    \t\trep.getStepAttributeString (id_step, i, \"field_name\") );\r\n\t\t\t    outputFields[i].setType( \t\t\trep.getStepAttributeString (id_step, i, \"field_type\") );\r\n\t\t\t    outputFields[i].setFormat(  \t\trep.getStepAttributeString (id_step, i, \"field_format\") );\r\n\t\t\t    outputFields[i].setCurrencySymbol(\trep.getStepAttributeString (id_step, i, \"field_currency\") );\r\n\t\t\t    outputFields[i].setDecimalSymbol(\trep.getStepAttributeString (id_step, i, \"field_decimal\") );\r\n\t\t\t    outputFields[i].setGroupingSymbol(\trep.getStepAttributeString (id_step, i, \"field_group\") );\r\n\t\t\t\toutputFields[i].setTrimType(        ValueMeta.getTrimTypeByCode(rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\t\t\t    \r\n\t\t\t    outputFields[i].setNullString(\t\trep.getStepAttributeString (id_step, i, \"field_nullif\") );\r\n\t\t\t    outputFields[i].setLength(\t   (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\r\n\t\t\t    outputFields[i].setPrecision(  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\r\n\t\t\t}\r\n            endedLine        =      rep.getStepAttributeString (id_step, \"endedLine\");\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\r\n\t\t}\r\n\t}","id":42570,"modified_method":"public void readRep(Repository rep, long id_step, List<DatabaseMeta> databases, Map<String, Counter> counters)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tseparator       =      rep.getStepAttributeString (id_step, \"separator\");\r\n\t\t\tenclosure       =      rep.getStepAttributeString (id_step, \"enclosure\");\r\n            enclosureForced =      rep.getStepAttributeBoolean(id_step, \"enclosure_forced\");\r\n\t\t\theaderEnabled   =      rep.getStepAttributeBoolean(id_step, \"header\");\r\n\t\t\tfooterEnabled   =      rep.getStepAttributeBoolean(id_step, \"footer\");   \r\n\t\t\tfileFormat      =      rep.getStepAttributeString (id_step, \"format\");  \r\n\t\t\tfileCompression =      rep.getStepAttributeString (id_step, \"compression\");\r\n\t\t\tfileNameInField =      rep.getStepAttributeBoolean (id_step, \"fileNameInField\");\r\n\t\t\tfileNameField\t=\t   rep.getStepAttributeString (id_step, \"fileNameField\");\r\n\t\t\tif (fileCompression == null)\r\n\t\t\t{\r\n\t\t\t\tif (rep.getStepAttributeBoolean(id_step, \"zipped\"))\r\n\t\t\t\t{\r\n\t\t\t\t\tfileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_ZIP];\r\n\t\t\t\t}\r\n                else\r\n                {\r\n                    fileCompression = fileCompressionTypeCodes[FILE_COMPRESSION_TYPE_NONE];\r\n                }\r\n\t\t\t}\r\n            encoding        =      rep.getStepAttributeString (id_step, \"encoding\");\r\n            \r\n\t\t\tfileName        =      rep.getStepAttributeString (id_step, \"file_name\");  \r\n\t\t\tfileAsCommand        =      rep.getStepAttributeBoolean (id_step, \"file_is_command\");  \r\n\t\t\tdoNotOpenNewFileInit =      rep.getStepAttributeBoolean(id_step, \"do_not_open_new_file_init\");\r\n\t\t\textension       =      rep.getStepAttributeString (id_step, \"file_extention\");\r\n\t\t\tfileAppended          =      rep.getStepAttributeBoolean(id_step, \"file_append\");\r\n\t\t\tsplitEvery      = (int)rep.getStepAttributeInteger(id_step, \"file_split\");\r\n\t\t\tstepNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_stepnr\");\r\n\t\t\tpartNrInFilename      =      rep.getStepAttributeBoolean(id_step, \"file_add_partnr\");\r\n\t\t\tdateInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_date\");\r\n\t\t\ttimeInFilename        =      rep.getStepAttributeBoolean(id_step, \"file_add_time\");\r\n\t\t\tSpecifyFormat        =      rep.getStepAttributeBoolean(id_step, \"SpecifyFormat\");\r\n\t\t\tdate_time_format       =      rep.getStepAttributeString (id_step, \"date_time_format\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tString AddToResultFiles = rep.getStepAttributeString (id_step, \"add_to_result_filenames\");  \r\n\t\t\tif(Const.isEmpty(AddToResultFiles))\r\n\t\t\t\taddToResultFilenames=true;\r\n\t\t\telse\r\n\t\t\t\taddToResultFilenames   =      rep.getStepAttributeBoolean(id_step, \"add_to_result_filenames\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tpadded             =      rep.getStepAttributeBoolean(id_step, \"file_pad\");\r\n\t\t\tfastDump             =      rep.getStepAttributeBoolean(id_step, \"file_fast_dump\");\r\n\t\r\n\t\t\tnewline = getNewLine(fileFormat);\r\n\t\t\t\r\n\t\t\tint nrfields = rep.countNrStepAttributes(id_step, \"field_name\");\r\n\t\t\t\r\n\t\t\tallocate(nrfields);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<nrfields;i++)\r\n\t\t\t{\r\n\t\t\t    outputFields[i] = new TextFileField();\r\n\r\n\t\t\t    outputFields[i].setName(    \t\trep.getStepAttributeString (id_step, i, \"field_name\") );\r\n\t\t\t    outputFields[i].setType( \t\t\trep.getStepAttributeString (id_step, i, \"field_type\") );\r\n\t\t\t    outputFields[i].setFormat(  \t\trep.getStepAttributeString (id_step, i, \"field_format\") );\r\n\t\t\t    outputFields[i].setCurrencySymbol(\trep.getStepAttributeString (id_step, i, \"field_currency\") );\r\n\t\t\t    outputFields[i].setDecimalSymbol(\trep.getStepAttributeString (id_step, i, \"field_decimal\") );\r\n\t\t\t    outputFields[i].setGroupingSymbol(\trep.getStepAttributeString (id_step, i, \"field_group\") );\r\n\t\t\t\toutputFields[i].setTrimType(        ValueMeta.getTrimTypeByCode(rep.getStepAttributeString(id_step, i, \"field_trim_type\")) );\t\t\t    \r\n\t\t\t    outputFields[i].setNullString(\t\trep.getStepAttributeString (id_step, i, \"field_nullif\") );\r\n\t\t\t    outputFields[i].setLength(\t   (int)rep.getStepAttributeInteger(id_step, i, \"field_length\") );\r\n\t\t\t    outputFields[i].setPrecision(  (int)rep.getStepAttributeInteger(id_step, i, \"field_precision\") );\r\n\t\t\t}\r\n            endedLine        =      rep.getStepAttributeString (id_step, \"endedLine\");\r\n\t\t\t\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unexpected error reading step information from the repository\", e);\r\n\t\t}\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\",        separator);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\",        enclosure);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"enclosure_forced\", enclosureForced);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",           headerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"footer\",           footerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"format\",           fileFormat);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"compression\",      fileCompression);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_is_command\",  fileAsCommand);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"do_not_open_new_file_init\", doNotOpenNewFileInit);  \r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_append\",      fileAppended);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_split\",       splitEvery);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_partnr\",  partNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"date_time_format\",   date_time_format);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"SpecifyFormat\",    SpecifyFormat);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addToResultFilenames);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_pad\",         padded);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_fast_dump\",   fastDump);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t\t{\r\n\t\t\t    TextFileField field = outputFields[i];\r\n\t\t\t    \r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getName());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field.getTypeDesc());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    field.getFormat());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\",  field.getCurrencySymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",   field.getDecimalSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",     field.getGroupingSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", field.getTrimTypeCode());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\",    field.getNullString());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    field.getLength());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\r\n\t\t\t}\r\n            rep.saveStepAttribute(id_transformation, id_step, \"endedLine\",         endedLine);\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\r\n\t\t}\r\n\t}","id":42571,"modified_method":"public void saveRep(Repository rep, long id_transformation, long id_step)\r\n\t\tthrows KettleException\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"separator\",        separator);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"enclosure\",        enclosure);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"enclosure_forced\", enclosureForced);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"header\",           headerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"footer\",           footerEnabled);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"format\",           fileFormat);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"compression\",      fileCompression);\r\n            rep.saveStepAttribute(id_transformation, id_step, \"encoding\",         encoding);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_name\",        fileName);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_is_command\",  fileAsCommand);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"do_not_open_new_file_init\", doNotOpenNewFileInit);  \r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_extention\",   extension);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_append\",      fileAppended);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_split\",       splitEvery);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_stepnr\",  stepNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_partnr\",  partNrInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_date\",    dateInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"date_time_format\",   date_time_format);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"SpecifyFormat\",    SpecifyFormat);\r\n\t\t\t\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"add_to_result_filenames\",    addToResultFilenames);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_add_time\",    timeInFilename);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_pad\",         padded);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"file_fast_dump\",   fastDump);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"fileNameInField\",   fileNameInField);\r\n\t\t\trep.saveStepAttribute(id_transformation, id_step, \"fileNameField\",   fileNameField);\r\n\t\t\t\r\n\t\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t\t{\r\n\t\t\t    TextFileField field = outputFields[i];\r\n\t\t\t    \r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_name\",      field.getName());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_type\",      field.getTypeDesc());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_format\",    field.getFormat());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_currency\",  field.getCurrencySymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_decimal\",   field.getDecimalSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_group\",     field.getGroupingSymbol());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_trim_type\", field.getTrimTypeCode());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_nullif\",    field.getNullString());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_length\",    field.getLength());\r\n\t\t\t\trep.saveStepAttribute(id_transformation, id_step, i, \"field_precision\", field.getPrecision());\r\n\t\t\t}\r\n            rep.saveStepAttribute(id_transformation, id_step, \"endedLine\",         endedLine);\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tthrow new KettleException(\"Unable to save step information to the repository for id_step=\"+id_step, e);\r\n\t\t}\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\r\n\t{\r\n\t\tStringBuffer retval=new StringBuffer(800);\r\n\t\t\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", separator));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure_forced\", enclosureForced));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\",    headerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"footer\",    footerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"format\",    fileFormat));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"compression\",    fileCompression));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"endedLine\",  endedLine));\r\n\r\n\t\tretval.append(\"    <file>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"is_command\", fileAsCommand));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"do_not_open_new_file_init\", doNotOpenNewFileInit));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",     fileAppended));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"haspartno\",  partNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"SpecifyFormat\",   SpecifyFormat));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"date_time_format\",  date_time_format));\r\n\t\t\r\n\t\t\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_to_result_filenames\",   addToResultFilenames));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"pad\",        padded));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"fast_dump\",  fastDump));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"splitevery\", splitEvery));\r\n\t\tretval.append(\"    <\/file>\").append(Const.CR);\r\n        \r\n\t\tretval.append(\"    <fields>\").append(Const.CR);\r\n\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t{\r\n\t\t    TextFileField field = outputFields[i];\r\n\t\t    \r\n\t\t\tif (field.getName()!=null && field.getName().length()!=0)\r\n\t\t\t{\r\n\t\t\t\tretval.append(\"      <field>\").append(Const.CR);\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getName()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\",      field.getTypeDesc()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\",    field.getFormat()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\",  field.getCurrencySymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\",   field.getDecimalSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\",     field.getGroupingSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"nullif\",    field.getNullString()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", field.getTrimTypeCode()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\",    field.getLength()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\r\n\t\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\r\n\t\t\t}\r\n\t\t}\r\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n\t\treturn retval.toString();\r\n\t}","id":42572,"modified_method":"public String getXML()\r\n\t{\r\n\t\tStringBuffer retval=new StringBuffer(800);\r\n\t\t\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"separator\", separator));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure\", enclosure));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"enclosure_forced\", enclosureForced));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"header\",    headerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"footer\",    footerEnabled));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"format\",    fileFormat));\r\n\t\tretval.append(\"    \").append(XMLHandler.addTagValue(\"compression\",    fileCompression));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"encoding\",  encoding));\r\n        retval.append(\"    \").append(XMLHandler.addTagValue(\"endedLine\",  endedLine));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"fileNameInField\",  fileNameInField));\r\n        retval.append(\"    \"+XMLHandler.addTagValue(\"fileNameField\",  fileNameField));        \r\n\r\n\t\tretval.append(\"    <file>\").append(Const.CR);\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"name\",       fileName));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"is_command\", fileAsCommand));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"do_not_open_new_file_init\", doNotOpenNewFileInit));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"extention\",  extension));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"append\",     fileAppended));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"split\",      stepNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"haspartno\",  partNrInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_date\",   dateInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_time\",   timeInFilename));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"SpecifyFormat\",   SpecifyFormat));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"date_time_format\",  date_time_format));\r\n\t\t\r\n\t\t\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_to_result_filenames\",   addToResultFilenames));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"pad\",        padded));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"fast_dump\",  fastDump));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"splitevery\", splitEvery));\r\n\t\tretval.append(\"    <\/file>\").append(Const.CR);\r\n        \r\n\t\tretval.append(\"    <fields>\").append(Const.CR);\r\n\t\tfor (int i=0;i<outputFields.length;i++)\r\n\t\t{\r\n\t\t    TextFileField field = outputFields[i];\r\n\t\t    \r\n\t\t\tif (field.getName()!=null && field.getName().length()!=0)\r\n\t\t\t{\r\n\t\t\t\tretval.append(\"      <field>\").append(Const.CR);\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"name\",      field.getName()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"type\",      field.getTypeDesc()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"format\",    field.getFormat()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"currency\",  field.getCurrencySymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"decimal\",   field.getDecimalSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"group\",     field.getGroupingSymbol()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"nullif\",    field.getNullString()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"trim_type\", field.getTrimTypeCode()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"length\",    field.getLength()));\r\n\t\t\t\tretval.append(\"        \").append(XMLHandler.addTagValue(\"precision\", field.getPrecision()));\r\n\t\t\t\tretval.append(\"      <\/field>\").append(Const.CR);\r\n\t\t\t}\r\n\t\t}\r\n\t\tretval.append(\"    <\/fields>\").append(Const.CR);\r\n\r\n\t\treturn retval.toString();\r\n\t}","commit_id":"3cf81be0f3daa9c58ff210868cd88b053177df26","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Int2ObjectHashMap makePersistent() throws XPathException {\n        if (size <= 1)\n            return null;\n        List oldIds = new ArrayList(20);\n        int top = 1;\n        while (top > 0) {\n            oldIds.add(new Integer(top));\n            top = getNextSiblingFor(top);\n        }\n        DocumentImpl expandedDoc = expandRefs();\n        org.exist.dom.DocumentImpl doc = context.storeTemporaryDoc(expandedDoc);\n        NodeList cl = doc.getDocumentElement().getChildNodes();\n        storedNodes = new Int2ObjectHashMap();\n        top = 1;\n        int i = 0;\n        while(top > 0 && i < cl.getLength()) {\n            org.exist.dom.NodeImpl node = (org.exist.dom.NodeImpl) cl.item(i);\n            NodeProxy proxy = new NodeProxy(doc, node.getGID(), node.getInternalAddress());\n            int old = ((Integer)oldIds.get(i)).intValue();\n            storedNodes.put(old, proxy);\n            top = expandedDoc.getNextSiblingFor(top);\n            i++;\n        }\n        return storedNodes;\n    }","id":42573,"modified_method":"public Int2ObjectHashMap makePersistent() throws XPathException {\n        if (size <= 1)\n            return null;\n        List oldIds = new ArrayList(20);\n        int top = 1;\n        while (top > 0) {\n            oldIds.add(new Integer(top));\n            top = getNextSiblingFor(top);\n        }\n        DocumentImpl expandedDoc = expandRefs();\n        org.exist.dom.DocumentImpl doc = context.storeTemporaryDoc(expandedDoc);\n        org.exist.dom.ElementImpl root = (org.exist.dom.ElementImpl) doc.getDocumentElement();\n        NodeList cl = root.getChildNodes();\n        storedNodes = new Int2ObjectHashMap();\n        storedNodes.put(0, new NodeProxy(doc, root.getGID(), root.getInternalAddress()));\n        top = 1;\n        int i = 0;\n        while(top > 0 && i < cl.getLength()) {\n            org.exist.dom.NodeImpl node = (org.exist.dom.NodeImpl) cl.item(i);\n            NodeProxy proxy = new NodeProxy(doc, node.getGID(), node.getInternalAddress());\n            int old = ((Integer)oldIds.get(i)).intValue();\n            storedNodes.put(old, proxy);\n            top = expandedDoc.getNextSiblingFor(top);\n            i++;\n        }\n        return storedNodes;\n    }","commit_id":"5ad382d5074e3b4f2dc1c417335337edf93fdf33","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @param alignRadioGroup the name of the alignment radio group.\n     * @return the panel holding the vertical alignment settings for the image\n     */\n    private Panel getVerticalAlignmentPanel(String alignRadioGroup)\n    {\n        FlowPanel vAlignPanel = new FlowPanel();\n        Label vAlignLabel = new Label(Strings.INSTANCE.imageVerticalAlignmentLabel());\n        vAlignPanel.addStyleName(\"xVAlignPanel\");\n        vAlignPanel.add(vAlignLabel);\n        RadioButton topRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignTopLabel());\n        topRadio.setValue(ImageConfig.ImageAlignment.TOP.toString());\n        topRadio.addKeyboardListener(this);\n        RadioButton middleRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignMiddleLabel());\n        middleRadio.setValue(ImageConfig.ImageAlignment.MIDDLE.toString());\n        middleRadio.addKeyboardListener(this);\n        RadioButton bottomRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignBottomLabel());\n        bottomRadio.setValue(ImageConfig.ImageAlignment.BOTTOM.toString());\n        bottomRadio.addKeyboardListener(this);\n        alignmentOptions.add(topRadio);\n        alignmentOptions.add(middleRadio);\n        alignmentOptions.add(bottomRadio);\n        vAlignPanel.add(topRadio);\n        vAlignPanel.add(middleRadio);\n        vAlignPanel.add(bottomRadio);\n\n        return vAlignPanel;\n    }","id":42574,"modified_method":"/**\n     * @param alignRadioGroup the name of the alignment radio group.\n     * @return the panel holding the vertical alignment settings for the image\n     */\n    private Panel getVerticalAlignmentPanel(String alignRadioGroup)\n    {\n        FlowPanel vAlignPanel = new FlowPanel();\n        Label vAlignLabel = new Label(Strings.INSTANCE.imageVerticalAlignmentLabel());\n        vAlignPanel.addStyleName(\"xVAlignPanel\");\n        vAlignPanel.add(vAlignLabel);\n        RadioButton topRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignTopLabel());\n        topRadio.setFormValue(ImageConfig.ImageAlignment.TOP.toString());\n        topRadio.addKeyboardListener(this);\n        RadioButton middleRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignMiddleLabel());\n        middleRadio.setFormValue(ImageConfig.ImageAlignment.MIDDLE.toString());\n        middleRadio.addKeyboardListener(this);\n        RadioButton bottomRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignBottomLabel());\n        bottomRadio.setFormValue(ImageConfig.ImageAlignment.BOTTOM.toString());\n        bottomRadio.addKeyboardListener(this);\n        alignmentOptions.add(topRadio);\n        alignmentOptions.add(middleRadio);\n        alignmentOptions.add(bottomRadio);\n        vAlignPanel.add(topRadio);\n        vAlignPanel.add(middleRadio);\n        vAlignPanel.add(bottomRadio);\n\n        return vAlignPanel;\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the selected image alignment\n     */\n    public ImageConfig.ImageAlignment getSelectedAlignment()\n    {\n        for (RadioButton rb : alignmentOptions) {\n            if (rb.isChecked()) {\n                return ImageConfig.ImageAlignment.valueOf(rb.getValue());\n            }\n        }\n        return null;\n    }","id":42575,"modified_method":"/**\n     * @return the selected image alignment\n     */\n    public ImageConfig.ImageAlignment getSelectedAlignment()\n    {\n        for (RadioButton rb : alignmentOptions) {\n            if (rb.isChecked()) {\n                return ImageConfig.ImageAlignment.valueOf(rb.getFormValue());\n            }\n        }\n        return null;\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param alignRadioGroup the name of the alignment radio group.\n     * @return the panel holding the horizontal alignment settings for the image\n     */\n    private Panel getHorizontalAlignmentPanel(String alignRadioGroup)\n    {\n        FlowPanel hAlignPanel = new FlowPanel();\n        Label hAlignLabel = new Label(Strings.INSTANCE.imageHorizontalAlignmentLabel());\n        hAlignPanel.addStyleName(\"xHAlignPanel\");\n        hAlignPanel.add(hAlignLabel);\n        alignmentOptions = new ArrayList<RadioButton>();\n        RadioButton leftRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignLeftLabel());\n        leftRadio.setValue(ImageConfig.ImageAlignment.LEFT.toString());\n        leftRadio.addKeyboardListener(this);\n        RadioButton centerRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignCenterLabel());\n        centerRadio.setValue(ImageConfig.ImageAlignment.CENTER.toString());\n        centerRadio.addKeyboardListener(this);\n        RadioButton rightRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignRightLabel());\n        rightRadio.setValue(ImageConfig.ImageAlignment.RIGHT.toString());\n        rightRadio.addKeyboardListener(this);\n        alignmentOptions.add(leftRadio);\n        alignmentOptions.add(centerRadio);\n        alignmentOptions.add(rightRadio);\n        hAlignPanel.add(leftRadio);\n        hAlignPanel.add(centerRadio);\n        hAlignPanel.add(rightRadio);\n\n        return hAlignPanel;\n    }","id":42576,"modified_method":"/**\n     * @param alignRadioGroup the name of the alignment radio group.\n     * @return the panel holding the horizontal alignment settings for the image\n     */\n    private Panel getHorizontalAlignmentPanel(String alignRadioGroup)\n    {\n        FlowPanel hAlignPanel = new FlowPanel();\n        Label hAlignLabel = new Label(Strings.INSTANCE.imageHorizontalAlignmentLabel());\n        hAlignPanel.addStyleName(\"xHAlignPanel\");\n        hAlignPanel.add(hAlignLabel);\n        alignmentOptions = new ArrayList<RadioButton>();\n        RadioButton leftRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignLeftLabel());\n        leftRadio.setFormValue(ImageConfig.ImageAlignment.LEFT.toString());\n        leftRadio.addKeyboardListener(this);\n        RadioButton centerRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignCenterLabel());\n        centerRadio.setFormValue(ImageConfig.ImageAlignment.CENTER.toString());\n        centerRadio.addKeyboardListener(this);\n        RadioButton rightRadio = new RadioButton(alignRadioGroup, Strings.INSTANCE.imageAlignRightLabel());\n        rightRadio.setFormValue(ImageConfig.ImageAlignment.RIGHT.toString());\n        rightRadio.addKeyboardListener(this);\n        alignmentOptions.add(leftRadio);\n        alignmentOptions.add(centerRadio);\n        alignmentOptions.add(rightRadio);\n        hAlignPanel.add(leftRadio);\n        hAlignPanel.add(centerRadio);\n        hAlignPanel.add(rightRadio);\n\n        return hAlignPanel;\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        // register the custom command\n        textArea.getCommandManager().registerCommand(Command.INSERT_IMAGE, new InsertImageExecutable());\n\n        // add the toolbar extension\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_IMAGE)) {\n            imageButton = new PushButton(Images.INSTANCE.image().createImage(), this);\n            imageButton.setTitle(Strings.INSTANCE.imageTooltip());\n            toolBarExtension.addFeature(\"image\", imageButton);\n            getUIExtensionList().add(toolBarExtension);\n\n            // add the menu extension\n            menuExtension = new ImageMenuExtension(this);\n            getUIExtensionList().add(menuExtension);\n\n            imageWizard = new ImageWizard(getConfig());\n            imageWizard.addWizardListener(this);\n        }\n\n        // Create an image metadata extractor for this text area\n        metaDataExtractor = new ImageMetaDataExtractor();\n        // do the initial extracting on the loaded document\n        metaDataExtractor.onInnerHTMLChange(getTextArea().getDocument().getDocumentElement());\n        getTextArea().getDocument().addInnerHTMLListener(metaDataExtractor);\n\n        // Create an image behavior adjuster for this text area\n        behaviorAdjuster = new ImageBehaviorAdjuster();\n        behaviorAdjuster.setTextArea(getTextArea());\n        getTextArea().addKeyboardListener(behaviorAdjuster);\n    }","id":42577,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        // register the custom command\n        textArea.getCommandManager().registerCommand(Command.INSERT_IMAGE, new InsertImageExecutable());\n\n        // add the toolbar extension\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_IMAGE)) {\n            imageButton = new PushButton(Images.INSTANCE.image().createImage(), this);\n            imageButton.setTitle(Strings.INSTANCE.imageTooltip());\n            toolBarExtension.addFeature(\"image\", imageButton);\n            getUIExtensionList().add(toolBarExtension);\n\n            // add the menu extension\n            menuExtension = new ImageMenuExtension(this);\n            getUIExtensionList().add(menuExtension);\n\n            imageWizard = new ImageWizard(getConfig());\n            imageWizard.addWizardListener(this);\n        }\n\n        // Create an image metadata extractor for this text area\n        metaDataExtractor = new ImageMetaDataExtractor();\n        // do the initial extracting on the loaded document\n        metaDataExtractor.onInnerHTMLChange((Element) getTextArea().getDocument().getDocumentElement());\n        getTextArea().getDocument().addInnerHTMLListener(metaDataExtractor);\n\n        // Create an image behavior adjuster for this text area\n        behaviorAdjuster = new ImageBehaviorAdjuster();\n        behaviorAdjuster.setTextArea(getTextArea());\n        getTextArea().addKeyboardListener(behaviorAdjuster);\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        // add the custom executables\n        Executable createLinkExec =\n            getTextArea().getCommandManager().registerCommand(Command.CREATE_LINK, new CreateLinkExecutable());\n        Executable unlinkExec =\n            getTextArea().getCommandManager().registerCommand(Command.UNLINK, new UnlinkExecutable());\n        if (createLinkExec != null || unlinkExec != null) {\n            originalExecutables = new HashMap<Command, Executable>();\n        }\n        if (createLinkExec != null) {\n            originalExecutables.put(Command.CREATE_LINK, createLinkExec);\n        }\n        if (unlinkExec != null) {\n            originalExecutables.put(Command.UNLINK, unlinkExec);\n        }\n\n        menuExtension = new LinkMenuExtension(this);\n        getUIExtensionList().add(menuExtension);\n\n        // Initialize the metadata extractor, to handle link metadatas\n        metaDataExtractor = new LinkMetaDataExtractor();\n        // do the initial extracting on the loaded document\n        metaDataExtractor.onInnerHTMLChange(getTextArea().getDocument().getDocumentElement());\n        getTextArea().getDocument().addInnerHTMLListener(metaDataExtractor);\n        \n        // create an empty link handler and add it to the RTA command manager\n        linkFilter = new EmptyLinkFilter(getTextArea());\n        getTextArea().getCommandManager().addCommandListener(linkFilter);\n    }","id":42578,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        // add the custom executables\n        Executable createLinkExec =\n            getTextArea().getCommandManager().registerCommand(Command.CREATE_LINK, new CreateLinkExecutable());\n        Executable unlinkExec =\n            getTextArea().getCommandManager().registerCommand(Command.UNLINK, new UnlinkExecutable());\n        if (createLinkExec != null || unlinkExec != null) {\n            originalExecutables = new HashMap<Command, Executable>();\n        }\n        if (createLinkExec != null) {\n            originalExecutables.put(Command.CREATE_LINK, createLinkExec);\n        }\n        if (unlinkExec != null) {\n            originalExecutables.put(Command.UNLINK, unlinkExec);\n        }\n\n        menuExtension = new LinkMenuExtension(this);\n        getUIExtensionList().add(menuExtension);\n\n        // Initialize the metadata extractor, to handle link metadatas\n        metaDataExtractor = new LinkMetaDataExtractor();\n        // do the initial extracting on the loaded document\n        metaDataExtractor.onInnerHTMLChange((Element) getTextArea().getDocument().getDocumentElement());\n        getTextArea().getDocument().addInnerHTMLListener(metaDataExtractor);\n        \n        // create an empty link handler and add it to the RTA command manager\n        linkFilter = new EmptyLinkFilter(getTextArea());\n        getTextArea().getCommandManager().addCommandListener(linkFilter);\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandListener#onCommand(CommandManager, Command, String)\n     */\n    public void onCommand(CommandManager sender, Command command, String param)\n    {\n        List<Command> needCleanup =\n            Arrays.asList(Command.DELETE, Command.INDENT, Command.OUTDENT, RESET_COMMAND, Command.INSERT_ORDERED_LIST,\n                Command.INSERT_UNORDERED_LIST);\n        // clean up the lists in the document on delete, indent, outdent and reset\n        if (needCleanup.contains(command)) {\n            cleanUp(getTextArea().getDocument().getDocumentElement());\n        }\n    }","id":42579,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see CommandListener#onCommand(CommandManager, Command, String)\n     */\n    public void onCommand(CommandManager sender, Command command, String param)\n    {\n        List<Command> needCleanup =\n            Arrays.asList(Command.DELETE, Command.INDENT, Command.OUTDENT, RESET_COMMAND, Command.INSERT_ORDERED_LIST,\n                Command.INSERT_UNORDERED_LIST);\n        // clean up the lists in the document on delete, indent, outdent and reset\n        if (needCleanup.contains(command)) {\n            cleanUp((Element) getTextArea().getDocument().getDocumentElement());\n        }\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see KeyboardListener#onKeyUp(Widget, char, int)\n     */\n    public void onKeyUp(Widget sender, char keyCode, int modifiers)\n    {\n        // check we're on the right element\n        if (textArea != sender) {\n            return;\n        }\n\n        // Execute cleanup after each delete, enter, backspace key\n        boolean needsCleanup =\n            (keyCode == KEY_ENTER && (modifiers != MODIFIER_SHIFT)) || keyCode == KEY_DELETE\n                || keyCode == KEY_BACKSPACE;\n        if (needsCleanup) {\n            // Clean the whole document as an operation on a list can impact more than one list (two consecutive lists\n            // can be impacted by the same delete)\n            cleanUp(textArea.getDocument().getDocumentElement());\n        } else {\n            return;\n        }\n    }","id":42580,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see KeyboardListener#onKeyUp(Widget, char, int)\n     */\n    public void onKeyUp(Widget sender, char keyCode, int modifiers)\n    {\n        // check we're on the right element\n        if (textArea != sender) {\n            return;\n        }\n\n        // Execute cleanup after each delete, enter, backspace key\n        boolean needsCleanup =\n            (keyCode == KEY_ENTER && (modifiers != MODIFIER_SHIFT)) || keyCode == KEY_DELETE\n                || keyCode == KEY_BACKSPACE;\n        if (needsCleanup) {\n            // Clean the whole document as an operation on a list can impact more than one list (two consecutive lists\n            // can be impacted by the same delete)\n            cleanUp((Element) textArea.getDocument().getDocumentElement());\n        } else {\n            return;\n        }\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests that three levels nesting of anchors are cleaned correctly.\n     * \n     * @throws Exception if something goes wrong parsing XHTML\n     */\n    public void testFilterThreeLevels() throws Exception\n    {\n        String beforeAnchor =\n            \"<html><head/><body><p><!--startwikilink:http://www.xwiki.org--><span>\"\n                + \"<a class=\\\"wikimodel-freestanding\\\" href=\\\"http://www.xwiki.com\\\">\" + \"<span>\";\n        String anchorLabel = \"http://www.xwiki.org\";\n        String afterAnchor = \"<\/span><\/a>s <\/span><!--stopwikilink-->s<\/p><\/body><\/html>\";\n        String documentString =\n            PROLOGUE_DTD + beforeAnchor + \"<a href=\\\"http://www.xwiki.orgs\\\"><a href=\\\"http://www.xwiki.com\\\">\"\n                + anchorLabel + \"<\/a>com<\/a>\" + afterAnchor;\n\n        Document doc = prepareDocument(documentString);\n        filter.filter(doc, null);\n        String actual = serializeDocument(doc);\n\n        String expected = PROLOGUE_DTD + beforeAnchor + anchorLabel + \"com\" + afterAnchor;\n        assertEquals(expected, actual);\n    }","id":42581,"modified_method":"/**\n     * Tests that three levels nesting of anchors are cleaned correctly.\n     * \n     * @throws Exception if something goes wrong parsing XHTML\n     */\n    public void testFilterThreeLevels() throws Exception\n    {\n        String beforeAnchor =\n            \"<html><head/><body><p><!--startwikilink:http://www.xwiki.org--><span>\"\n                + \"<a class=\\\"wikimodel-freestanding\\\" href=\\\"http://www.xwiki.com\\\">\" + \"<span>\";\n        String anchorLabel = \"http://www.xwiki.org\";\n        String afterAnchor = \"<\/span><\/a>s <\/span><!--stopwikilink-->s<\/p><\/body><\/html>\";\n        String documentString =\n            PROLOGUE_DTD + beforeAnchor + \"<a href=\\\"http://www.xwiki.orgs\\\"><a href=\\\"http://www.xwiki.com\\\">\"\n                + anchorLabel + \"<\/a>com<\/a>\" + afterAnchor;\n\n        Document doc = prepareDocument(documentString);\n        filter.filter(doc, null);\n        String actual = HTMLUtils.toString(doc);\n\n        String expected = PROLOGUE_DTD + beforeAnchor + anchorLabel + \"com\" + afterAnchor;\n        assertEquals(expected, actual);\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests that two nesting levels for anchors are removed.\n     * \n     * @throws Exception if something goes wrong parsing XHTML\n     */\n    public void testFilterTwoLevels() throws Exception\n    {\n        String beforeAnchor =\n            \"<html><head/><body><p><!--startwikilink:http://www.xwiki.org--><span class=\\\"wikiexternallink\\\">\"\n                + \"<a class=\\\"wikimodel-freestanding\\\" href=\\\"http://www.xwiki.org\\\">\"\n                + \"<span class=\\\"wikigeneratedlinkcontent\\\">\";\n        String anchorLabel = \"http://www.<strong>xwiki<\/strong>.org\";\n        String afterAnchor = \"<\/span><\/a>ssst<\/span><!--stopwikilink-->s<\/p><\/body><\/html>\";\n        String documentString =\n            PROLOGUE_DTD + beforeAnchor + \"<a href=\\\"http://www.xwiki.orgs\\\">\" + anchorLabel + \"<\/a>\" + afterAnchor;\n\n        Document doc = prepareDocument(documentString);\n        filter.filter(doc, null);\n        String actual = serializeDocument(doc);\n\n        String expected = PROLOGUE_DTD + beforeAnchor + anchorLabel + afterAnchor;\n\n        assertEquals(expected, actual);\n    }","id":42582,"modified_method":"/**\n     * Tests that two nesting levels for anchors are removed.\n     * \n     * @throws Exception if something goes wrong parsing XHTML\n     */\n    public void testFilterTwoLevels() throws Exception\n    {\n        String beforeAnchor =\n            \"<html><head/><body><p><!--startwikilink:http://www.xwiki.org--><span class=\\\"wikiexternallink\\\">\"\n                + \"<a class=\\\"wikimodel-freestanding\\\" href=\\\"http://www.xwiki.org\\\">\"\n                + \"<span class=\\\"wikigeneratedlinkcontent\\\">\";\n        String anchorLabel = \"http://www.<strong>xwiki<\/strong>.org\";\n        String afterAnchor = \"<\/span><\/a>ssst<\/span><!--stopwikilink-->s<\/p><\/body><\/html>\";\n        String documentString =\n            PROLOGUE_DTD + beforeAnchor + \"<a href=\\\"http://www.xwiki.orgs\\\">\" + anchorLabel + \"<\/a>\" + afterAnchor;\n\n        Document doc = prepareDocument(documentString);\n        filter.filter(doc, null);\n        String actual = HTMLUtils.toString(doc);\n\n        String expected = PROLOGUE_DTD + beforeAnchor + anchorLabel + afterAnchor;\n\n        assertEquals(expected, actual);\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Tests that the nested anchors cleaner leaves a document with anchors on just on level unchanged.\n     * \n     * @throws Exception if the XML parsing fails\n     */\n    public void testFilterOneLevel() throws Exception\n    {\n        String documentString =\n            PROLOGUE_DTD + \"<html><head /><body><p>XWiki&nbsp;<!--startwikilink:http://www.xwiki.org-->\"\n                + \"<span class=\\\"wikiexternallink\\\"><a href=\\\"http://www.xwiki.org\\\">http://www.xwiki.org<\/a><\/span>\"\n                + \"<!--stopwikilink--> .org<br /><\/p><\/body><\/html>\";\n        Document doc = prepareDocument(documentString);\n\n        String before = serializeDocument(doc);\n        filter.filter(doc, null);\n\n        String after = serializeDocument(doc);\n\n        assertEquals(before, after);\n    }","id":42583,"modified_method":"/**\n     * Tests that the nested anchors cleaner leaves a document with anchors on just on level unchanged.\n     * \n     * @throws Exception if the XML parsing fails\n     */\n    public void testFilterOneLevel() throws Exception\n    {\n        String documentString =\n            PROLOGUE_DTD + \"<html><head /><body><p>XWiki&nbsp;<!--startwikilink:http://www.xwiki.org-->\"\n                + \"<span class=\\\"wikiexternallink\\\"><a href=\\\"http://www.xwiki.org\\\">http://www.xwiki.org<\/a><\/span>\"\n                + \"<!--stopwikilink--> .org<br /><\/p><\/body><\/html>\";\n        Document doc = prepareDocument(documentString);\n\n        String before = HTMLUtils.toString(doc);\n        filter.filter(doc, null);\n\n        String after = HTMLUtils.toString(doc);\n\n        assertEquals(before, after);\n    }","commit_id":"1f53c3024aab9881b4aa89a87c5fbb8e668239e7","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Init log4j. Needs Presentation Server Properties system up and running.\n     */\n    public static void initLogger() {\n        try {\n            // Accept both xs:string and xs:anyURI types\n            String log4jConfigURL = OXFProperties.instance().getPropertySet().getStringOrURIAsString(LOG4J_DOM_CONFIG_PROPERTY);\n            if (log4jConfigURL == null)\n                log4jConfigURL = OXFProperties.instance().getPropertySet().getStringOrURIAsString(LOG4J_DOM_CONFIG_PROPERTY_OLD);\n\n            if (log4jConfigURL != null) {\n                Processor url = PipelineUtils.createURLGenerator(log4jConfigURL);\n                DOMSerializer dom = new DOMSerializer();\n                PipelineUtils.connect(url, ProcessorImpl.OUTPUT_DATA, dom, ProcessorImpl.INPUT_DATA);\n                PipelineContext ctx = new PipelineContext();\n                dom.reset(ctx);\n                dom.start(ctx);\n                DOMConfigurator.configure(dom.getW3CDocument(ctx).getDocumentElement());\n            } else {\n                logger.info(\"Property \" + LOG4J_DOM_CONFIG_PROPERTY + \" not set. Skipping logging initialization.\");\n            }\n        } catch (Throwable e) {\n            logger.error(\"Cannot load Log4J configuration. Skipping logging initialization\", e);\n        }\n    }","id":42584,"modified_method":"/**\n     * Init log4j. Needs Presentation Server Properties system up and running.\n     */\n    public static void initLogger() {\n        try {\n            // Accept both xs:string and xs:anyURI types\n            String log4jConfigURL = OXFProperties.instance().getPropertySet().getStringOrURIAsString(LOG4J_DOM_CONFIG_PROPERTY);\n            if (log4jConfigURL == null)\n                log4jConfigURL = OXFProperties.instance().getPropertySet().getStringOrURIAsString(LOG4J_DOM_CONFIG_PROPERTY_OLD);\n\n            if (log4jConfigURL != null) {\n                Processor url = PipelineUtils.createURLGenerator(log4jConfigURL);\n                DOMSerializer dom = new DOMSerializer();\n                PipelineUtils.connect(url, ProcessorImpl.OUTPUT_DATA, dom, ProcessorImpl.INPUT_DATA);\n                PipelineContext ctx = new PipelineContext();\n                dom.reset(ctx);\n                dom.start(ctx);\n                Object o = dom.getW3CDocument(ctx).getDocumentElement();\n                DOMConfigurator.configure( ( org.w3c.dom.Element )o );\n            } else {\n                logger.info(\"Property \" + LOG4J_DOM_CONFIG_PROPERTY + \" not set. Skipping logging initialization.\");\n            }\n        } catch (Throwable e) {\n            logger.error(\"Cannot load Log4J configuration. Skipping logging initialization\", e);\n        }\n    }","commit_id":"f42e34db9ee3c554c6a4efe278757dec0fb8846d","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@CheckForNull\n    private JackrabbitAccessControlList getACL(Tree tree) throws RepositoryException {\n        String nodeName = tree.getName();\n\n        if (!tree.isRoot()) {\n            Tree parent = tree.getParent();\n            if (AccessControlConstants.REP_POLICY.equals(nodeName)\n                    && ntMgr.isNodeType(tree, AccessControlConstants.NT_REP_ACL)) {\n                return getACL(parent.getPath());\n            } else if (AccessControlConstants.REP_REPO_POLICY.equals(nodeName)\n                    && ntMgr.isNodeType(tree, AccessControlConstants.NT_REP_ACL)\n                    && parent.isRoot()) {\n                return getACL((String) null);\n            }\n        }\n\n        return null;\n    }","id":42585,"modified_method":"@CheckForNull\n    private JackrabbitAccessControlList getACL(Tree tree) throws RepositoryException {\n        String nodeName = tree.getName();\n\n        JackrabbitAccessControlList acl = null;\n        if (!tree.isRoot()) {\n            Tree parent = tree.getParent();\n            if (AccessControlConstants.REP_POLICY.equals(nodeName)\n                    && ntMgr.isNodeType(tree, AccessControlConstants.NT_REP_ACL)) {\n                acl = getACL(parent.getPath());\n            } else if (AccessControlConstants.REP_REPO_POLICY.equals(nodeName)\n                    && ntMgr.isNodeType(tree, AccessControlConstants.NT_REP_ACL)\n                    && parent.isRoot()) {\n                acl = getACL((String) null);\n            }\n        }\n\n        if (acl != null) {\n            // clear all existing entries\n            for (AccessControlEntry ace: acl.getAccessControlEntries()) {\n                acl.removeAccessControlEntry(ace);\n            }\n        }\n\n        return acl;\n    }","commit_id":"034012bc11410266aa428b47cb7c15572b1578ff","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Imports a resource-based ACL containing a single entry.\n     *\n     * @throws Exception\n     */\n    public void testImportACLOnly() throws Exception {\n        try {\n            Node target = testRootNode.addNode(nodeName1);\n            target.addMixin(\"rep:AccessControllable\");\n\n            doImport(target.getPath(), XML_POLICY_TREE_3);\n\n            String path = target.getPath();\n\n            AccessControlManager acMgr = superuser.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(path);\n\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof JackrabbitAccessControlList);\n\n            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(2, entries.length);\n\n            AccessControlEntry entry = entries[0];\n            assertEquals(\"everyone\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            entry = entries[1];\n            assertEquals(\"admin\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            if(entry instanceof JackrabbitAccessControlEntry) {\n                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());\n            }\n        } finally {\n            superuser.refresh(false);\n        }\n    }","id":42586,"modified_method":"public void testImportACLOnly() throws Exception {\n        try {\n            Node target = testRootNode.addNode(nodeName1);\n            target.addMixin(\"rep:AccessControllable\");\n\n            doImport(target.getPath(), XML_POLICY_TREE_3);\n\n            String path = target.getPath();\n\n            AccessControlManager acMgr = superuser.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(path);\n\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof JackrabbitAccessControlList);\n\n            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(2, entries.length);\n\n            AccessControlEntry entry = entries[0];\n            assertEquals(\"everyone\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            entry = entries[1];\n            assertEquals(\"admin\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            if(entry instanceof JackrabbitAccessControlEntry) {\n                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());\n            }\n        } finally {\n            superuser.refresh(false);\n        }\n    }","commit_id":"034012bc11410266aa428b47cb7c15572b1578ff","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Imports a resource-based ACL containing a single entry.\n     *\n     * @throws Exception\n     */\n    @Ignore(\"OAK-414\") // FIXME\n    public void testImportACLUnknown() throws Exception {\n        try {\n            Node target = testRootNode.addNode(nodeName1);\n            target.addMixin(\"rep:AccessControllable\");\n\n            //FIXME import fails\n            doImport(target.getPath(), XML_POLICY_TREE_4);\n\n            String path = target.getPath();\n\n            AccessControlManager acMgr = superuser.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(path);\n\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof JackrabbitAccessControlList);\n\n            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(2, entries.length);\n\n            AccessControlEntry entry = entries[0];\n            assertEquals(\"unknownprincipal\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            entry = entries[1];\n            assertEquals(\"admin\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            if(entry instanceof JackrabbitAccessControlEntry) {\n                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());\n            }\n        } finally {\n            superuser.refresh(false);\n        }\n    }","id":42587,"modified_method":"public void testImportACLUnknown() throws Exception {\n        try {\n            Node target = testRootNode.addNode(nodeName1);\n            target.addMixin(\"rep:AccessControllable\");\n\n            doImport(target.getPath(), XML_POLICY_TREE_4);\n\n            String path = target.getPath();\n\n            AccessControlManager acMgr = superuser.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(path);\n\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof JackrabbitAccessControlList);\n\n            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(2, entries.length);\n\n            AccessControlEntry entry = entries[0];\n            assertEquals(\"unknownprincipal\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            entry = entries[1];\n            assertEquals(\"admin\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            if(entry instanceof JackrabbitAccessControlEntry) {\n                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());\n            }\n        } finally {\n            superuser.refresh(false);\n        }\n    }","commit_id":"034012bc11410266aa428b47cb7c15572b1578ff","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Imports a resource-based ACL containing a single entry.\n     *\n     * @throws Exception\n     */\n    @Ignore(\"OAK-414\") // FIXME\n    public void testImportACLRemoveACE() throws Exception {\n        try {\n            Node target = testRootNode.addNode(nodeName1);\n            target.addMixin(\"rep:AccessControllable\");\n\n            doImport(target.getPath(), XML_POLICY_TREE_3);\n            doImport(target.getPath(), XML_POLICY_TREE_5);\n\n            String path = target.getPath();\n\n            AccessControlManager acMgr = superuser.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(path);\n\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof JackrabbitAccessControlList);\n\n            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();\n            //FIXME assert fails\n            assertEquals(1, entries.length);\n\n            AccessControlEntry entry = entries[0];\n            assertEquals(\"admin\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            if (entry instanceof JackrabbitAccessControlEntry) {\n                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());\n            }\n        } finally {\n            superuser.refresh(false);\n        }\n    }","id":42588,"modified_method":"public void testImportACLRemoveACE() throws Exception {\n        try {\n            Node target = testRootNode.addNode(nodeName1);\n            target.addMixin(\"rep:AccessControllable\");\n\n            doImport(target.getPath(), XML_POLICY_TREE_3);\n            doImport(target.getPath(), XML_POLICY_TREE_5);\n\n            String path = target.getPath();\n\n            AccessControlManager acMgr = superuser.getAccessControlManager();\n            AccessControlPolicy[] policies = acMgr.getPolicies(path);\n\n            assertEquals(1, policies.length);\n            assertTrue(policies[0] instanceof JackrabbitAccessControlList);\n\n            AccessControlEntry[] entries = ((JackrabbitAccessControlList) policies[0]).getAccessControlEntries();\n            assertEquals(1, entries.length);\n\n            AccessControlEntry entry = entries[0];\n            assertEquals(\"admin\", entry.getPrincipal().getName());\n            assertEquals(1, entry.getPrivileges().length);\n            assertEquals(acMgr.privilegeFromName(Privilege.JCR_WRITE), entry.getPrivileges()[0]);\n\n            if (entry instanceof JackrabbitAccessControlEntry) {\n                assertTrue(((JackrabbitAccessControlEntry) entry).isAllow());\n            }\n        } finally {\n            superuser.refresh(false);\n        }\n    }","commit_id":"034012bc11410266aa428b47cb7c15572b1578ff","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public ACL getACL() {\n        return Hudson.getInstance().getAuthorizationStrategy().getACL(this);\n    }","id":42589,"modified_method":"public ACL getACL() {\n        final ACL base = Hudson.getInstance().getAuthorizationStrategy().getACL(this);\n        // always allow the user full control of himself.\n        return new ACL() {\n            public boolean hasPermission(Authentication a, Permission permission) {\n                return a.getName().equals(id) || base.hasPermission(a, permission);\n            }\n        };\n    }","commit_id":"dd29ee69c6d78c4f8ad43466110f5cb82788302d","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Gets the {@link User} object representing the currently logged-in user, or null\n     * if the current user is anonymous.\n     * @since 1.172\n     */\n    public static User current() {\n        Authentication a = Hudson.getAuthentication();\n        if(a instanceof AnonymousAuthenticationToken)\n            return null;\n        return get(a.getPrincipal().toString());\n    }","id":42590,"modified_method":"/**\n     * Gets the {@link User} object representing the currently logged-in user, or null\n     * if the current user is anonymous.\n     * @since 1.172\n     */\n    public static User current() {\n        Authentication a = Hudson.getAuthentication();\n        if(a instanceof AnonymousAuthenticationToken)\n            return null;\n        return get(a.getName());\n    }","commit_id":"dd29ee69c6d78c4f8ad43466110f5cb82788302d","url":"https://github.com/kohsuke/hudson"},{"original_method":"private Integer allocateId() {\n        return new Integer(getJdbcTemplate().queryForInt(\"SELECT nextval('alarmNxtId')\"));\n    }","id":42591,"modified_method":"private Integer allocateId() {\n        return new Integer(getJdbcTemplate().queryForInt(\"SELECT nextval('alarmsNxtId')\"));\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSave() {\n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(new Integer(7));\n        event.setEventUei(\"uei://org/opennms/test/EventDaoTest\");\n        OnmsNode node = (OnmsNode) getNodeDao().findAll().iterator().next();\n        alarm.setNode(node);\n        alarm.setUei(event.getEventUei());\n        alarm.setSeverity(event.getEventSeverity());\n        alarm.setFirstEventTime(event.getEventTime());\n        alarm.setLastEvent(event);\n        \n        getAlarmDao().save(alarm);\n        //it works we're so smart! hehe\n        OnmsAlarm newAlarm = getAlarmDao().load(alarm.getId());\n        assertEquals(\"uei://org/opennms/test/EventDaoTest\", newAlarm.getUei());\n        assertEquals(alarm.getLastEvent(), newAlarm.getLastEvent());\n    }","id":42592,"modified_method":"public void testSave() {\n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        event.setEventTime(new Date());\n        event.setEventSeverity(new Integer(7));\n        event.setEventUei(\"uei://org/opennms/test/EventDaoTest\");\n        OnmsNode node = (OnmsNode) getNodeDao().findAll().iterator().next();\n        alarm.setNode(node);\n        alarm.setUei(event.getEventUei());\n        alarm.setSeverity(event.getEventSeverity());\n        alarm.setFirstEventTime(event.getEventTime());\n        alarm.setLastEvent(event);\n        alarm.setCounter(new Integer(1));\n        \n        getAlarmDao().save(alarm);\n        //it works we're so smart! hehe\n        OnmsAlarm newAlarm = getAlarmDao().load(alarm.getId());\n        assertEquals(\"uei://org/opennms/test/EventDaoTest\", newAlarm.getUei());\n        assertEquals(alarm.getLastEvent(), newAlarm.getLastEvent());\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AlarmMappingQuery(DataSource ds, String clause) {\n        super(ds, \"SELECT \" + \n        \t\t\"a.eventUei as eventUei, \" + \n        \t\t\"a.dpName as dpName, \" + \n        \t\t\"a.nodeID as nodeID, \" + \n        \t\t\"a.ipaddr as ipaddr, \" + \n        \t\t\"a.serviceID as serviceID, \" + \n        \t\t\"a.reductionKey as reductionKey, \" + \n        \t\t\"a.alarmType as alarmType, \" + \n        \t\t\"a.counter as counter, \" + \n        \t\t\"a.severity as severity, \" + \n        \t\t\"a.lastEventID as lastEventID, \" + \n        \t\t\"a.firstEventTime as firstEventTime, \" + \n        \t\t\"a.lastEventTime as lastEventTime, \" + \n        \t\t\"a.description as description, \" + \n        \t\t\"a.logMsg as logMsg, \" + \n        \t\t\"a.operInstruct as operInstruct, \" + \n        \t\t\"a.tticketID as tticketID, \" + \n        \t\t\"a.tticketState as tticketState, \" + \n        \t\t\"a.mouseOverText as mouseOverText, \" + \n        \t\t\"a.suppressedUntil as suppressedUntil, \" + \n        \t\t\"a.suppressedUser as suppressedUser, \" + \n        \t\t\"a.suppressedTime as suppressedTime, \" + \n        \t\t\"a.alarmAckUser as alarmAckUser, \" + \n        \t\t\"a.alarmAckTime as alarmAckTime, \" + \n        \t\t\"a.clearUei as clearUei, \" +\n\t\t\t\"a.alarmID as alarmID\" +clause);\n    }","id":42593,"modified_method":"public AlarmMappingQuery(DataSource ds, String clause) {\n        super(ds, \"SELECT \" + \n        \t\t\"a.eventUei as eventUei, \" + \n        \t\t\"a.dpName as dpName, \" + \n        \t\t\"a.nodeID as nodeID, \" + \n        \t\t\"a.ipaddr as ipaddr, \" + \n        \t\t\"a.serviceID as serviceID, \" + \n        \t\t\"a.reductionKey as reductionKey, \" + \n        \t\t\"a.alarmType as alarmType, \" + \n        \t\t\"a.counter as counter, \" + \n        \t\t\"a.severity as severity, \" + \n        \t\t\"a.lastEventID as lastEventID, \" + \n        \t\t\"a.firstEventTime as firstEventTime, \" + \n        \t\t\"a.lastEventTime as lastEventTime, \" + \n        \t\t\"a.description as description, \" + \n        \t\t\"a.logMsg as logMsg, \" + \n        \t\t\"a.operInstruct as operInstruct, \" + \n        \t\t\"a.tticketID as tticketID, \" + \n        \t\t\"a.tticketState as tticketState, \" + \n        \t\t\"a.mouseOverText as mouseOverText, \" + \n        \t\t\"a.suppressedUntil as suppressedUntil, \" + \n        \t\t\"a.suppressedUser as suppressedUser, \" + \n        \t\t\"a.suppressedTime as suppressedTime, \" + \n        \t\t\"a.alarmAckUser as alarmAckUser, \" + \n        \t\t\"a.alarmAckTime as alarmAckTime, \" + \n        \t\t\"a.clearUei as clearUei, \" +\n\t\t\t\"a.alarmID as alarmID \" +clause);\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AlarmSaveOrUpdate(DataSource ds, String updateStmt) {\n        setDataSource(ds);\n        setSql(updateStmt);\n        \n        // assumes that the update and insert statements have the same parms in the same order\n        declareParameter(new SqlParameter(Types.VARCHAR));  //eventUei\n        declareParameter(new SqlParameter(Types.INTEGER));  //dpName\n        declareParameter(new SqlParameter(Types.INTEGER));  //nodeID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //ipaddr\n        declareParameter(new SqlParameter(Types.INTEGER));  //serviceID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //reductionKey\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmType\n        declareParameter(new SqlParameter(Types.INTEGER));  //counter\n        declareParameter(new SqlParameter(Types.INTEGER));  //severity\n        declareParameter(new SqlParameter(Types.INTEGER));  //lastEventID\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //firstEventTime\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //lastEventTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //description\n        declareParameter(new SqlParameter(Types.VARCHAR));  //logMsg\n        declareParameter(new SqlParameter(Types.VARCHAR));  //operInstruct\n        declareParameter(new SqlParameter(Types.VARCHAR));  //tticketID\n        declareParameter(new SqlParameter(Types.INTEGER));  //tticketState\n        declareParameter(new SqlParameter(Types.VARCHAR));  //mouseOverText\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedUntil\n        declareParameter(new SqlParameter(Types.VARCHAR));  //suppressedUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //alarmAckUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //alarmAckTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //clearUei\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmID\n        compile();\n    }","id":42594,"modified_method":"public AlarmSaveOrUpdate(DataSource ds, String updateStmt) {\n        setDataSource(ds);\n        setSql(updateStmt);\n        \n        // assumes that the update and insert statements have the same parms in the same order\n        declareParameter(new SqlParameter(Types.VARCHAR));  //eventUei\n        declareParameter(new SqlParameter(Types.VARCHAR));  //dpName\n        declareParameter(new SqlParameter(Types.INTEGER));  //nodeID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //ipaddr\n        declareParameter(new SqlParameter(Types.INTEGER));  //serviceID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //reductionKey\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmType\n        declareParameter(new SqlParameter(Types.INTEGER));  //counter\n        declareParameter(new SqlParameter(Types.INTEGER));  //severity\n        declareParameter(new SqlParameter(Types.INTEGER));  //lastEventID\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //firstEventTime\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //lastEventTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //description\n        declareParameter(new SqlParameter(Types.VARCHAR));  //logMsg\n        declareParameter(new SqlParameter(Types.VARCHAR));  //operInstruct\n        declareParameter(new SqlParameter(Types.VARCHAR));  //tticketID\n        declareParameter(new SqlParameter(Types.INTEGER));  //tticketState\n        declareParameter(new SqlParameter(Types.VARCHAR));  //mouseOverText\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedUntil\n        declareParameter(new SqlParameter(Types.VARCHAR));  //suppressedUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //alarmAckUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //alarmAckTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //clearUei\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmID\n        compile();\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int persist(OnmsAlarm alarm) {\n        Object[] parms = new Object[] {\n        \t\talarm.getUei(), //eventUei\n        \t\talarm.getDistPoller(), //dpName\n        \t\talarm.getNode(), //nodeID\n        \t\talarm.getIpAddr(), //ipaddr\n        \t\talarm.getService(), //serviceID\n        \t\talarm.getReductionKey(), //reductionKey\n        \t\talarm.getAlarmType(), //alarmType\n        \t\talarm.getCounter(), //counter\n        \t\talarm.getSeverity(), //severity\n        \t\talarm.getLastEvent(), //lastEventID\n        \t\talarm.getFirstEventTime(), //firstEventTime\n        \t\talarm.getFirstEventTime(), //lastEventTime\n        \t\talarm.getDescription(), //description\n        \t\talarm.getLogMsg(), //logMsg\n        \t\talarm.getOperInstruct(), //operInstruct\n        \t\talarm.getTTicketId(), //tticketID\n        \t\talarm.getTTicketId(), //tticketState\n        \t\talarm.getMouseOverText(), //mouseOverText\n        \t\talarm.getSuppressedUntil(), //suppressedUntil\n        \t\talarm.getSuppressedUser(), //suppressedUser\n        \t\talarm.getSuppressedTime(), //suppressedTime\n        \t\talarm.getAlarmAckUser(), //alarmAckUser\n        \t\talarm.getAlarmAckTime(), //alarmAckTime\n        \t\talarm.getClearUei(), //clearUei        \n        \t\talarm.getId()}; //alarmID\n        return update(parms);\n    }","id":42595,"modified_method":"public int persist(OnmsAlarm alarm) {\n        Object[] parms = new Object[] {\n        \t\talarm.getUei(), //eventUei\n        \t\t(alarm.getDistPoller() == null ? null : alarm.getDistPoller().getName()), //dpName\n        \t\t(alarm.getNode() == null ? null : alarm.getNode().getId()), //nodeID\n        \t\talarm.getIpAddr(), //ipaddr\n        \t\t(alarm.getService() == null ? null : alarm.getService().getServiceType().getId()), //serviceID\n        \t\talarm.getReductionKey(), //reductionKey\n        \t\talarm.getAlarmType(), //alarmType\n        \t\talarm.getCounter(), //counter\n        \t\talarm.getSeverity(), //severity\n        \t\talarm.getLastEvent().getId(), //lastEventID\n        \t\talarm.getFirstEventTime(), //firstEventTime\n        \t\talarm.getFirstEventTime(), //lastEventTime\n        \t\talarm.getDescription(), //description\n        \t\talarm.getLogMsg(), //logMsg\n        \t\talarm.getOperInstruct(), //operInstruct\n        \t\talarm.getTTicketId(), //tticketID\n        \t\talarm.getTTicketId(), //tticketState\n        \t\talarm.getMouseOverText(), //mouseOverText\n        \t\talarm.getSuppressedUntil(), //suppressedUntil\n        \t\talarm.getSuppressedUser(), //suppressedUser\n        \t\talarm.getSuppressedTime(), //suppressedTime\n        \t\talarm.getAlarmAckUser(), //alarmAckUser\n        \t\talarm.getAlarmAckTime(), //alarmAckTime\n        \t\talarm.getClearUei(), //clearUei        \n        \t\talarm.getId()}; //alarmID\n        return update(parms);\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateAndGets() {\n        OnmsNode onmsNode = new OnmsNode(getDistPollerDao().load(\"localhost\"));\n        onmsNode.setLabel(\"myNode\");\n        getNodeDao().save(onmsNode);\n        OnmsAssetRecord assetRecord = onmsNode.getAssetRecord();\n        assetRecord.setAssetNumber(\"imported-id: 7\");\n        getAssetRecordDao().update(assetRecord);\n        getAssetRecordDao().flush();\n\n        //Test findAll method\n        Collection assetRecords = getAssetRecordDao().findAll();\n        assertEquals(7, assetRecords.size());\n        \n        //Test countAll method\n        assertEquals(7, getAssetRecordDao().countAll());\n\n        //test build map of nodeids to assetNumbers from AssetRecord objects\n        Map arMap = getAssetRecordDao().findImportedAssetNumbersToNodeIds(\"imported:\");\n        Integer id = assetRecord.getNode().getId();\n        //assertEquals(\"imported-id: 7\", arMap.get(id));\n        assertEquals(arMap.get(\"imported-id: 7\"), id);\n    }","id":42596,"modified_method":"public void testCreateAndGets() {\n        OnmsNode onmsNode = new OnmsNode(getDistPollerDao().load(\"localhost\"));\n        onmsNode.setLabel(\"myNode\");\n        getNodeDao().save(onmsNode);\n        OnmsAssetRecord assetRecord = onmsNode.getAssetRecord();\n        assetRecord.setAssetNumber(\"imported-id: 7\");\n        getAssetRecordDao().update(assetRecord);\n        getAssetRecordDao().flush();\n\n        //Test findAll method\n        Collection assetRecords = getAssetRecordDao().findAll();\n        assertEquals(7, assetRecords.size());\n        \n        //Test countAll method\n        assertEquals(7, getAssetRecordDao().countAll());\n\n        //test build map of nodeids to assetNumbers from AssetRecord objects\n        Map arMap = getAssetRecordDao().findImportedAssetNumbersToNodeIds(\"imported-id:\");\n        Integer id = assetRecord.getNode().getId();\n        assertEquals(arMap.get(\"imported-id: 7\"), id);\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected PlatformTransactionManager setUp(DB db, boolean createDb) throws Exception {\n        m_createDb = createDb;\n        \n        if (createDb) {\n        \tSystem.err.println(\"user.dir = \"+System.getProperty(\"user.dir\"));\n            String cmd = System.getProperty(\"psql.command\", \"psql\") ;\n            System.err.println(\"psql.command = \"+cmd);\n            Process p = Runtime.getRuntime().exec(cmd+\" test -U opennms -f etc/create.sql\");\n            p.waitFor();\n            System.err.println(\"Got an exitValue of \"+p.exitValue());\n        }\n        \n        //m_dataSource = db.getDataSource();\n        m_dataSource = db.getPoolingDataSource();\n        \n        // initialize the factory classs and register them with the Cache\n        AssetRecordFactory.register(m_dataSource);\n        DistPollerFactory.register(m_dataSource);\n        IpInterfaceFactory.register(m_dataSource);\n        MonitoredServiceFactory.register(m_dataSource);\n        NodeFactory.register(m_dataSource);\n        CategoryFactory.register(m_dataSource);\n        ServiceTypeFactory.register(m_dataSource);\n        SnmpInterfaceFactory.register(m_dataSource);\n        OutageFactory.register(m_dataSource);\n        EventFactory.register(m_dataSource);\n        AgentFactory.register(m_dataSource);\n        AlarmFactory.register(m_dataSource);\n        \n        return new DataSourceTransactionManager(m_dataSource);\n    }","id":42597,"modified_method":"protected PlatformTransactionManager setUp(DB db, boolean createDb) throws Exception {\n        m_createDb = createDb;\n        \n        if (createDb) {\n        \tSystem.err.println(\"user.dir = \"+System.getProperty(\"user.dir\"));\n            String cmd = System.getProperty(\"psql.command\", \"psql\") ;\n            System.err.println(\"psql.command = \"+cmd);\n            String createSqlDir = System.getProperty(\"create.sql.dir\", \"etc\");\n            System.err.println(\"create.sql.dir = \"+createSqlDir);\n            File createSql = new File(createSqlDir, \"create.sql\");\n            Process p = Runtime.getRuntime().exec(cmd+\" test -U opennms -f \"+createSql.getAbsolutePath());\n            p.waitFor();\n            System.err.println(\"Got an exitValue of \"+p.exitValue());\n        }\n                \n        //m_dataSource = db.getDataSource();\n        m_dataSource = db.getPoolingDataSource();\n        \n        // initialize the factory classs and register them with the Cache\n        AssetRecordFactory.register(m_dataSource);\n        DistPollerFactory.register(m_dataSource);\n        IpInterfaceFactory.register(m_dataSource);\n        MonitoredServiceFactory.register(m_dataSource);\n        NodeFactory.register(m_dataSource);\n        CategoryFactory.register(m_dataSource);\n        ServiceTypeFactory.register(m_dataSource);\n        SnmpInterfaceFactory.register(m_dataSource);\n        OutageFactory.register(m_dataSource);\n        EventFactory.register(m_dataSource);\n        AgentFactory.register(m_dataSource);\n        AlarmFactory.register(m_dataSource);\n        \n        return new DataSourceTransactionManager(m_dataSource);\n    }","commit_id":"bf0f4e4be3a381bb06f5e87e9095dbff5664ee04","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Integer allocateId() {\n        return new Integer(getJdbcTemplate().queryForInt(\"SELECT nextval('alarmNxtId')\"));\n    }","id":42598,"modified_method":"private Integer allocateId() {\n        return new Integer(getJdbcTemplate().queryForInt(\"SELECT nextval('alarmsNxtId')\"));\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testSave() {\n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        event.setEventCreateTime(new Date());\n        event.setEventSeverity(new Integer(7));\n        event.setEventUei(\"uei://org/opennms/test/EventDaoTest\");\n        OnmsNode node = (OnmsNode) getNodeDao().findAll().iterator().next();\n        alarm.setNode(node);\n        alarm.setUei(event.getEventUei());\n        alarm.setSeverity(event.getEventSeverity());\n        alarm.setFirstEventTime(event.getEventTime());\n        alarm.setLastEvent(event);\n        \n        getAlarmDao().save(alarm);\n        //it works we're so smart! hehe\n        OnmsAlarm newAlarm = getAlarmDao().load(alarm.getId());\n        assertEquals(\"uei://org/opennms/test/EventDaoTest\", newAlarm.getUei());\n        assertEquals(alarm.getLastEvent(), newAlarm.getLastEvent());\n    }","id":42599,"modified_method":"public void testSave() {\n        OnmsAlarm alarm = new OnmsAlarm();\n        alarm.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        OnmsEvent event = new OnmsEvent();\n        event.setDistPoller(getDistPollerDao().load(\"localhost\"));\n        event.setEventTime(new Date());\n        event.setEventSeverity(new Integer(7));\n        event.setEventUei(\"uei://org/opennms/test/EventDaoTest\");\n        OnmsNode node = (OnmsNode) getNodeDao().findAll().iterator().next();\n        alarm.setNode(node);\n        alarm.setUei(event.getEventUei());\n        alarm.setSeverity(event.getEventSeverity());\n        alarm.setFirstEventTime(event.getEventTime());\n        alarm.setLastEvent(event);\n        alarm.setCounter(new Integer(1));\n        \n        getAlarmDao().save(alarm);\n        //it works we're so smart! hehe\n        OnmsAlarm newAlarm = getAlarmDao().load(alarm.getId());\n        assertEquals(\"uei://org/opennms/test/EventDaoTest\", newAlarm.getUei());\n        assertEquals(alarm.getLastEvent(), newAlarm.getLastEvent());\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AlarmMappingQuery(DataSource ds, String clause) {\n        super(ds, \"SELECT \" + \n        \t\t\"a.eventUei as eventUei, \" + \n        \t\t\"a.dpName as dpName, \" + \n        \t\t\"a.nodeID as nodeID, \" + \n        \t\t\"a.ipaddr as ipaddr, \" + \n        \t\t\"a.serviceID as serviceID, \" + \n        \t\t\"a.reductionKey as reductionKey, \" + \n        \t\t\"a.alarmType as alarmType, \" + \n        \t\t\"a.counter as counter, \" + \n        \t\t\"a.severity as severity, \" + \n        \t\t\"a.lastEventID as lastEventID, \" + \n        \t\t\"a.firstEventTime as firstEventTime, \" + \n        \t\t\"a.lastEventTime as lastEventTime, \" + \n        \t\t\"a.description as description, \" + \n        \t\t\"a.logMsg as logMsg, \" + \n        \t\t\"a.operInstruct as operInstruct, \" + \n        \t\t\"a.tticketID as tticketID, \" + \n        \t\t\"a.tticketState as tticketState, \" + \n        \t\t\"a.mouseOverText as mouseOverText, \" + \n        \t\t\"a.suppressedUntil as suppressedUntil, \" + \n        \t\t\"a.suppressedUser as suppressedUser, \" + \n        \t\t\"a.suppressedTime as suppressedTime, \" + \n        \t\t\"a.alarmAckUser as alarmAckUser, \" + \n        \t\t\"a.alarmAckTime as alarmAckTime, \" + \n        \t\t\"a.clearUei as clearUei, \" +\n\t\t\t\"a.alarmID as alarmID\" +clause);\n    }","id":42600,"modified_method":"public AlarmMappingQuery(DataSource ds, String clause) {\n        super(ds, \"SELECT \" + \n        \t\t\"a.eventUei as eventUei, \" + \n        \t\t\"a.dpName as dpName, \" + \n        \t\t\"a.nodeID as nodeID, \" + \n        \t\t\"a.ipaddr as ipaddr, \" + \n        \t\t\"a.serviceID as serviceID, \" + \n        \t\t\"a.reductionKey as reductionKey, \" + \n        \t\t\"a.alarmType as alarmType, \" + \n        \t\t\"a.counter as counter, \" + \n        \t\t\"a.severity as severity, \" + \n        \t\t\"a.lastEventID as lastEventID, \" + \n        \t\t\"a.firstEventTime as firstEventTime, \" + \n        \t\t\"a.lastEventTime as lastEventTime, \" + \n        \t\t\"a.description as description, \" + \n        \t\t\"a.logMsg as logMsg, \" + \n        \t\t\"a.operInstruct as operInstruct, \" + \n        \t\t\"a.tticketID as tticketID, \" + \n        \t\t\"a.tticketState as tticketState, \" + \n        \t\t\"a.mouseOverText as mouseOverText, \" + \n        \t\t\"a.suppressedUntil as suppressedUntil, \" + \n        \t\t\"a.suppressedUser as suppressedUser, \" + \n        \t\t\"a.suppressedTime as suppressedTime, \" + \n        \t\t\"a.alarmAckUser as alarmAckUser, \" + \n        \t\t\"a.alarmAckTime as alarmAckTime, \" + \n        \t\t\"a.clearUei as clearUei, \" +\n\t\t\t\"a.alarmID as alarmID \" +clause);\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public int persist(OnmsAlarm alarm) {\n        Object[] parms = new Object[] {\n        \t\talarm.getUei(), //eventUei\n        \t\talarm.getDistPoller(), //dpName\n        \t\talarm.getNode(), //nodeID\n        \t\talarm.getIpAddr(), //ipaddr\n        \t\talarm.getService(), //serviceID\n        \t\talarm.getReductionKey(), //reductionKey\n        \t\talarm.getAlarmType(), //alarmType\n        \t\talarm.getCounter(), //counter\n        \t\talarm.getSeverity(), //severity\n        \t\talarm.getLastEvent(), //lastEventID\n        \t\talarm.getFirstEventTime(), //firstEventTime\n        \t\talarm.getFirstEventTime(), //lastEventTime\n        \t\talarm.getDescription(), //description\n        \t\talarm.getLogMsg(), //logMsg\n        \t\talarm.getOperInstruct(), //operInstruct\n        \t\talarm.getTTicketId(), //tticketID\n        \t\talarm.getTTicketId(), //tticketState\n        \t\talarm.getMouseOverText(), //mouseOverText\n        \t\talarm.getSuppressedUntil(), //suppressedUntil\n        \t\talarm.getSuppressedUser(), //suppressedUser\n        \t\talarm.getSuppressedTime(), //suppressedTime\n        \t\talarm.getAlarmAckUser(), //alarmAckUser\n        \t\talarm.getAlarmAckTime(), //alarmAckTime\n        \t\talarm.getClearUei(), //clearUei        \n        \t\talarm.getId()}; //alarmID\n        return update(parms);\n    }","id":42601,"modified_method":"public int persist(OnmsAlarm alarm) {\n        Object[] parms = new Object[] {\n        \t\talarm.getUei(), //eventUei\n        \t\t(alarm.getDistPoller() == null ? null : alarm.getDistPoller().getName()), //dpName\n        \t\t(alarm.getNode() == null ? null : alarm.getNode().getId()), //nodeID\n        \t\talarm.getIpAddr(), //ipaddr\n        \t\t(alarm.getService() == null ? null : alarm.getService().getServiceType().getId()), //serviceID\n        \t\talarm.getReductionKey(), //reductionKey\n        \t\talarm.getAlarmType(), //alarmType\n        \t\talarm.getCounter(), //counter\n        \t\talarm.getSeverity(), //severity\n        \t\talarm.getLastEvent().getId(), //lastEventID\n        \t\talarm.getFirstEventTime(), //firstEventTime\n        \t\talarm.getFirstEventTime(), //lastEventTime\n        \t\talarm.getDescription(), //description\n        \t\talarm.getLogMsg(), //logMsg\n        \t\talarm.getOperInstruct(), //operInstruct\n        \t\talarm.getTTicketId(), //tticketID\n        \t\talarm.getTTicketId(), //tticketState\n        \t\talarm.getMouseOverText(), //mouseOverText\n        \t\talarm.getSuppressedUntil(), //suppressedUntil\n        \t\talarm.getSuppressedUser(), //suppressedUser\n        \t\talarm.getSuppressedTime(), //suppressedTime\n        \t\talarm.getAlarmAckUser(), //alarmAckUser\n        \t\talarm.getAlarmAckTime(), //alarmAckTime\n        \t\talarm.getClearUei(), //clearUei        \n        \t\talarm.getId()}; //alarmID\n        return update(parms);\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public AlarmSaveOrUpdate(DataSource ds, String updateStmt) {\n        setDataSource(ds);\n        setSql(updateStmt);\n        \n        // assumes that the update and insert statements have the same parms in the same order\n        declareParameter(new SqlParameter(Types.VARCHAR));  //eventUei\n        declareParameter(new SqlParameter(Types.INTEGER));  //dpName\n        declareParameter(new SqlParameter(Types.INTEGER));  //nodeID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //ipaddr\n        declareParameter(new SqlParameter(Types.INTEGER));  //serviceID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //reductionKey\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmType\n        declareParameter(new SqlParameter(Types.INTEGER));  //counter\n        declareParameter(new SqlParameter(Types.INTEGER));  //severity\n        declareParameter(new SqlParameter(Types.INTEGER));  //lastEventID\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //firstEventTime\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //lastEventTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //description\n        declareParameter(new SqlParameter(Types.VARCHAR));  //logMsg\n        declareParameter(new SqlParameter(Types.VARCHAR));  //operInstruct\n        declareParameter(new SqlParameter(Types.VARCHAR));  //tticketID\n        declareParameter(new SqlParameter(Types.INTEGER));  //tticketState\n        declareParameter(new SqlParameter(Types.VARCHAR));  //mouseOverText\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedUntil\n        declareParameter(new SqlParameter(Types.VARCHAR));  //suppressedUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //alarmAckUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //alarmAckTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //clearUei\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmID\n        compile();\n    }","id":42602,"modified_method":"public AlarmSaveOrUpdate(DataSource ds, String updateStmt) {\n        setDataSource(ds);\n        setSql(updateStmt);\n        \n        // assumes that the update and insert statements have the same parms in the same order\n        declareParameter(new SqlParameter(Types.VARCHAR));  //eventUei\n        declareParameter(new SqlParameter(Types.VARCHAR));  //dpName\n        declareParameter(new SqlParameter(Types.INTEGER));  //nodeID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //ipaddr\n        declareParameter(new SqlParameter(Types.INTEGER));  //serviceID\n        declareParameter(new SqlParameter(Types.VARCHAR));  //reductionKey\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmType\n        declareParameter(new SqlParameter(Types.INTEGER));  //counter\n        declareParameter(new SqlParameter(Types.INTEGER));  //severity\n        declareParameter(new SqlParameter(Types.INTEGER));  //lastEventID\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //firstEventTime\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //lastEventTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //description\n        declareParameter(new SqlParameter(Types.VARCHAR));  //logMsg\n        declareParameter(new SqlParameter(Types.VARCHAR));  //operInstruct\n        declareParameter(new SqlParameter(Types.VARCHAR));  //tticketID\n        declareParameter(new SqlParameter(Types.INTEGER));  //tticketState\n        declareParameter(new SqlParameter(Types.VARCHAR));  //mouseOverText\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedUntil\n        declareParameter(new SqlParameter(Types.VARCHAR));  //suppressedUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //suppressedTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //alarmAckUser\n        declareParameter(new SqlParameter(Types.TIMESTAMP));  //alarmAckTime\n        declareParameter(new SqlParameter(Types.VARCHAR));  //clearUei\n        declareParameter(new SqlParameter(Types.INTEGER));  //alarmID\n        compile();\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateAndGets() {\n        OnmsNode onmsNode = new OnmsNode(getDistPollerDao().load(\"localhost\"));\n        onmsNode.setLabel(\"myNode\");\n        getNodeDao().save(onmsNode);\n        OnmsAssetRecord assetRecord = onmsNode.getAssetRecord();\n        assetRecord.setAssetNumber(\"imported-id: 7\");\n        getAssetRecordDao().update(assetRecord);\n        getAssetRecordDao().flush();\n\n        //Test findAll method\n        Collection assetRecords = getAssetRecordDao().findAll();\n        assertEquals(7, assetRecords.size());\n        \n        //Test countAll method\n        assertEquals(7, getAssetRecordDao().countAll());\n\n        //test build map of nodeids to assetNumbers from AssetRecord objects\n        Map arMap = getAssetRecordDao().findImportedAssetNumbersToNodeIds(\"imported:\");\n        Integer id = assetRecord.getNode().getId();\n        //assertEquals(\"imported-id: 7\", arMap.get(id));\n        assertEquals(arMap.get(\"imported-id: 7\"), id);\n    }","id":42603,"modified_method":"public void testCreateAndGets() {\n        OnmsNode onmsNode = new OnmsNode(getDistPollerDao().load(\"localhost\"));\n        onmsNode.setLabel(\"myNode\");\n        getNodeDao().save(onmsNode);\n        OnmsAssetRecord assetRecord = onmsNode.getAssetRecord();\n        assetRecord.setAssetNumber(\"imported-id: 7\");\n        getAssetRecordDao().update(assetRecord);\n        getAssetRecordDao().flush();\n\n        //Test findAll method\n        Collection assetRecords = getAssetRecordDao().findAll();\n        assertEquals(7, assetRecords.size());\n        \n        //Test countAll method\n        assertEquals(7, getAssetRecordDao().countAll());\n\n        //test build map of nodeids to assetNumbers from AssetRecord objects\n        Map arMap = getAssetRecordDao().findImportedAssetNumbersToNodeIds(\"imported-id:\");\n        Integer id = assetRecord.getNode().getId();\n        assertEquals(arMap.get(\"imported-id: 7\"), id);\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected PlatformTransactionManager setUp(DB db, boolean createDb) throws Exception {\n        m_createDb = createDb;\n        \n        if (createDb) {\n        \tSystem.err.println(\"user.dir = \"+System.getProperty(\"user.dir\"));\n            String cmd = System.getProperty(\"psql.command\", \"psql\") ;\n            System.err.println(\"psql.command = \"+cmd);\n            Process p = Runtime.getRuntime().exec(cmd+\" test -U opennms -f etc/create.sql\");\n            p.waitFor();\n            System.err.println(\"Got an exitValue of \"+p.exitValue());\n        }\n        \n        //m_dataSource = db.getDataSource();\n        m_dataSource = db.getPoolingDataSource();\n        \n        // initialize the factory classs and register them with the Cache\n        AssetRecordFactory.register(m_dataSource);\n        DistPollerFactory.register(m_dataSource);\n        IpInterfaceFactory.register(m_dataSource);\n        MonitoredServiceFactory.register(m_dataSource);\n        NodeFactory.register(m_dataSource);\n        CategoryFactory.register(m_dataSource);\n        ServiceTypeFactory.register(m_dataSource);\n        SnmpInterfaceFactory.register(m_dataSource);\n        OutageFactory.register(m_dataSource);\n        EventFactory.register(m_dataSource);\n        AgentFactory.register(m_dataSource);\n        AlarmFactory.register(m_dataSource);\n        \n        return new DataSourceTransactionManager(m_dataSource);\n    }","id":42604,"modified_method":"protected PlatformTransactionManager setUp(DB db, boolean createDb) throws Exception {\n        m_createDb = createDb;\n        \n        if (createDb) {\n        \tSystem.err.println(\"user.dir = \"+System.getProperty(\"user.dir\"));\n            String cmd = System.getProperty(\"psql.command\", \"psql\") ;\n            System.err.println(\"psql.command = \"+cmd);\n            String createSqlDir = System.getProperty(\"create.sql.dir\", \"etc\");\n            System.err.println(\"create.sql.dir = \"+createSqlDir);\n            File createSql = new File(createSqlDir, \"create.sql\");\n            Process p = Runtime.getRuntime().exec(cmd+\" test -U opennms -f \"+createSql.getAbsolutePath());\n            p.waitFor();\n            System.err.println(\"Got an exitValue of \"+p.exitValue());\n        }\n                \n        //m_dataSource = db.getDataSource();\n        m_dataSource = db.getPoolingDataSource();\n        \n        // initialize the factory classs and register them with the Cache\n        AssetRecordFactory.register(m_dataSource);\n        DistPollerFactory.register(m_dataSource);\n        IpInterfaceFactory.register(m_dataSource);\n        MonitoredServiceFactory.register(m_dataSource);\n        NodeFactory.register(m_dataSource);\n        CategoryFactory.register(m_dataSource);\n        ServiceTypeFactory.register(m_dataSource);\n        SnmpInterfaceFactory.register(m_dataSource);\n        OutageFactory.register(m_dataSource);\n        EventFactory.register(m_dataSource);\n        AgentFactory.register(m_dataSource);\n        AlarmFactory.register(m_dataSource);\n        \n        return new DataSourceTransactionManager(m_dataSource);\n    }","commit_id":"513f6b571dd78ce7e77fadf680df6c95934be367","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param e\n     */\n    @Override\n    public void writeEvent(Event e) {\n        Integer eventId = getNextEventId();\n        \n        if (e.getCreationTime() == null) \n            e.setCreationTime(e.getTime());\n        \n        Object[] values = {\n                eventId,\n                e.getSource(),\n                e.getDistPoller(),\n                e.getUei(),\n                new Timestamp(e.getCreationTime().getTime()),\n                new Timestamp(e.getTime().getTime()),\n                Integer.valueOf(OnmsSeverity.get(e.getSeverity()).getId()),\n                (e.hasNodeid() ? new Long(e.getNodeid()) : null),\n                e.getInterface(),\n                getServiceID(e.getService()),\n                \"localhost\",\n                \"Y\",\n                \"Y\",\n                e.getTticket() == null ? \"\" : e.getTticket().getContent(),\n                Integer.valueOf(e.getTticket() == null ? \"0\" : e.getTticket().getState()),\n                EventParameterUtils.format(e),\n                e.getLogmsg() == null? null : e.getLogmsg().getContent()\n        };\n        e.setDbid(eventId.intValue());\n        update(\"insert into events (\" +\n                \"eventId, eventSource, systemId, eventUei, eventCreateTime, eventTime, eventSeverity, \" +\n                \"nodeId, ipAddr, serviceId, systemId, \" +\n                \"eventLog, eventDisplay, eventtticket, eventtticketstate, eventparms, eventlogmsg) \" +\n                \"values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\", values);\n    }","id":42605,"modified_method":"/**\n     * @param e\n     */\n    @Override\n    public void writeEvent(Event e) {\n        Integer eventId = getNextEventId();\n        \n        if (e.getCreationTime() == null) \n            e.setCreationTime(e.getTime());\n        \n        Object[] values = {\n                eventId,\n                e.getSource(),\n                e.getUei(),\n                new Timestamp(e.getCreationTime().getTime()),\n                new Timestamp(e.getTime().getTime()),\n                Integer.valueOf(OnmsSeverity.get(e.getSeverity()).getId()),\n                (e.hasNodeid() ? new Long(e.getNodeid()) : null),\n                e.getInterface(),\n                getServiceID(e.getService()),\n                e.getDistPoller() == null ? \"00000000-0000-0000-0000-000000000000\" : e.getDistPoller(),\n                \"Y\",\n                \"Y\",\n                e.getTticket() == null ? \"\" : e.getTticket().getContent(),\n                Integer.valueOf(e.getTticket() == null ? \"0\" : e.getTticket().getState()),\n                EventParameterUtils.format(e),\n                e.getLogmsg() == null? null : e.getLogmsg().getContent()\n        };\n        e.setDbid(eventId.intValue());\n        update(\"insert into events (\" +\n                \"eventId, eventSource, eventUei, eventCreateTime, eventTime, eventSeverity, \" +\n                \"nodeId, ipAddr, serviceId, systemId, \" +\n                \"eventLog, eventDisplay, eventtticket, eventtticketstate, eventparms, eventlogmsg) \" +\n                \"values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\", values);\n    }","commit_id":"c76c6b4f8e92548a15643e952a318b8b7d784266","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic void apply(Project project) {\n\t\tGradleUtil.applyPlugin(project, LiferayOSGiDefaultsPlugin.class);\n\t\tGradleUtil.applyPlugin(project, LiferayThemeDefaultsPlugin.class);\n\t}","id":42606,"modified_method":"@Override\n\tpublic void apply(Project project) {\n\t\tsuper.apply(project);\n\n\t\tGradleUtil.applyPlugin(project, LiferayRelengPlugin.class);\n\t}","commit_id":"bdb4361f776f65c600bb0043459c527b5e9a2a15","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void apply(Project project) {\n\t\tClass<? extends Plugin<Project>> clazz;\n\n\t\tif (isOSGiPlugin(project)) {\n\t\t\tclazz = LiferayOSGiPlugin.class;\n\t\t}\n\t\telse if (isThemePlugin(project)) {\n\t\t\tclazz = LiferayThemePlugin.class;\n\t\t}\n\t\telse {\n\t\t\tclazz = LiferayBasePlugin.class;\n\t\t}\n\n\t\tGradleUtil.applyPlugin(project, clazz);\n\t}","id":42607,"modified_method":"@Override\n\tpublic void apply(Project project) {\n\t\tClass<? extends Plugin<Project>> clazz;\n\n\t\tif (isOSGiPlugin(project)) {\n\t\t\tclazz = getOSGiPluginClass();\n\t\t}\n\t\telse if (isThemePlugin(project)) {\n\t\t\tclazz = getThemePluginClass();\n\t\t}\n\t\telse {\n\t\t\tclazz = getBasePluginClass();\n\t\t}\n\n\t\tGradleUtil.applyPlugin(project, clazz);\n\t}","commit_id":"bdb4361f776f65c600bb0043459c527b5e9a2a15","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected File getWarFile(Project project) {\n\t\treturn project.file(\"dist/\" + project.getName() + \".war\");\n\t}","id":42608,"modified_method":"protected File getWarFile(Project project) {\n\t\tBasePluginConvention basePluginConvention = GradleUtil.getConvention(\n\t\t\tproject, BasePluginConvention.class);\n\n\t\treturn project.file(\n\t\t\t\"dist/\" + basePluginConvention.getArchivesBaseName() + \".war\");\n\t}","commit_id":"0345b4daab819d7044f3e9ed931acd1f83bf23e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Task addTaskCreateLiferayThemeJson(\n\t\tProject project, final WorkspaceExtension workspaceExtension) {\n\n\t\tTask task = project.task(CREATE_LIFERAY_THEME_JSON_TASK_NAME);\n\n\t\tfinal File liferayThemeJsonFile = project.file(\"liferay-theme.json\");\n\n\t\ttask.doLast(\n\t\t\tnew Action<Task>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void execute(Task task) {\n\t\t\t\t\tProject project = task.getProject();\n\n\t\t\t\t\tMap<String, Object> map = new HashMap<>();\n\n\t\t\t\t\tFile appServerDir = new File(\n\t\t\t\t\t\tworkspaceExtension.getHomeDir(), \"tomcat-8.0.32\");\n\n\t\t\t\t\tmap.put(\"appServerPath\", appServerDir.getAbsolutePath());\n\n\t\t\t\t\tFile appServerThemeDir = new File(\n\t\t\t\t\t\tappServerDir, \"webapps/\" + project.getName());\n\n\t\t\t\t\tmap.put(\n\t\t\t\t\t\t\"appServerPathTheme\",\n\t\t\t\t\t\tappServerThemeDir.getAbsolutePath());\n\n\t\t\t\t\tmap.put(\"deployed\", false);\n\n\t\t\t\t\tFile deployDir = new File(\n\t\t\t\t\t\tworkspaceExtension.getHomeDir(), \"osgi/modules\");\n\n\t\t\t\t\tmap.put(\"deployPath\", deployDir.getAbsolutePath());\n\t\t\t\t\tmap.put(\"themeName\", project.getName());\n\n\t\t\t\t\tString json = JsonOutput.toJson(\n\t\t\t\t\t\tCollections.singletonMap(\"LiferayTheme\", map));\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFiles.write(\n\t\t\t\t\t\t\tliferayThemeJsonFile.toPath(),\n\t\t\t\t\t\t\tjson.getBytes(StandardCharsets.UTF_8));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tthrow new GradleException(ioe.getMessage(), ioe);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});\n\n\t\ttask.setDescription(\n\t\t\t\"Generates the \" + liferayThemeJsonFile.getName() +\n\t\t\t\t\" file for this project.\");\n\n\t\treturn task;\n\t}","id":42609,"modified_method":"protected void configureLiferay(\n\t\tProject project, WorkspaceExtension workspaceExtension) {\n\n\t\tLiferayExtension liferayExtension = GradleUtil.getExtension(\n\t\t\tproject, LiferayExtension.class);\n\n\t\tliferayExtension.setAppServerParentDir(workspaceExtension.getHomeDir());\n\t}","commit_id":"0345b4daab819d7044f3e9ed931acd1f83bf23e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void configureRootTaskDistBundle(\n\t\tfinal Project project, String rootTaskName) {\n\n\t\tCopySpec copySpec = (CopySpec)GradleUtil.getTask(\n\t\t\tproject.getRootProject(), rootTaskName);\n\n\t\tcopySpec.into(\n\t\t\t\"osgi/modules\",\n\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\tConfigurableFileCollection configurableFileCollection =\n\t\t\t\t\t\tproject.files(getWarFile(project));\n\n\t\t\t\t\tconfigurableFileCollection.builtBy(_GULP_BUILD_TASK_NAME);\n\n\t\t\t\t\tcopySpec.from(configurableFileCollection);\n\t\t\t\t}\n\n\t\t\t});\n\t}","id":42610,"modified_method":"protected void configureRootTaskDistBundle(\n\t\tfinal Project project, String rootTaskName) {\n\n\t\tCopySpec copySpec = (CopySpec)GradleUtil.getTask(\n\t\t\tproject.getRootProject(), rootTaskName);\n\n\t\tcopySpec.into(\n\t\t\t\"osgi/modules\",\n\t\t\tnew Closure<Void>(null) {\n\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tpublic void doCall(CopySpec copySpec) {\n\t\t\t\t\tConfigurableFileCollection configurableFileCollection =\n\t\t\t\t\t\tproject.files(getWarFile(project));\n\n\t\t\t\t\tconfigurableFileCollection.builtBy(\n\t\t\t\t\t\tBasePlugin.ASSEMBLE_TASK_NAME);\n\n\t\t\t\t\tcopySpec.from(getWarFile(project));\n\t\t\t\t}\n\n\t\t\t});\n\t}","commit_id":"0345b4daab819d7044f3e9ed931acd1f83bf23e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void apply(Project project) {\n\t\tWorkspaceExtension workspaceExtension = GradleUtil.getExtension(\n\t\t\t(ExtensionAware)project.getGradle(), WorkspaceExtension.class);\n\n\t\t// liferay-theme-tasks already uses the \"build\" directory\n\n\t\tproject.setBuildDir(\"build_gradle\");\n\n\t\tGradleUtil.applyPlugin(project, BasePlugin.class);\n\t\tGradleUtil.applyPlugin(project, GulpPlugin.class);\n\n\t\tTask createLiferayThemeJsonTask = addTaskCreateLiferayThemeJson(\n\t\t\tproject, workspaceExtension);\n\n\t\taddTaskDeploy(project);\n\t\tconfigureArtifacts(project);\n\t\tconfigureTaskClean(project);\n\t\tconfigureTasksExecuteGulp(project, createLiferayThemeJsonTask);\n\n\t\tconfigureRootTaskDistBundle(\n\t\t\tproject, RootProjectConfigurator.DIST_BUNDLE_TAR_TASK_NAME);\n\t\tconfigureRootTaskDistBundle(\n\t\t\tproject, RootProjectConfigurator.DIST_BUNDLE_ZIP_TASK_NAME);\n\t}","id":42611,"modified_method":"@Override\n\tpublic void apply(Project project) {\n\t\tWorkspaceExtension workspaceExtension = GradleUtil.getExtension(\n\t\t\t(ExtensionAware)project.getGradle(), WorkspaceExtension.class);\n\n\t\tGradleUtil.applyPlugin(project, LiferayThemePlugin.class);\n\n\t\tconfigureLiferay(project, workspaceExtension);\n\n\t\tconfigureRootTaskDistBundle(\n\t\t\tproject, RootProjectConfigurator.DIST_BUNDLE_TAR_TASK_NAME);\n\t\tconfigureRootTaskDistBundle(\n\t\t\tproject, RootProjectConfigurator.DIST_BUNDLE_ZIP_TASK_NAME);\n\t}","commit_id":"0345b4daab819d7044f3e9ed931acd1f83bf23e5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected ScriptHandlerFactory createScriptHandlerFactory() {\n        return new DefaultScriptHandlerFactory(\n                get(DependencyManagementServices.class),\n                get(FileResolver.class),\n                new DependencyMetaDataProviderImpl());\n    }","id":42612,"modified_method":"protected ScriptHandlerFactory createScriptHandlerFactory() {\n        return new DefaultScriptHandlerFactory(\n                get(DependencyManagementServices.class),\n                get(FileResolver.class),\n                get(DependencyMetaDataProvider.class)\n        );\n    }","commit_id":"8f92cfe512bcd5b01e9c6aa8784b8cdee48ad1e7","url":"https://github.com/gradle/gradle"},{"original_method":"protected ScriptPluginFactory createScriptObjectConfigurerFactory() {\n        return new DefaultScriptPluginFactory(\n                get(ScriptCompilerFactory.class),\n                get(ImportsReader.class),\n                getFactory(LoggingManagerInternal.class),\n                get(Instantiator.class),\n                get(ScriptHandlerFactory.class),\n                get(PluginResolverFactory.class),\n                get(FileLookup.class)\n        );\n    }","id":42613,"modified_method":"protected ScriptPluginFactory createScriptObjectConfigurerFactory() {\n        return new DefaultScriptPluginFactory(\n                get(ScriptCompilerFactory.class),\n                get(ImportsReader.class),\n                getFactory(LoggingManagerInternal.class),\n                get(Instantiator.class),\n                get(ScriptHandlerFactory.class),\n                get(PluginRequestApplicatorFactory.class),\n                get(FileLookup.class)\n        );\n    }","commit_id":"8f92cfe512bcd5b01e9c6aa8784b8cdee48ad1e7","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultScriptPluginFactory(ScriptCompilerFactory scriptCompilerFactory,\n                                      ImportsReader importsReader,\n                                      Factory<LoggingManagerInternal> loggingManagerFactory,\n                                      Instantiator instantiator,\n                                      ScriptHandlerFactory scriptHandlerFactory,\n                                      PluginResolverFactory pluginResolverFactory,\n                                      FileLookup fileLookup) {\n        this.scriptCompilerFactory = scriptCompilerFactory;\n        this.importsReader = importsReader;\n        this.loggingManagerFactory = loggingManagerFactory;\n        this.instantiator = instantiator;\n        this.scriptHandlerFactory = scriptHandlerFactory;\n        this.pluginResolverFactory = pluginResolverFactory;\n        this.fileLookup = fileLookup;\n    }","id":42614,"modified_method":"public DefaultScriptPluginFactory(ScriptCompilerFactory scriptCompilerFactory,\n                                      ImportsReader importsReader,\n                                      Factory<LoggingManagerInternal> loggingManagerFactory,\n                                      Instantiator instantiator,\n                                      ScriptHandlerFactory scriptHandlerFactory,\n                                      PluginRequestApplicatorFactory pluginRequestApplicatorFactory,\n                                      FileLookup fileLookup) {\n        this.scriptCompilerFactory = scriptCompilerFactory;\n        this.importsReader = importsReader;\n        this.loggingManagerFactory = loggingManagerFactory;\n        this.instantiator = instantiator;\n        this.scriptHandlerFactory = scriptHandlerFactory;\n        this.pluginRequestApplicatorFactory = pluginRequestApplicatorFactory;\n        this.fileLookup = fileLookup;\n    }","commit_id":"8f92cfe512bcd5b01e9c6aa8784b8cdee48ad1e7","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(final Object target) {\n            DefaultServiceRegistry services = new DefaultServiceRegistry();\n            services.add(ScriptPluginFactory.class, DefaultScriptPluginFactory.this);\n            services.add(ScriptHandlerFactory.class, scriptHandlerFactory);\n            services.add(ClassLoaderScope.class, classLoaderScope);\n            services.add(LoggingManagerInternal.class, loggingManagerFactory.create());\n            services.add(Instantiator.class, instantiator);\n            services.add(ScriptHandler.class, scriptHandler);\n            services.add(FileLookup.class, fileLookup);\n\n            ScriptSource withImports = importsReader.withImports(scriptSource);\n\n            PluginDependenciesService pluginDependenciesService = new PluginDependenciesService(getSource());\n            services.add(PluginDependenciesService.class, pluginDependenciesService);\n\n            ScriptCompiler compiler = scriptCompilerFactory.createCompiler(withImports);\n            compiler.setClassloader(classLoaderScope.getBase().getChildClassLoader());\n\n            boolean supportsPluginsBlock = ProjectScript.class.isAssignableFrom(scriptType);\n            String onPluginBlockError = supportsPluginsBlock ? null : \"Only Project build scripts can contain plugins {} blocks\";\n\n            PluginsAndBuildscriptTransformer scriptBlockTransformer = new PluginsAndBuildscriptTransformer(classpathClosureName, onPluginBlockError);\n\n            StatementExtractingScriptTransformer classpathScriptTransformer = new StatementExtractingScriptTransformer(classpathClosureName, scriptBlockTransformer);\n\n            compiler.setTransformer(classpathScriptTransformer);\n\n            ScriptRunner<? extends BasicScript> classPathScriptRunner = compiler.compile(scriptType);\n            classPathScriptRunner.getScript().init(target, services);\n            classPathScriptRunner.run();\n\n            Configuration classpathConfiguration = scriptHandler.getConfigurations().getByName(ScriptHandler.CLASSPATH_CONFIGURATION);\n            Set<File> files = classpathConfiguration.getFiles();\n            ClassPath classPath = new DefaultClassPath(files);\n\n            ClassLoader exportedClassLoader = classLoaderScope.export(classPath);\n\n            List<PluginRequest> pluginRequests = pluginDependenciesService.getRequests();\n            if (!pluginRequests.isEmpty()) {\n\n                Map<String, List<PluginRequest>> groupedById = CollectionUtils.groupBy(pluginRequests, new Transformer<String, PluginRequest>() {\n                    public String transform(PluginRequest pluginRequest) {\n                        return pluginRequest.getId();\n                    }\n                });\n\n                // Ignore duplicate noops - noop plugin just used for testing\n                groupedById.remove(NoopPluginResolver.PLUGIN_ID);\n\n                // Check for duplicates\n                for (Map.Entry<String, List<PluginRequest>> entry : groupedById.entrySet()) {\n                    List<PluginRequest> pluginRequestsForId = entry.getValue();\n                    if (pluginRequestsForId.size() > 1) {\n                        PluginRequest first = pluginRequests.get(0);\n                        PluginRequest second = pluginRequests.get(1);\n\n                        InvalidPluginRequestException exception = new InvalidPluginRequestException(second, \"Plugin with id '\" + entry.getKey() + \"' was already requested at line \" + first.getLineNumber());\n                        throw new LocationAwareException(exception, second.getScriptSource(), second.getLineNumber());\n                    }\n                }\n\n                PluginResolver pluginResolver = pluginResolverFactory.createPluginResolver(exportedClassLoader);\n                @SuppressWarnings(\"ConstantConditions\")\n                PluginResolutionApplicator resolutionApplicator = new PluginResolutionApplicator((PluginAware) target, classLoaderScope);\n                PluginRequestApplicator requestApplicator = new PluginRequestApplicator(pluginResolver, resolutionApplicator);\n                requestApplicator.applyPlugin(pluginRequests);\n            }\n\n            classLoaderScope.lock();\n\n            compiler.setClassloader(classLoaderScope.getScopeClassLoader());\n\n            compiler.setTransformer(new BuildScriptTransformer(\"no_\" + classpathScriptTransformer.getId(), classpathScriptTransformer.invert()));\n            ScriptRunner<? extends BasicScript> runner = compiler.compile(scriptType);\n\n            BasicScript script = runner.getScript();\n            script.init(target, services);\n            if (ownerScript && target instanceof ScriptAware) {\n                ((ScriptAware) target).setScript(script);\n            }\n            runner.run();\n        }","id":42615,"modified_method":"public void apply(final Object target) {\n            DefaultServiceRegistry services = new DefaultServiceRegistry();\n            services.add(ScriptPluginFactory.class, DefaultScriptPluginFactory.this);\n            services.add(ScriptHandlerFactory.class, scriptHandlerFactory);\n            services.add(ClassLoaderScope.class, classLoaderScope);\n            services.add(LoggingManagerInternal.class, loggingManagerFactory.create());\n            services.add(Instantiator.class, instantiator);\n            services.add(ScriptHandler.class, scriptHandler);\n            services.add(FileLookup.class, fileLookup);\n\n            ScriptSource withImports = importsReader.withImports(scriptSource);\n\n            PluginDependenciesService pluginDependenciesService = new PluginDependenciesService(getSource());\n            services.add(PluginDependenciesService.class, pluginDependenciesService);\n\n            ScriptCompiler compiler = scriptCompilerFactory.createCompiler(withImports);\n            compiler.setClassloader(classLoaderScope.getBase().getChildClassLoader());\n\n            boolean supportsPluginsBlock = ProjectScript.class.isAssignableFrom(scriptType);\n            String onPluginBlockError = supportsPluginsBlock ? null : \"Only Project build scripts can contain plugins {} blocks\";\n\n            PluginsAndBuildscriptTransformer scriptBlockTransformer = new PluginsAndBuildscriptTransformer(classpathClosureName, onPluginBlockError);\n\n            StatementExtractingScriptTransformer classpathScriptTransformer = new StatementExtractingScriptTransformer(classpathClosureName, scriptBlockTransformer);\n\n            compiler.setTransformer(classpathScriptTransformer);\n\n            ScriptRunner<? extends BasicScript> classPathScriptRunner = compiler.compile(scriptType);\n            classPathScriptRunner.getScript().init(target, services);\n            classPathScriptRunner.run();\n\n            Configuration classpathConfiguration = scriptHandler.getConfigurations().getByName(ScriptHandler.CLASSPATH_CONFIGURATION);\n            Set<File> files = classpathConfiguration.getFiles();\n            ClassPath classPath = new DefaultClassPath(files);\n\n            ClassLoader exportedClassLoader = classLoaderScope.export(classPath);\n\n            List<PluginRequest> pluginRequests = pluginDependenciesService.getRequests();\n            if (!pluginRequests.isEmpty()) {\n\n                Map<String, List<PluginRequest>> groupedById = CollectionUtils.groupBy(pluginRequests, new Transformer<String, PluginRequest>() {\n                    public String transform(PluginRequest pluginRequest) {\n                        return pluginRequest.getId();\n                    }\n                });\n\n                // Ignore duplicate noops - noop plugin just used for testing\n                groupedById.remove(NOOP_PLUGIN_ID);\n\n                // Check for duplicates\n                for (Map.Entry<String, List<PluginRequest>> entry : groupedById.entrySet()) {\n                    List<PluginRequest> pluginRequestsForId = entry.getValue();\n                    if (pluginRequestsForId.size() > 1) {\n                        PluginRequest first = pluginRequests.get(0);\n                        PluginRequest second = pluginRequests.get(1);\n\n                        InvalidPluginRequestException exception = new InvalidPluginRequestException(second, \"Plugin with id '\" + entry.getKey() + \"' was already requested at line \" + first.getLineNumber());\n                        throw new LocationAwareException(exception, second.getScriptSource(), second.getLineNumber());\n                    }\n                }\n\n                PluginRequestApplicator requestApplicator = pluginRequestApplicatorFactory.createRequestApplicator((PluginAware) target, exportedClassLoader, classLoaderScope);\n                for (PluginRequest pluginRequest : pluginRequests) {\n                    requestApplicator.applyPlugin(pluginRequest);\n                }\n            }\n\n            classLoaderScope.lock();\n\n            compiler.setClassloader(classLoaderScope.getScopeClassLoader());\n\n            compiler.setTransformer(new BuildScriptTransformer(\"no_\" + classpathScriptTransformer.getId(), classpathScriptTransformer.invert()));\n            ScriptRunner<? extends BasicScript> runner = compiler.compile(scriptType);\n\n            BasicScript script = runner.getScript();\n            script.init(target, services);\n            if (ownerScript && target instanceof ScriptAware) {\n                ((ScriptAware) target).setScript(script);\n            }\n            runner.run();\n        }","commit_id":"8f92cfe512bcd5b01e9c6aa8784b8cdee48ad1e7","url":"https://github.com/gradle/gradle"},{"original_method":"public ClassPath findClassPath(String name) {\n        if (name.equals(\"GRADLE_PLUGINS\")) {\n            ClassPath classpath = new DefaultClassPath();\n            for (Module pluginModule : pluginModuleRegistry.getPluginModules()) {\n                classpath = classpath.plus(pluginModule.getClasspath());\n            }\n            return classpath;\n        }\n        if (name.equals(\"GRADLE_CORE_IMPL\")) {\n            return moduleRegistry.getModule(\"gradle-core-impl\").getClasspath();\n        }\n\n        return null;\n    }","id":42616,"modified_method":"public ClassPath findClassPath(String name) {\n        if (name.equals(\"GRADLE_PLUGINS\")) {\n            ClassPath classpath = new DefaultClassPath();\n            for (Module pluginModule : pluginModuleRegistry.getPluginModules()) {\n                classpath = classpath.plus(pluginModule.getClasspath());\n            }\n            return classpath;\n        }\n        if (name.equals(\"GRADLE_CORE_IMPL\")) {\n            ClassPath coreImpl = moduleRegistry.getModule(\"gradle-core-impl\").getClasspath();\n            ClassPath pluginUse = moduleRegistry.getModule(\"gradle-plugin-use\").getClasspath();\n            return coreImpl.plus(pluginUse);\n        }\n\n        return null;\n    }","commit_id":"8f92cfe512bcd5b01e9c6aa8784b8cdee48ad1e7","url":"https://github.com/gradle/gradle"},{"original_method":"@NotNull\n  private static Version parseVersion(@NotNull ProcessOutput output) throws SvnBindException {\n    if (output.isTimeout() || (output.getExitCode() != 0) || !output.getStderr().isEmpty()) {\n      throw new SvnBindException(\n        String.format(\"Exit code: %d, Error: %s, Timeout: %b\", output.getExitCode(), output.getStderr(), output.isTimeout()));\n    }\n\n    return parseVersion(output.getStdout());\n  }","id":42617,"modified_method":"@NotNull\n  private static Version parseVersion(@NotNull ProcessOutput output) throws SvnBindException {\n    // TODO: This or similar check should likely go to CommandRuntime - to be applied for all commands\n    if (output.isTimeout()) {\n      throw new SvnBindException(String.format(\"Exit code: %d, Error: %s\", output.getExitCode(), output.getStderr()));\n    }\n\n    return parseVersion(output.getStdout());\n  }","commit_id":"581b34f67765d5512b9565ad96cc061e090847fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected Notification validate(@NotNull String executable) {\n    Notification result = createDefaultNotification();\n\n    // Necessary executable path will be taken from settings while command execution\n    final Version version = getConfiguredClientVersion();\n    if (version != null) {\n      try {\n        result = validateVersion(version);\n\n        if (result == null) {\n          result = validateEnglishOutput();\n        }\n      }\n      catch (Throwable e) {\n        LOG.info(e);\n      }\n    }\n\n    return result;\n  }","id":42618,"modified_method":"@Override\n  @Nullable\n  protected Notification validate(@NotNull String executable) {\n    Notification result = createDefaultNotification();\n\n    // Necessary executable path will be taken from settings while command execution\n    final Version version = getConfiguredClientVersion();\n    if (version != null) {\n      try {\n        result = validateVersion(version);\n\n        if (result == null) {\n          result = validateLocale();\n        }\n      }\n      catch (Throwable e) {\n        LOG.info(e);\n      }\n    }\n\n    return result;\n  }","commit_id":"581b34f67765d5512b9565ad96cc061e090847fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns true if the supplied executable is valid.\n   * Default implementation: try to execute the given executable and test if output returned errors.\n   * This can take a long time since it spawns external process.\n   * @param executable Path to executable.\n   * @return true if process with the supplied executable completed without errors and with exit code 0.\n   */\n  protected boolean isExecutableValid(@NotNull String executable) {\n    try {\n      GeneralCommandLine commandLine = new GeneralCommandLine();\n      commandLine.setExePath(executable);\n      CapturingProcessHandler handler = new CapturingProcessHandler(commandLine.createProcess(), CharsetToolkit.getDefaultSystemCharset());\n      ProcessOutput result = handler.runProcess(60 * 1000);\n      return !result.isTimeout() && (result.getExitCode() == 0) && result.getStderr().isEmpty();\n    }\n    catch (Throwable ignored) {\n      return false;\n    }\n  }","id":42619,"modified_method":"/**\n   * Returns true if the supplied executable is valid.\n   * Default implementation: try to execute the given executable and test if output returned errors.\n   * This can take a long time since it spawns external process.\n   * @param executable Path to executable.\n   * @return true if process with the supplied executable completed without errors and with exit code 0.\n   */\n  protected boolean isExecutableValid(@NotNull String executable) {\n    try {\n      GeneralCommandLine commandLine = new GeneralCommandLine();\n      commandLine.setExePath(executable);\n      CapturingProcessHandler handler = new CapturingProcessHandler(commandLine.createProcess(), CharsetToolkit.getDefaultSystemCharset());\n      ProcessOutput result = handler.runProcess(60 * 1000);\n      boolean timeout = result.isTimeout();\n      int exitCode = result.getExitCode();\n      String stderr = result.getStderr();\n      if (timeout) {\n        LOG.warn(\"Validation of \" + executable + \" failed with a timeout\");\n      }\n      if (exitCode != 0) {\n        LOG.warn(\"Validation of \" + executable + \" failed with non-zero exit code: \" + exitCode);\n      }\n      if (!stderr.isEmpty()) {\n        LOG.warn(\"Validation of \" + executable + \" failed with a non-empty error output: \" + stderr);\n      }\n      return !timeout && exitCode == 0 && stderr.isEmpty();\n    }\n    catch (Throwable t) {\n      LOG.warn(t);\n      return false;\n    }\n  }","commit_id":"8dbda1f9c975edcae24b0724ca53ec2cda7645b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private String runPythonHelper(@NotNull final String helper,\n                                 @NotNull final List<String> args, final boolean askForSudo) throws PyExternalProcessException {\n    ProcessOutput output = getHelperOutput(helper, args, askForSudo, null);\n    final int retcode = output.getExitCode();\n    if (output.isTimeout()) {\n      throw new PyExternalProcessException(ERROR_TIMEOUT, helper, args, \"Timed out\");\n    }\n    else if (retcode != 0) {\n      final String stdout = output.getStdout();\n      String message = output.getStderr();\n      if (message.trim().isEmpty()) {\n        message = stdout;\n      }\n      throw new PyExternalProcessException(retcode, helper, args, message);\n    }\n    return output.getStdout();\n  }","id":42620,"modified_method":"@NotNull\n  private String runPythonHelper(@NotNull final String helper,\n                                 @NotNull final List<String> args, final boolean askForSudo) throws PyExternalProcessException {\n    ProcessOutput output = getHelperOutput(helper, args, askForSudo, null);\n    final int retcode = output.getExitCode();\n    if (output.isTimeout()) {\n      throw new PyExternalProcessException(ERROR_TIMEOUT, helper, args, \"Timed out\");\n    }\n    else if (retcode != 0) {\n      final String message = output.getStderr() + \"\\n\" + output.getStdout();\n      throw new PyExternalProcessException(retcode, helper, args, message);\n    }\n    return output.getStdout();\n  }","commit_id":"5e1de017400e5966e34ff0dbee0ec81e77074448","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClientServiceImpl(ClientSpecification specification, ApplicationManagerConnectionHandler appMgrHandler) {\n    Preconditions.checkNotNull(specification);\n    this.specification = specification;\n    this.appMgrHandler = appMgrHandler;\n  }","id":42621,"modified_method":"public ClientServiceImpl(ClientSpecification specification,\n                           ApplicationManagerConnectionHandler appMgrHandler, Configuration configuration) {\n    Preconditions.checkNotNull(specification);\n    this.specification = specification;\n    this.appMgrHandler = appMgrHandler;\n    this.configuration = configuration;\n  }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClientServiceImpl(ApplicationId applicationId, Configuration configuration) {\n    this(applicationId,  new ApplicationManagerConnectionHandler(configuration));\n  }","id":42622,"modified_method":"public ClientServiceImpl(ApplicationId applicationId, Configuration configuration) {\n    this(applicationId,  new ApplicationManagerConnectionHandler(configuration), configuration);\n  }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void startUp() {\n    Log.info(\"Connecting to resource manager ...\");\n    appMgr = appMgrHandler.connect();\n\n    /**\n     *  If requested to use application id, then don't attempt to spawn a app master, but use\n     *  the application id for monitoring status and stopping the application.\n     */\n    if(useProvidedApplicationId) {\n      stopped = false;\n      return;\n    }\n\n    /** Get a new application id. */\n    GetNewApplicationResponse response = null;\n    try {\n      response = appMgr.getNewApplication(Records.newRecord(GetNewApplicationRequest.class));\n    } catch (YarnRemoteException e) {\n      Log.error(\"Failed to acquire application id from resource manager. Reason : {}\", e.getMessage());\n      stop();\n      return;\n    }\n\n    /** Retrieve application id from the response from connecting to resource manager. */\n    applicationId = response.getApplicationId();\n\n    /** Build a container launch context to create the AM container. */\n    ContainerLaunchContextFactory containerLaunchContextFactory =\n      new ContainerLaunchContextFactory(response.getMinimumResourceCapability(), response.getMaximumResourceCapability());\n\n    ApplicationSubmissionContext context = Records.newRecord(ApplicationSubmissionContext.class);\n    context.setApplicationId(applicationId);\n    context.setApplicationName(specification.getApplicationName());\n\n    try {\n      String user = UserGroupInformation.getCurrentUser().getShortUserName();\n\n      /** Build the container specification for launching application manager. */\n      TaskSpecification.Builder builder = new TaskSpecification.Builder(specification.getConfiguration());\n      builder.setMemory(specification.getMemory());\n      for(String command : specification.getCommands()) {\n        builder.addCommand(command);\n      }\n      for(Map.Entry<String, String> entry : specification.getEnvironment().entrySet()) {\n        builder.addEnv(entry.getKey(), entry.getValue());\n      }\n      builder.setUser(user);\n      builder.setPriority(0);\n      TaskSpecification appMasterSpecs = builder.create();\n\n      /** Create and populate container launch context. */\n      ContainerLaunchContext clc = containerLaunchContextFactory.create(appMasterSpecs);\n      context.setAMContainerSpec(clc);\n      context.setUser(appMasterSpecs.getUser());\n      context.setQueue(specification.getQueue());\n      context.setPriority(ContainerLaunchContextFactory.createPriority(appMasterSpecs.getPriority()));\n\n      /** Create application submission request and submit the application */\n      SubmitApplicationRequest request = Records.newRecord(SubmitApplicationRequest.class);\n      request.setApplicationSubmissionContext(context);\n      appMgr.submitApplication(request);\n      stopped = false;\n    } catch (YarnRemoteException e) {\n      Log.error(\"Unable to submit the application to YARN for running. Reason : {}\", e.getMessage());\n      stop();\n    } catch (IOException e) {\n      Log.error(\"Unable to retrieve user for set context for running application master. Reason : {}\", e.getMessage());\n      stop();\n    }\n  }","id":42623,"modified_method":"@Override\n  public void startUp() {\n    Log.info(\"Connecting to resource manager ...\");\n    appMgr = appMgrHandler.connect();\n\n    /**\n     *  If requested to use application id, then don't attempt to spawn a app master, but use\n     *  the application id for monitoring status and stopping the application.\n     */\n    if(useProvidedApplicationId) {\n      stopped = false;\n      return;\n    }\n\n    /** Get a new application id. */\n    GetNewApplicationResponse response = null;\n    try {\n      response = appMgr.getNewApplication(Records.newRecord(GetNewApplicationRequest.class));\n    } catch (YarnRemoteException e) {\n      Log.error(\"Failed to acquire application id from resource manager. Reason : {}\", e.getMessage());\n      stop();\n      return;\n    }\n\n    /** Retrieve application id from the response from connecting to resource manager. */\n    applicationId = response.getApplicationId();\n\n    /** Build a container launch context to create the AM container. */\n    ContainerLaunchContextFactory containerLaunchContextFactory =\n      new ContainerLaunchContextFactory(response.getMinimumResourceCapability(), response.getMaximumResourceCapability());\n\n    ApplicationSubmissionContext context = Records.newRecord(ApplicationSubmissionContext.class);\n    context.setApplicationId(applicationId);\n    context.setApplicationName(specification.getApplicationName());\n\n    try {\n      String user = UserGroupInformation.getCurrentUser().getShortUserName();\n\n      /** Build the container specification for launching application manager. */\n      TaskSpecification.Builder builder = new TaskSpecification.Builder(specification.getConfiguration());\n      builder.setId(specification.getApplicationName());\n      builder.setMemory(specification.getMemory());\n      for(String command : specification.getCommands()) {\n        builder.addCommand(command);\n      }\n      for(Map.Entry<String, String> entry : specification.getEnvironment().entrySet()) {\n        builder.addEnv(entry.getKey(), entry.getValue());\n      }\n      builder.setUser(user);\n      builder.setPriority(0);\n\n      /**\n       * Add the resources needed for Application Master to Task specification and make sure they are available\n       * on DFS.\n       */\n      DFSUtility dfsUtility = new DFSUtility(applicationId, configuration);\n      for(Map.Entry<String, String> entry : specification.getNamedLocalResources().entrySet()) {\n        dfsUtility.copyToHdfs(entry.getValue());\n        URI uri = dfsUtility.getResourceURI(entry.getValue());\n        builder.addNamedResource(entry.getKey(), uri.toString());\n      }\n\n      TaskSpecification appMasterSpecs = builder.create();\n\n      /** Create and populate container launch context. */\n\n      ContainerLaunchContext clc = containerLaunchContextFactory.create(appMasterSpecs);\n      context.setAMContainerSpec(clc);\n      context.setUser(appMasterSpecs.getUser());\n      context.setQueue(specification.getQueue());\n      context.setPriority(ContainerLaunchContextFactory.createPriority(appMasterSpecs.getPriority()));\n\n      /** Create application submission request and submit the application */\n      SubmitApplicationRequest request = Records.newRecord(SubmitApplicationRequest.class);\n      request.setApplicationSubmissionContext(context);\n      appMgr.submitApplication(request);\n      stopped = false;\n    } catch (YarnRemoteException e) {\n      Log.error(\"Unable to submit the application to YARN for running. Reason : {}\", e.getMessage());\n      stop();\n    } catch (IOException e) {\n      Log.error(\"Unable to retrieve user for set context for running application master. Reason : {}\", e.getMessage());\n      stop();\n    }\n  }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClientServiceImpl(ClientSpecification specification) {\n    this(specification, new ApplicationManagerConnectionHandler(specification.getConfiguration()));\n  }","id":42624,"modified_method":"public ClientServiceImpl(ClientSpecification specification) {\n    this(specification, new ApplicationManagerConnectionHandler(specification.getConfiguration()),\n      specification.getConfiguration());\n  }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Run one iteration of the scheduled task. If any invocation of this method throws an exception,\n   * the service will transition to the {@link com.google.common.util.concurrent.Service.State#FAILED} state and\n   * this method will no longer be called.\n   */\n  @Override\n  protected void runOneIteration() throws Exception {\n    if(! isRunning()) {\n      return;\n    }\n\n    /** Get the application status */\n    try {\n      GetApplicationReportRequest request = Records.newRecord(GetApplicationReportRequest.class);\n      request.setApplicationId(applicationId);\n      GetApplicationReportResponse response = appMgr.getApplicationReport(request);\n      applicationReport = response.getApplicationReport();\n      if(applicationReport == null) {\n        Log.warn(\"Have not received application report.\");\n      } else if(FAILED.contains(applicationReport.getYarnApplicationState())) {\n        stopped = true;\n        failed = true;\n      } else if(applicationReport.getYarnApplicationState() == YarnApplicationState.FINISHED) {\n        stopped = true;\n        failed = false;\n      }\n    } catch (YarnRemoteException e) {\n      Log.warn(\"Unable to get status of application {}. Reason : {}\", applicationId.toString(), e.getMessage());\n    }\n  }","id":42625,"modified_method":"/**\n   * Run one iteration of the scheduled task. If any invocation of this method throws an exception,\n   * the service will transition to the {@link com.google.common.util.concurrent.Service.State#FAILED} state and\n   * this method will no longer be called.\n   */\n  @Override\n  protected void runOneIteration() throws Exception {\n    if(! isRunning()) {\n      return;\n    }\n\n    /** Get the application status */\n    try {\n      GetApplicationReportRequest request = Records.newRecord(GetApplicationReportRequest.class);\n      request.setApplicationId(applicationId);\n      GetApplicationReportResponse response = appMgr.getApplicationReport(request);\n      applicationReport = response.getApplicationReport();\n      if(applicationReport == null) {\n        Log.warn(\"Have not received application report.\");\n      } else if(FAILED.contains(applicationReport.getYarnApplicationState())) {\n        stopped = true;\n        failed = true;\n        stop();\n      } else if(applicationReport.getYarnApplicationState() == YarnApplicationState.FINISHED) {\n        stopped = true;\n        failed = false;\n        stop();\n      }\n    } catch (YarnRemoteException e) {\n      Log.warn(\"Unable to get status of application {}. Reason : {}\", applicationId.toString(), e.getMessage());\n    }\n  }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClientServiceImpl(ApplicationId applicationId, ApplicationManagerConnectionHandler appMgrHandler) {\n    Preconditions.checkNotNull(applicationId);\n    Preconditions.checkNotNull(appMgrHandler);\n    this.applicationId = applicationId;\n    this.appMgrHandler = appMgrHandler;\n    this.specification = null;\n    this.useProvidedApplicationId = true;\n  }","id":42626,"modified_method":"public ClientServiceImpl(ApplicationId applicationId,\n                           ApplicationManagerConnectionHandler appMgrHandler, Configuration configuration) {\n    Preconditions.checkNotNull(applicationId);\n    Preconditions.checkNotNull(appMgrHandler);\n    this.applicationId = applicationId;\n    this.appMgrHandler = appMgrHandler;\n    this.specification = null;\n    this.useProvidedApplicationId = true;\n    this.configuration = configuration;\n  }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClientSpecification create() {\n      ClientSpecification specification = new ClientSpecification();\n      specification.setApplicationName(applicationName);\n      specification.setQueue(queue);\n      specification.setConfiguration(configuration);\n      specification.setCommands(commands);\n      specification.setEnvironment(environment);\n      specification.setMemory(memory);\n      return specification;\n    }","id":42627,"modified_method":"public ClientSpecification create() throws IOException {\n      ClientSpecification specification = new ClientSpecification();\n      specification.setApplicationName(applicationName);\n      specification.setQueue(queue);\n      specification.setConfiguration(configuration);\n      specification.setCommands(commands);\n      specification.setEnvironment(environment);\n      specification.setMemory(memory);\n      specification.setNamedLocalResources(namedResources);\n      return specification;\n    }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"public TaskSpecification create() throws IOException {\n      TaskSpecification cgp = new TaskSpecification();\n      cgp.setUser(user);\n      cgp.setMemory(memory);\n      cgp.setPriority(priority);\n      cgp.setNumInstances(numInstances);\n      cgp.setEnvironment(env);\n      cgp.setCommands(commands);\n      cgp.setId(id);\n\n      Map<String, LocalResource> localResourceMap = Maps.newHashMap();\n      FileSystem fs = FileSystem.get(configuration);\n      for(Map.Entry<String, String> entry : namedResources.entrySet()) {\n        LocalResource localResource = Records.newRecord(LocalResource.class);\n        Path path = new Path(entry.getValue());\n        FileStatus stat = fs.getFileStatus(path);\n        localResource.setSize(stat.getLen());\n        localResource.setTimestamp(stat.getModificationTime());\n        localResource.setResource(ConverterUtils.getYarnUrlFromPath(path));\n        localResourceMap.put(entry.getKey(), localResource);\n      }\n\n      return cgp;\n    }","id":42628,"modified_method":"public TaskSpecification create() throws IOException {\n      TaskSpecification cgp = new TaskSpecification();\n      cgp.setUser(user);\n      cgp.setMemory(memory);\n      cgp.setPriority(priority);\n      cgp.setNumInstances(numInstances);\n      cgp.setEnvironment(env);\n      cgp.setCommands(commands);\n      cgp.setId(id);\n\n      Map<String, LocalResource> localResourceMap = Maps.newHashMap();\n      FileSystem fs = FileSystem.get(configuration);\n      for(Map.Entry<String, String> entry : namedResources.entrySet()) {\n        LocalResource localResource = Records.newRecord(LocalResource.class);\n        Path path = new Path(entry.getValue());\n        FileStatus stat = fs.getFileStatus(path);\n\n        localResource.setResource(ConverterUtils.getYarnUrlFromPath(path));\n        localResource.setType(LocalResourceType.FILE);\n        localResource.setSize(stat.getLen());\n        localResource.setTimestamp(stat.getModificationTime());\n        localResource.setVisibility(LocalResourceVisibility.APPLICATION);\n        localResourceMap.put(entry.getKey(), localResource);\n      }\n      cgp.setNamedLocalResources(localResourceMap);\n      return cgp;\n    }","commit_id":"559af12b90b12287f8f14fa3cfdb25910fad9386","url":"https://github.com/caskdata/cdap"},{"original_method":"public static LWMap loadMap(String fileName) {\n        try {\n            \n            //probably don't want to save over original rdf\n            //LWMap map = new LWMap(fileName);\n            //so construct a name based on file name instead:\n            String mapName = fileName.substring(fileName.lastIndexOf(\"/\")+1,fileName.length());\n            if(mapName.lastIndexOf(\".\")>0)\n                mapName = mapName.substring(0,mapName.lastIndexOf(\".\"));\n            if(mapName.length() == 0)\n                mapName = \"RDF Import\";\n            LWMap map = new LWMap(mapName);\n            \n\n            // create an empty model\n            Model model = ModelFactory.createDefaultModel();\n            \n            // use the FileManager to find the input file\n            InputStream in = new FileInputStream(fileName);\n            if (in == null) {\n                throw new IllegalArgumentException(\n                        \"File: \" + fileName + \" not found\");\n            }\n            \n// read the RDF/XML file\n            model.read(in, \"\");\n            \n// write it to standard out\n            model.write(System.out);\n            int totalResources = 0;\n            Map<String,LWNode> hashMap = new HashMap<String,LWNode>();\n            ResIterator resIterator = model.listSubjects();\n            while(resIterator.hasNext()) {\n                com.hp.hpl.jena.rdf.model.Resource res = resIterator.nextResource();\n                LWNode node = createNodeFromResource(res);\n                hashMap.put(res.getURI(),node);\n                map.add(node);\n                totalResources++;\n            }\n            \n            com.hp.hpl.jena.rdf.model.NodeIterator nIterator = model.listObjects();\n            while(nIterator.hasNext()) {\n                RDFNode rdfNode = nIterator.nextNode();\n                if(rdfNode instanceof  com.hp.hpl.jena.rdf.model.Resource ) {\n                    com.hp.hpl.jena.rdf.model.Resource nodeResource = (com.hp.hpl.jena.rdf.model.Resource)rdfNode;\n                    if(!hashMap.containsKey(nodeResource.getURI())) {\n                        LWNode node = createNodeFromResource(nodeResource);\n                        hashMap.put(nodeResource.getURI(),node);\n                        map.add(node);\n                        totalResources++;\n                    }\n                }\n            }\n            float y = 20;\n            float x = 0;\n            int count = 0;\n           com.hp.hpl.jena.rdf.model.StmtIterator iter = model.listStatements();\n            while(iter.hasNext()){\n               com.hp.hpl.jena.rdf.model.Statement stmt = iter.nextStatement();\n               com.hp.hpl.jena.rdf.model.Resource stmtSubject = stmt.getSubject(); \n               com.hp.hpl.jena.rdf.model.Property stmtProperty = stmt.getPredicate();\n               com.hp.hpl.jena.rdf.model.RDFNode  stmtObject = stmt.getObject();\n               if(stmtObject instanceof com.hp.hpl.jena.rdf.model.Resource) {\n                    LWNode node1 = hashMap.get(stmtSubject.getURI());\n                    LWNode node2 = hashMap.get(((com.hp.hpl.jena.rdf.model.Resource)stmtObject).getURI());\n                    LWLink link = new LWLink(node1,node2);\n                    map.add(link);\n                }else if(stmtObject instanceof com.hp.hpl.jena.rdf.model.Literal) {\n                          tufts.vue.Resource mapResource = hashMap.get(stmtSubject.getURI()).getResource();\n                          mapResource.setProperty(stmtProperty.getLocalName(), stmtObject);\n                }\n                      \n            }\n            /**\n            float y = 20;\n            float x = 0;\n            int count = 0;\n            \n            LWNode node = null;\n            \n            int toggle = 0;\n            \n            // read the rdf statements and add metadata values and links\n            Iterator<com.hp.hpl.jena.rdf.model.Resource> iter = list.iterator();\n            while (iter.hasNext()) {\n                 com.hp.hpl.jena.rdf.model.Resource  r = iter.next();   \n                \n                float oldWidth = 0.0f;\n                if(node!=null)\n                    oldWidth = node.getWidth();\n                 \n                String uri = r.getURI();\n                String name = uri;\n                int lastSlash = name.lastIndexOf(\"/\");\n                if(lastSlash > 1 && (lastSlash == name.length()-1) )\n                {\n                    name = name.substring(0,name.length()-1);\n                }\n                name = name.substring(name.lastIndexOf(\"/\")+1,name.length());\n                if(name.length() == 0)\n                {\n                    name = uri;\n                }\n                if(name.length() > NODE_LABEL_TRUNCATE_LENGTH)\n                    name = name.substring(0,NODE_LABEL_TRUNCATE_LENGTH) + \"...\";\n                node = new LWNode(name);\n                System.out.println(\"Resource uri: \"+r.getURI());\n                com.hp.hpl.jena.rdf.model.StmtIterator stmtIterator = r.listProperties();\n                java.util.Properties properties = new java.util.Properties();\n                \n                // oldWidth can be used to seperate wide nodes from each other\n                // not perfectly reliable and not needed while node names are truncated\n                //if(oldWidth > 150)\n                //  x += oldWidth + 50;\n                //else\n                  x += 150;\n                \n                if(toggle == 0)\n                {\n                    toggle++;\n                    y = y + 50;\n                }\n                else\n                if(toggle == 1)\n                {\n                    toggle = 0;\n                    y = y - 50;\n                }\n                if(count % 5 == 0)\n                {\n                    y += 100;\n                    x = 400;\n                    toggle = 0;\n                }\n                \n                count++;\n                \n                node.setLocation(x,y);\n                tufts.vue.MapResource resource = new MapResource(r.getURI());\n                //resource.setProperties(properties);\n                node.setResource(resource);\n                map.addNode(node);\n                while(stmtIterator.hasNext()){\n                      com.hp.hpl.jena.rdf.model.Statement stmt = stmtIterator.nextStatement();\n                      Object obj = stmt.getObject();\n                      if(obj instanceof com.hp.hpl.jena.rdf.model.Resource) {\n                          Iterator nodeIterator = map.getNodeIterator();\n                          while(nodeIterator.hasNext()) {\n                              LWNode nodeCon = (LWNode)nodeIterator.next();\n                              if(nodeCon.getResource().getSpec().equals(((com.hp.hpl.jena.rdf.model.Resource)obj).getURI())){\n                                    LWLink link = new LWLink(node,nodeCon);\n                                    link.setLabel(stmt.getPredicate().getLocalName());\n                                    System.out.println(\"Resource\"+r.getURI()+\"Predicate: \"+stmt.getPredicate().getLocalName()+\"Object:\"+obj);\n                                    node.setLocation(node.getLocation().getX(),node.getLocation().getY()-20);\n                                    nodeCon.setLocation(nodeCon.getLocation().getX(),nodeCon.getLocation().getY()-20);\n                                    map.addLink(link);\n                              }\n                          }\n                          System.out.println(\"Resource: \"+r.getURI()+\" sub resource:\"+obj.toString());\n                      }else if(obj instanceof com.hp.hpl.jena.rdf.model.Literal) {\n                          properties.setProperty(stmt.getPredicate().getLocalName(), obj.toString());\n                          System.out.println(\"Resource: \"+r.getURI()+\" Literal:\"+obj.toString()+\" Predicate\"+stmt.getPredicate());\n                      }\n                      //System.out.println(\"Literal=\"+stmt.getLiteral()+\"predicate =\"+stmt.getPredicate());\n                }\n               \n            }\n            **/\n        \n            return map;\n        } catch (Exception e) {\n            // out of the Open File dialog box.\n            System.err.println(\"OpenAction.loadMap[\" + fileName + \"]: \" + e);\n            VueUtil.alert(null, \"\\\"\" + fileName + \"\\\" cannot be opened in this version of VUE.\", \"Map Open Error\");\n            e.printStackTrace();\n        }\n            \n        return null;\n    }","id":42629,"modified_method":"public static LWMap loadMap(String fileName) {\n        try {\n            \n            //probably don't want to save over original rdf\n            //LWMap map = new LWMap(fileName);\n            //so construct a name based on file name instead:\n            String mapName = fileName.substring(fileName.lastIndexOf(\"/\")+1,fileName.length());\n            if(mapName.lastIndexOf(\".\")>0)\n                mapName = mapName.substring(0,mapName.lastIndexOf(\".\"));\n            if(mapName.length() == 0)\n                mapName = \"RDF Import\";\n            LWMap map = new LWMap(mapName);\n            \n\n            // create an empty model\n            Model model = ModelFactory.createDefaultModel();\n            \n            // use the FileManager to find the input file\n            InputStream in = new FileInputStream(fileName);\n            if (in == null) {\n                throw new IllegalArgumentException(\n                        \"File: \" + fileName + \" not found\");\n            }\n            \n// read the RDF/XML file\n            model.read(in, \"\");\n            \n// write it to standard out\n            model.write(System.out);\n            int totalResources = 0;\n            Map<String,LWNode> hashMap = new HashMap<String,LWNode>();\n            ResIterator resIterator = model.listSubjects();\n            while(resIterator.hasNext()) {\n                com.hp.hpl.jena.rdf.model.Resource res = resIterator.nextResource();\n                LWNode node = createNodeFromResource(res);\n                hashMap.put(res.getURI(),node);\n                map.add(node);\n                totalResources++;\n            }\n            \n            com.hp.hpl.jena.rdf.model.NodeIterator nIterator = model.listObjects();\n            while(nIterator.hasNext()) {\n                RDFNode rdfNode = nIterator.nextNode();\n                if(rdfNode instanceof  com.hp.hpl.jena.rdf.model.Resource ) {\n                    com.hp.hpl.jena.rdf.model.Resource nodeResource = (com.hp.hpl.jena.rdf.model.Resource)rdfNode;\n                    if(!hashMap.containsKey(nodeResource.getURI())) {\n                        LWNode node = createNodeFromResource(nodeResource);\n                        hashMap.put(nodeResource.getURI(),node);\n                        map.add(node);\n                        totalResources++;\n                    }\n                }\n            }\n            //float y = 20;\n            //float x = 0;\n            //int count = 0;\n           resetLayoutParameters();\n           com.hp.hpl.jena.rdf.model.StmtIterator iter = model.listStatements();\n            while(iter.hasNext()){\n               com.hp.hpl.jena.rdf.model.Statement stmt = iter.nextStatement();\n               com.hp.hpl.jena.rdf.model.Resource stmtSubject = stmt.getSubject(); \n               com.hp.hpl.jena.rdf.model.Property stmtProperty = stmt.getPredicate();\n               com.hp.hpl.jena.rdf.model.RDFNode  stmtObject = stmt.getObject();\n               if(stmtObject instanceof com.hp.hpl.jena.rdf.model.Resource) {\n                    LWNode node1 = hashMap.get(stmtSubject.getURI());\n                    LWNode node2 = hashMap.get(((com.hp.hpl.jena.rdf.model.Resource)stmtObject).getURI());\n                    LWLink link = new LWLink(node1,node2);\n                    map.add(link);\n                }else if(stmtObject instanceof com.hp.hpl.jena.rdf.model.Literal) {\n                          tufts.vue.Resource mapResource = hashMap.get(stmtSubject.getURI()).getResource();\n                          if(mapResource != null)\n                            mapResource.setProperty(stmtProperty.getLocalName(), stmtObject);\n                }\n                      \n            }\n        \n            return map;\n        } catch (Exception e) {\n            // out of the Open File dialog box.\n            System.err.println(\"OpenAction.loadMap[\" + fileName + \"]: \" + e);\n            VueUtil.alert(null, \"\\\"\" + fileName + \"\\\" cannot be opened in this version of VUE.\", \"Map Open Error\");\n            e.printStackTrace();\n        }\n            \n        return null;\n    }","commit_id":"49926735f2bac89f5b27823a174af54bdb12c914","url":"https://github.com/VUE/VUE"},{"original_method":"private static LWNode createNodeFromResource(com.hp.hpl.jena.rdf.model.Resource r) {\n        tufts.vue.MapResource resource = new MapResource(r.getURI());\n        LWNode node = new LWNode(r.getURI());\n        node.setResource(resource);\n        double angle = Math.random()*Math.PI*4;\n        node.setLocation(200+200*Math.cos(angle),200+200*Math.sin(angle));\n        return node;\n    }","id":42630,"modified_method":"private static LWNode createNodeFromResource(com.hp.hpl.jena.rdf.model.Resource r) {\n        \n        tufts.vue.MapResource resource = null;\n        try\n        {\n          resource = new MapResource(r.getURI());\n        }\n        catch(Error err)\n        {\n          System.out.println(\"Error in creation of Map Resource: \" + err);\n        }\n        \n        LWNode node = new LWNode(\"Empty\");\n        if(resource == null)\n        {\n          node = new LWNode(\"Resource Error\");\n        }\n        else\n        {\n          node = new LWNode(r.getURI());\n          node.setResource(resource);\n        }\n        placeNode(node);\n        //double angle = Math.random()*Math.PI*4;\n        //node.setLocation(200+200*Math.cos(angle),200+200*Math.sin(angle));\n        return node;\n    }","commit_id":"49926735f2bac89f5b27823a174af54bdb12c914","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n   * Sync given view with data in DB. Ensures that view data in DB is updated,\n   * all instances changes from xml config are reflected to DB\n   *\n   * @param view                 view config from xml\n   * @param instanceDefinitions  view instances from xml\n   *\n   * @throws Exception if the view can not be synced\n   */\n  private void syncView(ViewEntity view,\n                        Set<ViewInstanceEntity> instanceDefinitions)\n      throws Exception {\n\n    String             viewName      = view.getName();\n    ViewEntity         persistedView = viewDAO.findByName(viewName);\n    ResourceTypeEntity resourceType  = view.getResourceType();\n\n    // if the view is not yet persisted ...\n    if (persistedView == null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Creating View \" + viewName + \".\");\n      }\n\n      // get or create an admin resource type to represent this view\n      ResourceTypeEntity resourceTypeEntity = resourceTypeDAO.findByName(viewName);\n      if (resourceTypeEntity == null) {\n        resourceTypeEntity = resourceType;\n        resourceTypeDAO.create(resourceTypeEntity);\n      }\n\n      for( ViewInstanceEntity instance : view.getInstances()) {\n        instance.setResource(createViewInstanceResource(resourceType));\n      }\n      // ... merge the view\n      persistedView = viewDAO.merge(view);\n    }\n\n    Map<String, ViewInstanceEntity> xmlInstanceEntityMap = new HashMap<String, ViewInstanceEntity>();\n    for( ViewInstanceEntity instance : view.getInstances()) {\n      xmlInstanceEntityMap.put(instance.getName(), instance);\n    }\n\n    view.setResourceType(persistedView.getResourceType());\n    view.setPermissions(persistedView.getPermissions());\n\n    // make sure that each instance of the view in the db is reflected in the given view\n    for (ViewInstanceEntity persistedInstance : persistedView.getInstances()){\n\n      String             instanceName = persistedInstance.getName();\n      ViewInstanceEntity instance     = view.getInstanceDefinition(instanceName);\n\n      xmlInstanceEntityMap.remove(instanceName);\n\n      // if the persisted instance is not in the view ...\n      if (instance == null) {\n        if (persistedInstance.isXmlDriven()) {\n          // this instance was persisted from an earlier view.xml but has been removed...\n          // remove it from the db\n          instanceDAO.remove(persistedInstance);\n        } else {\n          // this instance was not specified in the view.xml but was added through the API...\n          // bind it to the view and add it to the registry\n          instanceDAO.merge(persistedInstance);\n          bindViewInstance(view, persistedInstance);\n          instanceDefinitions.add(persistedInstance);\n        }\n      } else {\n        instance.setResource(persistedInstance.getResource());\n      }\n    }\n\n    // these instances appear in the view.xml but are not present in the db...\n    // add them to db\n    for (ViewInstanceEntity instance : xmlInstanceEntityMap.values()) {\n      instance.setResource(createViewInstanceResource(resourceType));\n      instanceDAO.merge(instance);\n    }\n  }","id":42631,"modified_method":"/**\n   * Sync given view with data in DB. Ensures that view data in DB is updated,\n   * all instances changes from xml config are reflected to DB\n   *\n   * @param view                 view config from xml\n   * @param instanceDefinitions  view instances from xml\n   *\n   * @throws Exception if the view can not be synced\n   */\n  private void syncView(ViewEntity view,\n                        Set<ViewInstanceEntity> instanceDefinitions)\n      throws Exception {\n\n    String             viewName      = view.getName();\n    ViewEntity         persistedView = viewDAO.findByName(viewName);\n    ResourceTypeEntity resourceType  = view.getResourceType();\n\n    // if the view is not yet persisted ...\n    if (persistedView == null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Creating View \" + viewName + \".\");\n      }\n\n      // get or create an admin resource type to represent this view\n      ResourceTypeEntity resourceTypeEntity = resourceTypeDAO.findByName(viewName);\n      if (resourceTypeEntity == null) {\n        resourceTypeEntity = resourceType;\n        resourceTypeDAO.create(resourceTypeEntity);\n      }\n\n      for( ViewInstanceEntity instance : view.getInstances()) {\n        instance.setResource(createViewInstanceResource(resourceType));\n      }\n      // ... merge the view\n      persistedView = viewDAO.merge(view);\n    }\n\n    view.setResourceType(persistedView.getResourceType());\n    view.setPermissions(persistedView.getPermissions());\n\n    // make sure that each instance of the view in the db is reflected in the given view\n    for (ViewInstanceEntity persistedInstance : persistedView.getInstances()){\n\n      String             instanceName = persistedInstance.getName();\n      ViewInstanceEntity instance     = view.getInstanceDefinition(instanceName);\n\n      // if the persisted instance is not in the view ...\n      if (instance == null) {\n        if (persistedInstance.isXmlDriven()) {\n          // this instance was persisted from an earlier view.xml but has been removed...\n          // remove it from the db\n          instanceDAO.remove(persistedInstance);\n        } else {\n          // this instance was not specified in the view.xml but was added through the API...\n          // bind it to the view and add it to the registry\n          instanceDAO.merge(persistedInstance);\n          bindViewInstance(view, persistedInstance);\n          instanceDefinitions.add(persistedInstance);\n        }\n      } else {\n        instance.setResource(persistedInstance.getResource());\n        instance.setViewInstanceId(persistedInstance.getViewInstanceId());\n        instance.setData(persistedInstance.getData());\n      }\n    }\n  }","commit_id":"456dcb246bb575c4c84c4294a7341e77932a566f","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testReadViewArchives() throws Exception {\n\n    File viewDir = createNiceMock(File.class);\n    File extractedArchiveDir = createNiceMock(File.class);\n    File viewArchive = createNiceMock(File.class);\n    File archiveDir = createNiceMock(File.class);\n    File entryFile  = createNiceMock(File.class);\n    File classesDir = createNiceMock(File.class);\n    File libDir = createNiceMock(File.class);\n    File fileEntry = createNiceMock(File.class);\n\n    JarFile viewJarFile = createNiceMock(JarFile.class);\n    Enumeration<JarEntry> enumeration = createMock(Enumeration.class);\n    JarEntry jarEntry = createNiceMock(JarEntry.class);\n    InputStream is = createMock(InputStream.class);\n    FileOutputStream fos = createMock(FileOutputStream.class);\n\n    ResourceTypeEntity resourceTypeEntity = new ResourceTypeEntity();\n    resourceTypeEntity.setId(10);\n    resourceTypeEntity.setName(\"MY_VIEW{1.0.0}\");\n\n    ViewEntity viewDefinition = ViewEntityTest.getViewEntity();\n    viewDefinition.setResourceType(resourceTypeEntity);\n\n    Set<ViewInstanceEntity> viewInstanceEntities = ViewInstanceEntityTest.getViewInstanceEntities(viewDefinition);\n    viewDefinition.setInstances(viewInstanceEntities);\n\n    Map<File, ViewConfig> viewConfigs =\n        Collections.singletonMap(viewArchive, viewDefinition.getConfiguration());\n\n    long resourceId = 99L;\n    for (ViewInstanceEntity viewInstanceEntity : viewInstanceEntities) {\n      ResourceEntity resourceEntity = new ResourceEntity();\n      resourceEntity.setId(resourceId);\n      resourceEntity.setResourceType(resourceTypeEntity);\n      viewInstanceEntity.setResource(resourceEntity);\n    }\n\n    Map<String, File> files = new HashMap<String, File>();\n\n    files.put(\"/var/lib/ambari-server/resources/views/work\", extractedArchiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\", archiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/view.xml\", entryFile);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/classes\", classesDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/lib\", libDir);\n\n    Map<File, FileOutputStream> outputStreams = new HashMap<File, FileOutputStream>();\n    outputStreams.put(entryFile, fos);\n\n    Map<File, JarFile> jarFiles = new HashMap<File, JarFile>();\n    jarFiles.put(viewArchive, viewJarFile);\n\n    // set expectations\n    expect(configuration.getViewsDir()).andReturn(viewDir);\n    expect(viewDir.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views\");\n\n    expect(configuration.getViewExtractionThreadPoolCoreSize()).andReturn(2).anyTimes();\n    expect(configuration.getViewExtractionThreadPoolMaxSize()).andReturn(3).anyTimes();\n    expect(configuration.getViewExtractionThreadPoolTimeout()).andReturn(10000L).anyTimes();\n\n    expect(viewDir.listFiles()).andReturn(new File[]{viewArchive});\n\n    expect(viewArchive.isDirectory()).andReturn(false);\n    expect(viewArchive.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n\n    expect(archiveDir.exists()).andReturn(false);\n    expect(archiveDir.getAbsolutePath()).andReturn(\n        \"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n    expect(archiveDir.mkdir()).andReturn(true);\n    expect(archiveDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewJarFile.entries()).andReturn(enumeration);\n    expect(viewJarFile.getInputStream(jarEntry)).andReturn(is);\n\n    expect(enumeration.hasMoreElements()).andReturn(true);\n    expect(enumeration.hasMoreElements()).andReturn(false);\n    expect(enumeration.nextElement()).andReturn(jarEntry);\n\n    expect(jarEntry.getName()).andReturn(\"view.xml\");\n    expect(jarEntry.isDirectory()).andReturn(false);\n\n    expect(is.available()).andReturn(1);\n    expect(is.available()).andReturn(0);\n\n    expect(is.read()).andReturn(10);\n    fos.write(10);\n\n    fos.close();\n    is.close();\n\n    expect(extractedArchiveDir.exists()).andReturn(false);\n    expect(extractedArchiveDir.mkdir()).andReturn(true);\n\n    expect(classesDir.exists()).andReturn(true);\n    expect(classesDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(libDir.exists()).andReturn(true);\n\n    expect(libDir.listFiles()).andReturn(new File[]{fileEntry});\n    expect(fileEntry.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewDAO.findByName(\"MY_VIEW{1.0.0}\")).andReturn(viewDefinition);\n\n    expect(viewDAO.findAll()).andReturn(Collections.<ViewEntity>emptyList());\n\n    // replay mocks\n    replay(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, resourceDAO, viewDAO, viewInstanceDAO);\n\n    TestViewArchiveUtility archiveUtility = new TestViewArchiveUtility(viewConfigs, files, outputStreams, jarFiles);\n\n    ViewRegistry registry = getRegistry(viewDAO, viewInstanceDAO, userDAO, memberDAO, privilegeDAO,\n        resourceDAO, resourceTypeDAO, securityHelper, handlerList, null, archiveUtility);\n\n    registry.readViewArchives();\n\n    ViewEntity view = null;\n\n    // Wait for the view load to complete.\n    long timeout = System.currentTimeMillis() + 10000L;\n    while ((view == null || !view.getStatus().equals(ViewDefinition.ViewStatus.DEPLOYED))&&\n        System.currentTimeMillis() < timeout) {\n      view = registry.getDefinition(\"MY_VIEW\", \"1.0.0\");\n    }\n\n    Assert.assertNotNull(view);\n    Assert.assertEquals(ViewDefinition.ViewStatus.DEPLOYED, view.getStatus());\n\n    Assert.assertEquals(2, registry.getInstanceDefinitions(view).size());\n\n    // verify mocks\n    verify(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, resourceDAO, viewDAO, viewInstanceDAO);\n  }","id":42632,"modified_method":"@Test\n  public void testReadViewArchives() throws Exception {\n\n    File viewDir = createNiceMock(File.class);\n    File extractedArchiveDir = createNiceMock(File.class);\n    File viewArchive = createNiceMock(File.class);\n    File archiveDir = createNiceMock(File.class);\n    File entryFile  = createNiceMock(File.class);\n    File classesDir = createNiceMock(File.class);\n    File libDir = createNiceMock(File.class);\n    File fileEntry = createNiceMock(File.class);\n\n    JarFile viewJarFile = createNiceMock(JarFile.class);\n    Enumeration<JarEntry> enumeration = createMock(Enumeration.class);\n    JarEntry jarEntry = createNiceMock(JarEntry.class);\n    InputStream is = createMock(InputStream.class);\n    FileOutputStream fos = createMock(FileOutputStream.class);\n\n    ResourceTypeEntity resourceTypeEntity = new ResourceTypeEntity();\n    resourceTypeEntity.setId(10);\n    resourceTypeEntity.setName(\"MY_VIEW{1.0.0}\");\n\n    ViewEntity viewDefinition = ViewEntityTest.getViewEntity();\n    viewDefinition.setResourceType(resourceTypeEntity);\n\n    Set<ViewInstanceEntity> viewInstanceEntities = ViewInstanceEntityTest.getViewInstanceEntities(viewDefinition);\n\n    for (ViewInstanceEntity viewInstanceEntity : viewInstanceEntities) {\n      viewInstanceEntity.putInstanceData(\"p1\", \"v1\");\n    }\n    viewDefinition.setInstances(viewInstanceEntities);\n\n    Map<File, ViewConfig> viewConfigs =\n        Collections.singletonMap(viewArchive, viewDefinition.getConfiguration());\n\n    long resourceId = 99L;\n    for (ViewInstanceEntity viewInstanceEntity : viewInstanceEntities) {\n      ResourceEntity resourceEntity = new ResourceEntity();\n      resourceEntity.setId(resourceId);\n      resourceEntity.setResourceType(resourceTypeEntity);\n      viewInstanceEntity.setResource(resourceEntity);\n    }\n\n    Map<String, File> files = new HashMap<String, File>();\n\n    files.put(\"/var/lib/ambari-server/resources/views/work\", extractedArchiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\", archiveDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/view.xml\", entryFile);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/classes\", classesDir);\n    files.put(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}/WEB-INF/lib\", libDir);\n\n    Map<File, FileOutputStream> outputStreams = new HashMap<File, FileOutputStream>();\n    outputStreams.put(entryFile, fos);\n\n    Map<File, JarFile> jarFiles = new HashMap<File, JarFile>();\n    jarFiles.put(viewArchive, viewJarFile);\n\n    // set expectations\n    expect(configuration.getViewsDir()).andReturn(viewDir);\n    expect(viewDir.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views\");\n\n    expect(configuration.getViewExtractionThreadPoolCoreSize()).andReturn(2).anyTimes();\n    expect(configuration.getViewExtractionThreadPoolMaxSize()).andReturn(3).anyTimes();\n    expect(configuration.getViewExtractionThreadPoolTimeout()).andReturn(10000L).anyTimes();\n\n    expect(viewDir.listFiles()).andReturn(new File[]{viewArchive});\n\n    expect(viewArchive.isDirectory()).andReturn(false);\n    expect(viewArchive.getAbsolutePath()).andReturn(\"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n\n    expect(archiveDir.exists()).andReturn(false);\n    expect(archiveDir.getAbsolutePath()).andReturn(\n        \"/var/lib/ambari-server/resources/views/work/MY_VIEW{1.0.0}\").anyTimes();\n    expect(archiveDir.mkdir()).andReturn(true);\n    expect(archiveDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewJarFile.entries()).andReturn(enumeration);\n    expect(viewJarFile.getInputStream(jarEntry)).andReturn(is);\n\n    expect(enumeration.hasMoreElements()).andReturn(true);\n    expect(enumeration.hasMoreElements()).andReturn(false);\n    expect(enumeration.nextElement()).andReturn(jarEntry);\n\n    expect(jarEntry.getName()).andReturn(\"view.xml\");\n    expect(jarEntry.isDirectory()).andReturn(false);\n\n    expect(is.available()).andReturn(1);\n    expect(is.available()).andReturn(0);\n\n    expect(is.read()).andReturn(10);\n    fos.write(10);\n\n    fos.close();\n    is.close();\n\n    expect(extractedArchiveDir.exists()).andReturn(false);\n    expect(extractedArchiveDir.mkdir()).andReturn(true);\n\n    expect(classesDir.exists()).andReturn(true);\n    expect(classesDir.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(libDir.exists()).andReturn(true);\n\n    expect(libDir.listFiles()).andReturn(new File[]{fileEntry});\n    expect(fileEntry.toURI()).andReturn(new URI(\"file:./\"));\n\n    expect(viewDAO.findByName(\"MY_VIEW{1.0.0}\")).andReturn(viewDefinition);\n\n    expect(viewDAO.findAll()).andReturn(Collections.<ViewEntity>emptyList());\n\n    // replay mocks\n    replay(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, resourceDAO, viewDAO, viewInstanceDAO);\n\n    TestViewArchiveUtility archiveUtility = new TestViewArchiveUtility(viewConfigs, files, outputStreams, jarFiles);\n\n    ViewRegistry registry = getRegistry(viewDAO, viewInstanceDAO, userDAO, memberDAO, privilegeDAO,\n        resourceDAO, resourceTypeDAO, securityHelper, handlerList, null, archiveUtility);\n\n    registry.readViewArchives();\n\n    ViewEntity view = null;\n\n    // Wait for the view load to complete.\n    long timeout = System.currentTimeMillis() + 10000L;\n    while ((view == null || !view.getStatus().equals(ViewDefinition.ViewStatus.DEPLOYED))&&\n        System.currentTimeMillis() < timeout) {\n      view = registry.getDefinition(\"MY_VIEW\", \"1.0.0\");\n    }\n\n    Assert.assertNotNull(view);\n    Assert.assertEquals(ViewDefinition.ViewStatus.DEPLOYED, view.getStatus());\n\n    Collection<ViewInstanceEntity> instanceDefinitions = registry.getInstanceDefinitions(view);\n    Assert.assertEquals(2, instanceDefinitions.size());\n\n    for (ViewInstanceEntity viewInstanceEntity : instanceDefinitions) {\n      Assert.assertEquals(\"v1\", viewInstanceEntity.getInstanceData(\"p1\").getValue());\n    }\n\n    // verify mocks\n    verify(configuration, viewDir, extractedArchiveDir, viewArchive, archiveDir, entryFile, classesDir,\n        libDir, fileEntry, viewJarFile, enumeration, jarEntry, is, fos, resourceDAO, viewDAO, viewInstanceDAO);\n  }","commit_id":"456dcb246bb575c4c84c4294a7341e77932a566f","url":"https://github.com/apache/ambari"},{"original_method":"/**\n\t * For Wicket it would be sufficient for this method to be package\n\t * protected. However to allow wicket-bench easy access to the information\n\t * ...\n\t * \n\t * @return Number of markup elements\n\t */\n\tpublic int size()\n\t{\n\t\treturn markup.size();\n\t}","id":42633,"modified_method":"/**\n\t * For Wicket it would be sufficient for this method to be package\n\t * protected. However to allow wicket-bench easy access to the information\n\t * ...\n\t * \n\t * @return Number of markup elements\n\t */\n\tpublic int size()\n\t{\n\t\treturn markupElements.size();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Add the tag to the local cache if open or open-close and if wicket:id is\n\t * present\n\t * \n\t * @param index\n\t * @param tag\n\t */\n\tprivate void addToCache(final int index, final ComponentTag tag)\n\t{\n\t\t// Only if the tag has wicket:id=\"xx\" and open or open-close\n\t\tif ((tag.isOpen() || tag.isOpenClose()) && tag.getAttributes().containsKey(wicketId))\n\t\t{\n\t\t\t// Add the tag to the cache\n\t\t\tif (this.componentMap == null)\n\t\t\t{\n\t\t\t\tthis.componentMap = new HashMap();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * XXX cleanup - this fragment check probably needs to be in\n\t\t\t * componenttag.isWantToBeDirectMarkupChild() or something similar\n\t\t\t * instead of being here\n\t\t\t */\n\t\t\tfinal boolean fragment = (tag instanceof WicketTag && ((WicketTag)tag).isFragementTag());\n\n\t\t\tfinal String key;\n\n\t\t\tif (tag.getPath() != null && !fragment/* WICKET-404 */)\n\t\t\t{\n\t\t\t\tkey = tag.getPath() + \":\" + tag.getId();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkey = tag.getId();\n\t\t\t}\n\t\t\tthis.componentMap.put(key, new Integer(index));\n\t\t}\n\t}","id":42634,"modified_method":"/**\n\t * Add the tag to the local cache if open or open-close and if wicket:id is\n\t * present\n\t * \n\t * @param index\n\t * @param tag\n\t */\n\tprivate void addToCache(final int index, final ComponentTag tag)\n\t{\n\t\t// Only if the tag has wicket:id=\"xx\" and open or open-close\n\t\tif ((tag.isOpen() || tag.isOpenClose()) && tag.getAttributes().containsKey(getMarkupResourceData().getWicketId()))\n\t\t{\n\t\t\t// Add the tag to the cache\n\t\t\tif (this.componentMap == null)\n\t\t\t{\n\t\t\t\tthis.componentMap = new HashMap();\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * XXX cleanup - this fragment check probably needs to be in\n\t\t\t * componenttag.isWantToBeDirectMarkupChild() or something similar\n\t\t\t * instead of being here\n\t\t\t */\n\t\t\tfinal boolean fragment = (tag instanceof WicketTag && ((WicketTag)tag).isFragementTag());\n\n\t\t\tfinal String key;\n\n\t\t\tif (tag.getPath() != null && !fragment/* WICKET-404 */)\n\t\t\t{\n\t\t\t\tkey = tag.getPath() + \":\" + tag.getId();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkey = tag.getId();\n\t\t\t}\n\t\t\tthis.componentMap.put(key, new Integer(index));\n\t\t}\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Reset the markup to its defaults, except for the wicket namespace which\n\t * remains unchanged.\n\t */\n\tfinal void reset()\n\t{\n\t\tthis.markup = new MarkupFragment(this);\n\t\tthis.resource = null;\n\t\tthis.xmlDeclaration = null;\n\t\tthis.encoding = null;\n\t\tthis.currentPath = null;\n\t}","id":42635,"modified_method":"/**\n\t * Reset the markup to its defaults, except for the wicket namespace which\n\t * remains unchanged.\n\t */\n\tfinal void reset()\n\t{\n\t\tthis.markupElements = new ArrayList();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Make all tags immutable and the list of elements unmodifable.\n\t */\n\tfinal void makeImmutable()\n\t{\n\t\tthis.markup.makeImmutable();\n\n\t\t// We assume all markup elements have now been added. It is\n\t\t// now time to initialize all remaining variables based\n\t\t// on the markup loaded, which could not be initialized\n\t\t// earlier on.\n\t\tinitialize();\n\t}","id":42636,"modified_method":"/**\n\t * Make all tags immutable and the list of elements unmodifable.\n\t */\n\tfinal void makeImmutable()\n\t{\n\t\tfor (int i = 0; i < this.markupElements.size(); i++)\n\t\t{\n\t\t\tMarkupElement elem = (MarkupElement)this.markupElements.get(i);\n\t\t\tif (elem instanceof ComponentTag)\n\t\t\t{\n\t\t\t\t// Make the tag immutable\n\t\t\t\t((ComponentTag)elem).makeImmutable();\n\t\t\t}\n\t\t}\n\n\t\tthis.markupElements = Collections.unmodifiableList(this.markupElements);\n\t\t\n\t\tinitialize();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Set the components path within the markup and add the component tag to\n\t * the local cache\n\t * \n\t * @param componentPath\n\t * @param tag\n\t * @return componentPath\n\t */\n\tprivate StringBuffer setComponentPathForTag(final StringBuffer componentPath,\n\t\t\tfinal ComponentTag tag)\n\t{\n\t\t// Only if the tag has wicket:id=\"xx\" and open or open-close\n\t\tif ((tag.isOpen() || tag.isOpenClose()) && tag.getAttributes().containsKey(wicketId))\n\t\t{\n\t\t\t// With open-close the path does not change. It can/will not have\n\t\t\t// children. The same is true for HTML tags like <br> or <img>\n\t\t\t// which might not have close tags.\n\t\t\tif (tag.isOpenClose() || tag.hasNoCloseTag())\n\t\t\t{\n\t\t\t\t// Set the components path.\n\t\t\t\tif ((this.currentPath != null) && (this.currentPath.length() > 0))\n\t\t\t\t{\n\t\t\t\t\ttag.setPath(this.currentPath.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Set the components path.\n\t\t\t\tif (this.currentPath == null)\n\t\t\t\t{\n\t\t\t\t\tthis.currentPath = new StringBuffer(100);\n\t\t\t\t}\n\t\t\t\telse if (this.currentPath.length() > 0)\n\t\t\t\t{\n\t\t\t\t\ttag.setPath(this.currentPath.toString());\n\t\t\t\t\tthis.currentPath.append(':');\n\t\t\t\t}\n\n\t\t\t\t// .. and append the tags id to the component path for the\n\t\t\t\t// children to come\n\t\t\t\tthis.currentPath.append(tag.getId());\n\t\t\t}\n\t\t}\n\t\telse if (tag.isClose() && (this.currentPath != null))\n\t\t{\n\t\t\t// For example <wicket:message> does not have an id\n\t\t\tif ((tag.getOpenTag() == null)\n\t\t\t\t\t|| tag.getOpenTag().getAttributes().containsKey(wicketId))\n\t\t\t{\n\t\t\t\t// Remove the last element from the component path\n\t\t\t\tint index = this.currentPath.lastIndexOf(\":\");\n\t\t\t\tif (index != -1)\n\t\t\t\t{\n\t\t\t\t\tthis.currentPath.setLength(index);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.currentPath.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.currentPath;\n\t}","id":42637,"modified_method":"/**\n\t * Set the components path within the markup and add the component tag to\n\t * the local cache\n\t * \n\t * @param componentPath\n\t * @param tag\n\t * @return componentPath\n\t */\n\tprivate StringBuffer setComponentPathForTag(final StringBuffer componentPath,\n\t\t\tfinal ComponentTag tag)\n\t{\n\t\t// Only if the tag has wicket:id=\"xx\" and open or open-close\n\t\tif ((tag.isOpen() || tag.isOpenClose()) && tag.getAttributes().containsKey(markupResourceData.getWicketId()))\n\t\t{\n\t\t\t// With open-close the path does not change. It can/will not have\n\t\t\t// children. The same is true for HTML tags like <br> or <img>\n\t\t\t// which might not have close tags.\n\t\t\tif (tag.isOpenClose() || tag.hasNoCloseTag())\n\t\t\t{\n\t\t\t\t// Set the components path.\n\t\t\t\tif ((this.currentPath != null) && (this.currentPath.length() > 0))\n\t\t\t\t{\n\t\t\t\t\ttag.setPath(this.currentPath.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Set the components path.\n\t\t\t\tif (this.currentPath == null)\n\t\t\t\t{\n\t\t\t\t\tthis.currentPath = new StringBuffer(100);\n\t\t\t\t}\n\t\t\t\telse if (this.currentPath.length() > 0)\n\t\t\t\t{\n\t\t\t\t\ttag.setPath(this.currentPath.toString());\n\t\t\t\t\tthis.currentPath.append(':');\n\t\t\t\t}\n\n\t\t\t\t// .. and append the tags id to the component path for the\n\t\t\t\t// children to come\n\t\t\t\tthis.currentPath.append(tag.getId());\n\t\t\t}\n\t\t}\n\t\telse if (tag.isClose() && (this.currentPath != null))\n\t\t{\n\t\t\t// For example <wicket:message> does not have an id\n\t\t\tif ((tag.getOpenTag() == null)\n\t\t\t\t\t|| tag.getOpenTag().getAttributes().containsKey(markupResourceData.getWicketId()))\n\t\t\t{\n\t\t\t\t// Remove the last element from the component path\n\t\t\t\tint index = this.currentPath.lastIndexOf(\":\");\n\t\t\t\tif (index != -1)\n\t\t\t\t{\n\t\t\t\t\tthis.currentPath.setLength(index);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.currentPath.setLength(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.currentPath;\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Create an iterator for the component tags in the markup.\n\t * \n\t * @param startIndex\n\t *            The index to start with\n\t * @param matchClass\n\t *            Iterate over elements matching the class\n\t * @return ComponentTagIterator\n\t */\n\tpublic Iterator componentTagIterator(final int startIndex, final Class matchClass)\n\t{\n\t\treturn this.markup.iterator(startIndex, matchClass);\n\t}","id":42638,"modified_method":"/**\n\t * Create an iterator for the component tags in the markup.\n\t * \n\t * @param startIndex\n\t *            The index to start with\n\t * @param matchClass\n\t *            Iterate over elements matching the class\n\t * @return ComponentTagIterator\n\t */\n\tpublic Iterator componentTagIterator(final int startIndex, final Class matchClass)\n\t{\n\t\treturn iterator(startIndex, matchClass);\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Initialize the index where <head> can be found.\n\t */\n\tprotected void initialize()\n\t{\n\t\t// Reset\n\t\tthis.componentMap = null;\n\n\t\tif (markup != null)\n\t\t{\n\t\t\t// HTML tags like <img> may not have a close tag. But because that\n\t\t\t// can only be detected until later on in the sequential markup\n\t\t\t// reading loop, we only can do it now.\n\t\t\tStringBuffer componentPath = null;\n\t\t\tfor (int i = 0; i < this.markup.size(); i++)\n\t\t\t{\n\t\t\t\tMarkupElement elem = this.markup.get(i);\n\t\t\t\tif (elem instanceof ComponentTag)\n\t\t\t\t{\n\t\t\t\t\tComponentTag tag = (ComponentTag)elem;\n\n\t\t\t\t\t// Set the tags components path\n\t\t\t\t\tcomponentPath = setComponentPathForTag(componentPath, tag);\n\n\t\t\t\t\t// and add it to the local cache to be found fast if\n\t\t\t\t\t// required\n\t\t\t\t\taddToCache(i, tag);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// The variable is only needed while adding markup elements.\n\t\t// initialize() is invoked after all elements have been added.\n\t\tthis.currentPath = null;\n\t}","id":42639,"modified_method":"/**\n\t * Initialize the index where wicket tags can be found\n\t */\n\tprotected void initialize()\n\t{\n\t\t// Reset\n\t\tthis.componentMap = null;\n\n\t\tif (markupElements != null)\n\t\t{\n\t\t\t// HTML tags like <img> may not have a close tag. But because that\n\t\t\t// can only be detected until later on in the sequential markup\n\t\t\t// reading loop, we only can do it now.\n\t\t\tStringBuffer componentPath = null;\n\t\t\tfor (int i = 0; i < size(); i++)\n\t\t\t{\n\t\t\t\tMarkupElement elem = get(i);\n\t\t\t\tif (elem instanceof ComponentTag)\n\t\t\t\t{\n\t\t\t\t\tComponentTag tag = (ComponentTag)elem;\n\n\t\t\t\t\t// Set the tags components path\n\t\t\t\t\tcomponentPath = setComponentPathForTag(componentPath, tag);\n\n\t\t\t\t\t// and add it to the local cache to be found fast if\n\t\t\t\t\t// required\n\t\t\t\t\taddToCache(i, tag);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// The variable is only needed while adding markup elements.\n\t\t// initialize() is invoked after all elements have been added.\n\t\tthis.currentPath = null;\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Add a MarkupElement\n\t * \n\t * @param pos\n\t * @param markupElement\n\t */\n\tfinal void addMarkupElement(final int pos, final MarkupElement markupElement)\n\t{\n\t\tthis.markup.addMarkupElement(pos, markupElement);\n\t}","id":42640,"modified_method":"/**\n\t * Add a MarkupElement\n\t * \n\t * @param pos\n\t * @param markupElement\n\t */\n\tfinal public void addMarkupElement(final int pos, final MarkupElement markupElement)\n\t{\n\t\tthis.markupElements.add(pos, markupElement);\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return String representation of markup list\n\t */\n\tpublic String toString()\n\t{\n\t\tif (resource != null)\n\t\t{\n\t\t\treturn resource.toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn \"(unknown resource)\";\n\t\t}\n\t}","id":42641,"modified_method":"/**\n\t * @return String representation of markup list\n\t */\n\tpublic final String toString()\n\t{\n\t\tfinal AppendingStringBuffer buf = new AppendingStringBuffer(400);\n\t\tbuf.append(this.markupResourceData.toString());\n\t\tbuf.append(\"\\n\");\n\n\t\tfinal Iterator iter = this.markupElements.iterator();\n\t\twhile (iter.hasNext())\n\t\t{\n\t\t\tbuf.append(iter.next());\n\t\t\tbuf.append(\",\");\n\t\t}\n\n\t\treturn buf.toString();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * For Wicket it would be sufficient for this method to be package\n\t * protected. However to allow wicket-bench easy access to the information\n\t * ...\n\t * \n\t * @param index\n\t *            Index into markup list\n\t * @return Markup element\n\t */\n\tpublic MarkupElement get(final int index)\n\t{\n\t\treturn markup.get(index);\n\t}","id":42642,"modified_method":"/**\n\t * For Wicket it would be sufficient for this method to be package\n\t * protected. However to allow wicket-bench easy access to the information\n\t * ...\n\t * \n\t * @param index\n\t *            Index into markup list\n\t * @return Markup element\n\t */\n\tpublic final MarkupElement get(final int index)\n\t{\n\t\treturn (MarkupElement)markupElements.get(index);\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Add a MarkupElement\n\t * \n\t * @param markupElement\n\t */\n\tpublic final void addMarkupElement(final MarkupElement markupElement)\n\t{\n\t\tthis.markup.addMarkupElement(markupElement);\n\t}","id":42643,"modified_method":"/**\n\t * Add a MarkupElement\n\t * \n\t * @param markupElement\n\t */\n\tfinal public void addMarkupElement(final MarkupElement markupElement)\n\t{\n\t\tthis.markupElements.add(markupElement);\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * The markup has just been loaded and now we check if markup inheritance\n\t * applies, which is if <wicket:extend> is found in the markup. If yes, than\n\t * load the base markups and merge the markup elements to create an updated\n\t * (merged) list of markup elements.\n\t * \n\t * @param container\n\t *            The original requesting markup container\n\t * @param markup\n\t *            The markup to checked for inheritance\n\t * @return A markup object with the the base markup elements resolved.\n\t */\n\tprivate Markup checkForMarkupInheritance(final MarkupContainer container, final Markup markup)\n\t{\n\t\t// Check if markup contains <wicket:extend> which tells us that\n\t\t// we need to read the inherited markup as well.\n\t\tint extendIndex = requiresBaseMarkup(markup);\n\t\tif (extendIndex == -1)\n\t\t{\n\t\t\t// return a MarkupStream for the markup\n\t\t\treturn markup;\n\t\t}\n\n\t\t// get the base markup\n\t\tfinal Markup baseMarkup = getMarkup(container, markup.getResource().getMarkupClass()\n\t\t\t\t.getSuperclass());\n\n\t\tif (baseMarkup == Markup.NO_MARKUP)\n\t\t{\n\t\t\tthrow new MarkupNotFoundException(\n\t\t\t\t\t\"Parent markup of inherited markup not found. Component class: \"\n\t\t\t\t\t\t\t+ markup.getResource().getContainerInfo().getContainerClass().getName()\n\t\t\t\t\t\t\t+ \" Enable debug messages for org.apache.wicket.util.resource.Resource to get a list of all filenames tried.\");\n\t\t}\n\n\t\tfinal CharSequence key = markup.getResource().getCacheKey();\n\t\tif (key != null)\n\t\t{\n\t\t\t// register an after-load listener for base markup. The listener\n\t\t\t// implementation will remove the derived markup which must be\n\t\t\t// merged\n\t\t\t// with the base markup\n\t\t\tafterLoadListeners.add(baseMarkup.getResource(), new IChangeListener()\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Make sure there is only one listener per derived markup\n\t\t\t\t * \n\t\t\t\t * @see java.lang.Object#equals(java.lang.Object)\n\t\t\t\t */\n\t\t\t\tpublic boolean equals(Object obj)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Make sure there is only one listener per derived markup\n\t\t\t\t * \n\t\t\t\t * @see java.lang.Object#hashCode()\n\t\t\t\t */\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn key.hashCode();\n\t\t\t\t}\n\n\t\t\t\tpublic void onChange()\n\t\t\t\t{\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.debug(\"Remove derived markup from cache: \" + markup.getResource());\n\t\t\t\t\t}\n\t\t\t\t\tremoveMarkup(markup.getResource());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Merge base and derived markup\n\t\tMarkup mergedMarkup = new MergedMarkup(markup, baseMarkup, extendIndex);\n\t\treturn mergedMarkup;\n\t}","id":42644,"modified_method":"/**\n\t * The markup has just been loaded and now we check if markup inheritance\n\t * applies, which is if <wicket:extend> is found in the markup. If yes, than\n\t * load the base markups and merge the markup elements to create an updated\n\t * (merged) list of markup elements.\n\t * \n\t * @param container\n\t *            The original requesting markup container\n\t * @param markup\n\t *            The markup to checked for inheritance\n\t * @return A markup object with the the base markup elements resolved.\n\t */\n\tprivate Markup checkForMarkupInheritance(final MarkupContainer container, final Markup markup)\n\t{\n\t\t// Check if markup contains <wicket:extend> which tells us that\n\t\t// we need to read the inherited markup as well.\n\t\tint extendIndex = requiresBaseMarkup(markup);\n\t\tif (extendIndex == -1)\n\t\t{\n\t\t\t// return a MarkupStream for the markup\n\t\t\treturn markup;\n\t\t}\n\n\t\t// get the base markup\n\t\tfinal Markup baseMarkup = getMarkup(container, markup.getMarkupResourceData().getResource().getMarkupClass()\n\t\t\t\t.getSuperclass());\n\n\t\tif (baseMarkup == Markup.NO_MARKUP)\n\t\t{\n\t\t\tthrow new MarkupNotFoundException(\n\t\t\t\t\t\"Parent markup of inherited markup not found. Component class: \"\n\t\t\t\t\t\t\t+ markup.getMarkupResourceData().getResource().getContainerInfo().getContainerClass().getName()\n\t\t\t\t\t\t\t+ \" Enable debug messages for org.apache.wicket.util.resource.Resource to get a list of all filenames tried.\");\n\t\t}\n\n\t\tfinal CharSequence key = markup.getMarkupResourceData().getResource().getCacheKey();\n\t\tif (key != null)\n\t\t{\n\t\t\t// register an after-load listener for base markup. The listener\n\t\t\t// implementation will remove the derived markup which must be\n\t\t\t// merged with the base markup\n\t\t\tafterLoadListeners.add(baseMarkup.getMarkupResourceData().getResource(), new IChangeListener()\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Make sure there is only one listener per derived markup\n\t\t\t\t * \n\t\t\t\t * @see java.lang.Object#equals(java.lang.Object)\n\t\t\t\t */\n\t\t\t\tpublic boolean equals(Object obj)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Make sure there is only one listener per derived markup\n\t\t\t\t * \n\t\t\t\t * @see java.lang.Object#hashCode()\n\t\t\t\t */\n\t\t\t\tpublic int hashCode()\n\t\t\t\t{\n\t\t\t\t\treturn key.hashCode();\n\t\t\t\t}\n\n\t\t\t\tpublic void onChange()\n\t\t\t\t{\n\t\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.debug(\"Remove derived markup from cache: \" + markup.getMarkupResourceData().getResource());\n\t\t\t\t\t}\n\t\t\t\t\tremoveMarkup(markup.getMarkupResourceData().getResource());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Merge base and derived markup\n\t\tMarkup mergedMarkup = new MergedMarkup(markup, baseMarkup, extendIndex);\n\t\treturn mergedMarkup;\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param xmlParser\n\t *            The streaming xml parser to read and parse the markup\n\t * @param resource\n\t *            The markup resource (file)\n\t */\n\tpublic MarkupParser(final IXmlPullParser xmlParser, final MarkupResourceStream resource)\n\t{\n\t\tthis.xmlParser = xmlParser;\n\t\tthis.markupSettings = Application.get().getMarkupSettings();\n\n\t\tthis.markup = new Markup();\n\t\tthis.markup.setResource(resource);\n\n\t\t// Initialize the markup filter chain\n\t\tinitializeMarkupFilters();\n\t}","id":42645,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param xmlParser\n\t *            The streaming xml parser to read and parse the markup\n\t * @param resource\n\t *            The markup resource (file)\n\t */\n\tpublic MarkupParser(final IXmlPullParser xmlParser, final MarkupResourceStream resource)\n\t{\n\t\tthis.xmlParser = xmlParser;\n\t\tthis.markupSettings = Application.get().getMarkupSettings();\n\n\t\tMarkupResourceData markup = new MarkupResourceData();\n\t\tmarkup.setResource(resource);\n\t\t\n\t\tthis.markup = new Markup(markup);\n\n\t\t// Initialize the markup filter chain\n\t\tinitializeMarkupFilters();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * In case you want to analyze markup which BY DEFAULT does not use \"wicket\"\n\t * to find relevant tags.\n\t * \n\t * @param namespace\n\t */\n\tpublic final void setWicketNamespace(final String namespace)\n\t{\n\t\tthis.markup.setWicketNamespace(namespace);\n\t}","id":42646,"modified_method":"/**\n\t * In case you want to analyze markup which BY DEFAULT does not use \"wicket\"\n\t * to find relevant tags.\n\t * \n\t * @param namespace\n\t */\n\tpublic final void setWicketNamespace(final String namespace)\n\t{\n\t\tthis.markup.getMarkupResourceData().setWicketNamespace(namespace);\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Applications which subclass initFilterChain() might also wish to access\n\t * the markup resource stream.\n\t * \n\t * @return The markup resource stream\n\t */\n\tprotected MarkupResourceStream getMarkupResourceStream()\n\t{\n\t\treturn this.markup.getResource();\n\t}","id":42647,"modified_method":"/**\n\t * Applications which subclass initFilterChain() might also wish to access\n\t * the markup resource stream.\n\t * \n\t * @return The markup resource stream\n\t */\n\tprotected MarkupResourceStream getMarkupResourceStream()\n\t{\n\t\treturn this.markup.getMarkupResourceData().getResource();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Reads and parses markup from a file.\n\t * \n\t * @return The markup\n\t * @throws IOException\n\t * @throws ResourceStreamNotFoundException\n\t */\n\tpublic final Markup parse() throws IOException, ResourceStreamNotFoundException\n\t{\n\t\t// Initialize the xml parser\n\t\tthis.xmlParser.parse(this.markup.getResource().getInputStream(), this.markupSettings\n\t\t\t\t.getDefaultMarkupEncoding());\n\n\t\t// parse the xml markup and tokenize it into wicket relevant markup\n\t\t// elements\n\t\tparseMarkup();\n\n\t\tthis.markup.setEncoding(xmlParser.getEncoding());\n\t\tthis.markup.setXmlDeclaration(xmlParser.getXmlDeclaration());\n\n\t\treturn this.markup;\n\t}","id":42648,"modified_method":"/**\n\t * Reads and parses markup from a file.\n\t * \n\t * @return The markup\n\t * @throws IOException\n\t * @throws ResourceStreamNotFoundException\n\t */\n\tpublic final Markup parse() throws IOException, ResourceStreamNotFoundException\n\t{\n\t\tMarkupResourceData markupResourceData = this.markup.getMarkupResourceData();\n\t\t\n\t\t// Initialize the xml parser\n\t\tthis.xmlParser.parse(markupResourceData.getResource().getInputStream(), this.markupSettings\n\t\t\t\t.getDefaultMarkupEncoding());\n\n\t\t// parse the xml markup and tokenize it into wicket relevant markup\n\t\t// elements\n\t\tparseMarkup();\n\n\t\tmarkupResourceData.setEncoding(xmlParser.getEncoding());\n\t\tmarkupResourceData.setXmlDeclaration(xmlParser.getXmlDeclaration());\n\n\t\treturn this.markup;\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Create a new markup filter chain and initialize with all default filters\n\t * required.\n\t */\n\tprivate final void initializeMarkupFilters()\n\t{\n\t\t// Chain together all the different markup filters and configure them\n\t\tthis.markupFilterChain = xmlParser;\n\n\t\tappendMarkupFilter(new WicketTagIdentifier(markup));\n\t\tappendMarkupFilter(new TagTypeHandler());\n\t\tappendMarkupFilter(new HtmlHandler());\n\t\tappendMarkupFilter(new WicketRemoveTagHandler());\n\t\tappendMarkupFilter(new WicketLinkTagHandler());\n\t\tappendMarkupFilter(new WicketNamespaceHandler(markup));\n\n\t\t// Provided the wicket component requesting the markup is known ...\n\t\tfinal MarkupResourceStream resource = markup.getResource();\n\t\tif (resource != null)\n\t\t{\n\t\t\tfinal ContainerInfo containerInfo = resource.getContainerInfo();\n\t\t\tif (containerInfo != null)\n\t\t\t{\n\t\t\t\tappendMarkupFilter(new WicketMessageTagHandler());\n\t\t\t\tappendMarkupFilter(new BodyTagHandler());\n\n\t\t\t\t// Pages require additional handlers\n\t\t\t\tif (Page.class.isAssignableFrom(containerInfo.getContainerClass()))\n\t\t\t\t{\n\t\t\t\t\tappendMarkupFilter(new HtmlHeaderSectionHandler(this.markup));\n\t\t\t\t}\n\n\t\t\t\tappendMarkupFilter(new HeadForceTagIdHandler(containerInfo.getContainerClass()));\n\t\t\t}\n\t\t}\n\n\t\tappendMarkupFilter(new PrependContextPathHandler(Application.get()));\n\t\tappendMarkupFilter(new EnclosureHandler());\n\t}","id":42649,"modified_method":"/**\n\t * Create a new markup filter chain and initialize with all default filters\n\t * required.\n\t */\n\tprivate final void initializeMarkupFilters()\n\t{\n\t\t// Chain together all the different markup filters and configure them\n\t\tthis.markupFilterChain = xmlParser;\n\n\t\tMarkupResourceData markupResourceData = this.markup.getMarkupResourceData();\n\t\t\n\t\tappendMarkupFilter(new WicketTagIdentifier(markupResourceData));\n\t\tappendMarkupFilter(new TagTypeHandler());\n\t\tappendMarkupFilter(new HtmlHandler());\n\t\tappendMarkupFilter(new WicketRemoveTagHandler());\n\t\tappendMarkupFilter(new WicketLinkTagHandler());\n\t\tappendMarkupFilter(new WicketNamespaceHandler(markupResourceData));\n\n\t\t// Provided the wicket component requesting the markup is known ...\n\t\tfinal MarkupResourceStream resource = markupResourceData.getResource();\n\t\tif (resource != null)\n\t\t{\n\t\t\tfinal ContainerInfo containerInfo = resource.getContainerInfo();\n\t\t\tif (containerInfo != null)\n\t\t\t{\n\t\t\t\tappendMarkupFilter(new WicketMessageTagHandler());\n\t\t\t\tappendMarkupFilter(new BodyTagHandler());\n\n\t\t\t\t// Pages require additional handlers\n\t\t\t\tif (Page.class.isAssignableFrom(containerInfo.getContainerClass()))\n\t\t\t\t{\n\t\t\t\t\tappendMarkupFilter(new HtmlHeaderSectionHandler(markup));\n\t\t\t\t}\n\n\t\t\t\tappendMarkupFilter(new HeadForceTagIdHandler(containerInfo.getContainerClass()));\n\t\t\t}\n\t\t}\n\n\t\tappendMarkupFilter(new PrependContextPathHandler(Application.get()));\n\t\tappendMarkupFilter(new EnclosureHandler());\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Scans the given markup and extracts balancing tags.\n\t * \n\t */\n\tprivate void parseMarkup()\n\t{\n\t\t// Get relevant settings from the Application\n\t\tfinal boolean stripComments = this.markupSettings.getStripComments();\n\t\tfinal boolean compressWhitespace = this.markupSettings.getCompressWhitespace();\n\n\t\ttry\n\t\t{\n\t\t\t// always remember the latest index (size)\n\t\t\tint size = this.markup.size();\n\n\t\t\t// Loop through tags\n\t\t\tComponentTag tag;\n\t\t\twhile (null != (tag = getNextTag()))\n\t\t\t{\n\t\t\t\tboolean add = (tag.getId() != null);\n\t\t\t\tif (!add && tag.getXmlTag().isClose())\n\t\t\t\t{\n\t\t\t\t\tadd = ((tag.getOpenTag() != null) && (tag.getOpenTag().getId() != null));\n\t\t\t\t}\n\n\t\t\t\t// Add tag to list?\n\t\t\t\tif (add || tag.isModified())\n\t\t\t\t{\n\t\t\t\t\t// Add text from last position to the current tag position\n\t\t\t\t\tfinal CharSequence text = xmlParser.getInputFromPositionMarker(tag.getPos());\n\t\t\t\t\tif (text.length() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tString rawMarkup = text.toString();\n\n\t\t\t\t\t\tif (stripComments)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trawMarkup = removeComment(rawMarkup);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (compressWhitespace)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trawMarkup = compressWhitespace(rawMarkup);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure you add it at the correct location.\n\t\t\t\t\t\t// IMarkupFilters might have added elements as well.\n\t\t\t\t\t\tthis.markup.addMarkupElement(size, new RawMarkup(rawMarkup));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (add)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Add to the markup unless the tag has been flagged as\n\t\t\t\t\t\t// to be removed from the markup. (e.g. <wicket:remove>\n\t\t\t\t\t\tif (tag.isIgnore() == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.markup.addMarkupElement(tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (tag.isModified())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.markup.addMarkupElement(new RawMarkup(tag.toCharSequence()));\n\t\t\t\t\t}\n\n\t\t\t\t\txmlParser.setPositionMarker();\n\t\t\t\t}\n\n\t\t\t\t// always remember the latest index (size)\n\t\t\t\tsize = this.markup.size();\n\t\t\t}\n\t\t}\n\t\tcatch (final ParseException ex)\n\t\t{\n\t\t\t// Add remaining input string\n\t\t\tfinal CharSequence text = xmlParser.getInputFromPositionMarker(-1);\n\t\t\tif (text.length() > 0)\n\t\t\t{\n\t\t\t\tthis.markup.addMarkupElement(new RawMarkup(text));\n\t\t\t}\n\n\t\t\tthis.markup.setEncoding(xmlParser.getEncoding());\n\t\t\tthis.markup.setXmlDeclaration(xmlParser.getXmlDeclaration());\n\n\t\t\tfinal MarkupStream markupStream = new MarkupStream(markup);\n\t\t\tmarkupStream.setCurrentIndex(this.markup.size() - 1);\n\t\t\tthrow new MarkupException(markupStream, ex.getMessage(), ex);\n\t\t}\n\n\t\t// Add tail?\n\t\tfinal CharSequence text = xmlParser.getInputFromPositionMarker(-1);\n\t\tif (text.length() > 0)\n\t\t{\n\t\t\tString rawMarkup = text.toString();\n\n\t\t\tif (stripComments)\n\t\t\t{\n\t\t\t\trawMarkup = removeComment(rawMarkup);\n\t\t\t}\n\n\t\t\tif (compressWhitespace)\n\t\t\t{\n\t\t\t\trawMarkup = compressWhitespace(rawMarkup);\n\t\t\t}\n\n\t\t\t// Make sure you add it at the correct location.\n\t\t\t// IMarkupFilters might have added elements as well.\n\t\t\tthis.markup.addMarkupElement(new RawMarkup(rawMarkup));\n\t\t}\n\n\t\t// Make all tags immutable and the list of elements unmodifable\n\t\tthis.markup.makeImmutable();\n\t}","id":42650,"modified_method":"/**\n\t * Scans the given markup and extracts balancing tags.\n\t * \n\t */\n\tprivate void parseMarkup()\n\t{\n\t\t// Get relevant settings from the Application\n\t\tfinal boolean stripComments = this.markupSettings.getStripComments();\n\t\tfinal boolean compressWhitespace = this.markupSettings.getCompressWhitespace();\n\n\t\ttry\n\t\t{\n\t\t\t// always remember the latest index (size)\n\t\t\tint size = this.markup.size();\n\n\t\t\t// Loop through tags\n\t\t\tComponentTag tag;\n\t\t\twhile (null != (tag = getNextTag()))\n\t\t\t{\n\t\t\t\tboolean add = (tag.getId() != null);\n\t\t\t\tif (!add && tag.getXmlTag().isClose())\n\t\t\t\t{\n\t\t\t\t\tadd = ((tag.getOpenTag() != null) && (tag.getOpenTag().getId() != null));\n\t\t\t\t}\n\n\t\t\t\t// Add tag to list?\n\t\t\t\tif (add || tag.isModified())\n\t\t\t\t{\n\t\t\t\t\t// Add text from last position to the current tag position\n\t\t\t\t\tfinal CharSequence text = xmlParser.getInputFromPositionMarker(tag.getPos());\n\t\t\t\t\tif (text.length() > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tString rawMarkup = text.toString();\n\n\t\t\t\t\t\tif (stripComments)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trawMarkup = removeComment(rawMarkup);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (compressWhitespace)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trawMarkup = compressWhitespace(rawMarkup);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure you add it at the correct location.\n\t\t\t\t\t\t// IMarkupFilters might have added elements as well.\n\t\t\t\t\t\tthis.markup.addMarkupElement(size, new RawMarkup(rawMarkup));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (add)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Add to the markup unless the tag has been flagged as\n\t\t\t\t\t\t// to be removed from the markup. (e.g. <wicket:remove>\n\t\t\t\t\t\tif (tag.isIgnore() == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.markup.addMarkupElement(tag);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (tag.isModified())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.markup.addMarkupElement(new RawMarkup(tag.toCharSequence()));\n\t\t\t\t\t}\n\n\t\t\t\t\txmlParser.setPositionMarker();\n\t\t\t\t}\n\n\t\t\t\t// always remember the latest index (size)\n\t\t\t\tsize = this.markup.size();\n\t\t\t}\n\t\t}\n\t\tcatch (final ParseException ex)\n\t\t{\n\t\t\t// Add remaining input string\n\t\t\tfinal CharSequence text = xmlParser.getInputFromPositionMarker(-1);\n\t\t\tif (text.length() > 0)\n\t\t\t{\n\t\t\t\tthis.markup.addMarkupElement(new RawMarkup(text));\n\t\t\t}\n\n\t\t\tthis.markup.getMarkupResourceData().setEncoding(xmlParser.getEncoding());\n\t\t\tthis.markup.getMarkupResourceData().setXmlDeclaration(xmlParser.getXmlDeclaration());\n\n\t\t\tfinal MarkupStream markupStream = new MarkupStream(this.markup);\n\t\t\tmarkupStream.setCurrentIndex(this.markup.size() - 1);\n\t\t\tthrow new MarkupException(markupStream, ex.getMessage(), ex);\n\t\t}\n\n\t\t// Add tail?\n\t\tfinal CharSequence text = xmlParser.getInputFromPositionMarker(-1);\n\t\tif (text.length() > 0)\n\t\t{\n\t\t\tString rawMarkup = text.toString();\n\n\t\t\tif (stripComments)\n\t\t\t{\n\t\t\t\trawMarkup = removeComment(rawMarkup);\n\t\t\t}\n\n\t\t\tif (compressWhitespace)\n\t\t\t{\n\t\t\t\trawMarkup = compressWhitespace(rawMarkup);\n\t\t\t}\n\n\t\t\t// Make sure you add it at the correct location.\n\t\t\t// IMarkupFilters might have added elements as well.\n\t\t\tthis.markup.addMarkupElement(new RawMarkup(rawMarkup));\n\t\t}\n\n\t\t// Make all tags immutable and the list of elements unmodifable\n\t\tthis.markup.makeImmutable();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The resource where this markup stream came from\n\t */\n\tpublic IResourceStream getResource()\n\t{\n\t\treturn markup.getResource();\n\t}","id":42651,"modified_method":"/**\n\t * @return The resource where this markup stream came from\n\t */\n\tpublic IResourceStream getResource()\n\t{\n\t\treturn markup.getMarkupResourceData().getResource();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * DO NOT YOU THIS CONSTRUCTOR. IT WILL MOST LIKELY BE REPLACED IN THE NEAR\n\t * FUTURE.\n\t */\n\tprotected MarkupStream()\n\t{\n\t\tmarkup = null;\n\t}","id":42652,"modified_method":"/**\n\t * DO NOT YOU THIS CONSTRUCTOR. IT WILL MOST LIKELY BE REPLACED IN THE NEAR\n\t * FUTURE.\n\t */\n\tprotected MarkupStream()\n\t{\n\t\tthis.markup = null;\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the component/container's Class which is directly associated with the\n\t * stream.\n\t * \n\t * @return The component's class\n\t */\n\tpublic final Class getContainerClass()\n\t{\n\t\treturn markup.getResource().getMarkupClass();\n\t}","id":42653,"modified_method":"/**\n\t * Get the component/container's Class which is directly associated with the\n\t * stream.\n\t * \n\t * @return The component's class\n\t */\n\tpublic final Class getContainerClass()\n\t{\n\t\treturn markup.getMarkupResourceData().getResource().getMarkupClass();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the markup encoding. A markup encoding may be specified in a markup\n\t * file with an XML encoding specifier of the form &lt;?xml ...\n\t * encoding=\"...\" ?&gt;.\n\t * \n\t * @return The encoding, or null if not found\n\t */\n\tpublic final String getEncoding()\n\t{\n\t\treturn markup.getEncoding();\n\t}","id":42654,"modified_method":"/**\n\t * Gets the markup encoding. A markup encoding may be specified in a markup\n\t * file with an XML encoding specifier of the form &lt;?xml ...\n\t * encoding=\"...\" ?&gt;.\n\t * \n\t * @return The encoding, or null if not found\n\t */\n\tpublic final String getEncoding()\n\t{\n\t\treturn markup.getMarkupResourceData().getEncoding();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param markup\n\t *            List of markup elements\n\t */\n\tpublic MarkupStream(final Markup markup)\n\t{\n\t\tthis.markup = markup;\n\n\t\tif (markup.size() > 0)\n\t\t{\n\t\t\tcurrent = get(currentIndex);\n\t\t}\n\t}","id":42655,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param markupFragment\n\t *            List of markup elements\n\t */\n\tpublic MarkupStream(final Markup markupFragment)\n\t{\n\t\tthis.markup = markupFragment;\n\n\t\tif (markupFragment.size() > 0)\n\t\t{\n\t\t\tcurrent = get(currentIndex);\n\t\t}\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Return the XML declaration string, in case if found in the markup.\n\t * \n\t * @return Null, if not found.\n\t */\n\tpublic String getXmlDeclaration()\n\t{\n\t\treturn markup.getXmlDeclaration();\n\t}","id":42656,"modified_method":"/**\n\t * Return the XML declaration string, in case if found in the markup.\n\t * \n\t * @return Null, if not found.\n\t */\n\tpublic String getXmlDeclaration()\n\t{\n\t\treturn markup.getMarkupResourceData().getXmlDeclaration();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the wicket namespace valid for this specific markup\n\t * \n\t * @return wicket namespace\n\t */\n\tpublic final String getWicketNamespace()\n\t{\n\t\treturn this.markup.getWicketNamespace();\n\t}","id":42657,"modified_method":"/**\n\t * Get the wicket namespace valid for this specific markup\n\t * \n\t * @return wicket namespace\n\t */\n\tpublic final String getWicketNamespace()\n\t{\n\t\treturn markup.getMarkupResourceData().getWicketNamespace();\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Merge inherited and base markup.\n\t * \n\t * @param markup\n\t *            The inherited markup\n\t * @param baseMarkup\n\t *            The base markup\n\t * @param extendIndex\n\t *            Index where <wicket:extend> has been found\n\t */\n\tprivate void merge(final Markup markup, final Markup baseMarkup, int extendIndex)\n\t{\n\t\t// True if either <wicket:head> or <head> has been processed\n\t\tboolean wicketHeadProcessed = false;\n\n\t\t// Add all elements from the base markup to the new list\n\t\t// until <wicket:child/> is found. Convert <wicket:child/>\n\t\t// into <wicket:child> and add it as well.\n\t\tWicketTag childTag = null;\n\t\tint baseIndex = 0;\n\t\tfor (; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\tif (element instanceof RawMarkup)\n\t\t\t{\n\t\t\t\t// Add the element to the merged list\n\t\t\t\taddMarkupElement(element);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal ComponentTag tag = (ComponentTag)element;\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((baseMarkup.getResource() != null) && (tag.getMarkupClass() == null))\n\t\t\t{\n\t\t\t\ttag.setMarkupClass(baseMarkup.getResource().getMarkupClass());\n\t\t\t}\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\n\t\t\t\t// Found org.apache.wicket.child in base markup. In case of 3+ level\n\t\t\t\t// inheritance make sure the child tag is not from one of the\n\t\t\t\t// deeper levels\n\t\t\t\tif (wtag.isChildTag()\n\t\t\t\t\t\t&& (tag.getMarkupClass() == baseMarkup.getResource().getMarkupClass()))\n\t\t\t\t{\n\t\t\t\t\tif (wtag.isOpenClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child /> => <wicket:child>...<\/wicket:child>\n\t\t\t\t\t\tchildTag = wtag;\n\t\t\t\t\t\tWicketTag childOpenTag = (WicketTag)wtag.mutable();\n\t\t\t\t\t\tchildOpenTag.getXmlTag().setType(XmlTag.OPEN);\n\t\t\t\t\t\tchildOpenTag.setMarkupClass(baseMarkup.getResource().getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(childOpenTag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (wtag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child>\n\t\t\t\t\t\taddMarkupElement(wtag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Did not expect a <\/wicket:child> tag in \"\n\t\t\t\t\t\t\t\t+ baseMarkup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Process the head of the extended markup only once\n\t\t\t\tif (wicketHeadProcessed == false)\n\t\t\t\t{\n\t\t\t\t\t// if <\/wicket:head> in base markup\n\t\t\t\t\tif (wtag.isClose() && wtag.isHeadTag())\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the current close tag\n\t\t\t\t\t\taddMarkupElement(wtag);\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\n\t\t\t\t\t\t// Do not add the current tag. It has already been\n\t\t\t\t\t\t// added.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if <wicket:panel> or ... in base markup\n\t\t\t\t\tif (wtag.isOpen() && wtag.isMajorWicketComponentTag())\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process the head of the extended markup only once\n\t\t\tif (wicketHeadProcessed == false)\n\t\t\t{\n\t\t\t\t// if <head> in base markup\n\t\t\t\tif ((tag.isClose() && TagUtils.isHeadTag(tag))\n\t\t\t\t\t\t|| (tag.isOpen() && TagUtils.isBodyTag(tag)))\n\t\t\t\t{\n\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the element to the merged list\n\t\t\taddMarkupElement(element);\n\t\t}\n\n\t\tif (baseIndex == baseMarkup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Expected to find <wicket:child/> in base markup: \"\n\t\t\t\t\t+ baseMarkup.toString());\n\t\t}\n\n\t\t// Now append all elements from the derived markup starting with\n\t\t// <wicket:extend> until <\/wicket:extend> to the list\n\t\tfor (; extendIndex < markup.size(); extendIndex++)\n\t\t{\n\t\t\tMarkupElement element = markup.get(extendIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\t\t\t\tif (wtag.isExtendTag() && wtag.isClose())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (extendIndex == markup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"Missing close tag <\/wicket:extend> in derived markup: \" + markup.toString());\n\t\t}\n\n\t\t// If <wicket:child> than skip the body and find <\/wicket:child>\n\t\tif (((ComponentTag)baseMarkup.get(baseIndex)).isOpen())\n\t\t{\n\t\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t\t{\n\t\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\t\tif (element instanceof WicketTag)\n\t\t\t\t{\n\t\t\t\t\tWicketTag tag = (WicketTag)element;\n\t\t\t\t\tif (tag.isChildTag() && tag.isClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Ok, skipped the childs content\n\t\t\t\t\t\ttag.setMarkupClass(baseMarkup.getResource().getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(tag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\t\"Wicket tags like <wicket:xxx> are not allowed in between <wicket:child> and <\/wicket:child> tags: \"\n\t\t\t\t\t\t\t\t\t\t+ markup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (element instanceof ComponentTag)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Wicket tags identified by wicket:id are not allowed in between <wicket:child> and <\/wicket:child> tags: \"\n\t\t\t\t\t\t\t\t\t+ markup.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// <\/wicket:child> not found\n\t\t\tif (baseIndex == baseMarkup.size())\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"Expected to find <\/wicket:child> in base markup: \" + baseMarkup.toString());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// And now all remaining elements from the derived markup.\n\t\t\t// But first add <\/wicket:child>\n\t\t\tWicketTag childCloseTag = (WicketTag)childTag.mutable();\n\t\t\tchildCloseTag.getXmlTag().setType(XmlTag.CLOSE);\n\t\t\tchildCloseTag.setMarkupClass(baseMarkup.getResource().getMarkupClass());\n\t\t\taddMarkupElement(childCloseTag);\n\t\t}\n\t\t\n\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((element instanceof ComponentTag) && (baseMarkup.getResource() != null))\n\t\t\t{\n\t\t\t\tComponentTag tag = (ComponentTag)element;\n\t\t\t\ttag.setMarkupClass(baseMarkup.getResource().getMarkupClass());\n\t\t\t}\n\t\t}\n\n\t\t// Automatically add <head> if missing and required. On a Page\n\t\t// it must enclose ALL of the <wicket:head> tags.\n\t\t// Note: HtmlHeaderSectionHandler does something similar, but because\n\t\t// markup filters are not called for merged markup again, ...\n\t\tif (Page.class.isAssignableFrom(markup.getResource().getMarkupClass()))\n\t\t{\n\t\t\t// Find the position inside the markup for first <wicket:head>,\n\t\t\t// last <\/wicket:head> and <head>\n\t\t\tint hasOpenWicketHead = -1;\n\t\t\tint hasCloseWicketHead = -1;\n\t\t\tint hasHead = -1;\n\t\t\tfor (int i = 0; i < size(); i++)\n\t\t\t{\n\t\t\t\tMarkupElement element = get(i);\n\n\t\t\t\tif ((hasOpenWicketHead == -1) && (element instanceof WicketTag)\n\t\t\t\t\t\t&& ((WicketTag)element).isHeadTag())\n\t\t\t\t{\n\t\t\t\t\thasOpenWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((element instanceof WicketTag) && ((WicketTag)element).isHeadTag()\n\t\t\t\t\t\t&& ((WicketTag)element).isClose())\n\t\t\t\t{\n\t\t\t\t\thasCloseWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead == -1) && (element instanceof ComponentTag)\n\t\t\t\t\t\t&& TagUtils.isHeadTag((ComponentTag)element))\n\t\t\t\t{\n\t\t\t\t\thasHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead != -1) && (hasOpenWicketHead != -1))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a <head> tag is missing, insert it automatically\n\t\t\tif ((hasOpenWicketHead != -1) && (hasHead == -1))\n\t\t\t{\n\t\t\t\tfinal XmlTag headOpenTag = new XmlTag();\n\t\t\t\theadOpenTag.setName(\"head\");\n\t\t\t\theadOpenTag.setType(XmlTag.OPEN);\n\t\t\t\tfinal ComponentTag openTag = new ComponentTag(headOpenTag);\n\t\t\t\topenTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\n\t\t\t\tfinal XmlTag headCloseTag = new XmlTag();\n\t\t\t\theadCloseTag.setName(headOpenTag.getName());\n\t\t\t\theadCloseTag.setType(XmlTag.CLOSE);\n\t\t\t\tfinal ComponentTag closeTag = new ComponentTag(headCloseTag);\n\t\t\t\tcloseTag.setOpenTag(openTag);\n\t\t\t\tcloseTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\n\t\t\t\taddMarkupElement(hasOpenWicketHead, openTag);\n\t\t\t\taddMarkupElement(hasCloseWicketHead + 2, closeTag);\n\t\t\t}\n\t\t}\n\t}","id":42658,"modified_method":"/**\n\t * Merge inherited and base markup.\n\t * \n\t * @param markup\n\t *            The inherited markup\n\t * @param baseMarkup\n\t *            The base markup\n\t * @param extendIndex\n\t *            Index where <wicket:extend> has been found\n\t */\n\tprivate void merge(final Markup markup, final Markup baseMarkup, int extendIndex)\n\t{\n\t\t// True if either <wicket:head> or <head> has been processed\n\t\tboolean wicketHeadProcessed = false;\n\n\t\t// Add all elements from the base markup to the new list\n\t\t// until <wicket:child/> is found. Convert <wicket:child/>\n\t\t// into <wicket:child> and add it as well.\n\t\tWicketTag childTag = null;\n\t\tint baseIndex = 0;\n\t\tfor (; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\tif (element instanceof RawMarkup)\n\t\t\t{\n\t\t\t\t// Add the element to the merged list\n\t\t\t\taddMarkupElement(element);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal ComponentTag tag = (ComponentTag)element;\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((baseMarkup.getMarkupResourceData().getResource() != null) && (tag.getMarkupClass() == null))\n\t\t\t{\n\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());\n\t\t\t}\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\n\t\t\t\t// Found org.apache.wicket.child in base markup. In case of 3+ level\n\t\t\t\t// inheritance make sure the child tag is not from one of the\n\t\t\t\t// deeper levels\n\t\t\t\tif (wtag.isChildTag()\n\t\t\t\t\t\t&& (tag.getMarkupClass() == baseMarkup.getMarkupResourceData().getResource().getMarkupClass()))\n\t\t\t\t{\n\t\t\t\t\tif (wtag.isOpenClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child /> => <wicket:child>...<\/wicket:child>\n\t\t\t\t\t\tchildTag = wtag;\n\t\t\t\t\t\tWicketTag childOpenTag = (WicketTag)wtag.mutable();\n\t\t\t\t\t\tchildOpenTag.getXmlTag().setType(XmlTag.OPEN);\n\t\t\t\t\t\tchildOpenTag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(childOpenTag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (wtag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\t// <wicket:child>\n\t\t\t\t\t\taddMarkupElement(wtag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Did not expect a <\/wicket:child> tag in \"\n\t\t\t\t\t\t\t\t+ baseMarkup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Process the head of the extended markup only once\n\t\t\t\tif (wicketHeadProcessed == false)\n\t\t\t\t{\n\t\t\t\t\t// if <\/wicket:head> in base markup\n\t\t\t\t\tif (wtag.isClose() && wtag.isHeadTag())\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the current close tag\n\t\t\t\t\t\taddMarkupElement(wtag);\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\n\t\t\t\t\t\t// Do not add the current tag. It has already been\n\t\t\t\t\t\t// added.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if <wicket:panel> or ... in base markup\n\t\t\t\t\tif (wtag.isOpen() && wtag.isMajorWicketComponentTag())\n\t\t\t\t\t{\n\t\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process the head of the extended markup only once\n\t\t\tif (wicketHeadProcessed == false)\n\t\t\t{\n\t\t\t\t// if <head> in base markup\n\t\t\t\tif ((tag.isClose() && TagUtils.isHeadTag(tag))\n\t\t\t\t\t\t|| (tag.isOpen() && TagUtils.isBodyTag(tag)))\n\t\t\t\t{\n\t\t\t\t\twicketHeadProcessed = true;\n\n\t\t\t\t\t// Add the <wicket:head> body from the derived markup.\n\t\t\t\t\tcopyWicketHead(markup, extendIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the element to the merged list\n\t\t\taddMarkupElement(element);\n\t\t}\n\n\t\tif (baseIndex == baseMarkup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\"Expected to find <wicket:child/> in base markup: \"\n\t\t\t\t\t+ baseMarkup.toString());\n\t\t}\n\n\t\t// Now append all elements from the derived markup starting with\n\t\t// <wicket:extend> until <\/wicket:extend> to the list\n\t\tfor (; extendIndex < markup.size(); extendIndex++)\n\t\t{\n\t\t\tMarkupElement element = markup.get(extendIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\tif (element instanceof WicketTag)\n\t\t\t{\n\t\t\t\tWicketTag wtag = (WicketTag)element;\n\t\t\t\tif (wtag.isExtendTag() && wtag.isClose())\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (extendIndex == markup.size())\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"Missing close tag <\/wicket:extend> in derived markup: \" + markup.toString());\n\t\t}\n\n\t\t// If <wicket:child> than skip the body and find <\/wicket:child>\n\t\tif (((ComponentTag)baseMarkup.get(baseIndex)).isOpen())\n\t\t{\n\t\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t\t{\n\t\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\t\tif (element instanceof WicketTag)\n\t\t\t\t{\n\t\t\t\t\tWicketTag tag = (WicketTag)element;\n\t\t\t\t\tif (tag.isChildTag() && tag.isClose())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Ok, skipped the childs content\n\t\t\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());\n\t\t\t\t\t\taddMarkupElement(tag);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\t\"Wicket tags like <wicket:xxx> are not allowed in between <wicket:child> and <\/wicket:child> tags: \"\n\t\t\t\t\t\t\t\t\t\t+ markup.toString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (element instanceof ComponentTag)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"Wicket tags identified by wicket:id are not allowed in between <wicket:child> and <\/wicket:child> tags: \"\n\t\t\t\t\t\t\t\t\t+ markup.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// <\/wicket:child> not found\n\t\t\tif (baseIndex == baseMarkup.size())\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"Expected to find <\/wicket:child> in base markup: \" + baseMarkup.toString());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// And now all remaining elements from the derived markup.\n\t\t\t// But first add <\/wicket:child>\n\t\t\tWicketTag childCloseTag = (WicketTag)childTag.mutable();\n\t\t\tchildCloseTag.getXmlTag().setType(XmlTag.CLOSE);\n\t\t\tchildCloseTag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());\n\t\t\taddMarkupElement(childCloseTag);\n\t\t}\n\t\t\n\t\tfor (baseIndex++; baseIndex < baseMarkup.size(); baseIndex++)\n\t\t{\n\t\t\tMarkupElement element = baseMarkup.get(baseIndex);\n\t\t\taddMarkupElement(element);\n\n\t\t\t// Make sure all tags of the base markup remember where they are\n\t\t\t// from\n\t\t\tif ((element instanceof ComponentTag) && (baseMarkup.getMarkupResourceData().getResource() != null))\n\t\t\t{\n\t\t\t\tComponentTag tag = (ComponentTag)element;\n\t\t\t\ttag.setMarkupClass(baseMarkup.getMarkupResourceData().getResource().getMarkupClass());\n\t\t\t}\n\t\t}\n\n\t\t// Automatically add <head> if missing and required. On a Page\n\t\t// it must enclose ALL of the <wicket:head> tags.\n\t\t// Note: HtmlHeaderSectionHandler does something similar, but because\n\t\t// markup filters are not called for merged markup again, ...\n\t\tif (Page.class.isAssignableFrom(markup.getMarkupResourceData().getResource().getMarkupClass()))\n\t\t{\n\t\t\t// Find the position inside the markup for first <wicket:head>,\n\t\t\t// last <\/wicket:head> and <head>\n\t\t\tint hasOpenWicketHead = -1;\n\t\t\tint hasCloseWicketHead = -1;\n\t\t\tint hasHead = -1;\n\t\t\tfor (int i = 0; i < size(); i++)\n\t\t\t{\n\t\t\t\tMarkupElement element = get(i);\n\n\t\t\t\tif ((hasOpenWicketHead == -1) && (element instanceof WicketTag)\n\t\t\t\t\t\t&& ((WicketTag)element).isHeadTag())\n\t\t\t\t{\n\t\t\t\t\thasOpenWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((element instanceof WicketTag) && ((WicketTag)element).isHeadTag()\n\t\t\t\t\t\t&& ((WicketTag)element).isClose())\n\t\t\t\t{\n\t\t\t\t\thasCloseWicketHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead == -1) && (element instanceof ComponentTag)\n\t\t\t\t\t\t&& TagUtils.isHeadTag((ComponentTag)element))\n\t\t\t\t{\n\t\t\t\t\thasHead = i;\n\t\t\t\t}\n\t\t\t\telse if ((hasHead != -1) && (hasOpenWicketHead != -1))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a <head> tag is missing, insert it automatically\n\t\t\tif ((hasOpenWicketHead != -1) && (hasHead == -1))\n\t\t\t{\n\t\t\t\tfinal XmlTag headOpenTag = new XmlTag();\n\t\t\t\theadOpenTag.setName(\"head\");\n\t\t\t\theadOpenTag.setType(XmlTag.OPEN);\n\t\t\t\tfinal ComponentTag openTag = new ComponentTag(headOpenTag);\n\t\t\t\topenTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\n\t\t\t\tfinal XmlTag headCloseTag = new XmlTag();\n\t\t\t\theadCloseTag.setName(headOpenTag.getName());\n\t\t\t\theadCloseTag.setType(XmlTag.CLOSE);\n\t\t\t\tfinal ComponentTag closeTag = new ComponentTag(headCloseTag);\n\t\t\t\tcloseTag.setOpenTag(openTag);\n\t\t\t\tcloseTag.setId(HtmlHeaderSectionHandler.HEADER_ID);\n\n\t\t\t\taddMarkupElement(hasOpenWicketHead, openTag);\n\t\t\t\taddMarkupElement(hasCloseWicketHead + 2, closeTag);\n\t\t\t}\n\t\t}\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Merge inherited and base markup.\n\t * \n\t * @param markup\n\t *            The inherited markup\n\t * @param baseMarkup\n\t *            The base markup\n\t * @param extendIndex\n\t *            Index where <wicket:extend> has been found\n\t */\n\tMergedMarkup(final Markup markup, final Markup baseMarkup, int extendIndex)\n\t{\n\t\t// Copy settings from derived markup\n\t\tsetResource(markup.getResource());\n\t\tsetXmlDeclaration(markup.getXmlDeclaration());\n\t\tsetEncoding(markup.getEncoding());\n\t\tsetWicketNamespace(markup.getWicketNamespace());\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tString derivedResource = Strings.afterLast(markup.getResource().toString(), '/');\n\t\t\tString baseResource = Strings.afterLast(baseMarkup.getResource().toString(), '/');\n\t\t\tlog.debug(\"Merge markup: derived markup: \" + derivedResource + \"; base markup: \"\n\t\t\t\t\t+ baseResource);\n\t\t}\n\n\t\t// Merge derived and base markup\n\t\tmerge(markup, baseMarkup, extendIndex);\n\n\t\t// Initialize internals based on new markup\n\t\tinitialize();\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"Merge markup: \" + toDebugString());\n\t\t}\n\t}","id":42659,"modified_method":"/**\n\t * Merge inherited and base markup.\n\t * \n\t * @param markup\n\t *            The inherited markup\n\t * @param baseMarkup\n\t *            The base markup\n\t * @param extendIndex\n\t *            Index where <wicket:extend> has been found\n\t */\n\tMergedMarkup(final Markup markup, final Markup baseMarkup, int extendIndex)\n\t{\n\t\tsuper(new MarkupResourceData());\n\t\t\n\t\t// Copy settings from derived markup\n\t\tgetMarkupResourceData().setResource(markup.getMarkupResourceData().getResource());\n\t\tgetMarkupResourceData().setXmlDeclaration(markup.getMarkupResourceData().getXmlDeclaration());\n\t\tgetMarkupResourceData().setEncoding(markup.getMarkupResourceData().getEncoding());\n\t\tgetMarkupResourceData().setWicketNamespace(markup.getMarkupResourceData().getWicketNamespace());\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tString derivedResource = Strings.afterLast(markup.getMarkupResourceData().getResource().toString(), '/');\n\t\t\tString baseResource = Strings.afterLast(baseMarkup.getMarkupResourceData().getResource().toString(), '/');\n\t\t\tlog.debug(\"Merge markup: derived markup: \" + derivedResource + \"; base markup: \"\n\t\t\t\t\t+ baseResource);\n\t\t}\n\n\t\t// Merge derived and base markup\n\t\tmerge(markup, baseMarkup, extendIndex);\n\n\t\t// Initialize internals based on new markup\n//\t\tinitialize();\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"Merge markup: \" + toString());\n\t\t}\n\t}","commit_id":"07f8689e12562d48f143cdc0dbe703c7cec14d9f","url":"https://github.com/apache/wicket"},{"original_method":"private static LWNode createNodeFromResource(com.hp.hpl.jena.rdf.model.Resource r) {\n\n        tufts.vue.Resource resource = null;\n        try\n        {\n            resource = tufts.vue.Resource.getFactory().get(r.getURI());\n            //resource = new MapResource(r.getURI());\n        }\n        catch(Error err)\n        {\n          System.out.println(\"Error in creation of Map Resource: \" + err);\n        }\n        \n        LWNode node = new LWNode(\"Empty\");\n        if(resource == null)\n        {\n          node = new LWNode(\"Resource Error\");\n        }\n        else\n        {\n          node = new LWNode(r.getURI());\n          node.setResource(resource);\n        }\n        placeNode(node);\n        //double angle = Math.random()*Math.PI*4;\n        //node.setLocation(200+200*Math.cos(angle),200+200*Math.sin(angle));\n        return node;\n    }","id":42660,"modified_method":"private static LWNode createNodeFromResource(com.hp.hpl.jena.rdf.model.Resource r) {\n\n        tufts.vue.Resource resource = null;\n        try\n        {\n            resource = tufts.vue.Resource.getFactory().get(r.getURI());\n            //resource = new MapResource(r.getURI());\n        }\n        catch(Error err)\n        {\n          System.out.println(\"Error in creation of Map Resource: \" + err);\n        }\n        \n        LWNode node = new LWNode(\"Empty\");\n        if(resource == null)\n        {\n          node = new LWNode(\"Resource Error\");\n        }\n        else\n        {\n          \n          String labelDisplay = VueResources.getString(\"rdf.import.displayType\");\n          \n          if(labelDisplay.equals(\"LABEL\"))\n          {    \n            edu.tufts.vue.rdf.RDFIndex index = new edu.tufts.vue.rdf.RDFIndex();\n            com.hp.hpl.jena.rdf.model.Property labelOf = index.createProperty(edu.tufts.vue.rdf.RDFIndex.VUE_ONTOLOGY,edu.tufts.vue.metadata.Constants.LABEL);\n            node = new LWNode(r.getProperty(labelOf).getString());\n          }\n          else\n          {\n            node = new LWNode(r.getURI());  \n          }    \n          node.setResource(resource);\n        }\n        placeNode(node);\n        //double angle = Math.random()*Math.PI*4;\n        //node.setLocation(200+200*Math.cos(angle),200+200*Math.sin(angle));\n        return node;\n    }","commit_id":"ea7fb5cccf27283a0c8af744913e70467f17161d","url":"https://github.com/VUE/VUE"},{"original_method":"public void setResource(Resource r)\n    {\n        super.setResource(r);\n        if (getChild(0) instanceof LWImage) {\n            LWImage image = (LWImage) getChild(0);\n            if (image.isNodeIcon())\n                image.setResource(r);\n        }\n    }","id":42661,"modified_method":"public void setResource(Resource r)\n    {\n        super.setResource(r);\n        if (r == null || mXMLRestoreUnderway)\n            return;\n        if (getChild(0) instanceof LWImage) {\n            LWImage image = (LWImage) getChild(0);\n            if (image.isNodeIcon() && image.getResource() != null && !image.getResource().equals(getResource())) {\n                // above hack: image resource will be null while being created in MapDropTarget\n                image.setResource(r);\n            }\n        } else if (r.isImage()) {\n            final LWImage imageIcon = new LWImage();\n            addChild(imageIcon);\n            sendToBack(imageIcon);\n            // set resource last so picks update node-icon status reliably:\n            imageIcon.setResource(r);\n        }\n    }","commit_id":"ff7f52b1f01a21435f1006734f3f2ff308390e00","url":"https://github.com/VUE/VUE"},{"original_method":"@Test\n    @Ignore(\"takes a long time, just did this to make sure 'upgrades' would not bomb\")\n    public void testUpdateTwice() throws Exception {\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.migrate(m_migration);\n        m.migrate(m_migration);\n    }","id":42662,"modified_method":"@Test\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testUpdateTwice() throws Exception {\n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.migrate(migration);\n        m.migrate(migration);\n    }","commit_id":"89475af596217ecebfbd2a88c85acc6b4d0a35c8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testUpdate() throws Exception {\n        Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        m.prepareDatabase(m_migration);\n        m.migrate(m_migration);\n\n        Connection conn = null;\n        try {\n            conn = m_dataSource.getConnection();\n\n            Set<String> tables = new HashSet<String>();\n            ResultSet rs = conn.getMetaData().getTables(null, null, \"%\", null);\n            while (rs.next()) {\n                tables.add(rs.getString(\"TABLE_NAME\").toLowerCase());\n            }\n            assertTrue(\"must contain table 'alarms'\", tables.contains(\"alarms\"));\n\n            Set<String> procs = new HashSet<String>();\n            rs = conn.getMetaData().getProcedures(null, null, \"%\");\n            while (rs.next()) {\n                procs.add(rs.getString(\"PROCEDURE_NAME\").toLowerCase());\n            }\n            System.err.println(\"procs = \" + procs);\n            assertTrue(\"must have stored procedure 'setSnmpInterfaceKeysOnUpdate'\", procs.contains(\"setsnmpinterfacekeysonupdate\"));\n        } finally {\n            if (conn != null) {\n                conn.close();\n            }\n        }\n    }","id":42663,"modified_method":"@Test\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testUpdate() throws Exception {\n        // Make sure there is no databasechangelog table\n        assertFalse(changelogExists());\n\n        Resource aResource = null;\n        for (final Resource resource : m_context.getResources(\"classpath*:/changelog.xml\")) {\n            if (resource.getURI().toString().contains(\"test-api.schema.a\")) {\n                aResource = resource;\n            }\n        }\n\n        Set<String> tables = getTables();\n        assertFalse(\"must not contain table 'schematest'\", tables.contains(\"schematest\"));\n        \n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n        migration.setAccessor(new ExistingResourceAccessor(aResource));\n\n        LogUtils.infof(this, \"Running migration on database: %s\", migration.toString());\n\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        m.prepareDatabase(migration);\n        m.migrate(migration);\n\n        LogUtils.infof(this, \"Migration complete: %s\", migration.toString());\n\n        tables = getTables();\n        assertTrue(\"must contain table 'schematest'\", tables.contains(\"schematest\"));\n    }","commit_id":"89475af596217ecebfbd2a88c85acc6b4d0a35c8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testMultipleChangelogs() throws Exception {\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n\n        for (final Resource resource : m_context.getResources(\"classpath*:/changelog.xml\")) {\n            System.err.println(\"=== found resource: \" + resource + \" ===\");\n            migration.setAccessor(new ExistingResourceAccessor(resource));\n            m.migrate(migration);\n        }\n\n        final Connection connection = m_dataSource.getConnection();\n        final PreparedStatement statement = connection.prepareStatement(\"SELECT id FROM databasechangelog\");\n        assertTrue(statement.execute());\n        final ResultSet rs = statement.getResultSet();\n        final List<String> ids = new ArrayList<String>();\n        while (rs.next()) {\n            ids.add(rs.getString(1));\n        }\n        \n        assertTrue(ids.size() > 0);\n        assertTrue(ids.contains(\"test-api.schema.a\"));\n        assertTrue(ids.contains(\"test-api.schema.b\"));\n    }","id":42664,"modified_method":"@Test\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testMultipleChangelogs() throws Exception {\n        // Make sure there is no databasechangelog table\n        Connection connection = m_dataSource.getConnection();\n        try {\n            PreparedStatement statement = connection.prepareStatement(\"SELECT id FROM databasechangelog\");\n            statement.execute();\n            Assert.fail(\"databasechangelog exists\");\n        } catch (SQLException e) {\n        } finally {\n            connection.close();\n        }\n\n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        // Add a resource accessor to the migration so that it will load multiple changelog.xml files\n        // from the classpath\n        for (final Resource resource : m_context.getResources(\"classpath*:/changelog.xml\")) {\n            LogUtils.infof(this, \"=== found resource: \" + resource + \" ===\");\n            migration.setAccessor(new ExistingResourceAccessor(resource));\n            m.migrate(migration);\n        }\n\n        connection = m_dataSource.getConnection();\n        PreparedStatement statement = connection.prepareStatement(\"SELECT id FROM databasechangelog\");\n        assertTrue(statement.execute());\n        ResultSet rs = statement.getResultSet();\n        List<String> ids = new ArrayList<String>();\n        while (rs.next()) {\n            ids.add(rs.getString(1));\n        }\n\n        assertTrue(ids.size() > 0);\n        assertTrue(ids.contains(\"test-api.schema.a\"));\n        assertTrue(ids.contains(\"test-api.schema.b\"));\n    }","commit_id":"89475af596217ecebfbd2a88c85acc6b4d0a35c8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging();\n\n        m_migration = new Migration();\n        m_migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        m_migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        m_migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        m_migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        m_migration.setChangeLog(\"changelog.xml\");\n    }","id":42665,"modified_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging();\n    }","commit_id":"89475af596217ecebfbd2a88c85acc6b4d0a35c8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setupLogging<\/p>\n     *\n     * @param toConsole a boolean.\n     * @param level a {@link java.lang.String} object.\n     * @param config a {@link java.util.Properties} object.\n     */\n    public static void setupLogging(final boolean toConsole, final String level, final Properties config) {\n        resetLogLevel();\n        \n        final Properties logConfig = new Properties(config);\n        final String consoleAppender = (toConsole ? \", CONSOLE\" : \"\");\n        \n        setProperty(logConfig, \"log4j.appender.CONSOLE\", \"org.apache.log4j.ConsoleAppender\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout.ConversionPattern\", \"%d %-5p [%t] %c: %m%n\");\n        setProperty(logConfig, \"log4j.appender.MOCK\", MockLogAppender.class.getName());\n        setProperty(logConfig, \"log4j.appender.MOCK.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.MOCK.layout.ConversionPattern\", \"%-5p [%t] %c: %m%n\");\n\n        setProperty(logConfig, \"log4j.rootCategory\", level + consoleAppender + \", MOCK\");\n        setProperty(logConfig, \"log4j.logger.org.apache.commons.httpclient.HttpMethodBase\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.exolab.castor\", \"INFO\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j.agent\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.com.mchange.v2.c3p0.impl\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.hibernate.cfg.AnnotationBinder\", \"ERROR\" + consoleAppender + \", MOCK\");\n        \n        PropertyConfigurator.configure(logConfig);\n    }","id":42666,"modified_method":"/**\n     * <p>setupLogging<\/p>\n     *\n     * @param toConsole a boolean.\n     * @param level a {@link java.lang.String} object.\n     * @param config a {@link java.util.Properties} object.\n     */\n    public static void setupLogging(final boolean toConsole, final String level, final Properties config) {\n        resetLogLevel();\n        \n        final Properties logConfig = new Properties(config);\n        final String consoleAppender = (toConsole ? \", CONSOLE\" : \"\");\n        \n        setProperty(logConfig, \"log4j.appender.CONSOLE\", \"org.apache.log4j.ConsoleAppender\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout.ConversionPattern\", \"%d %-5p [%t] %c: %m%n\");\n        setProperty(logConfig, \"log4j.appender.MOCK\", MockLogAppender.class.getName());\n        setProperty(logConfig, \"log4j.appender.MOCK.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.MOCK.layout.ConversionPattern\", \"%-5p [%t] %c: %m%n\");\n\n        setProperty(logConfig, \"log4j.rootCategory\", level + consoleAppender + \", MOCK\");\n        setProperty(logConfig, \"log4j.logger.org.apache.commons.httpclient.HttpMethodBase\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.exolab.castor\", \"INFO\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j.agent\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.com.mchange.v2\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.beans.factory.support\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.context.support\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.jdbc.datasource\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.test.context.support\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.hibernate.cfg.AnnotationBinder\", \"ERROR\" + consoleAppender + \", MOCK\");\n        \n        PropertyConfigurator.configure(logConfig);\n    }","commit_id":"89475af596217ecebfbd2a88c85acc6b4d0a35c8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging();\n\n        m_migration = new Migration();\n        m_migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        m_migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        m_migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        m_migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        m_migration.setChangeLog(\"changelog.xml\");\n    }","id":42667,"modified_method":"@Before\n    public void setUp() throws Exception {\n        MockLogAppender.setupLogging();\n    }","commit_id":"529f3f8ed99dcc4aea6d6721270ff675b9ce382e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @DirtiesContext\n    @JUnitTemporaryDatabase(createSchema=false)\n    @Ignore(\"takes a long time, just did this to make sure 'upgrades' would not bomb\")\n    public void testUpdateTwice() throws Exception {\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.migrate(m_migration);\n        m.migrate(m_migration);\n    }","id":42668,"modified_method":"@Test\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testUpdateTwice() throws Exception {\n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.migrate(migration);\n        m.migrate(migration);\n    }","commit_id":"529f3f8ed99dcc4aea6d6721270ff675b9ce382e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @DirtiesContext\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testUpdate() throws Exception {\n        Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        m.prepareDatabase(m_migration);\n        m.migrate(m_migration);\n\n        Connection conn = null;\n        try {\n            conn = m_dataSource.getConnection();\n\n            Set<String> tables = new HashSet<String>();\n            ResultSet rs = conn.getMetaData().getTables(null, null, \"%\", null);\n            while (rs.next()) {\n                tables.add(rs.getString(\"TABLE_NAME\").toLowerCase());\n            }\n            assertTrue(\"must contain table 'alarms'\", tables.contains(\"alarms\"));\n\n            Set<String> procs = new HashSet<String>();\n            rs = conn.getMetaData().getProcedures(null, null, \"%\");\n            while (rs.next()) {\n                procs.add(rs.getString(\"PROCEDURE_NAME\").toLowerCase());\n            }\n            System.err.println(\"procs = \" + procs);\n            assertTrue(\"must have stored procedure 'setSnmpInterfaceKeysOnUpdate'\", procs.contains(\"setsnmpinterfacekeysonupdate\"));\n        } finally {\n            if (conn != null) {\n                conn.close();\n            }\n        }\n    }","id":42669,"modified_method":"@Test\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testUpdate() throws Exception {\n        // Make sure there is no databasechangelog table\n        assertFalse(changelogExists());\n\n        Resource aResource = null;\n        for (final Resource resource : m_context.getResources(\"classpath*:/changelog.xml\")) {\n            if (resource.getURI().toString().contains(\"test-api.schema.a\")) {\n                aResource = resource;\n            }\n        }\n\n        Set<String> tables = getTables();\n        assertFalse(\"must not contain table 'schematest'\", tables.contains(\"schematest\"));\n        \n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n        migration.setAccessor(new ExistingResourceAccessor(aResource));\n\n        LogUtils.infof(this, \"Running migration on database: %s\", migration.toString());\n\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        m.prepareDatabase(migration);\n        m.migrate(migration);\n\n        LogUtils.infof(this, \"Migration complete: %s\", migration.toString());\n\n        tables = getTables();\n        assertTrue(\"must contain table 'schematest'\", tables.contains(\"schematest\"));\n    }","commit_id":"529f3f8ed99dcc4aea6d6721270ff675b9ce382e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @DirtiesContext\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testMultipleChangelogs() throws Exception {\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n\n        for (final Resource resource : m_context.getResources(\"classpath*:/changelog.xml\")) {\n            System.err.println(\"=== found resource: \" + resource + \" ===\");\n            migration.setAccessor(new ExistingResourceAccessor(resource));\n            m.migrate(migration);\n        }\n\n        final Connection connection = m_dataSource.getConnection();\n        final PreparedStatement statement = connection.prepareStatement(\"SELECT id FROM databasechangelog\");\n        assertTrue(statement.execute());\n        final ResultSet rs = statement.getResultSet();\n        final List<String> ids = new ArrayList<String>();\n        while (rs.next()) {\n            ids.add(rs.getString(1));\n        }\n        \n        assertTrue(ids.size() > 0);\n        assertTrue(ids.contains(\"test-api.schema.a\"));\n        assertTrue(ids.contains(\"test-api.schema.b\"));\n    }","id":42670,"modified_method":"@Test\n    @JUnitTemporaryDatabase(createSchema=false)\n    public void testMultipleChangelogs() throws Exception {\n        // Make sure there is no databasechangelog table\n        Connection connection = m_dataSource.getConnection();\n        try {\n            PreparedStatement statement = connection.prepareStatement(\"SELECT id FROM databasechangelog\");\n            statement.execute();\n            Assert.fail(\"databasechangelog exists\");\n        } catch (SQLException e) {\n        } finally {\n            connection.close();\n        }\n\n        final Migration migration = new Migration();\n        migration.setAdminUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setAdminPassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setDatabaseUser(System.getProperty(TemporaryDatabase.ADMIN_USER_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_USER));\n        migration.setDatabasePassword(System.getProperty(TemporaryDatabase.ADMIN_PASSWORD_PROPERTY, TemporaryDatabase.DEFAULT_ADMIN_PASSWORD));\n        migration.setChangeLog(\"changelog.xml\");\n\n        final Migrator m = new Migrator();\n        m.setDataSource(m_dataSource);\n        m.setAdminDataSource(m_dataSource);\n        m.setValidateDatabaseVersion(false);\n        m.setCreateUser(false);\n        m.setCreateDatabase(false);\n\n        // Add a resource accessor to the migration so that it will load multiple changelog.xml files\n        // from the classpath\n        for (final Resource resource : m_context.getResources(\"classpath*:/changelog.xml\")) {\n            LogUtils.infof(this, \"=== found resource: \" + resource + \" ===\");\n            migration.setAccessor(new ExistingResourceAccessor(resource));\n            m.migrate(migration);\n        }\n\n        connection = m_dataSource.getConnection();\n        PreparedStatement statement = connection.prepareStatement(\"SELECT id FROM databasechangelog\");\n        assertTrue(statement.execute());\n        ResultSet rs = statement.getResultSet();\n        List<String> ids = new ArrayList<String>();\n        while (rs.next()) {\n            ids.add(rs.getString(1));\n        }\n\n        assertTrue(ids.size() > 0);\n        assertTrue(ids.contains(\"test-api.schema.a\"));\n        assertTrue(ids.contains(\"test-api.schema.b\"));\n    }","commit_id":"529f3f8ed99dcc4aea6d6721270ff675b9ce382e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>setupLogging<\/p>\n     *\n     * @param toConsole a boolean.\n     * @param level a {@link java.lang.String} object.\n     * @param config a {@link java.util.Properties} object.\n     */\n    public static void setupLogging(final boolean toConsole, final String level, final Properties config) {\n        resetLogLevel();\n        \n        final Properties logConfig = new Properties(config);\n        final String consoleAppender = (toConsole ? \", CONSOLE\" : \"\");\n        \n        setProperty(logConfig, \"log4j.appender.CONSOLE\", \"org.apache.log4j.ConsoleAppender\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout.ConversionPattern\", \"%d %-5p [%t] %c: %m%n\");\n        setProperty(logConfig, \"log4j.appender.MOCK\", MockLogAppender.class.getName());\n        setProperty(logConfig, \"log4j.appender.MOCK.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.MOCK.layout.ConversionPattern\", \"%-5p [%t] %c: %m%n\");\n\n        setProperty(logConfig, \"log4j.rootCategory\", level + consoleAppender + \", MOCK\");\n        setProperty(logConfig, \"log4j.logger.org.apache.commons.httpclient.HttpMethodBase\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.exolab.castor\", \"INFO\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j.agent\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.com.mchange.v2.c3p0.impl\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.hibernate.cfg.AnnotationBinder\", \"ERROR\" + consoleAppender + \", MOCK\");\n        \n        PropertyConfigurator.configure(logConfig);\n    }","id":42671,"modified_method":"/**\n     * <p>setupLogging<\/p>\n     *\n     * @param toConsole a boolean.\n     * @param level a {@link java.lang.String} object.\n     * @param config a {@link java.util.Properties} object.\n     */\n    public static void setupLogging(final boolean toConsole, final String level, final Properties config) {\n        resetLogLevel();\n        \n        final Properties logConfig = new Properties(config);\n        final String consoleAppender = (toConsole ? \", CONSOLE\" : \"\");\n        \n        setProperty(logConfig, \"log4j.appender.CONSOLE\", \"org.apache.log4j.ConsoleAppender\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.CONSOLE.layout.ConversionPattern\", \"%d %-5p [%t] %c: %m%n\");\n        setProperty(logConfig, \"log4j.appender.MOCK\", MockLogAppender.class.getName());\n        setProperty(logConfig, \"log4j.appender.MOCK.layout\", \"org.apache.log4j.PatternLayout\");\n        setProperty(logConfig, \"log4j.appender.MOCK.layout.ConversionPattern\", \"%-5p [%t] %c: %m%n\");\n\n        setProperty(logConfig, \"log4j.rootCategory\", level + consoleAppender + \", MOCK\");\n        setProperty(logConfig, \"log4j.logger.org.apache.commons.httpclient.HttpMethodBase\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.exolab.castor\", \"INFO\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.org.snmp4j.agent\", \"ERROR\");\n        setProperty(logConfig, \"log4j.logger.com.mchange.v2\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.beans.factory.support\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.context.support\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.jdbc.datasource\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.springframework.test.context.support\", \"WARN\");\n        setProperty(logConfig, \"log4j.logger.org.hibernate.cfg.AnnotationBinder\", \"ERROR\" + consoleAppender + \", MOCK\");\n        \n        PropertyConfigurator.configure(logConfig);\n    }","commit_id":"529f3f8ed99dcc4aea6d6721270ff675b9ce382e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testUTF8Transport(Connection connection) throws Exception\n\t{\n\t\t/*\n\t\t * byte[] b = new byte[102400]; byte[] b2 = new byte[102400]; byte[] b3 =\n\t\t * new byte[102400]; char[] cin = new char[102400]; Random r = new\n\t\t * Random(); r.nextBytes(b);\n\t\t */\n\t\tbyte[] b = new byte[1024];\n\t\tbyte[] b2 = new byte[1024];\n\t\tbyte[] b3 = new byte[1024];\n\t\tchar[] cin = new char[1024];\n\n\t\t{\n\t\t\tint i = 0;\n\t\t\tfor (byte bx = Byte.MIN_VALUE; bx <= Byte.MAX_VALUE && i < b.length; bx++)\n\t\t\t{\n\t\t\t\tb[i++] = bx;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tcin[i] = (char) (b[i]);\n\t\t\tlog.info(\"Byte \"+b[i]+\":\"+(int)cin[i]);\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tb2[i] = (byte) (cin[i]);\n\t\t}\n\t\tfor (int i = 0; i < cin.length; i++)\n\t\t{\n\t\t\tif (b[i] != b2[i])\n\t\t\t{\n\t\t\t\tlog.info(\"Internal Byte First test at \" + i + \" does not match \"\n\t\t\t\t\t\t+ (int) b[i] + \":\" + b[i] + \" != \" + (int) b2[i] + \":\" + b2[i]);\n\n\t\t\t\tthrow new Exception(\"Internal Check Failed, byte char conversion failed\");\n\t\t\t}\n\t\t}\n\n\t\tString bin = new String(cin);\n\t\tString bout = null;\n\n\t\tchar[] cin2 = bin.toCharArray();\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tb2[i] = (byte) (cin2[i]);\n\t\t}\n\t\tfor (int i = 0; i < cin2.length; i++)\n\t\t{\n\t\t\tif (b[i] != b2[i])\n\t\t\t{\n\t\t\t\tlog.info(\"Internal  Char String Byte First test at \" + i\n\t\t\t\t\t\t+ \" does not match \" + (int) b[i] + \":\" + b[i] + \" != \"\n\t\t\t\t\t\t+ (int) b2[i] + \":\" + b2[i]);\n\n\t\t\t\tthrow new Exception(\"Internal Check Failed, byte char conversion \");\n\t\t\t}\n\t\t}\n\n\t\tPreparedStatement statement = null;\n\t\tPreparedStatement statement2 = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tstatement = connection\n\t\t\t\t\t.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n\t\t\tstatement.clearParameters();\n\t\t\tstatement.setInt(1, 1);\n\t\t\tstatement.setString(2, bin);\n\t\t\tstatement.executeUpdate();\n\n\t\t\tstatement2 = connection\n\t\t\t\t\t.prepareStatement(\"select bval from blobtest where id =  ? \");\n\t\t\tstatement2.clearParameters();\n\t\t\tstatement2.setInt(1, 1);\n\t\t\trs = statement2.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t{\n\t\t\t\tbout = rs.getString(1);\n\t\t\t}\n\t\t\tchar[] cout = bout.toCharArray();\n\t\t\tif (cout.length != cin.length)\n\t\t\t{\n\t\t\t\tlog.info(\"Dropped \" + (cin.length - cout.length));\n\t\t\t\tthrow new Exception(\"Truncation Error on transport\");\n\t\t\t}\n\t\t\tfor (int i = 0; i < b.length; i++)\n\t\t\t{\n\t\t\t\tb3[i] = (byte) (cout[i]);\n\t\t\t\t// log.info(\"Byte at \"+i+\" is \"+b3[i]+\" char \"+(int)cout[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < cin.length; i++)\n\t\t\t{\n\t\t\t\tif (b[i] != b3[i])\n\t\t\t\t{\n\t\t\t\t\tlog.info(\"External Byte at \" + i + \" does not match \" + \":\" + b[i]\n\t\t\t\t\t\t\t+ \" != \" + b3[i]);\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\t\"UTF-8 Transport and/or database is NOT Ok for UTF8 usage \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.info(\"DB Connection passes UTF-8 tests\");\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\trs.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstatement2.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t}\n\n\t}","id":42672,"modified_method":"public void testUTF8Transport(Connection connection) throws Exception\n\t{\n\t\t/*\n\t\t * byte[] b = new byte[102400]; byte[] b2 = new byte[102400]; byte[] b3 =\n\t\t * new byte[102400]; char[] cin = new char[102400]; Random r = new\n\t\t * Random(); r.nextBytes(b);\n\t\t */\n\t\tbyte[] bin = new byte[102400];\n\t\tchar[] cin = new char[102400];\n\t\tbyte[] bout = new byte[102400];\n\n\t\t{\n\t\t\tint i = 0;\n\t\t\tfor (int bx = 0; i < bin.length; bx++)\n\t\t\t{\n\t\t\t\tbin[i++] = (byte) bx;\n\t\t\t}\n\t\t}\n\t\tByteStorageConversion.toChar(bin, 0, cin, 0, cin.length);\n\t\tString sin = new String(cin);\n\n\t\tchar[] cout = sin.toCharArray();\n\t\tByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n\t\tfor (int i = 0; i < bin.length; i++)\n\t\t{\n\t\t\tif (bin[i] != bout[i])\n\t\t\t{\n\t\t\t\tthrow new Exception(\"Internal Byte conversion failed at \" + bin[i] + \"=>\"\n\t\t\t\t\t\t+ (int) cin[i] + \"=>\" + bout[i]);\n\t\t\t}\n\t\t}\n\n\t\tPreparedStatement statement = null;\n\t\tPreparedStatement statement2 = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tstatement = connection\n\t\t\t\t\t.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n\t\t\tstatement.clearParameters();\n\t\t\tstatement.setInt(1, 20);\n\t\t\tstatement.setString(2, sin);\n\t\t\tstatement.executeUpdate();\n\n\t\t\tstatement2 = connection\n\t\t\t\t\t.prepareStatement(\"select bval from blobtest where id =  ? \");\n\t\t\tstatement2.clearParameters();\n\t\t\tstatement2.setInt(1, 20);\n\t\t\trs = statement2.executeQuery();\n\t\t\tString sout = null;\n\t\t\tif (rs.next())\n\t\t\t{\n\t\t\t\tsout = rs.getString(1);\n\t\t\t}\n\n\t\t\tcout = sout.toCharArray();\n\t\t\tByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n\t\t\tif (sin.length() != sout.length())\n\t\t\t{\n\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"UTF-8 Data was lost communicating with the database, please \"\n\t\t\t\t\t\t\t\t+ \"check connection string and default table types (Truncation/Expansion)\");\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < bin.length; i++)\n\t\t\t{\n\t\t\t\tif (bin[i] != bout[i])\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\t\"UTF-8 Data was corrupted communicating with the database, \"\n\t\t\t\t\t\t\t\t\t+ \"please check connectionstring and default table types (Conversion)\"\n\t\t\t\t\t\t\t\t\t+ \"\" + bin[i] + \"=>\" + (int) cin[i] + \"=>\" + bout[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.info(\"DB Connection passes UTF-8 tests\");\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\trs.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstatement2.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void testBlobData() throws SQLException\n\t{\n\t\tbyte[] b = new byte[102400];\n\t\tbyte[] b2 = new byte[102400];\n\t\tbyte[] b3 = new byte[102400];\n\t\tchar[] cin = new char[102400];\n\t\tRandom r = new Random();\n\t\tr.nextBytes(b);\n\t\t\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tcin[i] = (char) (b[i]);\n\t\t}\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tb2[i] = (byte) (cin[i]);\n\t\t}\n\t\tfor (int i = 0; i < cin.length; i++)\n\t\t{\n\t\t\tif (b[i] != b2[i])\n\t\t\t{\n\t\t\t\tlog.info(\"Internal Byte First test at \" + i + \" does not match \"\n\t\t\t\t\t\t+ (int) b[i] + \":\" + b[i] + \" != \" + (int) b2[i] + \":\" + b2[i]);\n\n\t\t\t\tfail(\"Did not transfer Ok internally\");\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Internal trasfer Ok\");\n\n\t\tString bin = new String(cin);\n\t\tString bout = null;\n\t\t\n\t\tchar[] cin2 = bin.toCharArray();\n\t\tfor (int i = 0; i < b.length; i++)\n\t\t{\n\t\t\tb2[i] = (byte) (cin2[i]);\n\t\t}\n\t\tfor (int i = 0; i < cin2.length; i++)\n\t\t{\n\t\t\tif (b[i] != b2[i])\n\t\t\t{\n\t\t\t\tlog.info(\"Internal  Char String Byte First test at \" + i + \" does not match \"\n\t\t\t\t\t\t+ (int) b[i] + \":\" + b[i] + \" != \" + (int) b2[i] + \":\" + b2[i]);\n\n\t\t\t\tfail(\"Did not transfer Ok internally with char\");\n\t\t\t}\n\t\t}\n\n\n\t\tConnection connection = null;\n\t\tPreparedStatement statement = null;\n\t\tPreparedStatement statement2 = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = tds.getConnection();\n\t\t\tstatement = connection\n\t\t\t\t\t.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n\t\t\tstatement.clearParameters();\n\t\t\tstatement.setInt(1, 1);\n\t\t\tstatement.setString(2, bin);\n\t\t\tstatement.executeUpdate();\n\n\t\t\tstatement2 = connection\n\t\t\t\t\t.prepareStatement(\"select bval from blobtest where id =  ? \");\n\t\t\tstatement2.clearParameters();\n\t\t\tstatement2.setInt(1, 1);\n\t\t\trs = statement2.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t{\n\t\t\t\tbout = rs.getString(1);\n\t\t\t}\n\t\t\tchar[] cout = bout.toCharArray();\n\t\t\tif (cout.length != cin.length)\n\t\t\t{\n\t\t\t\tlog.info(\"Dropped \" + (cin.length - cout.length));\n\t\t\t}\n\t\t\tfor (int i = 0; i < b.length; i++)\n\t\t\t{\n\t\t\t\tb3[i] = (byte) (cout[i]);\n\t\t//\t\tlog.info(\"Byte at \"+i+\" is \"+b3[i]+\"  char \"+(int)cout[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < cin.length; i++)\n\t\t\t{\n\t\t\t\tif (b[i] != b3[i])\n\t\t\t\t{\n\t\t\t\t\tlog.info(\"External Byte at \" + i + \" does not match \" + \":\" + b[i] + \" != \" + b3[i]);\n\t\t\t\t\tfail(\"Did not transfer Ok internally \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < cin.length; i++)\n\t\t\t{\n\t\t\t\tif (cin[i] != cout[i])\n\t\t\t\t{\n\t\t\t\t\tlog.info(\"External Char at \" + i + \" does not match \" + (int) cin[i]\n\t\t\t\t\t\t\t+ \":\" + cin[i] + \" != \" + (int) cout[i] + \":\" + cout[i]);\n\t\t\t\t\tlog.info(\"Bytes:\" + b[i]);\n\n\t\t\t\t\tfail(\"DId not serialize Ok\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassertEquals(bin, bout);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\trs.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstatement2.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t}\n\n\t}","id":42673,"modified_method":"public void testBlobData() throws SQLException\n\t{\n\t\t// run the test 10 times to make really certain there is no problem\n\t\tfor (int k = 0; k < 10; k++)\n\t\t{\n\t\t\tbyte[] bin = new byte[102400];\n\t\t\tchar[] cin = new char[102400];\n\n\t\t\tbyte[] bout = new byte[102400];\n\t\t\tRandom r = new Random();\n\t\t\tr.nextBytes(bin);\n\n\t\t\tByteStorageConversion.toChar(bin, 0, cin, 0, cin.length);\n\t\t\tString sin = new String(cin);\n\n\t\t\tchar[] cout = sin.toCharArray();\n\t\t\tByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n\t\t\tfor (int i = 0; i < bin.length; i++)\n\t\t\t{\n\t\t\t\tassertEquals(\"Internal Byte conversion failed at \" + bin[i] + \"=>\"\n\t\t\t\t\t\t+ (int) cin[i] + \"=>\" + bout[i], bin[i], bout[i]);\n\t\t\t}\n\n\t\t\tConnection connection = null;\n\t\t\tPreparedStatement statement = null;\n\t\t\tPreparedStatement statement2 = null;\n\t\t\tResultSet rs = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection = tds.getConnection();\n\t\t\t\tstatement = connection\n\t\t\t\t\t\t.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n\t\t\t\tstatement.clearParameters();\n\t\t\t\tstatement.setInt(1, k);\n\t\t\t\tstatement.setString(2, sin);\n\t\t\t\tstatement.executeUpdate();\n\n\t\t\t\tstatement2 = connection\n\t\t\t\t\t\t.prepareStatement(\"select bval from blobtest where id =  ? \");\n\t\t\t\tstatement2.clearParameters();\n\t\t\t\tstatement2.setInt(1, k);\n\t\t\t\trs = statement2.executeQuery();\n\t\t\t\tString sout = null;\n\t\t\t\tif (rs.next())\n\t\t\t\t{\n\t\t\t\t\tsout = rs.getString(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcout = sout.toCharArray();\n\t\t\t\tByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n\t\t\t\tassertEquals(\"Input and Output Lenghts are not the same \", sin.length(),\n\t\t\t\t\t\tsout.length());\n\n\t\t\t\tfor (int i = 0; i < bin.length; i++)\n\t\t\t\t{\n\t\t\t\t\tassertEquals(\"Database Byte conversion failed at \" + bin[i] + \"=>\"\n\t\t\t\t\t\t\t+ (int) cin[i] + \"=>\" + bout[i], bin[i], bout[i]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tstatement2.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tstatement.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @param connection\n\t * @param convert\n\t * @throws SQLException\n\t */\n\tprivate void createRegisterTable(Connection connection,\n\t\t\tSchemaConversionHandler convert) throws SQLException\n\t{\n\t\tStatement stmt = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tstmt = connection.createStatement();\n\t\t\tlong nrecords = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// select count(*) from content_migrate;\n\t\t\t\tString sql = convert.getCheckMigrateTable();\n\t\t\t\trs = stmt.executeQuery(sql);\n\t\t\t\tif (rs.next())\n\t\t\t\t{\n\t\t\t\t\tnrecords = rs.getLong(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException sqle)\n\t\t\t{\n\t\t\t\tString sql = convert.getCreateMigrateTable();\n\t\t\t\tstmt.execute(sql);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nrecords == 0)\n\t\t\t{\n\t\t\t\tString sql = convert.getPopulateMigrateTable();\n\t\t\t\tstmt.executeUpdate(sql);\n\t\t\t}\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t}","id":42674,"modified_method":"/**\n\t * @param connection\n\t * @param convert\n\t * @throws SQLException\n\t */\n\tprivate void createRegisterTable(Connection connection,\n\t\t\tSchemaConversionHandler convert, SchemaConversionDriver driver) throws SQLException\n\t{\n\t\tStatement stmt = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tstmt = connection.createStatement();\n\t\t\tlong nrecords = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// select count(*) from content_migrate;\n\t\t\t\tString sql = driver.getCheckMigrateTable();\n\t\t\t\trs = stmt.executeQuery(sql);\n\t\t\t\tif (rs.next())\n\t\t\t\t{\n\t\t\t\t\tnrecords = rs.getLong(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException sqle)\n\t\t\t{\n\t\t\t\tString sql = driver.getCreateMigrateTable();\n\t\t\t\tstmt.execute(sql);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\trs.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nrecords == 0)\n\t\t\t{\n\t\t\t\tString sql = driver.getPopulateMigrateTable();\n\t\t\t\tstmt.executeUpdate(sql);\n\t\t\t}\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public boolean migrate(DataSource datasource, SchemaConversionHandler convert)\n\t{\n\t\tboolean alldone = false;\n\t\tConnection connection = null;\n\t\tPreparedStatement selectNextBatch = null;\n\t\tPreparedStatement markNextBatch = null;\n\t\tPreparedStatement completeNextBatch = null;\n\t\tPreparedStatement selectRecord = null;\n\t\tPreparedStatement updateRecord = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\tselectNextBatch = connection.prepareStatement(convert.getSelectNextBatch());\n\t\t\tmarkNextBatch = connection.prepareStatement(convert.getMarkNextBatch());\n\t\t\tcompleteNextBatch = connection.prepareStatement(convert\n\t\t\t\t\t.getCompleteNextBatch());\n\t\t\tselectRecord = connection.prepareStatement(convert.getSelectRecord());\n\t\t\tupdateRecord = connection.prepareStatement(convert.getUpdateRecord());\n\n\t\t\t// we need some way of identifying those records that have not been\n\t\t\t// convertd.\n\t\t\t// 1. Create a register table to map progress.\n\n\t\t\tcreateRegisterTable(connection, convert);\n\n\t\t\t// 2. select x at a time\n\t\t\trs = selectNextBatch.executeQuery();\n\t\t\tList<String> l = new ArrayList<String>();\n\t\t\twhile (rs.next())\n\t\t\t{\n\t\t\t\tl.add(rs.getString(1));\n\t\t\t}\n\t\t\trs.close();\n\t\t\t\n\t\t\tlog.info(\"Migrating \"+l.size()+\" records \");\n\t\t\t\n\t\t\tfor (String id : l)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tmarkNextBatch.clearParameters();\n\t\t\t\tmarkNextBatch.setString(1, id);\n\t\t\t\tif (markNextBatch.executeUpdate() != 1)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Failed to mark id [\" + id + \"][\" +id.length()+\"] for processing \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String id : l)\n\t\t\t{\n\t\t\t\tselectRecord.clearParameters();\n\t\t\t\tselectRecord.setString(1, id);\n\t\t\t\trs = selectRecord.executeQuery();\n\t\t\t\tObject source = null;\n\t\t\t\tif (rs.next())\n\t\t\t\t{\n\t\t\t\t\tsource = convert.getSource(id, rs);\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t\tif (source != null)\n\t\t\t\t{\n\t\t\t\t\tupdateRecord.clearParameters();\n\t\t\t\t\tif (convert.convertSource(id, source, updateRecord))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (updateRecord.executeUpdate() != 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.warn(\"Failed to update record \" + id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.warn(\"Did not update record \" + id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcompleteNextBatch.clearParameters();\n\t\t\t\tcompleteNextBatch.setString(1, id);\n\t\t\t\tif (completeNextBatch.executeUpdate() != 1)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Failed to mark id \" + id + \" for processing \");\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tlog.info(\"Done \");\n\n\t\t\tif (l.size() == 0)\n\t\t\t{\n\t\t\t\tdropRegisterTable(connection, convert);\n\t\t\t\talldone = true;\n\t\t\t}\n\t\t\tconnection.commit();\n\n\t\t}\n\t\tcatch (SQLException e)\n\t\t{\n\t\t\tlog.error(\"Failed to perform migration \",e);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t}\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\trs.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tselectNextBatch.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmarkNextBatch.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcompleteNextBatch.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tselectRecord.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tupdateRecord.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.close();\n\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\n\t\t}\n\t\treturn alldone;\n\t}","id":42675,"modified_method":"public boolean migrate(DataSource datasource, SchemaConversionHandler convert, SchemaConversionDriver driver) throws SchemaConversionException\n\t{\n\t\tboolean alldone = false;\n\t\tConnection connection = null;\n\t\tPreparedStatement selectNextBatch = null;\n\t\tPreparedStatement markNextBatch = null;\n\t\tPreparedStatement completeNextBatch = null;\n\t\tPreparedStatement selectRecord = null;\n\t\tPreparedStatement updateRecord = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\tselectNextBatch = connection.prepareStatement(driver.getSelectNextBatch());\n\t\t\tmarkNextBatch = connection.prepareStatement(driver.getMarkNextBatch());\n\t\t\tcompleteNextBatch = connection.prepareStatement(driver\n\t\t\t\t\t.getCompleteNextBatch());\n\t\t\tselectRecord = connection.prepareStatement(driver.getSelectRecord());\n\t\t\tupdateRecord = connection.prepareStatement(driver.getUpdateRecord());\n\n\t\t\t// we need some way of identifying those records that have not been\n\t\t\t// convertd.\n\t\t\t// 1. Create a register table to map progress.\n\n\t\t\tcreateRegisterTable(connection, convert, driver);\n\n\t\t\t// 2. select x at a time\n\t\t\trs = selectNextBatch.executeQuery();\n\t\t\tList<String> l = new ArrayList<String>();\n\t\t\twhile (rs.next())\n\t\t\t{\n\t\t\t\tl.add(rs.getString(1));\n\t\t\t}\n\t\t\trs.close();\n\t\t\t\n\t\t\tlog.info(\"Migrating \"+l.size()+\" records \");\n\t\t\t\n\t\t\tfor (String id : l)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tmarkNextBatch.clearParameters();\n\t\t\t\tmarkNextBatch.setString(1, id);\n\t\t\t\tif (markNextBatch.executeUpdate() != 1)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Failed to mark id [\" + id + \"][\" +id.length()+\"] for processing \");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String id : l)\n\t\t\t{\n\t\t\t\tselectRecord.clearParameters();\n\t\t\t\tselectRecord.setString(1, id);\n\t\t\t\trs = selectRecord.executeQuery();\n\t\t\t\tObject source = null;\n\t\t\t\tif (rs.next())\n\t\t\t\t{\n\t\t\t\t\tsource = convert.getSource(id, rs);\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t\tif (source != null)\n\t\t\t\t{\n\t\t\t\t\tupdateRecord.clearParameters();\n\t\t\t\t\tif (convert.convertSource(id, source, updateRecord))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (updateRecord.executeUpdate() != 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.warn(\"Failed to update record \" + id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.warn(\"Did not update record \" + id);\n\t\t\t\t\t}\n\t\t\t\t\tselectRecord.clearParameters();\n\t\t\t\t\tselectRecord.setString(1, id);\n\t\t\t\t\trs = selectRecord.executeQuery();\n\t\t\t\t\tObject result = null;\n\t\t\t\t\tif (rs.next())\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = convert.getSource(id, rs);\n\t\t\t\t\t}\n\t\t\t\t\trs.close();\n\t\t\t\t\t\n\t\t\t\t\tconvert.validate(id, source, result);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcompleteNextBatch.clearParameters();\n\t\t\t\tcompleteNextBatch.setString(1, id);\n\t\t\t\tif (completeNextBatch.executeUpdate() != 1)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Failed to mark id \" + id + \" for processing \");\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tlog.info(\"Done \");\n\n\t\t\tif (l.size() == 0)\n\t\t\t{\n\t\t\t\tdropRegisterTable(connection, convert, driver);\n\t\t\t\talldone = true;\n\t\t\t}\n\t\t\tconnection.commit();\n\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Failed to perform migration \",e);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.rollback();\n\t\t\t\tlog.error(\"Rollback Sucessfull \",e);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tlog.error(\"Rollback Failed \",e);\n\t\t\t}\n\t\t\tthrow new SchemaConversionException(\"Schema Conversion has been aborted due to earlier errors, please investigate \");\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\trs.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tselectNextBatch.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmarkNextBatch.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcompleteNextBatch.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tselectRecord.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tupdateRecord.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.close();\n\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\n\t\t\t}\n\n\t\t}\n\t\treturn alldone;\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @throws SQLException\n\t */\n\tprivate void dropRegisterTable(Connection connection, SchemaConversionHandler convert)\n\t\t\tthrows SQLException\n\t{\n\t\tStatement stmt = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tstmt = connection.createStatement();\n\t\t\tString sql = convert.getDropMigrateTable();\n\t\t\tstmt.execute(sql);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}","id":42676,"modified_method":"/**\n\t * @throws SQLException\n\t */\n\tprivate void dropRegisterTable(Connection connection, SchemaConversionHandler convert, SchemaConversionDriver driver)\n\t\t\tthrows SQLException\n\t{\n\t\tStatement stmt = null;\n\t\tResultSet rs = null;\n\t\ttry\n\t\t{\n\t\t\tstmt = connection.createStatement();\n\t\t\tString sql = driver.getDropMigrateTable();\n\t\t\tstmt.execute(sql);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * \n\t * \n\t */\n\tpublic String serialize(SerializableEntity se) throws EntityParseException\n\t{\n\t\tif ( !(se instanceof SerializableCollectionAccess) ) {\n\t\t\tthrow new EntityParseException(\"Cant serialize \"+se+\" as it is not a SerializableCollectionAccess \"); \n\t\t}\n\t\tSerializableCollectionAccess sc = (SerializableCollectionAccess) se;\n\t\t\n\t\ttry\n\t\t{\n\t\t\tString id = sc.getSerializableId();\n\t\t\tboolean hidden = sc.getSerializableHidden();\n\t\t\tAccessMode access = sc.getSerializableAccess();\n\t\t\tTime releaseDate = sc.getSerializableReleaseDate();\n\t\t\tTime retractDate = sc.getSerializableRetractDate();\n\t\t\tCollection<String> groups = sc.getSerializableGroup();\n\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tDataOutputStream ds = new DataOutputStream(baos);\n\t\t\tds.writeInt(TYPE1);\n\t\t\tds.writeInt(BLOCK1);\n\t\t\tds.writeUTF(id);\n\t\t\tds.writeUTF(ResourceType.TYPE_FOLDER);\n\t\t\t\n\t\t\tif(access == null || AccessMode.SITE == access)\n\t\t\t{\n\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t}\n\n\t\t\tds.writeUTF(access.toString());\n\t\t\tds.writeBoolean(hidden);\n\t\t\tds.writeInt(BLOCK2);\n\t\t\tif (!hidden && releaseDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(releaseDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (!hidden && retractDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(retractDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (groups != null)\n\t\t\t{\n\t\t\t\tds.writeInt(BLOCK3);\n\t\t\t\tds.writeInt(groups.size());\n\t\t\t\tfor (Iterator igroup = groups.iterator(); igroup.hasNext();)\n\t\t\t\t{\n\t\t\t\t\tString groupRef = (String) igroup.next();\n\t\t\t\t\tds.writeUTF(groupRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds.writeInt(BLOCK4);\n\t\t\tbaseResourcePropertiesSerializer.serialize(sc.getSerializableProperties(),ds);\n\t\t\tds.writeInt(BLOCK_END);\n\n\t\t\tds.flush();\n\t\t\tbaos.flush();\n\t\t\tbyte[] op = baos.toByteArray();\n\t\t\tchar[] opc = new char[op.length + BLOB_ID.length()];\n\t\t\tint bid = BLOB_ID.length();\n\t\t\tfor (int i = 0; i < bid; i++)\n\t\t\t{\n\t\t\t\topc[i] = BLOB_ID.charAt(i);\n\t\t\t}\n\t\t\tfor (int i = bid; i < opc.length; i++)\n\t\t\t{\n\t\t\t\topc[i] = (char) op[i-bid];\n\t\t\t}\n\t\t\treturn new String(opc);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to serialize entity \", ex);\n\t\t}\n\t}","id":42677,"modified_method":"/**\n\t * \n\t * \n\t */\n\tpublic String serialize(SerializableEntity se) throws EntityParseException\n\t{\n\t\tif ( !(se instanceof SerializableCollectionAccess) ) {\n\t\t\tthrow new EntityParseException(\"Cant serialize \"+se+\" as it is not a SerializableCollectionAccess \"); \n\t\t}\n\t\tSerializableCollectionAccess sc = (SerializableCollectionAccess) se;\n\t\t\n\t\ttry\n\t\t{\n\t\t\tString id = sc.getSerializableId();\n\t\t\tboolean hidden = sc.getSerializableHidden();\n\t\t\tAccessMode access = sc.getSerializableAccess();\n\t\t\tTime releaseDate = sc.getSerializableReleaseDate();\n\t\t\tTime retractDate = sc.getSerializableRetractDate();\n\t\t\tCollection<String> groups = sc.getSerializableGroup();\n\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tDataOutputStream ds = new DataOutputStream(baos);\n\t\t\tds.writeInt(TYPE1);\n\t\t\tds.writeInt(BLOCK1);\n\t\t\tds.writeUTF(id);\n\t\t\tds.writeUTF(ResourceType.TYPE_FOLDER);\n\t\t\t\n\t\t\tif(access == null || AccessMode.SITE == access)\n\t\t\t{\n\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t}\n\n\t\t\tds.writeUTF(access.toString());\n\t\t\tds.writeBoolean(hidden);\n\t\t\tds.writeInt(BLOCK2);\n\t\t\tif (!hidden && releaseDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(releaseDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (!hidden && retractDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(retractDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (groups != null)\n\t\t\t{\n\t\t\t\tds.writeInt(BLOCK3);\n\t\t\t\tds.writeInt(groups.size());\n\t\t\t\tfor (Iterator igroup = groups.iterator(); igroup.hasNext();)\n\t\t\t\t{\n\t\t\t\t\tString groupRef = (String) igroup.next();\n\t\t\t\t\tds.writeUTF(groupRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds.writeInt(BLOCK4);\n\t\t\tbaseResourcePropertiesSerializer.serialize(sc.getSerializableProperties(),ds);\n\t\t\tds.writeInt(BLOCK_END);\n\n\t\t\tds.flush();\n\t\t\tbaos.flush();\n\t\t\tbyte[] op = baos.toByteArray();\n\t\t\tchar[] opc = new char[op.length + BLOB_ID.length()];\n\t\t\tint bid = BLOB_ID.length();\n\t\t\t\n\t\t\tByteStorageConversion.toChar(op, 0, opc, bid, op.length);\n\t\t\t\n\t\t\tfor (int i = 0; i < bid; i++)\n\t\t\t{\n\t\t\t\topc[i] = BLOB_ID.charAt(i);\n\t\t\t}\t\t\t\n\t\t\treturn new String(opc);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to serialize entity \", ex);\n\t\t}\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * \n\t */\n\tpublic void parse(SerializableEntity se, String serialized)\n\t\t\tthrows EntityParseException\n\t{\n\t\t\n\t\tif ( !(se instanceof SerializableCollectionAccess) ) {\n\t\t\tthrow new EntityParseException(\"Cant serialize \"+se+\" as it is not a SerializableCollection \"); \n\t\t}\n\t\tSerializableCollectionAccess sc = (SerializableCollectionAccess) se;\n\n\t\ttry\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (!serialized.startsWith(BLOB_ID))\n\t\t\t{\n\t\t\t\tthrow new EntityParseException(\n\t\t\t\t\t\t\"Data Block does not belong to this serializer got [\"\n\t\t\t\t\t\t\t\t+ serialized.substring(0, BLOB_ID.length())\n\t\t\t\t\t\t\t\t+ \"] expected [\" + BLOB_ID + \"]\");\n\t\t\t}\n\t\t\tchar[] cbuf = serialized.toCharArray();\n\t\t\tint blobIdLength = BLOB_ID.length();\n\t\t\tbyte[] sb = new byte[cbuf.length - blobIdLength];\n\t\t\tfor (int i = blobIdLength; i < cbuf.length; i++)\n\t\t\t{\n\t\t\t\tsb[i - blobIdLength] = (byte) cbuf[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tString id = null;\n\t\t\tAccessMode access = AccessMode.INHERITED;\n\t\t\tboolean hidden = false;\n\t\t\tString resourceType = ResourceType.TYPE_FOLDER;\n\t\t\tTime releaseDate = null;\n\t\t\tTime retractDate = null;\n\t\t\tCollection<String> groups = new Vector<String>();\n\n\t\t\t\n\t\t\tByteArrayInputStream baos = new ByteArrayInputStream(sb);\n\t\t\tDataInputStream ds = new DataInputStream(baos);\n\t\t\tint type = ds.readInt();\n\t\t\tif (type == TYPE1)\n\t\t\t{\n\t\t\t\tboolean finished = false;\n\t\t\t\twhile (!finished)\n\t\t\t\t{\n\t\t\t\t\tint block = ds.readInt();\n\t\t\t\t\tswitch (block)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase BLOCK1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid = ds.readUTF();\n\t\t\t\t\t\t\tif (!ResourceType.TYPE_FOLDER.equals(ds.readUTF()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new EntityParseException(\n\t\t\t\t\t\t\t\t\t\t\"Data block is not of tye \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ ResourceType.TYPE_FOLDER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taccess = AccessMode.fromString(ds.readUTF());\n\t\t\t\t\t\t\tif (access == null || AccessMode.SITE == access)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thidden = ds.readBoolean();\n\n\t\t\t\t\t\t\tresourceType = ResourceType.TYPE_FOLDER;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong rd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK3:\n\t\t\t\t\t\t\tint sz = ds.readInt();\n\t\t\t\t\t\t\tfor (int i = 0; i < sz; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroups.add(ds.readUTF());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK4:\n\t\t\t\t\t\t\tbaseResourcePropertiesSerializer.parse(sc.getSerializableProperties(),ds);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK_END:\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new EntityParseException(\"Unrecognised Record Type \"+type);\n\t\t\t}\n\t\t\tsc.setSerializableId(id);\n\t\t\tsc.setSerializableAccess(access);\n\t\t\tsc.setSerializableHidden(hidden);\n\t\t\tsc.setSerializableResourceType(resourceType);\n\t\t\tsc.setSerializableReleaseDate(releaseDate);\n\t\t\tsc.setSerializableRetractDate(retractDate);\n\t\t\tsc.setSerializableGroups(groups);\n\n\t\t}\n\t\tcatch ( EntityParseException  epe ) {\n\t\t\tthrow epe;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to parse entity\", ex);\n\t\t}\n\n\t}","id":42678,"modified_method":"/**\n\t * \n\t */\n\tpublic void parse(SerializableEntity se, String serialized)\n\t\t\tthrows EntityParseException\n\t{\n\t\t\n\t\tif ( !(se instanceof SerializableCollectionAccess) ) {\n\t\t\tthrow new EntityParseException(\"Cant serialize \"+se+\" as it is not a SerializableCollection \"); \n\t\t}\n\t\tSerializableCollectionAccess sc = (SerializableCollectionAccess) se;\n\n\t\ttry\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (!serialized.startsWith(BLOB_ID))\n\t\t\t{\n\t\t\t\tthrow new EntityParseException(\n\t\t\t\t\t\t\"Data Block does not belong to this serializer got [\"\n\t\t\t\t\t\t\t\t+ serialized.substring(0, BLOB_ID.length())\n\t\t\t\t\t\t\t\t+ \"] expected [\" + BLOB_ID + \"]\");\n\t\t\t}\n\t\t\tchar[] cbuf = serialized.toCharArray();\t\t\t\n\t\t\tbyte[] sb = new byte[cbuf.length - BLOB_ID.length()];\n\t\t\t\n\t\t\tByteStorageConversion.toByte(cbuf, BLOB_ID.length(), sb, 0, sb.length);\n\t\t\t\n\t\t\t\n\t\t\tString id = null;\n\t\t\tAccessMode access = AccessMode.INHERITED;\n\t\t\tboolean hidden = false;\n\t\t\tString resourceType = ResourceType.TYPE_FOLDER;\n\t\t\tTime releaseDate = null;\n\t\t\tTime retractDate = null;\n\t\t\tCollection<String> groups = new Vector<String>();\n\n\t\t\t\n\t\t\tByteArrayInputStream baos = new ByteArrayInputStream(sb);\n\t\t\tDataInputStream ds = new DataInputStream(baos);\n\t\t\tint type = ds.readInt();\n\t\t\tif (type == TYPE1)\n\t\t\t{\n\t\t\t\tboolean finished = false;\n\t\t\t\twhile (!finished)\n\t\t\t\t{\n\t\t\t\t\tint block = ds.readInt();\n\t\t\t\t\tswitch (block)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase BLOCK1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid = ds.readUTF();\n\t\t\t\t\t\t\tif (!ResourceType.TYPE_FOLDER.equals(ds.readUTF()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow new EntityParseException(\n\t\t\t\t\t\t\t\t\t\t\"Data block is not of tye \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ ResourceType.TYPE_FOLDER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taccess = AccessMode.fromString(ds.readUTF());\n\t\t\t\t\t\t\tif (access == null || AccessMode.SITE == access)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thidden = ds.readBoolean();\n\n\t\t\t\t\t\t\tresourceType = ResourceType.TYPE_FOLDER;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong rd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK3:\n\t\t\t\t\t\t\tint sz = ds.readInt();\n\t\t\t\t\t\t\tfor (int i = 0; i < sz; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroups.add(ds.readUTF());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK4:\n\t\t\t\t\t\t\tbaseResourcePropertiesSerializer.parse(sc.getSerializableProperties(),ds);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK_END:\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new EntityParseException(\"Unrecognised Record Type \"+type);\n\t\t\t}\n\t\t\tsc.setSerializableId(id);\n\t\t\tsc.setSerializableAccess(access);\n\t\t\tsc.setSerializableHidden(hidden);\n\t\t\tsc.setSerializableResourceType(resourceType);\n\t\t\tsc.setSerializableReleaseDate(releaseDate);\n\t\t\tsc.setSerializableRetractDate(retractDate);\n\t\t\tsc.setSerializableGroups(groups);\n\n\t\t}\n\t\tcatch ( EntityParseException  epe ) {\n\t\t\tthrow epe;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to parse entity\", ex);\n\t\t}\n\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String serialize(SerializableEntity se) throws EntityParseException\n\t{\n\t\tif (!(se instanceof SerializableResourceAccess))\n\t\t{\n\t\t\tthrow new EntityParseException(\"Cant serialize \" + se\n\t\t\t\t\t+ \" as it is not a SerializableResourceAccess \");\n\t\t}\n\t\tSerializableResourceAccess sc = (SerializableResourceAccess) se;\n\n\t\ttry\n\t\t{\n\t\t\tString id = sc.getSerializableId();\n\t\t\tboolean hidden = sc.getSerializableHidden();\n\t\t\tAccessMode access = sc.getSerializableAccess();\n\t\t\tTime releaseDate = sc.getSerializableReleaseDate();\n\t\t\tTime retractDate = sc.getSerializableRetractDate();\n\t\t\tCollection<String> groups = sc.getSerializableGroup();\n\t\t\tbyte[] body = sc.getSerializableBody();\n\t\t\tString contentType = sc.getSerializableContentType();\n\t\t\tString filePath = sc.getSerializableFilePath();\n\t\t\tString resourceType = sc.getSerializableResourceType();\n\t\t\tlong contentLength = sc.getSerializableContentLength();\n\t\t\t\n\t\t\tif ( contentType == null ) {\n\t\t\t\tcontentType = \"\";\n\t\t\t}\n\t\t\tif ( filePath == null ) {\n\t\t\t\tfilePath = \"\";\n\t\t\t}\n\t\t\tif ( resourceType == null ) {\n\t\t\t\tresourceType = ResourceType.TYPE_UPLOAD;\n\t\t\t}\n\n\t\t\tif (body != null) contentLength = body.length;\n\n\t\t\tif (access == null || AccessMode.SITE == access)\n\t\t\t{\n\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t}\n\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tDataOutputStream ds = new DataOutputStream(baos);\n\t\t\tds.writeInt(TYPE1);\n\t\t\tds.writeInt(BLOCK1);\n\t\t\tds.writeUTF(id);\n\t\t\tds.writeUTF(resourceType);\n\t\t\tds.writeUTF(access.toString());\n\t\t\tds.writeBoolean(hidden);\n\t\t\tds.writeInt(BLOCK2);\n\t\t\tif (!hidden && releaseDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(releaseDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (!hidden && retractDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(retractDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (groups != null)\n\t\t\t{\n\t\t\t\tds.writeInt(BLOCK3);\n\t\t\t\tds.writeInt(groups.size());\n\t\t\t\tfor (Iterator igroup = groups.iterator(); igroup.hasNext();)\n\t\t\t\t{\n\t\t\t\t\tString groupRef = (String) igroup.next();\n\t\t\t\t\tds.writeUTF(groupRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds.writeInt(BLOCK4);\n\t\t\tbaseResourcePropertiesSerializer\n\t\t\t\t\t.serialize(sc.getSerializableProperties(), ds);\n\t\t\tds.writeInt(BLOCK5);\n\t\t\tds.writeUTF(contentType);\n\t\t\tds.writeLong(contentLength);\n\t\t\tds.writeUTF(filePath);\n\n\t\t\tif (body != null)\n\t\t\t{\n\t\t\t\tds.writeInt(BLOCK6);\n\t\t\t\tds.writeInt(body.length);\n\t\t\t\tds.write(body);\n\t\t\t}\n\t\t\tds.writeInt(BLOCK_END);\n\t\t\tds.flush();\n\t\t\tbaos.flush();\n\t\t\tbyte[] op = baos.toByteArray();\n\t\t\tint bid = BLOB_ID.length();\n\t\t\tchar[] opc = new char[op.length + bid];\n\t\t\tfor (int i = 0; i < bid; i++)\n\t\t\t{\n\t\t\t\topc[i] = BLOB_ID.charAt(i);\n\t\t\t}\n\t\t\tfor (int i = bid; i < opc.length; i++)\n\t\t\t{\n\t\t\t\topc[i] = (char) op[i-bid];\n\t\t\t}\n\t\t\treturn new String(opc);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to serialize entity \", ex);\n\t\t}\n\t}","id":42679,"modified_method":"public String serialize(SerializableEntity se) throws EntityParseException\n\t{\n\t\tif (!(se instanceof SerializableResourceAccess))\n\t\t{\n\t\t\tthrow new EntityParseException(\"Cant serialize \" + se\n\t\t\t\t\t+ \" as it is not a SerializableResourceAccess \");\n\t\t}\n\t\tSerializableResourceAccess sc = (SerializableResourceAccess) se;\n\n\t\ttry\n\t\t{\n\t\t\tString id = sc.getSerializableId();\n\t\t\tboolean hidden = sc.getSerializableHidden();\n\t\t\tAccessMode access = sc.getSerializableAccess();\n\t\t\tTime releaseDate = sc.getSerializableReleaseDate();\n\t\t\tTime retractDate = sc.getSerializableRetractDate();\n\t\t\tCollection<String> groups = sc.getSerializableGroup();\n\t\t\tbyte[] body = sc.getSerializableBody();\n\t\t\tString contentType = sc.getSerializableContentType();\n\t\t\tString filePath = sc.getSerializableFilePath();\n\t\t\tString resourceType = sc.getSerializableResourceType();\n\t\t\tlong contentLength = sc.getSerializableContentLength();\n\t\t\t\n\t\t\tif ( contentType == null ) {\n\t\t\t\tcontentType = \"\";\n\t\t\t}\n\t\t\tif ( filePath == null ) {\n\t\t\t\tfilePath = \"\";\n\t\t\t}\n\t\t\tif ( resourceType == null ) {\n\t\t\t\tresourceType = ResourceType.TYPE_UPLOAD;\n\t\t\t}\n\n\t\t\tif (body != null) contentLength = body.length;\n\n\t\t\tif (access == null || AccessMode.SITE == access)\n\t\t\t{\n\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t}\n\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tDataOutputStream ds = new DataOutputStream(baos);\n\t\t\tds.writeInt(TYPE1);\n\t\t\tds.writeInt(BLOCK1);\n\t\t\tds.writeUTF(id);\n\t\t\tds.writeUTF(resourceType);\n\t\t\tds.writeUTF(access.toString());\n\t\t\tds.writeBoolean(hidden);\n\t\t\tds.writeInt(BLOCK2);\n\t\t\tif (!hidden && releaseDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(releaseDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (!hidden && retractDate != null)\n\t\t\t{\n\t\t\t\tds.writeLong(retractDate.getTime());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds.writeLong(-1);\n\t\t\t}\n\t\t\tif (groups != null)\n\t\t\t{\n\t\t\t\tds.writeInt(BLOCK3);\n\t\t\t\tds.writeInt(groups.size());\n\t\t\t\tfor (Iterator igroup = groups.iterator(); igroup.hasNext();)\n\t\t\t\t{\n\t\t\t\t\tString groupRef = (String) igroup.next();\n\t\t\t\t\tds.writeUTF(groupRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds.writeInt(BLOCK4);\n\t\t\tbaseResourcePropertiesSerializer\n\t\t\t\t\t.serialize(sc.getSerializableProperties(), ds);\n\t\t\tds.writeInt(BLOCK5);\n\t\t\tds.writeUTF(contentType);\n\t\t\tds.writeLong(contentLength);\n\t\t\tds.writeUTF(filePath);\n\n\t\t\tif (body != null)\n\t\t\t{\n\t\t\t\tds.writeInt(BLOCK6);\n\t\t\t\tds.writeInt(body.length);\n\t\t\t\tds.write(body);\n\t\t\t}\n\t\t\tds.writeInt(BLOCK_END);\n\t\t\tds.flush();\n\t\t\tbaos.flush();\n\t\t\tbyte[] op = baos.toByteArray();\n\t\t\tint bid = BLOB_ID.length();\n\t\t\tchar[] opc = new char[op.length + bid];\n\t\t\t\n\t\t\t\n\t\t\tByteStorageConversion.toChar(op, 0, opc, bid, op.length);\n\t\t\t\n\t\t\tfor (int i = 0; i < bid; i++)\n\t\t\t{\n\t\t\t\topc[i] = BLOB_ID.charAt(i);\n\t\t\t}\n\t\t\treturn new String(opc);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to serialize entity \", ex);\n\t\t}\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void parse(SerializableEntity se, String serialized)\n\t\t\tthrows EntityParseException\n\t{\n\n\t\tif (!(se instanceof SerializableResourceAccess))\n\t\t{\n\t\t\tthrow new EntityParseException(\"Cant serialize \" + se\n\t\t\t\t\t+ \" as it is not a SerializableResourceAccess \");\n\t\t}\n\t\tSerializableResourceAccess sc = (SerializableResourceAccess) se;\n\t\tString id = null;\n\n\t\ttry\n\t\t{\n\n\t\t\tif (!serialized.startsWith(BLOB_ID))\n\t\t\t{\n\t\t\t\tthrow new EntityParseException(\n\t\t\t\t\t\t\"Data Block does not belong to this serializer got [\"\n\t\t\t\t\t\t\t\t+ serialized.substring(0, BLOB_ID.length())\n\t\t\t\t\t\t\t\t+ \"] expected [\" + BLOB_ID + \"]\");\n\t\t\t}\n\t\t\tchar[] cbuf = serialized.toCharArray();\n\t\t\tint blobIdLength = BLOB_ID.length();\n\t\t\tbyte[] sb = new byte[cbuf.length - blobIdLength];\n\t\t\tfor (int i = blobIdLength; i < cbuf.length; i++)\n\t\t\t{\n\t\t\t\tsb[i - blobIdLength] = (byte) cbuf[i];\n\t\t\t}\n\n\t\t\tAccessMode access = AccessMode.INHERITED;\n\t\t\tboolean hidden = false;\n\t\t\tString resourceType = ResourceType.TYPE_UPLOAD;\n\t\t\tTime releaseDate = null;\n\t\t\tTime retractDate = null;\n\t\t\tCollection<String> groups = new Vector<String>();\n\t\t\tString contentType = null;\n\t\t\tlong contentLength = 0;\n\t\t\tString filePath = null;\n\t\t\tbyte[] body = null;\n\n\t\t\tByteArrayInputStream baos = new ByteArrayInputStream(sb);\n\t\t\tDataInputStream ds = new DataInputStream(baos);\n\t\t\tint type = ds.readInt();\n\t\t\tif (type == TYPE1)\n\t\t\t{\n\t\t\t\tboolean finished = false;\n\t\t\t\twhile (!finished)\n\t\t\t\t{\n\t\t\t\t\tint block = ds.readInt();\n\t\t\t\t\tswitch (block)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase BLOCK1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid = ds.readUTF();\n\t\t\t\t\t\t\tresourceType = ds.readUTF();\n\t\t\t\t\t\t\taccess = AccessMode.fromString(ds.readUTF());\n\t\t\t\t\t\t\tif (access == null || AccessMode.SITE == access)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\thidden = ds.readBoolean();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong rd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hidden)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = null;\n\t\t\t\t\t\t\t\tretractDate = null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK3:\n\t\t\t\t\t\t\tint sz = ds.readInt();\n\t\t\t\t\t\t\tfor (int i = 0; i < sz; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroups.add(ds.readUTF());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK4:\n\t\t\t\t\t\t\tbaseResourcePropertiesSerializer.parse(sc\n\t\t\t\t\t\t\t\t\t.getSerializableProperties(), ds);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK5:\n\t\t\t\t\t\t\tcontentType = ds.readUTF();\n\t\t\t\t\t\t\tcontentLength = ds.readLong();\n\t\t\t\t\t\t\tfilePath = ds.readUTF();\n\n\t\t\t\t\t\t\tResourceTypeRegistry registry = sc.getResourceTypeRegistry();\n\t\t\t\t\t\t\tif (resourceType == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (registry != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceType = registry\n\t\t\t\t\t\t\t\t\t\t\t.mimetype2resourcetype(contentType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( resourceType == null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceType = ResourceType.TYPE_UPLOAD;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK6:\n\t\t\t\t\t\t\tbody = new byte[ds.readInt()];\n\t\t\t\t\t\t\tds.read(body);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK_END:\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new EntityParseException(\"Unrecognised Record Type \" + type);\n\t\t\t}\n\t\t\t\n\t\t\tsc.setSerializableId(id);\n\t\t\tsc.setSerializableAccess(access);\n\t\t\tsc.setSerializableHidden(hidden);\n\t\t\tsc.setSerializableResourceType(resourceType);\n\t\t\tsc.setSerializableReleaseDate(releaseDate);\n\t\t\tsc.setSerializableRetractDate(retractDate);\n\t\t\tsc.setSerializableGroups(groups);\n\t\t\tsc.setSerializableContentType(contentType);\n\t\t\tsc.setSerializableContentLength(contentLength);\n\t\t\tsc.setSerializableFilePath(filePath);\n\t\t\tsc.setSerializableBody(body);\n\n\t\t}\n\t\tcatch (EntityParseException epe)\n\t\t{\n\t\t\tthrow epe;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to parse entity [\"+id+\"]\", ex);\n\t\t}\n\t}","id":42680,"modified_method":"public void parse(SerializableEntity se, String serialized)\n\t\t\tthrows EntityParseException\n\t{\n\n\t\tif (!(se instanceof SerializableResourceAccess))\n\t\t{\n\t\t\tthrow new EntityParseException(\"Cant serialize \" + se\n\t\t\t\t\t+ \" as it is not a SerializableResourceAccess \");\n\t\t}\n\t\tSerializableResourceAccess sc = (SerializableResourceAccess) se;\n\t\tString id = null;\n\n\t\ttry\n\t\t{\n\n\t\t\tif (!serialized.startsWith(BLOB_ID))\n\t\t\t{\n\t\t\t\tthrow new EntityParseException(\n\t\t\t\t\t\t\"Data Block does not belong to this serializer got [\"\n\t\t\t\t\t\t\t\t+ serialized\n\t\t\t\t\t\t\t\t+ \"] expected [\" + BLOB_ID + \"]\");\n\t\t\t}\n\t\t\tchar[] cbuf = serialized.toCharArray();\n\t\t\tint blobIdLength = BLOB_ID.length();\n\t\t\tbyte[] sb = new byte[cbuf.length - blobIdLength];\n\t\t\t\n\t\t\tByteStorageConversion.toByte(cbuf, BLOB_ID.length(), sb, 0, sb.length);\n\n\t\t\tAccessMode access = AccessMode.INHERITED;\n\t\t\tboolean hidden = false;\n\t\t\tString resourceType = ResourceType.TYPE_UPLOAD;\n\t\t\tTime releaseDate = null;\n\t\t\tTime retractDate = null;\n\t\t\tCollection<String> groups = new Vector<String>();\n\t\t\tString contentType = null;\n\t\t\tlong contentLength = 0;\n\t\t\tString filePath = null;\n\t\t\tbyte[] body = null;\n\n\t\t\tByteArrayInputStream baos = new ByteArrayInputStream(sb);\n\t\t\tDataInputStream ds = new DataInputStream(baos);\n\t\t\tint type = ds.readInt();\n\t\t\tif (type == TYPE1)\n\t\t\t{\n\t\t\t\tboolean finished = false;\n\t\t\t\twhile (!finished)\n\t\t\t\t{\n\t\t\t\t\tint block = ds.readInt();\n\t\t\t\t\tswitch (block)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase BLOCK1:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid = ds.readUTF();\n\t\t\t\t\t\t\tresourceType = ds.readUTF();\n\t\t\t\t\t\t\taccess = AccessMode.fromString(ds.readUTF());\n\t\t\t\t\t\t\tif (access == null || AccessMode.SITE == access)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taccess = AccessMode.INHERITED;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\thidden = ds.readBoolean();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK2:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlong rd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trd = ds.readLong();\n\t\t\t\t\t\t\tif (rd != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = timeService.newTime(rd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tretractDate = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (hidden)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treleaseDate = null;\n\t\t\t\t\t\t\t\tretractDate = null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK3:\n\t\t\t\t\t\t\tint sz = ds.readInt();\n\t\t\t\t\t\t\tfor (int i = 0; i < sz; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroups.add(ds.readUTF());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK4:\n\t\t\t\t\t\t\tbaseResourcePropertiesSerializer.parse(sc\n\t\t\t\t\t\t\t\t\t.getSerializableProperties(), ds);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK5:\n\t\t\t\t\t\t\tcontentType = ds.readUTF();\n\t\t\t\t\t\t\tcontentLength = ds.readLong();\n\t\t\t\t\t\t\tfilePath = ds.readUTF();\n\n\t\t\t\t\t\t\tResourceTypeRegistry registry = sc.getResourceTypeRegistry();\n\t\t\t\t\t\t\tif (resourceType == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (registry != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceType = registry\n\t\t\t\t\t\t\t\t\t\t\t.mimetype2resourcetype(contentType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( resourceType == null )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresourceType = ResourceType.TYPE_UPLOAD;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK6:\n\t\t\t\t\t\t\tbody = new byte[ds.readInt()];\n\t\t\t\t\t\t\tds.read(body);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase BLOCK_END:\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new EntityParseException(\"Unrecognised Record Type \" + type);\n\t\t\t}\n\t\t\t\n\t\t\tsc.setSerializableId(id);\n\t\t\tsc.setSerializableAccess(access);\n\t\t\tsc.setSerializableHidden(hidden);\n\t\t\tsc.setSerializableResourceType(resourceType);\n\t\t\tsc.setSerializableReleaseDate(releaseDate);\n\t\t\tsc.setSerializableRetractDate(retractDate);\n\t\t\tsc.setSerializableGroups(groups);\n\t\t\tsc.setSerializableContentType(contentType);\n\t\t\tsc.setSerializableContentLength(contentLength);\n\t\t\tsc.setSerializableFilePath(filePath);\n\t\t\tsc.setSerializableBody(body);\n\n\t\t}\n\t\tcatch (EntityParseException epe)\n\t\t{\n\t\t\tthrow epe;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tthrow new EntityParseException(\"Failed to parse entity [\"+id+\"]\", ex);\n\t\t}\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @throws Exception\n\t * @throws Exception\n\t */\n\tprivate void convert(String config) throws Exception\n\t{\n\n\t\tDriverAdapterCPDS cpds = new DriverAdapterCPDS();\n\n\t\tProperties p = new Properties();\n\t\tif (config != null)\n\t\t{\n\t\t\tlog.info(\"Using Config \" + config);\n\t\t\tFile f = new File(config);\n\t\t\tFileInputStream fin = new FileInputStream(config);\n\t\t\tp.load(fin);\n\t\t\tfin.close();\n\t\t\tfor (Iterator<Object> i = p.keySet().iterator(); i.hasNext();)\n\t\t\t{\n\t\t\t\tObject k = i.next();\n\t\t\t\tlog.info(\"   Test Properties \" + k + \":\" + p.get(k));\n\t\t\t}\n\t\t}\n\n\t\tcpds.setDriver(p.getProperty(\"dbDriver\", \"com.mysql.jdbc.Driver\"));\n\t\tcpds\n\t\t\t\t.setUrl(p\n\t\t\t\t\t\t.getProperty(\"dbURL\",\n\t\t\t\t\t\t\t\t\"jdbc:mysql://127.0.0.1:3306/sakai22?useUnicode=true&characterEncoding=UTF-8\"));\n\t\tcpds.setUser(p.getProperty(\"dbUser\", \"sakai22\"));\n\t\tcpds.setPassword(p.getProperty(\"dbPass\", \"sakai22\"));\n\n\t\ttds = new SharedPoolDataSource();\n\t\ttds.setConnectionPoolDataSource(cpds);\n\t\ttds.setMaxActive(10);\n\t\ttds.setMaxWait(5);\n\t\ttds.setDefaultAutoCommit(false);\n\n\t\tdoMigrate();\n\n\t\ttds.close();\n\n\t}","id":42681,"modified_method":"/**\n\t * @throws Exception\n\t * @throws Exception\n\t */\n\tprivate void convert(String config) throws Exception\n\t{\n\n\t\tDriverAdapterCPDS cpds = new DriverAdapterCPDS();\n\n\t\tProperties p = new Properties();\n\t\tif (config != null)\n\t\t{\n\t\t\tlog.info(\"Using Config \" + config);\n\t\t\tFile f = new File(config);\n\t\t\tFileInputStream fin = new FileInputStream(config);\n\t\t\tp.load(fin);\n\t\t\tfin.close();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (Iterator<Object> i = p.keySet().iterator(); i.hasNext();)\n\t\t\t{\n\t\t\t\tObject k = i.next();\n\t\t\t\tsb.append(\"\\n \" + k + \":\" + p.get(k));\n\t\t\t}\n\t\t\tlog.info(\"Loaded Properties from \" + config + \" as \" + sb.toString());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp.load(this.getClass().getResourceAsStream(\"upgradeschema.config\"));\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (Iterator<Object> i = p.keySet().iterator(); i.hasNext();)\n\t\t\t{\n\t\t\t\tObject k = i.next();\n\t\t\t\tsb.append(\"\\n \" + k + \":\" + p.get(k));\n\t\t\t}\n\t\t\tlog.info(\"Loaded Default Properties \" + config + \" as \" + sb.toString());\n\t\t}\n\n\t\tcpds.setDriver(p.getProperty(\"dbDriver\"));\n\t\tcpds.setUrl(p.getProperty(\"dbURL\"));\n\t\tcpds.setUser(p.getProperty(\"dbUser\"));\n\t\tcpds.setPassword(p.getProperty(\"dbPass\"));\n\n\t\ttds = new SharedPoolDataSource();\n\t\ttds.setConnectionPoolDataSource(cpds);\n\t\ttds.setMaxActive(10);\n\t\ttds.setMaxWait(5);\n\t\ttds.setDefaultAutoCommit(false);\n\n\t\tCheckConnection cc = new CheckConnection();\n\t\tcc.check(tds);\n\n\t\tList<SchemaConversionDriver> sequence = new ArrayList<SchemaConversionDriver>();\n\t\tint k = 0;\n\t\twhile(true) {\n\t\t\tif ( p.get(\"convert.\"+k) != null ) {\n\t\t\t\tSchemaConversionDriver s = new SchemaConversionDriver();\n\t\t\t\ts.load(p, \"convert.\"+k);\n\t\t\t\tsequence.add(s);\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\n\t\t}\n\n\t\tdoMigrate(sequence);\n\n\t\ttds.close();\n\n\t}","commit_id":"6df7f61920d07fc58e23256ab5d3f279e10f3e7b","url":"https://github.com/sakaiproject/sakai"},{"original_method":"abstract void migrate(@NotNull Project project,\n                        @NotNull ProblemDescriptor descriptor,\n                        @NotNull PsiForeachStatement foreachStatement,\n                        @NotNull PsiExpression iteratedValue,\n                        @NotNull PsiStatement body,\n                        @NotNull TerminalBlock tb);","id":42682,"modified_method":"abstract PsiElement migrate(@NotNull Project project,\n                        @NotNull ProblemDescriptor descriptor,\n                        @NotNull PsiForeachStatement foreachStatement,\n                        @NotNull PsiExpression iteratedValue,\n                        @NotNull PsiStatement body,\n                        @NotNull TerminalBlock tb);","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void replaceInitializer(PsiForeachStatement foreachStatement,\n                                 PsiVariable var,\n                                 PsiExpression initializer,\n                                 String replacement,\n                                 InitializerUsageStatus status) {\n    Project project = foreachStatement.getProject();\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    if(status == InitializerUsageStatus.DECLARED_JUST_BEFORE) {\n      initializer.replace(elementFactory.createExpressionFromText(replacement, foreachStatement));\n      removeLoop(foreachStatement);\n      simplifyAndFormat(project, var);\n    } else {\n      if(status == InitializerUsageStatus.AT_WANTED_PLACE_ONLY) {\n        initializer.delete();\n      }\n      PsiElement result =\n        foreachStatement.replace(elementFactory.createStatementFromText(var.getName() + \" = \" + replacement + \";\", foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","id":42683,"modified_method":"static PsiElement replaceInitializer(PsiForeachStatement foreachStatement,\n                                 PsiVariable var,\n                                 PsiExpression initializer,\n                                 String replacement,\n                                 InitializerUsageStatus status) {\n    Project project = foreachStatement.getProject();\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    if(status == InitializerUsageStatus.DECLARED_JUST_BEFORE) {\n      initializer.replace(elementFactory.createExpressionFromText(replacement, foreachStatement));\n      removeLoop(foreachStatement);\n      return var;\n    } else {\n      if(status == InitializerUsageStatus.AT_WANTED_PLACE_ONLY) {\n        initializer.delete();\n      }\n      return\n        foreachStatement.replace(elementFactory.createStatementFromText(var.getName() + \" = \" + replacement + \";\", foreachStatement));\n    }\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement element = descriptor.getPsiElement();\n    if (element instanceof PsiForeachStatement) {\n      PsiForeachStatement foreachStatement = (PsiForeachStatement)element;\n      PsiStatement body = foreachStatement.getBody();\n      final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n      if (body != null && iteratedValue != null) {\n        final PsiParameter parameter = foreachStatement.getIterationParameter();\n        TerminalBlock tb = TerminalBlock.from(parameter, body);\n        if (!FileModificationService.getInstance().preparePsiElementForWrite(foreachStatement)) return;\n        migrate(project, descriptor, foreachStatement, iteratedValue, body, tb);\n      }\n    }\n  }","id":42684,"modified_method":"@Override\n  public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n    PsiElement element = descriptor.getPsiElement();\n    if (element instanceof PsiForeachStatement) {\n      PsiForeachStatement foreachStatement = (PsiForeachStatement)element;\n      PsiStatement body = foreachStatement.getBody();\n      final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n      if (body != null && iteratedValue != null) {\n        final PsiParameter parameter = foreachStatement.getIterationParameter();\n        TerminalBlock tb = TerminalBlock.from(parameter, body);\n        if (!FileModificationService.getInstance().preparePsiElementForWrite(foreachStatement)) return;\n        PsiElement result = migrate(project, descriptor, foreachStatement, iteratedValue, body, tb);\n        if(result != null) {\n          simplifyAndFormat(project, result);\n        }\n      }\n    }\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void replaceWithNumericAddition(@NotNull Project project,\n                                         PsiForeachStatement foreachStatement,\n                                         PsiVariable var,\n                                         StringBuilder builder,\n                                         PsiType expressionType) {\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    restoreComments(foreachStatement, foreachStatement.getBody());\n    InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n    if (status != InitializerUsageStatus.UNKNOWN) {\n      PsiExpression initializer = var.getInitializer();\n      if (ExpressionUtils.isZero(initializer)) {\n        PsiType type = var.getType();\n        String replacement = (type.equals(expressionType) ? \"\" : \"(\" + type.getCanonicalText() + \") \") + builder;\n        replaceInitializer(foreachStatement, var, initializer, replacement, status);\n        return;\n      }\n    }\n    PsiElement result =\n      foreachStatement.replace(elementFactory.createStatementFromText(var.getName() + \"+=\" + builder + \";\", foreachStatement));\n    simplifyAndFormat(project, result);\n  }","id":42685,"modified_method":"static PsiElement replaceWithNumericAddition(@NotNull Project project,\n                                               PsiForeachStatement foreachStatement,\n                                               PsiVariable var,\n                                               StringBuilder builder,\n                                               PsiType expressionType) {\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    restoreComments(foreachStatement, foreachStatement.getBody());\n    InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n    if (status != InitializerUsageStatus.UNKNOWN) {\n      PsiExpression initializer = var.getInitializer();\n      if (ExpressionUtils.isZero(initializer)) {\n        PsiType type = var.getType();\n        String replacement = (type.equals(expressionType) ? \"\" : \"(\" + type.getCanonicalText() + \") \") + builder;\n        return replaceInitializer(foreachStatement, var, initializer, replacement, status);\n      }\n    }\n    return foreachStatement.replace(elementFactory.createStatementFromText(var.getName() + \"+=\" + builder + \";\", foreachStatement));\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final PsiType iteratedValueType = iteratedValue.getType();\n    final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n\n    if (methodCallExpression == null) return;\n\n    restoreComments(foreachStatement, body);\n    if (!tb.hasOperations() && StreamApiMigrationInspection.isAddAllCall(tb)) {\n      final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n      final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() : \"\";\n      final String collectionText =\n        iteratedValueType instanceof PsiArrayType ? \"java.util.Arrays.asList(\" + iteratedValue.getText() + \")\" :\n        getIteratedValueText(iteratedValue);\n      final String callText = StringUtil.getQualifiedName(qualifierText, \"addAll(\" + collectionText + \");\");\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n      simplifyAndFormat(project, result);\n      return;\n    }\n    PsiExpression itemToAdd = methodCallExpression.getArgumentList().getExpressions()[0];\n    PsiType addedType = getAddedElementType(methodCallExpression);\n    if (addedType == null) addedType = itemToAdd.getType();\n    final StringBuilder builder =\n      generateStream(iteratedValue, new StreamApiMigrationInspection.MapOp(tb.getLastOperation(), itemToAdd, tb.getVariable(), addedType));\n\n    final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n    final PsiLocalVariable variable = StreamApiMigrationInspection.extractCollectionVariable(qualifierExpression);\n    if (variable != null) {\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(variable, foreachStatement);\n      if(status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = variable.getInitializer();\n        LOG.assertTrue(initializer != null);\n        PsiMethodCallExpression toArrayExpression =\n          StreamApiMigrationInspection.extractToArrayExpression(foreachStatement, methodCallExpression);\n        if(toArrayExpression != null) {\n          PsiType type = initializer.getType();\n          if(type instanceof PsiClassType) {\n            String replacement = StreamApiMigrationInspection.COLLECTION_TO_ARRAY.get(((PsiClassType)type).rawType().getCanonicalText());\n            if(replacement != null) {\n              builder.append(\".\").append(replacement);\n              PsiExpression[] args = toArrayExpression.getArgumentList().getExpressions();\n              if(args.length == 0) {\n                builder.append(\"()\");\n              } else {\n                if(args.length != 1 || !(args[0] instanceof PsiNewExpression)) return;\n                PsiNewExpression newArray = (PsiNewExpression)args[0];\n                PsiType arrayType = newArray.getType();\n                if(arrayType == null) return;\n                String name = arrayType.getCanonicalText();\n                builder.append('(').append(name).append(\"::new)\");\n              }\n              PsiElement result =\n                toArrayExpression.replace(elementFactory.createExpressionFromText(builder.toString(), toArrayExpression));\n              removeLoop(foreachStatement);\n              if(status != InitializerUsageStatus.AT_WANTED_PLACE) {\n                variable.delete();\n              }\n              simplifyAndFormat(project, result);\n              return;\n            }\n          }\n        }\n        String callText = builder.append(\".collect(java.util.stream.Collectors.\")\n          .append(createInitializerReplacementText(qualifierExpression.getType(), initializer))\n          .append(\")\").toString();\n        replaceInitializer(foreachStatement, variable, initializer, callText, status);\n        return;\n      }\n    }\n    final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() + \".\" : \"\";\n\n    JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    SuggestedNameInfo suggestedNameInfo =\n      codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, null, null, addedType, false);\n    if (suggestedNameInfo.names.length == 0) {\n      suggestedNameInfo = codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, \"item\", null, itemToAdd.getType(), false);\n    }\n    String varName = codeStyleManager.suggestUniqueVariableName(suggestedNameInfo, methodCallExpression, false).names[0];\n\n    PsiExpression forEachBody =\n      elementFactory.createExpressionFromText(qualifierText + \"add(\" + varName + \")\", qualifierExpression);\n    final String callText =\n      builder.append(\".forEach(\").append(varName).append(\"->\").append(forEachBody.getText()).append(\");\").toString();\n    PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n    simplifyAndFormat(project, result);\n  }","id":42686,"modified_method":"@Override\n  PsiElement migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    final PsiType iteratedValueType = iteratedValue.getType();\n    final PsiMethodCallExpression methodCallExpression = tb.getSingleMethodCall();\n\n    if (methodCallExpression == null) return null;\n\n    restoreComments(foreachStatement, body);\n    if (!tb.hasOperations() && StreamApiMigrationInspection.isAddAllCall(tb)) {\n      final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n      final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() : \"\";\n      final String collectionText =\n        iteratedValueType instanceof PsiArrayType ? \"java.util.Arrays.asList(\" + iteratedValue.getText() + \")\" :\n        getIteratedValueText(iteratedValue);\n      final String callText = StringUtil.getQualifiedName(qualifierText, \"addAll(\" + collectionText + \");\");\n      return foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n    }\n    PsiExpression itemToAdd = methodCallExpression.getArgumentList().getExpressions()[0];\n    PsiType addedType = getAddedElementType(methodCallExpression);\n    if (addedType == null) addedType = itemToAdd.getType();\n    final StringBuilder builder =\n      generateStream(iteratedValue, new StreamApiMigrationInspection.MapOp(tb.getLastOperation(), itemToAdd, tb.getVariable(), addedType));\n\n    final PsiExpression qualifierExpression = methodCallExpression.getMethodExpression().getQualifierExpression();\n    final PsiLocalVariable variable = StreamApiMigrationInspection.extractCollectionVariable(qualifierExpression);\n    if (variable != null) {\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(variable, foreachStatement);\n      if(status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = variable.getInitializer();\n        LOG.assertTrue(initializer != null);\n        PsiMethodCallExpression toArrayExpression =\n          StreamApiMigrationInspection.extractToArrayExpression(foreachStatement, methodCallExpression);\n        if(toArrayExpression != null) {\n          PsiType type = initializer.getType();\n          if(type instanceof PsiClassType) {\n            String replacement = StreamApiMigrationInspection.COLLECTION_TO_ARRAY.get(((PsiClassType)type).rawType().getCanonicalText());\n            if(replacement != null) {\n              builder.append(\".\").append(replacement);\n              PsiExpression[] args = toArrayExpression.getArgumentList().getExpressions();\n              if(args.length == 0) {\n                builder.append(\"()\");\n              } else {\n                if(args.length != 1 || !(args[0] instanceof PsiNewExpression)) return null;\n                PsiNewExpression newArray = (PsiNewExpression)args[0];\n                PsiType arrayType = newArray.getType();\n                if(arrayType == null) return null;\n                String name = arrayType.getCanonicalText();\n                builder.append('(').append(name).append(\"::new)\");\n              }\n              PsiElement result =\n                toArrayExpression.replace(elementFactory.createExpressionFromText(builder.toString(), toArrayExpression));\n              removeLoop(foreachStatement);\n              if(status != InitializerUsageStatus.AT_WANTED_PLACE) {\n                variable.delete();\n              }\n              return result;\n            }\n          }\n        }\n        String callText = builder.append(\".collect(java.util.stream.Collectors.\")\n          .append(createInitializerReplacementText(qualifierExpression.getType(), initializer))\n          .append(\")\").toString();\n        return replaceInitializer(foreachStatement, variable, initializer, callText, status);\n      }\n    }\n    final String qualifierText = qualifierExpression != null ? qualifierExpression.getText() + \".\" : \"\";\n\n    JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(project);\n    SuggestedNameInfo suggestedNameInfo =\n      codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, null, null, addedType, false);\n    if (suggestedNameInfo.names.length == 0) {\n      suggestedNameInfo = codeStyleManager.suggestVariableName(VariableKind.LOCAL_VARIABLE, \"item\", null, itemToAdd.getType(), false);\n    }\n    String varName = codeStyleManager.suggestUniqueVariableName(suggestedNameInfo, methodCallExpression, false).names[0];\n\n    PsiExpression forEachBody =\n      elementFactory.createExpressionFromText(qualifierText + \"add(\" + varName + \")\", qualifierExpression);\n    final String callText =\n      builder.append(\".forEach(\").append(varName).append(\"->\").append(forEachBody.getText()).append(\");\").toString();\n    return foreachStatement.replace(elementFactory.createStatementFromText(callText, foreachStatement));\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiExpression operand = StreamApiMigrationInspection.extractIncrementedLValue(tb.getSingleExpression(PsiExpression.class));\n    if (!(operand instanceof PsiReferenceExpression)) return;\n    PsiElement element = ((PsiReferenceExpression)operand).resolve();\n    if (!(element instanceof PsiLocalVariable)) return;\n    PsiLocalVariable var = (PsiLocalVariable)element;\n    final StringBuilder builder = generateStream(iteratedValue, tb.getLastOperation());\n    builder.append(\".count()\");\n    replaceWithNumericAddition(project, foreachStatement, var, builder, PsiType.LONG);\n  }","id":42687,"modified_method":"@Override\n  PsiElement migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiExpression operand = StreamApiMigrationInspection.extractIncrementedLValue(tb.getSingleExpression(PsiExpression.class));\n    if (!(operand instanceof PsiReferenceExpression)) return null;\n    PsiElement element = ((PsiReferenceExpression)operand).resolve();\n    if (!(element instanceof PsiLocalVariable)) return null;\n    PsiLocalVariable var = (PsiLocalVariable)element;\n    final StringBuilder builder = generateStream(iteratedValue, tb.getLastOperation());\n    builder.append(\".count()\");\n    return replaceWithNumericAddition(project, foreachStatement, var, builder, PsiType.LONG);\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiStatement statement = tb.getSingleStatement();\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    String stream = generateStream(iteratedValue, tb.getLastOperation()).append(\".findFirst()\").toString();\n    if (statement instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)statement;\n      PsiExpression value = returnStatement.getReturnValue();\n      if (value == null) return;\n      PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n      if (nextReturnStatement == null) return;\n      PsiExpression orElseExpression = nextReturnStatement.getReturnValue();\n      if (!ExpressionUtils.isSimpleExpression(orElseExpression)) return;\n      stream = generateOptionalUnwrap(stream, tb, value, orElseExpression, null);\n      restoreComments(foreachStatement, body);\n      boolean siblings = nextReturnStatement.getParent() == foreachStatement.getParent();\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + stream + \";\", foreachStatement));\n      if (siblings) {\n        nextReturnStatement.delete();\n      }\n      simplifyAndFormat(project, result);\n    }\n    else {\n      PsiStatement[] statements = tb.getStatements();\n      if (statements.length != 2) return;\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statements[0]);\n      if (assignment == null) {\n        if(!(statements[0] instanceof PsiExpressionStatement)) return;\n        PsiExpression expression = ((PsiExpressionStatement)statements[0]).getExpression();\n        restoreComments(foreachStatement, body);\n        PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\n          stream + \".ifPresent(\" + LambdaUtil.createLambda(tb.getVariable(), expression) + \");\", foreachStatement));\n        simplifyAndFormat(project, result);\n        return;\n      }\n      PsiExpression lValue = assignment.getLExpression();\n      if (!(lValue instanceof PsiReferenceExpression)) return;\n      PsiElement element = ((PsiReferenceExpression)lValue).resolve();\n      if (!(element instanceof PsiVariable)) return;\n      PsiVariable var = (PsiVariable)element;\n      PsiExpression value = assignment.getRExpression();\n      if (value == null) return;\n      restoreComments(foreachStatement, body);\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n      if (status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = var.getInitializer();\n        if (initializer != null) {\n          String replacementText = generateOptionalUnwrap(stream, tb, value, initializer, var.getType());\n          replaceInitializer(foreachStatement, var, initializer, replacementText, status);\n          return;\n        }\n      }\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(\n        var.getName() + \" = \" + generateOptionalUnwrap(stream, tb, value, lValue, var.getType()) + \";\", foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","id":42688,"modified_method":"@Override\n  PsiElement migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiStatement statement = tb.getSingleStatement();\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    String stream = generateStream(iteratedValue, tb.getLastOperation()).append(\".findFirst()\").toString();\n    if (statement instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)statement;\n      PsiExpression value = returnStatement.getReturnValue();\n      if (value == null) return null;\n      PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n      if (nextReturnStatement == null) return null;\n      PsiExpression orElseExpression = nextReturnStatement.getReturnValue();\n      if (!ExpressionUtils.isSimpleExpression(orElseExpression)) return null;\n      stream = generateOptionalUnwrap(stream, tb, value, orElseExpression, null);\n      restoreComments(foreachStatement, body);\n      if (nextReturnStatement.getParent() == foreachStatement.getParent()) {\n        nextReturnStatement.delete();\n      }\n      return foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + stream + \";\", foreachStatement));\n    }\n    else {\n      PsiStatement[] statements = tb.getStatements();\n      if (statements.length != 2) return null;\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statements[0]);\n      if (assignment == null) {\n        if(!(statements[0] instanceof PsiExpressionStatement)) return null;\n        PsiExpression expression = ((PsiExpressionStatement)statements[0]).getExpression();\n        restoreComments(foreachStatement, body);\n        return foreachStatement.replace(elementFactory.createStatementFromText(\n          stream + \".ifPresent(\" + LambdaUtil.createLambda(tb.getVariable(), expression) + \");\", foreachStatement));\n      }\n      PsiExpression lValue = assignment.getLExpression();\n      if (!(lValue instanceof PsiReferenceExpression)) return null;\n      PsiElement element = ((PsiReferenceExpression)lValue).resolve();\n      if (!(element instanceof PsiVariable)) return null;\n      PsiVariable var = (PsiVariable)element;\n      PsiExpression value = assignment.getRExpression();\n      if (value == null) return null;\n      restoreComments(foreachStatement, body);\n      InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n      if (status != InitializerUsageStatus.UNKNOWN) {\n        PsiExpression initializer = var.getInitializer();\n        if (initializer != null) {\n          String replacementText = generateOptionalUnwrap(stream, tb, value, initializer, var.getType());\n          return replaceInitializer(foreachStatement, var, initializer, replacementText, status);\n        }\n      }\n      return foreachStatement.replace(elementFactory.createStatementFromText(\n        var.getName() + \" = \" + generateOptionalUnwrap(stream, tb, value, lValue, var.getType()) + \";\", foreachStatement));\n    }\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    restoreComments(foreachStatement, body);\n\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n\n    StringBuilder buffer = generateStream(iteratedValue, tb.getLastOperation(), true);\n    PsiElement block = tb.convertToElement(elementFactory);\n\n    buffer.append(\".\").append(myForEachMethodName).append(\"(\");\n\n    final String functionalExpressionText = tb.getVariable().getName() + \" -> \" + wrapInBlock(block);\n    PsiExpressionStatement callStatement = (PsiExpressionStatement)elementFactory\n      .createStatementFromText(buffer.toString() + functionalExpressionText + \");\", foreachStatement);\n    callStatement = (PsiExpressionStatement)foreachStatement.replace(callStatement);\n\n    final PsiExpressionList argumentList = ((PsiCallExpression)callStatement.getExpression()).getArgumentList();\n    LOG.assertTrue(argumentList != null, callStatement.getText());\n    final PsiExpression[] expressions = argumentList.getExpressions();\n    LOG.assertTrue(expressions.length == 1);\n\n    if (expressions[0] instanceof PsiFunctionalExpression &&\n        ((PsiFunctionalExpression)expressions[0]).getFunctionalInterfaceType() == null) {\n      callStatement =\n        (PsiExpressionStatement)callStatement.replace(elementFactory.createStatementFromText(\n          buffer.toString() + \"(\" + tb.getVariable().getText() + \") -> \" + wrapInBlock(block) + \");\", callStatement));\n    }\n\n    simplifyAndFormat(project, callStatement);\n  }","id":42689,"modified_method":"@Override\n  PsiElement migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    restoreComments(foreachStatement, body);\n\n    final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n\n    StringBuilder buffer = generateStream(iteratedValue, tb.getLastOperation(), true);\n    PsiElement block = tb.convertToElement(elementFactory);\n\n    buffer.append(\".\").append(myForEachMethodName).append(\"(\");\n\n    final String functionalExpressionText = tb.getVariable().getName() + \" -> \" + wrapInBlock(block);\n    PsiExpressionStatement callStatement = (PsiExpressionStatement)elementFactory\n      .createStatementFromText(buffer.toString() + functionalExpressionText + \");\", foreachStatement);\n    callStatement = (PsiExpressionStatement)foreachStatement.replace(callStatement);\n\n    final PsiExpressionList argumentList = ((PsiCallExpression)callStatement.getExpression()).getArgumentList();\n    LOG.assertTrue(argumentList != null, callStatement.getText());\n    final PsiExpression[] expressions = argumentList.getExpressions();\n    LOG.assertTrue(expressions.length == 1);\n\n    if (expressions[0] instanceof PsiFunctionalExpression &&\n        ((PsiFunctionalExpression)expressions[0]).getFunctionalInterfaceType() == null) {\n      callStatement =\n        (PsiExpressionStatement)callStatement.replace(elementFactory.createStatementFromText(\n          buffer.toString() + \"(\" + tb.getVariable().getText() + \") -> \" + wrapInBlock(block) + \");\", callStatement));\n    }\n    return callStatement;\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    if(tb.getSingleStatement() instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)tb.getSingleStatement();\n      PsiExpression value = returnStatement.getReturnValue();\n      if (ExpressionUtils.isLiteral(value, Boolean.TRUE) || ExpressionUtils.isLiteral(value, Boolean.FALSE)) {\n        boolean foundResult = (boolean)((PsiLiteralExpression)value).getValue();\n        PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n        if (nextReturnStatement != null && ExpressionUtils.isLiteral(nextReturnStatement.getReturnValue(), !foundResult)) {\n          String methodName = foundResult ? \"anyMatch\" : \"noneMatch\";\n          String streamText = generateStream(iteratedValue, tb.getLastOperation()).toString();\n          streamText = addTerminalOperation(streamText, methodName, foreachStatement, tb);\n          restoreComments(foreachStatement, body);\n          boolean siblings = nextReturnStatement.getParent() == foreachStatement.getParent();\n          PsiElement result =\n            foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + streamText + \";\", foreachStatement));\n          if (siblings) {\n            nextReturnStatement.delete();\n          }\n          simplifyAndFormat(project, result);\n          return;\n        }\n      }\n    }\n    PsiStatement[] statements = tb.getStatements();\n    if(statements.length == 1 || (statements.length == 2 && statements[1] instanceof PsiBreakStatement)) {\n      restoreComments(foreachStatement, body);\n      String streamText = generateStream(iteratedValue, tb.getLastOperation()).toString();\n      streamText = addTerminalOperation(streamText, \"anyMatch\", foreachStatement, tb);\n      PsiStatement statement = statements[0];\n      PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statement);\n      if(assignment != null) {\n        PsiExpression lValue = assignment.getLExpression();\n        PsiExpression rValue = assignment.getRExpression();\n        if (!(lValue instanceof PsiReferenceExpression) || rValue == null) return;\n        PsiElement maybeVar = ((PsiReferenceExpression)lValue).resolve();\n        if(maybeVar instanceof PsiVariable) {\n          // Simplify single assignments like this:\n          // boolean flag = false;\n          // for(....) if(...) {flag = true; break;}\n          PsiVariable var = (PsiVariable)maybeVar;\n          PsiExpression initializer = var.getInitializer();\n          InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n          if(initializer != null && status != InitializerUsageStatus.UNKNOWN) {\n            String replacement;\n            if(ExpressionUtils.isLiteral(initializer, Boolean.FALSE) &&\n               ExpressionUtils.isLiteral(rValue, Boolean.TRUE)) {\n              replacement = streamText;\n            } else if(ExpressionUtils.isLiteral(initializer, Boolean.TRUE) &&\n                      ExpressionUtils.isLiteral(rValue, Boolean.FALSE)) {\n              replacement = \"!\"+streamText;\n            } else {\n              replacement = streamText + \"?\" + rValue.getText() + \":\" + initializer.getText();\n            }\n            replaceInitializer(foreachStatement, var, initializer, replacement, status);\n            return;\n          }\n        }\n      }\n      String replacement = \"if(\" + streamText + \"){\" + statement.getText() + \"}\";\n      PsiElement result = foreachStatement.replace(elementFactory.createStatementFromText(replacement, foreachStatement));\n      simplifyAndFormat(project, result);\n    }\n  }","id":42690,"modified_method":"@Override\n  PsiElement migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);\n    if(tb.getSingleStatement() instanceof PsiReturnStatement) {\n      PsiReturnStatement returnStatement = (PsiReturnStatement)tb.getSingleStatement();\n      PsiExpression value = returnStatement.getReturnValue();\n      if (ExpressionUtils.isLiteral(value, Boolean.TRUE) || ExpressionUtils.isLiteral(value, Boolean.FALSE)) {\n        boolean foundResult = (boolean)((PsiLiteralExpression)value).getValue();\n        PsiReturnStatement nextReturnStatement = StreamApiMigrationInspection.getNextReturnStatement(foreachStatement);\n        if (nextReturnStatement != null && ExpressionUtils.isLiteral(nextReturnStatement.getReturnValue(), !foundResult)) {\n          String methodName = foundResult ? \"anyMatch\" : \"noneMatch\";\n          String streamText = generateStream(iteratedValue, tb.getLastOperation()).toString();\n          streamText = addTerminalOperation(streamText, methodName, foreachStatement, tb);\n          restoreComments(foreachStatement, body);\n          if (nextReturnStatement.getParent() == foreachStatement.getParent()) {\n            nextReturnStatement.delete();\n          }\n          return foreachStatement.replace(elementFactory.createStatementFromText(\"return \" + streamText + \";\", foreachStatement));\n        }\n      }\n    }\n    PsiStatement[] statements = tb.getStatements();\n    if (!(statements.length == 1 || (statements.length == 2 && statements[1] instanceof PsiBreakStatement))) return null;\n    restoreComments(foreachStatement, body);\n    String streamText = generateStream(iteratedValue, tb.getLastOperation()).toString();\n    streamText = addTerminalOperation(streamText, \"anyMatch\", foreachStatement, tb);\n    PsiStatement statement = statements[0];\n    PsiAssignmentExpression assignment = ExpressionUtils.getAssignment(statement);\n    if(assignment != null) {\n      PsiExpression lValue = assignment.getLExpression();\n      PsiExpression rValue = assignment.getRExpression();\n      if (!(lValue instanceof PsiReferenceExpression) || rValue == null) return null;\n      PsiElement maybeVar = ((PsiReferenceExpression)lValue).resolve();\n      if(maybeVar instanceof PsiVariable) {\n        // Simplify single assignments like this:\n        // boolean flag = false;\n        // for(....) if(...) {flag = true; break;}\n        PsiVariable var = (PsiVariable)maybeVar;\n        PsiExpression initializer = var.getInitializer();\n        InitializerUsageStatus status = StreamApiMigrationInspection.getInitializerUsageStatus(var, foreachStatement);\n        if(initializer != null && status != InitializerUsageStatus.UNKNOWN) {\n          String replacement;\n          if(ExpressionUtils.isLiteral(initializer, Boolean.FALSE) &&\n             ExpressionUtils.isLiteral(rValue, Boolean.TRUE)) {\n            replacement = streamText;\n          } else if(ExpressionUtils.isLiteral(initializer, Boolean.TRUE) &&\n                    ExpressionUtils.isLiteral(rValue, Boolean.FALSE)) {\n            replacement = \"!\"+streamText;\n          } else {\n            replacement = streamText + \"?\" + rValue.getText() + \":\" + initializer.getText();\n          }\n          return replaceInitializer(foreachStatement, var, initializer, replacement, status);\n        }\n      }\n    }\n    String replacement = \"if(\" + streamText + \"){\" + statement.getText() + \"}\";\n    return foreachStatement.replace(elementFactory.createStatementFromText(replacement, foreachStatement));\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiAssignmentExpression assignment = tb.getSingleExpression(PsiAssignmentExpression.class);\n    if (assignment == null) return;\n    PsiVariable var = StreamApiMigrationInspection.extractAccumulator(assignment);\n    if (var == null) return;\n\n    PsiExpression addend = StreamApiMigrationInspection.extractAddend(assignment);\n    if (addend == null) return;\n    PsiType type = var.getType();\n    if (!(type instanceof PsiPrimitiveType) || type.equals(PsiType.FLOAT)) return;\n    if (!type.equals(PsiType.DOUBLE) && !type.equals(PsiType.LONG)) {\n      type = PsiType.INT;\n    }\n    final StringBuilder builder =\n      generateStream(iteratedValue, new StreamApiMigrationInspection.MapOp(tb.getLastOperation(), addend, tb.getVariable(), type));\n    builder.append(\".sum()\");\n    replaceWithNumericAddition(project, foreachStatement, var, builder, type);\n  }","id":42691,"modified_method":"@Override\n  PsiElement migrate(@NotNull Project project,\n               @NotNull ProblemDescriptor descriptor,\n               @NotNull PsiForeachStatement foreachStatement,\n               @NotNull PsiExpression iteratedValue,\n               @NotNull PsiStatement body,\n               @NotNull StreamApiMigrationInspection.TerminalBlock tb) {\n    PsiAssignmentExpression assignment = tb.getSingleExpression(PsiAssignmentExpression.class);\n    if (assignment == null) return null;\n    PsiVariable var = StreamApiMigrationInspection.extractAccumulator(assignment);\n    if (var == null) return null;\n\n    PsiExpression addend = StreamApiMigrationInspection.extractAddend(assignment);\n    if (addend == null) return null;\n    PsiType type = var.getType();\n    if (!(type instanceof PsiPrimitiveType) || type.equals(PsiType.FLOAT)) return null;\n    if (!type.equals(PsiType.DOUBLE) && !type.equals(PsiType.LONG)) {\n      type = PsiType.INT;\n    }\n    final StringBuilder builder =\n      generateStream(iteratedValue, new StreamApiMigrationInspection.MapOp(tb.getLastOperation(), addend, tb.getVariable(), type));\n    builder.append(\".sum()\");\n    return replaceWithNumericAddition(project, foreachStatement, var, builder, type);\n  }","commit_id":"2f421a5c62a1f2935bc40cf690969c90623b4431","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void migrate( File fromStoreDir, RecordFormats fromFormat, File toStoreDir, RecordFormats toFormat,\n            StoreType[] types, StoreType... additionalTypesToOpen )\n    {\n        StoreType[] storesToOpen = ArrayUtil.concat( types, additionalTypesToOpen );\n        try (\n            NeoStores fromStores = new StoreFactory( fromStoreDir, config, new DefaultIdGeneratorFactory( fs ),\n                    pageCache, fs, NullLogProvider.getInstance(), fromFormat ).openNeoStores( true, storesToOpen );\n            NeoStores toStores = new StoreFactory( toStoreDir,\n                    withPersistedStoreHeadersAsConfigFrom( fromStores, storesToOpen ),\n                    new DefaultIdGeneratorFactory( fs ),\n                    pageCache, fs, NullLogProvider.getInstance(), toFormat ).openNeoStores( true, storesToOpen ) )\n        {\n            for ( StoreType type : types )\n            {\n                // This condition will exclude counts store first and foremost.\n                if ( type.isRecordStore() )\n                {\n                    migrate( fromStores.getRecordStore( type ), toStores.getRecordStore( type ) );\n                }\n            }\n        }\n    }","id":42692,"modified_method":"public void migrate( File fromStoreDir, RecordFormats fromFormat, File toStoreDir, RecordFormats toFormat,\n            MigrationProgressMonitor.Section progressMonitor, StoreType[] types, StoreType... additionalTypesToOpen )\n    {\n        StoreType[] storesToOpen = ArrayUtil.concat( types, additionalTypesToOpen );\n        progressMonitor.start( storesToOpen.length );\n\n        try (\n            NeoStores fromStores = new StoreFactory( fromStoreDir, config, new DefaultIdGeneratorFactory( fs ),\n                    pageCache, fs, NullLogProvider.getInstance(), fromFormat ).openNeoStores( true, storesToOpen );\n            NeoStores toStores = new StoreFactory( toStoreDir,\n                    withPersistedStoreHeadersAsConfigFrom( fromStores, storesToOpen ),\n                    new DefaultIdGeneratorFactory( fs ),\n                    pageCache, fs, NullLogProvider.getInstance(), toFormat ).openNeoStores( true, storesToOpen ) )\n        {\n            for ( StoreType type : types )\n            {\n                // This condition will exclude counts store first and foremost.\n                if ( type.isRecordStore() )\n                {\n                    migrate( fromStores.getRecordStore( type ), toStores.getRecordStore( type ) );\n                    progressMonitor.progress( 1 );\n                }\n            }\n        }\n    }","commit_id":"39c1be921d8a2f6ed8652f281d401ad05714fe61","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Section startSection( String name )\n    {\n        return SECTION;\n    }","id":42693,"modified_method":"@Override\n    public Section startSection( String name )\n    {\n        return NO_OP_SECTION;\n    }","commit_id":"39c1be921d8a2f6ed8652f281d401ad05714fe61","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void migrateWithDirectMigration( File storeDir, File migrationDir,\n            RecordFormats oldFormat, RecordFormats newFormat )\n    {\n        DirectRecordStoreMigrator migrator = new DirectRecordStoreMigrator( pageCache, fileSystem, config );\n        StoreType[] stores = stream( StoreType.values() )\n                // Not interested in migrating MetaData store.\n                .filter( type -> type != META_DATA )\n                .toArray( StoreType[]::new );\n        migrator.migrate( storeDir, oldFormat, migrationDir, newFormat, stores );\n    }","id":42694,"modified_method":"private void migrateWithDirectMigration( File storeDir, File migrationDir,\n            RecordFormats oldFormat, RecordFormats newFormat, MigrationProgressMonitor.Section progressMonitor )\n    {\n        DirectRecordStoreMigrator migrator = new DirectRecordStoreMigrator( pageCache, fileSystem, config );\n        StoreType[] stores = stream( StoreType.values() )\n                // Not interested in migrating MetaData store.\n                .filter( type -> type != META_DATA )\n                .toArray( StoreType[]::new );\n        migrator.migrate( storeDir, oldFormat, migrationDir, newFormat, progressMonitor, stores );\n    }","commit_id":"39c1be921d8a2f6ed8652f281d401ad05714fe61","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void migrate( File storeDir, File migrationDir, MigrationProgressMonitor.Section progressMonitor,\n            String versionToMigrateFrom, String versionToMigrateTo ) throws IOException\n    {\n        // Extract information about the last transaction from legacy neostore\n        File neoStore = new File( storeDir, MetaDataStore.DEFAULT_NAME );\n        long lastTxId = MetaDataStore.getRecord( pageCache, neoStore, Position.LAST_TRANSACTION_ID );\n        long lastTxChecksum = extractTransactionChecksum( neoStore, storeDir, lastTxId );\n        LogPosition lastTxLogPosition = extractTransactionLogPosition( neoStore, storeDir, lastTxId );\n        // Write the tx checksum to file in migrationDir, because we need it later when moving files into storeDir\n        writeLastTxChecksum( migrationDir, lastTxChecksum );\n        writeLastTxLogPosition( migrationDir, lastTxLogPosition );\n\n        RecordFormats oldFormat = InternalRecordFormatSelector.fromVersion( versionToMigrateFrom );\n        RecordFormats newFormat = InternalRecordFormatSelector.fromVersion( versionToMigrateTo );\n        if ( !oldFormat.equals( newFormat ) )\n        {\n            if ( newFormat.hasSameCapabilities( oldFormat, CapabilityType.FORMAT ) )\n            {\n                // Do direct migration\n                migrateWithDirectMigration( storeDir, migrationDir, oldFormat, newFormat );\n            }\n            else\n            {\n                // Some form of migration is required (a fallback/catch-all option)\n                migrateWithBatchImporter( storeDir, migrationDir,\n                        lastTxId, lastTxChecksum, lastTxLogPosition.getLogVersion(), lastTxLogPosition.getByteOffset(),\n                        progressMonitor, oldFormat, newFormat );\n            }\n        }\n\n        if ( versionToMigrateFrom.equals( LowLimitV2_1.STORE_VERSION ) )\n        {\n            removeDuplicateEntityProperties( storeDir, migrationDir, pageCache, schemaIndexProvider, oldFormat );\n        }\n\n        // DO NOT migrate logs. LegacyLogs is able to migrate logs, but only changes its format, not any\n        // contents of it, and since the record format has changed there would be a mismatch between the\n        // commands in the log and the contents in the store. If log migration is to be performed there\n        // must be a proper translation happening while doing so.\n    }","id":42695,"modified_method":"@Override\n    public void migrate( File storeDir, File migrationDir, MigrationProgressMonitor.Section progressMonitor,\n            String versionToMigrateFrom, String versionToMigrateTo ) throws IOException\n    {\n        // Extract information about the last transaction from legacy neostore\n        File neoStore = new File( storeDir, MetaDataStore.DEFAULT_NAME );\n        long lastTxId = MetaDataStore.getRecord( pageCache, neoStore, Position.LAST_TRANSACTION_ID );\n        long lastTxChecksum = extractTransactionChecksum( neoStore, storeDir, lastTxId );\n        LogPosition lastTxLogPosition = extractTransactionLogPosition( neoStore, storeDir, lastTxId );\n        // Write the tx checksum to file in migrationDir, because we need it later when moving files into storeDir\n        writeLastTxChecksum( migrationDir, lastTxChecksum );\n        writeLastTxLogPosition( migrationDir, lastTxLogPosition );\n\n        RecordFormats oldFormat = InternalRecordFormatSelector.fromVersion( versionToMigrateFrom );\n        RecordFormats newFormat = InternalRecordFormatSelector.fromVersion( versionToMigrateTo );\n        if ( !oldFormat.equals( newFormat ) )\n        {\n            if ( newFormat.hasSameCapabilities( oldFormat, CapabilityType.FORMAT ) )\n            {\n                // Do direct migration\n                migrateWithDirectMigration( storeDir, migrationDir, oldFormat, newFormat, progressMonitor );\n            }\n            else\n            {\n                // Some form of migration is required (a fallback/catch-all option)\n                migrateWithBatchImporter( storeDir, migrationDir,\n                        lastTxId, lastTxChecksum, lastTxLogPosition.getLogVersion(), lastTxLogPosition.getByteOffset(),\n                        progressMonitor, oldFormat, newFormat );\n            }\n        }\n\n        if ( versionToMigrateFrom.equals( LowLimitV2_1.STORE_VERSION ) )\n        {\n            removeDuplicateEntityProperties( storeDir, migrationDir, pageCache, schemaIndexProvider, oldFormat );\n        }\n\n        // DO NOT migrate logs. LegacyLogs is able to migrate logs, but only changes its format, not any\n        // contents of it, and since the record format has changed there would be a mismatch between the\n        // commands in the log and the contents in the store. If log migration is to be performed there\n        // must be a proper translation happening while doing so.\n    }","commit_id":"39c1be921d8a2f6ed8652f281d401ad05714fe61","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void prepareBatchImportMigration( File storeDir, File migrationDir, RecordFormats oldFormat,\n            RecordFormats newFormat )\n            throws IOException\n    {\n        BatchingNeoStores.createStore( fileSystem, migrationDir.getPath(), config );\n\n        // We use the batch importer for migrating the data, and we use it in a special way where we only\n        // rewrite the stores that have actually changed format. We know that to be node and relationship\n        // stores. Although since the batch importer also populates the counts store, all labels need to\n        // be read, i.e. both inlined and those existing in dynamic records. That's why we need to copy\n        // that dynamic record store over before doing the \"batch import\".\n        //   Copying this file just as-is assumes that the format hasn't change. If that happens we're in\n        // a different situation, where we first need to migrate this file.\n        if ( newFormat.dynamic().equals( oldFormat.dynamic() ) )\n        {\n            Iterable<StoreFile> storeFiles = iterable( StoreFile.NODE_LABEL_STORE );\n            StoreFile.fileOperation( COPY, fileSystem, storeDir, migrationDir, storeFiles,\n                    true, // OK if it's not there (1.9)\n                    ExistingTargetStrategy.FAIL, StoreFileType.values() );\n        }\n        else\n        {\n            // Migrate all token stores, schema store and dynamic node label ids, keeping their ids intact\n            DirectRecordStoreMigrator migrator = new DirectRecordStoreMigrator( pageCache, fileSystem, config );\n            migrator.migrate( storeDir, oldFormat, migrationDir, newFormat,\n                    new StoreType[] {\n                        StoreType.LABEL_TOKEN, StoreType.LABEL_TOKEN_NAME,\n                        StoreType.PROPERTY_KEY_TOKEN, StoreType.PROPERTY_KEY_TOKEN_NAME,\n                        StoreType.RELATIONSHIP_TYPE_TOKEN, StoreType.RELATIONSHIP_TYPE_TOKEN_NAME,\n                        StoreType.NODE_LABEL,\n                        StoreType.SCHEMA },\n                    new StoreType[] {\n                        StoreType.NODE,\n                    } );\n        }\n    }","id":42696,"modified_method":"private void prepareBatchImportMigration( File storeDir, File migrationDir, RecordFormats oldFormat,\n            RecordFormats newFormat )\n            throws IOException\n    {\n        BatchingNeoStores.createStore( fileSystem, migrationDir.getPath(), config );\n\n        // We use the batch importer for migrating the data, and we use it in a special way where we only\n        // rewrite the stores that have actually changed format. We know that to be node and relationship\n        // stores. Although since the batch importer also populates the counts store, all labels need to\n        // be read, i.e. both inlined and those existing in dynamic records. That's why we need to copy\n        // that dynamic record store over before doing the \"batch import\".\n        //   Copying this file just as-is assumes that the format hasn't change. If that happens we're in\n        // a different situation, where we first need to migrate this file.\n        if ( newFormat.dynamic().equals( oldFormat.dynamic() ) )\n        {\n            Iterable<StoreFile> storeFiles = iterable( StoreFile.NODE_LABEL_STORE );\n            StoreFile.fileOperation( COPY, fileSystem, storeDir, migrationDir, storeFiles,\n                    true, // OK if it's not there (1.9)\n                    ExistingTargetStrategy.FAIL, StoreFileType.values() );\n        }\n        else\n        {\n            // Migrate all token stores, schema store and dynamic node label ids, keeping their ids intact\n            DirectRecordStoreMigrator migrator = new DirectRecordStoreMigrator( pageCache, fileSystem, config );\n\n            StoreType[] storesToMigrate = {\n                    StoreType.LABEL_TOKEN, StoreType.LABEL_TOKEN_NAME,\n                    StoreType.PROPERTY_KEY_TOKEN, StoreType.PROPERTY_KEY_TOKEN_NAME,\n                    StoreType.RELATIONSHIP_TYPE_TOKEN, StoreType.RELATIONSHIP_TYPE_TOKEN_NAME,\n                    StoreType.NODE_LABEL,\n                    StoreType.SCHEMA};\n\n            // Migrate these stores silently because they are usually very small\n            MigrationProgressMonitor.Section section = SilentMigrationProgressMonitor.NO_OP_SECTION;\n\n            migrator.migrate( storeDir, oldFormat, migrationDir, newFormat, section, storesToMigrate, StoreType.NODE );\n        }\n    }","commit_id":"39c1be921d8a2f6ed8652f281d401ad05714fe61","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * @see org.opencms.xml.containerpage.I_CmsADEConfiguration#createNewElement(CmsObject, String, ServletRequest, String)\n     */\n    public CmsResource createNewElement(CmsObject cms, String cntPageUri, ServletRequest request, String type)\n    throws CmsException {\n\n        CmsResource cfg = getConfigurationFile(cms, cntPageUri);\n        CmsConfigurationParser parser = new CmsConfigurationParser(cms, cfg);\n        String newFileName = getNextNewFileName(cms, cntPageUri, request, type);\n        cms.copyResource(parser.getConfiguration().get(type).getSourceFile(), newFileName);\n        return cms.readResource(newFileName);\n    }","id":42697,"modified_method":"/**\n     * @see org.opencms.xml.containerpage.I_CmsADEConfiguration#createNewElement(CmsObject, String, ServletRequest, String)\n     */\n    public CmsResource createNewElement(CmsObject cms, String cntPageUri, ServletRequest request, String type)\n    throws CmsException {\n\n        CmsConfigurationParser parser = getConfigurationParser(cms, cntPageUri);\n        String newFileName = getNextNewFileName(cms, cntPageUri, request, type);\n        cms.copyResource(parser.getConfiguration().get(type).getSourceFile(), newFileName);\n        return cms.readResource(newFileName);\n    }","commit_id":"d03c01cd72ed86bf1faf992a45e87dd18c285baa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the configuration file to use.<p>\n     * \n     * @param cms the current cms context\n     * @param containerPageUri the container page uri\n     * \n     * @return the configuration file to use, or <code>null<\/code> if not found\n     */\n    protected CmsResource getConfigurationFile(CmsObject cms, String containerPageUri) {\n\n        // get the resource type configuration file, will be the same for every locale\n        String cfgPath = null;\n        try {\n            cfgPath = cms.readPropertyObject(containerPageUri, PROPERTY_CONTAINER_CONFIG, true).getValue();\n        } catch (CmsException e) {\n            LOG.debug(e.getLocalizedMessage(), e);\n        }\n        CmsResource resTypeConfigRes = null;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            LOG.warn(Messages.get().getBundle().key(\n                Messages.ERR_CONFIG_NOT_SET_2,\n                containerPageUri,\n                PROPERTY_CONTAINER_CONFIG));\n        } else {\n            try {\n                resTypeConfigRes = cms.readResource(cfgPath);\n            } catch (Exception e) {\n                throw new CmsIllegalStateException(Messages.get().container(\n                    Messages.ERR_CONFIG_NOT_FOUND_3,\n                    containerPageUri,\n                    PROPERTY_CONTAINER_CONFIG,\n                    cfgPath));\n            }\n            if (resTypeConfigRes.getTypeId() != 14) {\n                throw new CmsIllegalStateException(Messages.get().container(\n                    Messages.ERR_CONFIG_WRONG_TYPE_3,\n                    containerPageUri,\n                    PROPERTY_CONTAINER_CONFIG,\n                    cfgPath));\n            }\n        }\n        return resTypeConfigRes;\n    }","id":42698,"modified_method":"/**\n     * Returns the configuration file to use.<p>\n     * \n     * @param cms the current cms context\n     * @param containerPageUri the container page uri\n     * \n     * @return the configuration file to use, or <code>null<\/code> if not found\n     */\n    protected CmsResource getConfigurationFile(CmsObject cms, String containerPageUri) {\n\n        // get the resource type configuration file, will be the same for every locale\n        String cfgPath = null;\n        try {\n            cfgPath = cms.readPropertyObject(containerPageUri, PROPERTY_CONTAINER_CONFIG, true).getValue();\n        } catch (CmsException e) {\n            LOG.debug(e.getLocalizedMessage(), e);\n        }\n        CmsResource resTypeConfigRes = null;\n        if (CmsStringUtil.isEmptyOrWhitespaceOnly(cfgPath)) {\n            LOG.warn(Messages.get().getBundle().key(\n                Messages.ERR_CONFIG_NOT_SET_2,\n                containerPageUri,\n                PROPERTY_CONTAINER_CONFIG));\n        } else {\n            try {\n                resTypeConfigRes = cms.readResource(cfgPath);\n            } catch (Exception e) {\n                throw new CmsIllegalStateException(Messages.get().container(\n                    Messages.ERR_CONFIG_NOT_FOUND_3,\n                    containerPageUri,\n                    PROPERTY_CONTAINER_CONFIG,\n                    cfgPath));\n            }\n        }\n        return resTypeConfigRes;\n    }","commit_id":"d03c01cd72ed86bf1faf992a45e87dd18c285baa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.containerpage.I_CmsADEConfiguration#getNextNewFileName(CmsObject, String, ServletRequest, String)\n     */\n    public synchronized String getNextNewFileName(CmsObject cms, String cntPageUri, ServletRequest request, String type)\n    throws CmsException {\n\n        CmsResource cfg = getConfigurationFile(cms, cntPageUri);\n        CmsConfigurationParser parser = new CmsConfigurationParser(cms, cfg);\n        return parser.getNewFileName(cms, parser.getConfiguration().get(type).getDestination());\n    }","id":42699,"modified_method":"/**\n     * @see org.opencms.xml.containerpage.I_CmsADEConfiguration#getNextNewFileName(CmsObject, String, ServletRequest, String)\n     */\n    public synchronized String getNextNewFileName(CmsObject cms, String cntPageUri, ServletRequest request, String type)\n    throws CmsException {\n\n        CmsConfigurationParser parser = getConfigurationParser(cms, cntPageUri);\n        return parser.getNewFileName(cms, parser.getConfiguration().get(type).getDestination());\n    }","commit_id":"d03c01cd72ed86bf1faf992a45e87dd18c285baa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.xml.containerpage.I_CmsADEConfiguration#getCreatableElements(CmsObject, String, ServletRequest)\n     */\n    public List<CmsResource> getCreatableElements(CmsObject cms, String cntPageUri, ServletRequest request)\n    throws CmsException {\n\n        CmsResource cfg = getConfigurationFile(cms, cntPageUri);\n        if (cfg == null) {\n            return new ArrayList<CmsResource>();\n        }\n        return new CmsConfigurationParser(cms, cfg).getNewElements();\n    }","id":42700,"modified_method":"/**\n     * @see org.opencms.xml.containerpage.I_CmsADEConfiguration#getCreatableElements(CmsObject, String, ServletRequest)\n     */\n    public List<CmsResource> getCreatableElements(CmsObject cms, String cntPageUri, ServletRequest request)\n    throws CmsException {\n\n        return getConfigurationParser(cms, cntPageUri).getNewElements();\n    }","commit_id":"d03c01cd72ed86bf1faf992a45e87dd18c285baa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructs a new instance.<p>\n     * \n     * @param cms the cms context used for reading the configuration\n     * @param config the configuration file\n     *  \n     * @throws CmsException if something goes wrong\n     */\n    public CmsConfigurationParser(CmsObject cms, CmsResource config)\n    throws CmsException {\n\n        m_configuration = new HashMap<String, CmsConfigurationItem>();\n        m_newElements = new ArrayList<CmsResource>();\n\n        CmsFile configFile = cms.readFile(config);\n        I_CmsXmlDocument content = CmsXmlContentFactory.unmarshal(cms, configFile);\n        parseConfiguration(cms, content);\n    }","id":42701,"modified_method":"/**\n     * Constructs a new instance.<p>\n     * \n     * @param cms the cms context used for reading the configuration\n     * @param config the configuration file\n     *  \n     * @throws CmsException if something goes wrong\n     */\n    public CmsConfigurationParser(CmsObject cms, CmsResource config)\n    throws CmsException {\n\n        if (config.getTypeId() != CmsResourceTypeXmlContainerPage.SUB_CONTAINER_TYPE_ID) {\n            throw new CmsIllegalStateException(Messages.get().container(\n                Messages.ERR_CONFIG_WRONG_TYPE_2,\n                CmsADEDefaultConfiguration.PROPERTY_CONTAINER_CONFIG,\n                cms.getSitePath(config)));\n        }\n\n        m_configuration = new HashMap<String, CmsConfigurationItem>();\n        m_newElements = new ArrayList<CmsResource>();\n\n        CmsFile configFile = cms.readFile(config);\n        I_CmsXmlDocument content = CmsXmlContentFactory.unmarshal(cms, configFile);\n        parseConfiguration(cms, content);\n    }","commit_id":"d03c01cd72ed86bf1faf992a45e87dd18c285baa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Set the time after which the message is hidden.\n     *\n     * @param duration the time (in milliseconds)\n     * @return the current Object, for convenience\n     */\n    public Notification setDuration(int duration) {\n        this.duration = duration;\n        return this;\n    }","id":42702,"modified_method":"/**\n     * Set the time after which the message is hidden.\n     *\n     * @param duration the time (in milliseconds)\n     * Preset values {@link #TIME_SHORT}, {@link #TIME_DEFAULT}, {@link #TIME_LONG}\n     * and {@link #TIME_VERY_LONG} can be used.\n     * @return the current Object, for convenience\n     */\n    public Notification setDuration(int duration) {\n        this.duration = duration;\n        return this;\n    }","commit_id":"9caa042d2acb12b27a71c8d619e135f81101ed64","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void build(Notification note) {\n            JButton close = new JButton(new HideAction());\n            close.setPreferredSize(new Dimension(50, 50));\n            JToolBar tbClose = new JToolBar();\n            close.setMargin(new Insets(0, 0, 1, 1));\n            close.setContentAreaFilled(false);\n\n            tbClose.setFloatable(false);\n            tbClose.setBorderPainted(false);\n            tbClose.setOpaque(false);\n            tbClose.add(close);\n\n            setOpaque(false);\n            innerPanel = new RoundedPanel();\n            innerPanel.setBackground(PANEL_SEMITRANSPARENT);\n            innerPanel.setForeground(Color.BLACK);\n\n            GroupLayout layout = new GroupLayout(innerPanel);\n            innerPanel.setLayout(layout);\n            layout.setAutoCreateGaps(true);\n            layout.setAutoCreateContainerGaps(true);\n\n            innerPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n            add(innerPanel);\n\n            JLabel icon = null;\n            if (note.getIcon() != null) {\n                icon = new JLabel(note.getIcon());\n            }\n            Component content = note.getContent();\n            GroupLayout.SequentialGroup hgroup = layout.createSequentialGroup();\n            if (icon != null) {\n                hgroup.addComponent(icon);\n            }\n            hgroup.addComponent(content).addComponent(tbClose);\n            GroupLayout.ParallelGroup vgroup = layout.createParallelGroup();\n            if (icon != null) {\n                vgroup.addComponent(icon);\n            }\n            vgroup.addComponent(content).addComponent(tbClose);\n            layout.setHorizontalGroup(hgroup);\n            layout.setVerticalGroup(vgroup);\n\n            /*\n             * The timer stops when the mouse cursor is above the panel.\n             *\n             * This is not straightforward, because the JPanel will get a\n             * mouseExited event when the cursor moves on top of the JButton\n             * inside the panel.\n             *\n             * The current hacky solution is to register the freeze MouseListener\n             * not only to the panel, but to all the components inside the panel.\n             *\n             * Moving the mouse cursor from one component to the next would\n             * cause some flickering (timer is started and stopped for a fraction\n             * of a second, background color is switched twice), so there is\n             * a tiny delay before the timer really resumes.\n             */\n            MouseListener freeze = new FreezeMouseListener();\n            addMouseListenerToAllChildComponents(this, freeze);\n        }","id":42703,"modified_method":"private void build(final Notification note) {\n            JButton btnClose = new JButton(new HideAction());\n            btnClose.setPreferredSize(new Dimension(50, 50));\n            btnClose.setMargin(new Insets(0, 0, 1, 1));\n            btnClose.setContentAreaFilled(false);\n            // put it in JToolBar to get a better appearance\n            JToolBar tbClose = new JToolBar();\n            tbClose.setFloatable(false);\n            tbClose.setBorderPainted(false);\n            tbClose.setOpaque(false);\n            tbClose.add(btnClose);\n\n            JToolBar tbHelp = null;\n            if (note.getHelpTopic() != null) {\n                JButton btnHelp = new JButton(tr(\"Help\"));\n                btnHelp.setIcon(ImageProvider.get(\"help\"));\n                btnHelp.setToolTipText(tr(\"Show help information\"));\n                HelpUtil.setHelpContext(btnHelp, note.getHelpTopic());\n                btnHelp.addActionListener(new AbstractAction() {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        SwingUtilities.invokeLater(new Runnable() {\n                            @Override\n                            public void run() {\n                                HelpBrowser.setUrlForHelpTopic(note.getHelpTopic());\n                            }\n                        });\n                    }\n                });\n                btnHelp.setOpaque(false);\n                tbHelp = new JToolBar();\n                tbHelp.setFloatable(false);\n                tbHelp.setBorderPainted(false);\n                tbHelp.setOpaque(false);\n                tbHelp.add(btnHelp);\n            }\n\n            setOpaque(false);\n            innerPanel = new RoundedPanel();\n            innerPanel.setBackground(PANEL_SEMITRANSPARENT);\n            innerPanel.setForeground(Color.BLACK);\n\n            GroupLayout layout = new GroupLayout(innerPanel);\n            innerPanel.setLayout(layout);\n            layout.setAutoCreateGaps(true);\n            layout.setAutoCreateContainerGaps(true);\n\n            innerPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n            add(innerPanel);\n\n            JLabel icon = null;\n            if (note.getIcon() != null) {\n                icon = new JLabel(note.getIcon());\n            }\n            Component content = note.getContent();\n            GroupLayout.SequentialGroup hgroup = layout.createSequentialGroup();\n            if (icon != null) {\n                hgroup.addComponent(icon);\n            }\n            if (tbHelp != null) {\n                hgroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.TRAILING)\n                        .addComponent(content)\n                        .addComponent(tbHelp)\n                );\n            } else {\n                hgroup.addComponent(content);\n            }\n            hgroup.addComponent(tbClose);\n            GroupLayout.ParallelGroup vgroup = layout.createParallelGroup();\n            if (icon != null) {\n                vgroup.addComponent(icon);\n            }\n            vgroup.addComponent(content);\n            vgroup.addComponent(tbClose);\n            layout.setHorizontalGroup(hgroup);\n\n            if (tbHelp != null) {\n                layout.setVerticalGroup(layout.createSequentialGroup()\n                        .addGroup(vgroup)\n                        .addComponent(tbHelp)\n                );\n            } else {\n                layout.setVerticalGroup(vgroup);\n            }\n\n            /*\n             * The timer stops when the mouse cursor is above the panel.\n             *\n             * This is not straightforward, because the JPanel will get a\n             * mouseExited event when the cursor moves on top of the JButton\n             * inside the panel.\n             *\n             * The current hacky solution is to register the freeze MouseListener\n             * not only to the panel, but to all the components inside the panel.\n             *\n             * Moving the mouse cursor from one component to the next would\n             * cause some flickering (timer is started and stopped for a fraction\n             * of a second, background color is switched twice), so there is\n             * a tiny delay before the timer really resumes.\n             */\n            MouseListener freeze = new FreezeMouseListener();\n            addMouseListenerToAllChildComponents(this, freeze);\n        }","commit_id":"9caa042d2acb12b27a71c8d619e135f81101ed64","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void alertSelectAtLeastOneWay() {\n        HelpAwareOptionPane.showOptionDialog(\n                Main.parent,\n                tr(\"Please select at least one way to simplify.\"),\n                tr(\"Warning\"),\n                JOptionPane.WARNING_MESSAGE,\n                HelpUtil.ht(\"/Action/SimplifyWay#SelectAWayToSimplify\")\n                );\n    }","id":42704,"modified_method":"protected void alertSelectAtLeastOneWay() {\n        new Notification(\n                tr(\"Please select at least one way to simplify.\"))\n                .setIcon(JOptionPane.WARNING_MESSAGE)\n                .setDuration(Notification.TIME_SHORT)\n                .setHelpTopic(HelpUtil.ht(\"/Action/SimplifyWay#SelectAWayToSimplify\"))\n                .show();\n    }","commit_id":"9caa042d2acb12b27a71c8d619e135f81101ed64","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static Class[] getInterfacesForComponent(Service component)\n        throws MuleException, ClassNotFoundException\n    {\n        Class[] interfaces;\n        List ifaces = null;\n\n        Map localProperties = (Map) properties.get();\n        if (null != localProperties)\n        {\n            ifaces = (List) localProperties.get(SoapConstants.SERVICE_INTERFACES);\n        }\n        if (ifaces == null || ifaces.size() == 0)\n        {\n            final Class implementationClass;\n            try\n            {\n                implementationClass = component.getServiceFactory().getOrCreate().getClass();\n            }\n            catch (Exception e)\n            {\n                throw new ClassNotFoundException(\"Unable to retrieve class from service factory\", e);\n            }\n            // get all implemented interfaces from superclasses as well\n            final List intfList = ClassUtils.getAllInterfaces(implementationClass);\n            interfaces = (Class[])intfList.toArray(new Class[intfList.size()]);\n        }\n        else\n        {\n            interfaces = new Class[ifaces.size()];\n            for (int i = 0; i < ifaces.size(); i++)\n            {\n                String iface = (String)ifaces.get(i);\n                interfaces[i] = ClassUtils.loadClass(iface, AxisServiceProxy.class);\n            }\n        }\n\n        interfaces = removeInterface(interfaces, Callable.class);\n        interfaces = removeInterface(interfaces, Disposable.class);\n        interfaces = removeInterface(interfaces, Initialisable.class);\n        return interfaces;\n    }","id":42705,"modified_method":"public static Class[] getInterfacesForComponent(Service component)\n        throws MuleException, ClassNotFoundException\n    {\n        Class[] interfaces;\n        List ifaces = null;\n\n        Map localProperties = (Map) properties.get();\n        if (null != localProperties)\n        {\n            ifaces = (List) localProperties.get(SoapConstants.SERVICE_INTERFACES);\n        }\n        if (ifaces == null || ifaces.size() == 0)\n        {\n            final Class implementationClass;\n            try\n            {\n                implementationClass = component.getServiceFactory().getObjectClass();\n            }\n            catch (Exception e)\n            {\n                throw new ClassNotFoundException(\"Unable to retrieve class from service factory\", e);\n            }\n            // get all implemented interfaces from superclasses as well\n            final List intfList = ClassUtils.getAllInterfaces(implementationClass);\n            interfaces = (Class[])intfList.toArray(new Class[intfList.size()]);\n        }\n        else\n        {\n            interfaces = new Class[ifaces.size()];\n            for (int i = 0; i < ifaces.size(); i++)\n            {\n                String iface = (String)ifaces.get(i);\n                interfaces[i] = ClassUtils.loadClass(iface, AxisServiceProxy.class);\n            }\n        }\n\n        interfaces = removeInterface(interfaces, Callable.class);\n        interfaces = removeInterface(interfaces, Disposable.class);\n        interfaces = removeInterface(interfaces, Initialisable.class);\n        return interfaces;\n    }","commit_id":"dcbb8118f183155acc1a7df20af41a80f037c6bd","url":"https://github.com/mulesoft/mule"},{"original_method":"private Class<?> getInterface() throws MuleException, ClassNotFoundException\n    {\n        try\n        {\n            return service.getServiceFactory().getOrCreate().getClass();\n        }\n        catch (Exception e)\n        {\n            throw new CreateException(e, this);\n        }\n    }","id":42706,"modified_method":"private Class<?> getInterface() throws MuleException, ClassNotFoundException\n    {\n        try\n        {\n            return service.getServiceFactory().getObjectClass();\n        }\n        catch (Exception e)\n        {\n            throw new CreateException(e, this);\n        }\n    }","commit_id":"dcbb8118f183155acc1a7df20af41a80f037c6bd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected ConfigurationBuilder getBuilder() throws Exception\n    {\n      return new XFireEchoConfigutationBuilder();\n    }","id":42707,"modified_method":"protected ConfigurationBuilder getBuilder() throws Exception\n    {\n      return new XFireEchoConfigurationBuilder();\n    }","commit_id":"dcbb8118f183155acc1a7df20af41a80f037c6bd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected int getWarmUpMessages()\n    {\n        return 10;\n    }","id":42708,"modified_method":"protected int getWarmUpMessages()\n    {\n        // MULE-3016\n        return 0;\n    }","commit_id":"dcbb8118f183155acc1a7df20af41a80f037c6bd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected int getNumberOfRequests()\n    {\n        return 10;\n    }","id":42709,"modified_method":"protected int getNumberOfRequests()\n    {\n        // MULE-3016\n        return 1;\n    }","commit_id":"dcbb8118f183155acc1a7df20af41a80f037c6bd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void create() throws CreateException\n    {\n        try\n        {\n            Map props = new HashMap(endpoint.getProperties());\n\n            // convert port Type to QName if specified\n            if (props.containsKey(PORT_TYPE))\n            {\n                Object value = props.get(PORT_TYPE);\n                QName portTypeQName = QNamePropertyEditor.convert((String) value);\n                props.put(PORT_TYPE, portTypeQName);\n            }\n\n            // check if there is the namespace property on the service\n            String namespace = (String) endpoint.getProperties().get(SoapConstants.SOAP_NAMESPACE_PROPERTY);\n\n            // check for namespace set as annotation\n            if (connector.isEnableJSR181Annotations())\n            {\n                WebAnnotations wa = (WebAnnotations) ClassUtils.instanciateClass(\n                    XFireConnector.CLASSNAME_ANNOTATIONS, null, this.getClass());\n                // at this point, the object hasn't been created in the descriptor so\n                // we have to retrieve the implementation classname and create a\n                // class for it\n                WebServiceAnnotation webServiceAnnotation = \n                    wa.getWebServiceAnnotation(service.getServiceFactory().getObjectClass());\n                namespace = webServiceAnnotation.getTargetNamespace();\n            }\n\n            if ((namespace == null) || (namespace.equalsIgnoreCase(\"\")))\n            {\n                namespace = MapUtils.getString(props, \"namespace\", XFireConnector.DEFAULT_MULE_NAMESPACE_URI);\n            }\n\n            //Convert createDefaultBindings string to boolean before rewriting as xfire property\n            if (props.get(\"createDefaultBindings\") != null)\n            {\n                props.put(\"createDefaultBindings\", Boolean.valueOf((String) props.get(\"createDefaultBindings\")));\n            }\n\n            if (props.size() == 0)\n            {\n                // Xfire checks that properties are null rather than empty\n                props = null;\n            }\n            else\n            {\n                rewriteProperty(props, PORT_TYPE);\n                rewriteProperty(props, \"style\");\n                rewriteProperty(props, \"use\");\n                rewriteProperty(props, \"createDefaultBindings\");\n                rewriteProperty(props, \"soap12Transports\");\n                rewriteProperty(props, \"soap11Transports\");\n                rewriteProperty(props, \"scope\");\n                rewriteProperty(props, \"schemas\");\n            }\n\n            serviceInterfaces = (List)endpoint.getProperties().get(SoapConstants.SERVICE_INTERFACES);\n            Class exposedInterface;\n\n            if (serviceInterfaces == null)\n            {\n                exposedInterface = service.getServiceFactory().getOrCreate().getClass();\n            }\n            else\n            {\n                String className = (String) serviceInterfaces.get(0);\n                exposedInterface = ClassUtils.loadClass(className, this.getClass());\n                logger.info(className + \" class was used to expose your service\");\n\n                if (serviceInterfaces.size() > 1)\n                {\n                    logger.info(\"Only the first class was used to expose your method\");\n                }\n            }\n\n            String wsdlUrl = (String) endpoint.getProperties().get(SoapConstants.WSDL_URL_PROPERTY);\n\n            if (StringUtils.isBlank(wsdlUrl))\n            {\n                xfireService = connector.getServiceFactory().create(exposedInterface,\n                    service.getName(), namespace, props);\n            }\n            else\n            {\n                xfireService = connector.getServiceFactory().create(exposedInterface,\n                    new QName(namespace, service.getName()), new URL(wsdlUrl), props);\n            }\n            \n            List inList = connector.getServerInHandlers();\n            if (inList != null)\n            {\n                for (int i = 0; i < inList.size(); i++)\n                {\n                    Class clazz = ClassUtils.loadClass(inList.get(i).toString(), this.getClass());\n                    Handler handler = (Handler) clazz.getConstructor((Class[])null).newInstance((Object[])null);\n                    xfireService.addInHandler(handler);\n                }\n            }\n\n            boolean sync = endpoint.isSynchronous();\n            xfireService.setInvoker(new MuleInvoker(this, sync));\n        }\n        catch (Exception e)\n        {\n            throw new CreateException(e, this);\n        }\n    }","id":42710,"modified_method":"protected void create() throws CreateException\n    {\n        try\n        {\n            Map props = new HashMap(endpoint.getProperties());\n\n            // convert port Type to QName if specified\n            if (props.containsKey(PORT_TYPE))\n            {\n                Object value = props.get(PORT_TYPE);\n                QName portTypeQName = QNamePropertyEditor.convert((String) value);\n                props.put(PORT_TYPE, portTypeQName);\n            }\n\n            // check if there is the namespace property on the service\n            String namespace = (String) endpoint.getProperties().get(SoapConstants.SOAP_NAMESPACE_PROPERTY);\n\n            // check for namespace set as annotation\n            if (connector.isEnableJSR181Annotations())\n            {\n                WebAnnotations wa = (WebAnnotations) ClassUtils.instanciateClass(\n                    XFireConnector.CLASSNAME_ANNOTATIONS, null, this.getClass());\n                // at this point, the object hasn't been created in the descriptor so\n                // we have to retrieve the implementation classname and create a\n                // class for it\n                WebServiceAnnotation webServiceAnnotation = \n                    wa.getWebServiceAnnotation(service.getServiceFactory().getObjectClass());\n                namespace = webServiceAnnotation.getTargetNamespace();\n            }\n\n            if ((namespace == null) || (namespace.equalsIgnoreCase(\"\")))\n            {\n                namespace = MapUtils.getString(props, \"namespace\", XFireConnector.DEFAULT_MULE_NAMESPACE_URI);\n            }\n\n            //Convert createDefaultBindings string to boolean before rewriting as xfire property\n            if (props.get(\"createDefaultBindings\") != null)\n            {\n                props.put(\"createDefaultBindings\", Boolean.valueOf((String) props.get(\"createDefaultBindings\")));\n            }\n\n            if (props.size() == 0)\n            {\n                // Xfire checks that properties are null rather than empty\n                props = null;\n            }\n            else\n            {\n                rewriteProperty(props, PORT_TYPE);\n                rewriteProperty(props, \"style\");\n                rewriteProperty(props, \"use\");\n                rewriteProperty(props, \"createDefaultBindings\");\n                rewriteProperty(props, \"soap12Transports\");\n                rewriteProperty(props, \"soap11Transports\");\n                rewriteProperty(props, \"scope\");\n                rewriteProperty(props, \"schemas\");\n            }\n\n            serviceInterfaces = (List)endpoint.getProperties().get(SoapConstants.SERVICE_INTERFACES);\n            Class exposedInterface;\n\n            if (serviceInterfaces == null)\n            {\n                exposedInterface = service.getServiceFactory().getObjectClass();\n            }\n            else\n            {\n                String className = (String) serviceInterfaces.get(0);\n                exposedInterface = ClassUtils.loadClass(className, this.getClass());\n                logger.info(className + \" class was used to expose your service\");\n\n                if (serviceInterfaces.size() > 1)\n                {\n                    logger.info(\"Only the first class was used to expose your method\");\n                }\n            }\n\n            String wsdlUrl = (String) endpoint.getProperties().get(SoapConstants.WSDL_URL_PROPERTY);\n\n            if (StringUtils.isBlank(wsdlUrl))\n            {\n                xfireService = connector.getServiceFactory().create(exposedInterface,\n                    service.getName(), namespace, props);\n            }\n            else\n            {\n                xfireService = connector.getServiceFactory().create(exposedInterface,\n                    new QName(namespace, service.getName()), new URL(wsdlUrl), props);\n            }\n            \n            List inList = connector.getServerInHandlers();\n            if (inList != null)\n            {\n                for (int i = 0; i < inList.size(); i++)\n                {\n                    Class clazz = ClassUtils.loadClass(inList.get(i).toString(), this.getClass());\n                    Handler handler = (Handler) clazz.getConstructor((Class[])null).newInstance((Object[])null);\n                    xfireService.addInHandler(handler);\n                }\n            }\n\n            boolean sync = endpoint.isSynchronous();\n            xfireService.setInvoker(new MuleInvoker(this, sync));\n        }\n        catch (Exception e)\n        {\n            throw new CreateException(e, this);\n        }\n    }","commit_id":"dcbb8118f183155acc1a7df20af41a80f037c6bd","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n  public void testCreateBoot() throws Exception {\n    if (SystemInfo.isWindows) return; // Windows is not supported so far\n    File bootJDK = new File(System.getProperty(\"java.home\")).getParentFile();\n    if (SystemInfo.isMac) {\n      bootJDK = bootJDK.getParentFile().getParentFile();\n    }\n    String verStr = System.getProperty(\"java.version\");\n\n    JdkBundle bundle = JdkBundle.createBoot();\n\n    assertTrue(bundle.isBoot());\n    assertFalse(bundle.isBundled());\n\n    assertTrue(FileUtil.filesEqual(bundle.getBundleAsFile(), bootJDK));\n    Pair<Version, Integer> verUpdate = bundle.getVersionUpdate();\n\n    assertNotNull(verUpdate);\n\n    assertEquals(verStr, verUpdate.first.toString() + \"_\" + verUpdate.second.toString());\n  }","id":42711,"modified_method":"@Test\n  public void testCreateBoot() throws Exception {\n    if (SystemInfo.isWindows) return; // Windows is not supported so far\n    File bootJDK = new File(System.getProperty(\"java.home\")).getParentFile();\n\n    if (!new File(bootJDK, \"lib/tools.jar\").exists()) return; // Skip pure jre\n\n    if (SystemInfo.isMac) {\n      bootJDK = bootJDK.getParentFile().getParentFile();\n    }\n    String verStr = System.getProperty(\"java.version\");\n\n    JdkBundle bundle = JdkBundle.createBoot();\n\n    assertNotNull(bundle);\n    assertTrue(bundle.isBoot());\n    assertFalse(bundle.isBundled());\n\n    assertTrue(FileUtil.filesEqual(bundle.getBundleAsFile(), bootJDK));\n    Pair<Version, Integer> verUpdate = bundle.getVersionUpdate();\n\n    assertNotNull(verUpdate);\n\n    assertEquals(verStr, verUpdate.first.toString() + \"_\" + verUpdate.second.toString());\n  }","commit_id":"03d72ab48ddd551dd055be43b161c8dd630b1963","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testCreateBundle() throws Exception {\n    if (SystemInfo.isWindows) return; // Windows is not supported so far\n    File bootJDK = new File(System.getProperty(\"java.home\")).getParentFile();\n    if (SystemInfo.isMac) {\n      bootJDK = bootJDK.getParentFile().getParentFile();\n    }\n    String verStr = System.getProperty(\"java.version\");\n\n    JdkBundle bundle = JdkBundle.createBundle(bootJDK, true, true);\n    assertNotNull(bundle);\n\n    assertTrue(bundle.isBoot());\n    assertTrue(bundle.isBundled());\n\n    assertTrue(FileUtil.filesEqual(bundle.getBundleAsFile(), bootJDK));\n    Pair<Version, Integer> verUpdate = bundle.getVersionUpdate();\n\n    assertNotNull(verUpdate);\n\n    assertEquals(verStr, verUpdate.first.toString() + \"_\" + verUpdate.second.toString());\n  }","id":42712,"modified_method":"@Test\n  public void testCreateBundle() throws Exception {\n    if (SystemInfo.isWindows) return; // Windows is not supported so far\n    File bootJDK = new File(System.getProperty(\"java.home\")).getParentFile();\n\n    if (!new File(bootJDK, \"lib/tools.jar\").exists()) return; // Skip pure jre\n\n    if (SystemInfo.isMac) {\n      bootJDK = bootJDK.getParentFile().getParentFile();\n    }\n    String verStr = System.getProperty(\"java.version\");\n\n    JdkBundle bundle = JdkBundle.createBundle(bootJDK, true, true);\n    assertNotNull(bundle);\n\n    assertTrue(bundle.isBoot());\n    assertTrue(bundle.isBundled());\n\n    assertTrue(FileUtil.filesEqual(bundle.getBundleAsFile(), bootJDK));\n    Pair<Version, Integer> verUpdate = bundle.getVersionUpdate();\n\n    assertNotNull(verUpdate);\n\n    assertEquals(verStr, verUpdate.first.toString() + \"_\" + verUpdate.second.toString());\n  }","commit_id":"03d72ab48ddd551dd055be43b161c8dd630b1963","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static JdkBundleList findJdkPaths() {\n    JdkBundle bootJdk = JdkBundle.createBoot();\n\n    JdkBundleList jdkBundleList = new JdkBundleList();\n    jdkBundleList.addBundle(bootJdk, true);\n\n    if (bundledJdkFile.exists()) {\n      JdkBundle bundledJdk = JdkBundle.createBundle(bundledJdkFile, false, true);\n      jdkBundleList.addBundle(bundledJdk, true);\n    }\n\n    if (SystemInfo.isMac) {\n      jdkBundleList.addBundlesFromLocation(STANDARD_JDK_6_LOCATION_ON_MAC_OS_X, JDK6_VERSION, JDK6_VERSION);\n      jdkBundleList.addBundlesFromLocation(STANDARD_JDK_LOCATION_ON_MAC_OS_X, JDK6_VERSION, JDK6_VERSION);\n      jdkBundleList.addBundlesFromLocation(STANDARD_JDK_LOCATION_ON_MAC_OS_X, JDK8_VERSION, null);\n    }\n    else if (SystemInfo.isLinux) {\n      for (String location : STANDARD_JVM_LOCATIONS_ON_LINUX) {\n        jdkBundleList.addBundlesFromLocation(location, JDK8_VERSION, null);\n      }\n    }\n\n    return jdkBundleList;\n  }","id":42713,"modified_method":"@NotNull\n  private static JdkBundleList findJdkPaths() {\n    JdkBundle bootJdk = JdkBundle.createBoot();\n\n    JdkBundleList jdkBundleList = new JdkBundleList();\n    if (bootJdk != null) {\n      jdkBundleList.addBundle(bootJdk, true);\n    }\n\n    if (bundledJdkFile.exists()) {\n      JdkBundle bundledJdk = JdkBundle.createBundle(bundledJdkFile, false, true);\n      if (bundledJdk != null) {\n        jdkBundleList.addBundle(bundledJdk, true);\n      }\n    }\n\n    if (SystemInfo.isMac) {\n      jdkBundleList.addBundlesFromLocation(STANDARD_JDK_6_LOCATION_ON_MAC_OS_X, JDK6_VERSION, JDK6_VERSION);\n      jdkBundleList.addBundlesFromLocation(STANDARD_JDK_LOCATION_ON_MAC_OS_X, JDK6_VERSION, JDK6_VERSION);\n      jdkBundleList.addBundlesFromLocation(STANDARD_JDK_LOCATION_ON_MAC_OS_X, JDK8_VERSION, null);\n    }\n    else if (SystemInfo.isLinux) {\n      for (String location : STANDARD_JVM_LOCATIONS_ON_LINUX) {\n        jdkBundleList.addBundlesFromLocation(location, JDK8_VERSION, null);\n      }\n    }\n\n    return jdkBundleList;\n  }","commit_id":"03d72ab48ddd551dd055be43b161c8dd630b1963","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n     * @param args\r\n     */\r\n    public static void main(String[] args) throws Exception{\r\n    \tFelixLauncher launcher=new FelixLauncher();\r\n        String jmood=\"file:target/org.apache.felix.jmood-0.8.0-SNAPSHOT.jar\";\r\n        String jmxintrospector=\"file:../org.apache.felix.mishell/target/org.apache.felix.mishell-0.8.0-SNAPSHOT.jar\";\r\n    \tlauncher.addBundle(jmood);\r\n    \tlauncher.addBundle(jmxintrospector);\r\n        launcher.addPackage(\"org.osgi.framework\");\r\n        launcher.addPackage(\"org.osgi.util.tracker\");\r\n        launcher.addPackage(\"org.osgi.service.log\");\r\n        launcher.addPackage(\"org.osgi.service.packageadmin\");\r\n        launcher.addPackage(\"org.osgi.service.startlevel\");\r\n        launcher.addPackage(\"org.osgi.service.permissionadmin\");\r\n        launcher.addPackage(\"org.osgi.service.useradmin\");\r\n        launcher.addPackage(\"org.osgi.service.cm\");\r\n        launcher.addPackage(\"javax.management\");\r\n        launcher.addPackage(\"javax.management.remote\");\r\n        launcher.addPackage(\"javax.script\");\r\n    \tlauncher.start();\r\n    }","id":42714,"modified_method":"/**\r\n     * @param args\r\n     * \r\n     */\r\n    public static void main(String[] args) throws Exception{\r\n    \tFelixLauncher launcher=new FelixLauncher();\r\n    \tString jmood=launcher.getFelixBundleUrl(\"org.apache.felix.jmood\");\r\n    \tString mishell=launcher.getFelixBundleUrl(\"org.apache.felix.mishell\");\r\n    \tString jruby=launcher.getM2Url(\"org.jruby\", \"jruby-bundle\", \"0.8.0-SNAPSHOT\");\r\n    \tlauncher.addBundle(jruby);\r\n        launcher.addBundle(jmood);\r\n    \tlauncher.addBundle(mishell);\r\n        launcher.addPackage(\"org.osgi.framework\");\r\n        launcher.addPackage(\"org.osgi.util.tracker\");\r\n        launcher.addPackage(\"org.osgi.service.log\");\r\n        launcher.addPackage(\"org.osgi.service.packageadmin\");\r\n        launcher.addPackage(\"org.osgi.service.startlevel\");\r\n        launcher.addPackage(\"org.osgi.service.permissionadmin\");\r\n        launcher.addPackage(\"org.osgi.service.useradmin\");\r\n        launcher.addPackage(\"org.osgi.service.cm\");\r\n        launcher.addPackage(\"javax.management\");\r\n        launcher.addPackage(\"javax.management.remote\");\r\n        launcher.addPackage(\"javax.management.openmbean\");  \r\n        launcher.addPackage(\"javax.script\");\r\n    \tlauncher.start();\r\n    }","commit_id":"c6560172da67936ffbc26e6a8a7360d73791df55","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void twoRoundRobin() throws Exception\n    {\n        startCluster( 5, 2, \"round_robin\" );\n\n        createTransactionOnMaster();\n        assertLastTransactions( lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ), lastTx( SECOND_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID ), lastTx( FOURTH_SLAVE, BASE_TX_ID ) );\n\n        createTransactionOnMaster();\n        assertLastTransactions( lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ), lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 2 ), lastTx( FOURTH_SLAVE, BASE_TX_ID ) );\n\n        createTransactionOnMaster();\n        assertLastTransactions( lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ), lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 3 ), lastTx( FOURTH_SLAVE, BASE_TX_ID + 3 ) );\n\n        createTransactionOnMaster();\n        assertLastTransactions( lastTx( FIRST_SLAVE, BASE_TX_ID + 4 ), lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 3 ), lastTx( FOURTH_SLAVE, BASE_TX_ID + 4 ) );\n    }","id":42715,"modified_method":"@Test\n    public void twoRoundRobin() throws Exception\n    {\n        ManagedCluster cluster = startCluster( 5, 2, \"round_robin\" );\n\n        createTransactionOnMaster( cluster );\n        assertLastTransactions( cluster,\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID ),\n                lastTx( FOURTH_SLAVE, BASE_TX_ID ) );\n\n        createTransactionOnMaster( cluster );\n        assertLastTransactions( cluster,\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( FOURTH_SLAVE, BASE_TX_ID ) );\n\n        createTransactionOnMaster( cluster );\n        assertLastTransactions( cluster,\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 3 ),\n                lastTx( FOURTH_SLAVE, BASE_TX_ID + 3 ) );\n\n        createTransactionOnMaster( cluster );\n        assertLastTransactions( cluster,\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 4 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 3 ),\n                lastTx( FOURTH_SLAVE, BASE_TX_ID + 4 ) );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startCluster( int memberCount, final int pushFactor, final String pushStrategy )\n    {\n        ClusterManager clusterManager = life.add( new ClusterManager( clusterOfSize( memberCount ),\n                testDirectory.directory( name.getMethodName() ), stringMap() )\n        {\n            @Override\n            protected void config( GraphDatabaseBuilder builder, String clusterName, InstanceId serverId )\n            {\n                builder.setConfig( HaSettings.tx_push_factor, \"\" + pushFactor );\n                builder.setConfig( HaSettings.tx_push_strategy, pushStrategy );\n            }\n        } );\n        life.start();\n        cluster = clusterManager.getDefaultCluster();\n        cluster.await( allSeesAllAsAvailable() );\n\n        mapMachineIds();\n    }","id":42716,"modified_method":"private ManagedCluster startCluster( int memberCount, final int pushFactor, final String pushStrategy )\n            throws Exception\n    {\n        ManagedCluster cluster = clusterRule.provider( clusterOfSize( memberCount ) )\n                .config( HaSettings.tx_push_factor, \"\" + pushFactor )\n                .config( HaSettings.tx_push_strategy, pushStrategy )\n                .availabilityChecks( Arrays.asList( allSeesAllAsAvailable() ) )\n                .startCluster();\n\n        mapMachineIds( cluster );\n\n        return cluster;\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createTransaction( final GraphDatabaseAPI db )\n    {\n        TransactionTemplate template = new TransactionTemplate()\n                .with( db )\n                .retries( 10 )\n                .backoff( 1, TimeUnit.SECONDS )\n                .monitor( new TransactionTemplate.Monitor.Adapter()\n                {\n                    @Override\n                    public void failure( Throwable ex )\n                    {\n                        // Assume this is because of master switch\n                        // Redo the machine id mapping\n                        cluster.await( allSeesAllAsAvailable() );\n                        mapMachineIds();\n                    }\n                } );\n        template.execute( new Consumer<Transaction>()\n        {\n            @Override\n            public void accept( Transaction transaction )\n            {\n                db.createNode();\n            }\n        } );\n    }","id":42717,"modified_method":"private void createTransaction( final ManagedCluster cluster, final GraphDatabaseAPI db )\n    {\n        TransactionTemplate template = new TransactionTemplate()\n                .with( db )\n                .retries( 10 )\n                .backoff( 1, TimeUnit.SECONDS )\n                .monitor( new TransactionTemplate.Monitor.Adapter()\n                {\n                    @Override\n                    public void failure( Throwable ex )\n                    {\n                        // Assume this is because of master switch\n                        // Redo the machine id mapping\n                        cluster.await( allSeesAllAsAvailable() );\n                        mapMachineIds( cluster );\n                    }\n                } );\n        template.execute( new Consumer<Transaction>()\n        {\n            @Override\n            public void accept( Transaction transaction )\n            {\n                db.createNode();\n            }\n        } );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPushToSlavesInDescendingOrder() throws Exception\n    {\n        startCluster( 4, 2, \"fixed\" );\n\n        for ( int i = 0; i < 5; i++ )\n        {\n            createTransactionOnMaster();\n            assertLastTransactions( lastTx( THIRD_SLAVE, BASE_TX_ID + 1 + i ) );\n            assertLastTransactions( lastTx( SECOND_SLAVE, BASE_TX_ID + 1 + i ) );\n            assertLastTransactions( lastTx( FIRST_SLAVE, BASE_TX_ID ) );\n        }\n    }","id":42718,"modified_method":"@Test\n    public void shouldPushToSlavesInDescendingOrder() throws Exception\n    {\n        ManagedCluster cluster = startCluster( 4, 2, \"fixed\" );\n\n        for ( int i = 0; i < 5; i++ )\n        {\n            createTransactionOnMaster( cluster );\n            assertLastTransactions( cluster, lastTx( THIRD_SLAVE, BASE_TX_ID + 1 + i ) );\n            assertLastTransactions( cluster, lastTx( SECOND_SLAVE, BASE_TX_ID + 1 + i ) );\n            assertLastTransactions( cluster, lastTx( FIRST_SLAVE, BASE_TX_ID ) );\n        }\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void slaveListIsCorrectAfterMasterSwitch() throws Exception\n    {\n        startCluster( 3, 1, \"fixed\" );\n        cluster.shutdown( cluster.getMaster() );\n        cluster.await( masterAvailable() );\n        HighlyAvailableGraphDatabase newMaster = cluster.getMaster();\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n        createTransaction( newMaster );\n        assertLastTransactions( lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ), lastTx( SECOND_SLAVE, BASE_TX_ID + 1 ) );\n    }","id":42719,"modified_method":"@Test\n    public void slaveListIsCorrectAfterMasterSwitch() throws Exception\n    {\n        ManagedCluster cluster = startCluster( 3, 1, \"fixed\" );\n        cluster.shutdown( cluster.getMaster() );\n        cluster.await( masterAvailable() );\n        HighlyAvailableGraphDatabase newMaster = cluster.getMaster();\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n        createTransaction( cluster, newMaster );\n        assertLastTransactions( cluster,\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 1 ) );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void assertLastTransactions( LastTxMapping... transactionMappings )\n    {\n        StringBuilder failures = new StringBuilder();\n        for ( LastTxMapping mapping : transactionMappings )\n        {\n            GraphDatabaseAPI db = cluster.getMemberByServerId( mapping.serverId );\n            mapping.format( failures, getLastTx( db ) );\n        }\n        assertTrue( failures.toString(), failures.length() == 0 );\n    }","id":42720,"modified_method":"private void assertLastTransactions( ManagedCluster cluster, LastTxMapping... transactionMappings )\n    {\n        StringBuilder failures = new StringBuilder();\n        for ( LastTxMapping mapping : transactionMappings )\n        {\n            GraphDatabaseAPI db = cluster.getMemberByServerId( mapping.serverId );\n            mapping.format( failures, getLastTx( db ) );\n        }\n        assertTrue( failures.toString(), failures.length() == 0 );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void slavesListGetsUpdatedWhenSlaveLeavesNicely() throws Exception\n    {\n        startCluster( 3, 1, \"fixed\" );\n\n        cluster.shutdown( cluster.getAnySlave() );\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n    }","id":42721,"modified_method":"@Test\n    public void slavesListGetsUpdatedWhenSlaveLeavesNicely() throws Exception\n    {\n        ManagedCluster cluster = startCluster( 3, 1, \"fixed\" );\n\n        cluster.shutdown( cluster.getAnySlave() );\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void slavesListGetsUpdatedWhenSlaveRageQuits() throws Throwable\n    {\n        startCluster( 3, 1, \"fixed\" );\n        cluster.fail( cluster.getAnySlave() );\n\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n    }","id":42722,"modified_method":"@Test\n    public void slavesListGetsUpdatedWhenSlaveRageQuits() throws Throwable\n    {\n        ManagedCluster cluster = startCluster( 3, 1, \"fixed\" );\n        cluster.fail( cluster.getAnySlave() );\n\n        cluster.await( masterSeesSlavesAsAvailable( 1 ) );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createTransactionOn( InstanceId serverId )\n    {\n        createTransaction( cluster.getMemberByServerId( serverId ) );\n    }","id":42723,"modified_method":"private void createTransactionOn( ManagedCluster cluster, InstanceId serverId )\n    {\n        createTransaction( cluster, cluster.getMemberByServerId( serverId ) );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPushToOneLessSlaveOnSlaveCommit() throws Exception\n    {\n        startCluster( 4, 2, \"fixed\" );\n\n        createTransactionOn( new InstanceId( FIRST_SLAVE ) );\n        assertLastTransactions( lastTx( MASTER, BASE_TX_ID + 1 ), lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID ), lastTx( THIRD_SLAVE, BASE_TX_ID + 1 ) );\n\n        createTransactionOn( new InstanceId( SECOND_SLAVE ) );\n        assertLastTransactions( lastTx( MASTER, BASE_TX_ID + 2 ), lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ), lastTx( THIRD_SLAVE, BASE_TX_ID + 2 ) );\n\n        createTransactionOn( new InstanceId( THIRD_SLAVE ) );\n        assertLastTransactions( lastTx( MASTER, BASE_TX_ID + 3 ), lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 3 ), lastTx( THIRD_SLAVE, BASE_TX_ID + 3 ) );\n    }","id":42724,"modified_method":"@Test\n    public void shouldPushToOneLessSlaveOnSlaveCommit() throws Exception\n    {\n        ManagedCluster cluster = startCluster( 4, 2, \"fixed\" );\n\n        createTransactionOn( cluster, new InstanceId( FIRST_SLAVE ) );\n        assertLastTransactions( cluster,\n                lastTx( MASTER, BASE_TX_ID + 1 ),\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 1 ) );\n\n        createTransactionOn( cluster, new InstanceId( SECOND_SLAVE ) );\n        assertLastTransactions( cluster,\n                lastTx( MASTER, BASE_TX_ID + 2 ),\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 2 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 2 ) );\n\n        createTransactionOn( cluster, new InstanceId( THIRD_SLAVE ) );\n        assertLastTransactions( cluster,\n                lastTx( MASTER, BASE_TX_ID + 3 ),\n                lastTx( FIRST_SLAVE, BASE_TX_ID + 1 ),\n                lastTx( SECOND_SLAVE, BASE_TX_ID + 3 ),\n                lastTx( THIRD_SLAVE, BASE_TX_ID + 3 ) );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createTransactionOnMaster()\n    {\n        createTransaction( cluster.getMaster() );\n    }","id":42725,"modified_method":"private void createTransactionOnMaster( ManagedCluster cluster )\n    {\n        createTransaction( cluster, cluster.getMaster() );\n    }","commit_id":"f6ac03090b58c33709801376843bbf395eae3681","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testFailOver( int clusterSize ) throws Throwable\n    {\n        // given\n        ClusterManager clusterManager = new ClusterManager( clusterOfSize( clusterSize ), dir.cleanDirectory( \"failover\" ), stringMap(\n                ClusterSettings.default_timeout.name(),    \"1\",\n                ClusterSettings.heartbeat_interval.name(), \"1\",\n                ClusterSettings.heartbeat_timeout.name(),  \"2\" ) );\n\n        clusterManager.start();\n        ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n\n        cluster.await( ClusterManager.allSeesAllAsAvailable() );\n        HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n\n        // When\n        long start = System.nanoTime();\n        ClusterManager.RepairKit repairKit = cluster.fail( oldMaster );\n        logger.getLogger().warn( \"Shut down master\" );\n\n        // Then\n        cluster.await( ClusterManager.masterAvailable( oldMaster ) );\n        long end = System.nanoTime();\n\n        logger.getLogger().warn( \"Failover took:\" + (end - start) / 1000000 + \"ms\" );\n\n        repairKit.repair();\n        Thread.sleep( 3000 ); // give repaired instance chance to cleanly rejoin and exit faster\n\n        clusterManager.stop();\n    }","id":42726,"modified_method":"private void testFailOver( int clusterSize ) throws Throwable\n    {\n        // given\n        ClusterManager clusterManager = new ClusterManager.Builder().withRootDirectory( dir.cleanDirectory( \"failover\" ) ).\n        withProvider( ClusterManager.clusterOfSize( clusterSize ) )\n                .withSharedConfig( stringMap(\n                    ClusterSettings.default_timeout.name(),    \"1\",\n                    ClusterSettings.heartbeat_interval.name(), \"1\",\n                    ClusterSettings.heartbeat_timeout.name(),  \"2\" ) )\n                .build();\n\n        clusterManager.start();\n        ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n\n        cluster.await( ClusterManager.allSeesAllAsAvailable() );\n        HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n\n        // When\n        long start = System.nanoTime();\n        ClusterManager.RepairKit repairKit = cluster.fail( oldMaster );\n        logger.getLogger().warning( \"Shut down master\" );\n\n        // Then\n        cluster.await( ClusterManager.masterAvailable( oldMaster ) );\n        long end = System.nanoTime();\n\n        logger.getLogger().warning( \"Failover took:\" + (end - start) / 1000000 + \"ms\" );\n\n        repairKit.repair();\n        Thread.sleep( 3000 ); // give repaired instance chance to cleanly rejoin and exit faster\n\n        clusterManager.stop();\n    }","commit_id":"6d7c70f3856810ee8ba082a042bdbea8c9d947a9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testFailoverWithAdditionalSlave( int clusterSize, int[] slaveIndexes ) throws Throwable\n    {\n        ClusterManager manager = new ClusterManager( ClusterManager.clusterOfSize( clusterSize ),\n                TargetDirectory.forTest( getClass() ).cleanDirectory( \"testCluster\" ), stringMap(\n                ClusterSettings.default_timeout.name(),    \"1\",\n                ClusterSettings.heartbeat_interval.name(), \"1\",\n                ClusterSettings.heartbeat_timeout.name(),  \"2\" ) );\n\n        try\n        {\n            manager.start();\n            ClusterManager.ManagedCluster cluster = manager.getDefaultCluster();\n\n            cluster.await( allSeesAllAsAvailable() );\n            cluster.await( masterAvailable() );\n\n            Collection<HighlyAvailableGraphDatabase> failed = new ArrayList<>();\n            Collection<RepairKit> repairKits = new ArrayList<>();\n\n            for ( int slaveIndex : slaveIndexes )\n            {\n                HighlyAvailableGraphDatabase nthSlave = getNthSlave( cluster, slaveIndex );\n                failed.add( nthSlave );\n                RepairKit repairKit = cluster.fail( nthSlave );\n                repairKits.add( repairKit );\n            }\n\n            HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n            failed.add( oldMaster );\n            repairKits.add( cluster.fail( oldMaster ) );\n\n            cluster.await( masterAvailable( toArray( failed ) ) );\n\n            for ( RepairKit repairKit : repairKits )\n            {\n                repairKit.repair();\n            }\n\n            Thread.sleep( 3000 ); // give repaired instances a chance to cleanly rejoin and exit faster\n        }\n        finally\n        {\n            manager.shutdown();\n        }\n    }","id":42727,"modified_method":"private void testFailoverWithAdditionalSlave( int clusterSize, int[] slaveIndexes ) throws Throwable\n    {\n        ClusterManager manager = new ClusterManager.Builder().withRootDirectory( dir.cleanDirectory( \"testcluster\" ) ).\n                withProvider( ClusterManager.clusterOfSize( clusterSize ) )\n                .withSharedConfig( stringMap(\n                        ClusterSettings.default_timeout.name(),    \"1\",\n                        ClusterSettings.heartbeat_interval.name(), \"1\",\n                        ClusterSettings.heartbeat_timeout.name(),  \"2\" ) )\n                .build();\n\n        try\n        {\n            manager.start();\n            ClusterManager.ManagedCluster cluster = manager.getDefaultCluster();\n\n            cluster.await( allSeesAllAsAvailable() );\n            cluster.await( masterAvailable() );\n\n            Collection<HighlyAvailableGraphDatabase> failed = new ArrayList<>();\n            Collection<RepairKit> repairKits = new ArrayList<>();\n\n            for ( int slaveIndex : slaveIndexes )\n            {\n                HighlyAvailableGraphDatabase nthSlave = getNthSlave( cluster, slaveIndex );\n                failed.add( nthSlave );\n                RepairKit repairKit = cluster.fail( nthSlave );\n                repairKits.add( repairKit );\n            }\n\n            HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n            failed.add( oldMaster );\n            repairKits.add( cluster.fail( oldMaster ) );\n\n            cluster.await( masterAvailable( toArray( failed ) ) );\n\n            for ( RepairKit repairKit : repairKits )\n            {\n                repairKit.repair();\n            }\n\n            Thread.sleep( 3000 ); // give repaired instances a chance to cleanly rejoin and exit faster\n        }\n        finally\n        {\n            manager.shutdown();\n        }\n    }","commit_id":"6d7c70f3856810ee8ba082a042bdbea8c9d947a9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testFailOver( int clusterSize ) throws Throwable\n    {\n        // given\n        ClusterManager clusterManager = new ClusterManager( clusterOfSize( clusterSize ), dir.cleanDirectory( \"failover\" ), stringMap(\n                ClusterSettings.default_timeout.name(),    \"1\",\n                ClusterSettings.heartbeat_interval.name(), \"1\",\n                ClusterSettings.heartbeat_timeout.name(),  \"2\" ) );\n\n        clusterManager.start();\n        ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n\n        cluster.await( ClusterManager.allSeesAllAsAvailable() );\n        HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n\n        // When\n        long start = System.nanoTime();\n        ClusterManager.RepairKit repairKit = cluster.fail( oldMaster );\n        logger.getLogger().warn( \"Shut down master\" );\n\n        // Then\n        cluster.await( ClusterManager.masterAvailable( oldMaster ) );\n        long end = System.nanoTime();\n\n        logger.getLogger().warn( \"Failover took:\" + (end - start) / 1000000 + \"ms\" );\n\n        repairKit.repair();\n        Thread.sleep( 3000 ); // give repaired instance chance to cleanly rejoin and exit faster\n\n        clusterManager.stop();\n    }","id":42728,"modified_method":"private void testFailOver( int clusterSize ) throws Throwable\n    {\n        // given\n        ClusterManager clusterManager = new ClusterManager.Builder().withRootDirectory( dir.cleanDirectory( \"failover\" ) ).\n        withProvider( ClusterManager.clusterOfSize( clusterSize ) )\n                .withSharedConfig( stringMap(\n                    ClusterSettings.default_timeout.name(),    \"1\",\n                    ClusterSettings.heartbeat_interval.name(), \"1\",\n                    ClusterSettings.heartbeat_timeout.name(),  \"2\" ) )\n                .build();\n\n        clusterManager.start();\n        ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n\n        cluster.await( ClusterManager.allSeesAllAsAvailable() );\n        HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n\n        // When\n        long start = System.nanoTime();\n        ClusterManager.RepairKit repairKit = cluster.fail( oldMaster );\n        logger.getLogger().warning( \"Shut down master\" );\n\n        // Then\n        cluster.await( ClusterManager.masterAvailable( oldMaster ) );\n        long end = System.nanoTime();\n\n        logger.getLogger().warning( \"Failover took:\" + (end - start) / 1000000 + \"ms\" );\n\n        repairKit.repair();\n        Thread.sleep( 3000 ); // give repaired instance chance to cleanly rejoin and exit faster\n\n        clusterManager.stop();\n    }","commit_id":"140c532415d4f21837e92edde8c9bd1d1b8c2693","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testFailoverWithAdditionalSlave( int clusterSize, int[] slaveIndexes ) throws Throwable\n    {\n        ClusterManager manager = new ClusterManager( ClusterManager.clusterOfSize( clusterSize ),\n                TargetDirectory.forTest( getClass() ).cleanDirectory( \"testCluster\" ), stringMap(\n                ClusterSettings.default_timeout.name(),    \"1\",\n                ClusterSettings.heartbeat_interval.name(), \"1\",\n                ClusterSettings.heartbeat_timeout.name(),  \"2\" ) );\n\n        try\n        {\n            manager.start();\n            ClusterManager.ManagedCluster cluster = manager.getDefaultCluster();\n\n            cluster.await( allSeesAllAsAvailable() );\n            cluster.await( masterAvailable() );\n\n            Collection<HighlyAvailableGraphDatabase> failed = new ArrayList<>();\n            Collection<RepairKit> repairKits = new ArrayList<>();\n\n            for ( int slaveIndex : slaveIndexes )\n            {\n                HighlyAvailableGraphDatabase nthSlave = getNthSlave( cluster, slaveIndex );\n                failed.add( nthSlave );\n                RepairKit repairKit = cluster.fail( nthSlave );\n                repairKits.add( repairKit );\n            }\n\n            HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n            failed.add( oldMaster );\n            repairKits.add( cluster.fail( oldMaster ) );\n\n            cluster.await( masterAvailable( toArray( failed ) ) );\n\n            for ( RepairKit repairKit : repairKits )\n            {\n                repairKit.repair();\n            }\n\n            Thread.sleep( 3000 ); // give repaired instances a chance to cleanly rejoin and exit faster\n        }\n        finally\n        {\n            manager.shutdown();\n        }\n    }","id":42729,"modified_method":"private void testFailoverWithAdditionalSlave( int clusterSize, int[] slaveIndexes ) throws Throwable\n    {\n        ClusterManager manager = new ClusterManager.Builder().withRootDirectory( dir.cleanDirectory( \"testcluster\" ) ).\n                withProvider( ClusterManager.clusterOfSize( clusterSize ) )\n                .withSharedConfig( stringMap(\n                        ClusterSettings.default_timeout.name(),    \"1\",\n                        ClusterSettings.heartbeat_interval.name(), \"1\",\n                        ClusterSettings.heartbeat_timeout.name(),  \"2\" ) )\n                .build();\n\n        try\n        {\n            manager.start();\n            ClusterManager.ManagedCluster cluster = manager.getDefaultCluster();\n\n            cluster.await( allSeesAllAsAvailable() );\n            cluster.await( masterAvailable() );\n\n            Collection<HighlyAvailableGraphDatabase> failed = new ArrayList<>();\n            Collection<RepairKit> repairKits = new ArrayList<>();\n\n            for ( int slaveIndex : slaveIndexes )\n            {\n                HighlyAvailableGraphDatabase nthSlave = getNthSlave( cluster, slaveIndex );\n                failed.add( nthSlave );\n                RepairKit repairKit = cluster.fail( nthSlave );\n                repairKits.add( repairKit );\n            }\n\n            HighlyAvailableGraphDatabase oldMaster = cluster.getMaster();\n            failed.add( oldMaster );\n            repairKits.add( cluster.fail( oldMaster ) );\n\n            cluster.await( masterAvailable( toArray( failed ) ) );\n\n            for ( RepairKit repairKit : repairKits )\n            {\n                repairKit.repair();\n            }\n\n            Thread.sleep( 3000 ); // give repaired instances a chance to cleanly rejoin and exit faster\n        }\n        finally\n        {\n            manager.shutdown();\n        }\n    }","commit_id":"140c532415d4f21837e92edde8c9bd1d1b8c2693","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void actionPerformed(AnActionEvent e) {\n      ShowSettingsUtil.getInstance()\n        .editConfigurable(myProject, OptionsEditorDialog.DIMENSION_KEY, ProjectStructureConfigurable.getInstance(myProject));\n    }","id":42730,"modified_method":"@Override\n    public void actionPerformed(AnActionEvent e) {\n      final FlexIdeBuildConfiguration activeConfiguration = FlexBuildConfigurationManager.getInstance(myModule).getActiveConfiguration();\n      final ProjectStructureConfigurable c = ProjectStructureConfigurable.getInstance(myModule.getProject());\n      ShowSettingsUtil.getInstance().editConfigurable(myModule.getProject(), c, new Runnable() {\n        @Override\n        public void run() {\n          Place p = FlexIdeModuleStructureExtension.getInstance().getConfigurator().getPlaceFor(myModule, activeConfiguration);\n          c.navigateTo(p, true);\n        }\n      });\n    }","commit_id":"2692ef3f570a78b6e26f8ddcc1134a706860d79a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public EditBcsAction(Project project) {\n      super(\"Configure project\", \"Edit Flex build configurations\", IconLoader.getIcon(\"/actions/editSource.png\"));\n      myProject = project;\n    }","id":42731,"modified_method":"public EditBcsAction(Module module) {\n      super(\"Configure project\", \"Edit Flex build configurations\", IconLoader.getIcon(\"/actions/editSource.png\"));\n      myModule = module;\n    }","commit_id":"2692ef3f570a78b6e26f8ddcc1134a706860d79a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  protected DefaultActionGroup createPopupActionGroup(JComponent button) {\n    DefaultActionGroup group = new DefaultActionGroup();\n    FlexBuildConfigurationManager bcManager = FlexBuildConfigurationManager.getInstance(myLastModule);\n    FlexIdeBuildConfiguration[] buildConfigurations = bcManager.getBuildConfigurations();\n    group.add(new EditBcsAction(myLastModule.getProject()));\n    group.addSeparator();\n    for (FlexIdeBuildConfiguration c : buildConfigurations) {\n      group.add(new BCAction(myLastModule, c));\n    }\n    return group;\n  }","id":42732,"modified_method":"@NotNull\n  @Override\n  protected DefaultActionGroup createPopupActionGroup(JComponent button) {\n    DefaultActionGroup group = new DefaultActionGroup();\n    FlexBuildConfigurationManager bcManager = FlexBuildConfigurationManager.getInstance(myLastModule);\n    FlexIdeBuildConfiguration[] buildConfigurations = bcManager.getBuildConfigurations();\n    group.add(new EditBcsAction(myLastModule));\n    group.addSeparator();\n    for (FlexIdeBuildConfiguration c : buildConfigurations) {\n      group.add(new BCAction(myLastModule, c));\n    }\n    return group;\n  }","commit_id":"2692ef3f570a78b6e26f8ddcc1134a706860d79a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void disposeUIResources() {\n    if (myRootTreeEditor != null) {\n      myRootTreeEditor.setContentEntryEditor(null);\n    }\n    super.disposeUIResources();\n  }","id":42733,"modified_method":"public void disposeUIResources() {\n    if (myRootTreeEditor != null) {\n      myRootTreeEditor.setContentEntryEditor(null);\n    }\n    myEntryToEditorMap.clear();\n    super.disposeUIResources();\n  }","commit_id":"c94576287980fd14faa0cd5fdade6202038e11b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disposeUIResources() {\n    myCbModuleJdk = null;\n    myJdkPanel = null;\n  }","id":42734,"modified_method":"public void disposeUIResources() {\n    myModuleEditor = null;\n    myCbModuleJdk = null;\n    myJdkPanel = null;\n  }","commit_id":"c94576287980fd14faa0cd5fdade6202038e11b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean showDialog(Project project, String moduleToSelect, String tabNameToSelect, final boolean show) {\n    final ProjectRootConfigurable projectRootConfigurable = ProjectRootConfigurable.getInstance(project);\n    projectRootConfigurable.selectModuleTab(moduleToSelect, tabNameToSelect);\n    projectRootConfigurable.setStartModuleWizard(show);\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        projectRootConfigurable.setStartModuleWizard(false);\n      }\n    });\n    return ShowSettingsUtil.getInstance().editConfigurable(project, DIMENSION_KEY, projectRootConfigurable);\n  }","id":42735,"modified_method":"public static boolean showDialog(Project project, final String moduleToSelect, final String tabNameToSelect, final boolean show) {\n    final ProjectRootConfigurable projectRootConfigurable = ProjectRootConfigurable.getInstance(project);\n    return ShowSettingsUtil.getInstance().editConfigurable(project, projectRootConfigurable, new Runnable(){\n      public void run() {\n        projectRootConfigurable.selectModuleTab(moduleToSelect, tabNameToSelect);\n        projectRootConfigurable.setStartModuleWizard(show);\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            projectRootConfigurable.setStartModuleWizard(false);\n          }\n        });\n      }\n    });\n  }","commit_id":"c94576287980fd14faa0cd5fdade6202038e11b2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    EditorOptions editorOptions = ShowSettingsUtil.getInstance().findApplicationConfigurable(EditorOptions.class);\n    final DefaultSearchableConfigurable configurable = new DefaultSearchableConfigurable(editorOptions);\n    ShowSettingsUtil.getInstance().editConfigurable(project, configurable, new Runnable() {\n      public void run() {\n        configurable.enableSearch(ApplicationBundle.message(\"group.code.folding\"));\n      }\n    });\n  }","id":42736,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    EditorOptions editorOptions = ShowSettingsUtil.getInstance().findApplicationConfigurable(EditorOptions.class);\n    final Configurable[] configurables = editorOptions.getConfigurables();\n    for (Configurable c : configurables) {\n      if (c instanceof CodeFoldingConfigurable) {\n        ShowSettingsUtil.getInstance().editConfigurable(project, c);\n        break;\n      }\n    }\n  }","commit_id":"84524142f1ad30614ed726658f949bd64dbcc88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Resolves the specified name to a Class. The method loadClass()\n     * is called by the virtual machine.  As an abstract method,\n     * loadClass() must be defined in a subclass of ClassLoader.\n     *\n     * @param      name the name of the desired Class.\n     * @param      resolve true if the Class needs to be resolved;\n     *             false if the virtual machine just wants to determine\n     *             whether the class exists or not\n     * @return     the resulting Class.\n     * @exception  ClassNotFoundException  if the class loader cannot\n     *             find a the requested class.\n     */\n    protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsClassLoader] Class \" + name + \" requested.\");\n        }\n        Class c = null;\n        CmsFile classFile = null;\n        // first try to load the class using the systemClassloader\n        try{\n            ClassLoader sysClassLoader = this.getSystemClassLoader();\n            c = sysClassLoader.loadClass(name);\n        }catch(ClassNotFoundException exc){\n             // to continue set c back to null\n            c = null;\n        }\n        if(c != null) {\n            return c;\n        }\n        // try to load the class using the parent class loader.\n        try {\n            ClassLoader apClassLoader = this.getClass().getClassLoader();\n            InputStream fromAp = apClassLoader.getResourceAsStream(name.replace('.','/')+\".class\");\n            byte[] myClassData = null;\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            if(fromAp != null){\n                copyStream(fromAp, outStream);\n                myClassData = outStream.toByteArray();\n            }\n            // Class data successfully read. Now define a new class using this data\n            if(myClassData != null) {\n                try {\n                    c = defineClass(null, myClassData, 0, myClassData.length);\n                }\n                catch(Exception e) {\n                    throw new ClassNotFoundException(e.toString());\n                }\n                catch(Error e) {\n                    throw new ClassNotFoundException(\"Something really bad happened while loading class \" + name);\n                }\n                cache.put(name, c);\n                if(resolve) {\n                    resolveClass(c);\n                }\n                if(A_OpenCms.isLogging()) {\n                    A_OpenCms.log(C_OPENCMS_DEBUG, \"Classloader returned class \"\n                            + name + \" successfully!\");\n                }\n                return c;\n            }\n\n            //c = Class.forName(name);\n        }catch(ClassNotFoundException e) {\n            // to continue set c back to null\n            c = null;\n        }catch(IOException  e) {\n            // to continue set c back to null\n            c = null;\n        }\n        if(c != null) {\n            return c;\n        }\n\n        // OK. The parent loader didn't find the class.\n        // Let's have a look in our own class cache\n        c = (Class)cache.get(name);\n        if(c != null) {\n            if(A_OpenCms.isLogging()) {\n                A_OpenCms.log(C_OPENCMS_DEBUG, \"BINGO! Class \" + name + \"was found in cache.\");\n            }\n\n            // bingo! the class is already loaded and is\n            // stored in our classcache\n            if(resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"Class \" + name + \"was NOT found in cache.\");\n        }\n\n        // No class found.\n        // Then we have to search in the OpenCMS System.\n        Enumeration allRepositories = repository.elements();\n        String filename = null;\n        byte[] myClassData = null;\n        while((allRepositories.hasMoreElements()) && (classFile == null)) {\n            filename = (String)allRepositories.nextElement();\n            if(isZipOrJarArchive(filename)) {\n                try {\n                    if(A_OpenCms.isLogging()) {\n                        A_OpenCms.log(C_OPENCMS_DEBUG, \"Try to load archive file \" + filename + \".\");\n                    }\n                    myClassData = loadClassFromZipFile(m_cms.readFile(filename), name);\n                }\n                catch(Exception e) {\n                    myClassData = null;\n                }\n            }\n            else {\n\n                //filename = filename + className;\n                // check if the repository name is just a path.\n                // if so, add the complete classname and the fileextension \".class\"\n                if(filename.endsWith(\"/\")) {\n                    String classname = name.replace('.', '/');\n                    filename = filename + classname + \".class\";\n                }\n                try {\n                   classFile = m_cms.readFile(filename);\n                    myClassData = classFile.getContents();\n                }\n                catch(Exception e) {\n                    // File could not be read for any reason\n                    classFile = null;\n                    myClassData = null;\n                }\n            }\n        }\n        if(classFile == null) {\n            throw new ClassNotFoundException(name);\n        }\n\n        // Class data successfully read. Now define a new class using this data\n        if(myClassData != null) {\n            try {\n                c = defineClass(null, myClassData, 0, myClassData.length);\n            }\n            catch(ClassFormatError e) {\n                throw new ClassNotFoundException(filename + \" seems to be no class file. Sorry.\");\n            }\n            catch(Exception e) {\n                throw new ClassNotFoundException(e.toString());\n            }\n            catch(Error e) {\n                throw new ClassNotFoundException(\"Something really bad happened while loading class \" + filename);\n            }\n            cache.put(name, c);\n            if(resolve) {\n                resolveClass(c);\n            }\n            if(A_OpenCms.isLogging()) {\n                A_OpenCms.log(C_OPENCMS_DEBUG, \"Classloader returned class \"\n                        + name + \" successfully!\");\n            }\n            return c;\n        }\n        throw new ClassNotFoundException(name);\n    }","id":42737,"modified_method":"/**\n     * Resolves the specified name to a Class. The method loadClass()\n     * is called by the virtual machine.  As an abstract method,\n     * loadClass() must be defined in a subclass of ClassLoader.\n     *\n     * @param      name the name of the desired Class.\n     * @param      resolve true if the Class needs to be resolved;\n     *             false if the virtual machine just wants to determine\n     *             whether the class exists or not\n     * @return     the resulting Class.\n     * @exception  ClassNotFoundException  if the class loader cannot\n     *             find a the requested class.\n     */\n    protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsClassLoader] Class \" + name + \" requested.\");\n        }\n        Class c = null;\n        // first try to load the class using the systemClassloader\n        try{\n            ClassLoader sysClassLoader = this.getSystemClassLoader();\n            c = sysClassLoader.loadClass(name);\n        }catch(ClassNotFoundException exc){\n             // to continue set c back to null\n            c = null;\n        }\n        if(c != null) {\n            return c;\n        }\n        // I shall not load myself, I shall not load myself\n        String heyItsMe = \"com.opencms.core.CmsClassLoader\";\n        if (heyItsMe.equals(name)  ){\n            c = Class.forName(name);\n            if (c != null){\n                return c;\n            }\n        }\n\n        // try to load the class using the parent class loader.\n        try {\n            ClassLoader apClassLoader = this.getClass().getClassLoader();\n            InputStream fromAp = apClassLoader.getResourceAsStream(name.replace('.','/')+\".class\");\n            byte[] myClassData = null;\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            if(fromAp != null){\n                copyStream(fromAp, outStream);\n                myClassData = outStream.toByteArray();\n            }\n            // Class data successfully read. Now define a new class using this data\n            if(myClassData != null) {\n                try {\n                    c = defineClass(null, myClassData, 0, myClassData.length);\n                }\n                catch(Exception e) {\n                    throw new ClassNotFoundException(e.toString());\n                }\n                catch(Error e) {\n                    throw new ClassNotFoundException(\"Something really bad happened while loading class \" + name);\n                }\n                cache.put(name, c);\n                if(resolve) {\n                    resolveClass(c);\n                }\n                if(C_DEBUG && A_OpenCms.isLogging()) {\n                    A_OpenCms.log(C_OPENCMS_DEBUG, \"Classloader returned class \"\n                            + name + \" successfully!\");\n                }\n                return c;\n            }\n\n            //c = Class.forName(name);\n        }catch(ClassNotFoundException e) {\n            // to continue set c back to null\n            c = null;\n        }catch(IOException  e) {\n            // to continue set c back to null\n            c = null;\n        }\n        if(c != null) {\n            return c;\n        }\n\n        // OK. The parent loader didn't find the class.\n        // Let's have a look in our own class cache\n        c = (Class)cache.get(name);\n        if(c != null) {\n            if(C_DEBUG && A_OpenCms.isLogging()) {\n                A_OpenCms.log(C_OPENCMS_DEBUG, \"BINGO! Class \" + name + \"was found in cache.\");\n            }\n\n            // bingo! the class is already loaded and is\n            // stored in our classcache\n            if(resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"Class \" + name + \"was NOT found in cache.\");\n        }\n\n        // No class found.\n        // Then we have to search in the OpenCMS System.\n        Enumeration allRepositories = repository.elements();\n        String filename = null;\n        byte[] myClassData = null;\n        while((allRepositories.hasMoreElements()) && (myClassData == null)) {\n            filename = (String)allRepositories.nextElement();\n\n/*            if(isZipOrJarArchive(filename)) {\n                try {\n                    if(A_OpenCms.isLogging()) {\n                        A_OpenCms.log(C_OPENCMS_DEBUG, \"Try to load archive file \" + filename + \".\");\n                    }\n                    myClassData = loadClassFromZipFile(readFile(filename), name);\n                }\n                catch(Exception e) {\n                    myClassData = null;\n                }\n            }\n            else */ {\n\n                //filename = filename + className;\n                // check if the repository name is just a path.\n                // if so, add the complete classname and the fileextension \".class\"\n                if(filename.endsWith(\"/\")) {\n                    String classname = name.replace('.', '/');\n                    filename = filename + classname + \".class\";\n                }\n                try {\n                   myClassData = readFileContent(filename);\n                }\n                catch(Exception e) {\n                    // File could not be read for any reason\n                    myClassData = null;\n                }\n            }\n        }\n        if(myClassData == null) {\n            throw new ClassNotFoundException(name);\n        }\n\n        // Class data successfully read. Now define a new class using this data\n        if(myClassData != null) {\n            try {\n                c = defineClass(null, myClassData, 0, myClassData.length);\n            }\n            catch(ClassFormatError e) {\n                throw new ClassNotFoundException(filename + \" seems to be no class file. Sorry.\");\n            }\n            catch(Exception e) {\n                throw new ClassNotFoundException(e.toString());\n            }\n            catch(Error e) {\n                throw new ClassNotFoundException(\"Something really bad happened while loading class \" + filename);\n            }\n            cache.put(name, c);\n            if(resolve) {\n                resolveClass(c);\n            }\n            if(C_DEBUG && A_OpenCms.isLogging()) {\n                A_OpenCms.log(C_OPENCMS_DEBUG, \"Classloader returned class \"\n                        + name + \" successfully!\");\n            }\n            return c;\n        }\n        throw new ClassNotFoundException(name);\n    }","commit_id":"d7ac12c396afe77e8320837c0a8c17d029cc939d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Clears the cache.\n     */\n    public static void clearCache() {\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_INFO, \"[CmsClassLoader] clearing class instance cache.\");\n        }\n        if (cache != null){\n            cache.clear();\n        }\n    }","id":42738,"modified_method":"/**\n     * Clears the cache.\n     */\n    public static void clearCache() {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_INFO, \"[CmsClassLoader] clearing class instance cache.\");\n        }\n        if (cache != null){\n            cache.clear();\n        }\n    }","commit_id":"d7ac12c396afe77e8320837c0a8c17d029cc939d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new class loader that will load classes from specified\n     * class repositories.\n     *\n     * @param cms CmsObject Object to get access to system resources\n     * @param classRepository An set of Strings indicating directories.\n     * @param parent Parent classloader that should be called first before\n     *        trying to load classes from the opencms system.\n     * @throw java.lang.IllegalArgumentException if the objects contained\n     *        in the vector are not valid cms folders.\n     *  >>>>>out of order<<<<<< /\n    public CmsClassLoader(CmsObject cms, Vector classRepository, ClassLoader parent) throws IllegalArgumentException {\n\n        // Create the cache of loaded classes\n        cache = new Hashtable();\n\n        // Verify that all the repository are valid.\n        if(classRepository == null) {\n            classRepository = new Vector();\n        }\n        Enumeration e = classRepository.elements();\n        while(e.hasMoreElements()) {\n            Object o = e.nextElement();\n            String file;\n\n            // Check to see if element is a File instance.\n            try {\n                file = (String)o;\n            }\n            catch(ClassCastException objectIsNotFile) {\n                throw new IllegalArgumentException(\"Object \" + o\n                        + \" is not a valid \\\"String\\\" instance\");\n            }\n\n            // Check to see if we have proper access.\n            try {\n                cms.readFolder(file);\n            }\n            catch(Exception exc) {\n                throw new IllegalArgumentException(\"Repository \"\n                        + file + \" could not be accessed while initializing class loader.\");\n            }\n        }\n\n        // Store the class repository for use\n        this.repository = classRepository;\n        // Increment and store generation counter\n        this.generation = generationCounter++;\n        this.m_cms = cms;\n    }\n\n    /**\n     * Creates a new class loader that will load classes from specified\n     * class repositories.\n     *\n     * @param cms CmsObject Object to get access to system resources\n     * @param classRepository An set of Strings indicating directories.\n     * @throw java.lang.IllegalArgumentException if the objects contained\n     *        in the vector are not valid cms folders.\n     */\n    void init(CmsObject cms, Vector classRepository) throws IllegalArgumentException {\n\n        // Verify that all the repository are valid.\n        if(classRepository == null) {\n            classRepository = new Vector();\n        }\n        Enumeration e = classRepository.elements();\n        while(e.hasMoreElements()) {\n            Object o = e.nextElement();\n            String file;\n\n            // Check to see if element is a File instance.\n            try {\n                file = (String)o;\n            }\n            catch(ClassCastException objectIsNotFile) {\n                throw new IllegalArgumentException(\"Object \" + o\n                        + \" is not a valid \\\"String\\\" instance\");\n            }\n\n            // Check to see if we have proper access.\n            try {\n                cms.readFolder(file);\n            }\n            catch(Exception exc) {\n                throw new IllegalArgumentException(\"Repository \"\n                        + file + \" could not be accessed while initializing class loader.\");\n            }\n        }\n\n        // Store the class repository for use\n        this.repository = classRepository;\n        // Increment and store generation counter\n        this.generation = generationCounter++;\n        this.m_cms = cms;\n    }","id":42739,"modified_method":"/**\n     * Creates a new class loader that will load classes from specified\n     * class repositories.\n     *\n     * @param cms CmsObject Object to get access to system resources\n     * @param classRepository An set of Strings indicating directories.\n     * @throw java.lang.IllegalArgumentException if the objects contained\n     *        in the vector are not valid cms folders.\n     */\n    public void init(Object cms, Vector classRepository) throws IllegalArgumentException {\n        m_cms = cms;\n\n        // Verify that all the repository are valid.\n        if(classRepository == null) {\n            classRepository = new Vector();\n        }\n        Enumeration e = classRepository.elements();\n        while(e.hasMoreElements()) {\n            Object o = e.nextElement();\n            String file;\n\n            // Check to see if element is a File instance.\n            try {\n                file = (String)o;\n            }\n            catch(ClassCastException objectIsNotFile) {\n                throw new IllegalArgumentException(\"Object \" + o\n                        + \" is not a valid \\\"String\\\" instance\");\n            }\n        }\n        try{\n            m_cmsObjectClass = Class.forName(\"com.opencms.file.CmsObject\", true, this);\n            m_cmsFileClass = Class.forName(\"com.opencms.file.CmsFile\", true, this);\n            m_readFile = m_cmsObjectClass.getMethod(\"readFile\", new Class[] {String.class});\n            m_getContent = m_cmsFileClass.getMethod(\"getContents\", new Class[0]);\n        } catch (Exception exc){\n            throw new IllegalArgumentException(\"Error in CmsClassloader.init() \"+exc.toString() );\n        }\n\n        // Store the class repository for use\n        repository = classRepository;\n        // Increment and store generation counter\n        generation = generationCounter++;\n    }","commit_id":"d7ac12c396afe77e8320837c0a8c17d029cc939d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initialization of the OpenCms servlet.\n     * Used instead of a constructor (Overloaded Servlet API method)\n     * <p>\n     * The connection information for the property database is read from the configuration\n     * file and all resource brokers are initialized via the initalizer.\n     *\n     * @param config Configuration of OpenCms.\n     * @exception ServletException Thrown when sevlet initalization fails.\n     */\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        // Collect the configurations\n        try {\n            m_configurations = new Configurations(new ExtendedProperties(config.getInitParameter(\"properties\")));\n        }\n        catch(Exception e) {\n            throw new ServletException(e.getMessage() + \".  Properties file is: \" + config.getInitParameter(\"properties\"));\n        }\n\n        // Initialize the logging\n        A_OpenCms.initializeServletLogging(m_configurations);\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] logging started\");\n        }\n\n        // initialize the redirect information\n        int count = 0;\n        String redirect;\n        String redirectlocation;\n        while((redirect = (String)m_configurations.getString(C_PROPERTY_REDIRECT + \".\" + count)) != null) {\n            redirectlocation = (String)m_configurations.getString(C_PROPERTY_REDIRECTLOCATION + \".\" + count);\n            m_redirect.addElement(redirect);\n            m_redirectlocation.addElement(redirectlocation);\n            count++;\n            if(A_OpenCms.isLogging()) {\n                A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] redirect-rule: \" + redirect + \" -> \" + redirectlocation);\n            }\n        }\n        m_clusterurl = (String)m_configurations.getString(C_CLUSTERURL, \"\");\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] Clusterurl: \" + m_clusterurl);\n        }\n        try {\n\n            // invoke the OpenCms\n            m_opencms = new OpenCms(m_configurations);\n        }\n        catch(Exception exc) {\n            throw new ServletException(exc.getMessage());\n        }\n\n        //initalize the session storage\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing session storage\");\n        }\n        m_sessionStorage = new CmsCoreSession();\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing... DONE\");\n        }\n\n        // create the cms-object for the class-loader to read classes from the vfs\n        CmsObject cms = new CmsObject();\n        try {\n            m_opencms.initUser(cms, null, null, C_USER_GUEST, C_GROUP_GUEST, C_PROJECT_ONLINE_ID);\n        } catch (CmsException exc) {\n            throw new ServletException(\"Error while initializing the cms-object for the classloader\", exc);\n        }\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing CmsClassLoader \");\n        }\n        // get the repositories for the classloader\n        Vector repositories = new Vector();\n        String[] repositoriesFromConfigFile = null;\n        String[] repositoriesFromRegistry = null;\n\n        // add repositories from the configuration file\n        repositoriesFromConfigFile = cms.getConfigurations().getStringArray(\"repositories\");\n        for(int i = 0;i < repositoriesFromConfigFile.length;i++) {\n            repositories.addElement(repositoriesFromConfigFile[i]);\n        }\n\n        // add the repositories from the registry, if it is available\n        I_CmsRegistry reg = null;\n        try{\n            reg = cms.getRegistry();\n        }catch(CmsException e){\n             throw new ServletException(e.getMessage());\n        }\n        if(reg != null) {\n            repositoriesFromRegistry = reg.getRepositories();\n            for(int i = 0;i < repositoriesFromRegistry.length;i++) {\n                try {\n                    cms.readFileHeader(repositoriesFromRegistry[i]);\n                    repositories.addElement(repositoriesFromRegistry[i]);\n                }\n                catch(CmsException e) {\n                // this repository was not found, do do not add it to the repository list\n                // no exception handling is nescessary here.\n                }\n            }\n        }\n        // give the guest-loggedin cms-object and the repositories to the classloader\n        CmsClassLoader loader = new CmsClassLoader();\n        loader.init(cms, repositories);\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing CmsClassLoader... DONE\");\n        }\n    }","id":42740,"modified_method":"/**\n     * Initialization of the OpenCms servlet.\n     * Used instead of a constructor (Overloaded Servlet API method)\n     * <p>\n     * The connection information for the property database is read from the configuration\n     * file and all resource brokers are initialized via the initalizer.\n     *\n     * @param config Configuration of OpenCms.\n     * @exception ServletException Thrown when sevlet initalization fails.\n     */\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        // Collect the configurations\n        try {\n            m_configurations = new Configurations(new ExtendedProperties(config.getInitParameter(\"properties\")));\n        }\n        catch(Exception e) {\n            throw new ServletException(e.getMessage() + \".  Properties file is: \" + config.getInitParameter(\"properties\"));\n        }\n\n        // Initialize the logging\n        A_OpenCms.initializeServletLogging(m_configurations);\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] logging started\");\n        }\n\n        // initialize the redirect information\n        int count = 0;\n        String redirect;\n        String redirectlocation;\n        while((redirect = (String)m_configurations.getString(C_PROPERTY_REDIRECT + \".\" + count)) != null) {\n            redirectlocation = (String)m_configurations.getString(C_PROPERTY_REDIRECTLOCATION + \".\" + count);\n            m_redirect.addElement(redirect);\n            m_redirectlocation.addElement(redirectlocation);\n            count++;\n            if(A_OpenCms.isLogging()) {\n                A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] redirect-rule: \" + redirect + \" -> \" + redirectlocation);\n            }\n        }\n        m_clusterurl = (String)m_configurations.getString(C_CLUSTERURL, \"\");\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] Clusterurl: \" + m_clusterurl);\n        }\n        try {\n\n            // invoke the OpenCms\n            m_opencms = new OpenCms(m_configurations);\n        }\n        catch(Exception exc) {\n            throw new ServletException(exc.getMessage());\n        }\n\n        //initalize the session storage\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing session storage\");\n        }\n        m_sessionStorage = new CmsCoreSession();\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing... DONE\");\n        }\n\n        // create the cms-object for the class-loader to read classes from the vfs\n        CmsObject cms = new CmsObject();\n        try {\n            m_opencms.initUser(cms, null, null, C_USER_GUEST, C_GROUP_GUEST, C_PROJECT_ONLINE_ID);\n        } catch (CmsException exc) {\n            throw new ServletException(\"Error while initializing the cms-object for the classloader\", exc);\n        }\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing CmsClassLoader \");\n        }\n        // get the repositories for the classloader\n        Vector repositories = new Vector();\n        String[] repositoriesFromConfigFile = null;\n        String[] repositoriesFromRegistry = null;\n\n        // add repositories from the configuration file\n        repositoriesFromConfigFile = cms.getConfigurations().getStringArray(\"repositories\");\n        for(int i = 0;i < repositoriesFromConfigFile.length;i++) {\n            repositories.addElement(repositoriesFromConfigFile[i]);\n        }\n\n        // add the repositories from the registry, if it is available\n        I_CmsRegistry reg = null;\n        try{\n            reg = cms.getRegistry();\n        }catch(CmsException e){\n             throw new ServletException(e.getMessage());\n        }\n        if(reg != null) {\n            repositoriesFromRegistry = reg.getRepositories();\n            for(int i = 0;i < repositoriesFromRegistry.length;i++) {\n                try {\n                    cms.readFileHeader(repositoriesFromRegistry[i]);\n                    repositories.addElement(repositoriesFromRegistry[i]);\n                }\n                catch(CmsException e) {\n                // this repository was not found, do do not add it to the repository list\n                // no exception handling is nescessary here.\n                }\n            }\n        }\n        // give the guest-loggedin cms-object and the repositories to the classloader\n        // CmsClassLoader loader = new CmsClassLoader();\n        CmsClassLoader loader = (CmsClassLoader) (getClass().getClassLoader());\n        loader.init(cms, repositories);\n        if(A_OpenCms.isLogging()) {\n            A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INIT, \"[OpenCmsServlet] initializing CmsClassLoader... DONE\");\n        }\n    }","commit_id":"d7ac12c396afe77e8320837c0a8c17d029cc939d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initialization of the OpenCms HttpServlet.\n     * Used instead of a constructor (Overloaded Servlet API method)\n     * <p>\n     * The connection information for the property database will be read from the configuration\n     * file and all resource brokers will be initialized via the initalizer.\n     *\n     * @param config Configuration of OpenCms.\n     * @exception ServletException Thrown when sevlet initalization fails.\n     */\n    public void init(ServletConfig config) throws ServletException {\n        String classname = \"com.opencms.core.OpenCmsHttpServlet\";\n        try {\n            ClassLoader loader = new CmsClassLoader();\n            Class c = loader.loadClass(classname);\n            //Class c = CmsTemplateClassManager.class.getClassLoader().loadClass(classname);\n            // Now we have to look for the constructor\n            m_servlet = (HttpServlet)c.newInstance();\n        } catch(Exception e) {\n            String errorMessage = null;\n\n            // Construct error message for the different exceptions\n            if(e instanceof ClassNotFoundException) {\n                errorMessage = \"XXXCould not load template class \" + classname + \". \" + e.getMessage();\n            }\n            else {\n                if(e instanceof InstantiationException) {\n                    errorMessage = \"XXXCould not instantiate template class \" + classname;\n                }\n                else {\n                    if(e instanceof NoSuchMethodException) {\n                        errorMessage = \"XXXCould not find constructor of template class \" + classname;\n                    }\n                    else {\n                        errorMessage = \"XXXUnknown error while getting instance of template class \" + classname;\n                    }\n                }\n            }\n            /*if(A_OpenCms.isLogging()) {\n                A_OpenCms.log(C_OPENCMS_CRITICAL, \"[CmsTemplateClassManager] \" + errorMessage);\n            }*/\n            throw new ServletException(e);\n            //throw new CmsException(errorMessage, CmsException.C_CLASSLOADER_ERROR, e);\n        }\n        /*\n        try{\n            m_servlet = (HttpServlet) com.opencms.template.CmsTemplateClassManager.getClassInstance(null, \"com.opencms.core.OpenCmsHttpServlet\" );\n        }catch(Exception e){\n            throw new ServletException(e);\n        }*/\n        m_servlet.init(config);\n    }","id":42741,"modified_method":"/**\n     * Initialization of the OpenCms HttpServlet.\n     * Used instead of a constructor (Overloaded Servlet API method)\n     * <p>\n     * The connection information for the property database will be read from the configuration\n     * file and all resource brokers will be initialized via the initalizer.\n     *\n     * @param config Configuration of OpenCms.\n     * @exception ServletException Thrown when sevlet initalization fails.\n     */\n    public void init(ServletConfig config) throws ServletException {\n        String classname = \"com.opencms.core.OpenCmsHttpServlet\";\n        try {\n            ClassLoader loader = new CmsClassLoader();\n            Class c = loader.loadClass(classname);\n            // Now we have to look for the constructor\n            m_servlet = (HttpServlet)c.newInstance();\n        } catch(Exception e) {\n            throw new ServletException(e);\n        }\n        m_servlet.init(config);\n    }","commit_id":"d7ac12c396afe77e8320837c0a8c17d029cc939d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        if(C_DEBUG && A_OpenCms.isLogging()) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsEditor] getting content of element \" + elementName);\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsEditor] template file is: \" + templateFile);\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsEditor] selected template section is: \" + ((templateSelector==null)?\"<root>\":templateSelector));\n        }\n\n        String result = null;        \n\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile();       \n        String fullFileName = CmsXmlWpTemplateFile.lookupAbsoluteFilename(cms, templateFile, xmlTemplateDocument);\n        CmsFile file = cms.readFile(fullFileName);\n        xmlTemplateDocument.init(cms, file);       \n                \n        // Try to process the template file\n        try {\n            result = xmlTemplateDocument.getProcessedTemplateContent(this, parameters);\n        } catch(Throwable e) {\n           // There were errors while generating output for this template.\n            // Clear HTML cache and then throw exception again\n            xmlTemplateDocument.clearFileCache(xmlTemplateDocument);\n            if(isCacheable(cms, templateFile, parameters)) {\n                m_cache.clearCache(getKey(cms, templateFile, parameters));\n            }\n            if(e instanceof CmsException) {\n                throw (CmsException)e;\n            } else {\n                // under normal cirumstances, this should not happen.\n                // any exception should be caught earlier and replaced by \n                // corresponding CmsExceptions.\n                String errorMessage = \"Exception while getting content for (sub)template \" + elementName + \". \" + e;                                       \n                if(A_OpenCms.isLogging()) {\n                    A_OpenCms.log(C_OPENCMS_CRITICAL, \"[CmsXmlTemplate] \" + errorMessage);\n                }\n                throw new CmsException(errorMessage);                \n            }\n        }        \n        return result.getBytes();\n    }","id":42742,"modified_method":"public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n        String result = null;     \n       String user=null;\n        \n        // get user name and password\n        String name=(String)parameters.get(\"NAME\");\n        String password=(String)parameters.get(\"PASSWORD\");\n        \n        // try to read this user\n        if ((name != null) && (password != null)){\n            try {\n                user=cms.loginUser(name,password);\n            } catch (CmsException e) {\n                if (e.getType()==CmsException.C_NO_ACCESS) {\n                    user=null;                    \n                } else {\n                    throw e;\n                }   \n            }   \n            // check if a user was found.\n            if (user!= null) {\n                // get a session for this user so that he is authentificated at the\n                // end of this request\n                HttpSession session = ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);\n                if(A_OpenCms.isLogging()) {\n                    A_OpenCms.log(C_OPENCMS_INFO, \"[CmsLogin] Login user \" + user);\n                }\n            }\n        }\n        \n        \n        \n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile();       \n        String fullFileName = CmsXmlWpTemplateFile.lookupAbsoluteFilename(cms, templateFile, xmlTemplateDocument);\n        CmsFile file = cms.readFile(fullFileName);\n        xmlTemplateDocument.init(cms, file);       \n                \n        // Try to process the template file\n        try {\n            result = xmlTemplateDocument.getProcessedTemplateContent(this, parameters);\n        } catch(Throwable e) {\n           // There were errors while generating output for this template.\n            // Clear HTML cache and then throw exception again\n            xmlTemplateDocument.clearFileCache(xmlTemplateDocument);\n            if(isCacheable(cms, templateFile, parameters)) {\n                m_cache.clearCache(getKey(cms, templateFile, parameters));\n            }\n            if(e instanceof CmsException) {\n                throw (CmsException)e;\n            } else {\n                // under normal cirumstances, this should not happen.\n                // any exception should be caught earlier and replaced by \n                // corresponding CmsExceptions.\n                String errorMessage = \"Exception while getting content for (sub)template \" + elementName + \". \" + e;                                       \n                if(A_OpenCms.isLogging()) {\n                    A_OpenCms.log(C_OPENCMS_CRITICAL, \"[CmsXmlTemplate] \" + errorMessage);\n                }\n                throw new CmsException(errorMessage);                \n            }\n        }        \n        return result.getBytes();\n    }","commit_id":"a4ea47170f269f55097285b6de95e64c7c93dba2","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void removeImport(GrImportStatement importStatement) throws IncorrectOperationException {\n    PsiElement before = importStatement.getPrevSibling();\n    while (before instanceof PsiWhiteSpace || hasElementType(before, GroovyTokenTypes.mNLS)) {\n      before = before.getPrevSibling();\n    }\n\n    PsiElement rangeStart = importStatement;\n    if (before != null && !(before instanceof PsiImportStatement) && before != importStatement.getPrevSibling()) {\n      rangeStart = before.getNextSibling();\n      final PsiElement el = addBefore(GroovyPsiElementFactory.getInstance(getProject()).createLineTerminator(2), rangeStart);\n      rangeStart=el.getNextSibling();\n    }\n\n    PsiElement rangeEnd = importStatement.getNextSibling();\n    while (rangeEnd instanceof PsiWhiteSpace || hasElementType(rangeEnd, GroovyTokenTypes.mSEMI)) {\n      rangeEnd = rangeEnd.getNextSibling();\n    }\n    final PsiElement last = hasElementType(rangeEnd, GroovyTokenTypes.mNLS) ? rangeEnd : rangeEnd.getPrevSibling();\n    if (rangeStart != null && last != null) {\n      deleteChildRange(rangeStart, last);\n    }\n  }","id":42743,"modified_method":"public void removeImport(GrImportStatement importStatement) throws IncorrectOperationException {\n    PsiElement before = importStatement.getPrevSibling();\n    while (before instanceof PsiWhiteSpace || hasElementType(before, GroovyTokenTypes.mNLS)) {\n      before = before.getPrevSibling();\n    }\n\n    PsiElement rangeStart = importStatement;\n    if (before != null && !(before instanceof PsiImportStatement) && before != importStatement.getPrevSibling()) {\n      rangeStart = before.getNextSibling();\n      final PsiElement el = addBefore(GroovyPsiElementFactory.getInstance(getProject()).createLineTerminator(2), rangeStart);\n      rangeStart=el.getNextSibling();\n    }\n\n    PsiElement rangeEnd = importStatement;\n    while (true) {\n      final PsiElement next = rangeEnd.getNextSibling();\n      if (!(next instanceof PsiWhiteSpace) && !hasElementType(next, GroovyTokenTypes.mSEMI)) {\n        break;\n      }\n      rangeEnd = next;\n    }\n    final PsiElement last = hasElementType(rangeEnd.getNextSibling(), GroovyTokenTypes.mNLS) ? rangeEnd.getNextSibling() : rangeEnd;\n    if (rangeStart != null && last != null) {\n      deleteChildRange(rangeStart, last);\n    }\n  }","commit_id":"c2d2bb4df71a3e6c55a14758c396995e97c03ffa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run() {\n      if (!ProjectRootManager.getInstance(myFile.getProject()).getFileIndex().isInSource(myFile.getVirtualFile())) {\n        return;\n      }\n\n      final Set<String> importedClasses = new LinkedHashSet<String>();\n      final Set<String> staticallyImportedMembers = new LinkedHashSet<String>();\n      final Set<GrImportStatement> usedImports = new HashSet<GrImportStatement>();\n      final Set<String> implicitlyImported = new LinkedHashSet<String>();\n      final List<GrImportStatement> oldImports =\n        findUnusedImports(importedClasses, staticallyImportedMembers, usedImports, implicitlyImported);\n      if (myRemoveUnusedOnly) {\n        for (GrImportStatement oldImport : oldImports) {\n          if (!usedImports.contains(oldImport)) {\n            myFile.removeImport(oldImport);\n          }\n        }\n        return;\n      }\n\n      // Getting aliased imports\n      GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(myFile.getProject());\n      ArrayList<GrImportStatement> aliased = new ArrayList<GrImportStatement>();\n      for (GrImportStatement oldImport : oldImports) {\n        if (oldImport.isAliasedImport() && usedImports.contains(oldImport)) {\n          aliased.add(factory.createImportStatementFromText(oldImport.getText()));\n        }\n      }\n\n      // Add new import statements\n      GrImportStatement[] newImports = prepare(importedClasses, staticallyImportedMembers, implicitlyImported);\n      for (GrImportStatement aliasedImport : aliased) {\n        myFile.addImport(aliasedImport);\n      }\n      for (GrImportStatement newImport : newImports) {\n        myFile.addImport(newImport);\n      }\n\n      myFile.removeImport(myFile.addImport(factory.createImportStatementFromText(\"import xxxx\"))); //to remove trailing whitespaces\n\n      for (GrImportStatement importStatement : oldImports) {\n        myFile.removeImport(importStatement);\n      }\n    }","id":42744,"modified_method":"public void run() {\n      if (!ProjectRootManager.getInstance(myFile.getProject()).getFileIndex().isInSource(myFile.getVirtualFile())) {\n        return;\n      }\n\n      final Set<String> importedClasses = new LinkedHashSet<String>();\n      final Set<String> staticallyImportedMembers = new LinkedHashSet<String>();\n      final Set<GrImportStatement> usedImports = new HashSet<GrImportStatement>();\n      final Set<String> implicitlyImported = new LinkedHashSet<String>();\n      final List<GrImportStatement> oldImports =\n        findUnusedImports(importedClasses, staticallyImportedMembers, usedImports, implicitlyImported);\n      if (myRemoveUnusedOnly) {\n        for (GrImportStatement oldImport : oldImports) {\n          if (!usedImports.contains(oldImport)) {\n            myFile.removeImport(oldImport);\n          }\n        }\n        return;\n      }\n\n      // Getting aliased imports\n      GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(myFile.getProject());\n      ArrayList<GrImportStatement> aliased = new ArrayList<GrImportStatement>();\n      for (GrImportStatement oldImport : oldImports) {\n        if (oldImport.isAliasedImport() && usedImports.contains(oldImport)) {\n          aliased.add(factory.createImportStatementFromText(oldImport.getText()));\n        }\n      }\n\n      // Add new import statements\n      GrImportStatement[] newImports = prepare(importedClasses, staticallyImportedMembers, implicitlyImported);\n      if (oldImports.isEmpty() && newImports.length == 0 && aliased.isEmpty()) {\n        return;\n      }\n\n      for (GrImportStatement aliasedImport : aliased) {\n        myFile.addImport(aliasedImport);\n      }\n      for (GrImportStatement newImport : newImports) {\n        myFile.addImport(newImport);\n      }\n\n      myFile.removeImport(myFile.addImport(factory.createImportStatementFromText(\"import xxxx\"))); //to remove trailing whitespaces\n\n      for (GrImportStatement importStatement : oldImports) {\n        myFile.removeImport(importStatement);\n      }\n    }","commit_id":"c2d2bb4df71a3e6c55a14758c396995e97c03ffa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isApplicable(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getParent(node) != null) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.getParent(node), \"cellLayout\", true), \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\") && !(EditorCellModel_Behavior.call_isIndented_1237383418148(node));\n  }","id":42745,"modified_method":"public boolean isApplicable(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getParent(node) != null) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\"), \"cellLayout\", true), \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\") && !(EditorCellModel_Behavior.call_isIndented_1237383418148(node));\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getParent(node) != null) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.getParent(node), \"cellLayout\", true), \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\") && !(EditorCellModel_Behavior.call_isNewLine_1237383076236(node));\n  }","id":42746,"modified_method":"public boolean isApplicable(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getParent(node) != null) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\"), \"cellLayout\", true), \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\") && !(EditorCellModel_Behavior.call_isNewLine_1237383076236(node));\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getParent(node) != null) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.getParent(node), \"cellLayout\", true), \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\") && !(EditorCellModel_Behavior.call_isNewLine_1237383076236(node));\n  }","id":42747,"modified_method":"public boolean isApplicable(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getParent(node) != null) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\"), \"cellLayout\", true), \"jetbrains.mps.lang.editor.structure.CellLayout_Indent\") && !(EditorCellModel_Behavior.call_isNewLine_1237383076236(node));\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean isExtendsBaseLanguage(SNode node) {\n    SNode editor = SNodeOperations.getAncestor(node, \"jetbrains.mps.lang.editor.structure.BaseEditorComponent\", false, false);\n    if (editor == null) {\n      return false;\n    }\n    if (SNodeOperations.getModel(SLinkOperations.getTarget(SLinkOperations.getTarget(editor, \"conceptDeclaration\", false), \"extends\", false)) != SNodeOperations.getModel(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c895902ca(jetbrains.mps.baseLanguage.structure)\", \"1068580123132\"))) {\n      return false;\n    }\n    return true;\n  }","id":42748,"modified_method":"public static boolean isExtendsBaseLanguage(SNode node) {\n    SNode editor = SNodeOperations.getAncestor(node, \"jetbrains.mps.lang.editor.structure.BaseEditorComponent\", false, false);\n    if (editor == null) {\n      return false;\n    }\n    if (SNodeOperations.getModel(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(editor, \"conceptDeclaration\", false), \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"), \"extends\", false)) != SNodeOperations.getModel(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c895902ca(jetbrains.mps.baseLanguage.structure)\", \"1068580123132\"))) {\n      return false;\n    }\n    return true;\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> moveToIndentLayoutChildren(SNode node, boolean isLast) {\n    List<SNode> result = ListOperations.<SNode>createList();\n    if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.editor.structure.CellModel_Collection\")) {\n      SNode collection = node;\n      if (SLinkOperations.getTarget(collection, \"renderingCondition\", true) != null || EditorCellModel_Behavior.call_isIndented_1237383418148(node) || SPropertyOperations.getBoolean(collection, \"vertical\") || SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(collection, \"childCellModel\", true)).last(), \"renderingCondition\", true) != null) {\n        moveToIndentLayout(node);\n        if (isLast) {\n          SNode classItem = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\", null);\n          SPropertyOperations.set(classItem, \"flag\", \"\" + true);\n          SLinkOperations.addChild(node, \"styleItem\", classItem);\n        }\n        ListSequence.fromList(result).addElement(node);\n      } else\n      {\n        List<SNode> children = SLinkOperations.getTargets(node, \"childCellModel\", true);\n        for(int i = 0 ; i < ListSequence.fromList(children).count() ; i++ ) {\n          ListSequence.fromList(result).addSequence(ListSequence.fromList(moveToIndentLayoutChildren(ListSequence.fromList(children).getElement(i), isLast && (i == ListSequence.fromList(children).count() - 1))));\n        }\n      }\n    } else if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.editor.structure.CellModel_Indent\")) {\n      IndentLayoutUtil.makeIndent(SNodeOperations.getNextSibling(node));\n    } else\n    {\n      ListSequence.fromList(result).addElement(node);\n      if (isLast) {\n        SNode classItem = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\", null);\n        SPropertyOperations.set(classItem, \"flag\", \"\" + true);\n        SLinkOperations.addChild(node, \"styleItem\", classItem);\n      }\n    }\n    return result;\n  }","id":42749,"modified_method":"public static List<SNode> moveToIndentLayoutChildren(SNode node, boolean isLast) {\n    List<SNode> result = ListOperations.<SNode>createList();\n    if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.editor.structure.CellModel_Collection\")) {\n      SNode collection = SNodeOperations.cast(node, \"jetbrains.mps.lang.editor.structure.CellModel_Collection\");\n      if (SLinkOperations.getTarget(collection, \"renderingCondition\", true) != null || EditorCellModel_Behavior.call_isIndented_1237383418148(node) || SPropertyOperations.getBoolean(collection, \"vertical\") || SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(collection, \"childCellModel\", true)).last(), \"renderingCondition\", true) != null) {\n        moveToIndentLayout(SNodeOperations.cast(node, \"jetbrains.mps.lang.editor.structure.CellModel_Collection\"));\n        if (isLast) {\n          SNode classItem = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\", null);\n          SPropertyOperations.set(classItem, \"flag\", \"\" + true);\n          SLinkOperations.addChild(node, \"styleItem\", classItem);\n        }\n        ListSequence.fromList(result).addElement(node);\n      } else\n      {\n        List<SNode> children = SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.lang.editor.structure.CellModel_Collection\"), \"childCellModel\", true);\n        for(int i = 0 ; i < ListSequence.fromList(children).count() ; i++ ) {\n          ListSequence.fromList(result).addSequence(ListSequence.fromList(moveToIndentLayoutChildren(ListSequence.fromList(children).getElement(i), isLast && (i == ListSequence.fromList(children).count() - 1))));\n        }\n      }\n    } else if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.lang.editor.structure.CellModel_Indent\")) {\n      IndentLayoutUtil.makeIndent(SNodeOperations.cast(SNodeOperations.getNextSibling(node), \"jetbrains.mps.lang.editor.structure.EditorCellModel\"));\n    } else\n    {\n      ListSequence.fromList(result).addElement(node);\n      if (isLast) {\n        SNode classItem = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.IndentLayoutNewLineStyleClassItem\", null);\n        SPropertyOperations.set(classItem, \"flag\", \"\" + true);\n        SLinkOperations.addChild(node, \"styleItem\", classItem);\n      }\n    }\n    return result;\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    String text = SPropertyOperations.getString(node, \"text\").trim();\n    SNode collection = SModelOperations.createNewNode(SNodeOperations.getModel(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n    SLinkOperations.setNewChild(collection, \"cellLayout\", \"jetbrains.mps.lang.editor.structure.CellLayout_Flow\");\n    SNodeOperations.replaceWithAnother(node, collection);\n    String[] strings = text.split(\" \");\n    int i = 0;\n    for(String word : strings) {\n      SNode constantCell = SNodeOperations.copyNode(node);\n      SPropertyOperations.set(constantCell, \"text\", word);\n      boolean leftPaddingSet = false;\n      boolean rightPaddingSet = false;\n      for(SNode styleClassItem : SLinkOperations.getTargets(constantCell, \"styleItem\", true)) {\n        if (SNodeOperations.isInstanceOf(styleClassItem, \"jetbrains.mps.lang.editor.structure.PaddingLeftStyleClassItem\")) {\n          leftPaddingSet = true;\n          if (i != 0) {\n            SPropertyOperations.set(styleClassItem, \"value\", \"0.5\");\n          }\n        }\n        if (SNodeOperations.isInstanceOf(styleClassItem, \"jetbrains.mps.lang.editor.structure.PaddingRightStyleClassItem\")) {\n          rightPaddingSet = true;\n          if (i != strings.length - 1) {\n            SPropertyOperations.set(styleClassItem, \"value\", \"0.5\");\n          }\n        }\n      }\n      if (!(leftPaddingSet)) {\n        SNode paddingLeftStyleClassItem = SLinkOperations.addNewChild(constantCell, \"styleItem\", \"jetbrains.mps.lang.editor.structure.PaddingLeftStyleClassItem\");\n        SPropertyOperations.set(paddingLeftStyleClassItem, \"value\", \"0.5\");\n      }\n      if (!(rightPaddingSet)) {\n        SNode paddingRightStyleClassItem = SLinkOperations.addNewChild(constantCell, \"styleItem\", \"jetbrains.mps.lang.editor.structure.PaddingRightStyleClassItem\");\n        SPropertyOperations.set(paddingRightStyleClassItem, \"value\", \"0.5\");\n      }\n      SLinkOperations.addChild(collection, \"childCellModel\", constantCell);\n      i++ ;\n    }\n  }","id":42750,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    String text = SPropertyOperations.getString(node, \"text\").trim();\n    SNode collection = SModelOperations.createNewNode(SNodeOperations.getModel(node), \"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n    SLinkOperations.setNewChild(collection, \"cellLayout\", \"jetbrains.mps.lang.editor.structure.CellLayout_Flow\");\n    SNodeOperations.replaceWithAnother(node, collection);\n    String[] strings = text.split(\" \");\n    int i = 0;\n    for(String word : strings) {\n      SNode constantCell = SNodeOperations.copyNode(node);\n      SPropertyOperations.set(constantCell, \"text\", word);\n      boolean leftPaddingSet = false;\n      boolean rightPaddingSet = false;\n      for(SNode styleClassItem : SLinkOperations.getTargets(constantCell, \"styleItem\", true)) {\n        if (SNodeOperations.isInstanceOf(styleClassItem, \"jetbrains.mps.lang.editor.structure.PaddingLeftStyleClassItem\")) {\n          leftPaddingSet = true;\n          if (i != 0) {\n            SPropertyOperations.set(SNodeOperations.cast(styleClassItem, \"jetbrains.mps.lang.editor.structure.PaddingLeftStyleClassItem\"), \"value\", \"0.5\");\n          }\n        }\n        if (SNodeOperations.isInstanceOf(styleClassItem, \"jetbrains.mps.lang.editor.structure.PaddingRightStyleClassItem\")) {\n          rightPaddingSet = true;\n          if (i != strings.length - 1) {\n            SPropertyOperations.set(SNodeOperations.cast(styleClassItem, \"jetbrains.mps.lang.editor.structure.PaddingRightStyleClassItem\"), \"value\", \"0.5\");\n          }\n        }\n      }\n      if (!(leftPaddingSet)) {\n        SNode paddingLeftStyleClassItem = SLinkOperations.addNewChild(constantCell, \"styleItem\", \"jetbrains.mps.lang.editor.structure.PaddingLeftStyleClassItem\");\n        SPropertyOperations.set(paddingLeftStyleClassItem, \"value\", \"0.5\");\n      }\n      if (!(rightPaddingSet)) {\n        SNode paddingRightStyleClassItem = SLinkOperations.addNewChild(constantCell, \"styleItem\", \"jetbrains.mps.lang.editor.structure.PaddingRightStyleClassItem\");\n        SPropertyOperations.set(paddingRightStyleClassItem, \"value\", \"0.5\");\n      }\n      SLinkOperations.addChild(collection, \"childCellModel\", constantCell);\n      i++ ;\n    }\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n    SPropertyOperations.set(result, \"vertical\", \"\" + false);\n    List<SNode> nodes = editorContext.getSelectedNodes();\n    SNodeOperations.insertNextSiblingChild(ListSequence.fromList(nodes).last(), result);\n    for(SNode sn : nodes) {\n      SLinkOperations.addChild(result, \"childCellModel\", sn);\n    }\n  }","id":42751,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n    SPropertyOperations.set(result, \"vertical\", \"\" + false);\n    List<SNode> nodes = editorContext.getSelectedNodes();\n    SNodeOperations.insertNextSiblingChild(ListSequence.fromList(nodes).last(), result);\n    for(SNode sn : nodes) {\n      SLinkOperations.addChild(result, \"childCellModel\", SNodeOperations.cast(sn, \"jetbrains.mps.lang.editor.structure.EditorCellModel\"));\n    }\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n    SPropertyOperations.set(result, \"vertical\", \"\" + true);\n    List<SNode> nodes = editorContext.getSelectedNodes();\n    SNodeOperations.insertNextSiblingChild(ListSequence.fromList(nodes).last(), result);\n    for(SNode sn : nodes) {\n      SLinkOperations.addChild(result, \"childCellModel\", sn);\n    }\n  }","id":42752,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.lang.editor.structure.CellModel_Collection\", null);\n    SPropertyOperations.set(result, \"vertical\", \"\" + true);\n    List<SNode> nodes = editorContext.getSelectedNodes();\n    SNodeOperations.insertNextSiblingChild(ListSequence.fromList(nodes).last(), result);\n    for(SNode sn : nodes) {\n      SLinkOperations.addChild(result, \"childCellModel\", SNodeOperations.cast(sn, \"jetbrains.mps.lang.editor.structure.EditorCellModel\"));\n    }\n  }","commit_id":"76b396252eebe3249532a1b4be0515b06a01c649","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean hasMatchingCloseTag(PsiElement element, int offset) {\n      @NonNls final String text = element.getText();\n      final int endOffset1 = StringUtil.indexOfIgnoreCase(text, \"<\/code>\", offset);\n      if (endOffset1 >= 0) {\n        final int startOffset1 = StringUtil.indexOfIgnoreCase(text, \"<code>\", offset);\n        return startOffset1 < 0 || startOffset1 > endOffset1;\n      }\n      PsiElement sibling = element.getNextSibling();\n      while (sibling != null) {\n        @NonNls final String text1 = sibling.getText();\n        final int endOffset = StringUtil.indexOfIgnoreCase(text1, \"<\/code>\", 0);\n        if (endOffset >= 0) {\n          final int startOffset = StringUtil.indexOfIgnoreCase(text1, \"<code>\", 0);\n          return startOffset < 0 || startOffset > endOffset;\n        }\n        sibling = sibling.getNextSibling();\n      }\n      return false;\n    }","id":42753,"modified_method":"private static boolean hasMatchingCloseTag(PsiElement element, int offset) {\n      while (element != null) {\n        @NonNls final String text = element.getText();\n        final int endIndex = StringUtil.indexOfIgnoreCase(text, \"<\/code>\", offset);\n        if (containsHtmlTag(text, offset, endIndex >= 0 ? endIndex : text.length())) {\n          return false;\n        }\n        if (endIndex >= 0) {\n          return true;\n        }\n        offset = 0;\n        element = element.getNextSibling();\n      }\n      return false;\n    }","commit_id":"b08fb9071760606788da0bcf1ddd31f5396a4242","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiElement findTargetElement(Project project, Editor editor, int offset) {\n    int flags = TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED\n            | TargetElementUtil.NEW_AS_CONSTRUCTOR\n            | TargetElementUtil.LOOKUP_ITEM_ACCEPTED\n            | TargetElementUtil.THIS_ACCEPTED\n            | TargetElementUtil.SUPER_ACCEPTED;\n    PsiElement element = TargetElementUtil.findTargetElement(editor, flags, offset);\n    if (element instanceof PsiPackage) return null;\n\n    if (element != null) return element;\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) {\n      return null;\n    }\n    PsiElement elementAt = file.findElementAt(offset);\n    if (elementAt instanceof PsiKeyword) {\n      IElementType type = ((PsiKeyword)elementAt).getTokenType();\n      if (type == JavaTokenType.CONTINUE_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiContinueStatement) {\n          PsiStatement statement = ((PsiContinueStatement)elementAt.getParent()).findContinuedStatement();\n          return statement;\n        }\n      }\n      else if (type == JavaTokenType.BREAK_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiBreakStatement) {\n          PsiStatement statement = ((PsiBreakStatement)elementAt.getParent()).findExitedStatement();\n          if (statement == null) return null;\n          if (statement.getParent() instanceof PsiLabeledStatement) {\n            statement = (PsiStatement)statement.getParent();\n          }\n          PsiElement nextSibling = statement.getNextSibling();\n          return nextSibling instanceof PsiWhiteSpace ? nextSibling.getNextSibling() : nextSibling;\n        }\n      }\n    }\n    else if (elementAt instanceof PsiIdentifier) {\n      PsiElement parent = elementAt.getParent();\n      PsiStatement statement = null;\n      if (parent instanceof PsiContinueStatement) {\n        statement = ((PsiContinueStatement)parent).findContinuedStatement();\n      }\n      else if (parent instanceof PsiBreakStatement) {\n        statement = ((PsiBreakStatement)parent).findExitedStatement();\n      }\n      if (statement == null) return null;\n\n      LOG.assertTrue(statement.getParent() instanceof PsiLabeledStatement);\n      return ((PsiLabeledStatement)statement.getParent()).getLabelIdentifier();\n    }\n\n    return null;\n  }","id":42754,"modified_method":"public static PsiElement findTargetElement(Project project, Editor editor, int offset) {\n    int flags = TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED\n            | TargetElementUtil.NEW_AS_CONSTRUCTOR\n            | TargetElementUtil.LOOKUP_ITEM_ACCEPTED\n            | TargetElementUtil.THIS_ACCEPTED\n            | TargetElementUtil.SUPER_ACCEPTED;\n    PsiElement element = TargetElementUtil.findTargetElement(editor, flags, offset);\n    if (element instanceof PsiPackage) return null;\n\n    if (element != null) return element;\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) {\n      return null;\n    }\n    PsiElement elementAt = file.findElementAt(offset);\n    if (elementAt instanceof PsiKeyword) {\n      IElementType type = ((PsiKeyword)elementAt).getTokenType();\n      if (type == JavaTokenType.CONTINUE_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiContinueStatement) {\n          PsiStatement statement = ((PsiContinueStatement)elementAt.getParent()).findContinuedStatement();\n          return statement;\n        }\n      }\n      else if (type == JavaTokenType.BREAK_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiBreakStatement) {\n          PsiStatement statement = ((PsiBreakStatement)elementAt.getParent()).findExitedStatement();\n          if (statement == null) return null;\n          if (statement.getParent() instanceof PsiLabeledStatement) {\n            statement = (PsiStatement)statement.getParent();\n          }\n          PsiElement nextSibling = statement.getNextSibling();\n          while (!(nextSibling instanceof PsiStatement) && nextSibling != null) nextSibling = nextSibling.getNextSibling();\n          return nextSibling != null ? nextSibling : statement.getNextSibling();\n        }\n      }\n    }\n    else if (elementAt instanceof PsiIdentifier) {\n      PsiElement parent = elementAt.getParent();\n      PsiStatement statement = null;\n      if (parent instanceof PsiContinueStatement) {\n        statement = ((PsiContinueStatement)parent).findContinuedStatement();\n      }\n      else if (parent instanceof PsiBreakStatement) {\n        statement = ((PsiBreakStatement)parent).findExitedStatement();\n      }\n      if (statement == null) return null;\n\n      LOG.assertTrue(statement.getParent() instanceof PsiLabeledStatement);\n      return ((PsiLabeledStatement)statement.getParent()).getLabelIdentifier();\n    }\n\n    return null;\n  }","commit_id":"39b0a2f355c72532e38f4948de357e41a76ecbc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Parses a link type from its wrapping span and from its reference.\n     * \n     * @param wrappingSpan the link's wrapping span\n     * @param reference the link reference\n     * @return the link type, as parsed from it's wrapping span and from its reference\n     */\n    private LinkType readLinkType(Element wrappingSpan, String reference)\n    {\n        String wrappingSpanClass = wrappingSpan.getClassName();\n        if (\"wikilink\".equals(wrappingSpanClass)) {\n            return LinkType.WIKIPAGE;\n        }\n        if (\"wikicreatelink\".equals(wrappingSpanClass)) {\n            return LinkType.NEW_WIKIPAGE;\n        }\n        if (\"wikiexternallink\".equals(wrappingSpanClass)) {\n            String linkProtocol = getLinkProtocol(reference);\n            if (\"mailto\".equalsIgnoreCase(linkProtocol)) {\n                return LinkType.EMAIL;\n            } else if (\"attach\".equalsIgnoreCase(linkProtocol)) {\n                return LinkType.ATTACHMENT;\n            }\n        }\n        return LinkType.EXTERNAL;\n    }","id":42755,"modified_method":"/**\n     * Parses a link type from its wrapping span and from its reference.\n     * \n     * @param wrappingSpan the link's wrapping span\n     * @param reference the link reference\n     * @return the link type, as parsed from it's wrapping span and from its reference\n     */\n    private LinkType readLinkType(Element wrappingSpan, String reference)\n    {\n        LinkType linkType = LinkType.getByClassName(wrappingSpan.getClassName());\n        if (linkType == null) {\n            // Default to external link.\n            linkType = LinkType.EXTERNAL;\n        } else if (linkType == LinkType.EXTERNAL && \"mailto\".equalsIgnoreCase(getLinkProtocol(reference))) {\n            // Email links don't user a dedicated CSS class name.\n            linkType = LinkType.EMAIL;\n        }\n        return linkType;\n    }","commit_id":"1262ed5cafdec37973c83e0559a4d5905861b693","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Updates the meta data of the given anchor.\n     * \n     * @param anchor the anchor whose meta data will be updated\n     * @param reference the new link reference\n     * @param linkType the new link type\n     */\n    private void updateMetaData(AnchorElement anchor, String reference, LinkType linkType)\n    {\n        Document document = (Document) anchor.getOwnerDocument();\n        DocumentFragment metaData = document.createDocumentFragment();\n        metaData.appendChild(document.createComment(\"startwikilink:\" + EscapeUtils.escapeComment(reference)));\n        metaData.appendChild(document.createSpanElement());\n        if (CLASS_NAME_MAPPING.containsKey(linkType)) {\n            Element.as(metaData.getChild(1)).setClassName(CLASS_NAME_MAPPING.get(linkType));\n        }\n        metaData.getChild(1).appendChild(document.createTextNode(Element.INNER_HTML_PLACEHOLDER));\n        metaData.appendChild(document.createComment(\"stopwikilink\"));\n        Element.as(anchor).setMetaData(metaData);\n    }","id":42756,"modified_method":"/**\n     * Updates the meta data of the given anchor.\n     * \n     * @param anchor the anchor whose meta data will be updated\n     * @param reference the new link reference\n     * @param linkType the new link type\n     */\n    private void updateMetaData(AnchorElement anchor, String reference, LinkType linkType)\n    {\n        Document document = (Document) anchor.getOwnerDocument();\n        DocumentFragment metaData = document.createDocumentFragment();\n        metaData.appendChild(document.createComment(\"startwikilink:\" + EscapeUtils.escapeComment(reference)));\n        metaData.appendChild(document.createSpanElement());\n        Element.as(metaData.getChild(1)).setClassName(linkType.getClassName());\n        metaData.getChild(1).appendChild(document.createTextNode(Element.INNER_HTML_PLACEHOLDER));\n        metaData.appendChild(document.createComment(\"stopwikilink\"));\n        Element.as(anchor).setMetaData(metaData);\n    }","commit_id":"1262ed5cafdec37973c83e0559a4d5905861b693","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Processes the passed anchor looking for the wrapping span and neighbour comments to encapsulate it all in a\n     * metafragment and leave only the anchor in the tree.\n     * \n     * @param anchor the anchor element found\n     */\n    private void processElement(Element anchor)\n    {\n        // search for parent span and surrounding comments\n        Element parentNode = anchor.getParentElement().cast();\n        boolean foundWikiLink = parentNode != null && parentNode.getNodeName().equalsIgnoreCase(\"span\");\n        String spanClass = parentNode.getClassName();\n        foundWikiLink &=\n            spanClass.contains(\"wikilink\") || spanClass.contains(\"wikicreatelink\")\n                || spanClass.contains(\"wikiexternallink\");\n        Node previousSibling = null;\n        Node nextSibling = null;\n        if (foundWikiLink) {\n            // test the surrounding comments\n            previousSibling = parentNode.getPreviousSibling();\n            foundWikiLink &=\n                previousSibling != null && previousSibling.getNodeType() == DOMUtils.COMMENT_NODE\n                    && previousSibling.getNodeValue().startsWith(\"startwikilink\");\n            nextSibling = parentNode.getNextSibling();\n            foundWikiLink &=\n                nextSibling != null && nextSibling.getNodeType() == DOMUtils.COMMENT_NODE\n                    && nextSibling.getNodeValue().startsWith(\"stopwikilink\");\n        }\n\n        if (!foundWikiLink) {\n            return;\n        }\n\n        DocumentFragment metaFragment = ((Document) anchor.getOwnerDocument()).createDocumentFragment();\n        // put the end comments in\n        metaFragment.appendChild(previousSibling);\n        // create the placeholder and replace the anchor\n        Text placeholder = (Text) ((Document) anchor.getOwnerDocument()).createTextNode(Element.INNER_HTML_PLACEHOLDER);\n        parentNode.replaceChild(placeholder, anchor);\n        // replace the parent node with the anchor\n        parentNode.getParentElement().replaceChild(anchor, parentNode);\n        // put parent node in meta fragment\n        metaFragment.appendChild(parentNode);\n        // put the end comment in\n        metaFragment.appendChild(nextSibling);\n        anchor.setMetaData(metaFragment);\n    }","id":42757,"modified_method":"/**\n     * Processes the passed anchor looking for the wrapping span and neighbor comments to encapsulate it all in a meta\n     * fragment and leave only the anchor in the tree.\n     * \n     * @param anchor the anchor element found\n     */\n    private void processElement(Element anchor)\n    {\n        // Search for parent span and surrounding comments.\n        Element parentNode = anchor.getParentElement().cast();\n        if (parentNode == null || !\"span\".equalsIgnoreCase(parentNode.getNodeName())\n            || LinkType.getByClassName(parentNode.getClassName()) == null || !hasLinkMarkers(parentNode)) {\n            return;\n        }\n\n        DocumentFragment metaFragment = ((Document) anchor.getOwnerDocument()).createDocumentFragment();\n        // Move the link markers.\n        metaFragment.appendChild(parentNode.getPreviousSibling());\n        metaFragment.appendChild(parentNode.getNextSibling());\n        // Create the place-holder and replace the anchor.\n        Text placeholder = (Text) ((Document) anchor.getOwnerDocument()).createTextNode(Element.INNER_HTML_PLACEHOLDER);\n        parentNode.replaceChild(placeholder, anchor);\n        // Replace the parent node with the anchor.\n        parentNode.getParentElement().replaceChild(anchor, parentNode);\n        // Put the parent node in the meta fragment.\n        metaFragment.insertAfter(parentNode, metaFragment.getFirstChild());\n        anchor.setMetaData(metaFragment);\n    }","commit_id":"1262ed5cafdec37973c83e0559a4d5905861b693","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static PsiElement findTargetElement(Project project, Editor editor, int offset) {\n    int flags = TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED\n                | TargetElementUtil.NEW_AS_CONSTRUCTOR\n                | TargetElementUtil.LOOKUP_ITEM_ACCEPTED\n                | TargetElementUtil.THIS_ACCEPTED\n                | TargetElementUtil.SUPER_ACCEPTED;\n    PsiElement element = TargetElementUtil.findTargetElement(editor, flags, offset);\n\n    if (element != null) return element;\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) {\n      return null;\n    }\n    PsiElement elementAt = file.findElementAt(offset);\n    if (elementAt instanceof PsiKeyword) {\n      IElementType type = ((PsiKeyword)elementAt).getTokenType();\n      if (type == JavaTokenType.CONTINUE_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiContinueStatement) {\n          return ((PsiContinueStatement)elementAt.getParent()).findContinuedStatement();\n        }\n      }\n      else if (type == JavaTokenType.BREAK_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiBreakStatement) {\n          PsiStatement statement = ((PsiBreakStatement)elementAt.getParent()).findExitedStatement();\n          if (statement == null) return null;\n          if (statement.getParent() instanceof PsiLabeledStatement) {\n            statement = (PsiStatement)statement.getParent();\n          }\n          PsiElement nextSibling = statement.getNextSibling();\n          while (!(nextSibling instanceof PsiStatement) && nextSibling != null) nextSibling = nextSibling.getNextSibling();\n          return nextSibling != null ? nextSibling : statement.getNextSibling();\n        }\n      }\n    }\n    else if (elementAt instanceof PsiIdentifier) {\n      PsiElement parent = elementAt.getParent();\n      PsiStatement statement = null;\n      if (parent instanceof PsiContinueStatement) {\n        statement = ((PsiContinueStatement)parent).findContinuedStatement();\n      }\n      else if (parent instanceof PsiBreakStatement) {\n        statement = ((PsiBreakStatement)parent).findExitedStatement();\n      }\n      if (statement == null) return null;\n\n      LOG.assertTrue(statement.getParent() instanceof PsiLabeledStatement);\n      return ((PsiLabeledStatement)statement.getParent()).getLabelIdentifier();\n    }\n\n    return null;\n  }","id":42758,"modified_method":"public static PsiElement findTargetElement(Project project, Editor editor, int offset) {\n    int flags = TargetElementUtil.REFERENCED_ELEMENT_ACCEPTED\n                | TargetElementUtil.NEW_AS_CONSTRUCTOR\n                | TargetElementUtil.LOOKUP_ITEM_ACCEPTED\n                | TargetElementUtil.THIS_ACCEPTED\n                | TargetElementUtil.SUPER_ACCEPTED;\n    PsiElement element = TargetElementUtil.findTargetElement(editor, flags, offset);\n\n    if (element != null) return element;\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) {\n      return null;\n    }\n    PsiElement elementAt = file.findElementAt(offset);\n    if (elementAt instanceof PsiKeyword) {\n      IElementType type = ((PsiKeyword)elementAt).getTokenType();\n      if (type == JavaTokenType.CONTINUE_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiContinueStatement) {\n          return ((PsiContinueStatement)elementAt.getParent()).findContinuedStatement();\n        }\n      }\n      else if (type == JavaTokenType.BREAK_KEYWORD) {\n        if (elementAt.getParent() instanceof PsiBreakStatement) {\n          PsiStatement statement = ((PsiBreakStatement)elementAt.getParent()).findExitedStatement();\n          if (statement == null) return null;\n          if (statement.getParent() instanceof PsiLabeledStatement) {\n            statement = (PsiStatement)statement.getParent();\n          }\n          PsiElement nextSibling = statement.getNextSibling();\n          while (!(nextSibling instanceof PsiStatement) && nextSibling != null) nextSibling = nextSibling.getNextSibling();\n          //return nextSibling != null ? nextSibling : statement.getNextSibling();\n          if (nextSibling != null) return nextSibling;\n          nextSibling = statement.getNextSibling();\n          if (nextSibling != null) return nextSibling;\n          return statement.getLastChild();\n        }\n      }\n    }\n    else if (elementAt instanceof PsiIdentifier) {\n      PsiElement parent = elementAt.getParent();\n      PsiStatement statement = null;\n      if (parent instanceof PsiContinueStatement) {\n        statement = ((PsiContinueStatement)parent).findContinuedStatement();\n      }\n      else if (parent instanceof PsiBreakStatement) {\n        statement = ((PsiBreakStatement)parent).findExitedStatement();\n      }\n      if (statement == null) return null;\n\n      LOG.assertTrue(statement.getParent() instanceof PsiLabeledStatement);\n      return ((PsiLabeledStatement)statement.getParent()).getLabelIdentifier();\n    }\n\n    return null;\n  }","commit_id":"7257a380020c5eb9f08298a246dbae1255c256e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(final Project project, Editor editor, PsiFile file) {\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    int offset = getOffset(editor);\n    PsiElement element = findTargetElement(project, editor, offset);\n    if (element == null) {\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.declaration\");\n      chooseAmbiguousTarget(project, editor, offset);\n      return;\n    }\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.declaration\");\n    PsiElement navElement = element.getNavigationElement();\n\n    //TODO: move this logic to ClsMethodImpl.getNavigationElement\n    if (navElement == element && element instanceof PsiCompiledElement && element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      if (method.isConstructor() && method.getParameterList().getParameters().length == 0) {\n        PsiClass aClass = method.getContainingClass();\n        PsiElement navClass = aClass.getNavigationElement();\n        if (aClass != navClass) navElement = navClass;\n      }\n    }\n\n    if (navElement instanceof Navigatable && ((Navigatable)navElement).canNavigate()) {\n        ((Navigatable)navElement).navigate(true);\n    }\n  }","id":42759,"modified_method":"public void invoke(final Project project, Editor editor, PsiFile file) {\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    int offset = getOffset(editor);\n    PsiElement element = findTargetElement(project, editor, offset);\n    if (element == null) {\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.declaration\");\n      chooseAmbiguousTarget(project, editor, offset);\n      return;\n    }\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.declaration\");\n    PsiElement navElement = element.getNavigationElement();\n\n    //TODO: move this logic to ClsMethodImpl.getNavigationElement\n    if (navElement == element && element instanceof PsiCompiledElement && element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)element;\n      if (method.isConstructor() && method.getParameterList().getParameters().length == 0) {\n        PsiClass aClass = method.getContainingClass();\n        PsiElement navClass = aClass.getNavigationElement();\n        if (aClass != navClass) navElement = navClass;\n      }\n    }\n\n    if (navElement instanceof Navigatable) {\n      if (((Navigatable)navElement).canNavigate()) {\n        ((Navigatable)navElement).navigate(true);\n      }\n    }\n    else if (navElement != null) {\n      int navOffset = navElement.getTextOffset();\n      VirtualFile virtualFile = PsiUtil.getVirtualFile(navElement);\n      if (virtualFile != null) {\n        new OpenFileDescriptor(project, virtualFile, navOffset).navigate(true);\n      }\n    }\n  }","commit_id":"7257a380020c5eb9f08298a246dbae1255c256e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initVariantsInClassScope() {\n    super.initVariantsInClassScope();\n    {\n      //Completion of \"this\" & \"super\" inside wildcards\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\"))), new LeftNeighbour(new TextFilter(\"?\"))));\n      variant.includeScopeClass(PsiVariable.class, true);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.EXTENDS, TailType.SPACE);\n      this.registerVariant(variant);\n    }\n  }","id":42760,"modified_method":"protected void initVariantsInClassScope() {\n    super.initVariantsInClassScope();\n    {\n      //Completion of \"this\" & \"super\" inside wildcards\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\"))), new LeftNeighbour(new TextFilter(\"?\"))));\n      variant.includeScopeClass(PsiVariable.class, true);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.EXTENDS, TailType.SPACE);\n      registerVariant(variant);\n    }\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initVariantsInFileScope() {\n    super.initVariantsInFileScope();\n    //static keyword in static import\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiImportList.class, new LeftNeighbour(new TextFilter (PsiKeyword.IMPORT)));\n      variant.addCompletion(PsiKeyword.STATIC, TailType.SPACE);\n\n      this.registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new AndFilter(new LeftNeighbour(new TextFilter(\"@\")),\n                                                   new NotFilter(new SuperParentFilter(\n                                                     new OrFilter(new ElementFilter[] {\n                                                       new ClassFilter(PsiNameValuePair.class),\n                                                       new ClassFilter(PsiParameterList.class)\n                                                     }\n                                                     )))\n                                                   );\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiClass.class);\n\n      variant.addCompletion(PsiKeyword.INTERFACE, TailType.SPACE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new OrFilter(new ElementFilter[]{\n        END_OF_BLOCK,\n        new LeftNeighbour(new TextFilter(MODIFIERS_LIST)),\n        new StartElementFilter()\n      });\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiClass.class);\n\n      variant.addCompletion(PsiKeyword.ENUM, TailType.SPACE);\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new ElementFilter() {\n        public boolean isClassAcceptable(Class hintClass){\n          return true;\n        }\n      \n        public boolean isAcceptable(Object element, PsiElement context){\n          if (! (element instanceof PsiElement)) return false;\n          final PsiElement parent = ((PsiElement)element).getParent();\n  \n          final PsiElement grandparent = (parent != null)?parent.getParent():null;\n          return (parent instanceof PsiNameValuePair ||\n                  grandparent instanceof PsiNameValuePair\n                 );\n        }\n      };\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiNameValuePair.class);\n\n      variant.addCompletion(new AnnotationMethodsGetter(), TailType.NONE);\n      variant.addCompletionFilter(TrueFilter.INSTANCE, TailType.NONE);\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new ScopeFilter(new ParentElementFilter(new AndFilter(\n        new ClassFilter(PsiSwitchLabelStatement.class),\n        new ParentElementFilter(\n          new PositionElementFilter() {\n            public boolean isAcceptable(Object element, PsiElement context) {\n              if (!(element instanceof PsiSwitchStatement)) return false;\n              final PsiExpression expression = ((PsiSwitchStatement)element).getExpression();\n              if(expression == null) return false;\n              final PsiType type = expression.getType();\n              return type instanceof PsiClassType;\n            }\n          }, 2)\n      )));\n      final CompletionVariant variant = new CompletionVariant(PsiReferenceExpression.class, position);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiEnumConstant.class), ':');\n      registerVariant(variant);\n    }\n  }","id":42761,"modified_method":"protected void initVariantsInFileScope() {\n    super.initVariantsInFileScope();\n    //static keyword in static import\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiImportList.class, new LeftNeighbour(new TextFilter (PsiKeyword.IMPORT)));\n      variant.addCompletion(PsiKeyword.STATIC, TailType.SPACE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new AndFilter(new LeftNeighbour(new TextFilter(\"@\")),\n                                                   new NotFilter(new SuperParentFilter(\n                                                     new OrFilter(new ClassFilter(PsiNameValuePair.class),\n                                                         new ClassFilter(PsiParameterList.class))))\n                                                   );\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiClass.class);\n\n      variant.addCompletion(PsiKeyword.INTERFACE, TailType.SPACE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new OrFilter(END_OF_BLOCK,\n          new LeftNeighbour(new TextFilter(MODIFIERS_LIST)),\n          new StartElementFilter());\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiClass.class);\n\n      variant.addCompletion(PsiKeyword.ENUM, TailType.SPACE);\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new ElementFilter() {\n        public boolean isClassAcceptable(Class hintClass){\n          return true;\n        }\n      \n        public boolean isAcceptable(Object element, PsiElement context){\n          if (! (element instanceof PsiElement)) return false;\n          final PsiElement parent = ((PsiElement)element).getParent();\n  \n          final PsiElement grandparent = (parent != null)?parent.getParent():null;\n          return (parent instanceof PsiNameValuePair ||\n                  grandparent instanceof PsiNameValuePair\n                 );\n        }\n      };\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiNameValuePair.class);\n\n      variant.addCompletion(new AnnotationMethodsGetter(), TailType.NONE);\n      variant.addCompletionFilter(TrueFilter.INSTANCE, TailType.NONE);\n      registerVariant(variant);\n    }\n\n    {\n      final ElementFilter position = new ScopeFilter(new ParentElementFilter(new AndFilter(\n        new ClassFilter(PsiSwitchLabelStatement.class),\n        new ParentElementFilter(\n          new PositionElementFilter() {\n            public boolean isAcceptable(Object element, PsiElement context) {\n              if (!(element instanceof PsiSwitchStatement)) return false;\n              final PsiExpression expression = ((PsiSwitchStatement)element).getExpression();\n              if(expression == null) return false;\n              final PsiType type = expression.getType();\n              return type instanceof PsiClassType;\n            }\n          }, 2)\n      )));\n      final CompletionVariant variant = new CompletionVariant(PsiReferenceExpression.class, position);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiEnumConstant.class), ':');\n      registerVariant(variant);\n    }\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void declareCompletionSpaces() {\n    declareFinalScope(PsiFile.class);\n\n    {\n      // Class body\n      final CompletionVariant variant = new CompletionVariant(CLASS_BODY);\n      variant.includeScopeClass(PsiClass.class, true);\n      this.registerVariant(variant);\n    }\n    {\n      // Method body\n      final CompletionVariant variant = new CompletionVariant(new InsideElementFilter(new ClassFilter(PsiCodeBlock.class)));\n      variant.includeScopeClass(PsiMethod.class, true);\n      variant.includeScopeClass(PsiClassInitializer.class, true);\n      this.registerVariant(variant);\n    }\n\n    {\n      // Field initializer\n      final CompletionVariant variant = new CompletionVariant(new AfterElementFilter(new TextFilter(\"=\")));\n      variant.includeScopeClass(PsiField.class, true);\n      this.registerVariant(variant);\n    }\n\n    declareFinalScope(PsiLiteralExpression.class);\n    declareFinalScope(PsiComment.class);\n  }","id":42762,"modified_method":"private void declareCompletionSpaces() {\n    declareFinalScope(PsiFile.class);\n\n    {\n      // Class body\n      final CompletionVariant variant = new CompletionVariant(CLASS_BODY);\n      variant.includeScopeClass(PsiClass.class, true);\n      registerVariant(variant);\n    }\n    {\n      // Method body\n      final CompletionVariant variant = new CompletionVariant(new InsideElementFilter(new ClassFilter(PsiCodeBlock.class)));\n      variant.includeScopeClass(PsiMethod.class, true);\n      variant.includeScopeClass(PsiClassInitializer.class, true);\n      registerVariant(variant);\n    }\n\n    {\n      // Field initializer\n      final CompletionVariant variant = new CompletionVariant(new AfterElementFilter(new TextFilter(\"=\")));\n      variant.includeScopeClass(PsiField.class, true);\n      registerVariant(variant);\n    }\n\n    declareFinalScope(PsiLiteralExpression.class);\n    declareFinalScope(PsiComment.class);\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initVariantsInFileScope(){\n// package keyword completion\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, new StartElementFilter());\n      variant.addCompletion(PsiKeyword.PACKAGE);\n      this.registerVariant(variant);\n    }\n\n// import keyword completion\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, new OrFilter(\n        new StartElementFilter(),\n        END_OF_BLOCK\n      ));\n      variant.addCompletion(PsiKeyword.IMPORT);\n\n      this.registerVariant(variant);\n    }\n// other in file scope\n    {\n      final ElementFilter position = new OrFilter(new ElementFilter[]{\n        END_OF_BLOCK,\n        new LeftNeighbour(new OrFilter(new SuperParentFilter(new ClassFilter(PsiAnnotation.class)),\n                                       new TextFilter(MODIFIERS_LIST))),\n        new StartElementFilter()\n      });\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiClass.class);\n\n      variant.addCompletion(PsiKeyword.CLASS);\n      variant.addCompletion(PsiKeyword.INTERFACE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiTypeCodeFragment.class, new StartElementFilter());\n      addPrimitiveTypes(variant, TailType.NONE);\n      final CompletionVariant variant1 = new CompletionVariant(PsiTypeCodeFragment.class,\n                                                               new AndFilter(\n                                                                 new StartElementFilter(),\n                                                                 new TypeCodeFragmentIsVoidEnabledFilter()\n                                                               )\n                                                               );\n      variant1.addCompletion(PsiKeyword.VOID, TailType.NONE);\n      registerVariant(variant);\n      registerVariant(variant1);\n\n    }\n\n  }","id":42763,"modified_method":"protected void initVariantsInFileScope(){\n// package keyword completion\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, new StartElementFilter());\n      variant.addCompletion(PsiKeyword.PACKAGE);\n      registerVariant(variant);\n    }\n\n// import keyword completion\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, new OrFilter(\n        new StartElementFilter(),\n        END_OF_BLOCK\n      ));\n      variant.addCompletion(PsiKeyword.IMPORT);\n\n      registerVariant(variant);\n    }\n// other in file scope\n    {\n      final ElementFilter position = new OrFilter(\n          END_OF_BLOCK,\n          new LeftNeighbour(new OrFilter(new SuperParentFilter(new ClassFilter(PsiAnnotation.class)),\n                                         new TextFilter(MODIFIERS_LIST))),\n          new StartElementFilter());\n\n      final CompletionVariant variant = new CompletionVariant(PsiJavaFile.class, position);\n      variant.includeScopeClass(PsiClass.class);\n\n      variant.addCompletion(PsiKeyword.CLASS);\n      variant.addCompletion(PsiKeyword.INTERFACE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiTypeCodeFragment.class, new StartElementFilter());\n      addPrimitiveTypes(variant, TailType.NONE);\n      final CompletionVariant variant1 = new CompletionVariant(PsiTypeCodeFragment.class,\n                                                               new AndFilter(\n                                                                 new StartElementFilter(),\n                                                                 new TypeCodeFragmentIsVoidEnabledFilter()\n                                                               )\n                                                               );\n      variant1.addCompletion(PsiKeyword.VOID, TailType.NONE);\n      registerVariant(variant);\n      registerVariant(variant1);\n\n    }\n\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * aClass == null for JspDeclaration scope\n   */\n  protected void initVariantsInClassScope() {\n// Completion for extends keyword\n// position\n    {\n      final ElementFilter position = new AndFilter(new ElementFilter[]{\n        new NotFilter(CLASS_BODY),\n        new NotFilter(new AfterElementFilter(new ContentFilter(new TextFilter(PsiKeyword.EXTENDS)))),\n        new NotFilter(new AfterElementFilter(new ContentFilter(new TextFilter(PsiKeyword.IMPLEMENTS)))),\n        new NotFilter(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\", \",\")))),\n        new NotFilter(new ScopeFilter(new EnumFilter())),\n        new LeftNeighbour(new OrFilter(\n          new ClassFilter(PsiIdentifier.class),\n          new TextFilter(\">\"))),\n      });\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.addCompletion(PsiKeyword.EXTENDS);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n      variant.excludeScopeClass(PsiTypeParameter.class);\n\n      this.registerVariant(variant);\n    }\n// Completion for implements keyword\n// position\n    {\n      final ElementFilter position = new AndFilter(new ElementFilter[]{\n        new NotFilter(CLASS_BODY),\n        new NotFilter(new BeforeElementFilter(new ContentFilter(new TextFilter(PsiKeyword.EXTENDS)))),\n        new NotFilter(new AfterElementFilter(new ContentFilter(new TextFilter(PsiKeyword.IMPLEMENTS)))),\n        new NotFilter(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\", \",\")))),\n        new LeftNeighbour(new OrFilter(\n          new ClassFilter(PsiIdentifier.class),\n          new TextFilter(\">\"))),\n        new NotFilter(new ScopeFilter(new InterfaceFilter()))\n      });\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.addCompletion(PsiKeyword.IMPLEMENTS);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n\n      this.registerVariant(variant);\n    }\n\n// Completion after extends in interface, type parameter and implements in class\n// position\n    {\n      final ElementFilter position = new AndFilter(\n        new NotFilter(CLASS_BODY),\n        new OrFilter( new ElementFilter [] {\n          new AndFilter(\n            new LeftNeighbour(new TextFilter(PsiKeyword.EXTENDS, \",\")),\n            new ScopeFilter(new InterfaceFilter())\n          ),\n          new AndFilter(\n            new LeftNeighbour(new TextFilter(PsiKeyword.EXTENDS, \"&\")),\n            new ScopeFilter(new ClassFilter(PsiTypeParameter.class))\n          ),\n          new LeftNeighbour(new TextFilter(PsiKeyword.IMPLEMENTS, \",\"))\n        }\n        )\n      );\n// completion\n      final OrFilter flags = new OrFilter();\n      flags.addFilter(new ThisOrAnyInnerFilter(\n        new AndFilter(new ElementFilter[]{\n          new ClassFilter(PsiClass.class),\n          new NotFilter(new AssignableFromContextFilter()),\n          new InterfaceFilter()\n        })\n      ));\n      flags.addFilter(new ClassFilter(PsiPackage.class));\n      CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n      variant.addCompletionFilterOnElement(flags);\n\n      this.registerVariant(variant);\n    }\n// Completion for classes in class extends\n// position\n    {\n      final ElementFilter position = new AndFilter(\n        new NotFilter(CLASS_BODY),\n        new AndFilter(new ElementFilter[]{\n          new LeftNeighbour(new TextFilter(PsiKeyword.EXTENDS)),\n          new ScopeFilter(new NotFilter(new InterfaceFilter()))\n        })\n      );\n\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(\n        new AndFilter(new ElementFilter[]{\n          new ClassFilter(PsiClass.class),\n          new NotFilter(new AssignableFromContextFilter()),\n          new NotFilter(new InterfaceFilter()),\n          new ModifierFilter(PsiModifier.FINAL, false)\n        })\n      ));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      this.registerVariant(variant);\n    }\n    {\n// declaration start\n// position\n      final CompletionVariant variant = new CompletionVariant(PsiClass.class, new AndFilter(\n        CLASS_BODY,\n        new OrFilter(\n          END_OF_BLOCK,\n          new LeftNeighbour(new OrFilter(\n            new TextFilter(MODIFIERS_LIST),\n            new SuperParentFilter(new ClassFilter(PsiAnnotation.class)),\n            new TokenTypeFilter(JavaTokenType.GT)))\n        )));\n\n// completion\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.VOID);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      this.registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\", \",\"))));\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.addCompletion(PsiKeyword.EXTENDS, TailType.SPACE);\n      this.registerVariant(variant);\n    }\n  }","id":42764,"modified_method":"/**\n   * aClass == null for JspDeclaration scope\n   */\n  protected void initVariantsInClassScope() {\n// Completion for extends keyword\n// position\n    {\n      final ElementFilter position = new AndFilter(\n          new NotFilter(CLASS_BODY),\n          new NotFilter(new AfterElementFilter(new ContentFilter(new TextFilter(PsiKeyword.EXTENDS)))),\n          new NotFilter(new AfterElementFilter(new ContentFilter(new TextFilter(PsiKeyword.IMPLEMENTS)))),\n          new NotFilter(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\", \",\")))),\n          new NotFilter(new ScopeFilter(new EnumFilter())),\n          new LeftNeighbour(new OrFilter(\n            new ClassFilter(PsiIdentifier.class),\n            new TextFilter(\">\"))));\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.addCompletion(PsiKeyword.EXTENDS);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n      variant.excludeScopeClass(PsiTypeParameter.class);\n\n      registerVariant(variant);\n    }\n// Completion for implements keyword\n// position\n    {\n      final ElementFilter position = new AndFilter(\n          new NotFilter(CLASS_BODY),\n          new NotFilter(new BeforeElementFilter(new ContentFilter(new TextFilter(PsiKeyword.EXTENDS)))),\n          new NotFilter(new AfterElementFilter(new ContentFilter(new TextFilter(PsiKeyword.IMPLEMENTS)))),\n          new NotFilter(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\", \",\")))),\n          new LeftNeighbour(new OrFilter(\n            new ClassFilter(PsiIdentifier.class),\n            new TextFilter(\">\"))),\n          new NotFilter(new ScopeFilter(new InterfaceFilter())));\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.addCompletion(PsiKeyword.IMPLEMENTS);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n\n      registerVariant(variant);\n    }\n\n// Completion after extends in interface, type parameter and implements in class\n// position\n    {\n      final ElementFilter position = new AndFilter(\n        new NotFilter(CLASS_BODY),\n        new OrFilter(\n            new AndFilter(\n                new LeftNeighbour(new TextFilter(PsiKeyword.EXTENDS, \",\")),\n                new ScopeFilter(new InterfaceFilter())\n            ),\n            new AndFilter(\n                new LeftNeighbour(new TextFilter(PsiKeyword.EXTENDS, \"&\")),\n                new ScopeFilter(new ClassFilter(PsiTypeParameter.class))\n            ),\n            new LeftNeighbour(new TextFilter(PsiKeyword.IMPLEMENTS, \",\")))\n      );\n// completion\n      final OrFilter flags = new OrFilter();\n      flags.addFilter(new ThisOrAnyInnerFilter(\n        new AndFilter(\n            new ClassFilter(PsiClass.class),\n            new NotFilter(new AssignableFromContextFilter()),\n            new InterfaceFilter())\n      ));\n      flags.addFilter(new ClassFilter(PsiPackage.class));\n      CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n      variant.addCompletionFilterOnElement(flags);\n\n      registerVariant(variant);\n    }\n// Completion for classes in class extends\n// position\n    {\n      final ElementFilter position = new AndFilter(\n        new NotFilter(CLASS_BODY),\n        new AndFilter(\n            new LeftNeighbour(new TextFilter(PsiKeyword.EXTENDS)),\n            new ScopeFilter(new NotFilter(new InterfaceFilter())))\n      );\n\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.excludeScopeClass(PsiAnonymousClass.class);\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(\n        new AndFilter(\n            new ClassFilter(PsiClass.class),\n            new NotFilter(new AssignableFromContextFilter()),\n            new NotFilter(new InterfaceFilter()),\n            new ModifierFilter(PsiModifier.FINAL, false))\n      ));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      registerVariant(variant);\n    }\n    {\n// declaration start\n// position\n      final CompletionVariant variant = new CompletionVariant(PsiClass.class, new AndFilter(\n        CLASS_BODY,\n        new OrFilter(\n          END_OF_BLOCK,\n          new LeftNeighbour(new OrFilter(\n            new TextFilter(MODIFIERS_LIST),\n            new SuperParentFilter(new ClassFilter(PsiAnnotation.class)),\n            new TokenTypeFilter(JavaTokenType.GT)))\n        )));\n\n// completion\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.VOID);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new LeftNeighbour(new LeftNeighbour(new TextFilter(\"<\", \",\"))));\n      variant.includeScopeClass(PsiClass.class, true);\n      variant.addCompletion(PsiKeyword.EXTENDS, TailType.SPACE);\n      registerVariant(variant);\n    }\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initVariantsInFieldScope() {\n    {\n// completion in initializer\n      final CompletionVariant variant = new CompletionVariant(new AfterElementFilter(new TextFilter(\"=\")));\n      variant.includeScopeClass(PsiVariable.class, false);\n      variant.addCompletionFilterOnElement(new OrFilter(\n        new ClassFilter(PsiVariable.class, false),\n        new ExcludeDeclaredFilter(new ClassFilter(PsiVariable.class))\n      ));\n      this.registerVariant(variant);\n    }\n  }","id":42765,"modified_method":"private void initVariantsInFieldScope() {\n    {\n// completion in initializer\n      final CompletionVariant variant = new CompletionVariant(new AfterElementFilter(new TextFilter(\"=\")));\n      variant.includeScopeClass(PsiVariable.class, false);\n      variant.addCompletionFilterOnElement(new OrFilter(\n        new ClassFilter(PsiVariable.class, false),\n        new ExcludeDeclaredFilter(new ClassFilter(PsiVariable.class))\n      ));\n      registerVariant(variant);\n    }\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initVariantsInMethodScope() {\n    {\n// parameters list completion\n      final CompletionVariant variant = new CompletionVariant(\n        new LeftNeighbour(new OrFilter(new TextFilter(new String[]{\"(\", \",\", PsiKeyword.FINAL}),\n                                       new SuperParentFilter(new ClassFilter(PsiAnnotation.class)))));\n      variant.includeScopeClass(PsiParameterList.class, true);\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.FINAL);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n      this.registerVariant(variant);\n    }\n\n// Completion for classes in method throws section\n// position\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\")\"),\n        new ParentElementFilter(new ClassFilter(PsiParameterList.class))));\n\n// completion\n      CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiClass.class); // for throws on separate line\n      variant.addCompletion(PsiKeyword.THROWS);\n\n      this.registerVariant(variant);\n\n//in annotation methods\n      variant = new CompletionVariant(PsiAnnotationMethod.class, position);\n      variant.addCompletion(PsiKeyword.DEFAULT);\n      this.registerVariant(variant);\n    }\n\n    {\n// Completion for classes in method throws section\n// position\n      final ElementFilter position = new AndFilter(\n        new LeftNeighbour(new TextFilter(PsiKeyword.THROWS, \",\")),\n        new InsideElementFilter(new ClassFilter(PsiReferenceList.class))\n      );\n\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiMethod.class, true);\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\")));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      this.registerVariant(variant);\n    }\n\n    {\n// completion for declarations\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new OrFilter(END_OF_BLOCK, new LeftNeighbour(new TextFilter(PsiKeyword.FINAL))));\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.CLASS);\n      this.registerVariant(variant);\n    }\n\n// Completion in cast expressions\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new AndFilter(\n        new TextFilter(\"(\"),\n        new ParentElementFilter(new OrFilter(\n          new ClassFilter(PsiParenthesizedExpression.class),\n          new ClassFilter(PsiTypeCastExpression.class))))));\n      addPrimitiveTypes(variant);\n      this.registerVariant(variant);\n    }\n\n    {\n// instanceof keyword\n      final ElementFilter position = new LeftNeighbour(new OrFilter(new ElementFilter[]{\n        new ReferenceOnFilter(new ClassFilter(PsiVariable.class)),\n        new TextFilter(PsiKeyword.THIS),\n        new AndFilter(new TextFilter(\")\"), new ParentElementFilter(new AndFilter(\n          new ClassFilter(PsiTypeCastExpression.class, false),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiExpression.class)),\n            new ClassFilter(PsiExpression.class))))),\n        new AndFilter(new TextFilter(\"]\"), new ParentElementFilter(new ClassFilter(PsiArrayAccessExpression.class)))\n      }));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.includeScopeClass(PsiMethod.class);\n      variant.addCompletionFilter(new FalseFilter());\n      variant.addCompletion(PsiKeyword.INSTANCEOF);\n\n      this.registerVariant(variant);\n    }\n\n    {\n// after instanceof keyword\n      final ElementFilter position = new PreviousElementFilter(new TextFilter(PsiKeyword.INSTANCEOF));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n\n      this.registerVariant(variant);\n    }\n\n    {\n// after final keyword\n      final ElementFilter position = new AndFilter(new SuperParentFilter(new ClassFilter(PsiCodeBlock.class)),\n                                                   new LeftNeighbour(new TextFilter(PsiKeyword.FINAL)));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiDeclarationStatement.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n      addPrimitiveTypes(variant);\n\n      this.registerVariant(variant);\n    }\n\n    {\n// Keyword completion in start of declaration\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, END_OF_BLOCK);\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      addKeywords(variant);\n      this.registerVariant(variant);\n    }\n\n    {\n// Keyword completion in returns\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new TextFilter(PsiKeyword.RETURN)));\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      this.registerVariant(variant);\n    }\n\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new TextFilter(PsiKeyword.TRY)),\n          new ParentElementFilter(new ClassFilter(PsiTryStatement.class))))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, true);\n      variant.addCompletion(PsiKeyword.CATCH, TailType.LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, '{');\n      variant.addCompletionFilter(new FalseFilter());\n      this.registerVariant(variant);\n    }\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new NotFilter(new TextFilter(PsiKeyword.TRY))),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n            new ParentElementFilter(new ClassFilter(PsiCatchSection.class)))\n          ))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      variant.addCompletion(PsiKeyword.CATCH, TailType.LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, '{');\n      //variant.addCompletionFilter(new FalseFilter());\n      this.registerVariant(variant);\n    }\n\n    {\n// Completion for catches\n      final CompletionVariant variant = new CompletionVariant(PsiTryStatement.class, new PreviousElementFilter(new AndFilter(\n        new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n        new TextFilter(\"(\")\n      )));\n      variant.includeScopeClass(PsiParameter.class);\n\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\")));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      this.registerVariant(variant);\n    }\n\n// Completion for else expression\n// completion\n    {\n      final ElementFilter position = new LeftNeighbour(\n        new OrFilter(\n          new AndFilter(new TextFilter(\"}\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 3)),\n          new AndFilter(new TextFilter(\";\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 2))\n        ));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.addCompletion(PsiKeyword.ELSE);\n\n      this.registerVariant(variant);\n    }\n\n    {\n// Super/This keyword completion\n      final ElementFilter position =\n        new LeftNeighbour(\n          new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n              new ReferenceOnFilter(new GeneratorFilter(EqualsFilter.class, new UpWalkGetter(new ClassFilter(PsiClass.class))))\n            )));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiVariable.class);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.DOT);\n      variant.addCompletion(PsiKeyword.THIS, TailType.DOT);\n      this.registerVariant(variant);\n    }\n    {\n// Class field completion\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(\n        new AndFilter(new TextFilter(\".\"), new LeftNeighbour(new OrFilter(new ElementFilter[]{\n          new ReferenceOnFilter(new ClassFilter(PsiClass.class)),\n          new TextFilter(PRIMITIVE_TYPES),\n          new TextFilter(\"]\")\n        })))));\n\n      variant.includeScopeClass(PsiVariable.class);\n      variant.addCompletion(PsiKeyword.CLASS, TailType.NONE);\n      this.registerVariant(variant);\n    }\n\n    {\n// break completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new OrFilter(\n        new ScopeFilter(new ClassFilter(PsiSwitchStatement.class)),\n        new InsideElementFilter(new ClassFilter(PsiBlockStatement.class)))));\n\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n      variant.includeScopeClass(PsiSwitchStatement.class, false);\n      variant.addCompletion(PsiKeyword.BREAK);\n      this.registerVariant(variant);\n    }\n    {\n// continue completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new InsideElementFilter(new ClassFilter(PsiBlockStatement.class))));\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n\n      variant.addCompletion(PsiKeyword.CONTINUE);\n      this.registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          END_OF_BLOCK,\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiSwitchLabelStatement.class)),\n            new LeftNeighbour(new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 2),\n              new AndFilter(new TextFilter(\";\", \"}\"),new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 3)\n              ))))));\n      variant.includeScopeClass(PsiSwitchStatement.class, true);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, ':');\n      this.registerVariant(variant);\n    }\n\n    {\n// primitive arrays after new\n      final CompletionVariant variant = new CompletionVariant(PsiExpression.class, new LeftNeighbour(\n        new AndFilter(new TextFilter(PsiKeyword.NEW), new LeftNeighbour(new NotFilter(new TextFilter(\".\", PsiKeyword.THROW)))))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      addPrimitiveTypes(variant);\n      variant.setItemProperty(LookupItem.BRACKETS_COUNT_ATTR, new Integer(1));\n      this.registerVariant(variant);\n    }\n\n    {\n// after new\n      final CompletionVariant variant = new CompletionVariant(new LeftNeighbour(new TextFilter(PsiKeyword.NEW)));\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n\n      this.registerVariant(variant);\n    }\n\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(\n        new ScopeFilter(new ParentElementFilter(new ClassFilter(PsiThrowStatement.class))),\n        new ParentElementFilter(new ClassFilter(PsiNewExpression.class)))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, false);\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\")));\n\n      this.registerVariant(variant);\n    }\n\n    {\n// completion in reference parameters\n      final CompletionVariant variant = new CompletionVariant(TrueFilter.INSTANCE);\n      variant.includeScopeClass(PsiReferenceParameterList.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n\n      this.registerVariant(variant);\n    }\n\n    {\n      // null completion\n      final CompletionVariant variant = new CompletionVariant(new NotFilter(new LeftNeighbour(new TextFilter(\".\"))));\n      variant.addCompletion(PsiKeyword.NULL,TailType.NONE);\n      variant.includeScopeClass(PsiExpressionList.class);\n      this.registerVariant(variant);\n    }\n  }","id":42766,"modified_method":"private void initVariantsInMethodScope() {\n    {\n// parameters list completion\n      final CompletionVariant variant = new CompletionVariant(\n        new LeftNeighbour(new OrFilter(new TextFilter(new String[]{\"(\", \",\", PsiKeyword.FINAL}),\n                                       new SuperParentFilter(new ClassFilter(PsiAnnotation.class)))));\n      variant.includeScopeClass(PsiParameterList.class, true);\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.FINAL);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n      registerVariant(variant);\n    }\n\n// Completion for classes in method throws section\n// position\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\")\"),\n        new ParentElementFilter(new ClassFilter(PsiParameterList.class))));\n\n// completion\n      CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiClass.class); // for throws on separate line\n      variant.addCompletion(PsiKeyword.THROWS);\n\n      registerVariant(variant);\n\n//in annotation methods\n      variant = new CompletionVariant(PsiAnnotationMethod.class, position);\n      variant.addCompletion(PsiKeyword.DEFAULT);\n      registerVariant(variant);\n    }\n\n    {\n// Completion for classes in method throws section\n// position\n      final ElementFilter position = new AndFilter(\n        new LeftNeighbour(new TextFilter(PsiKeyword.THROWS, \",\")),\n        new InsideElementFilter(new ClassFilter(PsiReferenceList.class))\n      );\n\n// completion\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiMethod.class, true);\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\")));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion for declarations\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new OrFilter(END_OF_BLOCK, new LeftNeighbour(new TextFilter(PsiKeyword.FINAL))));\n      addPrimitiveTypes(variant);\n      variant.addCompletion(PsiKeyword.CLASS);\n      registerVariant(variant);\n    }\n\n// Completion in cast expressions\n    {\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new AndFilter(\n        new TextFilter(\"(\"),\n        new ParentElementFilter(new OrFilter(\n          new ClassFilter(PsiParenthesizedExpression.class),\n          new ClassFilter(PsiTypeCastExpression.class))))));\n      addPrimitiveTypes(variant);\n      registerVariant(variant);\n    }\n\n    {\n// instanceof keyword\n      final ElementFilter position = new LeftNeighbour(new OrFilter(\n          new ReferenceOnFilter(new ClassFilter(PsiVariable.class)),\n          new TextFilter(PsiKeyword.THIS),\n          new AndFilter(new TextFilter(\")\"), new ParentElementFilter(new AndFilter(\n            new ClassFilter(PsiTypeCastExpression.class, false),\n            new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiExpression.class)),\n              new ClassFilter(PsiExpression.class))))),\n          new AndFilter(new TextFilter(\"]\"), new ParentElementFilter(new ClassFilter(PsiArrayAccessExpression.class)))));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.includeScopeClass(PsiMethod.class);\n      variant.addCompletionFilter(new FalseFilter());\n      variant.addCompletion(PsiKeyword.INSTANCEOF);\n\n      registerVariant(variant);\n    }\n\n    {\n// after instanceof keyword\n      final ElementFilter position = new PreviousElementFilter(new TextFilter(PsiKeyword.INSTANCEOF));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiExpression.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n\n      registerVariant(variant);\n    }\n\n    {\n// after final keyword\n      final ElementFilter position = new AndFilter(new SuperParentFilter(new ClassFilter(PsiCodeBlock.class)),\n                                                   new LeftNeighbour(new TextFilter(PsiKeyword.FINAL)));\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiDeclarationStatement.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n      addPrimitiveTypes(variant);\n\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in start of declaration\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, END_OF_BLOCK);\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      addKeywords(variant);\n      registerVariant(variant);\n    }\n\n    {\n// Keyword completion in returns\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(new TextFilter(PsiKeyword.RETURN)));\n      variant.addCompletion(PsiKeyword.THIS, TailType.NONE);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.NONE);\n      registerVariant(variant);\n    }\n\n\n// Catch/Finally completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new TextFilter(PsiKeyword.TRY)),\n          new ParentElementFilter(new ClassFilter(PsiTryStatement.class))))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, true);\n      variant.addCompletion(PsiKeyword.CATCH, TailType.LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, '{');\n      variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n// Catch/Finnaly completion\n    {\n      final ElementFilter position = new LeftNeighbour(new AndFilter(\n        new TextFilter(\"}\"),\n        new ParentElementFilter(new AndFilter(\n          new LeftNeighbour(new NotFilter(new TextFilter(PsiKeyword.TRY))),\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n            new ParentElementFilter(new ClassFilter(PsiCatchSection.class)))\n          ))));\n\n      final CompletionVariant variant = new CompletionVariant(position);\n      variant.includeScopeClass(PsiCodeBlock.class, false);\n      variant.addCompletion(PsiKeyword.CATCH, TailType.LPARENTH);\n      variant.addCompletion(PsiKeyword.FINALLY, '{');\n      //variant.addCompletionFilter(new FalseFilter());\n      registerVariant(variant);\n    }\n\n    {\n// Completion for catches\n      final CompletionVariant variant = new CompletionVariant(PsiTryStatement.class, new PreviousElementFilter(new AndFilter(\n        new ParentElementFilter(new ClassFilter(PsiTryStatement.class)),\n        new TextFilter(\"(\")\n      )));\n      variant.includeScopeClass(PsiParameter.class);\n\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\")));\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiPackage.class));\n\n      registerVariant(variant);\n    }\n\n// Completion for else expression\n// completion\n    {\n      final ElementFilter position = new LeftNeighbour(\n        new OrFilter(\n          new AndFilter(new TextFilter(\"}\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 3)),\n          new AndFilter(new TextFilter(\";\"),new ParentElementFilter(new ClassFilter(PsiIfStatement.class), 2))\n        ));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.addCompletion(PsiKeyword.ELSE);\n\n      registerVariant(variant);\n    }\n\n    {\n// Super/This keyword completion\n      final ElementFilter position =\n        new LeftNeighbour(\n          new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n              new ReferenceOnFilter(new GeneratorFilter(EqualsFilter.class, new UpWalkGetter(new ClassFilter(PsiClass.class))))\n            )));\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, position);\n      variant.includeScopeClass(PsiVariable.class);\n      variant.addCompletion(PsiKeyword.SUPER, TailType.DOT);\n      variant.addCompletion(PsiKeyword.THIS, TailType.DOT);\n      registerVariant(variant);\n    }\n    {\n// Class field completion\n      final CompletionVariant variant = new CompletionVariant(PsiMethod.class, new LeftNeighbour(\n        new AndFilter(\n            new TextFilter(\".\"),\n            new LeftNeighbour(\n                new OrFilter(\n                    new ReferenceOnFilter(new ClassFilter(PsiClass.class)),\n                    new TextFilter(PRIMITIVE_TYPES),\n                    new TextFilter(\"]\"))))));\n\n      variant.includeScopeClass(PsiVariable.class);\n      variant.addCompletion(PsiKeyword.CLASS, TailType.NONE);\n      registerVariant(variant);\n    }\n\n    {\n// break completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new OrFilter(\n        new ScopeFilter(new ClassFilter(PsiSwitchStatement.class)),\n        new InsideElementFilter(new ClassFilter(PsiBlockStatement.class)))));\n\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n      variant.includeScopeClass(PsiSwitchStatement.class, false);\n      variant.addCompletion(PsiKeyword.BREAK);\n      registerVariant(variant);\n    }\n    {\n// continue completion\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(END_OF_BLOCK, new InsideElementFilter(new ClassFilter(PsiBlockStatement.class))));\n      variant.includeScopeClass(PsiForeachStatement.class, false);\n      variant.includeScopeClass(PsiForStatement.class, false);\n      variant.includeScopeClass(PsiWhileStatement.class, false);\n      variant.includeScopeClass(PsiDoWhileStatement.class, false);\n\n      variant.addCompletion(PsiKeyword.CONTINUE);\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          END_OF_BLOCK,\n          new OrFilter(\n            new ParentElementFilter(new ClassFilter(PsiSwitchLabelStatement.class)),\n            new LeftNeighbour(new OrFilter(\n              new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 2),\n              new AndFilter(new TextFilter(\";\", \"}\"),new ParentElementFilter(new ClassFilter(PsiSwitchStatement.class), 3)\n              ))))));\n      variant.includeScopeClass(PsiSwitchStatement.class, true);\n      variant.addCompletion(PsiKeyword.CASE, TailType.SPACE);\n      variant.addCompletion(PsiKeyword.DEFAULT, ':');\n      registerVariant(variant);\n    }\n\n    {\n// primitive arrays after new\n      final CompletionVariant variant = new CompletionVariant(PsiExpression.class, new LeftNeighbour(\n        new AndFilter(new TextFilter(PsiKeyword.NEW), new LeftNeighbour(new NotFilter(new TextFilter(\".\", PsiKeyword.THROW)))))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      addPrimitiveTypes(variant);\n      variant.setItemProperty(LookupItem.BRACKETS_COUNT_ATTR, 1);\n      registerVariant(variant);\n    }\n\n    {\n// after new\n      final CompletionVariant variant = new CompletionVariant(new LeftNeighbour(new TextFilter(PsiKeyword.NEW)));\n      variant.includeScopeClass(PsiNewExpression.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n\n      registerVariant(variant);\n    }\n\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new AndFilter(\n        new ScopeFilter(new ParentElementFilter(new ClassFilter(PsiThrowStatement.class))),\n        new ParentElementFilter(new ClassFilter(PsiNewExpression.class)))\n      );\n      variant.includeScopeClass(PsiNewExpression.class, false);\n      variant.addCompletionFilterOnElement(new ThisOrAnyInnerFilter(new AssignableFromFilter(\"java.lang.Throwable\")));\n\n      registerVariant(variant);\n    }\n\n    {\n// completion in reference parameters\n      final CompletionVariant variant = new CompletionVariant(TrueFilter.INSTANCE);\n      variant.includeScopeClass(PsiReferenceParameterList.class, true);\n      variant.addCompletionFilterOnElement(new ClassFilter(PsiClass.class));\n\n      registerVariant(variant);\n    }\n\n    {\n      // null completion\n      final CompletionVariant variant = new CompletionVariant(new NotFilter(new LeftNeighbour(new TextFilter(\".\"))));\n      variant.addCompletion(PsiKeyword.NULL,TailType.NONE);\n      variant.includeScopeClass(PsiExpressionList.class);\n      registerVariant(variant);\n    }\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkParametersNumber(final List<CandidateInfo> conflicts, final int argumentsCount) {\n    boolean parametersNumberMatch = false;\n    for (CandidateInfo info : conflicts) {\n      if (info instanceof MethodCandidateInfo) {\n        final PsiMethod method = ((MethodCandidateInfo)info).getElement();\n        if (method.isVarArgs()) return; //Do not filter if there is at least one varargs method\n        if (method.getParameterList().getParameters().length == argumentsCount) {\n          parametersNumberMatch = true;\n        }\n      }\n    }\n\n    if (parametersNumberMatch) {\n      for (Iterator<CandidateInfo> iterator = conflicts.iterator(); iterator.hasNext();) {\n        CandidateInfo info = iterator.next();\n        if (info instanceof MethodCandidateInfo) {\n          final PsiMethod method = ((MethodCandidateInfo)info).getElement();\n          if (method.getParameterList().getParameters().length != argumentsCount) {\n            iterator.remove();\n          }\n        }\n      }\n    }\n  }","id":42767,"modified_method":"private void checkParametersNumber(final List<CandidateInfo> conflicts, final int argumentsCount) {\n    boolean parametersNumberMatch = false;\n    for (CandidateInfo info : conflicts) {\n      if (info instanceof MethodCandidateInfo) {\n        final PsiMethod method = ((MethodCandidateInfo)info).getElement();\n        if (method.getParameterList().getParameters().length == argumentsCount) {\n          parametersNumberMatch = true;\n        }\n      }\n    }\n\n    if (parametersNumberMatch) {\n      for (Iterator<CandidateInfo> iterator = conflicts.iterator(); iterator.hasNext();) {\n        CandidateInfo info = iterator.next();\n        if (info instanceof MethodCandidateInfo) {\n          final PsiMethod method = ((MethodCandidateInfo)info).getElement();\n          if (method.getParameterList().getParameters().length != argumentsCount) {\n            iterator.remove();\n          }\n        }\n      }\n    }\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static final PsiMetaData getMeta(final PsiElement element) {\n    ProgressManager.getInstance().checkCanceled();\n    PsiMetaData ret = null;\n    SoftReference<CachedValue<PsiMetaData>> value = element.getUserData(META_DATA_KEY);\n    if (value == null || (value != NULL && value.get() == null)) {\n      for (final MyBinding binding : ourBindings) {\n        try {\n          if (binding.myFilter.isClassAcceptable(element.getClass()) && binding.myFilter.isAcceptable(element, element.getParent())) {\n            final PsiMetaData data = binding.myDataClass.newInstance();\n            final CachedValue<PsiMetaData> cachedValue = element.getManager().getCachedValuesManager()\n              .createCachedValue(new CachedValueProvider<PsiMetaData>() {\n                public Result<PsiMetaData> compute() {\n                  data.init(element);\n                  return new Result<PsiMetaData>(data, data.getDependences());\n                }\n              }, false);\n            value = new SoftReference<CachedValue<PsiMetaData>>(cachedValue);\n            ret = cachedValue.getValue();\n            break;\n          }\n        }\n        catch (IllegalAccessException iae) {\n          value = null;\n        }\n        catch (InstantiationException ie) {\n          value = null;\n        }\n      }\n      element.putUserData(META_DATA_KEY, value != null ? value : NULL);\n    }\n    else if(value != NULL){\n      ret = value.get().getValue();\n    }\n\n    return ret;\n  }","id":42768,"modified_method":"public static PsiMetaData getMeta(final PsiElement element) {\n    ProgressManager.getInstance().checkCanceled();\n    PsiMetaData ret = null;\n    SoftReference<CachedValue<PsiMetaData>> value = element.getUserData(META_DATA_KEY);\n    if (value == null || (value != NULL && value.get() == null)) {\n      for (final MyBinding binding : ourBindings) {\n        try {\n          if (binding.myFilter.isClassAcceptable(element.getClass()) && binding.myFilter.isAcceptable(element, element.getParent())) {\n            final PsiMetaData data = binding.myDataClass.newInstance();\n            final CachedValue<PsiMetaData> cachedValue = element.getManager().getCachedValuesManager()\n              .createCachedValue(new CachedValueProvider<PsiMetaData>() {\n                public Result<PsiMetaData> compute() {\n                  data.init(element);\n                  return new Result<PsiMetaData>(data, data.getDependences());\n                }\n              }, false);\n            value = new SoftReference<CachedValue<PsiMetaData>>(cachedValue);\n            ret = cachedValue.getValue();\n            break;\n          }\n        }\n        catch (IllegalAccessException iae) {\n          value = null;\n        }\n        catch (InstantiationException ie) {\n          value = null;\n        }\n      }\n      element.putUserData(META_DATA_KEY, value != null ? value : NULL);\n    }\n    else if(value != NULL){\n      ret = value.get().getValue();\n    }\n\n    return ret;\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static final void bindDataToElement(final PsiElement element, final PsiMetaData data){\n    SoftReference<CachedValue<PsiMetaData>> value = new SoftReference<CachedValue<PsiMetaData>>(\n      element.getManager().getCachedValuesManager().createCachedValue(new CachedValueProvider<PsiMetaData>() {\n      public CachedValueProvider.Result<PsiMetaData> compute() {\n        data.init(element);\n        return new Result<PsiMetaData>(data, data.getDependences());\n      }\n    }));\n    element.putUserData(META_DATA_KEY, value);\n  }","id":42769,"modified_method":"public static void bindDataToElement(final PsiElement element, final PsiMetaData data){\n    SoftReference<CachedValue<PsiMetaData>> value = new SoftReference<CachedValue<PsiMetaData>>(\n      element.getManager().getCachedValuesManager().createCachedValue(new CachedValueProvider<PsiMetaData>() {\n      public CachedValueProvider.Result<PsiMetaData> compute() {\n        data.init(element);\n        return new Result<PsiMetaData>(data, data.getDependences());\n      }\n    }));\n    element.putUserData(META_DATA_KEY, value);\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAcceptable(Object element, PsiElement context){\n    if(myFilters.isEmpty())\n      return true;\n    for (Object myFilter : myFilters) {\n      final ElementFilter elementFilter = (ElementFilter)myFilter;\n      if (elementFilter.isAcceptable(element, context)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":42770,"modified_method":"public boolean isAcceptable(Object element, PsiElement context){\n    if(myFilters.isEmpty())\n      return true;\n    for (Object filter : myFilters) {\n      final ElementFilter elementFilter = (ElementFilter)filter;\n      if (elementFilter.isAcceptable(element, context)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"3314476891c70f6e28a00beba3f4835933188dec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected HtmlCompletionData(boolean _caseInsensitive) {\n    myCaseInsensitive = _caseInsensitive;\n    \n    if (myCaseInsensitive) {\n      // amp is not parsed in html separately\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          new TokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS),\n          new TextStartFilter(\"&\")\n        )\n      );\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new EntityRefGetter(), TailType.NONE);\n      variant.setInsertHandler(new EntityRefInsertHandler());\n\n      registerVariant(variant);\n    }\n  }","id":42771,"modified_method":"protected HtmlCompletionData(boolean _caseInsensitive) {\n    myCaseInsensitive = _caseInsensitive;\n  }","commit_id":"23a8dff6482f33c9beb7ad97cb7d7403e4a694d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlCompletionData(){\n    declareFinalScope(XmlTag.class);\n    declareFinalScope(XmlAttribute.class);\n    declareFinalScope(XmlAttributeValue.class);\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createTagCompletionFilter());\n      variant.includeScopeClass(XmlTag.class);\n      variant.addCompletionFilterOnElement(TrueFilter.INSTANCE);\n      variant.setInsertHandler(new XmlTagInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeCompletion());\n      variant.includeScopeClass(XmlAttribute.class);\n      variant.addCompletionFilterOnElement(TrueFilter.INSTANCE);\n      variant.setInsertHandler(new XmlAttributeInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeValueCompletionFilter());\n      variant.includeScopeClass(XmlAttributeValue.class);\n      variant.addCompletion(getAttributeValueGetter());\n      variant.addCompletionFilter(TrueFilter.INSTANCE, TailType.NONE);\n      variant.setInsertHandler(new XmlAttributeValueInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(new TokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS));\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new SimpleTagContentEnumerationValuesGetter(),TailType.NONE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          new LeftNeighbour(new TextFilter(\"&\")),\n          new OrFilter(\n            new TokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS),\n            new TokenTypeFilter(XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN)\n          )\n        )\n      );\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new EntityRefGetter());\n      variant.setInsertHandler(new EntityRefInsertHandler());\n      registerVariant(variant);\n    }\n  }","id":42772,"modified_method":"public XmlCompletionData(){\n    declareFinalScope(XmlTag.class);\n    declareFinalScope(XmlAttribute.class);\n    declareFinalScope(XmlAttributeValue.class);\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createTagCompletionFilter());\n      variant.includeScopeClass(XmlTag.class);\n      variant.addCompletionFilterOnElement(TrueFilter.INSTANCE);\n      variant.setInsertHandler(new XmlTagInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeCompletion());\n      variant.includeScopeClass(XmlAttribute.class);\n      variant.addCompletionFilterOnElement(TrueFilter.INSTANCE);\n      variant.setInsertHandler(new XmlAttributeInsertHandler());\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(createAttributeValueCompletionFilter());\n      variant.includeScopeClass(XmlAttributeValue.class);\n      variant.addCompletion(getAttributeValueGetter());\n      variant.addCompletionFilter(TrueFilter.INSTANCE, TailType.NONE);\n      variant.setInsertHandler(new XmlAttributeValueInsertHandler());\n      registerVariant(variant);\n    }\n\n    final ElementFilter entityCompletionFilter = createXmlEntityCompletionFilter();\n    \n    {\n      final CompletionVariant variant = new CompletionVariant(\n        new AndFilter(\n          new TokenTypeFilter(XmlTokenType.XML_DATA_CHARACTERS),\n          new NotFilter(entityCompletionFilter)\n        )\n      );\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new SimpleTagContentEnumerationValuesGetter(),TailType.NONE);\n\n      registerVariant(variant);\n    }\n\n    {\n      final CompletionVariant variant = new CompletionVariant(\n        entityCompletionFilter\n      );\n      variant.includeScopeClass(XmlToken.class, true);\n      variant.addCompletion(new EntityRefGetter());\n      variant.setInsertHandler(new EntityRefInsertHandler());\n      registerVariant(variant);\n    }\n  }","commit_id":"23a8dff6482f33c9beb7ad97cb7d7403e4a694d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      final XmlTag parentOfType = PsiTreeUtil.getParentOfType(context, XmlTag.class);\n      if (parentOfType != null) {\n        final XmlElementDescriptor descriptor = parentOfType.getDescriptor();\n        final List<String> results = new ArrayList<String>();\n\n        if (descriptor != null) {\n          final XmlNSDescriptor nsDescriptor = descriptor.getNSDescriptor();\n          final XmlFile descriptorFile = nsDescriptor != null ? nsDescriptor.getDescriptorFile():null;\n\n          // skip content of embedded dtd, its content will be inserted by word completion\n          if (descriptorFile != null && !descriptorFile.equals(parentOfType.getContainingFile())) {\n            final PsiElementProcessor processor = new PsiElementProcessor() {\n              public boolean execute(final PsiElement element) {\n                if (element instanceof XmlEntityDecl) {\n                  final XmlEntityDecl xmlEntityDecl = (XmlEntityDecl)element;\n                  if (xmlEntityDecl.isInternalReference()) results.add(xmlEntityDecl.getName());\n                }\n                return true;\n              }\n            };\n  \n            XmlUtil.processXmlElements(\n              descriptorFile,\n              processor,\n              true\n            );\n  \n            return results.toArray(new Object[results.size()]);\n          }\n        }\n      }\n      return new Object[0];\n    }","id":42773,"modified_method":"public Object[] get(final PsiElement context, CompletionContext completionContext) {\n      final XmlTag parentOfType = PsiTreeUtil.getParentOfType(context, XmlTag.class);\n      if (parentOfType != null) {\n        final XmlElementDescriptor descriptor = parentOfType.getDescriptor();\n        final List<String> results = new ArrayList<String>();\n\n        if (descriptor != null) {\n          final XmlNSDescriptor nsDescriptor = descriptor.getNSDescriptor();\n          final XmlFile descriptorFile = nsDescriptor != null ? nsDescriptor.getDescriptorFile():null;\n\n          if (descriptorFile != null) {\n            final PsiElementProcessor processor = new PsiElementProcessor() {\n              public boolean execute(final PsiElement element) {\n                if (element instanceof XmlEntityDecl) {\n                  final XmlEntityDecl xmlEntityDecl = (XmlEntityDecl)element;\n                  if (xmlEntityDecl.isInternalReference()) results.add(xmlEntityDecl.getName());\n                }\n                return true;\n              }\n            };\n  \n            XmlUtil.processXmlElements(\n              descriptorFile,\n              processor,\n              true\n            );\n  \n            return results.toArray(new Object[results.size()]);\n          }\n        }\n      }\n      return new Object[0];\n    }","commit_id":"23a8dff6482f33c9beb7ad97cb7d7403e4a694d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testENG7480() throws Exception {\n        Client client = getClient();\n\n        VoltTable vt;\n        String sql;\n        sql = \"insert into R1 Values(1, 'MA', 2, 1.1);\";\n        vt = client.callProcedure(\"@AdHoc\", sql).getResults()[0];\n\n        // constants interpreted as DECIMAL\n        sql = \"SELECT 0.1 + (1-0.1) * NUM FROM R1\";\n        vt = client.callProcedure(\"@AdHoc\", sql).getResults()[0];\n        assertTrue(vt.advanceRow());\n        assertEquals(1.9, vt.getDecimalAsBigDecimal(0).doubleValue());\n\n        sql = \"SELECT 0.1 + NUM * (1-0.1) FROM R1\";\n        vt = client.callProcedure(\"@AdHoc\", sql).getResults()[0];\n        assertTrue(vt.advanceRow());\n        assertEquals(1.9, vt.getDecimalAsBigDecimal(0).doubleValue());\n\n        // operation between float and decimal\n        sql = \"SELECT 0.1 + (1-0.1) * ratio FROM R1\";\n        vt = client.callProcedure(\"@AdHoc\", sql).getResults()[0];\n        assertTrue(vt.advanceRow());\n        assertEquals(2.08, vt.getDouble(0));\n\n        sql = \"SELECT 0.1 + ratio * (1-0.1) FROM R1\";\n        vt = client.callProcedure(\"@AdHoc\", sql).getResults()[0];\n        assertTrue(vt.advanceRow());\n        assertEquals(2.08, vt.getDouble(0));\n    }","id":42774,"modified_method":"public void testENG7480() throws Exception {\n        Client client = getClient();\n\n        String sql;\n        sql = \"insert into R1 Values(1, 'MA', 2, 2.2);\";\n        client.callProcedure(\"@AdHoc\", sql);\n        // query constants interpreted as DECIMAL\n\n        //\n        // operation between decimal and integer\n        //\n        sql = \"SELECT 0.1 + (1-0.1) + NUM FROM R1\";\n        runQueryTestUtil(client, sql, 3.0);\n\n        sql = \"SELECT 0.1 + (1-0.1) - NUM FROM R1\";\n        runQueryTestUtil(client, sql, -1.0);\n\n        sql = \"SELECT 0.1 + (1-0.1) / NUM FROM R1\";\n        runQueryTestUtil(client, sql, 0.55);\n\n        sql = \"SELECT 0.1 + (1-0.1) * NUM FROM R1\";\n        runQueryTestUtil(client, sql, 1.9);\n\n        // reverse order\n        sql = \"SELECT 0.1 + NUM + (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, 3.0);\n\n        sql = \"SELECT 0.1 + NUM - (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, 1.2);\n\n        sql = \"SELECT 0.1 + NUM / (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, 2.322222222222);\n\n        sql = \"SELECT 0.1 + NUM * (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, 1.9);\n\n        //\n        // operation between float and decimal\n        //\n        sql = \"SELECT 0.1 + (1-0.1) + ratio FROM R1\";\n        runQueryTestUtil(client, sql, true, 3.2);\n\n        sql = \"SELECT 0.1 + (1-0.1) - ratio FROM R1\";\n        runQueryTestUtil(client, sql, true, -1.2);\n\n        sql = \"SELECT 0.1 + (1-0.1) / ratio FROM R1\";\n        runQueryTestUtil(client, sql, true, 0.509090909091);\n\n        sql = \"SELECT 0.1 + (1-0.1) * ratio FROM R1\";\n        runQueryTestUtil(client, sql, true, 2.08);\n\n        // reverse order\n        sql = \"SELECT 0.1 + ratio + (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, true, 3.2);\n\n        sql = \"SELECT 0.1 + ratio - (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, true, 1.4);\n\n        sql = \"SELECT 0.1 + ratio / (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, true, 2.544444444444);\n\n        sql = \"SELECT 0.1 + ratio * (1-0.1) FROM R1\";\n        runQueryTestUtil(client, sql, true, 2.08);\n    }","commit_id":"824a922fa45ea0eccfbb21fd71c3f8f931f567cf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testExplicitErrorUDF() throws Exception\n    {\n        System.out.println(\"STARTING testExplicitErrorUDF\");\n        Client client = getClient();\n        ProcedureCallback callback = new ProcedureCallback() {\n            @Override\n            public void clientCallback(ClientResponse clientResponse)\n                    throws Exception {\n                if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                    throw new RuntimeException(\"Failed with response: \" + clientResponse.getStatusString());\n                }\n            }\n        };\n        /*\n        CREATE TABLE P1 (\n                ID INTEGER DEFAULT '0' NOT NULL,\n                DESC VARCHAR(300),\n                NUM INTEGER,\n                RATIO FLOAT,\n                PRIMARY KEY (ID)\n                );\n        */\n        for(int id=7; id < 15; id++) {\n            client.callProcedure(callback, \"P1.insert\", - id, \"X\"+String.valueOf(id), 10, 1.1);\n            client.drain();\n        }\n        ClientResponse cr = null;\n\n        // Exercise basic syntax without runtime invocation.\n        cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123) from P1 where ID = 0\");\n        assertEquals(cr.getStatus(), ClientResponse.SUCCESS);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR('abc') from P1 where ID = 0\");\n        assertEquals(cr.getStatus(), ClientResponse.SUCCESS);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123, 'abc') from P1 where ID = 0\");\n        assertEquals(cr.getStatus(), ClientResponse.SUCCESS);\n\n        boolean caught = false;\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123, 'abc') from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"abc\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123.5) from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"Specific error code\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR('abc') from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"abc\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            // This wants to be a statement compile-time error.\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123, 123) from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.matches(\".*SQL ERROR\\n.*VARCHAR.*\"));\n            caught = true;\n        }\n        assertTrue(caught);\n\n    }","id":42775,"modified_method":"public void testExplicitErrorUDF() throws Exception\n    {\n        System.out.println(\"STARTING testExplicitErrorUDF\");\n        Client client = getClient();\n        ProcedureCallback callback = new ProcedureCallback() {\n            @Override\n            public void clientCallback(ClientResponse clientResponse)\n                    throws Exception {\n                if (clientResponse.getStatus() != ClientResponse.SUCCESS) {\n                    throw new RuntimeException(\"Failed with response: \" + clientResponse.getStatusString());\n                }\n            }\n        };\n        /*\n        CREATE TABLE P1 (\n                ID INTEGER DEFAULT '0' NOT NULL,\n                DESC VARCHAR(300),\n                NUM INTEGER,\n                RATIO FLOAT,\n                PRIMARY KEY (ID)\n                );\n        */\n        for(int id=7; id < 15; id++) {\n            client.callProcedure(callback, \"P1.insert\", - id, \"X\"+String.valueOf(id), 10, 1.1);\n            client.drain();\n        }\n        ClientResponse cr = null;\n\n        // Exercise basic syntax without runtime invocation.\n        cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123) from P1 where ID = 0\");\n        assertEquals(cr.getStatus(), ClientResponse.SUCCESS);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR('abc') from P1 where ID = 0\");\n        assertEquals(cr.getStatus(), ClientResponse.SUCCESS);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123, 'abc') from P1 where ID = 0\");\n        assertEquals(cr.getStatus(), ClientResponse.SUCCESS);\n\n        boolean caught = false;\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123, 'abc') from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"abc\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123.5) from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.contains(\"Type DECIMAL can't be cast as BIGINT\"));\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR('abc') from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"abc\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            // This wants to be a statement compile-time error.\n            cr = client.callProcedure(\"@AdHoc\", \"select SQL_ERROR(123, 123) from P1\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.matches(\".*SQL ERROR\\n.*VARCHAR.*\"));\n            caught = true;\n        }\n        assertTrue(caught);\n\n    }","commit_id":"824a922fa45ea0eccfbb21fd71c3f8f931f567cf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDetermineImplicitCastingOrder()\n    {\n        // Check that STRING + STRING -> STRING\n        assertEquals(VoltTypeUtil.determineImplicitCasting(VoltType.STRING,\n                                                           VoltType.STRING),\n                     VoltType.STRING);\n\n        // Check the easy non-coerced order\n        VoltType[] winning_types = { VoltType.FLOAT,\n                                     VoltType.TIMESTAMP,\n                                     VoltType.BIGINT };\n        VoltType[] losing_types = { VoltType.FLOAT,\n                                    VoltType.TIMESTAMP,\n                                    VoltType.BIGINT,\n                                    VoltType.INTEGER,\n                                    VoltType.SMALLINT,\n                                    VoltType.TINYINT };\n        for (int i = 0; i < winning_types.length; ++i)\n        {\n            for (int j = i; j < losing_types.length; ++j)\n            {\n                assertEquals(winning_types[i],\n                             VoltTypeUtil.determineImplicitCasting(winning_types[i],\n                                                                   losing_types[j]));\n            }\n        }\n\n        // Finally, check the promotion of INT types if none of the winning types\n        // was present\n        VoltType[] promoted_types = { VoltType.INTEGER,\n                                      VoltType.SMALLINT,\n                                      VoltType.TINYINT };\n        for (int i = 0; i < promoted_types.length; ++i)\n        {\n            for (int j = i; j < promoted_types.length; ++j)\n            {\n                assertEquals(VoltType.BIGINT,\n                             VoltTypeUtil.determineImplicitCasting(promoted_types[i],\n                                                                   promoted_types[j]));\n            }\n        }\n    }","id":42776,"modified_method":"public void testDetermineImplicitCastingOrder()\n    {\n        // Check that STRING + STRING -> STRING\n        assertEquals(VoltType.STRING,\n                VoltTypeUtil.determineImplicitCasting(VoltType.STRING,VoltType.STRING));\n\n        // Check the easy non-coerced order\n        VoltType[] winning_types = { VoltType.FLOAT,\n                                     VoltType.BIGINT };\n        VoltType[] losing_types = { VoltType.FLOAT,\n                                    VoltType.BIGINT,\n                                    VoltType.INTEGER,\n                                    VoltType.SMALLINT,\n                                    VoltType.TINYINT };\n        for (int i = 0; i < winning_types.length; ++i)\n        {\n            for (int j = i; j < losing_types.length; ++j)\n            {\n                assertEquals(winning_types[i],\n                             VoltTypeUtil.determineImplicitCasting(winning_types[i],losing_types[j]));\n            }\n        }\n\n        // Finally, check the promotion of INT types if none of the winning types\n        // was present\n        VoltType[] promoted_types = { VoltType.INTEGER,\n                                      VoltType.SMALLINT,\n                                      VoltType.TINYINT };\n        for (int i = 0; i < promoted_types.length; ++i)\n        {\n            for (int j = i; j < promoted_types.length; ++j)\n            {\n                assertEquals(VoltType.BIGINT,\n                             VoltTypeUtil.determineImplicitCasting(promoted_types[i],promoted_types[j]));\n            }\n        }\n\n        assertEquals(VoltType.TIMESTAMP, VoltTypeUtil.determineImplicitCasting(VoltType.TIMESTAMP,VoltType.TIMESTAMP));\n\n        // check the invalid timestamp type operation\n        for (int i = 0; i < losing_types.length; ++i) {\n            validateVoltTypeCastingException(VoltType.TIMESTAMP, losing_types[i]);\n            validateVoltTypeCastingException(losing_types[i], VoltType.TIMESTAMP);\n        }\n    }","commit_id":"824a922fa45ea0eccfbb21fd71c3f8f931f567cf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDetermineImplicitCastingNullWins()\n    {\n        VoltType[] types = { VoltType.BIGINT,\n                             VoltType.DECIMAL,\n                             VoltType.FLOAT,\n                             VoltType.INTEGER,\n                             VoltType.SMALLINT,\n                             VoltType.STRING,\n                             VoltType.TIMESTAMP,\n                             VoltType.TINYINT };\n\n        for (VoltType right : types)\n        {\n            assertEquals(VoltTypeUtil.determineImplicitCasting(VoltType.NULL,\n                                                               right),\n                         VoltType.NULL);\n        }\n    }","id":42777,"modified_method":"public void testDetermineImplicitCastingNullWins()\n    {\n        VoltType[] types = { VoltType.BIGINT,\n                             VoltType.DECIMAL,\n                             VoltType.FLOAT,\n                             VoltType.INTEGER,\n                             VoltType.SMALLINT,\n                             VoltType.STRING,\n                             VoltType.TIMESTAMP,\n                             VoltType.TINYINT };\n\n        for (VoltType right : types)\n        {\n            assertEquals(VoltType.NULL,\n                    VoltTypeUtil.determineImplicitCasting(VoltType.NULL,right));\n        }\n    }","commit_id":"824a922fa45ea0eccfbb21fd71c3f8f931f567cf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDetermineImplicitCastingExceptions()\n    {\n        // either INVALID results in VoltTypeException\n        boolean caught = false;\n        try\n        {\n            VoltTypeUtil.determineImplicitCasting(VoltType.INVALID,\n                                                  VoltType.INTEGER);\n        }\n        catch (VoltTypeException e)\n        {\n            caught = true;\n        }\n        assertTrue(\"VoltType.INVALID failed to throw exception\", caught);\n\n        caught = false;\n        try\n        {\n            VoltTypeUtil.determineImplicitCasting(VoltType.INTEGER,\n                                                  VoltType.INVALID);\n        }\n        catch (VoltTypeException e)\n        {\n            caught = true;\n        }\n        assertTrue(\"VoltType.INVALID failed to throw exception\", caught);\n\n        // String and non-string throw VoltTypeException\n        caught = false;\n        try\n        {\n            VoltTypeUtil.determineImplicitCasting(VoltType.STRING,\n                                                  VoltType.INTEGER);\n        }\n        catch (VoltTypeException e)\n        {\n            caught = true;\n        }\n        assertTrue(\"VoltType.STRING and non-string failed to throw exception\",\n                   caught);\n    }","id":42778,"modified_method":"public void testDetermineImplicitCastingExceptions()\n    {\n        // either INVALID results in VoltTypeException\n        validateVoltTypeCastingException(VoltType.INVALID, VoltType.INTEGER);\n        validateVoltTypeCastingException(VoltType.INTEGER, VoltType.INVALID);\n\n        // String and non-string throw VoltTypeException\n        validateVoltTypeCastingException(VoltType.STRING, VoltType.INTEGER);\n        validateVoltTypeCastingException(VoltType.INTEGER, VoltType.STRING);\n    }","commit_id":"824a922fa45ea0eccfbb21fd71c3f8f931f567cf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDecimalMixedTypes()\n    {\n        // only exact types can cast to decimal.\n        boolean caught = false;\n        try\n        {\n            VoltTypeUtil.determineImplicitCasting(VoltType.DECIMAL,\n                                                  VoltType.FLOAT);\n        }\n        catch (VoltTypeException e)\n        {\n            caught = true;\n        }\n\n        assertTrue(\"VoltType.DECIMAL and VoltType.FLOAT threw\" +\n                   \"exception\", caught);\n\n        // Check that DECIMAL + DECIMAL -> DECIMAL\n        assertEquals(VoltTypeUtil.determineImplicitCasting(VoltType.DECIMAL,\n                                                           VoltType.DECIMAL),\n                                                           VoltType.DECIMAL);\n\n        // D + SMALLINT = D\n        assertEquals(VoltTypeUtil.determineImplicitCasting(VoltType.DECIMAL,\n                                                           VoltType.SMALLINT),\n                                                           VoltType.DECIMAL);\n}","id":42779,"modified_method":"public void testDecimalMixedTypes()\n    {\n        validateVoltTypeCastingException(VoltType.DECIMAL, VoltType.STRING);\n        validateVoltTypeCastingException(VoltType.STRING, VoltType.DECIMAL);\n        validateVoltTypeCastingException(VoltType.DECIMAL, VoltType.TIMESTAMP);\n\n        // Check that DECIMAL + FLOAT -> FLOAT\n        assertEquals(VoltType.FLOAT,\n                VoltTypeUtil.determineImplicitCasting(VoltType.DECIMAL,VoltType.FLOAT));\n\n        // Check that FLOAT + DECIMAL -> FLOAT\n        assertEquals(VoltType.FLOAT,\n                VoltTypeUtil.determineImplicitCasting(VoltType.FLOAT,VoltType.DECIMAL));\n\n        // Check that DECIMAL + DECIMAL -> DECIMAL\n        assertEquals(VoltType.DECIMAL,\n                VoltTypeUtil.determineImplicitCasting(VoltType.DECIMAL,VoltType.DECIMAL));\n\n        // D + SMALLINT = D\n        assertEquals(VoltType.DECIMAL,\n                VoltTypeUtil.determineImplicitCasting(VoltType.DECIMAL,VoltType.SMALLINT));\n    }","commit_id":"824a922fa45ea0eccfbb21fd71c3f8f931f567cf","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public String getShortForm() {\n    return shortForm;\n  }","id":42780,"modified_method":"/**\n   * Get this language's two character code, e.g. <code>en<\/code> for English.\n   */\n  public String getShortForm() {\n    return shortForm;\n  }","commit_id":"5e66cdd60e7fb2d6bd0d812959c72d5b8fcef921","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public Tagger getTagger() {\n    return tagger;\n  }","id":42781,"modified_method":"/**\n   * Get this language's part-of-speech tagger implemenation.\n   */\n  public Tagger getTagger() {\n    return tagger;\n  }","commit_id":"5e66cdd60e7fb2d6bd0d812959c72d5b8fcef921","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void createAndShowGUI() {\n    JFrame frame = new JFrame(\"JLanguageTool Demo\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    textArea = new JTextArea(\"This is a example input to to show you how JLanguageTool works. \" +\n            \"Note, howeva, that it does not include a spell checka.\");\n    textArea.setLineWrap(true);\n    textArea.setWrapStyleWord(true);\n    resultArea = new JTextPane();\n    resultArea.setContentType(\"text/html\");\n    resultArea.setText(\"<html>Results will appear here<\/html>\");\n    //resultArea.setLineWrap(true);\n    //resultArea.setWrapStyleWord(true);\n    //resultArea.setEditable(false);\n    JLabel label = new JLabel(\"Please type or paste text to check in the top area\");\n    JButton button = new JButton(\"Check text\");\n    button.setMnemonic('c'); \n    button.addActionListener(this);\n\n    Container contentPane = frame.getContentPane();\n    GridBagLayout gridLayout = new GridBagLayout();\n    contentPane.setLayout(gridLayout);\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.fill = GridBagConstraints.BOTH;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.gridx = 0;\n    cons.gridy = 0;\n    contentPane.add(new JScrollPane(textArea), cons);\n    cons.gridy = 1;\n    cons.weighty = 5.0f;\n    contentPane.add(new JScrollPane(resultArea), cons);\n\n    cons.fill = GridBagConstraints.NONE;\n    cons.gridx = 0;\n    cons.gridy = 2;\n    cons.weighty = 0.0f;\n    cons.insets = new Insets(3,3,3,3);\n    //cons.fill = GridBagConstraints.NONE;\n    contentPane.add(label, cons);\n    cons.gridy = 3;\n    contentPane.add(button, cons);\n    \n    //frame.getContentPane().add(button);\n    frame.pack();\n    frame.setSize(600, 600);\n    frame.setVisible(true);\n  }","id":42782,"modified_method":"private void createAndShowGUI() {\n    JFrame frame = new JFrame(\"JLanguageTool Demo\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    textArea = new JTextArea(\"This is a example input to to show you how JLanguageTool works. \" +\n            \"Note, howeva, that it does not include a spell checka.\");\n    textArea.setLineWrap(true);\n    textArea.setWrapStyleWord(true);\n    resultArea = new JTextPane();\n    resultArea.setContentType(\"text/html\");\n    resultArea.setText(\"<html>Results will appear here<\/html>\");\n    //resultArea.setLineWrap(true);\n    //resultArea.setWrapStyleWord(true);\n    //resultArea.setEditable(false);\n    JLabel label = new JLabel(\"Please type or paste text to check in the top area\");\n    JButton button = new JButton(\"Check text\");\n    button.setMnemonic('c'); \n    button.addActionListener(this);\n    \n    JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridBagLayout());\n    GridBagConstraints buttonCons = new GridBagConstraints();\n    buttonCons.gridx = 0;\n    buttonCons.gridy = 0;\n    panel2.add(button, buttonCons);\n    buttonCons.gridx = 1;\n    buttonCons.gridy = 0;\n    panel2.add(new JLabel(\" in: \"), buttonCons);\n    buttonCons.gridx = 2;\n    buttonCons.gridy = 0;\n    langBox = new JComboBox(Language.LANGUAGES);\n    panel2.add(langBox, buttonCons);\n\n    Container contentPane = frame.getContentPane();\n    GridBagLayout gridLayout = new GridBagLayout();\n    contentPane.setLayout(gridLayout);\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.fill = GridBagConstraints.BOTH;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.gridx = 0;\n    cons.gridy = 0;\n    contentPane.add(new JScrollPane(textArea), cons);\n    cons.gridy = 1;\n    cons.weighty = 5.0f;\n    contentPane.add(new JScrollPane(resultArea), cons);\n\n    cons.fill = GridBagConstraints.NONE;\n    cons.gridx = 0;\n    cons.gridy = 2;\n    cons.weighty = 0.0f;\n    cons.insets = new Insets(3,3,3,3);\n    //cons.fill = GridBagConstraints.NONE;\n    contentPane.add(label, cons);\n    cons.gridy = 3;\n    contentPane.add(panel2, cons);\n    \n    //frame.getContentPane().add(button);\n    frame.pack();\n    frame.setSize(600, 600);\n    frame.setVisible(true);\n  }","commit_id":"5e66cdd60e7fb2d6bd0d812959c72d5b8fcef921","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void actionPerformed(ActionEvent e) {\n    if (e == null) ;        // avoid compiler warning\n    if (textArea.getText().trim().equals(\"\")) {\n      textArea.setText(\"Please insert text to check here\");\n    } else {\n      StringBuffer sb = new StringBuffer();\n      resultArea.setText(\"<html>Starting check...<br>\\n<\/html>\");\n      resultArea.repaint(); // FIXME: why doesn't this work?\n      //resultArea.setCursor(new Cursor(Cursor.WAIT_CURSOR)); \n      sb.append(\"Starting check...<br>\\n\");\n      try {\n        checkText(textArea.getText(), Language.ENGLISH, sb);\n      } catch (IOException e1) {\n        sb.append(e1.toString());\n        e1.printStackTrace();\n      } catch (ParserConfigurationException e1) {\n        sb.append(e1.toString());\n        e1.printStackTrace();\n      } catch (SAXException e1) {\n        sb.append(e1.toString());\n        e1.printStackTrace();\n      }\n      sb.append(\"Check done.<br>\\n\");\n      resultArea.setText(sb.toString());\n      resultArea.setCaretPosition(0);\n    }\n  }","id":42783,"modified_method":"public void actionPerformed(ActionEvent e) {\n    if (e == null) ;        // avoid compiler warning\n    if (textArea.getText().trim().equals(\"\")) {\n      textArea.setText(\"Please insert text to check here\");\n    } else {\n      StringBuffer sb = new StringBuffer();\n      String langName = langBox.getSelectedItem().toString();\n      resultArea.setText(\"Starting check...<br>\\n\");\n      resultArea.repaint(); // FIXME: why doesn't this work?\n      //TODO: resultArea.setCursor(new Cursor(Cursor.WAIT_CURSOR)); \n      sb.append(\"Starting check in \" +langName+ \"...<br>\\n\");\n      int matches = 0;\n      try {\n        Language language = Language.getLanguageforName(langName);\n        matches = checkText(textArea.getText(), language, sb);\n      } catch (IOException e1) {\n        sb.append(e1.toString());\n        e1.printStackTrace();\n      } catch (ParserConfigurationException e1) {\n        sb.append(e1.toString());\n        e1.printStackTrace();\n      } catch (SAXException e1) {\n        sb.append(e1.toString());\n        e1.printStackTrace();\n      }\n      sb.append(\"Check done. \" +matches+ \" potential problems found<br>\\n\");\n      resultArea.setText(sb.toString());\n      resultArea.setCaretPosition(0);\n    }\n  }","commit_id":"5e66cdd60e7fb2d6bd0d812959c72d5b8fcef921","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void checkText(String text, Language language, StringBuffer sb) throws IOException,\n      ParserConfigurationException, SAXException {\n    long startTime = System.currentTimeMillis();\n    JLanguageTool lt = new JLanguageTool(language);\n    File defaultPatternFile = new File(de.danielnaber.languagetool.Main.RULES_DIR + File.separator\n        + language.getShortForm() + File.separator + de.danielnaber.languagetool.Main.PATTERN_FILE);\n    List patternRules = new ArrayList();\n    if (defaultPatternFile.exists()) {\n      patternRules = lt.loadPatternRules(defaultPatternFile.getAbsolutePath());\n    } else {\n      sb.append(\"Pattern file \" + defaultPatternFile.getAbsolutePath() + \" not found<br>\\n\");\n    }\n    for (Iterator iter = patternRules.iterator(); iter.hasNext();) {\n      Rule rule = (Rule) iter.next();\n      lt.addRule(rule);\n    }\n    List ruleMatches = lt.check(text);\n    long startTimeMatching = System.currentTimeMillis();\n    for (Iterator iter = ruleMatches.iterator(); iter.hasNext();) {\n      RuleMatch match = (RuleMatch) iter.next();\n      sb.append(\"<br>\\n<b>Line \" + (match.getLine() + 1) + \", column \" + match.getColumn() + \"<\/b><br>\\n\");\n      String msg = match.getMessage();\n      msg = msg.replaceAll(\"<suggestion>\", \"<b>\");\n      msg = msg.replaceAll(\"<\/suggestion>\", \"<\/b>\");\n      msg = msg.replaceAll(\"<old>\", \"<b>\");\n      msg = msg.replaceAll(\"<\/old>\", \"<\/b>\");\n      sb.append(\"<b>Message:<\/b> \" + msg + \"<br>\\n\");\n      sb.append(\"<b>Context:<\/b> \" + getContext(match.getFromPos(), match.getToPos(), text));\n      if (iter.hasNext())\n        sb.append(\"<br>\\n\");\n    }\n    long endTime = System.currentTimeMillis();\n    sb.append(\"<br>\\n<br>\\nTime: \" + (endTime - startTime) + \"ms (including \"\n        + (endTime - startTimeMatching) + \"ms for rule matching)<br>\\n\");\n  }","id":42784,"modified_method":"private int checkText(String text, Language language, StringBuffer sb) throws IOException,\n      ParserConfigurationException, SAXException {\n    long startTime = System.currentTimeMillis();\n    JLanguageTool lt = new JLanguageTool(language);\n    File defaultPatternFile = new File(de.danielnaber.languagetool.Main.RULES_DIR + File.separator\n        + language.getShortForm() + File.separator + de.danielnaber.languagetool.Main.PATTERN_FILE);\n    List patternRules = new ArrayList();\n    if (defaultPatternFile.exists()) {\n      patternRules = lt.loadPatternRules(defaultPatternFile.getAbsolutePath());\n    } else {\n      sb.append(\"Pattern file \" + defaultPatternFile.getAbsolutePath() + \" not found<br>\\n\");\n    }\n    for (Iterator iter = patternRules.iterator(); iter.hasNext();) {\n      Rule rule = (Rule) iter.next();\n      lt.addRule(rule);\n    }\n    List ruleMatches = lt.check(text);\n    long startTimeMatching = System.currentTimeMillis();\n    for (Iterator iter = ruleMatches.iterator(); iter.hasNext();) {\n      RuleMatch match = (RuleMatch) iter.next();\n      sb.append(\"<br>\\n<b>Line \" + (match.getLine() + 1) + \", column \" + match.getColumn() + \"<\/b><br>\\n\");\n      String msg = match.getMessage();\n      msg = msg.replaceAll(\"<suggestion>\", \"<b>\");\n      msg = msg.replaceAll(\"<\/suggestion>\", \"<\/b>\");\n      msg = msg.replaceAll(\"<old>\", \"<b>\");\n      msg = msg.replaceAll(\"<\/old>\", \"<\/b>\");\n      sb.append(\"<b>Message:<\/b> \" + msg + \"<br>\\n\");\n      sb.append(\"<b>Context:<\/b> \" + getContext(match.getFromPos(), match.getToPos(), text));\n      sb.append(\"<br>\\n\");\n    }\n    long endTime = System.currentTimeMillis();\n    sb.append(\"<br>\\nTime: \" + (endTime - startTime) + \"ms (including \"\n        + (endTime - startTimeMatching) + \"ms for rule matching)<br>\\n\");\n    return ruleMatches.size();\n  }","commit_id":"5e66cdd60e7fb2d6bd0d812959c72d5b8fcef921","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void endElement(String namespaceURI, String sName, String qName) throws SAXException {\n    if (namespaceURI == null) namespaceURI = null;      // avoid compiler warning\n    if (sName == null) sName = null;      // avoid compiler warning\n    Language language;\n    if (qName.equals(\"rule\")) {\n      if (Language.LANGUAGES.containsKey(languageStr)) {\n        language = (Language)Language.LANGUAGES.get(languageStr);\n      } else {\n        throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n      }\n      PatternRule rule = new PatternRule(id, language, pattern, description);\n      rule.setCorrectExample(correctExample.toString());\n      rule.setIncorrectExample(incorrectExample.toString());\n      rule.setCaseSensitive(caseSensitive);\n      rules.add(rule);\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = false;\n    } else if (qName.equals(\"example\")) {\n      inCorrectExample = false;\n      inIncorrectExample = false;\n    }\n  }","id":42785,"modified_method":"public void endElement(String namespaceURI, String sName, String qName) throws SAXException {\n    if (namespaceURI == null) namespaceURI = null;      // avoid compiler warning\n    if (sName == null) sName = null;      // avoid compiler warning\n    Language language = null;\n    if (qName.equals(\"rule\")) {\n      language = Language.getLanguageforShortName(languageStr);\n      if (language == null) {\n        throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n      }\n      PatternRule rule = new PatternRule(id, language, pattern, description);\n      rule.setCorrectExample(correctExample.toString());\n      rule.setIncorrectExample(incorrectExample.toString());\n      rule.setCaseSensitive(caseSensitive);\n      rules.add(rule);\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = false;\n    } else if (qName.equals(\"example\")) {\n      inCorrectExample = false;\n      inIncorrectExample = false;\n    }\n  }","commit_id":"5e66cdd60e7fb2d6bd0d812959c72d5b8fcef921","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void run(final File file) throws IOException {\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      for (int i = 0; i < files.length; i++) {\n        run(new File(file, files[i].getName()));\n      }\n    } else {\n      System.out.println(\"Checking \" + file.getAbsolutePath());\n      String text = StringTools.readFile(file.getAbsolutePath());\n      text = text.replaceAll(\"(?s)<header.*?>.*?<\/header>\", \"\");\n      text = text.replaceAll(\"<w.*?>\", \"\");\n      text = text.replaceAll(\"<c.*?>\", \"\");\n      text = text.replaceAll(\"<.*?>\", \"\");\n      text = text.replaceAll(\" +\", \" \");\n      text = text.replaceAll(\"&bquo|&equo\", \"\\\"\");\n      text = text.replaceAll(\"&mdash;?\", \"--\");\n      text = text.replaceAll(\"&amp;?\", \"&\");\n      //System.out.println(text);\n      Tools.checkText(text, prg.getJLanguageTool());\n    }\n  }","id":42786,"modified_method":"private void run(final File file) throws IOException {\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      for (int i = 0; i < files.length; i++) {\n        run(new File(file, files[i].getName()));\n      }\n    } else {\n      System.out.println(\"Checking \" + file.getAbsolutePath());\n      String text = StringTools.readFile(file.getAbsolutePath());\n      text = textFilter.filter(text);\n      //System.out.println(text);\n      Tools.checkText(text, prg.getJLanguageTool());\n    }\n  }","commit_id":"8338a98d38b36c755061eda7a186b182e40656ec","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n    if (qName.equals(\"text\")) {\n      inText = false;\n      //System.err.println(text.length() + \" \" + text.substring(0, Math.min(50, text.length())));\n      String textToCheck = cleanup(text.toString());\n      if (!textToCheck.contains(\"#REDIRECT\")) {\n        //System.err.println(\"#########################\");\n        //System.err.println(textToCheck);\n        try {\n          articleCount++;\n          if (maxArticles > 0 && articleCount >= maxArticles) {\n            System.out.printf(\"Maximim number of articles reached. Found %d matches in %d articles\\n\",\n                ruleMatches, articleCount);\n            System.exit(0);\n          }\n          System.out.println(\"checking article \" + articleCount);\n          ruleMatches += Tools.checkText(textToCheck, lt);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      text = new StringBuilder();\n    }\n  }","id":42787,"modified_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n    if (qName.equals(\"text\")) {\n      inText = false;\n      //System.err.println(text.length() + \" \" + text.substring(0, Math.min(50, text.length())));\n      String textToCheck = textFilter.filter(text.toString());\n      if (!textToCheck.contains(\"#REDIRECT\")) {\n        //System.err.println(\"#########################\");\n        //System.err.println(textToCheck);\n        try {\n          articleCount++;\n          if (maxArticles > 0 && articleCount >= maxArticles) {\n            System.out.printf(\"Maximim number of articles reached. Found %d matches in %d articles\\n\",\n                ruleMatches, articleCount);\n            System.exit(0);\n          }\n          System.out.println(\"checking article \" + articleCount);\n          ruleMatches += Tools.checkText(textToCheck, lt);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      text = new StringBuilder();\n    }\n  }","commit_id":"8338a98d38b36c755061eda7a186b182e40656ec","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void run(final File file) throws IOException {\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      for (int i = 0; i < files.length; i++) {\n        run(new File(file, files[i].getName()));\n      }\n    } else {\n      System.out.println(\"Checking \" + file.getAbsolutePath());\n      String text = StringTools.readFile(file.getAbsolutePath());\n      text = textFilter.filter(text);\n      //System.out.println(text);\n      Tools.checkText(text, langTool);\n    }\n  }","id":42788,"modified_method":"private void run(final File file) throws IOException {\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      for (int i = 0; i < files.length; i++) {\n        run(new File(file, files[i].getName()));\n      }\n    } else {\n      System.out.println(\"Checking \" + file.getAbsolutePath());\n      String text = StringTools.readFile(file.getAbsolutePath());\n      text = textFilter.filter(text);\n      if (CHECK_BY_SENTENCE) {\n        SentenceTokenizer st = new SentenceTokenizer();\n        List<String> sentences = st.tokenize(text);\n        for (String sentence : sentences) {\n          Tools.checkText(sentence, langTool, false, 1000);\n        }\n      } else {\n        Tools.checkText(text, langTool);\n      }\n    }\n  }","commit_id":"86d575610a0b2b9be7c8489df6332841ba0edece","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String toString() {\n    return token + \"/\" + posTag;\n  }","id":42789,"modified_method":"public String toString() {\n    if (lemma != null) {\n      return lemma + \"/\" + posTag;\n    } else {\n      return token + \"/\" + posTag;\n    }\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * The main check method. Tokenizes the text into sentences and matches these\n   * sentences against all currently active rules.\n   * \n   * @param text the text to check\n   * @return a List of {@link RuleMatch} objects\n   * @throws IOException \n   */\n  public List<RuleMatch> check(final String text) throws IOException {\n    sentenceCount = 0;\n    final List<String> sentences = sentenceTokenizer.tokenize(text);\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    final List<Rule> allRules = getAllRules();           \n    printIfVerbose(allRules.size() + \" rules activated for language \" + language);\n    int tokenCount = 0;\n    int lineCount = 0;\n    int columnCount = 0;\n    unknownWords = new HashSet<String>();\n    for (final String sentence : sentences) {\n      sentenceCount++;\n      AnalyzedSentence analyzedText = getAnalyzedSentence(sentence);\n      rememberUnknownWords(analyzedText);\n      \n      if (sentenceCount == sentences.size()) {\n        final AnalyzedTokenReadings[] anTokens = analyzedText.getTokens();\n        final AnalyzedToken paragraphEnd =\n          new AnalyzedToken(anTokens[anTokens.length - 1].getToken(),\n              PARAGRAPH_END_TAGNAME,\n              anTokens[anTokens.length - 1].getAnalyzedToken(0).getLemma(),\n              anTokens[anTokens.length - 1].getAnalyzedToken(0).getStartPos());\n        anTokens[anTokens.length - 1].addReading(paragraphEnd);\n        analyzedText = new AnalyzedSentence(anTokens); \n      }\n      \n      final List<RuleMatch> sentenceMatches = new ArrayList<RuleMatch>();\n      printIfVerbose(analyzedText.toString());\n      for (final Rule rule : allRules) {\n        if (disabledRules.contains(rule.getId())\n            || (rule.isDefaultOff() && !enabledRules.contains(rule.getId()))) {\n          continue;\n        }                \n        \n        if (disabledCategories.contains(rule.getCategory().getName())) {\n          continue;\n        }\n        \n        final RuleMatch[] thisMatches = rule.match(analyzedText);\n        for (final RuleMatch element1 : thisMatches) {\n          // change positions so they are relative to the complete text,\n          // not just to the sentence:\n          final RuleMatch thisMatch = new RuleMatch(element1.getRule(),\n              element1.getFromPos() + tokenCount,\n              element1.getToPos() + tokenCount,\n              element1.getMessage());\n          thisMatch.setSuggestedReplacements(element1.getSuggestedReplacements());\n          final String sentencePartToError = sentence.substring(0, element1.getFromPos());\n          final String sentencePartToEndOfError = sentence.substring(0, element1.getToPos());          \n          final int lastLineBreakPos = sentencePartToError.lastIndexOf('\\n');\n          int column = -1;\n          int endColumn = -1;\n          if (lastLineBreakPos == -1) {\n            column = sentencePartToError.length() + columnCount;\n          } else {\n            column = sentencePartToError.length() - lastLineBreakPos - 1;\n          }\n          final int lastLineBreakPosInError = sentencePartToEndOfError.lastIndexOf('\\n');\n          if (lastLineBreakPosInError == -1) {\n            endColumn = sentencePartToEndOfError.length() + columnCount + 1;\n          } else {\n            endColumn = sentencePartToEndOfError.length() - lastLineBreakPos;\n          }\n          final int lineBreaksToError = countLineBreaks(sentencePartToError);\n          final int lineBreaksToEndOfError = countLineBreaks(sentencePartToEndOfError);\n          thisMatch.setLine(lineCount + lineBreaksToError);\n          thisMatch.setEndLine(lineCount + lineBreaksToEndOfError);\n          thisMatch.setColumn(column);\n          thisMatch.setEndColumn(endColumn);\n          thisMatch.setOffset(element1.getFromPos() + tokenCount);\n          sentenceMatches.add(thisMatch);\n          if (rule.isParagraphBackTrack()) {\n            rule.addRuleMatch(thisMatch);\n          }\n        }        \n      }\n                  \n      Collections.sort(sentenceMatches);\n      ruleMatches.addAll(sentenceMatches);\n      tokenCount += sentence.length();\n      lineCount += countLineBreaks(sentence);\n      // calculate matching column:\n      final int linebreakPos = sentence.indexOf('\\n');\n      if (linebreakPos == -1) {\n        columnCount += sentence.length();\n      } else {\n        columnCount = sentence.length() - linebreakPos - 1;\n      }\n    }\n    \n    //removing false positives in paragraph-level rules\n    for (final Rule rule : allRules) {\n      if (rule.isParagraphBackTrack()\n          && (rule.getMatches() != null)) {\n        final List <RuleMatch> rm = rule.getMatches();           \n        for (final RuleMatch r : rm) {\n          if (rule.isInRemoved(r)) {\n            ruleMatches.remove(r);\n          }\n        }       \n      }          \n    }\n\n    return ruleMatches;\n  }","id":42790,"modified_method":"/**\n   * The main check method. Tokenizes the text into sentences and matches these\n   * sentences against all currently active rules.\n   * \n   * @param text the text to check\n   * @return a List of {@link RuleMatch} objects\n   * @throws IOException \n   */\n  public List<RuleMatch> check(final String text) throws IOException {\n    sentenceCount = 0;\n    final List<String> sentences = sentenceTokenize(text);\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    final List<Rule> allRules = getAllRules();           \n    printIfVerbose(allRules.size() + \" rules activated for language \" + language);\n    int tokenCount = 0;\n    int lineCount = 0;\n    int columnCount = 0;\n    unknownWords = new HashSet<String>();\n    for (final String sentence : sentences) {\n      sentenceCount++;\n      AnalyzedSentence analyzedText = getAnalyzedSentence(sentence);\n      rememberUnknownWords(analyzedText);\n      \n      if (sentenceCount == sentences.size()) {\n        final AnalyzedTokenReadings[] anTokens = analyzedText.getTokens();\n        final AnalyzedToken paragraphEnd =\n          new AnalyzedToken(anTokens[anTokens.length - 1].getToken(),\n              PARAGRAPH_END_TAGNAME,\n              anTokens[anTokens.length - 1].getAnalyzedToken(0).getLemma(),\n              anTokens[anTokens.length - 1].getAnalyzedToken(0).getStartPos());\n        anTokens[anTokens.length - 1].addReading(paragraphEnd);\n        analyzedText = new AnalyzedSentence(anTokens); \n      }\n      \n      final List<RuleMatch> sentenceMatches = new ArrayList<RuleMatch>();\n      printIfVerbose(analyzedText.toString());\n      for (final Rule rule : allRules) {\n        if (disabledRules.contains(rule.getId())\n            || (rule.isDefaultOff() && !enabledRules.contains(rule.getId()))) {\n          continue;\n        }                \n        \n        if (disabledCategories.contains(rule.getCategory().getName())) {\n          continue;\n        }\n        \n        final RuleMatch[] thisMatches = rule.match(analyzedText);\n        for (final RuleMatch element1 : thisMatches) {\n          // change positions so they are relative to the complete text,\n          // not just to the sentence:\n          final RuleMatch thisMatch = new RuleMatch(element1.getRule(),\n              element1.getFromPos() + tokenCount,\n              element1.getToPos() + tokenCount,\n              element1.getMessage());\n          thisMatch.setSuggestedReplacements(element1.getSuggestedReplacements());\n          final String sentencePartToError = sentence.substring(0, element1.getFromPos());\n          final String sentencePartToEndOfError = sentence.substring(0, element1.getToPos());          \n          final int lastLineBreakPos = sentencePartToError.lastIndexOf('\\n');\n          int column = -1;\n          int endColumn = -1;\n          if (lastLineBreakPos == -1) {\n            column = sentencePartToError.length() + columnCount;\n          } else {\n            column = sentencePartToError.length() - lastLineBreakPos - 1;\n          }\n          final int lastLineBreakPosInError = sentencePartToEndOfError.lastIndexOf('\\n');\n          if (lastLineBreakPosInError == -1) {\n            endColumn = sentencePartToEndOfError.length() + columnCount + 1;\n          } else {\n            endColumn = sentencePartToEndOfError.length() - lastLineBreakPos;\n          }\n          final int lineBreaksToError = countLineBreaks(sentencePartToError);\n          final int lineBreaksToEndOfError = countLineBreaks(sentencePartToEndOfError);\n          thisMatch.setLine(lineCount + lineBreaksToError);\n          thisMatch.setEndLine(lineCount + lineBreaksToEndOfError);\n          thisMatch.setColumn(column);\n          thisMatch.setEndColumn(endColumn);\n          thisMatch.setOffset(element1.getFromPos() + tokenCount);\n          sentenceMatches.add(thisMatch);\n          if (rule.isParagraphBackTrack()) {\n            rule.addRuleMatch(thisMatch);\n          }\n        }        \n      }\n                  \n      Collections.sort(sentenceMatches);\n      ruleMatches.addAll(sentenceMatches);\n      tokenCount += sentence.length();\n      lineCount += countLineBreaks(sentence);\n      // calculate matching column:\n      final int linebreakPos = sentence.indexOf('\\n');\n      if (linebreakPos == -1) {\n        columnCount += sentence.length();\n      } else {\n        columnCount = sentence.length() - linebreakPos - 1;\n      }\n    }\n    \n    //removing false positives in paragraph-level rules\n    for (final Rule rule : allRules) {\n      if (rule.isParagraphBackTrack()\n          && (rule.getMatches() != null)) {\n        final List <RuleMatch> rm = rule.getMatches();           \n        for (final RuleMatch r : rm) {\n          if (rule.isInRemoved(r)) {\n            ruleMatches.remove(r);\n          }\n        }       \n      }          \n    }\n\n    return ruleMatches;\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private static void exitWithUsageMessage() {\n    System.out.println(\"Usage: java de.danielnaber.languagetool.Main \" +\n            \"[-r|--recursive] [-v|--verbose] [-l|--language LANG] [-m|--mothertongue LANG] [-d|--disable RULES] \" +\n            \"[-e|--enable RULES] [-c|--encoding] [-u|--list-unknown] [-b] <file>\");\n    System.exit(1);\n  }","id":42791,"modified_method":"private static void exitWithUsageMessage() {\n    System.out.println(\"Usage: java de.danielnaber.languagetool.Main \" +\n            \"[-r|--recursive] [-v|--verbose] [-l|--language LANG] [-m|--mothertongue LANG] [-d|--disable RULES] \" +\n            \"[-e|--enable RULES] [-c|--encoding] [-u|--list-unknown] [-t|--taggeronly] [-b] <file>\");\n    System.exit(1);\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"Main(boolean verbose, Language language, Language motherTongue, String[] disabledRules,\n      String[] enabledRules, boolean apiFormat) throws IOException, \n      SAXException, ParserConfigurationException {\n    this.verbose = verbose;\n    this.apiFormat = apiFormat;\n    lt = new JLanguageTool(language, motherTongue);\n    lt.activateDefaultPatternRules();\n    lt.activateDefaultFalseFriendRules();\n    // disable rules that are disabled explicitly:\n    for (int i = 0; i < disabledRules.length; i++) {\n      lt.disableRule(disabledRules[i]);\n    }\n    // disable all rules except those enabled explicitly, if any:\n    if (enabledRules.length > 0) {\n      Set<String> enabledRuleIDs = new HashSet<String>(Arrays.asList(enabledRules));\n      for (Rule rule : lt.getAllRules()) {\n        if (!enabledRuleIDs.contains(rule.getId())) {\n          lt.disableRule(rule.getId());\n        }\n      }\n    }\n  }","id":42792,"modified_method":"Main(boolean verbose, boolean taggerOnly, Language language, Language motherTongue, String[] disabledRules,\n      String[] enabledRules, boolean apiFormat) throws IOException, \n      SAXException, ParserConfigurationException {\n    this.verbose = verbose;\n    this.apiFormat = apiFormat;\n    this.taggerOnly = taggerOnly;\n    lt = new JLanguageTool(language, motherTongue);\n    lt.activateDefaultPatternRules();\n    lt.activateDefaultFalseFriendRules();\n    // disable rules that are disabled explicitly:\n    for (int i = 0; i < disabledRules.length; i++) {\n      lt.disableRule(disabledRules[i]);\n    }\n    // disable all rules except those enabled explicitly, if any:\n    if (enabledRules.length > 0) {\n      Set<String> enabledRuleIDs = new HashSet<String>(Arrays.asList(enabledRules));\n      for (Rule rule : lt.getAllRules()) {\n        if (!enabledRuleIDs.contains(rule.getId())) {\n          lt.disableRule(rule.getId());\n        }\n      }\n    }\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void runOnFile(final String filename, final String encoding) throws IOException {\n    final File file = new File(filename);\n    if (file.length() < MAXFILESIZE) {\n      final String text = \n        getFilteredText(filename, encoding);\n        Tools.checkText(text, lt);\n      } else {\n        if (verbose)\n          lt.setOutput(System.err);\n        if (!apiFormat)\n          System.out.println(\"Working on \" \n              + filename + \"... in a line by line mode\");\n        //TODO: change LT default statistics mode to summarize at the end\n        //of processing\n        InputStreamReader isr = null;\n        BufferedReader br = null;\n        try {\n          if (encoding != null) {\n            isr = new InputStreamReader(\n                new FileInputStream(file.getAbsolutePath()), encoding);\n          } else {\n            isr = new InputStreamReader(\n                new FileInputStream(file.getAbsolutePath()));\n          }\n          br = new BufferedReader(isr);\n          String line;\n          while ((line = br.readLine()) != null) {\n            line += \"\\n\";\n            Tools.checkText(filterXML(line), lt);\n          }\n        } finally {\n          if (br != null) {\n            br.close();\n          }\n          if (isr != null) {\n            isr.close();\n          }\n        }         \n      }        \n    }","id":42793,"modified_method":"private void runOnFile(final String filename, final String encoding) throws IOException {\n    final File file = new File(filename);\n      if (file.length() < MAXFILESIZE) {\n      final String text = \n        getFilteredText(filename, encoding);\n        if (!taggerOnly) {\n        Tools.checkText(text, lt);\n        } else {\n          Tools.tagText(text, lt);\n        }                \n      } else {\n        if (verbose)\n          lt.setOutput(System.err);\n        if (!apiFormat)\n          System.out.println(\"Working on \" \n              + filename + \"... in a line by line mode\");\n        //TODO: change LT default statistics mode to summarize at the end\n        //of processing\n        InputStreamReader isr = null;\n        BufferedReader br = null;\n        try {\n          if (encoding != null) {\n            isr = new InputStreamReader(\n                new FileInputStream(file.getAbsolutePath()), encoding);\n          } else {\n            isr = new InputStreamReader(\n                new FileInputStream(file.getAbsolutePath()));\n          }\n          br = new BufferedReader(isr);\n          String line;\n          while ((line = br.readLine()) != null) {\n            line += \"\\n\";\n            if (!taggerOnly) {\n            Tools.checkText(filterXML(line), lt);\n            } else {\n              Tools.tagText(filterXML(line), lt);\n            }\n          }\n        } finally {\n          if (br != null) {\n            br.close();\n          }\n          if (isr != null) {\n            isr.close();\n          }\n        }         \n      }        \n    }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"Main(boolean verbose, Language language, Language motherTongue, String[] disabledRules,\n      String[] enabledRules) throws IOException, SAXException, ParserConfigurationException {\n      this(verbose, language, motherTongue, disabledRules, enabledRules, false);\n  }","id":42794,"modified_method":"Main(boolean verbose, Language language, Language motherTongue, String[] disabledRules,\n      String[] enabledRules) throws IOException, SAXException, ParserConfigurationException {\n      this(verbose, false, language, motherTongue, disabledRules, enabledRules, false);\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Command line tool to check plain text files.\n   */\n  public static void main(String[] args) throws IOException, ParserConfigurationException, SAXException {\n    if (args.length < 1 || args.length > 9) {\n      exitWithUsageMessage();\n    }\n    boolean verbose = false;\n    boolean recursive = false;\n    boolean singleLineBreakMarksParagraph = false;\n    boolean apiFormat = false;\n    boolean listUnknown = false;\n    Language language = null;\n    Language motherTongue = null;\n    String encoding = null;\n    String filename = null;\n    String[] disabledRules = new String[0];\n    String[] enabledRules = new String[0];\n    for (int i = 0; i < args.length; i++) {\n      if (args[i].equals(\"-h\") || args[i].equals(\"-help\") || args[i].equals(\"--help\")) {\n        exitWithUsageMessage();\n      } else if (args[i].equals(\"-v\") || args[i].equals(\"--verbose\")) {\n        verbose = true;\n      } else if (args[i].equals(\"-r\") || args[i].equals(\"--recursive\")) {\n        recursive = true;\n      } else if (args[i].equals(\"-d\") || args[i].equals(\"--disable\")) {\n        if (enabledRules.length > 0)\n          throw new IllegalArgumentException(\"You cannot specifiy both enabled and disabled rules\");\n        String rules = args[++i];\n        disabledRules = rules.split(\",\");\n      } else if (args[i].equals(\"-e\") || args[i].equals(\"--enable\")) {\n        if (disabledRules.length > 0)\n          throw new IllegalArgumentException(\"You cannot specifiy both enabled and disabled rules\");\n        String rules = args[++i];\n        enabledRules = rules.split(\",\");\n      } else if (args[i].equals(\"-l\") || args[i].equals(\"--language\")) {\n        language = getLanguageOrExit(args[++i]);\n      } else if (args[i].equals(\"-m\") || args[i].equals(\"--mothertongue\")) {\n        motherTongue = getLanguageOrExit(args[++i]);\n      } else if (args[i].equals(\"-c\") || args[i].equals(\"--encoding\")) {\n        encoding = args[++i];\n      } else if (args[i].equals(\"-u\") || args[i].equals(\"--list-unknown\")) {\n        listUnknown = true;\n      } else if (args[i].equals(\"-b\")) {\n        singleLineBreakMarksParagraph = true;\n      } else if (i == args.length - 1) {\n        filename = args[i];\n      } else if (args[i].equals(\"--api\")) {\n        apiFormat = true;\n      } else {\n        System.err.println(\"Unknown option: \" + args[i]);\n        exitWithUsageMessage();\n      }\n    }\n    if (filename == null) {\n      exitWithUsageMessage();\n    }\n    if (language == null) {\n      if (!apiFormat)\n        System.err.println(\"No language specified, using English\");\n      language = Language.ENGLISH;\n    } else if (!apiFormat) {\n      System.out.println(\"Expected text language: \" + language.getName());\n    }\n    language.getSentenceTokenizer().setSingleLineBreaksMarksParagraph(singleLineBreakMarksParagraph);\n    Main prg = new Main(verbose, language, motherTongue, disabledRules, enabledRules, apiFormat);\n    prg.setListUnknownWords(listUnknown);\n    if (recursive) {\n      prg.runRecursive(filename, encoding);\n    } else {\n      /* String text = prg.getFilteredText(filename, encoding);\n      Tools.checkText(text, prg.getJLanguageTool(), apiFormat);\n      */\n      prg.runOnFile(filename, encoding);\n      if (listUnknown) {\n        System.out.println(\"Unknown words: \" + prg.getJLanguageTool().getUnknownWords());\n      }\n    }\n  }","id":42795,"modified_method":"/**\n   * Command line tool to check plain text files.\n   */\n  public static void main(String[] args) throws IOException, ParserConfigurationException, SAXException {\n    if (args.length < 1 || args.length > 9) {\n      exitWithUsageMessage();\n    }\n    boolean verbose = false;\n    boolean recursive = false;\n    boolean taggerOnly = false;\n    boolean singleLineBreakMarksParagraph = false;\n    boolean apiFormat = false;\n    boolean listUnknown = false;\n    Language language = null;\n    Language motherTongue = null;\n    String encoding = null;\n    String filename = null;\n    String[] disabledRules = new String[0];\n    String[] enabledRules = new String[0];\n    for (int i = 0; i < args.length; i++) {\n      if (args[i].equals(\"-h\") || args[i].equals(\"-help\") || args[i].equals(\"--help\")) {\n        exitWithUsageMessage();\n      } else if (args[i].equals(\"-v\") || args[i].equals(\"--verbose\")) {\n        verbose = true;\n      } else if (args[i].equals(\"-t\") || args[i].equals(\"--taggeronly\")) {\n        taggerOnly = true;\n      } else if (args[i].equals(\"-r\") || args[i].equals(\"--recursive\")) {\n        recursive = true;\n      } else if (args[i].equals(\"-d\") || args[i].equals(\"--disable\")) {\n        if (enabledRules.length > 0)\n          throw new IllegalArgumentException(\"You cannot specifiy both enabled and disabled rules\");\n        String rules = args[++i];\n        disabledRules = rules.split(\",\");\n      } else if (args[i].equals(\"-e\") || args[i].equals(\"--enable\")) {\n        if (disabledRules.length > 0)\n          throw new IllegalArgumentException(\"You cannot specifiy both enabled and disabled rules\");\n        String rules = args[++i];\n        enabledRules = rules.split(\",\");\n      } else if (args[i].equals(\"-l\") || args[i].equals(\"--language\")) {\n        language = getLanguageOrExit(args[++i]);\n      } else if (args[i].equals(\"-m\") || args[i].equals(\"--mothertongue\")) {\n        motherTongue = getLanguageOrExit(args[++i]);\n      } else if (args[i].equals(\"-c\") || args[i].equals(\"--encoding\")) {\n        encoding = args[++i];\n      } else if (args[i].equals(\"-u\") || args[i].equals(\"--list-unknown\")) {\n        listUnknown = true;\n      } else if (args[i].equals(\"-b\")) {\n        singleLineBreakMarksParagraph = true;\n      } else if (i == args.length - 1) {\n        filename = args[i];\n      } else if (args[i].equals(\"--api\")) {\n        apiFormat = true;\n      } else {\n        System.err.println(\"Unknown option: \" + args[i]);\n        exitWithUsageMessage();\n      }\n    }\n    if (filename == null) {\n      exitWithUsageMessage();\n    }\n    if (language == null) {\n      if (!apiFormat)\n        System.err.println(\"No language specified, using English\");\n      language = Language.ENGLISH;\n    } else if (!apiFormat) {\n      System.out.println(\"Expected text language: \" + language.getName());\n    }\n    language.getSentenceTokenizer().setSingleLineBreaksMarksParagraph(singleLineBreakMarksParagraph);\n    Main prg = new Main(verbose, taggerOnly, language, motherTongue, disabledRules, enabledRules, apiFormat);\n    prg.setListUnknownWords(listUnknown);\n    if (recursive) {\n      prg.runRecursive(filename, encoding);\n    } else {\n      /* String text = prg.getFilteredText(filename, encoding);\n      Tools.checkText(text, prg.getJLanguageTool(), apiFormat);\n      */\n      prg.runOnFile(filename, encoding);\n      if (listUnknown) {\n        System.out.println(\"Unknown words: \" + prg.getJLanguageTool().getUnknownWords());\n      }\n    }\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public final RuleMatch[] match(final AnalyzedSentence text) throws IOException {\n\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();    \n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    final int[] tokenPositions = new int[tokens.length + 1 ];\n\n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    final int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n\n      //stop processing if rule is longer than the sentence\n      if (patternSize + i > tokens.length) {\n        allElementsMatch = false;\n        break;\n      }\n\n      //stop looking for sent_start - it will never match any\n      //token except the first\n      if (startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n\n      int matchingTokens = 0;\n      for (int k = 0; (k < patternSize); k++) {\n        if (elem != null) {\n          prevElement = elem;\n        }\n        elem = patternElements.get(k);        \n        skipNext = translateElementNo(elem.getSkipNext());\n        final int nextPos = tokenPos + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          final int numberOfReadings = tokens[m].getReadingsLength();\n\n          for (int l = 0; l < numberOfReadings; l++) {\n            final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null\n                && prevElement.isMatchedByScopeNextException(matchToken)) {\n              exceptionMatched = true;\n              prevMatched = true;              \n            }\n            if (elem.isReferenceElement()\n                && (firstMatchToken + elem.getMatch().getTokenRef() \n                    < tokens.length)) {\n              elem.compile(tokens[firstMatchToken + \n                                  elem.getMatch().getTokenRef()],\n                                  language.getSynthesizer());\n            }            \n\n            if (elem.hasAndGroup()) {\n              for (final Element andElement : elem.getAndGroup()) {\n                if (andElement.isReferenceElement()\n                    && (firstMatchToken + andElement.getMatch().getTokenRef() \n                        < tokens.length)) {\n                  andElement.compile(tokens[firstMatchToken \n                                            + andElement.getMatch().getTokenRef()],\n                                            language.getSynthesizer());\n                }                \n              }              \n              if (l == 0) { \n                elem.setupAndGroup();\n              }\n            }\n\n            thisMatched |= elem.isMatchedCompletely(matchToken);            \n\n            if (l + 1 == numberOfReadings && elem.hasAndGroup()) {\n              thisMatched &= elem.checkAndGroup(thisMatched);\n            }                \n            exceptionMatched |= elem.isExceptionMatchedCompletely(matchToken);\n            if (!exceptionMatched && m > 0 && elem.hasPreviousException()) {\n              final int numReadings = tokens[m - 1].getReadingsLength();\n              for (int p = 0; p < numReadings; p++) {             \n                exceptionMatched |= \n                  elem.isMatchedByScopePreviousException(\n                      tokens[m - 1].getAnalyzedToken(p));\n              }\n            }\n\n            // Logical OR (cannot be AND):\n              if (thisMatched || exceptionMatched) {\n                matched = true;\n                matchPos = m;\n                skipShift = matchPos - nextPos;              \n                tokenPositions[matchingTokens] = skipShift + 1;\n              } else {\n                matched |= false;                            \n              }\n              skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n\n          //disallow exceptions that should match only current tokens          \n          if (!(thisMatched || prevMatched)) {\n            exceptionMatched = false;\n            skipMatch = false;\n          }\n\n          if (skipMatch) {\n            break;\n          }\n\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n          matchingTokens++;\n          lastMatchToken = matchPos;          \n          if (firstMatchToken == -1) {\n            firstMatchToken = matchPos;\n          }\n          skipShiftTotal += skipShift;\n        } else {\n          prevSkipNext = 0;\n          skipShiftTotal = 0;\n          break;\n        }        \n      }\n\n      tokenPos++;\n\n      if (firstMatchToken + matchingTokens >= tokens.length) {\n        matchingTokens = tokens.length - firstMatchToken;\n      }\n\n      if (firstMatchToken + skipShiftTotal + matchingTokens > tokens.length) {\n        allElementsMatch = false;\n      }\n\n      if (allElementsMatch) {\n\n        final String errMessage = formatMatches(tokens,\n            tokenPositions, firstMatchToken, message);\n\n        int correctedStPos = 0;\n        if (startPositionCorrection > 0) {        \n          for (int l = 0; l <= startPositionCorrection; l++) {\n            correctedStPos +=  tokenPositions[l];\n          }\n          correctedStPos--;\n        }        \n\n        int correctedEndPos = 0;\n        if (endPositionCorrection < 0) {\n          int l = 0;\n          while (l > endPositionCorrection) {\n            correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n            l--;\n          }\n        }         \n\n        AnalyzedTokenReadings firstMatchTokenObj = tokens[firstMatchToken + correctedStPos];\n        boolean startsWithUppercase = \n          StringTools.startsWithUppercase(firstMatchTokenObj.toString())\n          && !matchConvertsCase();\n\n        if (firstMatchTokenObj.isSentStart() && tokens.length > firstMatchToken + correctedStPos + 1) {\n          // make uppercasing work also at sentence start: \n          firstMatchTokenObj = tokens[firstMatchToken + correctedStPos + 1];\n          startsWithUppercase = StringTools.startsWithUppercase(firstMatchTokenObj.toString());\n        }\n        int fromPos = tokens[firstMatchToken + correctedStPos]\n                             .getStartPos();\n        //FIXME: this is fishy, assumes that comma should always come before whitespace        \n        if (errMessage.contains(SUGG_TAG + \",\") && firstMatchToken + correctedStPos >= 1) {\n          fromPos = tokens[firstMatchToken + correctedStPos - 1].getStartPos() \n          + tokens[firstMatchToken + correctedStPos - 1].getToken().length();          \n        }\n\n        final int toPos = tokens[lastMatchToken + correctedEndPos].getStartPos()\n        + tokens[lastMatchToken + correctedEndPos].getToken().length();\n        if (fromPos < toPos) { //this can happen with some skip=\"-1\" when the last token is not matched\n          final RuleMatch ruleMatch = new RuleMatch(this, fromPos, toPos, errMessage,\n              startsWithUppercase);        \n          ruleMatches.add(ruleMatch);        \n        }\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n        skipShiftTotal = 0;\n      }\n    }\n\n    return ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);\n  }","id":42796,"modified_method":"@Override\n  public final RuleMatch[] match(final AnalyzedSentence text) throws IOException {\n\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();    \n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    final int[] tokenPositions = new int[tokens.length + 1 ];\n\n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    final int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n\n      //stop processing if rule is longer than the sentence\n      if (patternSize + i > tokens.length) {\n        allElementsMatch = false;\n        break;\n      }\n\n      //stop looking for sent_start - it will never match any\n      //token except the first\n      if (startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n\n      int matchingTokens = 0;\n      for (int k = 0; (k < patternSize); k++) {\n        if (elem != null) {\n          prevElement = elem;\n        }\n        elem = patternElements.get(k);        \n        skipNext = translateElementNo(elem.getSkipNext());\n        final int nextPos = tokenPos + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          final int numberOfReadings = tokens[m].getReadingsLength();\n\n          for (int l = 0; l < numberOfReadings; l++) {\n            final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null\n                && prevElement.isMatchedByScopeNextException(matchToken)) {\n              exceptionMatched = true;\n              prevMatched = true;              \n            }\n            if (elem.isReferenceElement()\n                && (firstMatchToken + elem.getMatch().getTokenRef() \n                    < tokens.length)) {\n              elem.compile(tokens[firstMatchToken + \n                                  elem.getMatch().getTokenRef()],\n                                  language.getSynthesizer());\n            }            \n\n            if (elem.hasAndGroup()) {\n              for (final Element andElement : elem.getAndGroup()) {\n                if (andElement.isReferenceElement()\n                    && (firstMatchToken + andElement.getMatch().getTokenRef() \n                        < tokens.length)) {\n                  andElement.compile(tokens[firstMatchToken \n                                            + andElement.getMatch().getTokenRef()],\n                                            language.getSynthesizer());\n                }                \n              }              \n              if (l == 0) { \n                elem.setupAndGroup();\n              }\n            }\n\n            thisMatched |= elem.isMatchedCompletely(matchToken);            \n\n            if (l + 1 == numberOfReadings && elem.hasAndGroup()) {\n              thisMatched &= elem.checkAndGroup(thisMatched);\n            }                \n            exceptionMatched |= elem.isExceptionMatchedCompletely(matchToken);\n            if (!exceptionMatched && m > 0 && elem.hasPreviousException()) {\n              final int numReadings = tokens[m - 1].getReadingsLength();\n              for (int p = 0; p < numReadings; p++) {             \n                exceptionMatched |= \n                  elem.isMatchedByScopePreviousException(\n                      tokens[m - 1].getAnalyzedToken(p));\n              }\n            }\n\n            // Logical OR (cannot be AND):\n              if (thisMatched || exceptionMatched) {\n                matched = true;\n                matchPos = m;\n                skipShift = matchPos - nextPos;              \n                tokenPositions[matchingTokens] = skipShift + 1;\n              } else {\n                matched |= false;                            \n              }\n              skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n\n          //disallow exceptions that should match only current tokens          \n          if (!(thisMatched || prevMatched)) {\n            exceptionMatched = false;\n            skipMatch = false;\n          }\n\n          if (skipMatch) {\n            break;\n          }\n\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n          matchingTokens++;\n          lastMatchToken = matchPos;          \n          if (firstMatchToken == -1) {\n            firstMatchToken = matchPos;\n          }\n          skipShiftTotal += skipShift;\n        } else {\n          prevSkipNext = 0;\n          skipShiftTotal = 0;\n          break;\n        }        \n      }\n\n      tokenPos++;\n\n      if (firstMatchToken + matchingTokens >= tokens.length) {\n        matchingTokens = tokens.length - firstMatchToken;\n      }\n\n      if (firstMatchToken + skipShiftTotal + matchingTokens > tokens.length) {\n        allElementsMatch = false;\n      }\n\n      if (allElementsMatch) {\n\n        final String errMessage = formatMatches(tokens,\n            tokenPositions, firstMatchToken, message);\n\n        int correctedStPos = 0;\n        if (startPositionCorrection > 0) {        \n          for (int l = 0; l <= startPositionCorrection; l++) {\n            correctedStPos +=  tokenPositions[l];\n          }\n          correctedStPos--;\n        }        \n\n        int correctedEndPos = 0;\n        if (endPositionCorrection < 0) {\n          int l = 0;\n          while (l > endPositionCorrection) {\n            correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n            l--;\n          }\n        }         \n\n        AnalyzedTokenReadings firstMatchTokenObj = tokens[firstMatchToken + correctedStPos];\n        boolean startsWithUppercase = \n          StringTools.startsWithUppercase(firstMatchTokenObj.getToken())\n          && !matchConvertsCase();\n\n        if (firstMatchTokenObj.isSentStart() && tokens.length > firstMatchToken + correctedStPos + 1) {\n          // make uppercasing work also at sentence start: \n          firstMatchTokenObj = tokens[firstMatchToken + correctedStPos + 1];\n          startsWithUppercase = StringTools.startsWithUppercase(firstMatchTokenObj.getToken());\n        }\n        int fromPos = tokens[firstMatchToken + correctedStPos]\n                             .getStartPos();\n        //FIXME: this is fishy, assumes that comma should always come before whitespace        \n        if (errMessage.contains(SUGG_TAG + \",\") && firstMatchToken + correctedStPos >= 1) {\n          fromPos = tokens[firstMatchToken + correctedStPos - 1].getStartPos() \n          + tokens[firstMatchToken + correctedStPos - 1].getToken().length();          \n        }\n\n        final int toPos = tokens[lastMatchToken + correctedEndPos].getStartPos()\n        + tokens[lastMatchToken + correctedEndPos].getToken().length();\n        if (fromPos < toPos) { //this can happen with some skip=\"-1\" when the last token is not matched\n          final RuleMatch ruleMatch = new RuleMatch(this, fromPos, toPos, errMessage,\n              startsWithUppercase);        \n          ruleMatches.add(ruleMatch);        \n        }\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n        skipShiftTotal = 0;\n      }\n    }\n\n    return ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testIsWhitespace() {\n    assertEquals(true, StringTools.isWhitespace(\"  \"));\n    assertEquals(true, StringTools.isWhitespace(\"\\t\"));\n    assertEquals(true, StringTools.isWhitespace(\"\\u2002\"));\n    //non-breaking space is not a whitespace\n    assertEquals(false, StringTools.isWhitespace(\"\\u00a0\"));\n    assertEquals(false, StringTools.isWhitespace(\"abc\"));    \n  }","id":42797,"modified_method":"public void testIsWhitespace() {\n    assertEquals(true, StringTools.isWhitespace(\"  \"));\n    assertEquals(true, StringTools.isWhitespace(\"\\t\"));\n    assertEquals(true, StringTools.isWhitespace(\"\\u2002\"));\n    //non-breaking space is not a whitespace\n    assertEquals(false, StringTools.isWhitespace(\"\\u00a0\"));\n    assertEquals(false, StringTools.isWhitespace(\"abc\"));\n    //non-breaking OOo field\n    assertEquals(false, StringTools.isWhitespace(\"\\\\u02\"));\n  }","commit_id":"032d44a4ba7f632551aef2b48e6e8f5fc3968970","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Prepare a server on the given host and port - use run() to start it.\n   * @param runInternally if true, then the server was started from the GUI.\n   * @param host the host to bind to, e.g. <code>\"localhost\"<\/code> or <code>null<\/code> to bind to any host\n   * @param allowedIps the IP addresses from which connections are allowed or <code>null<\/code> to allow any host\n   * @throws PortBindingException if we cannot bind to the given port, e.g. because something else is running there\n   */\n  public HTTPSServer(HTTPSServerConfig config, boolean runInternally, String host, Set<String> allowedIps) {\n    this.port = config.getPort();\n    this.host = host;\n    try {\n      if (host == null) {\n        server = HttpsServer.create(new InetSocketAddress(port), 0);\n      } else {\n        server = HttpsServer.create(new InetSocketAddress(host, port), 0);\n      }\n      final SSLContext sslContext = getSslContext(config.getKeystore(), config.getKeyStorePassword());\n      final HttpsConfigurator configurator = getConfigurator(sslContext);\n      ((HttpsServer)server).setHttpsConfigurator(configurator);\n      final RequestLimiter limiter = getRequestLimiterOrNull(config);\n      httpHandler = new LanguageToolHttpHandler(config.isVerbose(), allowedIps, runInternally, limiter);\n      httpHandler.setMaxTextLength(config.getMaxTextLength());\n      httpHandler.setAllowOriginUrl(config.getAllowOriginUrl());\n      httpHandler.setMaxCheckTimeMillis(config.getMaxCheckTimeMillis());\n      server.createContext(\"/\", httpHandler);\n      executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n      server.setExecutor(executorService);\n    } catch (BindException e) {\n      final ResourceBundle messages = JLanguageTool.getMessageBundle();\n      final String message = Tools.makeTexti18n(messages, \"https_server_start_failed\", host, Integer.toString(port));\n      throw new PortBindingException(message, e);\n    } catch (Exception e) {\n      final ResourceBundle messages = JLanguageTool.getMessageBundle();\n      final String message = Tools.makeTexti18n(messages, \"https_server_start_failed_unknown_reason\", host, Integer.toString(port));\n      throw new RuntimeException(message, e);\n    }\n  }","id":42798,"modified_method":"/**\n   * Prepare a server on the given host and port - use run() to start it.\n   * @param runInternally if true, then the server was started from the GUI.\n   * @param host the host to bind to, e.g. <code>\"localhost\"<\/code> or <code>null<\/code> to bind to any host\n   * @param allowedIps the IP addresses from which connections are allowed or <code>null<\/code> to allow any host\n   * @throws PortBindingException if we cannot bind to the given port, e.g. because something else is running there\n   */\n  public HTTPSServer(HTTPSServerConfig config, boolean runInternally, String host, Set<String> allowedIps) {\n    this.port = config.getPort();\n    this.host = host;\n    try {\n      if (host == null) {\n        server = HttpsServer.create(new InetSocketAddress(port), 0);\n      } else {\n        server = HttpsServer.create(new InetSocketAddress(host, port), 0);\n      }\n      final SSLContext sslContext = getSslContext(config.getKeystore(), config.getKeyStorePassword());\n      final HttpsConfigurator configurator = getConfigurator(sslContext);\n      ((HttpsServer)server).setHttpsConfigurator(configurator);\n      final RequestLimiter limiter = getRequestLimiterOrNull(config);\n      httpHandler = new LanguageToolHttpHandler(config.isVerbose(), allowedIps, runInternally, limiter);\n      httpHandler.setMaxTextLength(config.getMaxTextLength());\n      httpHandler.setAllowOriginUrl(config.getAllowOriginUrl());\n      httpHandler.setMaxCheckTimeMillis(config.getMaxCheckTimeMillis());\n      if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {\n        httpHandler.setAfterTheDeadlineMode(config.getAfterTheDeadlineLanguage());\n      }\n      server.createContext(\"/\", httpHandler);\n      executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n      server.setExecutor(executorService);\n    } catch (BindException e) {\n      final ResourceBundle messages = JLanguageTool.getMessageBundle();\n      final String message = Tools.makeTexti18n(messages, \"https_server_start_failed\", host, Integer.toString(port));\n      throw new PortBindingException(message, e);\n    } catch (Exception e) {\n      final ResourceBundle messages = JLanguageTool.getMessageBundle();\n      final String message = Tools.makeTexti18n(messages, \"https_server_start_failed_unknown_reason\", host, Integer.toString(port));\n      throw new RuntimeException(message, e);\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public static void main(String[] args) {\n    if (args.length > 7 || usageRequested(args)) {\n      System.out.println(\"Usage: \" + HTTPSServer.class.getSimpleName()\n              + \" --config propertyFile [--port|-p port] [--public]\");\n      System.out.println(\"  --config file  a Java property file with values for:\");\n      System.out.println(\"                 'keystore' - a Java keystore with an SSL certificate\");\n      System.out.println(\"                 'password' - the keystore's password\");\n      System.out.println(\"                 'maxTextLength' - maximum text length, longer texts will cause an error (optional)\");\n      System.out.println(\"                 'maxCheckTimeMillis' - maximum time in milliseconds allowed per check (optional)\");\n      System.out.println(\"                 'requestLimit' - maximum number of requests (optional)\");\n      System.out.println(\"                 'requestLimitPeriodInSeconds' - time period to which requestLimit applies (optional)\");\n      printCommonOptions();\n      System.exit(1);\n    }\n    final boolean runInternal = false;\n    try {\n      final HTTPSServerConfig config = new HTTPSServerConfig(args);\n      try {\n        final HTTPSServer server;\n        if (config.isPublicAccess()) {\n          System.out.println(\"WARNING: running in public mode, LanguageTool API can be accessed without restrictions!\");\n          server = new HTTPSServer(config, runInternal, null, null);\n        } else {\n          server = new HTTPSServer(config, runInternal, DEFAULT_HOST, DEFAULT_ALLOWED_IPS);\n        }\n        server.run();\n      } catch (Exception e) {\n        throw new RuntimeException(\"Could not start LanguageTool HTTPS server on \" + HTTPServerConfig.DEFAULT_HOST + \", port \" + config.getPort(), e);\n      }\n    } catch (IllegalConfigurationException e) {\n      System.out.println(e.getMessage());\n      System.out.println(\"Note: this is the HTTPS server - if you want to use plain HTTP instead, please see http://languagetool.org/http-server/\");\n      System.exit(1);\n    }\n  }","id":42799,"modified_method":"public static void main(String[] args) {\n    if (args.length > 7 || usageRequested(args)) {\n      System.out.println(\"Usage: \" + HTTPSServer.class.getSimpleName()\n              + \" --config propertyFile [--port|-p port] [--public]\");\n      System.out.println(\"  --config file  a Java property file with values for:\");\n      System.out.println(\"                 'keystore' - a Java keystore with an SSL certificate\");\n      System.out.println(\"                 'password' - the keystore's password\");\n      System.out.println(\"                 'mode' - 'LanguageTool' or 'AfterTheDeadline' for emulation of After the Deadline output (optional, experimental)\");\n      System.out.println(\"                 'afterTheDeadlineLanguage' - language code like 'en' or 'en-GB' (required if mode is 'AfterTheDeadline')\");\n      System.out.println(\"                 'maxTextLength' - maximum text length, longer texts will cause an error (optional)\");\n      System.out.println(\"                 'maxCheckTimeMillis' - maximum time in milliseconds allowed per check (optional)\");\n      System.out.println(\"                 'requestLimit' - maximum number of requests (optional)\");\n      System.out.println(\"                 'requestLimitPeriodInSeconds' - time period to which requestLimit applies (optional)\");\n      printCommonOptions();\n      System.exit(1);\n    }\n    final boolean runInternal = false;\n    try {\n      final HTTPSServerConfig config = new HTTPSServerConfig(args);\n      try {\n        final HTTPSServer server;\n        if (config.isPublicAccess()) {\n          System.out.println(\"WARNING: running in public mode, LanguageTool API can be accessed without restrictions!\");\n          server = new HTTPSServer(config, runInternal, null, null);\n        } else {\n          server = new HTTPSServer(config, runInternal, DEFAULT_HOST, DEFAULT_ALLOWED_IPS);\n        }\n        server.run();\n      } catch (Exception e) {\n        throw new RuntimeException(\"Could not start LanguageTool HTTPS server on \" + HTTPServerConfig.DEFAULT_HOST + \", port \" + config.getPort(), e);\n      }\n    } catch (IllegalConfigurationException e) {\n      System.out.println(e.getMessage());\n      System.out.println(\"Note: this is the HTTPS server - if you want to use plain HTTP instead, please see http://languagetool.org/http-server/\");\n      System.exit(1);\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public static void main(String[] args) {\n    if (args.length > 5 || usageRequested(args)) {\n      System.out.println(\"Usage: \" + HTTPServer.class.getSimpleName() + \" [--config propertyFile] [--port|-p port] [--public]\");\n      System.out.println(\"  --config file  a Java property file with values for:\");\n      System.out.println(\"                 'maxTextLength' - maximum text length, longer texts will cause an error (optional)\");\n      System.out.println(\"                 'maxCheckTimeMillis' - maximum time in milliseconds allowed per check (optional)\");\n      printCommonOptions();\n      System.exit(1);\n    }\n    final boolean runInternal = false;\n    final HTTPServerConfig config = new HTTPServerConfig(args);\n    try {\n      final HTTPServer server;\n      System.out.println(\"WARNING: running in HTTP mode, consider using SSL by running \" + HTTPSServer.class.getName() + \" instead\");\n      if (config.isPublicAccess()) {\n        System.out.println(\"WARNING: running in public mode, LanguageTool API can be accessed without restrictions!\");\n        server = new HTTPServer(config, runInternal, null, null);\n      } else {\n        server = new HTTPServer(config, runInternal, DEFAULT_HOST, DEFAULT_ALLOWED_IPS);\n      }\n      server.run();\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not start LanguageTool HTTP server on \" + DEFAULT_HOST + \", port \" + config.getPort(), e);\n    }\n  }","id":42800,"modified_method":"public static void main(String[] args) {\n    if (args.length > 5 || usageRequested(args)) {\n      System.out.println(\"Usage: \" + HTTPServer.class.getSimpleName() + \" [--config propertyFile] [--port|-p port] [--public]\");\n      System.out.println(\"  --config file  a Java property file with values for:\");\n      System.out.println(\"                 'mode' - 'LanguageTool' or 'AfterTheDeadline' for emulation of After the Deadline output (optional, experimental)\");\n      System.out.println(\"                 'afterTheDeadlineLanguage' - language code like 'en' or 'en-GB' (required if mode is 'AfterTheDeadline')\");\n      System.out.println(\"                 'maxTextLength' - maximum text length, longer texts will cause an error (optional)\");\n      System.out.println(\"                 'maxCheckTimeMillis' - maximum time in milliseconds allowed per check (optional)\");\n      printCommonOptions();\n      System.exit(1);\n    }\n    final boolean runInternal = false;\n    final HTTPServerConfig config = new HTTPServerConfig(args);\n    try {\n      final HTTPServer server;\n      System.out.println(\"WARNING: running in HTTP mode, consider using SSL by running \" + HTTPSServer.class.getName() + \" instead\");\n      if (config.isPublicAccess()) {\n        System.out.println(\"WARNING: running in public mode, LanguageTool API can be accessed without restrictions!\");\n        server = new HTTPServer(config, runInternal, null, null);\n      } else {\n        server = new HTTPServer(config, runInternal, DEFAULT_HOST, DEFAULT_ALLOWED_IPS);\n      }\n      server.run();\n    } catch (Exception e) {\n      throw new RuntimeException(\"Could not start LanguageTool HTTP server on \" + DEFAULT_HOST + \", port \" + config.getPort(), e);\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Prepare a server on the given host and port - use run() to start it.\n   * @param runInternally if true, then the server was started from the GUI.\n   * @param host the host to bind to, e.g. <code>\"localhost\"<\/code> or <code>null<\/code> to bind to any host\n   * @param allowedIps the IP addresses from which connections are allowed or <code>null<\/code> to allow any host\n   * @throws PortBindingException if we cannot bind to the given port, e.g. because something else is running there\n   * @since 1.7\n   */\n  public HTTPServer(HTTPServerConfig config, boolean runInternally, String host, Set<String> allowedIps) {\n    this.port = config.getPort();\n    this.host = host;\n    try {\n      InetSocketAddress address = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(port);\n      server = HttpServer.create(address, 0);\n      httpHandler = new LanguageToolHttpHandler(config.isVerbose(), allowedIps, runInternally, null);\n      httpHandler.setMaxTextLength(config.getMaxTextLength());\n      httpHandler.setAllowOriginUrl(config.getAllowOriginUrl());\n      httpHandler.setMaxCheckTimeMillis(config.getMaxCheckTimeMillis());\n      server.createContext(\"/\", httpHandler);\n      executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n      server.setExecutor(executorService);\n    } catch (Exception e) {\n      final ResourceBundle messages = JLanguageTool.getMessageBundle();\n      final String message = Tools.makeTexti18n(messages, \"http_server_start_failed\", host, Integer.toString(port));\n      throw new PortBindingException(message, e);\n    }\n  }","id":42801,"modified_method":"/**\n   * Prepare a server on the given host and port - use run() to start it.\n   * @param runInternally if true, then the server was started from the GUI.\n   * @param host the host to bind to, e.g. <code>\"localhost\"<\/code> or <code>null<\/code> to bind to any host\n   * @param allowedIps the IP addresses from which connections are allowed or <code>null<\/code> to allow any host\n   * @throws PortBindingException if we cannot bind to the given port, e.g. because something else is running there\n   * @since 1.7\n   */\n  public HTTPServer(HTTPServerConfig config, boolean runInternally, String host, Set<String> allowedIps) {\n    this.port = config.getPort();\n    this.host = host;\n    try {\n      InetSocketAddress address = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(port);\n      server = HttpServer.create(address, 0);\n      httpHandler = new LanguageToolHttpHandler(config.isVerbose(), allowedIps, runInternally, null);\n      httpHandler.setMaxTextLength(config.getMaxTextLength());\n      httpHandler.setAllowOriginUrl(config.getAllowOriginUrl());\n      httpHandler.setMaxCheckTimeMillis(config.getMaxCheckTimeMillis());\n      if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {\n        httpHandler.setAfterTheDeadlineMode(config.getAfterTheDeadlineLanguage());\n      }\n      server.createContext(\"/\", httpHandler);\n      executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);\n      server.setExecutor(executorService);\n    } catch (Exception e) {\n      final ResourceBundle messages = JLanguageTool.getMessageBundle();\n      final String message = Tools.makeTexti18n(messages, \"http_server_start_failed\", host, Integer.toString(port));\n      throw new PortBindingException(message, e);\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void parseConfigFile(File file) {\n    try {\n      final Properties props = new Properties();\n      try (FileInputStream fis = new FileInputStream(file)) {\n        props.load(fis);\n        maxTextLength = Integer.parseInt(getOptionalProperty(props, \"maxTextLength\", Integer.toString(Integer.MAX_VALUE)));\n        maxCheckTimeMillis = Long.parseLong(getOptionalProperty(props, \"maxCheckTimeMillis\", \"-1\"));\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Could not load properties from '\" + file + \"'\", e);\n    }\n  }","id":42802,"modified_method":"private void parseConfigFile(File file) {\n    try {\n      final Properties props = new Properties();\n      try (FileInputStream fis = new FileInputStream(file)) {\n        props.load(fis);\n        maxTextLength = Integer.parseInt(getOptionalProperty(props, \"maxTextLength\", Integer.toString(Integer.MAX_VALUE)));\n        maxCheckTimeMillis = Long.parseLong(getOptionalProperty(props, \"maxCheckTimeMillis\", \"-1\"));\n        mode = getOptionalProperty(props, \"mode\", \"LanguageTool\").equalsIgnoreCase(\"AfterTheDeadline\") ? Mode.AfterTheDeadline : Mode.LanguageTool;\n        if (mode == Mode.AfterTheDeadline) {\n          atdLanguage = Language.getLanguageForShortName(getProperty(props, \"afterTheDeadlineLanguage\", file));\n        }\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(\"Could not load properties from '\" + file + \"'\", e);\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"protected String getProperty(Properties props, String propertyName, File config) {\n    final String propertyValue = (String)props.get(propertyName);\n    if (propertyValue == null || propertyValue.trim().isEmpty()) {\n      throw new IllegalConfigurationException(\"Property '\" + propertyName + \"' must be set in \" + config);\n    }\n    return propertyValue;\n  }","id":42803,"modified_method":"/**\n   * @throws IllegalConfigurationException if property is not set \n   */\n  protected String getProperty(Properties props, String propertyName, File config) {\n    final String propertyValue = (String)props.get(propertyName);\n    if (propertyValue == null || propertyValue.trim().isEmpty()) {\n      throw new IllegalConfigurationException(\"Property '\" + propertyName + \"' must be set in \" + config);\n    }\n    return propertyValue;\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void sendError(HttpExchange httpExchange, int returnCode, String response) throws IOException {\n    httpExchange.sendResponseHeaders(returnCode, response.getBytes(ENCODING).length);\n    httpExchange.getResponseBody().write(response.getBytes(ENCODING));\n  }","id":42804,"modified_method":"private void sendError(HttpExchange httpExchange, int returnCode, String response) throws IOException {\n    if (afterTheDeadlineMode) {\n      String xmlResponse = \"<results><message>\" + escapeXml(response) + \"<\/message><\/results>\";\n      httpExchange.sendResponseHeaders(returnCode, xmlResponse.getBytes(ENCODING).length);\n      httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));\n    } else {\n      httpExchange.sendResponseHeaders(returnCode, response.getBytes(ENCODING).length);\n      httpExchange.getResponseBody().write(response.getBytes(ENCODING));\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void checkText(final String text, final HttpExchange httpExchange, final Map<String, String> parameters) throws Exception {\n    final long timeStart = System.currentTimeMillis();\n    if (text.length() > maxTextLength) {\n      throw new IllegalArgumentException(\"Text is \" + text.length() + \" characters long, exceeding maximum length of \" + maxTextLength);\n    }\n    final String langParam = parameters.get(\"language\");\n    //print(\"Check start: \" + text.length() + \" chars, \" + langParam);\n    final String autodetectParam = parameters.get(\"autodetect\");\n    if (langParam == null && (autodetectParam == null || !autodetectParam.equals(\"1\"))) {\n      throw new IllegalArgumentException(\"Missing 'language' parameter. Specify language or use autodetect=1 for auto-detecting the language of the input text.\");\n    }\n    \n    final Language lang;\n    if (autodetectParam != null && autodetectParam.equals(\"1\")) {\n      lang = detectLanguageOfString(text, langParam);\n      print(\"Auto-detected language: \" + lang.getShortNameWithCountryAndVariant());\n    } else {\n      lang = Language.getLanguageForShortName(langParam);\n    }\n    \n    final String motherTongueParam = parameters.get(\"motherTongue\");\n    final Language motherTongue = motherTongueParam != null ? Language.getLanguageForShortName(motherTongueParam) : null;\n    final boolean useEnabledOnly = \"yes\".equals(parameters.get(\"enabledOnly\"));\n    final String enabledParam = parameters.get(\"enabled\");\n    final List<String> enabledRules = new ArrayList<>();\n    if (enabledParam != null) {\n      enabledRules.addAll(Arrays.asList(enabledParam.split(\",\")));\n    }\n    \n    final String disabledParam = parameters.get(\"disabled\");\n    final List<String> disabledRules = new ArrayList<>();\n    if (disabledParam != null) {\n      disabledRules.addAll(Arrays.asList(disabledParam.split(\",\")));\n    }\n\n    if (disabledRules.size() > 0 && useEnabledOnly) {\n      throw new IllegalArgumentException(\"You cannot specify disabled rules using enabledOnly=yes\");\n    }\n    \n    final boolean useQuerySettings = enabledRules.size() > 0 || disabledRules.size() > 0;\n    final QueryParams params = new QueryParams(enabledRules, disabledRules, useEnabledOnly, useQuerySettings);\n    \n    final Future<List<RuleMatch>> future = executorService.submit(new Callable<List<RuleMatch>>() {\n      @Override\n      public List<RuleMatch> call() throws Exception {\n        return getRuleMatches(text, parameters, lang, motherTongue, params);\n      }\n    });\n    final List<RuleMatch> matches;\n    if (maxCheckTimeMillis < 0) {\n      matches = future.get();\n    } else {\n      try {\n        matches = future.get(maxCheckTimeMillis, TimeUnit.MILLISECONDS);\n      } catch (TimeoutException e) {\n        throw new RuntimeException(\"Text checking took longer than allowed maximum of \" + maxCheckTimeMillis +\n                \" milliseconds (handleCount: \" + handleCount + \", language: \" + lang.getShortNameWithCountryAndVariant() +\n                \", \" + text.length() + \" characters of text)\", e);\n      }\n    }\n    \n    setCommonHeaders(httpExchange);\n    final RuleAsXmlSerializer serializer = new RuleAsXmlSerializer();\n    final String xmlResponse = serializer.ruleMatchesToXml(matches, text, CONTEXT_SIZE, lang, motherTongue);\n    \n    String messageSent = \"sent\";\n    String languageMessage = lang.getShortNameWithCountryAndVariant();\n    final String referrer = httpExchange.getRequestHeaders().getFirst(\"Referer\");\n    try {\n      httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, xmlResponse.getBytes(ENCODING).length);\n      httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));\n      if (motherTongue != null) {\n        languageMessage += \" (mother tongue: \" + motherTongue.getShortNameWithCountryAndVariant() + \")\";\n      }\n    } catch (IOException exception) {\n      // the client is disconnected\n      messageSent = \"notSent: \" + exception.getMessage();\n    }\n    print(\"Check done: \" + text.length() + \" chars, \" + languageMessage + \", \" + referrer + \", \"\n            + \"handlers:\" + handleCount + \", \" + matches.size() + \" matches, \" + (System.currentTimeMillis() - timeStart) + \"ms\"\n            + \", \" + messageSent);\n  }","id":42805,"modified_method":"private void checkText(final String text, final HttpExchange httpExchange, final Map<String, String> parameters) throws Exception {\n    final long timeStart = System.currentTimeMillis();\n    if (text.length() > maxTextLength) {\n      throw new IllegalArgumentException(\"Text is \" + text.length() + \" characters long, exceeding maximum length of \" + maxTextLength);\n    }\n    //print(\"Check start: \" + text.length() + \" chars, \" + langParam);\n    final boolean autoDetectLanguage = getLanguageAutoDetect(parameters);\n    final Language lang = getLanguage(text, parameters.get(\"language\"), autoDetectLanguage);\n    final String motherTongueParam = parameters.get(\"motherTongue\");\n    final Language motherTongue = motherTongueParam != null ? Language.getLanguageForShortName(motherTongueParam) : null;\n    final boolean useEnabledOnly = \"yes\".equals(parameters.get(\"enabledOnly\"));\n    final String enabledParam = parameters.get(\"enabled\");\n    final List<String> enabledRules = new ArrayList<>();\n    if (enabledParam != null) {\n      enabledRules.addAll(Arrays.asList(enabledParam.split(\",\")));\n    }\n    \n    final String disabledParam = parameters.get(\"disabled\");\n    final List<String> disabledRules = new ArrayList<>();\n    if (disabledParam != null) {\n      disabledRules.addAll(Arrays.asList(disabledParam.split(\",\")));\n    }\n\n    if (disabledRules.size() > 0 && useEnabledOnly) {\n      throw new IllegalArgumentException(\"You cannot specify disabled rules using enabledOnly=yes\");\n    }\n    \n    final boolean useQuerySettings = enabledRules.size() > 0 || disabledRules.size() > 0;\n    final QueryParams params = new QueryParams(enabledRules, disabledRules, useEnabledOnly, useQuerySettings);\n    \n    final Future<List<RuleMatch>> future = executorService.submit(new Callable<List<RuleMatch>>() {\n      @Override\n      public List<RuleMatch> call() throws Exception {\n        return getRuleMatches(text, parameters, lang, motherTongue, params);\n      }\n    });\n    final List<RuleMatch> matches;\n    if (maxCheckTimeMillis < 0) {\n      matches = future.get();\n    } else {\n      try {\n        matches = future.get(maxCheckTimeMillis, TimeUnit.MILLISECONDS);\n      } catch (TimeoutException e) {\n        throw new RuntimeException(\"Text checking took longer than allowed maximum of \" + maxCheckTimeMillis +\n                \" milliseconds (handleCount: \" + handleCount + \", language: \" + lang.getShortNameWithCountryAndVariant() +\n                \", \" + text.length() + \" characters of text)\", e);\n      }\n    }\n    \n    setCommonHeaders(httpExchange);\n    String xmlResponse = getXmlResponse(text, lang, motherTongue, matches);\n    String messageSent = \"sent\";\n    String languageMessage = lang.getShortNameWithCountryAndVariant();\n    final String referrer = httpExchange.getRequestHeaders().getFirst(\"Referer\");\n    try {\n      httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, xmlResponse.getBytes(ENCODING).length);\n      httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));\n      if (motherTongue != null) {\n        languageMessage += \" (mother tongue: \" + motherTongue.getShortNameWithCountryAndVariant() + \")\";\n      }\n    } catch (IOException exception) {\n      // the client is disconnected\n      messageSent = \"notSent: \" + exception.getMessage();\n    }\n    print(\"Check done: \" + text.length() + \" chars, \" + languageMessage + \", \" + referrer + \", \"\n            + \"handlers:\" + handleCount + \", \" + matches.size() + \" matches, \" + (System.currentTimeMillis() - timeStart) + \"ms\"\n            + \", \" + messageSent);\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public void handle(HttpExchange httpExchange) throws IOException {\n    synchronized (this) {\n      handleCount++;\n    }\n    String text = null;\n    try {\n      final URI requestedUri = httpExchange.getRequestURI();\n      final String remoteAddress = httpExchange.getRemoteAddress().getAddress().getHostAddress();\n      // According to the Javadoc, \"Closing an exchange without consuming all of the request body is\n      // not an error but may make the underlying TCP connection unusable for following exchanges.\",\n      // so we consume the request now, even before checking for request limits:\n      final Map<String, String> parameters = getRequestQuery(httpExchange, requestedUri);\n      if (requestLimiter != null && !requestLimiter.isAccessOkay(remoteAddress)) {\n        final String errorMessage = \"Error: Access from \" + StringTools.escapeXML(remoteAddress) +\n                \" denied - too many requests. Allowed maximum requests: \" + requestLimiter.getRequestLimit() +\n                \" requests per \" + requestLimiter.getRequestLimitPeriodInSeconds() + \" seconds\";\n        sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);\n        print(errorMessage);\n        return;\n      }\n      if (allowedIps == null || allowedIps.contains(remoteAddress)) {\n        if (requestedUri.getRawPath().endsWith(\"/Languages\")) {\n          // request type: list known languages\n          printListOfLanguages(httpExchange);\n        } else {\n          // request type: text checking\n          text = parameters.get(\"text\");\n          if (text == null) {\n            throw new IllegalArgumentException(\"Missing 'text' parameter\");\n          }\n          checkText(text, httpExchange, parameters);\n        }\n      } else {\n        final String errorMessage = \"Error: Access from \" + StringTools.escapeXML(remoteAddress) + \" denied\";\n        sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);\n        throw new RuntimeException(errorMessage);\n      }\n    } catch (Exception e) {\n      print(\"An error has occurred. Stacktrace follows:\", System.err);\n      if (verbose) {\n        print(\"Exception was caused by this text: \" + text, System.err);\n      }\n      //noinspection CallToPrintStackTrace\n      e.printStackTrace();\n      final String response = \"Error: \" + StringTools.escapeXML(Tools.getFullStackTrace(e));\n      sendError(httpExchange, HttpURLConnection.HTTP_INTERNAL_ERROR, response);\n    } finally {\n      synchronized (this) {\n        handleCount--;\n      }\n      httpExchange.close();\n    }\n  }","id":42806,"modified_method":"@Override\n  public void handle(HttpExchange httpExchange) throws IOException {\n    synchronized (this) {\n      handleCount++;\n    }\n    String text = null;\n    try {\n      final URI requestedUri = httpExchange.getRequestURI();\n      final String remoteAddress = httpExchange.getRemoteAddress().getAddress().getHostAddress();\n      // According to the Javadoc, \"Closing an exchange without consuming all of the request body is\n      // not an error but may make the underlying TCP connection unusable for following exchanges.\",\n      // so we consume the request now, even before checking for request limits:\n      final Map<String, String> parameters = getRequestQuery(httpExchange, requestedUri);\n      if (requestLimiter != null && !requestLimiter.isAccessOkay(remoteAddress)) {\n        final String errorMessage = \"Error: Access from \" + StringTools.escapeXML(remoteAddress) +\n                \" denied - too many requests. Allowed maximum requests: \" + requestLimiter.getRequestLimit() +\n                \" requests per \" + requestLimiter.getRequestLimitPeriodInSeconds() + \" seconds\";\n        sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);\n        print(errorMessage);\n        return;\n      }\n      if (allowedIps == null || allowedIps.contains(remoteAddress)) {\n        if (requestedUri.getRawPath().endsWith(\"/Languages\")) {\n          // request type: list known languages\n          printListOfLanguages(httpExchange);\n        } else {\n          // request type: text checking\n          if (afterTheDeadlineMode) {\n            text = parameters.get(\"data\");\n            if (text == null) {\n              throw new IllegalArgumentException(\"Missing 'data' parameter\");\n            }\n            text = text.replaceAll(\"<\/p>\", \"\\n\\n\").replaceAll(\"<.*?>\", \"\");  // clean up HTML, position changes don't matter for AtD\n          } else {\n            text = parameters.get(\"text\");\n            if (text == null) {\n              throw new IllegalArgumentException(\"Missing 'text' parameter\");\n            }\n          }\n          checkText(text, httpExchange, parameters);\n        }\n      } else {\n        final String errorMessage = \"Error: Access from \" + StringTools.escapeXML(remoteAddress) + \" denied\";\n        sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);\n        throw new RuntimeException(errorMessage);\n      }\n    } catch (Exception e) {\n      print(\"An error has occurred. Stacktrace follows:\", System.err);\n      if (verbose) {\n        print(\"Exception was caused by this text: \" + text, System.err);\n      }\n      //noinspection CallToPrintStackTrace\n      e.printStackTrace();\n      final String response = \"Error: \" + StringTools.escapeXML(Tools.getFullStackTrace(e));\n      sendError(httpExchange, HttpURLConnection.HTTP_INTERNAL_ERROR, response);\n    } finally {\n      synchronized (this) {\n        handleCount--;\n      }\n      httpExchange.close();\n    }\n  }","commit_id":"535f1dcfc5d759851f5689fb89db8369ef318607","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n     * @param event the eviction event.\n     */\n    @NodeRemoved\n    public void nodeRemoved(NodeRemovedEvent event)\n    {\n        if (!event.getFqn().isChildOf(ROOT_FQN)) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(MessageFormat.format(\"The node {0} should not has been removed\", event.getFqn()));\n            }\n\n            return;\n        }\n\n        Map<String, T> data = event.getData();\n\n        String key = event.getFqn().getLastElementAsString();\n\n        if (event.isPre()) {\n            this.preEventData.put(key, data);\n        } else {\n            cacheEntryRemoved(key, this.preEventData.get(key).get(DATA_KEY));\n\n            this.preEventData.remove(key);\n        }\n    }","id":42807,"modified_method":"/**\n     * @param event the eviction event.\n     */\n    @NodeRemoved\n    public void nodeRemoved(NodeRemovedEvent event)\n    {\n        if (!event.getFqn().isChildOf(ROOT_FQN)) {\n            if (!event.getFqn().equals(ROOT_FQN)) {\n                LOG.info(MessageFormat.format(\n                    \"The [{0}] node has been removed but it should not even have been part of the cache\",\n                    event.getFqn()));\n            } else {\n                LOG.debug(\"The entire cache has been removed\");\n            }\n\n            return;\n        }\n\n        Map<String, T> data = event.getData();\n\n        String key = event.getFqn().getLastElementAsString();\n\n        if (event.isPre()) {\n            this.preEventData.put(key, data);\n        } else {\n            cacheEntryRemoved(key, this.preEventData.get(key).get(DATA_KEY));\n\n            this.preEventData.remove(key);\n        }\n    }","commit_id":"f6de009273d8abd881aea408be1c45027f1136fd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param event the eviction event.\n     */\n    @NodeEvicted\n    public void nodeEvicted(NodeEvictedEvent event)\n    {\n        if (!event.getFqn().isChildOf(ROOT_FQN)) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(MessageFormat.format(\"The node {0} should not has been evicted\", event.getFqn()));\n            }\n\n            return;\n        }\n\n        String key = event.getFqn().getLastElementAsString();\n\n        if (!event.isPre()) {\n            cacheEntryRemoved(key, null);\n        }\n    }","id":42808,"modified_method":"/**\n     * @param event the eviction event.\n     */\n    @NodeEvicted\n    public void nodeEvicted(NodeEvictedEvent event)\n    {\n        if (!event.getFqn().isChildOf(ROOT_FQN)) {\n            if (!event.getFqn().equals(ROOT_FQN)) {\n                LOG.warn(MessageFormat.format(\n                    \"The [{0}] node has been evicted but it should not even have been part of the cache\",\n                    event.getFqn()));\n            } else {\n                LOG.debug(\"The entire cache has been evicted\");\n            }\n\n            return;\n        }\n\n        String key = event.getFqn().getLastElementAsString();\n\n        if (!event.isPre()) {\n            cacheEntryRemoved(key, null);\n        }\n    }","commit_id":"f6de009273d8abd881aea408be1c45027f1136fd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void updateAMSConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n\n          Config amsEnv = cluster.getDesiredConfigByType(AMS_ENV);\n          if (amsEnv != null) {\n            Map<String, String> amsEnvProperties = amsEnv.getProperties();\n            String content = amsEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_ENV, newProperties, true, true);\n          }\n\n          String znodeParent = null;\n          Config amsHbaseSecuritySite = cluster.getDesiredConfigByType(AMS_HBASE_SECURITY_SITE);\n          if (amsHbaseSecuritySite != null) {\n            Map<String, String> amsHbaseSecuritySiteProperties = amsHbaseSecuritySite.getProperties();\n            znodeParent = amsHbaseSecuritySiteProperties.get(ZK_ZNODE_PARENT);\n            LOG.info(\"Removing config zookeeper.znode.parent from ams-hbase-security-site\");\n            removeConfigurationPropertiesFromCluster(cluster, AMS_HBASE_SECURITY_SITE, Collections.singleton(ZK_ZNODE_PARENT));\n          }\n\n          Config amsHbaseSite = cluster.getDesiredConfigByType(AMS_HBASE_SITE);\n          if (amsHbaseSite != null) {\n            Map<String, String> amsHbaseSiteProperties = amsHbaseSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            if (!amsHbaseSiteProperties.containsKey(ZK_ZNODE_PARENT)) {\n              if (StringUtils.isEmpty(znodeParent) || \"/hbase\".equals(znodeParent)) {\n                boolean isSecurityEnabled = false;\n                Config clusterEnv = cluster.getDesiredConfigByType(CLUSTER_ENV);\n                if (clusterEnv != null) {\n                  Map<String,String> clusterEnvProperties = clusterEnv.getProperties();\n                  if (clusterEnvProperties.containsKey(SECURITY_ENABLED)) {\n                    isSecurityEnabled = Boolean.valueOf(clusterEnvProperties.get(SECURITY_ENABLED));\n                  }\n                }\n                znodeParent = \"/ams-hbase-\" + (isSecurityEnabled ? \"secure\" : \"unsecure\");\n              }\n\n              LOG.info(\"Adding config zookeeper.znode.parent=\" + znodeParent + \" to ams-hbase-site\");\n              newProperties.put(ZK_ZNODE_PARENT, znodeParent);\n\n            }\n            if (amsHbaseSiteProperties.containsKey(ZK_CLIENT_PORT)) {\n              String newValue = \"{{zookeeper_clientPort}}\";\n              LOG.info(\"Replacing value of hbase.zookeeper.property.clientPort from \" +\n                amsHbaseSiteProperties.get(ZK_CLIENT_PORT) + \" to \" + newValue);\n\n              newProperties.put(ZK_CLIENT_PORT, newValue);\n            }\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_SITE, newProperties, true, true);\n          }\n\n          Config amsHbaseEnv = cluster.getDesiredConfigByType(AMS_HBASE_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsHbaseEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsHbaseEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_ENV, newProperties, true, true);\n          }\n        }\n      }\n    }\n  }","id":42809,"modified_method":"protected void updateAMSConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n\n          Config amsEnv = cluster.getDesiredConfigByType(AMS_ENV);\n          if (amsEnv != null) {\n            Map<String, String> amsEnvProperties = amsEnv.getProperties();\n            String content = amsEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_ENV, newProperties, true, true);\n          }\n\n          String znodeParent = null;\n          Config amsHbaseSecuritySite = cluster.getDesiredConfigByType(AMS_HBASE_SECURITY_SITE);\n          if (amsHbaseSecuritySite != null) {\n            Map<String, String> amsHbaseSecuritySiteProperties = amsHbaseSecuritySite.getProperties();\n            znodeParent = amsHbaseSecuritySiteProperties.get(ZK_ZNODE_PARENT);\n            LOG.info(\"Removing config zookeeper.znode.parent from ams-hbase-security-site\");\n            removeConfigurationPropertiesFromCluster(cluster, AMS_HBASE_SECURITY_SITE, Collections.singleton(ZK_ZNODE_PARENT));\n          }\n\n          Config amsHbaseSite = cluster.getDesiredConfigByType(AMS_HBASE_SITE);\n          if (amsHbaseSite != null) {\n            Map<String, String> amsHbaseSiteProperties = amsHbaseSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            if (!amsHbaseSiteProperties.containsKey(ZK_ZNODE_PARENT)) {\n              if (StringUtils.isEmpty(znodeParent) || \"/hbase\".equals(znodeParent)) {\n                boolean isSecurityEnabled = false;\n                Config clusterEnv = cluster.getDesiredConfigByType(CLUSTER_ENV);\n                if (clusterEnv != null) {\n                  Map<String,String> clusterEnvProperties = clusterEnv.getProperties();\n                  if (clusterEnvProperties.containsKey(SECURITY_ENABLED)) {\n                    isSecurityEnabled = Boolean.valueOf(clusterEnvProperties.get(SECURITY_ENABLED));\n                  }\n                }\n                znodeParent = \"/ams-hbase-\" + (isSecurityEnabled ? \"secure\" : \"unsecure\");\n              }\n\n              LOG.info(\"Adding config zookeeper.znode.parent=\" + znodeParent + \" to ams-hbase-site\");\n              newProperties.put(ZK_ZNODE_PARENT, znodeParent);\n\n            }\n\n            boolean isDistributed = false;\n            Config amsSite = cluster.getDesiredConfigByType(AMS_SITE);\n            if (amsSite != null) {\n              if (\"distributed\".equals(amsSite.getProperties().get(AMS_MODE))) {\n                isDistributed = true;\n              }\n            }\n\n            // Skip override if custom port found in embedded mode.\n            if (amsHbaseSiteProperties.containsKey(ZK_CLIENT_PORT) &&\n               (isDistributed || amsHbaseSiteProperties.get(ZK_CLIENT_PORT).equals(\"61181\"))) {\n              String newValue = \"{{zookeeper_clientPort}}\";\n              LOG.info(\"Replacing value of \" + ZK_CLIENT_PORT + \" from \" +\n                amsHbaseSiteProperties.get(ZK_CLIENT_PORT) + \" to \" +\n                newValue + \" in ams-hbase-site\");\n\n              newProperties.put(ZK_CLIENT_PORT, newValue);\n            }\n\n            if (!amsHbaseSiteProperties.containsKey(ZK_TICK_TIME)) {\n              LOG.info(\"Adding config \" + ZK_TICK_TIME + \" to ams-hbase-site\");\n              newProperties.put(ZK_TICK_TIME, \"6000\");\n            }\n\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_SITE, newProperties, true, true);\n          }\n\n          Config amsHbaseEnv = cluster.getDesiredConfigByType(AMS_HBASE_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsHbaseEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsHbaseEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_ENV, newProperties, true, true);\n          }\n        }\n      }\n    }\n  }","commit_id":"55651a9b93e442ecb5cec2eb6226711845c92de2","url":"https://github.com/apache/ambari"},{"original_method":"private void testAmsHbaseSiteUpdates(Map<String, String> oldPropertiesAmsHbaseSite,\n                                       Map<String, String> newPropertiesAmsHbaseSite,\n                                       Map<String, String> amsHbaseSecuritySiteProperties,\n                                       Map<String, String> clusterEnvProperties ) throws AmbariException {\n\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n\n    Config mockAmsHbaseSite = easyMockSupport.createNiceMock(Config.class);\n    expect(cluster.getDesiredConfigByType(\"ams-hbase-site\")).andReturn(mockAmsHbaseSite).atLeastOnce();\n    expect(mockAmsHbaseSite.getProperties()).andReturn(oldPropertiesAmsHbaseSite).times(2);\n\n    Config mockAmsHbaseSecuritySite = easyMockSupport.createNiceMock(Config.class);\n    expect(cluster.getDesiredConfigByType(\"ams-hbase-security-site\")).andReturn(mockAmsHbaseSecuritySite).anyTimes();\n    expect(mockAmsHbaseSecuritySite.getProperties()).andReturn(amsHbaseSecuritySiteProperties).anyTimes();\n\n    Config clusterEnv = easyMockSupport.createNiceMock(Config.class);\n    expect(cluster.getDesiredConfigByType(\"cluster-env\")).andReturn(clusterEnv).anyTimes();\n    expect(clusterEnv.getProperties()).andReturn(clusterEnvProperties).anyTimes();\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsHbaseSite, mockAmsHbaseSecuritySite, clusterEnv, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .addMockedMethod(\"createConfig\")\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<Map> propertiesCapture = EasyMock.newCapture();\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfig(anyObject(Cluster.class), anyString(), capture(propertiesCapture), anyString(),\n      anyObject(Map.class))).andReturn(createNiceMock(Config.class)).anyTimes();\n\n    replay(controller, injector2);\n    new UpgradeCatalog221(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    Map<String, String> updatedProperties = propertiesCapture.getValue();\n    assertTrue(Maps.difference(newPropertiesAmsHbaseSite, updatedProperties).areEqual());\n  }","id":42810,"modified_method":"private void testAmsHbaseSiteUpdates(Map<String, String> oldPropertiesAmsHbaseSite,\n                                       Map<String, String> newPropertiesAmsHbaseSite,\n                                       Map<String, String> amsHbaseSecuritySiteProperties,\n                                       Map<String, String> clusterEnvProperties ) throws AmbariException {\n\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n\n    Config mockAmsHbaseSite = easyMockSupport.createNiceMock(Config.class);\n    expect(cluster.getDesiredConfigByType(\"ams-hbase-site\")).andReturn(mockAmsHbaseSite).atLeastOnce();\n    expect(mockAmsHbaseSite.getProperties()).andReturn(oldPropertiesAmsHbaseSite).times(2);\n\n    Config mockAmsHbaseSecuritySite = easyMockSupport.createNiceMock(Config.class);\n    expect(cluster.getDesiredConfigByType(\"ams-hbase-security-site\")).andReturn(mockAmsHbaseSecuritySite).anyTimes();\n    expect(mockAmsHbaseSecuritySite.getProperties()).andReturn(amsHbaseSecuritySiteProperties).anyTimes();\n\n    Config clusterEnv = easyMockSupport.createNiceMock(Config.class);\n    expect(cluster.getDesiredConfigByType(\"cluster-env\")).andReturn(clusterEnv).anyTimes();\n    expect(clusterEnv.getProperties()).andReturn(clusterEnvProperties).anyTimes();\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsHbaseSite, mockAmsHbaseSecuritySite, clusterEnv, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .addMockedMethod(\"createConfig\")\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<Map> propertiesCapture = EasyMock.newCapture();\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfig(anyObject(Cluster.class), anyString(), capture(propertiesCapture), anyString(),\n      anyObject(Map.class))).andReturn(createNiceMock(Config.class)).anyTimes();\n\n    replay(controller, injector2);\n    new UpgradeCatalog221(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    Map<String, String> updatedProperties = propertiesCapture.getValue();\n    // Test zookeeper tick time setting\n    String tickTime = updatedProperties.remove(\"hbase.zookeeper.property.tickTime\");\n    assertEquals(\"6000\", tickTime);\n    assertTrue(Maps.difference(newPropertiesAmsHbaseSite, updatedProperties).areEqual());\n  }","commit_id":"55651a9b93e442ecb5cec2eb6226711845c92de2","url":"https://github.com/apache/ambari"},{"original_method":"public void updateFrom(final CvsRootConfiguration configuration) {\n    setEnabled(true);\n    myIsInUpdating.setValue(true);\n    try {\n      myCvsRootConfigurationPanelView.updateFrom(configuration);\n      myExtConnectionSettingsEditor.updateFrom(configuration.EXT_CONFIGURATION, configuration.SSH_FOR_EXT_CONFIGURATION);\n      mySshConnectionSettingsEditor.updateFrom(configuration.SSH_CONFIGURATION);\n      myDateOrRevisionOrTagSettings.updateFrom(configuration.DATE_OR_REVISION_SETTINGS);\n      myLocalConnectionSettingsPanel.updateFrom(configuration.LOCAL_CONFIGURATION);\n      myProxySettingsNonEmptyPanel.updateFrom(configuration.PROXY_SETTINGS);\n    }\n    finally {\n      myIsInUpdating.setValue(false);\n    }\n    setExtPanelEnabling();\n  }","id":42811,"modified_method":"public void updateFrom(final CvsRootConfiguration configuration) {\n    setEnabled(true);\n    myIsUpdating.set(Boolean.TRUE);\n    try {\n      myCvsRootConfigurationPanelView.updateFrom(configuration);\n      myExtConnectionSettingsEditor.updateFrom(configuration.EXT_CONFIGURATION, configuration.SSH_FOR_EXT_CONFIGURATION);\n      mySshConnectionSettingsEditor.updateFrom(configuration.SSH_CONFIGURATION);\n      myDateOrRevisionOrTagSettings.updateFrom(configuration.DATE_OR_REVISION_SETTINGS);\n      myLocalConnectionSettingsPanel.updateFrom(configuration.LOCAL_CONFIGURATION);\n      myProxySettingsNonEmptyPanel.updateFrom(configuration.PROXY_SETTINGS);\n    }\n    finally {\n      myIsUpdating.set(null);\n    }\n    setExtPanelEnabling();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void testConfiguration() {\n    CvsRootConfiguration newConfiguration = createConfigurationWithCurrentSettings();\n    if (newConfiguration == null) return;\n    testConnection(newConfiguration, myPanel, myProject);\n    updateFrom(newConfiguration);\n  }","id":42812,"modified_method":"private void testConfiguration() {\n    final CvsRootConfiguration newConfiguration = createConfigurationWithCurrentSettings();\n    if (newConfiguration == null) return;\n    testConnection(newConfiguration, myPanel, myProject);\n    updateFrom(newConfiguration);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setEnabled(Component component, boolean enabled) {\n    component.setEnabled(enabled);\n\n    if (component instanceof Container) {\n      Container container = (Container)component;\n      for (int i = 0; i < container.getComponentCount(); i++) {\n        setEnabled(container.getComponent(i), enabled);\n      }\n    }\n  }","id":42813,"modified_method":"private static void setEnabled(Component component, boolean enabled) {\n    component.setEnabled(enabled);\n\n    if (component instanceof Container) {\n      final Container container = (Container)component;\n      for (int i = 0; i < container.getComponentCount(); i++) {\n        setEnabled(container.getComponent(i), enabled);\n      }\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getSettingsPanelName(CvsRootData cvsRootData) {\n    CvsMethod method = cvsRootData.METHOD;\n    if (method == null) {\n      return EMPTY;\n    }\n    else {\n      return method.getDisplayName();\n    }\n  }","id":42814,"modified_method":"private static String getSettingsPanelName(CvsRootData cvsRootData) {\n    final CvsMethod method = cvsRootData.METHOD;\n    if (method == null) {\n      return EMPTY;\n    }\n    else {\n      return method.getDisplayName();\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void testConnection(final CvsRootConfiguration configuration, final Component component, Project project) {\n    final CvsLoginWorker loginWorker = configuration.getLoginWorker(project);\n    final Ref<Boolean> success = new Ref<Boolean>();\n    ProgressManager.getInstance().run(new Task.Modal(project, CvsBundle.message(\"message.connecting.to.cvs.server\"), false) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        indicator.setText2(CvsBundle.message(\"message.current.global.timeout.setting\",\n                                             CvsApplicationLevelConfiguration.getInstance().TIMEOUT));\n        try {\n          final ThreeState checkResult = LoginPerformer.checkLoginWorker(loginWorker, true);\n          if (ThreeState.NO.equals(checkResult)) {\n            showConnectionFailedMessage(component, CvsBundle.message(\"test.connection.login.failed.text\"));\n          } else if (ThreeState.UNSURE.equals(checkResult)) {\n            showConnectionFailedMessage(component, CvsBundle.message(\"error.message.authentication.canceled\"));\n          } else {\n            success.set(Boolean.TRUE);\n          }\n        }\n        catch (ProcessCanceledException ignore) {}\n        catch (final Exception e) {\n          showConnectionFailedMessage(component, e.getLocalizedMessage());\n        }\n      }\n    });\n    if (success.get() != Boolean.TRUE) return;\n    try{\n      configuration.testConnection(project);\n      showSuccessfulConnectionMessage(component);\n    }\n    catch (ProcessCanceledException ignore) {}\n    catch (final Exception e) {\n      showConnectionFailedMessage(component, e.getLocalizedMessage());\n    }\n  }","id":42815,"modified_method":"private static void testConnection(final CvsRootConfiguration configuration, final Component component, Project project) {\n    final CvsLoginWorker loginWorker = configuration.getLoginWorker(project);\n    final Ref<Boolean> success = new Ref<Boolean>();\n    ProgressManager.getInstance().run(new Task.Modal(project, CvsBundle.message(\"message.connecting.to.cvs.server\"), false) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        indicator.setText2(CvsBundle.message(\"message.current.global.timeout.setting\",\n                                             CvsApplicationLevelConfiguration.getInstance().TIMEOUT));\n        try {\n          final ThreeState result = LoginPerformer.checkLoginWorker(loginWorker, true);\n          if (ThreeState.NO == result) {\n            showConnectionFailedMessage(component, CvsBundle.message(\"test.connection.login.failed.text\"));\n          } else if (ThreeState.UNSURE == result) {\n            showConnectionFailedMessage(component, CvsBundle.message(\"error.message.authentication.canceled\"));\n          } else {\n            success.set(Boolean.TRUE);\n          }\n        }\n        catch (ProcessCanceledException ignore) {}\n        catch (final Exception e) {\n          showConnectionFailedMessage(component, e.getLocalizedMessage());\n        }\n      }\n    });\n    if (success.get() != Boolean.TRUE) return;\n    try{\n      configuration.testConnection(project);\n      showSuccessfulConnectionMessage(component);\n    }\n    catch (ProcessCanceledException ignore) {}\n    catch (final Exception e) {\n      showConnectionFailedMessage(component, e.getLocalizedMessage());\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean saveTo(CvsRootConfiguration configuration) {\n    try {\n      myCvsRootConfigurationPanelView.saveTo(configuration);\n      CvsApplicationLevelConfiguration globalCvsSettings = CvsApplicationLevelConfiguration.getInstance();\n\n      if (!myExtConnectionSettingsEditor.equalsTo(configuration.EXT_CONFIGURATION, configuration.SSH_FOR_EXT_CONFIGURATION)) {\n        myExtConnectionSettingsEditor.saveTo(configuration.EXT_CONFIGURATION, configuration.SSH_FOR_EXT_CONFIGURATION);\n        myExtConnectionSettingsEditor.saveTo(globalCvsSettings.EXT_CONFIGURATION, globalCvsSettings.SSH_FOR_EXT_CONFIGURATION);\n      }\n\n      if (!mySshConnectionSettingsEditor.equalsTo(configuration.SSH_CONFIGURATION)) {\n        mySshConnectionSettingsEditor.saveTo(configuration.SSH_CONFIGURATION);\n        mySshConnectionSettingsEditor.saveTo(globalCvsSettings.SSH_CONFIGURATION);\n      }\n\n      if (!myLocalConnectionSettingsPanel.equalsTo(configuration.LOCAL_CONFIGURATION)) {\n        myLocalConnectionSettingsPanel.saveTo(configuration.LOCAL_CONFIGURATION);\n        myLocalConnectionSettingsPanel.saveTo(globalCvsSettings.LOCAL_CONFIGURATION);\n      }\n\n      if (!myProxySettingsNonEmptyPanel.equalsTo(configuration.PROXY_SETTINGS)) {\n        myProxySettingsNonEmptyPanel.saveTo(configuration.PROXY_SETTINGS);\n        myProxySettingsNonEmptyPanel.saveTo(globalCvsSettings.PROXY_SETTINGS);\n      }\n      myDateOrRevisionOrTagSettings.saveTo(configuration.DATE_OR_REVISION_SETTINGS);\n      return true;\n    }\n    catch (InputException ex) {\n      ex.show();\n      return false;\n    }\n  }","id":42816,"modified_method":"public boolean saveTo(CvsRootConfiguration configuration) {\n    try {\n      myCvsRootConfigurationPanelView.saveTo(configuration);\n      final CvsApplicationLevelConfiguration globalCvsSettings = CvsApplicationLevelConfiguration.getInstance();\n\n      if (!myExtConnectionSettingsEditor.equalsTo(configuration.EXT_CONFIGURATION, configuration.SSH_FOR_EXT_CONFIGURATION)) {\n        myExtConnectionSettingsEditor.saveTo(configuration.EXT_CONFIGURATION, configuration.SSH_FOR_EXT_CONFIGURATION);\n        myExtConnectionSettingsEditor.saveTo(globalCvsSettings.EXT_CONFIGURATION, globalCvsSettings.SSH_FOR_EXT_CONFIGURATION);\n      }\n\n      if (!mySshConnectionSettingsEditor.equalsTo(configuration.SSH_CONFIGURATION)) {\n        mySshConnectionSettingsEditor.saveTo(configuration.SSH_CONFIGURATION);\n        mySshConnectionSettingsEditor.saveTo(globalCvsSettings.SSH_CONFIGURATION);\n      }\n\n      if (!myLocalConnectionSettingsPanel.equalsTo(configuration.LOCAL_CONFIGURATION)) {\n        myLocalConnectionSettingsPanel.saveTo(configuration.LOCAL_CONFIGURATION);\n        myLocalConnectionSettingsPanel.saveTo(globalCvsSettings.LOCAL_CONFIGURATION);\n      }\n\n      if (!myProxySettingsNonEmptyPanel.equalsTo(configuration.PROXY_SETTINGS)) {\n        myProxySettingsNonEmptyPanel.saveTo(configuration.PROXY_SETTINGS);\n        myProxySettingsNonEmptyPanel.saveTo(globalCvsSettings.PROXY_SETTINGS);\n      }\n      myDateOrRevisionOrTagSettings.saveTo(configuration.DATE_OR_REVISION_SETTINGS);\n      return true;\n    }\n    catch (InputException ex) {\n      ex.show();\n      return false;\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setExtPanelEnabling() {\n    try {\n      CvsRootData currentRootData = CvsRootDataBuilder.createSettingsOn(myCvsRootConfigurationPanelView.getCvsRoot(), true);\n      String settingsPanelName = getSettingsPanelName(currentRootData);\n      ((CardLayout)myConnectionSettingsPanel.getLayout()).show(myConnectionSettingsPanel, settingsPanelName);\n\n      ((CardLayout)myProxySettingsPanel.getLayout()).show(myProxySettingsPanel, getProxyPanelName(currentRootData));\n\n\n      if (currentRootData.CONTAINS_PROXY_INFO) {\n        myProxySettingsNonEmptyPanel.updateFrom(currentRootData);\n        myProxySettingsNonEmptyPanel.disablePanel();\n      }\n      else {\n        myProxySettingsNonEmptyPanel.enablePanel();\n      }\n\n    }\n    catch (Throwable ignored) {\n      ((CardLayout)myConnectionSettingsPanel.getLayout()).show(myConnectionSettingsPanel, EMPTY);\n\n      ((CardLayout)myProxySettingsPanel.getLayout()).show(myProxySettingsPanel, EMPTY);\n\n    }\n  }","id":42817,"modified_method":"private void setExtPanelEnabling() {\n    try {\n      final CvsRootData currentRootData = CvsRootDataBuilder.createSettingsOn(myCvsRootConfigurationPanelView.getCvsRoot(), true);\n      final String settingsPanelName = getSettingsPanelName(currentRootData);\n      ((CardLayout)myConnectionSettingsPanel.getLayout()).show(myConnectionSettingsPanel, settingsPanelName);\n      ((CardLayout)myProxySettingsPanel.getLayout()).show(myProxySettingsPanel, getProxyPanelName(currentRootData));\n\n      if (currentRootData.CONTAINS_PROXY_INFO) {\n        myProxySettingsNonEmptyPanel.updateFrom(currentRootData);\n        myProxySettingsNonEmptyPanel.disablePanel();\n      }\n      else {\n        myProxySettingsNonEmptyPanel.enablePanel();\n      }\n    }\n    catch (Throwable ignored) {\n      ((CardLayout)myConnectionSettingsPanel.getLayout()).show(myConnectionSettingsPanel, EMPTY);\n      ((CardLayout)myProxySettingsPanel.getLayout()).show(myProxySettingsPanel, EMPTY);\n\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void clearAllTextFieldsIn(Component component) {\n    if (component instanceof JTextField) {\n      ((JTextField)component).setText(\"\");\n      return;\n    }\n    if (component instanceof Container) {\n      Container container = (Container)component;\n      for (int i = 0; i < container.getComponentCount(); i++) {\n        clearAllTextFieldsIn(container.getComponent(i));\n      }\n    }\n  }","id":42818,"modified_method":"private static void clearAllTextFieldsIn(Component component) {\n    if (component instanceof JTextField) {\n      ((JTextField)component).setText(\"\");\n      return;\n    }\n    if (component instanceof Container) {\n      final Container container = (Container)component;\n      for (int i = 0; i < container.getComponentCount(); i++) {\n        clearAllTextFieldsIn(container.getComponent(i));\n      }\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private CvsRootConfiguration createConfigurationWithCurrentSettings() {\n    CvsRootConfiguration newConfiguration =\n      CvsApplicationLevelConfiguration.createNewConfiguration(CvsApplicationLevelConfiguration.getInstance());\n    if (!saveTo(newConfiguration)) return null;\n    return newConfiguration;\n  }","id":42819,"modified_method":"@Nullable\n  private CvsRootConfiguration createConfigurationWithCurrentSettings() {\n    final CvsRootConfiguration newConfiguration =\n      CvsApplicationLevelConfiguration.createNewConfiguration(CvsApplicationLevelConfiguration.getInstance());\n    if (!saveTo(newConfiguration)) return null;\n    return newConfiguration;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void disable() {\n    clearAllTextFields();\n    setEnabled(false);\n  }","id":42820,"modified_method":"public void disable() {\n    clearAllTextFieldsIn(myPanel);\n    setEnabled(false);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Cvs2SettingsEditPanel(Project project) {\n    myProject = project;\n    myDateOrRevisionOrTagSettings = new DateOrRevisionOrTagSettings(new TagsProviderOnEnvironment() {\n      @Override\n      @Nullable\n      protected CvsEnvironment getCvsEnvironment() {\n        return createConfigurationWithCurrentSettings();\n      }\n    }, project);\n    myPanel.setSize(myPanel.getPreferredSize());\n    myCvsRootConfigurationPanel.setLayout(new BorderLayout());\n    myCvsRootConfigurationPanel.add(myCvsRootConfigurationPanelView.getPanel(), BorderLayout.CENTER);\n\n    myConnectionSettingsPanel.setLayout(new CardLayout());\n    myExtConnectionSettingsEditor = new ExtConnectionDualPanel();\n    mySshConnectionSettingsEditor = new SshConnectionSettingsPanel();\n    myLocalConnectionSettingsPanel = new LocalConnectionSettingsPanel();\n    myConnectionSettingsPanel.add(myExtConnectionSettingsEditor.getPanel(), CvsMethod.EXT_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(new JPanel(), CvsMethod.PSERVER_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(mySshConnectionSettingsEditor.getPanel(), CvsMethod.SSH_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(myLocalConnectionSettingsPanel.getPanel(), CvsMethod.LOCAL_METHOD.getDisplayName());\n\n    myConnectionSettingsPanel.add(new JPanel(), EMPTY);\n\n    myDateOrRevisionOrTagSettingsPanel.setLayout(new BorderLayout(4, 2));\n    myDateOrRevisionOrTagSettingsPanel.add(myDateOrRevisionOrTagSettings.getPanel(), BorderLayout.CENTER);\n\n    myTestButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if (!myPanel.isEnabled()) return;\n        testConfiguration();\n      }\n    });\n\n    addCvsRootChangeListener(new CvsRootChangeListener() {\n      @Override\n      public void onCvsRootChanged() {\n        setExtPanelEnabling();\n      }\n    });\n\n    myProxySettingsPanel.setLayout(new CardLayout());\n\n    myProxySettingsNonEmptyPanel = new ProxySettingsPanel();\n\n    myProxySettingsPanel.add(myProxySettingsNonEmptyPanel.getPanel(), NON_EMPTY_PROXY_SETTINGS);\n    myProxySettingsPanel.add(new JPanel(), EMPTY);\n  }","id":42821,"modified_method":"public Cvs2SettingsEditPanel(Project project, boolean readOnly) {\n    myProject = project;\n    myDateOrRevisionOrTagSettings = new DateOrRevisionOrTagSettings(new TagsProviderOnEnvironment() {\n      @Override\n      @Nullable\n      protected CvsEnvironment getCvsEnvironment() {\n        return createConfigurationWithCurrentSettings();\n      }\n    }, project);\n    myPanel.setSize(myPanel.getPreferredSize());\n    myCvsRootConfigurationPanel.setLayout(new BorderLayout());\n    myCvsRootConfigurationPanelView = new CvsRootAsStringConfigurationPanel(readOnly, myIsUpdating);\n    myCvsRootConfigurationPanel.add(myCvsRootConfigurationPanelView.getPanel(), BorderLayout.CENTER);\n\n    myConnectionSettingsPanel.setLayout(new CardLayout());\n    myExtConnectionSettingsEditor = new ExtConnectionDualPanel();\n    mySshConnectionSettingsEditor = new SshConnectionSettingsPanel();\n    myLocalConnectionSettingsPanel = new LocalConnectionSettingsPanel();\n    myConnectionSettingsPanel.add(myExtConnectionSettingsEditor.getPanel(), CvsMethod.EXT_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(new JPanel(), CvsMethod.PSERVER_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(mySshConnectionSettingsEditor.getPanel(), CvsMethod.SSH_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(myLocalConnectionSettingsPanel.getPanel(), CvsMethod.LOCAL_METHOD.getDisplayName());\n    myConnectionSettingsPanel.add(new JPanel(), EMPTY);\n\n    myDateOrRevisionOrTagSettingsPanel.setLayout(new BorderLayout(4, 2));\n    myDateOrRevisionOrTagSettingsPanel.add(myDateOrRevisionOrTagSettings.getPanel(), BorderLayout.CENTER);\n\n    myTestButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if (!myPanel.isEnabled()) return;\n        testConfiguration();\n      }\n    });\n\n    addCvsRootChangeListener(new CvsRootChangeListener() {\n      @Override\n      public void onCvsRootChanged() {\n        setExtPanelEnabling();\n      }\n    });\n\n    myProxySettingsPanel.setLayout(new CardLayout());\n    myProxySettingsNonEmptyPanel = new ProxySettingsPanel();\n    myProxySettingsPanel.add(myProxySettingsNonEmptyPanel.getPanel(), NON_EMPTY_PROXY_SETTINGS);\n    myProxySettingsPanel.add(new JPanel(), EMPTY);\n\n    if (readOnly) setEnabled(myDateOrRevisionOrTagSettingsPanel, false);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createListPanel() {\n    return ScrollPaneFactory.createScrollPane(myList);\n  }","id":42822,"modified_method":"private JComponent createListPanel() {\n    final AnActionButton duplicateButton =\n      new AnActionButton(CvsBundle.message(\"action.name.copy\"), IconLoader.getIcon(\"/general/copy.png\")) {\n\n        @Override\n        public void updateButton(AnActionEvent e) {\n          e.getPresentation().setEnabled(getSelectedConfiguration() != null);\n        }\n\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          copySelectedConfiguration();\n        }\n      };\n    duplicateButton.setShortcut(new CustomShortcutSet(\n      KeyStroke.getKeyStroke(KeyEvent.VK_D, SystemInfo.isMac ? KeyEvent.META_MASK : KeyEvent.CTRL_MASK)));\n    final ToolbarDecorator decorator = ToolbarDecorator.createDecorator(myList).setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton anActionButton) {\n        createNewConfiguration();\n      }\n    }).addExtraAction(duplicateButton);\n    return decorator.createPanel();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void selectNone() {\n    myCvs2SettingsEditPanel.disable();\n    mySelection = null;\n  }","id":42823,"modified_method":"private void selectNone() {\n    mySelection = null;\n    myCvs2SettingsEditPanel.disable();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createNewConfiguration() {\n    if (!saveSelectedConfiguration()) return;\n    myList.setSelectedValue(null, false);\n    CvsRootConfiguration newConfig = CvsApplicationLevelConfiguration.createNewConfiguration(CvsApplicationLevelConfiguration.getInstance());\n    myModel.addElement(newConfig);\n    myList.setSelectedValue(newConfig, true);\n  }","id":42824,"modified_method":"private void createNewConfiguration() {\n    if (!saveSelectedConfiguration()) return;\n    myList.setSelectedValue(null, false);\n    final CvsRootConfiguration newConfig =\n      CvsApplicationLevelConfiguration.createNewConfiguration(CvsApplicationLevelConfiguration.getInstance());\n    myModel.addElement(newConfig);\n    myList.setSelectedValue(newConfig, true);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addSelectionListener() {\n    myList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        int selectedIndex = myList.getSelectedIndex();\n        if (selectedIndex < 0 || selectedIndex >= myModel.getSize()) {\n          selectNone();\n        }\n        else {\n          CvsRootConfiguration newSelection = (CvsRootConfiguration)myModel.getElementAt(selectedIndex);\n          if (newSelection == mySelection) return;\n          if (!select(newSelection)) {\n            myList.setSelectedValue(mySelection, true);\n          }\n        }\n      }\n    });\n  }","id":42825,"modified_method":"private void addSelectionListener() {\n    myList.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        final int selectedIndex = myList.getSelectedIndex();\n        if (selectedIndex < 0 || selectedIndex >= myModel.getSize()) {\n          selectNone();\n        }\n        else {\n          final CvsRootConfiguration newSelection = (CvsRootConfiguration)myModel.getElementAt(selectedIndex);\n          if (newSelection == mySelection) return;\n          if (!select(newSelection)) {\n            myList.setSelectedValue(mySelection, true);\n          }\n        }\n      }\n    });\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ArrayList<CvsRootConfiguration> getConfigurations() {\n    ArrayList<CvsRootConfiguration> result = new ArrayList<CvsRootConfiguration>();\n    Enumeration each = myModel.elements();\n    while (each.hasMoreElements()) result.add((CvsRootConfiguration)each.nextElement());\n    return result;\n  }","id":42826,"modified_method":"public List<CvsRootConfiguration> getConfigurations() {\n    final ArrayList<CvsRootConfiguration> result = new ArrayList<CvsRootConfiguration>();\n    final Enumeration each = myModel.elements();\n    while (each.hasMoreElements()) result.add((CvsRootConfiguration)each.nextElement());\n    return result;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean select(CvsRootConfiguration cvs2Configuration) {\n    if (mySelection != null) {\n      if (!myCvs2SettingsEditPanel.saveTo(mySelection)) {\n        return false;\n      }\n    }\n    mySelection = cvs2Configuration;\n    editSelectedConfiguration();\n    return true;\n  }","id":42827,"modified_method":"private boolean select(CvsRootConfiguration cvs2Configuration) {\n    if (mySelection != null && !myCvs2SettingsEditPanel.saveTo(mySelection)) return false;\n    mySelection = cvs2Configuration;\n    editSelectedConfiguration();\n    return true;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void copySelectedConfiguration() {\n    if (!saveSelectedConfiguration()) return;\n    CvsRootConfiguration newConfig = mySelection.getMyCopy();\n    myModel.addElement(newConfig);\n    myList.setSelectedValue(newConfig, true);\n  }","id":42828,"modified_method":"private void copySelectedConfiguration() {\n    if (!saveSelectedConfiguration()) return;\n    final CvsRootConfiguration newConfig = mySelection.getMyCopy();\n    myModel.addElement(newConfig);\n    myList.setSelectedIndex(myModel.getSize() - 1);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected Action[] createLeftSideActions() {\n    AbstractAction globalSettingsAction = new AbstractAction(CvsBundle.message(\"button.text.global.settings\")) {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        new ConfigureCvsGlobalSettingsDialog().show();\n      }\n    };\n    return new Action[]{globalSettingsAction};\n  }","id":42829,"modified_method":"@Override\n  protected Action[] createLeftSideActions() {\n    final AbstractAction globalSettingsAction = new AbstractAction(CvsBundle.message(\"button.text.global.settings\")) {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        new ConfigureCvsGlobalSettingsDialog().show();\n      }\n    };\n    return new Action[]{globalSettingsAction};\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected JComponent createCenterPanel() {\n    myList.setCellRenderer(new CvsListCellRenderer());\n\n    myCenterPanelLayout.setHgap(6);\n\n    myCenterPanel.add(createActionsPanel(), BorderLayout.NORTH);\n    JComponent listPanel = createListPanel();\n\n    myCenterPanel.add(listPanel, BorderLayout.CENTER);\n    myCenterPanel.add(createCvsConfigurationPanel(), BorderLayout.EAST);\n    myCenterPanel.add(new JSeparator(JSeparator.HORIZONTAL), BorderLayout.SOUTH);\n\n    myList.setModel(myModel);\n\n    addSelectionListener();\n\n\n    int minWidth = myList.getFontMetrics(myList.getFont()).stringWidth(SAMPLE_CVSROOT) + 40;\n    Dimension minSize = new Dimension(minWidth, myList.getMaximumSize().height);\n    listPanel.setMinimumSize(minSize);\n    listPanel.setPreferredSize(minSize);\n    return myCenterPanel;\n  }","id":42830,"modified_method":"@Override\n  protected JComponent createCenterPanel() {\n    myList.setCellRenderer(new CvsListCellRenderer());\n    final BorderLayout layout = new BorderLayout();\n    layout.setHgap(6);\n\n    final JPanel centerPanel = new JPanel(layout);\n    final JComponent listPanel = createListPanel();\n    centerPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));\n    centerPanel.add(listPanel, BorderLayout.CENTER);\n    centerPanel.add(createCvsConfigurationPanel(), BorderLayout.EAST);\n\n    myList.setModel(myModel);\n    addSelectionListener();\n\n\n    final int minWidth = myList.getFontMetrics(myList.getFont()).stringWidth(SAMPLE_CVSROOT) + 40;\n    final Dimension minSize = new Dimension(minWidth, myList.getMaximumSize().height);\n    listPanel.setMinimumSize(minSize);\n    listPanel.setPreferredSize(minSize);\n    return centerPanel;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static CvsRootConfiguration reconfigureCvsRoot(String root, Project project){\n    CvsApplicationLevelConfiguration configuration = CvsApplicationLevelConfiguration.getInstance();\n    CvsRootConfiguration selectedConfig = configuration.getConfigurationForCvsRoot(root);\n    ArrayList<CvsRootConfiguration> modifiableList = new ArrayList<CvsRootConfiguration>(configuration.CONFIGURATIONS);\n    CvsConfigurationsListEditor editor = new CvsConfigurationsListEditor(modifiableList, project);\n    editor.select(selectedConfig);\n    editor.setReadOnly();\n    editor.show();\n    if (editor.isOK()){\n      configuration.CONFIGURATIONS = modifiableList;\n      return configuration.getConfigurationForCvsRoot(root);\n    } else {\n      return null;\n    }\n  }","id":42831,"modified_method":"@Nullable\n  public static CvsRootConfiguration reconfigureCvsRoot(String root, Project project){\n    final CvsApplicationLevelConfiguration configuration = CvsApplicationLevelConfiguration.getInstance();\n    final CvsRootConfiguration selectedConfig = configuration.getConfigurationForCvsRoot(root);\n    final ArrayList<CvsRootConfiguration> modifiableList = new ArrayList<CvsRootConfiguration>(configuration.CONFIGURATIONS);\n    final CvsConfigurationsListEditor editor = new CvsConfigurationsListEditor(modifiableList, project, true);\n    editor.select(selectedConfig);\n    editor.show();\n    if (editor.isOK()){\n      configuration.CONFIGURATIONS = modifiableList;\n      return configuration.getConfigurationForCvsRoot(root);\n    } else {\n      return null;\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CvsConfigurationsListEditor(List<CvsRootConfiguration> configs, Project project) {\n    super(true);\n    myCvs2SettingsEditPanel = new Cvs2SettingsEditPanel(project);\n    setTitle(CvsBundle.message(\"operation.name.edit.configurations\"));\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    selectNone();\n    fillModel(configs);\n\n    myCvs2SettingsEditPanel.addCvsRootChangeListener(new CvsRootChangeListener() {\n      @Override\n      public void onCvsRootChanged() {\n        if (mySelection == null) return;\n        myCvs2SettingsEditPanel.saveTo(mySelection);\n        myList.repaint();\n      }\n    });\n\n    setTitle(CvsBundle.message(\"dialog.title.cvs.roots\"));\n\n    if (!configs.isEmpty()) {\n      myList.setSelectedIndex(0);\n    }\n    init();\n\n  }","id":42832,"modified_method":"public CvsConfigurationsListEditor(List<CvsRootConfiguration> configs, Project project) {\n    this(configs, project, false);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CvsRootAsStringConfigurationPanel(BooleanValueHolder isInUpdating) {\n    myIsInUpdating = isInUpdating;\n    myRootLabel.setLabelFor(myCvsRoot);\n    myCvsRoot.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void textChanged(DocumentEvent event) {\n        notifyListeners();\n      }\n    });\n\n    myEditFieldByFieldButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        CvsRootConfiguration cvsRootConfiguration = CvsApplicationLevelConfiguration.createNewConfiguration(CvsApplicationLevelConfiguration.getInstance());\n        saveTo(cvsRootConfiguration);\n        EditCvsConfigurationFieldByFieldDialog dialog\n          = new EditCvsConfigurationFieldByFieldDialog(myCvsRoot.getText());\n        dialog.show();\n        if (dialog.isOK()){\n          myCvsRoot.setText(dialog.getConfiguration());\n        }\n      }\n    });\n  }","id":42833,"modified_method":"public CvsRootAsStringConfigurationPanel(boolean readOnly, Ref<Boolean> isUpdating) {\n    myIsUpdating = isUpdating;\n    myCvsRoot.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void textChanged(DocumentEvent event) {\n        notifyListeners();\n      }\n    });\n\n    myEditFieldByFieldButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final CvsRootConfiguration cvsRootConfiguration =\n          CvsApplicationLevelConfiguration.createNewConfiguration(CvsApplicationLevelConfiguration.getInstance());\n        saveTo(cvsRootConfiguration);\n        final EditCvsConfigurationFieldByFieldDialog dialog = new EditCvsConfigurationFieldByFieldDialog(myCvsRoot.getText());\n        dialog.show();\n        if (dialog.isOK()) {\n          myCvsRoot.setText(dialog.getConfiguration());\n        }\n      }\n    });\n    if (readOnly) {\n      myCvsRoot.setEditable(false);\n      myEditFieldByFieldButton.setEnabled(false);\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateFrom(CvsRootConfiguration config) {\n    myCvsRoot.setText(config.CVS_ROOT);\n    myCvsRoot.selectAll();\n    myCvsRoot.requestFocus();\n  }","id":42834,"modified_method":"public void updateFrom(CvsRootConfiguration config) {\n    myCvsRoot.setText(config.CVS_ROOT);\n    myCvsRoot.selectAll();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void notifyListeners() {\n    if (myIsInUpdating.getValue()) return;\n    for (CvsRootChangeListener cvsRootChangeListener : myCvsRootListeners) {\n      cvsRootChangeListener.onCvsRootChanged();\n    }\n  }","id":42835,"modified_method":"protected void notifyListeners() {\n    if (!myIsUpdating.isNull()) return;\n    for (CvsRootChangeListener cvsRootChangeListener : myCvsRootListeners) {\n      cvsRootChangeListener.onCvsRootChanged();\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void refreshEnabling() {\n\n    boolean useBranch = myUseBranch.isSelected();\n    boolean useDate = myUseDate.isSelected();\n\n    myBranch.setEnabled(useBranch);\n    myBranch.setEditable(useBranch);\n\n    myDatePicker.setEnabled(useDate);\n\n    myBranch.getButton().setEnabled(useBranch);\n  }","id":42836,"modified_method":"private void refreshEnabling() {\n    final boolean useBranch = myUseBranch.isSelected();\n    myBranch.setEnabled(useBranch);\n    myBranch.setEditable(useBranch);\n    myDatePicker.setEnabled(myUseDate.isSelected());\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DateOrRevisionOrTagSettings(TagsProvider tagsProvider, Project project) {\n    myTagsProvider = tagsProvider;\n    myProject = project;\n    myDatePicker.setDateFormat(DateFormatUtil.getDateTimeFormat().getDelegate());\n\n    myUseBranch.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        refreshEnabling();\n        if (myUseBranch.isEnabled()){\n          myBranch.getTextField().selectAll();\n          myBranch.getTextField().requestFocus();\n        }\n      }\n    });\n\n    myUseHead.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        refreshEnabling();\n      }\n    });\n\n    myUseDate.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if (myUseDate.isSelected() && getDateString().equals(EMPTY_DATE)) {\n          setDate(new Date());\n        }\n        refreshEnabling();\n        if (myUseDate.isEnabled()){\n          myDatePicker.requestFocus();\n        }\n\n      }\n    });\n\n    myBranch.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        String tagName = TagsHelper.chooseBranch(myTagsProvider, myProject);\n        if (tagName != null) myBranch.setText(tagName);\n      }\n    });\n    refreshEnabling();\n  }","id":42837,"modified_method":"public DateOrRevisionOrTagSettings(TagsProvider tagsProvider, Project project) {\n    myTagsProvider = tagsProvider;\n    myProject = project;\n    myDatePicker.setDateFormat(DateFormatUtil.getDateTimeFormat().getDelegate());\n\n    myUseBranch.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        refreshEnabling();\n        if (myUseBranch.isEnabled()){\n          myBranch.getTextField().selectAll();\n          myBranch.getTextField().requestFocus();\n        }\n      }\n    });\n\n    myUseHead.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        refreshEnabling();\n      }\n    });\n\n    myUseDate.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if (myUseDate.isSelected() && getDateString().equals(EMPTY_DATE)) {\n          setDate(new Date());\n        }\n        refreshEnabling();\n        if (myUseDate.isEnabled()){\n          myDatePicker.requestFocus();\n        }\n\n      }\n    });\n\n    myBranch.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final String tagName = TagsHelper.chooseBranch(myTagsProvider, myProject);\n        if (tagName != null) myBranch.setText(tagName);\n      }\n    });\n    refreshEnabling();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getPanel() {\n    return myPanel;\n  }","id":42838,"modified_method":"public JPanel getPanel() {\n    return myPanel;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createComponent() {\n    JPanel result = new JPanel(new BorderLayout());\n    result.add(mySelectCvsConfigurationPanel, BorderLayout.CENTER);\n    JPanel buttonPanel = new JPanel(new BorderLayout());\n    result.add(buttonPanel, BorderLayout.SOUTH);\n    return result;\n  }","id":42839,"modified_method":"@Override\n  protected JComponent createComponent() {\n    return mySelectCvsConfigurationPanel;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void dispose() {\n    mySelectCvsConfigurationPanel.getObservable().deleteObserver(myObserver);\n  }","id":42840,"modified_method":"@Override\n  protected void dispose() {\n    mySelectCvsConfigurationPanel.removeListSelectionListener(myListSelectionListener);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SelectCVSConfigurationStep(Project project, CvsWizard wizard) {\n    super(CvsBundle.message(\"dialog.title.select.cvs.configuration\"), wizard);\n    mySelectCvsConfigurationPanel = new SelectCvsConfigurationPanel(project);\n    myObserver = new Observer() {\n          public void update(Observable o, Object arg) {\n            getWizard().updateStep();\n          }\n        };\n    mySelectCvsConfigurationPanel.getObservable().addObserver(myObserver);\n    init();\n  }","id":42841,"modified_method":"public SelectCVSConfigurationStep(Project project, CvsWizard wizard) {\n    super(CvsBundle.message(\"dialog.title.select.cvs.configuration\"), wizard);\n    mySelectCvsConfigurationPanel = new SelectCvsConfigurationPanel(project);\n    myListSelectionListener = new ListSelectionListener() {\n      @Override public void valueChanged(ListSelectionEvent e) {\n        getWizard().updateStep();\n      }\n    };\n    mySelectCvsConfigurationPanel.addListSelectionListener(myListSelectionListener);\n    init();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SelectCvsConfigurationDialog(Project project) {\n    super(true);\n    myPanel = new SelectCvsConfigurationPanel(project);\n    setOKActionEnabled(myPanel.getSelectedConfiguration() != null);\n\n    myPanel.getObservable().addObserver(new Observer() {\n      public void update(Observable o, Object arg) {\n        setOKActionEnabled(myPanel.getSelectedConfiguration() != null);\n      }\n    });\n    setTitle(CvsBundle.message(\"dialog.title.select.cvs.root.configuration\"));\n\n    init();\n  }","id":42842,"modified_method":"public SelectCvsConfigurationDialog(Project project) {\n    super(true);\n    myPanel = new SelectCvsConfigurationPanel(project);\n    setOKActionEnabled(myPanel.getSelectedConfiguration() != null);\n\n    myListener = new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        setOKActionEnabled(myPanel.getSelectedConfiguration() != null);\n      }\n    };\n    myPanel.addListSelectionListener(myListener);\n    setTitle(CvsBundle.message(\"dialog.title.select.cvs.root.configuration\"));\n    init();\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Component createButtonPanel() {\n    JPanel result = new JPanel(new BorderLayout());\n    JButton jButton = new JButton(CvsBundle.message(\"button.text.configure.cvs.roots\"));\n    jButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        editConfigurations();\n      }\n    });\n    result.add(jButton, BorderLayout.NORTH);\n    return result;\n  }","id":42843,"modified_method":"private Component createButtonPanel() {\n    final JPanel panel = new JPanel(new BorderLayout());\n    final JButton button = new JButton(CvsBundle.message(\"button.text.configure.cvs.roots\"));\n    button.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        editConfigurations();\n      }\n    });\n    panel.add(button, BorderLayout.NORTH);\n    return panel;\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SelectCvsConfigurationPanel(Project project) {\n    super(new BorderLayout(2, 4));\n    myProject = project;\n    add(createListPanel(), BorderLayout.CENTER);\n    add(createButtonPanel(), BorderLayout.EAST);\n    myObservable = new MyObservable();\n    myList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        mySelection = (CvsRootConfiguration)myList.getSelectedValue();\n        myObservable.setChanged();\n        myObservable.notifyObservers(mySelection);\n      }\n    });\n\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    fillModel(null);\n  }","id":42844,"modified_method":"public SelectCvsConfigurationPanel(Project project) {\n    super(new BorderLayout(2, 4));\n    myProject = project;\n    add(ScrollPaneFactory.createScrollPane(myList), BorderLayout.CENTER);\n    add(createButtonPanel(), BorderLayout.EAST);\n    myList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        mySelection = (CvsRootConfiguration)myList.getSelectedValue();\n        fireSelectionValueChanged(e.getFirstIndex(), e.getLastIndex(), e.getValueIsAdjusting());\n      }\n    });\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    fillModel(null);\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void editConfigurations() {\n    final CvsApplicationLevelConfiguration configuration = CvsApplicationLevelConfiguration.getInstance();\n    CvsConfigurationsListEditor cvsConfigurationsListEditor =\n      new CvsConfigurationsListEditor(new ArrayList<CvsRootConfiguration>(configuration.CONFIGURATIONS), myProject);\n    CvsRootConfiguration selectedConfiguration = getSelectedConfiguration();\n    if (selectedConfiguration != null) {\n      cvsConfigurationsListEditor.selectConfiguration(selectedConfiguration);\n    }\n    cvsConfigurationsListEditor.show();\n    if (cvsConfigurationsListEditor.isOK()) {\n      configuration.CONFIGURATIONS =\n        new ArrayList<CvsRootConfiguration>(cvsConfigurationsListEditor.getConfigurations());\n      fillModel(cvsConfigurationsListEditor.getSelectedConfiguration());\n    }\n  }","id":42845,"modified_method":"public void editConfigurations() {\n    final CvsApplicationLevelConfiguration configuration = CvsApplicationLevelConfiguration.getInstance();\n    final CvsConfigurationsListEditor cvsConfigurationsListEditor =\n      new CvsConfigurationsListEditor(new ArrayList<CvsRootConfiguration>(configuration.CONFIGURATIONS), myProject);\n    final CvsRootConfiguration selectedConfiguration = getSelectedConfiguration();\n    if (selectedConfiguration != null) {\n      cvsConfigurationsListEditor.selectConfiguration(selectedConfiguration);\n    }\n    cvsConfigurationsListEditor.show();\n    if (cvsConfigurationsListEditor.isOK()) {\n      configuration.CONFIGURATIONS = cvsConfigurationsListEditor.getConfigurations();\n      fillModel(cvsConfigurationsListEditor.getSelectedConfiguration());\n    }\n  }","commit_id":"24ac2e6a7b78423ba0af54b917bd6445488b82ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void propagateRetractLeftTupleDestroyRightTuple(final LeftTuple leftTuple,\n                                                           final PropagationContext context,\n                                                           final InternalWorkingMemory workingMemory) {\n        LeftTuple child = leftTuple.firstChild;\n        while ( child != null ) {\n            LeftTuple temp = child.getLeftParentNext();\n            doPropagateRetractLeftTuple( context,\n                                         workingMemory,\n                                         child,\n                                         child.getLeftTupleSink() );\n            workingMemory.getFactHandleFactory().destroyFactHandle( child.getRightParent().getFactHandle() );\n            child.unlinkFromRightParent();\n            child.unlinkFromLeftParent();\n            child = temp;\n        }\n    }","id":42846,"modified_method":"public void propagateRetractLeftTupleDestroyRightTuple(final LeftTuple leftTuple,\n                                                           final PropagationContext context,\n                                                           final InternalWorkingMemory workingMemory) {\n        LeftTuple child = leftTuple.firstChild;\n        InternalFactHandle rightParent = child.getRightParent().getFactHandle();\n        while ( child != null ) {\n            LeftTuple temp = child.getLeftParentNext();\n            doPropagateRetractLeftTuple( context,\n                                         workingMemory,\n                                         child,\n                                         child.getLeftTupleSink() );\n            child.unlinkFromRightParent();\n            child.unlinkFromLeftParent();\n            child = temp;\n        }\n        workingMemory.getFactHandleFactory().destroyFactHandle( rightParent );\n    }","commit_id":"7897a368dee319c7d948fd6756d7f4570bb40f8a","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * This method isn't as efficient as it could be, as its using the standard join node mechanisms - so everything is bidirectionally\r\n     * linked. As FactHandle's are never retracted, this relationship does not need to be maintined - but as this optimisation would \r\n     * need refactoring, I've used the standard join node mechanism for now. \r\n     * \r\n     */\r\n    public void assertTuple(final ReteTuple leftTuple,\r\n                            final PropagationContext context,\r\n                            final InternalWorkingMemory workingMemory) {\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n\r\n        memory.add( workingMemory,\r\n                    leftTuple );\r\n\r\n        for ( final Iterator it = this.dataProvider.getResults( leftTuple,\r\n                                                          workingMemory,\r\n                                                          context ); it.hasNext(); ) {\r\n            final Object object = it.next();\r\n\r\n            // First alpha node filters\r\n            boolean isAllowed = true;\r\n            for ( int i = 0, length = this.constraints.length; i < length; i++ ) {\r\n                if ( !this.constraints[i].isAllowed( object,\r\n                                                     leftTuple,\r\n                                                     workingMemory ) ) {\r\n                    isAllowed = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if ( !isAllowed ) {\r\n                continue;\r\n            }\r\n\r\n            final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( object );\r\n            final ObjectMatches objectMatches = new ObjectMatches( (DefaultFactHandle) handle );\r\n\r\n            if ( this.binder.isAllowed( handle,\r\n                                   leftTuple,\r\n                                   workingMemory ) ) {\r\n                final TupleMatch tupleMatch = new CompositeTupleMatch( leftTuple,\r\n                                                                       objectMatches );\r\n\r\n                leftTuple.addTupleMatch( (DefaultFactHandle) handle,\r\n                                         tupleMatch );\r\n\r\n                this.sink.propagateAssertTuple( leftTuple,\r\n                                                handle,\r\n                                                tupleMatch,\r\n                                                context,\r\n                                                workingMemory );\r\n            }\r\n        }\r\n    }","id":42847,"modified_method":"/**\r\n     * @inheritDoc \r\n     */\r\n    public void assertTuple(final ReteTuple leftTuple,\r\n                            final PropagationContext context,\r\n                            final InternalWorkingMemory workingMemory) {\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n\r\n        memory.getTupleMemory().add( leftTuple );\r\n        this.binder.updateFromTuple( workingMemory, leftTuple );\r\n\r\n        for ( final java.util.Iterator it = this.dataProvider.getResults( leftTuple,\r\n                                                          workingMemory,\r\n                                                          context ); it.hasNext(); ) {\r\n            final Object object = it.next();\r\n\r\n            // First alpha node filters\r\n            for ( int i = 0, length = this.constraints.length; i < length; i++ ) {\r\n                if ( !this.constraints[i].isAllowed( object,\r\n                                                     workingMemory ) ) {\r\n                    // next iteration\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if ( this.binder.isAllowedCachedLeft( object ) ) {\r\n                final InternalFactHandle handle = workingMemory.getFactHandleFactory().newFactHandle( object );\r\n                \r\n                memory.getCreatedHandles().put( leftTuple, handle );\r\n\r\n                this.sink.propagateAssertTuple( leftTuple,\r\n                                                handle,\r\n                                                context,\r\n                                                workingMemory );\r\n            }\r\n        }\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void retractTuple(final ReteTuple leftTuple,\r\n                             final PropagationContext context,\r\n                             final InternalWorkingMemory workingMemory) {\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n        memory.remove( workingMemory,\r\n                       leftTuple );\r\n\r\n        final Map matches = leftTuple.getTupleMatches();\r\n\r\n        if ( !matches.isEmpty() ) {\r\n            for ( final Iterator it = matches.values().iterator(); it.hasNext(); ) {\r\n                final TupleMatch tupleMatch = (TupleMatch) it.next();\r\n                tupleMatch.getTuple().retractChildEntries( context,\r\n                                                           workingMemory );\r\n                workingMemory.getFactHandleFactory().destroyFactHandle( tupleMatch.getObjectMatches().getFactHandle() );\r\n            }\r\n        }\r\n    }","id":42848,"modified_method":"public void retractTuple(final ReteTuple leftTuple,\r\n                             final PropagationContext context,\r\n                             final InternalWorkingMemory workingMemory) {\r\n\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n        memory.getTupleMemory().remove( leftTuple );\r\n        final InternalFactHandle handle = (InternalFactHandle) memory.getCreatedHandles().remove( leftTuple );\r\n\r\n        // if tuple was propagated\r\n        if ( handle != null ) {\r\n\r\n            this.sink.propagateRetractTuple( leftTuple,\r\n                                             handle,\r\n                                             context,\r\n                                             workingMemory );\r\n\r\n            // Destroying the 'from' result object \r\n            workingMemory.getFactHandleFactory().destroyFactHandle( handle );\r\n        }\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * This could be made more intelligent by finding out if the modified Fact is depended upon by the requiredDeclarations.\r\n     * If it isn't then we can continue to just propagate as a normal modify, without having to retrieve and check values \r\n     * from the DataProvider.\r\n     */\r\n    public void modifyTuple(final ReteTuple leftTuple,\r\n                            final PropagationContext context,\r\n                            final InternalWorkingMemory workingMemory) {\r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n\r\n        // We remove the tuple as now its modified it needs to go to the top of\r\n        // the stack, which is added back in else where\r\n        memory.remove( workingMemory,\r\n                       leftTuple );\r\n\r\n        final Map matches = leftTuple.getTupleMatches();\r\n\r\n        if ( matches.isEmpty() ) {\r\n            // No child propagations, so try as a new assert, will ensure the\r\n            // tuple is added to the top of the memory\r\n            assertTuple( leftTuple,\r\n                         context,\r\n                         workingMemory );\r\n        } else {\r\n            // first purge the network of all future uses of the 'from' facts           \r\n            for ( final Iterator it = matches.values().iterator(); it.hasNext(); ) {\r\n                final TupleMatch tupleMatch = (TupleMatch) it.next();\r\n                tupleMatch.getTuple().retractChildEntries( context,\r\n                                                           workingMemory );\r\n                workingMemory.getFactHandleFactory().destroyFactHandle( tupleMatch.getObjectMatches().getFactHandle() );\r\n            }\r\n\r\n            // now all existing matches must now be cleared and the DataProvider re-processed.\r\n            leftTuple.clearTupleMatches();\r\n\r\n            assertTuple( leftTuple,\r\n                         context,\r\n                         workingMemory );\r\n\r\n        }\r\n    }","id":42849,"modified_method":"public void updateSink(TupleSink sink,\r\n                           PropagationContext context,\r\n                           InternalWorkingMemory workingMemory) {\r\n        \r\n        final BetaMemory memory = (BetaMemory) workingMemory.getNodeMemory( this );\r\n        \r\n        final Iterator it = memory.getCreatedHandles().iterator();\r\n\r\n        for ( ObjectEntry entry = (ObjectEntry) it.next(); entry != null; entry = (ObjectEntry) it.next()) {\r\n            sink.assertTuple( new ReteTuple( (ReteTuple)entry.getKey(),\r\n                                             (InternalFactHandle) entry.getValue()),\r\n                              context,\r\n                              workingMemory );\r\n        }\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public FromNode(final int id,\r\n                    final DataProvider dataProvider,\r\n                    final TupleSource tupleSource,\r\n                    final AlphaNodeFieldConstraint[] constraints,\r\n                    final BetaConstraints binder) {\r\n        super( id );\r\n        this.dataProvider = dataProvider;\r\n        this.tupleSource = tupleSource;\r\n        this.constraints = constraints;\r\n        if ( binder == null ) {\r\n            this.binder = new DefaultBetaConstraints();\r\n        } else {\r\n            this.binder = binder;\r\n        }\r\n    }","id":42850,"modified_method":"public FromNode(final int id,\r\n                    final DataProvider dataProvider,\r\n                    final TupleSource tupleSource,\r\n                    final AlphaNodeFieldConstraint[] constraints,\r\n                    final BetaConstraints binder) {\r\n        super( id );\r\n        this.dataProvider = dataProvider;\r\n        this.tupleSource = tupleSource;\r\n        this.constraints = constraints;\r\n        this.binder = ( binder == null ) ? EmptyBetaConstraints.getInstance() : binder;\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void attach(final InternalWorkingMemory[] workingMemories) {\r\n        attach();\r\n\r\n        for ( int i = 0, length = workingMemories.length; i < length; i++ ) {\r\n            final InternalWorkingMemory workingMemory = workingMemories[i];\r\n            final PropagationContext propagationContext = new PropagationContextImpl( workingMemory.getNextPropagationIdCounter(),\r\n                                                                                      PropagationContext.RULE_ADDITION,\r\n                                                                                      null,\r\n                                                                                      null );\r\n            this.tupleSource.updateNewNode( workingMemory,\r\n                                            propagationContext );\r\n        }\r\n    }","id":42851,"modified_method":"public void attach(final InternalWorkingMemory[] workingMemories) {\r\n        attach();\r\n\r\n        for ( int i = 0, length = workingMemories.length; i < length; i++ ) {\r\n            final InternalWorkingMemory workingMemory = workingMemories[i];\r\n            final PropagationContext propagationContext = new PropagationContextImpl( workingMemory.getNextPropagationIdCounter(),\r\n                                                                                      PropagationContext.RULE_ADDITION,\r\n                                                                                      null,\r\n                                                                                      null );\r\n            this.tupleSource.updateSink( this, propagationContext, workingMemory );\r\n        }\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void remove(final BaseNode node,\r\n                       final InternalWorkingMemory[] workingMemories) {\r\n        // FIXME\r\n        //        if ( !node.isInUse() ) {\r\n        //            getTupleSinks().remove( node );\r\n        //        }\r\n        //        removeShare();\r\n        //\r\n        //        if ( !this.isInUse() ) {\r\n        //            for ( int i = 0, length = workingMemories.length; i < length; i++ ) {\r\n        //                workingMemories[i].clearNodeMemory( this );\r\n        //            }\r\n        //        }\r\n        //        this.tupleSource.remove( this,\r\n        //                                 workingMemories );\r\n    }","id":42852,"modified_method":"public void remove(final BaseNode node,\r\n                       final InternalWorkingMemory[] workingMemories) {\r\n        \r\n        if ( !node.isInUse() ) {\r\n            removeTupleSink( (TupleSink) node );\r\n        }\r\n        removeShare();\r\n\r\n        if ( !this.isInUse() ) {\r\n            for ( int i = 0, length = workingMemories.length; i < length; i++ ) {\r\n                workingMemories[i].clearNodeMemory( this );\r\n            }\r\n        }\r\n        this.tupleSource.remove( this,\r\n                               workingMemories );\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Object createMemory(final RuleBaseConfiguration config) {\r\n        return new BetaMemory( config,\r\n                               this.binder );\r\n    }","id":42853,"modified_method":"public Object createMemory(final RuleBaseConfiguration config) {\r\n        return this.binder.createBetaMemory();\r\n    }","commit_id":"4c10d44c91f56ea3cafe449ac420ed743f0379ea","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void analyzeParameters( XSLT xslt ) throws PortalException {\n\t\t\n\t  try {\n\t\t  \n\t\t\n\t\t\tString fragmentId = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_fragmentID\"));\n\t\t    String channelId = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_channelID\"));\n\t\t    String categoryId = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_categoryID\"));\n\t\t\tString action = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_action\"));\n\t\t    String channelState = CommonUtils.nvl(runtimeData.getParameter(\"channel-state\"),\"browse\");\n\t\t    String searchFragment = CommonUtils.nvl(runtimeData.getParameter(\"search-fragment\"),\"false\");\n\t\t    String searchChannel = CommonUtils.nvl(runtimeData.getParameter(\"search-channel\"),\"false\");\n\t\t    String searchCategory = CommonUtils.nvl(runtimeData.getParameter(\"search-category\"),\"false\");\n\t\t\tboolean all = false,\n\t\t\t        expand = action.equals(\"expand\"),\n\t\t\t        condense = action.equals(\"condense\");    \n\t  \t     \n\t  \t     Vector tagNames = new Vector();         \n\t\t           \n\t\tif ( expand || condense ) {\n\t\t\t \t\t \t\n\t\t\t\tif ( fragmentId.equals(\"all\") ) {\n\t\t\t\t   all = true;\n\t\t\t\t   tagNames.add(FRAGMENT); \t\t \n\t\t\t\t}      \n\t\t\t\t\n\t\t\t\tif ( channelId.equals(\"all\") ) { \n\t\t\t\t   all = true;\n\t\t\t\t   tagNames.add(CHANNEL);\n\t\t\t\t}   \n\t\t\t\t\n\t\t\t\tif ( categoryId.equals(\"all\") ) {\n\t\t\t\t   all = true;\n\t\t\t\t   tagNames.add(CATEGORY);\n\t\t\t\t}   \n\t\t\t\t   \t \n\t\t\t\t   \n\t\t\tif ( !all  ) {\n\t\t\t\t  String itemName = CHANNEL;\n\t\t\t\t  String itemId = channelId;\n\t\t\t\t  if ( fragmentId.length() > 0 ) {\n\t\t\t          itemId = fragmentId;\n\t\t\t\t\t  itemName = FRAGMENT;\n\t\t\t\t  } else if ( categoryId.length() > 0 && channelId.length() == 0 ) {\n\t\t\t\t      itemId = categoryId;\n\t\t\t\t\t  itemName = CATEGORY;\n\t\t\t\t  }\t  \t\n\n\t\t\t\t  ListItem item = new ListItem(categoryId,itemId,itemName,channelState.equals(\"search\")?\"search\":\"browse\");\n\t\t\t\n\t\t\t\t  if ( expand ) {\n\t\t\t\t    expandedItems.add(item);\n\t\t\t\t    condensedItems.remove(item);\n\t\t\t\t  } else {\n\t\t\t\t    condensedItems.add(item);  \n\t\t\t\t    expandedItems.remove(item);\n\t\t\t\t  }           \n\t\t\t}\n\t\t\t\t \n\t\t\t\n\t\t} else if ( action.equals(\"init\") ) {\n\t\t\t \t//if ( alm.isFragmentLoaded() )\n\t\t\t \t//alm.loadUserLayout();\t\n\t\t\t \trefreshFragmentMap(); \n\t\t\t \tinitRegistry();\n\t\t} else if ( action.equals(\"search\") ) {\n\t\t\tString query = runtimeData.getParameter(\"search-query\");\n\t\t\t// Clear all the previous state\n\t\t\tif ( query != null ) {\n\t\t\t\tNodeList nodeList = XPathAPI.selectNodeList(registry,\"//*\");\n\t\t\t\tfor ( int k = 0; k < nodeList.getLength(); k++ ) {\n\t\t\t\t  Element node = (Element) nodeList.item(k);\n\t\t\t\t  node.setAttribute(\"search-selected\",\"false\");\n\t\t\t\t  node.setAttribute(\"search-view\",\"condensed\");\n\t\t\t\t} \t\n\t\t\t}\n\t\t\tif ( CommonUtils.nvl(query).length() > 0 ) {\n\t\t\t  String[] xPathQueries = new String[3];\n\t\t\t  if ( searchChannel.equals(\"true\") )\t\n\t\t\t   xPathQueries[0] = \"//channel[contains(@name,'\"+query+\"') or contains(@description,'\"+query+\"')]\";\n\t\t\t  if ( searchCategory.equals(\"true\") )\n\t\t\t   xPathQueries[1] = \"//category[contains(@name,'\"+query+\"') or contains(@description,'\"+query+\"')]\"; \n\t\t\t  if ( searchFragment.equals(\"true\") )\n\t\t\t   xPathQueries[2] = \"//fragment[contains(name,'\"+query+\"') or contains(description,'\"+query+\"')]\";\n\t\t\t  for ( int i = 0; i < xPathQueries.length; i++) {  \n\t\t\t   if ( xPathQueries[i] != null ) {\t \t\n\t\t\t    NodeList nodeList =  XPathAPI.selectNodeList(registry,xPathQueries[i]);\n\t\t\t    for ( int k = 0; k < nodeList.getLength(); k++ ) {\n\t\t\t\t Element node = (Element) nodeList.item(k);\n\t\t\t\t node.setAttribute(\"search-selected\",\"true\");\n\t\t\t\t expandAscendents(node);\n\t\t\t    } \n\t\t\t   } \n\t\t\t  } \n\t\t\t}\t\t\n\t\t}\n\t\t\t \n\t\tVector removedItems = new Vector(); \n\t\tString attrName = channelState.equals(\"search\")?\"search-view\":\"view\";\n\t\t\n\t\tif ( !action.equals(\"search\") ) {\t\t\t\t \n\t\t if ( !all ) {   \n\t\t\t\t\n\t\t     Vector items = expandedItems;\t\t\n\t\t     for ( int k = 0; k < 2; items = condensedItems, k++ ) {\t\t \n\t\t\t  for ( int i = 0; i < items.size(); i++ ) {\t \n\t\t\t   for ( Iterator iter = items.iterator(); iter.hasNext(); ) {\n\t\t\t    ListItem item = (ListItem) iter.next();\n\t\t\t    if ( channelState.equals(item.getChannelState())) {\n\t\t\t     String xPathQuery = null;\n\t\t\t     if ( CHANNEL.equals(item.getName()) )\n\t\t\t      xPathQuery = \"//channel[../@ID='\"+item.getCategoryId()+\"' and @ID='\"+item.getItemId()+\"']\";\n\t\t\t     else \n\t\t\t      xPathQuery = \"//*[@ID='\"+item.getItemId()+\"']\";   \n\t\t\t\t Element elem = (Element) XPathAPI.selectSingleNode(registry,xPathQuery);\n\t\t\t\t if ( elem != null ) \n\t\t\t\t  elem.setAttribute(attrName,(k==0)?\"expanded\":\"condensed\");\n\t\t\t\t else\n\t\t\t\t  removedItems.add(item);\n\t\t\t    }  \n\t\t\t   } \n\t\t\t  }\n\t\t\t    items.removeAll(removedItems);\n\t\t     }\t           \n\t\t\t  \n\t\t } else { \n\t\t    \n\t\t      for ( int i = 0; i < tagNames.size(); i++ ) {\n\t\t        String tagName = (String) tagNames.get(i);\t\n\t\t\t    for ( Iterator iter = expandedItems.iterator(); iter.hasNext(); ) {\n\t\t\t   \t ListItem item = (ListItem)iter.next();\n\t\t\t  \t if ( tagName.equals(item.getName()) && channelState.equals(item.getChannelState()) )\n\t\t\t  \t  removedItems.add(item);\n\t\t\t    }\t\t\n\t\t\t      expandedItems.removeAll(removedItems);\n\t\t\t    for ( Iterator iter = condensedItems.iterator(); iter.hasNext(); ) {\n\t\t\t\t ListItem item = (ListItem)iter.next();\n\t\t\t\t if ( tagName.equals(item.getName()) && channelState.equals(item.getChannelState()) )\n\t\t\t\t  removedItems.add(item);\n\t\t\t    }\t\n\t\t\t\t  condensedItems.removeAll(removedItems);\n\t\t\t    NodeList nodeList = registry.getElementsByTagName(tagName);\n\t\t\t    String attrValue = (expand)?\"expanded\":\"condensed\";\n\t\t\t    for ( int k = 0; k < nodeList.getLength(); k++ ) {\n\t\t\t\t Element node = (Element) nodeList.item(k);\n\t\t\t\t node.setAttribute(attrName,attrValue);\n\t\t\t    } \n\t\t      }\n\t\t     \n\t\t  }\n\t\t}   \n\t\t     \n\t\t    // Passing all the HTTP params back to the stylesheet\n\t\t     passAllParameters(xslt);\n\t\t     xslt.setStylesheetParameter(\"search-fragment\", searchFragment);\n\t\t     xslt.setStylesheetParameter(\"search-channel\", searchChannel);\n\t\t     xslt.setStylesheetParameter(\"search-category\", searchCategory);\n\t\t     \n\t  } catch ( Exception e ) {\n\t  \t  e.printStackTrace();\n\t  \t  throw new PortalException(e.getMessage());\t     \n\t  }\n\t\t\t \n\t}","id":42854,"modified_method":"protected void analyzeParameters( XSLT xslt ) throws PortalException {\n\t\t\n\t  try {\n\t\t  \n\t\t\n\t\t\tString fragmentId = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_fragmentID\"));\n\t\t    String channelId = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_channelID\"));\n\t\t    String categoryId = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_categoryID\"));\n\t\t\tString action = CommonUtils.nvl(runtimeData.getParameter(\"uPcCS_action\"));\n\t\t    String channelState = CommonUtils.nvl(runtimeData.getParameter(\"channel-state\"),\"browse\");\n\t\t\tboolean all = false,\n\t\t\t        expand = action.equals(\"expand\"),\n\t\t\t        condense = action.equals(\"condense\");    \n\t  \t     \n\t  \t     Vector tagNames = new Vector();         \n\t\t           \n\t\tif ( expand || condense ) {\n\t\t\t \t\t \t\n\t\t\t\tif ( fragmentId.equals(\"all\") ) {\n\t\t\t\t   all = true;\n\t\t\t\t   tagNames.add(FRAGMENT); \t\t \n\t\t\t\t}      \n\t\t\t\t\n\t\t\t\tif ( channelId.equals(\"all\") ) { \n\t\t\t\t   all = true;\n\t\t\t\t   tagNames.add(CHANNEL);\n\t\t\t\t}   \n\t\t\t\t\n\t\t\t\tif ( categoryId.equals(\"all\") ) {\n\t\t\t\t   all = true;\n\t\t\t\t   tagNames.add(CATEGORY);\n\t\t\t\t}   \n\t\t\t\t   \t \n\t\t\t\t   \n\t\t\tif ( !all  ) {\n\t\t\t\t  String itemName = CHANNEL;\n\t\t\t\t  String itemId = channelId;\n\t\t\t\t  if ( fragmentId.length() > 0 ) {\n\t\t\t          itemId = fragmentId;\n\t\t\t\t\t  itemName = FRAGMENT;\n\t\t\t\t  } else if ( categoryId.length() > 0 && channelId.length() == 0 ) {\n\t\t\t\t      itemId = categoryId;\n\t\t\t\t\t  itemName = CATEGORY;\n\t\t\t\t  }\t  \t\n\n\t\t\t\t  ListItem item = new ListItem(categoryId,itemId,itemName,channelState.equals(\"search\")?\"search\":\"browse\");\n\t\t\t\n\t\t\t\t  if ( expand ) {\n\t\t\t\t    expandedItems.add(item);\n\t\t\t\t    condensedItems.remove(item);\n\t\t\t\t  } else {\n\t\t\t\t    condensedItems.add(item);  \n\t\t\t\t    expandedItems.remove(item);\n\t\t\t\t  }           \n\t\t\t}\n\t\t\t\t \n\t\t\t\n\t\t} else if ( action.equals(\"init\") ) {\n\t\t\t \t//if ( alm.isFragmentLoaded() )\n\t\t\t \t//alm.loadUserLayout();\t\n\t\t\t \trefreshFragmentMap(); \n\t\t\t \tinitRegistry();\n\t\t} else if ( action.equals(\"search\") ) {\n\t\t\tsearchFragment = CommonUtils.nvl(runtimeData.getParameter(\"search-fragment\"),\"false\");\n\t\t\tsearchChannel = CommonUtils.nvl(runtimeData.getParameter(\"search-channel\"),\"false\");\n\t\t\tsearchCategory = CommonUtils.nvl(runtimeData.getParameter(\"search-category\"),\"false\");\n\t\t\tsearchQuery = runtimeData.getParameter(\"search-query\");\n\t\t\t// Clear all the previous state\n\t\t\tif ( searchQuery != null ) {\n\t\t\t\tNodeList nodeList = XPathAPI.selectNodeList(registry,\"//*\");\n\t\t\t\tfor ( int k = 0; k < nodeList.getLength(); k++ ) {\n\t\t\t\t  Element node = (Element) nodeList.item(k);\n\t\t\t\t  node.setAttribute(\"search-selected\",\"false\");\n\t\t\t\t  node.setAttribute(\"search-view\",\"condensed\");\n\t\t\t\t} \t\n\t\t\t}\n\t\t\tif ( CommonUtils.nvl(searchQuery).length() > 0 ) {\n\t\t\t  String[] xPathQueries = new String[3];\n\t\t\t  if ( searchChannel.equals(\"true\") )\t\n\t\t\t   xPathQueries[0] = \"//channel[contains(@name,'\"+searchQuery+\"') or contains(@description,'\"+searchQuery+\"')]\";\n\t\t\t  if ( searchCategory.equals(\"true\") )\n\t\t\t   xPathQueries[1] = \"//category[contains(@name,'\"+searchQuery+\"') or contains(@description,'\"+searchQuery+\"')]\"; \n\t\t\t  if ( searchFragment.equals(\"true\") )\n\t\t\t   xPathQueries[2] = \"//fragment[contains(name,'\"+searchQuery+\"') or contains(description,'\"+searchQuery+\"')]\";\n\t\t\t  for ( int i = 0; i < xPathQueries.length; i++) {  \n\t\t\t   if ( xPathQueries[i] != null ) {\t \t\n\t\t\t    NodeList nodeList =  XPathAPI.selectNodeList(registry,xPathQueries[i]);\n\t\t\t    for ( int k = 0; k < nodeList.getLength(); k++ ) {\n\t\t\t\t Element node = (Element) nodeList.item(k);\n\t\t\t\t node.setAttribute(\"search-selected\",\"true\");\n\t\t\t\t expandAscendents(node);\n\t\t\t    } \n\t\t\t   } \n\t\t\t  } \n\t\t\t}\t\t\n\t\t}\n\t\t\t \n\t\tVector removedItems = new Vector(); \n\t\tString attrName = channelState.equals(\"search\")?\"search-view\":\"view\";\n\t\t\n\t\tif ( !action.equals(\"search\") ) {\t\t\t\t \n\t\t if ( !all ) {   \n\t\t\t\t\n\t\t     Vector items = expandedItems;\t\t\n\t\t     for ( int k = 0; k < 2; items = condensedItems, k++ ) {\t\t \n\t\t\t  for ( int i = 0; i < items.size(); i++ ) {\t \n\t\t\t   for ( Iterator iter = items.iterator(); iter.hasNext(); ) {\n\t\t\t    ListItem item = (ListItem) iter.next();\n\t\t\t    if ( channelState.equals(item.getChannelState())) {\n\t\t\t     String xPathQuery = null;\n\t\t\t     if ( CHANNEL.equals(item.getName()) )\n\t\t\t      xPathQuery = \"//channel[../@ID='\"+item.getCategoryId()+\"' and @ID='\"+item.getItemId()+\"']\";\n\t\t\t     else \n\t\t\t      xPathQuery = \"//*[@ID='\"+item.getItemId()+\"']\";   \n\t\t\t\t Element elem = (Element) XPathAPI.selectSingleNode(registry,xPathQuery);\n\t\t\t\t if ( elem != null ) \n\t\t\t\t  elem.setAttribute(attrName,(k==0)?\"expanded\":\"condensed\");\n\t\t\t\t else\n\t\t\t\t  removedItems.add(item);\n\t\t\t    }  \n\t\t\t   } \n\t\t\t  }\n\t\t\t    items.removeAll(removedItems);\n\t\t     }\t           \n\t\t\t  \n\t\t } else { \n\t\t    \n\t\t      for ( int i = 0; i < tagNames.size(); i++ ) {\n\t\t        String tagName = (String) tagNames.get(i);\t\n\t\t\t    for ( Iterator iter = expandedItems.iterator(); iter.hasNext(); ) {\n\t\t\t   \t ListItem item = (ListItem)iter.next();\n\t\t\t  \t if ( tagName.equals(item.getName()) && channelState.equals(item.getChannelState()) )\n\t\t\t  \t  removedItems.add(item);\n\t\t\t    }\t\t\n\t\t\t      expandedItems.removeAll(removedItems);\n\t\t\t    for ( Iterator iter = condensedItems.iterator(); iter.hasNext(); ) {\n\t\t\t\t ListItem item = (ListItem)iter.next();\n\t\t\t\t if ( tagName.equals(item.getName()) && channelState.equals(item.getChannelState()) )\n\t\t\t\t  removedItems.add(item);\n\t\t\t    }\t\n\t\t\t\t  condensedItems.removeAll(removedItems);\n\t\t\t    NodeList nodeList = registry.getElementsByTagName(tagName);\n\t\t\t    String attrValue = (expand)?\"expanded\":\"condensed\";\n\t\t\t    for ( int k = 0; k < nodeList.getLength(); k++ ) {\n\t\t\t\t Element node = (Element) nodeList.item(k);\n\t\t\t\t node.setAttribute(attrName,attrValue);\n\t\t\t    } \n\t\t      }\n\t\t     \n\t\t  }\n\t\t}   \n\t\t     \n\t\t    // Passing all the HTTP params back to the stylesheet\n\t\t     passAllParameters(xslt);\n\t\t     xslt.setStylesheetParameter(\"search-fragment\", searchFragment);\n\t\t     xslt.setStylesheetParameter(\"search-channel\", searchChannel);\n\t\t     xslt.setStylesheetParameter(\"search-category\", searchCategory);\n\t\t     xslt.setStylesheetParameter(\"search-query\", CommonUtils.nvl(searchQuery));\n\t\t     \n\t  } catch ( Exception e ) {\n\t  \t  e.printStackTrace();\n\t  \t  throw new PortalException(e.getMessage());\t     \n\t  }\n\t\t\t \n\t}","commit_id":"c490ddc7af25129026bffcc6dd8372058b1df1c8","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Nullable\n  protected PsiType inferContextType() {\n    final PsiElement parent = myPlaceToInferContext.getParent();\n    if (parent instanceof GrReturnStatement || exitsContains(myPlaceToInferContext)) {\n      final GrMethod method = PsiTreeUtil.getParentOfType(parent, GrMethod.class, true, GrClosableBlock.class);\n      if (method != null) {\n        return method.getReturnType();\n      }\n    }\n    else if (parent instanceof GrAssignmentExpression && myPlaceToInferContext.equals(((GrAssignmentExpression)parent).getRValue())) {\n      return ((GrAssignmentExpression)parent).getLValue().getType();\n    }\n    else if (parent instanceof GrVariable) {\n      return ((GrVariable)parent).getDeclaredType();\n    }\n    return null;\n  }","id":42855,"modified_method":"@Nullable\n  protected PsiType inferContextType() {\n    final PsiElement parent = myPlaceToInferContext.getParent();\n    if (parent instanceof GrReturnStatement || exitsContains(myPlaceToInferContext)) {\n      final GrMethod method = PsiTreeUtil.getParentOfType(parent, GrMethod.class, true, GrClosableBlock.class);\n      if (method != null) {\n        return method.getReturnType();\n      }\n    }\n    else if (parent instanceof GrAssignmentExpression && myPlaceToInferContext.equals(((GrAssignmentExpression)parent).getRValue())) {\n      GrExpression lValue = ((GrAssignmentExpression)parent).getLValue();\n      if (lValue instanceof GrIndexProperty) {\n        return null;\n      }\n      else {\n        return lValue.getType();\n      }\n    }\n    else if (parent instanceof GrVariable) {\n      return ((GrVariable)parent).getDeclaredType();\n    }\n    return null;\n  }","commit_id":"f5341956f04bcc7d4d0695863f35a7b10e8741e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(GrAssignmentExpression expression) {\n    GrExpression rValue = expression.getRValue();\n    if (rValue != null) {\n      rValue.accept(this);\n      expression.getLValue().accept(this);\n    }\n  }","id":42856,"modified_method":"public void visitAssignmentExpression(GrAssignmentExpression expression) {\n    GrExpression lValue = expression.getLValue();\n    if (expression.getOperationToken() != GroovyElementTypes.mASSIGN) {\n      if (lValue instanceof GrReferenceExpression) {\n        addNode(new ReadWriteVariableInstructionImpl((GrReferenceExpression) lValue, myInstructionNumber++, false));\n      }\n    }\n\n    GrExpression rValue = expression.getRValue();\n    if (rValue != null) {\n      rValue.accept(this);\n      lValue.accept(this);\n    }\n  }","commit_id":"7588d3ebd1180546f812dd961d068ae91e8aa802","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected PsiType inferContextType() {\n    final PsiElement parent = myPlaceToInferContext.getParent();\n    if (parent instanceof GrReturnStatement || exitsContains(myPlaceToInferContext)) {\n      final GrMethod method = PsiTreeUtil.getParentOfType(parent, GrMethod.class, true, GrClosableBlock.class);\n      if (method != null) {\n        return method.getReturnType();\n      }\n    }\n    else if (parent instanceof GrAssignmentExpression && myPlaceToInferContext.equals(((GrAssignmentExpression)parent).getRValue())) {\n      GrExpression lValue = ((GrAssignmentExpression)parent).getLValue();\n      if (lValue instanceof GrIndexProperty) {\n        return null;\n      }\n      else {\n        return lValue.getType();\n      }\n    }\n    else if (parent instanceof GrVariable) {\n      return ((GrVariable)parent).getDeclaredType();\n    }\n    return null;\n  }","id":42857,"modified_method":"@Nullable\n  protected PsiType inferContextType() {\n    final PsiElement parent = myPlaceToInferContext.getParent();\n    if (parent instanceof GrReturnStatement || exitsContains(myPlaceToInferContext)) {\n      final GrMethod method = PsiTreeUtil.getParentOfType(parent, GrMethod.class, true, GrClosableBlock.class);\n      if (method != null) {\n        return method.getReturnType();\n      }\n    }\n    else if (parent instanceof GrAssignmentExpression && myPlaceToInferContext.equals(((GrAssignmentExpression)parent).getRValue())) {\n      PsiElement lValue = PsiUtil.skipParentheses(((GrAssignmentExpression)parent).getLValue(), false);\n      if ((lValue instanceof GrExpression) && !(lValue instanceof GrIndexProperty)) {\n        return ((GrExpression)lValue).getType();\n      }\n      else {\n        return null;\n      }\n    }\n    else if (parent instanceof GrVariable) {\n      return ((GrVariable)parent).getDeclaredType();\n    }\n    return null;\n  }","commit_id":"a86989f51b5d06811096378af58cfe36cc527fa4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getInitializerTypeFor(PsiElement element) {\n    final PsiElement parent = element.getParent();\n    if (parent instanceof GrAssignmentExpression) {\n      if (element instanceof GrIndexProperty) {\n        final GrExpression rvalue = ((GrAssignmentExpression)parent).getRValue();\n        return rvalue != null ? rvalue.getType() : null; //don't try to infer assignment type in case of index property because of infinite recursion (example: a[2]+=4)\n      }\n      return ((GrAssignmentExpression)parent).getType();\n    }\n\n    if (parent instanceof GrTupleExpression) {\n      GrTupleExpression list = (GrTupleExpression)parent;\n      if (list.getParent() instanceof GrAssignmentExpression) { // multiple assignment\n        final GrExpression rValue = ((GrAssignmentExpression) list.getParent()).getRValue();\n        int idx = list.indexOf(element);\n        if (idx >= 0 && rValue != null) {\n          PsiType rType = rValue.getType();\n          if (rType instanceof GrTupleType) {\n            PsiType[] componentTypes = ((GrTupleType) rType).getComponentTypes();\n            if (idx < componentTypes.length) return componentTypes[idx];\n            return null;\n          }\n          return PsiUtil.extractIterableTypeParameter(rType, false);\n        }\n      }\n    }\n    if (parent instanceof GrUnaryExpression &&\n        TokenSets.POSTFIX_UNARY_OP_SET.contains(((GrUnaryExpression)parent).getOperationTokenType())) {\n      return ((GrUnaryExpression)parent).getType();\n    }\n\n    return null;\n  }","id":42858,"modified_method":"@Nullable\n  public static PsiType getInitializerTypeFor(PsiElement element) {\n    final PsiElement parent = skipParentheses(element.getParent(), true);\n    if (parent instanceof GrAssignmentExpression) {\n      if (element instanceof GrIndexProperty) {\n        final GrExpression rvalue = ((GrAssignmentExpression)parent).getRValue();\n        return rvalue != null ? rvalue.getType() : null; //don't try to infer assignment type in case of index property because of infinite recursion (example: a[2]+=4)\n      }\n      return ((GrAssignmentExpression)parent).getType();\n    }\n\n    if (parent instanceof GrTupleExpression) {\n      GrTupleExpression list = (GrTupleExpression)parent;\n      if (list.getParent() instanceof GrAssignmentExpression) { // multiple assignment\n        final GrExpression rValue = ((GrAssignmentExpression) list.getParent()).getRValue();\n        int idx = list.indexOf(element);\n        if (idx >= 0 && rValue != null) {\n          PsiType rType = rValue.getType();\n          if (rType instanceof GrTupleType) {\n            PsiType[] componentTypes = ((GrTupleType) rType).getComponentTypes();\n            if (idx < componentTypes.length) return componentTypes[idx];\n            return null;\n          }\n          return PsiUtil.extractIterableTypeParameter(rType, false);\n        }\n      }\n    }\n    if (parent instanceof GrUnaryExpression &&\n        TokenSets.POSTFIX_UNARY_OP_SET.contains(((GrUnaryExpression)parent).getOperationTokenType())) {\n      return ((GrUnaryExpression)parent).getType();\n    }\n\n    return null;\n  }","commit_id":"a86989f51b5d06811096378af58cfe36cc527fa4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Schedules a file for async persistence.\n   *\n   * @param path the id of the file for persistence\n   * @throws AlluxioException if scheduling fails\n   */\n  public void scheduleAsyncPersistence(AlluxioURI path) throws AlluxioException {\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      scheduleAsyncPersistenceAndJournal(inodePath);\n    }\n    // NOTE: persistence is asynchronous so there is no guarantee the path will still exist\n    mAsyncPersistHandler.scheduleAsyncPersistence(path);\n  }","id":42859,"modified_method":"/**\n   * Schedules a file for async persistence.\n   *\n   * @param path the id of the file for persistence\n   * @throws AlluxioException if scheduling fails\n   */\n  public void scheduleAsyncPersistence(AlluxioURI path) throws AlluxioException {\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      flushCounter = scheduleAsyncPersistenceAndJournal(inodePath);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n    // NOTE: persistence is asynchronous so there is no guarantee the path will still exist\n    mAsyncPersistHandler.scheduleAsyncPersistence(path);\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a directory for a given path.\n   * <p>\n   * This operation requires the client user to have\n   * {@link FileSystemAction#WRITE} permission on the parent of the path.\n   *\n   * @param path the path of the directory\n   * @param options method options\n   * @return an {@link alluxio.master.file.meta.InodeTree.CreatePathResult} representing the\n   *         modified inodes and created inodes during path creation\n   * @throws InvalidPathException when the path is invalid, please see documentation on\n   *         {@link InodeTree#createPath(AlluxioURI, CreatePathOptions)} for more details\n   * @throws FileAlreadyExistsException when there is already a file at path\n   * @throws IOException if a non-Alluxio related exception occurs\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   */\n  public InodeTree.CreatePathResult createDirectory(AlluxioURI path, CreateDirectoryOptions options)\n      throws InvalidPathException, FileAlreadyExistsException, IOException, AccessControlException,\n      FileDoesNotExistException {\n    LOG.debug(\"createDirectory {} \", path);\n    MasterContext.getMasterSource().incCreateDirectoriesOps(1);\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(path);\n      return createDirectoryAndJournal(inodePath, options);\n    }\n  }","id":42860,"modified_method":"/**\n   * Creates a directory for a given path.\n   * <p>\n   * This operation requires the client user to have\n   * {@link FileSystemAction#WRITE} permission on the parent of the path.\n   *\n   * @param path the path of the directory\n   * @param options method options\n   * @throws InvalidPathException when the path is invalid, please see documentation on\n   *         {@link InodeTree#createPath(AlluxioURI, CreatePathOptions)} for more details\n   * @throws FileAlreadyExistsException when there is already a file at path\n   * @throws IOException if a non-Alluxio related exception occurs\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   */\n  public void createDirectory(AlluxioURI path, CreateDirectoryOptions options)\n      throws InvalidPathException, FileAlreadyExistsException, IOException, AccessControlException,\n      FileDoesNotExistException {\n    LOG.debug(\"createDirectory {} \", path);\n    MasterContext.getMasterSource().incCreateDirectoriesOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(path);\n      flushCounter = createDirectoryAndJournal(inodePath, options);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Returns the file id for a given path. If the given path does not exist in Alluxio, the method\n   * attempts to load it from UFS.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#READ} permission of the path.\n   *\n   * @param path the path to get the file id for\n   * @return the file id for a given path, or -1 if there is no file at that path\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the path does not exist\n   */\n  public long getFileId(AlluxioURI path) throws AccessControlException, FileDoesNotExistException {\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ)) {\n      mPermissionChecker.checkPermission(FileSystemAction.READ, inodePath);\n      loadMetadataIfNotExist(inodePath);\n      mInodeTree.ensureFullInodePath(inodePath, InodeTree.LockMode.READ);\n      return inodePath.getInode().getId();\n    } catch (InvalidPathException | FileDoesNotExistException e) {\n      return IdUtils.INVALID_FILE_ID;\n    }\n  }","id":42861,"modified_method":"/**\n   * Returns the file id for a given path. If the given path does not exist in Alluxio, the method\n   * attempts to load it from UFS.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#READ} permission of the path.\n   *\n   * @param path the path to get the file id for\n   * @return the file id for a given path, or -1 if there is no file at that path\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the path does not exist\n   */\n  public long getFileId(AlluxioURI path) throws AccessControlException, FileDoesNotExistException {\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ)) {\n      mPermissionChecker.checkPermission(FileSystemAction.READ, inodePath);\n      flushCounter = loadMetadataIfNotExistAndJournal(inodePath);\n      mInodeTree.ensureFullInodePath(inodePath, InodeTree.LockMode.READ);\n      return inodePath.getInode().getId();\n    } catch (InvalidPathException | FileDoesNotExistException e) {\n      return IdUtils.INVALID_FILE_ID;\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Sets the file attribute.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} to set attribute for\n   * @param options attributes to be set, see {@link SetAttributeOptions}\n   * @param rootRequired indicates whether it requires to be the superuser\n   * @param ownerRequired indicates whether it requires to be the owner of this path\n   * @throws InvalidPathException if the given path is invalid\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws AccessControlException if permission checking fails\n   */\n  void setAttributeAndJournal(InodePath inodePath, SetAttributeOptions options,\n      boolean rootRequired, boolean ownerRequired)\n      throws InvalidPathException, FileDoesNotExistException, AccessControlException {\n    Inode<?> targetInode = inodePath.getInode();\n    long opTimeMs = System.currentTimeMillis();\n    if (options.isRecursive() && targetInode.isDirectory()) {\n      try (InodeLockGroup lockGroup = mInodeTree\n          .getInodeChildrenRecursive(inodePath, InodeTree.LockMode.WRITE)) {\n        List<Inode<?>> inodeChildren = lockGroup.getInodes();\n        for (Inode<?> inode : inodeChildren) {\n          // the path to inode for getPath should already be locked.\n          try (InodePath childPath = mInodeTree.lockFullInodePath(mInodeTree.getPath(inode),\n              InodeTree.LockMode.READ)) {\n            // TODO(gpang): a better way to check permissions\n            mPermissionChecker\n                .checkSetAttributePermission(childPath, rootRequired, ownerRequired);\n          }\n        }\n        TempInodePathWithDescendant tempInodePath = new TempInodePathWithDescendant(inodePath);\n        for (Inode<?> inode : inodeChildren) {\n          // the path to inode for getPath should already be locked.\n          tempInodePath.setDescendant(inode, mInodeTree.getPath(inode));\n          setAttributeInternal(tempInodePath, opTimeMs, options);\n          journalSetAttribute(inode.getId(), opTimeMs, options);\n        }\n      }\n    }\n    setAttributeInternal(inodePath, opTimeMs, options);\n    journalSetAttribute(targetInode.getId(), opTimeMs, options);\n  }","id":42862,"modified_method":"/**\n   * Sets the file attribute.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} to set attribute for\n   * @param options attributes to be set, see {@link SetAttributeOptions}\n   * @param rootRequired indicates whether it requires to be the superuser\n   * @param ownerRequired indicates whether it requires to be the owner of this path\n   * @throws InvalidPathException if the given path is invalid\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws AccessControlException if permission checking fails\n   */\n  long setAttributeAndJournal(InodePath inodePath, SetAttributeOptions options,\n      boolean rootRequired, boolean ownerRequired)\n      throws InvalidPathException, FileDoesNotExistException, AccessControlException {\n    Inode<?> targetInode = inodePath.getInode();\n    long opTimeMs = System.currentTimeMillis();\n    if (options.isRecursive() && targetInode.isDirectory()) {\n      try (InodeLockGroup lockGroup = mInodeTree\n          .getInodeChildrenRecursive(inodePath, InodeTree.LockMode.WRITE)) {\n        List<Inode<?>> inodeChildren = lockGroup.getInodes();\n        for (Inode<?> inode : inodeChildren) {\n          // the path to inode for getPath should already be locked.\n          try (InodePath childPath = mInodeTree.lockFullInodePath(mInodeTree.getPath(inode),\n              InodeTree.LockMode.READ)) {\n            // TODO(gpang): a better way to check permissions\n            mPermissionChecker\n                .checkSetAttributePermission(childPath, rootRequired, ownerRequired);\n          }\n        }\n        TempInodePathWithDescendant tempInodePath = new TempInodePathWithDescendant(inodePath);\n        for (Inode<?> inode : inodeChildren) {\n          // the path to inode for getPath should already be locked.\n          tempInodePath.setDescendant(inode, mInodeTree.getPath(inode));\n          setAttributeInternal(tempInodePath, opTimeMs, options);\n          journalSetAttribute(inode.getId(), opTimeMs, options);\n        }\n      }\n    }\n    setAttributeInternal(inodePath, opTimeMs, options);\n    return journalSetAttribute(targetInode.getId(), opTimeMs, options);\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Unmounts a UFS path previously mounted path onto an Alluxio path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the Alluxio path to unmount, must be a mount point\n   * @return true if the UFS path was successfully unmounted, false otherwise\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileDoesNotExistException if the path to be mounted does not exist\n   * @throws IOException if an I/O error occurs\n   */\n  boolean unmountAndJournal(InodePath inodePath)\n      throws InvalidPathException, FileDoesNotExistException, IOException {\n    if (unmountInternal(inodePath)) {\n      Inode<?> inode = inodePath.getInode();\n      // Use the internal delete API, setting {@code replayed} to true to prevent the delete\n      // operations from being persisted in the UFS.\n      long fileId = inode.getId();\n      long opTimeMs = System.currentTimeMillis();\n      deleteRecursiveInternal(inodePath, true /* replayed */, opTimeMs);\n      DeleteFileEntry deleteFile =\n          DeleteFileEntry.newBuilder().setId(fileId).setRecursive(true).setOpTimeMs(opTimeMs)\n              .build();\n      writeJournalEntry(JournalEntry.newBuilder().setDeleteFile(deleteFile).build());\n      DeleteMountPointEntry deleteMountPoint =\n          DeleteMountPointEntry.newBuilder().setAlluxioPath(inodePath.getUri().toString()).build();\n      writeJournalEntry(JournalEntry.newBuilder().setDeleteMountPoint(deleteMountPoint).build());\n      flushJournal();\n      return true;\n    }\n    return false;\n  }","id":42863,"modified_method":"/**\n   * Unmounts a UFS path previously mounted path onto an Alluxio path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the Alluxio path to unmount, must be a mount point\n   * @return the flush counter for journaling\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileDoesNotExistException if the path to be mounted does not exist\n   * @throws IOException if an I/O error occurs\n   */\n  long unmountAndJournal(InodePath inodePath)\n      throws InvalidPathException, FileDoesNotExistException, IOException {\n    if (unmountInternal(inodePath)) {\n      Inode<?> inode = inodePath.getInode();\n      // Use the internal delete API, setting {@code replayed} to true to prevent the delete\n      // operations from being persisted in the UFS.\n      long fileId = inode.getId();\n      long opTimeMs = System.currentTimeMillis();\n      deleteRecursiveInternal(inodePath, true /* replayed */, opTimeMs);\n      DeleteFileEntry deleteFile =\n          DeleteFileEntry.newBuilder().setId(fileId).setRecursive(true).setOpTimeMs(opTimeMs)\n              .build();\n      appendJournalEntry(JournalEntry.newBuilder().setDeleteFile(deleteFile).build());\n      DeleteMountPointEntry deleteMountPoint =\n          DeleteMountPointEntry.newBuilder().setAlluxioPath(inodePath.getUri().toString()).build();\n      return appendJournalEntry(\n          JournalEntry.newBuilder().setDeleteMountPoint(deleteMountPoint).build());\n    }\n    return AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Schedules a file for async persistence.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} of the file for persistence\n   * @throws AlluxioException if scheduling fails\n   */\n  void scheduleAsyncPersistenceAndJournal(InodePath inodePath) throws AlluxioException {\n    long fileId = inodePath.getInode().getId();\n    scheduleAsyncPersistenceInternal(inodePath);\n    // write to journal\n    AsyncPersistRequestEntry asyncPersistRequestEntry =\n        AsyncPersistRequestEntry.newBuilder().setFileId(fileId).build();\n    writeJournalEntry(\n        JournalEntry.newBuilder().setAsyncPersistRequest(asyncPersistRequestEntry).build());\n    flushJournal();\n  }","id":42864,"modified_method":"/**\n   * Schedules a file for async persistence.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} of the file for persistence\n   * @return the flush counter for journaling\n   * @throws AlluxioException if scheduling fails\n   */\n  long scheduleAsyncPersistenceAndJournal(InodePath inodePath) throws AlluxioException {\n    long fileId = inodePath.getInode().getId();\n    scheduleAsyncPersistenceInternal(inodePath);\n    // write to journal\n    AsyncPersistRequestEntry asyncPersistRequestEntry =\n        AsyncPersistRequestEntry.newBuilder().setFileId(fileId).build();\n    return appendJournalEntry(\n        JournalEntry.newBuilder().setAsyncPersistRequest(asyncPersistRequestEntry).build());\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Renames a file to a destination.\n   * <p>\n   * This operation requires users to have\n   * {@link FileSystemAction#WRITE} permission on the parent of the src path, and\n   * {@link FileSystemAction#WRITE} permission on the parent of the dst path.\n   *\n   * @param srcPath the source path to rename\n   * @param dstPath the destination path to rename the file to\n   * @throws FileDoesNotExistException if a non-existent file is encountered\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if permission checking fails\n   * @throws FileAlreadyExistsException if the file already exists\n   */\n  public void rename(AlluxioURI srcPath, AlluxioURI dstPath) throws FileAlreadyExistsException,\n      FileDoesNotExistException, InvalidPathException, IOException, AccessControlException {\n    MasterContext.getMasterSource().incRenamePathOps(1);\n    try (InodePathPair inodePathPair = mInodeTree\n        .lockInodePathPair(srcPath, InodeTree.LockMode.WRITE_PARENT, dstPath,\n            InodeTree.LockMode.WRITE)) {\n      InodePath srcInodePath = inodePathPair.getFirst();\n      InodePath dstInodePath = inodePathPair.getSecond();\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, srcInodePath);\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, dstInodePath);\n      mMountTable.checkUnderWritableMountPoint(srcPath);\n      mMountTable.checkUnderWritableMountPoint(dstPath);\n      renameAndJournal(srcInodePath, dstInodePath);\n      LOG.debug(\"Renamed {} to {}\", srcPath, dstPath);\n    }\n  }","id":42865,"modified_method":"/**\n   * Renames a file to a destination.\n   * <p>\n   * This operation requires users to have\n   * {@link FileSystemAction#WRITE} permission on the parent of the src path, and\n   * {@link FileSystemAction#WRITE} permission on the parent of the dst path.\n   *\n   * @param srcPath the source path to rename\n   * @param dstPath the destination path to rename the file to\n   * @throws FileDoesNotExistException if a non-existent file is encountered\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if permission checking fails\n   * @throws FileAlreadyExistsException if the file already exists\n   */\n  public void rename(AlluxioURI srcPath, AlluxioURI dstPath) throws FileAlreadyExistsException,\n      FileDoesNotExistException, InvalidPathException, IOException, AccessControlException {\n    MasterContext.getMasterSource().incRenamePathOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePathPair inodePathPair = mInodeTree\n        .lockInodePathPair(srcPath, InodeTree.LockMode.WRITE_PARENT, dstPath,\n            InodeTree.LockMode.WRITE)) {\n      InodePath srcInodePath = inodePathPair.getFirst();\n      InodePath dstInodePath = inodePathPair.getSecond();\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, srcInodePath);\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, dstInodePath);\n      mMountTable.checkUnderWritableMountPoint(srcPath);\n      mMountTable.checkUnderWritableMountPoint(dstPath);\n      flushCounter = renameAndJournal(srcInodePath, dstInodePath);\n      LOG.debug(\"Renamed {} to {}\", srcPath, dstPath);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Loads the metadata for the path, if it doesn't exist.\n   *\n   * @param inodePath the {@link InodePath} to load the metadata for\n   */\n  @GuardedBy(\"mInodeTree\")\n  private void loadMetadataIfNotExist(InodePath inodePath) {\n    if (!inodePath.fullPathExists()) {\n      try {\n        loadMetadataAndJournal(inodePath, true);\n      } catch (Exception e) {\n        LOG.error(\"Failed to load metadata for path: {}\", inodePath.getUri());\n      }\n    }\n  }","id":42866,"modified_method":"/**\n   * Loads the metadata for the path, if it doesn't exist.\n   *\n   * @param inodePath the {@link InodePath} to load the metadata for\n   */\n  @GuardedBy(\"mInodeTree\")\n  private long loadMetadataIfNotExistAndJournal(InodePath inodePath) {\n    if (!inodePath.fullPathExists()) {\n      try {\n        return loadMetadataAndJournal(inodePath, true);\n      } catch (Exception e) {\n        LOG.error(\"Failed to load metadata for path: {}\", inodePath.getUri());\n      }\n    }\n    return AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a directory for a given path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} of the directory\n   * @param options method options\n   * @return an {@link alluxio.master.file.meta.InodeTree.CreatePathResult} representing the\n   *         modified inodes and created inodes during path creation\n   * @throws FileAlreadyExistsException when there is already a file at path\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   * @throws InvalidPathException when the path is invalid, please see documentation on\n   *         {@link InodeTree#createPath(InodePath, CreatePathOptions)} for more details\n   * @throws AccessControlException if permission checking fails\n   * @throws IOException if a non-Alluxio related exception occurs\n   */\n  InodeTree.CreatePathResult createDirectoryAndJournal(InodePath inodePath,\n      CreateDirectoryOptions options)\n      throws FileAlreadyExistsException, FileDoesNotExistException, InvalidPathException,\n      AccessControlException, IOException {\n    InodeTree.CreatePathResult createResult = createDirectoryInternal(inodePath, options);\n    writeJournalEntry(mDirectoryIdGenerator.toJournalEntry());\n    journalCreatePathResult(createResult);\n    flushJournal();\n    MasterContext.getMasterSource().incDirectoriesCreated(1);\n    return createResult;\n  }","id":42867,"modified_method":"/**\n   * Creates a directory for a given path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} of the directory\n   * @param options method options\n   * @return the flush counter for journaling\n   * @throws FileAlreadyExistsException when there is already a file at path\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   * @throws InvalidPathException when the path is invalid, please see documentation on\n   *         {@link InodeTree#createPath(InodePath, CreatePathOptions)} for more details\n   * @throws AccessControlException if permission checking fails\n   * @throws IOException if a non-Alluxio related exception occurs\n   */\n  long createDirectoryAndJournal(InodePath inodePath, CreateDirectoryOptions options)\n      throws FileAlreadyExistsException, FileDoesNotExistException, InvalidPathException,\n      AccessControlException, IOException {\n    InodeTree.CreatePathResult createResult = createDirectoryInternal(inodePath, options);\n    long counter = appendJournalEntry(mDirectoryIdGenerator.toJournalEntry());\n    counter = AsyncJournalWriter.getFlushCounter(counter, journalCreatePathResult(createResult));\n    MasterContext.getMasterSource().incDirectoriesCreated(1);\n    return counter;\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Loads metadata for the object identified by the given path from UFS into Alluxio.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the path for which metadata should be loaded\n   * @param recursive whether parent directories should be created if they do not already exist\n   * @return the file id of the loaded path\n   * @throws InvalidPathException if invalid path is encountered\n   * @throws FileDoesNotExistException if there is no UFS path\n   * @throws FileAlreadyExistsException if the object to be loaded already exists\n   * @throws BlockInfoException if an invalid block size is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws InvalidFileSizeException if invalid file size is encountered\n   * @throws AccessControlException if permission checking fails\n   * @throws IOException if an I/O error occurs\n   */\n  long loadMetadataAndJournal(InodePath inodePath, boolean recursive)\n      throws InvalidPathException, FileDoesNotExistException, FileAlreadyExistsException,\n      BlockInfoException, FileAlreadyCompletedException, InvalidFileSizeException,\n      AccessControlException, IOException {\n    AlluxioURI path = inodePath.getUri();\n    MountTable.Resolution resolution = mMountTable.resolve(path);\n    AlluxioURI ufsUri = resolution.getUri();\n    UnderFileSystem ufs = resolution.getUfs();\n    try {\n      if (!ufs.exists(ufsUri.toString())) {\n        throw new FileDoesNotExistException(\n            ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage(path.getPath()));\n      }\n      if (ufs.isFile(ufsUri.toString())) {\n        long ufsBlockSizeByte = ufs.getBlockSizeByte(ufsUri.toString());\n        long ufsLength = ufs.getFileSize(ufsUri.toString());\n        // Metadata loaded from UFS has no TTL set.\n        CreateFileOptions options =\n            CreateFileOptions.defaults().setBlockSizeBytes(ufsBlockSizeByte).setRecursive(recursive)\n                .setMetadataLoad(true).setPersisted(true);\n        long fileId = createFileAndJournal(inodePath, options);\n        CompleteFileOptions completeOptions =\n            CompleteFileOptions.defaults().setUfsLength(ufsLength);\n        completeFileAndJournal(inodePath, completeOptions);\n        return fileId;\n      }\n      return loadDirectoryMetadataInternal(inodePath, recursive);\n    } catch (IOException e) {\n      LOG.error(ExceptionUtils.getStackTrace(e));\n      throw e;\n    }\n  }","id":42868,"modified_method":"/**\n   * Loads metadata for the object identified by the given path from UFS into Alluxio.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the path for which metadata should be loaded\n   * @param recursive whether parent directories should be created if they do not already exist\n   * @return the flush counter for journaling\n   * @throws InvalidPathException if invalid path is encountered\n   * @throws FileDoesNotExistException if there is no UFS path\n   * @throws FileAlreadyExistsException if the object to be loaded already exists\n   * @throws BlockInfoException if an invalid block size is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws InvalidFileSizeException if invalid file size is encountered\n   * @throws AccessControlException if permission checking fails\n   * @throws IOException if an I/O error occurs\n   */\n  long loadMetadataAndJournal(InodePath inodePath, boolean recursive)\n      throws InvalidPathException, FileDoesNotExistException, FileAlreadyExistsException,\n      BlockInfoException, FileAlreadyCompletedException, InvalidFileSizeException,\n      AccessControlException, IOException {\n    AlluxioURI path = inodePath.getUri();\n    MountTable.Resolution resolution = mMountTable.resolve(path);\n    AlluxioURI ufsUri = resolution.getUri();\n    UnderFileSystem ufs = resolution.getUfs();\n    try {\n      if (!ufs.exists(ufsUri.toString())) {\n        throw new FileDoesNotExistException(\n            ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage(path.getPath()));\n      }\n      if (ufs.isFile(ufsUri.toString())) {\n        long ufsBlockSizeByte = ufs.getBlockSizeByte(ufsUri.toString());\n        long ufsLength = ufs.getFileSize(ufsUri.toString());\n        // Metadata loaded from UFS has no TTL set.\n        CreateFileOptions options =\n            CreateFileOptions.defaults().setBlockSizeBytes(ufsBlockSizeByte).setRecursive(recursive)\n                .setMetadataLoad(true).setPersisted(true);\n        long counter = createFileAndJournal(inodePath, options);\n        long fileId = inodePath.getInode().getId();\n        CompleteFileOptions completeOptions =\n            CompleteFileOptions.defaults().setUfsLength(ufsLength);\n        counter = AsyncJournalWriter\n            .getFlushCounter(counter, completeFileAndJournal(inodePath, completeOptions));\n        return counter;\n      }\n      return loadDirectoryMetadataAndJournal(inodePath, recursive);\n    } catch (IOException e) {\n      LOG.error(ExceptionUtils.getStackTrace(e));\n      throw e;\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a file (not a directory) for a given path.\n   * <p>\n   * This operation requires {@link FileSystemAction#WRITE} permission on the parent of this path.\n   *\n   * @param path the file to create\n   * @param options method options\n   * @return the file id of the create file\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileAlreadyExistsException if the file already exists\n   * @throws BlockInfoException if an invalid block information in encountered\n   * @throws IOException if the creation fails\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   */\n  public long createFile(AlluxioURI path, CreateFileOptions options)\n      throws AccessControlException, InvalidPathException, FileAlreadyExistsException,\n          BlockInfoException, IOException, FileDoesNotExistException {\n    MasterContext.getMasterSource().incCreateFileOps(1);\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(path);\n      createFileAndJournal(inodePath, options);\n      return inodePath.getInode().getId();\n    }\n  }","id":42869,"modified_method":"/**\n   * Creates a file (not a directory) for a given path.\n   * <p>\n   * This operation requires {@link FileSystemAction#WRITE} permission on the parent of this path.\n   *\n   * @param path the file to create\n   * @param options method options\n   * @return the file id of the create file\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileAlreadyExistsException if the file already exists\n   * @throws BlockInfoException if an invalid block information in encountered\n   * @throws IOException if the creation fails\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   */\n  public long createFile(AlluxioURI path, CreateFileOptions options)\n      throws AccessControlException, InvalidPathException, FileAlreadyExistsException,\n          BlockInfoException, IOException, FileDoesNotExistException {\n    MasterContext.getMasterSource().incCreateFileOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(path);\n      flushCounter = createFileAndJournal(inodePath, options);\n      return inodePath.getInode().getId();\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Loads metadata for the object identified by the given path from UFS into Alluxio.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the path\n   * and its parent path if path is a file, or @link FileSystemAction#WRITE} permission on the\n   * parent path if path is a directory.\n   *\n   * @param path the path for which metadata should be loaded\n   * @param recursive whether parent directories should be created if they do not already exist\n   * @return the file id of the loaded path\n   * @throws BlockInfoException if an invalid block size is encountered\n   * @throws FileAlreadyExistsException if the object to be loaded already exists\n   * @throws FileDoesNotExistException if there is no UFS path\n   * @throws InvalidPathException if invalid path is encountered\n   * @throws InvalidFileSizeException if invalid file size is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if permission checking fails\n   */\n  // TODO(jiri): Make it possible to load UFS objects recursively.\n  public long loadMetadata(AlluxioURI path, boolean recursive)\n      throws BlockInfoException, FileAlreadyExistsException, FileDoesNotExistException,\n      InvalidPathException, InvalidFileSizeException, FileAlreadyCompletedException, IOException,\n      AccessControlException {\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      loadMetadataAndJournal(inodePath, recursive);\n      return inodePath.getInode().getId();\n    }\n  }","id":42870,"modified_method":"/**\n   * Loads metadata for the object identified by the given path from UFS into Alluxio.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the path\n   * and its parent path if path is a file, or @link FileSystemAction#WRITE} permission on the\n   * parent path if path is a directory.\n   *\n   * @param path the path for which metadata should be loaded\n   * @param recursive whether parent directories should be created if they do not already exist\n   * @return the file id of the loaded path\n   * @throws BlockInfoException if an invalid block size is encountered\n   * @throws FileAlreadyExistsException if the object to be loaded already exists\n   * @throws FileDoesNotExistException if there is no UFS path\n   * @throws InvalidPathException if invalid path is encountered\n   * @throws InvalidFileSizeException if invalid file size is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if permission checking fails\n   */\n  // TODO(jiri): Make it possible to load UFS objects recursively.\n  public long loadMetadata(AlluxioURI path, boolean recursive)\n      throws BlockInfoException, FileAlreadyExistsException, FileDoesNotExistException,\n      InvalidPathException, InvalidFileSizeException, FileAlreadyCompletedException, IOException,\n      AccessControlException {\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      flushCounter = loadMetadataAndJournal(inodePath, recursive);\n      return inodePath.getInode().getId();\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Unmounts a UFS path previously mounted path onto an Alluxio path.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the parent\n   * of the Alluxio path.\n   *\n   * @param alluxioPath the Alluxio path to unmount, must be a mount point\n   * @return true if the UFS path was successfully unmounted, false otherwise\n   * @throws FileDoesNotExistException if the path to be mounted does not exist\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if the permission check fails\n   */\n  public boolean unmount(AlluxioURI alluxioPath)\n      throws FileDoesNotExistException, InvalidPathException, IOException, AccessControlException {\n    MasterContext.getMasterSource().incUnmountOps(1);\n    try (\n        InodePath inodePath = mInodeTree.lockFullInodePath(alluxioPath, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      if (unmountAndJournal(inodePath)) {\n        MasterContext.getMasterSource().incPathsUnmounted(1);\n        return true;\n      }\n      return false;\n    }\n  }","id":42871,"modified_method":"/**\n   * Unmounts a UFS path previously mounted path onto an Alluxio path.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the parent\n   * of the Alluxio path.\n   *\n   * @param alluxioPath the Alluxio path to unmount, must be a mount point\n   * @return true if the UFS path was successfully unmounted, false otherwise\n   * @throws FileDoesNotExistException if the path to be mounted does not exist\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if the permission check fails\n   */\n  public boolean unmount(AlluxioURI alluxioPath)\n      throws FileDoesNotExistException, InvalidPathException, IOException, AccessControlException {\n    MasterContext.getMasterSource().incUnmountOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (\n        InodePath inodePath = mInodeTree.lockFullInodePath(alluxioPath, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      flushCounter = unmountAndJournal(inodePath);\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        MasterContext.getMasterSource().incPathsUnmounted(1);\n        return true;\n      }\n      return false;\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * @param fileId the file id to use\n   * @param opTimeMs the operation time (in milliseconds)\n   * @param options the method options\n   */\n  @GuardedBy(\"mInodeTree\")\n  private void journalSetAttribute(long fileId, long opTimeMs, SetAttributeOptions options) {\n    SetAttributeEntry.Builder builder =\n        SetAttributeEntry.newBuilder().setId(fileId).setOpTimeMs(opTimeMs);\n    if (options.getPinned() != null) {\n      builder.setPinned(options.getPinned());\n    }\n    if (options.getTtl() != null) {\n      builder.setTtl(options.getTtl());\n    }\n    if (options.getPersisted() != null) {\n      builder.setPersisted(options.getPersisted());\n    }\n    if (options.getOwner() != null) {\n      builder.setOwner(options.getOwner());\n    }\n    if (options.getGroup() != null) {\n      builder.setGroup(options.getGroup());\n    }\n    if (options.getPermission() != Constants.INVALID_PERMISSION) {\n      builder.setPermission(options.getPermission());\n    }\n    writeJournalEntry(JournalEntry.newBuilder().setSetAttribute(builder).build());\n    flushJournal();\n  }","id":42872,"modified_method":"/**\n   * @param fileId the file id to use\n   * @param opTimeMs the operation time (in milliseconds)\n   * @param options the method options\n   * @return the flush counter for journaling\n   */\n  @GuardedBy(\"mInodeTree\")\n  private long journalSetAttribute(long fileId, long opTimeMs, SetAttributeOptions options) {\n    SetAttributeEntry.Builder builder =\n        SetAttributeEntry.newBuilder().setId(fileId).setOpTimeMs(opTimeMs);\n    if (options.getPinned() != null) {\n      builder.setPinned(options.getPinned());\n    }\n    if (options.getTtl() != null) {\n      builder.setTtl(options.getTtl());\n    }\n    if (options.getPersisted() != null) {\n      builder.setPersisted(options.getPersisted());\n    }\n    if (options.getOwner() != null) {\n      builder.setOwner(options.getOwner());\n    }\n    if (options.getGroup() != null) {\n      builder.setGroup(options.getGroup());\n    }\n    if (options.getPermission() != Constants.INVALID_PERMISSION) {\n      builder.setPermission(options.getPermission());\n    }\n    return appendJournalEntry(JournalEntry.newBuilder().setSetAttribute(builder).build());\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Deletes a given path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the path to delete\n   * @param recursive if true, will delete all its children\n   * @return true if the file was deleted, false otherwise\n   * @throws InvalidPathException if the path is invalid\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws IOException if an I/O error occurs\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   */\n  boolean deleteAndJournal(InodePath inodePath, boolean recursive)\n      throws InvalidPathException, FileDoesNotExistException, IOException,\n      DirectoryNotEmptyException {\n    Inode<?> inode = inodePath.getInode();\n    long fileId = inode.getId();\n    long opTimeMs = System.currentTimeMillis();\n    boolean ret = deleteInternal(inodePath, recursive, false, opTimeMs);\n    DeleteFileEntry deleteFile = DeleteFileEntry.newBuilder()\n        .setId(fileId)\n        .setRecursive(recursive)\n        .setOpTimeMs(opTimeMs)\n        .build();\n    writeJournalEntry(JournalEntry.newBuilder().setDeleteFile(deleteFile).build());\n    flushJournal();\n    return ret;\n  }","id":42873,"modified_method":"/**\n   * Deletes a given path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the path to delete\n   * @param recursive if true, will delete all its children\n   * @return the flush counter for journaling\n   * @throws InvalidPathException if the path is invalid\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws IOException if an I/O error occurs\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   */\n  long deleteAndJournal(InodePath inodePath, boolean recursive)\n      throws InvalidPathException, FileDoesNotExistException, IOException,\n      DirectoryNotEmptyException {\n    Inode<?> inode = inodePath.getInode();\n    long fileId = inode.getId();\n    long opTimeMs = System.currentTimeMillis();\n    deleteInternal(inodePath, recursive, false, opTimeMs);\n    DeleteFileEntry deleteFile = DeleteFileEntry.newBuilder()\n        .setId(fileId)\n        .setRecursive(recursive)\n        .setOpTimeMs(opTimeMs)\n        .build();\n    return appendJournalEntry(JournalEntry.newBuilder().setDeleteFile(deleteFile).build());\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Renames a file to a destination.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param srcInodePath the source path to rename\n   * @param dstInodePath the destination path to rename the file to\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileDoesNotExistException if a non-existent file is encountered\n   * @throws FileAlreadyExistsException if the file already exists\n   * @throws IOException if an I/O error occurs\n   */\n  void renameAndJournal(InodePath srcInodePath, InodePath dstInodePath)\n      throws InvalidPathException, FileDoesNotExistException, FileAlreadyExistsException,\n      IOException {\n    if (!srcInodePath.fullPathExists()) {\n      throw new FileDoesNotExistException(\n          ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage(srcInodePath.getUri()));\n    }\n\n    Inode<?> srcInode = srcInodePath.getInode();\n    // Renaming path to itself is a no-op.\n    if (srcInodePath.getUri().equals(dstInodePath.getUri())) {\n      return;\n    }\n    // Renaming the root is not allowed.\n    if (srcInodePath.getUri().isRoot()) {\n      throw new InvalidPathException(ExceptionMessage.ROOT_CANNOT_BE_RENAMED.getMessage());\n    }\n    if (dstInodePath.getUri().isRoot()) {\n      throw new InvalidPathException(ExceptionMessage.RENAME_CANNOT_BE_TO_ROOT.getMessage());\n    }\n    // Renaming across mount points is not allowed.\n    String srcMount = mMountTable.getMountPoint(srcInodePath.getUri());\n    String dstMount = mMountTable.getMountPoint(dstInodePath.getUri());\n    if ((srcMount == null && dstMount != null) || (srcMount != null && dstMount == null)\n        || (srcMount != null && dstMount != null && !srcMount.equals(dstMount))) {\n      throw new InvalidPathException(ExceptionMessage.RENAME_CANNOT_BE_ACROSS_MOUNTS.getMessage(\n          srcInodePath.getUri(), dstInodePath.getUri()));\n    }\n    // Renaming onto a mount point is not allowed.\n    if (mMountTable.isMountPoint(dstInodePath.getUri())) {\n      throw new InvalidPathException(\n          ExceptionMessage.RENAME_CANNOT_BE_ONTO_MOUNT_POINT.getMessage(dstInodePath.getUri()));\n    }\n    // Renaming a path to one of its subpaths is not allowed. Check for that, by making sure\n    // srcComponents isn't a prefix of dstComponents.\n    if (PathUtils.hasPrefix(dstInodePath.getUri().getPath(), srcInodePath.getUri().getPath())) {\n      throw new InvalidPathException(ExceptionMessage.RENAME_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n          srcInodePath.getUri(), dstInodePath.getUri()));\n    }\n\n    // Get the inodes of the src and dst parents.\n    Inode<?> srcParentInode = srcInodePath.getParentInodeDirectory();\n    if (!srcParentInode.isDirectory()) {\n      throw new InvalidPathException(\n          ExceptionMessage.PATH_MUST_HAVE_VALID_PARENT.getMessage(srcInodePath.getUri()));\n    }\n    Inode<?> dstParentInode = dstInodePath.getParentInodeDirectory();\n    if (!dstParentInode.isDirectory()) {\n      throw new InvalidPathException(\n          ExceptionMessage.PATH_MUST_HAVE_VALID_PARENT.getMessage(dstInodePath.getUri()));\n    }\n\n    // Make sure destination path does not exist\n    if (dstInodePath.fullPathExists()) {\n      throw new FileAlreadyExistsException(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(dstInodePath.getUri()));\n    }\n\n    // Now we remove srcInode from it's parent and insert it into dstPath's parent\n    long opTimeMs = System.currentTimeMillis();\n    renameInternal(srcInodePath, dstInodePath, false, opTimeMs);\n\n    RenameEntry rename = RenameEntry.newBuilder()\n        .setId(srcInode.getId())\n        .setDstPath(dstInodePath.getUri().getPath())\n        .setOpTimeMs(opTimeMs)\n        .build();\n    writeJournalEntry(JournalEntry.newBuilder().setRename(rename).build());\n    flushJournal();\n  }","id":42874,"modified_method":"/**\n   * Renames a file to a destination.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param srcInodePath the source path to rename\n   * @param dstInodePath the destination path to rename the file to\n   * @return the flush counter for journaling\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileDoesNotExistException if a non-existent file is encountered\n   * @throws FileAlreadyExistsException if the file already exists\n   * @throws IOException if an I/O error occurs\n   */\n  long renameAndJournal(InodePath srcInodePath, InodePath dstInodePath)\n      throws InvalidPathException, FileDoesNotExistException, FileAlreadyExistsException,\n      IOException {\n    if (!srcInodePath.fullPathExists()) {\n      throw new FileDoesNotExistException(\n          ExceptionMessage.PATH_DOES_NOT_EXIST.getMessage(srcInodePath.getUri()));\n    }\n\n    Inode<?> srcInode = srcInodePath.getInode();\n    // Renaming path to itself is a no-op.\n    if (srcInodePath.getUri().equals(dstInodePath.getUri())) {\n      return AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    }\n    // Renaming the root is not allowed.\n    if (srcInodePath.getUri().isRoot()) {\n      throw new InvalidPathException(ExceptionMessage.ROOT_CANNOT_BE_RENAMED.getMessage());\n    }\n    if (dstInodePath.getUri().isRoot()) {\n      throw new InvalidPathException(ExceptionMessage.RENAME_CANNOT_BE_TO_ROOT.getMessage());\n    }\n    // Renaming across mount points is not allowed.\n    String srcMount = mMountTable.getMountPoint(srcInodePath.getUri());\n    String dstMount = mMountTable.getMountPoint(dstInodePath.getUri());\n    if ((srcMount == null && dstMount != null) || (srcMount != null && dstMount == null)\n        || (srcMount != null && dstMount != null && !srcMount.equals(dstMount))) {\n      throw new InvalidPathException(ExceptionMessage.RENAME_CANNOT_BE_ACROSS_MOUNTS.getMessage(\n          srcInodePath.getUri(), dstInodePath.getUri()));\n    }\n    // Renaming onto a mount point is not allowed.\n    if (mMountTable.isMountPoint(dstInodePath.getUri())) {\n      throw new InvalidPathException(\n          ExceptionMessage.RENAME_CANNOT_BE_ONTO_MOUNT_POINT.getMessage(dstInodePath.getUri()));\n    }\n    // Renaming a path to one of its subpaths is not allowed. Check for that, by making sure\n    // srcComponents isn't a prefix of dstComponents.\n    if (PathUtils.hasPrefix(dstInodePath.getUri().getPath(), srcInodePath.getUri().getPath())) {\n      throw new InvalidPathException(ExceptionMessage.RENAME_CANNOT_BE_TO_SUBDIRECTORY.getMessage(\n          srcInodePath.getUri(), dstInodePath.getUri()));\n    }\n\n    // Get the inodes of the src and dst parents.\n    Inode<?> srcParentInode = srcInodePath.getParentInodeDirectory();\n    if (!srcParentInode.isDirectory()) {\n      throw new InvalidPathException(\n          ExceptionMessage.PATH_MUST_HAVE_VALID_PARENT.getMessage(srcInodePath.getUri()));\n    }\n    Inode<?> dstParentInode = dstInodePath.getParentInodeDirectory();\n    if (!dstParentInode.isDirectory()) {\n      throw new InvalidPathException(\n          ExceptionMessage.PATH_MUST_HAVE_VALID_PARENT.getMessage(dstInodePath.getUri()));\n    }\n\n    // Make sure destination path does not exist\n    if (dstInodePath.fullPathExists()) {\n      throw new FileAlreadyExistsException(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(dstInodePath.getUri()));\n    }\n\n    // Now we remove srcInode from it's parent and insert it into dstPath's parent\n    long opTimeMs = System.currentTimeMillis();\n    renameInternal(srcInodePath, dstInodePath, false, opTimeMs);\n\n    RenameEntry rename = RenameEntry.newBuilder()\n        .setId(srcInode.getId())\n        .setDstPath(dstInodePath.getUri().getPath())\n        .setOpTimeMs(opTimeMs)\n        .build();\n    return appendJournalEntry(JournalEntry.newBuilder().setRename(rename).build());\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Returns the {@link FileInfo} for a given path.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#READ} permission on the path.\n   *\n   * @param path the path to get the {@link FileInfo} for\n   * @return the {@link FileInfo} for the given file id\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws InvalidPathException if the file path is not valid\n   * @throws AccessControlException if permission checking fails\n   */\n  public FileInfo getFileInfo(AlluxioURI path)\n      throws FileDoesNotExistException, InvalidPathException, AccessControlException {\n    MasterContext.getMasterSource().incGetFileInfoOps(1);\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ)) {\n      mPermissionChecker.checkPermission(FileSystemAction.READ, inodePath);\n      loadMetadataIfNotExist(inodePath);\n      mInodeTree.ensureFullInodePath(inodePath, InodeTree.LockMode.READ);\n      return getFileInfoInternal(inodePath);\n    }\n  }","id":42875,"modified_method":"/**\n   * Returns the {@link FileInfo} for a given path.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#READ} permission on the path.\n   *\n   * @param path the path to get the {@link FileInfo} for\n   * @return the {@link FileInfo} for the given file id\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws InvalidPathException if the file path is not valid\n   * @throws AccessControlException if permission checking fails\n   */\n  public FileInfo getFileInfo(AlluxioURI path)\n      throws FileDoesNotExistException, InvalidPathException, AccessControlException {\n    MasterContext.getMasterSource().incGetFileInfoOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ)) {\n      mPermissionChecker.checkPermission(FileSystemAction.READ, inodePath);\n      flushCounter = loadMetadataIfNotExistAndJournal(inodePath);\n      mInodeTree.ensureFullInodePath(inodePath, InodeTree.LockMode.READ);\n      return getFileInfoInternal(inodePath);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Mounts a UFS path onto an Alluxio path.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the parent\n   * of the Alluxio path.\n   *\n   * @param alluxioPath the Alluxio path to mount to\n   * @param ufsPath the UFS path to mount\n   * @param options the mount options\n   * @throws FileAlreadyExistsException if the path to be mounted already exists\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if the permission check fails\n   */\n  public void mount(AlluxioURI alluxioPath, AlluxioURI ufsPath, MountOptions options)\n      throws FileAlreadyExistsException, InvalidPathException, IOException, AccessControlException {\n    MasterContext.getMasterSource().incMountOps(1);\n    try (InodePath inodePath = mInodeTree.lockInodePath(alluxioPath, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(alluxioPath);\n      mountAndJournal(inodePath, ufsPath, options);\n      MasterContext.getMasterSource().incPathsMounted(1);\n    }\n  }","id":42876,"modified_method":"/**\n   * Mounts a UFS path onto an Alluxio path.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the parent\n   * of the Alluxio path.\n   *\n   * @param alluxioPath the Alluxio path to mount to\n   * @param ufsPath the UFS path to mount\n   * @param options the mount options\n   * @throws FileAlreadyExistsException if the path to be mounted already exists\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if the permission check fails\n   */\n  public void mount(AlluxioURI alluxioPath, AlluxioURI ufsPath, MountOptions options)\n      throws FileAlreadyExistsException, InvalidPathException, IOException, AccessControlException {\n    MasterContext.getMasterSource().incMountOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(alluxioPath, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(alluxioPath);\n      flushCounter = mountAndJournal(inodePath, ufsPath, options);\n      MasterContext.getMasterSource().incPathsMounted(1);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a file (not a directory) for a given path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the file to create\n   * @param options method options\n   * @return the file id of the create file\n   * @throws FileAlreadyExistsException if the file already exists\n   * @throws BlockInfoException if an invalid block information in encountered\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if the creation fails\n   */\n  long createFileAndJournal(InodePath inodePath, CreateFileOptions options)\n      throws FileAlreadyExistsException, BlockInfoException, FileDoesNotExistException,\n      InvalidPathException, IOException {\n    InodeTree.CreatePathResult createResult = createFileInternal(inodePath, options);\n    List<Inode<?>> created = createResult.getCreated();\n\n    writeJournalEntry(mDirectoryIdGenerator.toJournalEntry());\n    journalCreatePathResult(createResult);\n    flushJournal();\n    return created.get(created.size() - 1).getId();\n  }","id":42877,"modified_method":"/**\n   * Creates a file (not a directory) for a given path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the file to create\n   * @param options method options\n   * @return the file id of the create file\n   * @throws FileAlreadyExistsException if the file already exists\n   * @throws BlockInfoException if an invalid block information in encountered\n   * @throws FileDoesNotExistException if the parent of the path does not exist and the recursive\n   *         option is false\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws IOException if the creation fails\n   */\n  long createFileAndJournal(InodePath inodePath, CreateFileOptions options)\n      throws FileAlreadyExistsException, BlockInfoException, FileDoesNotExistException,\n      InvalidPathException, IOException {\n    InodeTree.CreatePathResult createResult = createFileInternal(inodePath, options);\n\n    long counter = appendJournalEntry(mDirectoryIdGenerator.toJournalEntry());\n    counter = AsyncJournalWriter.getFlushCounter(counter, journalCreatePathResult(createResult));\n    return counter;\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Mounts a UFS path onto an Alluxio path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the Alluxio path to mount to\n   * @param ufsPath the UFS path to mount\n   * @param options the mount options\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileAlreadyExistsException if the path to be mounted already exists\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if the permission check fails\n   */\n  void mountAndJournal(InodePath inodePath, AlluxioURI ufsPath, MountOptions options)\n      throws InvalidPathException, FileAlreadyExistsException, IOException, AccessControlException {\n    // Check that the Alluxio Path does not exist\n    if (inodePath.fullPathExists()) {\n      // TODO(calvin): Add a test to validate this (ALLUXIO-1831)\n      throw new InvalidPathException(\n          ExceptionMessage.MOUNT_POINT_ALREADY_EXISTS.getMessage(inodePath.getUri()));\n    }\n\n    mountInternal(inodePath, ufsPath, options);\n    boolean loadMetadataSuceeded = false;\n    try {\n      // This will create the directory at alluxioPath\n      loadDirectoryMetadataInternal(inodePath, false);\n      loadMetadataSuceeded = true;\n    } catch (FileDoesNotExistException e) {\n      // This exception should be impossible since we just mounted this path\n      throw Throwables.propagate(e);\n    } finally {\n      if (!loadMetadataSuceeded) {\n        unmountInternal(inodePath);\n      }\n      // Exception will be propagated from loadDirectoryMetadataInternal\n    }\n\n    // For proto, build a list of String pairs representing the properties map.\n    Map<String, String> properties = options.getProperties();\n    List<StringPairEntry> protoProperties = new ArrayList<>(properties.size());\n    for (Map.Entry<String, String> entry : properties.entrySet()) {\n      protoProperties.add(StringPairEntry.newBuilder()\n          .setKey(entry.getKey())\n          .setValue(entry.getValue())\n          .build());\n    }\n\n    AddMountPointEntry addMountPoint =\n        AddMountPointEntry.newBuilder().setAlluxioPath(inodePath.getUri().toString())\n            .setUfsPath(ufsPath.toString()).setReadOnly(options.isReadOnly())\n            .addAllProperties(protoProperties).build();\n    writeJournalEntry(JournalEntry.newBuilder().setAddMountPoint(addMountPoint).build());\n    flushJournal();\n  }","id":42878,"modified_method":"/**\n   * Mounts a UFS path onto an Alluxio path.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the Alluxio path to mount to\n   * @param ufsPath the UFS path to mount\n   * @param options the mount options\n   * @return the flush counter for journaling\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileAlreadyExistsException if the path to be mounted already exists\n   * @throws IOException if an I/O error occurs\n   * @throws AccessControlException if the permission check fails\n   */\n  long mountAndJournal(InodePath inodePath, AlluxioURI ufsPath, MountOptions options)\n      throws InvalidPathException, FileAlreadyExistsException, IOException, AccessControlException {\n    // Check that the Alluxio Path does not exist\n    if (inodePath.fullPathExists()) {\n      // TODO(calvin): Add a test to validate this (ALLUXIO-1831)\n      throw new InvalidPathException(\n          ExceptionMessage.MOUNT_POINT_ALREADY_EXISTS.getMessage(inodePath.getUri()));\n    }\n\n    mountInternal(inodePath, ufsPath, options);\n    boolean loadMetadataSuceeded = false;\n    try {\n      // This will create the directory at alluxioPath\n      loadDirectoryMetadataAndJournal(inodePath, false);\n      loadMetadataSuceeded = true;\n    } catch (FileDoesNotExistException e) {\n      // This exception should be impossible since we just mounted this path\n      throw Throwables.propagate(e);\n    } finally {\n      if (!loadMetadataSuceeded) {\n        unmountInternal(inodePath);\n      }\n      // Exception will be propagated from loadDirectoryMetadataAndJournal\n    }\n\n    // For proto, build a list of String pairs representing the properties map.\n    Map<String, String> properties = options.getProperties();\n    List<StringPairEntry> protoProperties = new ArrayList<>(properties.size());\n    for (Map.Entry<String, String> entry : properties.entrySet()) {\n      protoProperties.add(StringPairEntry.newBuilder()\n          .setKey(entry.getKey())\n          .setValue(entry.getValue())\n          .build());\n    }\n\n    AddMountPointEntry addMountPoint =\n        AddMountPointEntry.newBuilder().setAlluxioPath(inodePath.getUri().toString())\n            .setUfsPath(ufsPath.toString()).setReadOnly(options.isReadOnly())\n            .addAllProperties(protoProperties).build();\n    return appendJournalEntry(JournalEntry.newBuilder().setAddMountPoint(addMountPoint).build());\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Loads metadata for the directory identified by the given path from UFS into Alluxio. This does\n   * not actually require looking at the UFS path.\n   *\n   * @param inodePath the path for which metadata should be loaded\n   * @param recursive whether parent directories should be created if they do not already exist\n   * @return the file id of the loaded directory\n   * @throws FileAlreadyExistsException if the object to be loaded already exists\n   * @throws InvalidPathException if invalid path is encountered\n   * @throws IOException if an I/O error occurs   *\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the path does not exist\n   */\n  @GuardedBy(\"mInodeTree\")\n  private long loadDirectoryMetadataInternal(InodePath inodePath, boolean recursive)\n      throws FileAlreadyExistsException, FileDoesNotExistException, InvalidPathException,\n      AccessControlException, IOException {\n    CreateDirectoryOptions options = CreateDirectoryOptions.defaults()\n        .setMountPoint(mMountTable.isMountPoint(inodePath.getUri())).setPersisted(true)\n        .setRecursive(recursive).setMetadataLoad(true);\n    InodeTree.CreatePathResult result = createDirectoryAndJournal(inodePath, options);\n    List<Inode<?>> inodes = null;\n    if (result.getCreated().size() > 0) {\n      inodes = result.getCreated();\n    } else if (result.getPersisted().size() > 0) {\n      inodes = result.getPersisted();\n    } else if (result.getModified().size() > 0) {\n      inodes = result.getModified();\n    }\n    if (inodes == null) {\n      throw new FileAlreadyExistsException(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(inodePath.getUri()));\n    }\n    return inodes.get(inodes.size() - 1).getId();\n  }","id":42879,"modified_method":"/**\n   * Loads metadata for the directory identified by the given path from UFS into Alluxio. This does\n   * not actually require looking at the UFS path.\n   *\n   * @param inodePath the path for which metadata should be loaded\n   * @param recursive whether parent directories should be created if they do not already exist\n   * @return the flush counter for journaling\n   * @throws FileAlreadyExistsException if the object to be loaded already exists\n   * @throws InvalidPathException if invalid path is encountered\n   * @throws IOException if an I/O error occurs   *\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the path does not exist\n   */\n  @GuardedBy(\"mInodeTree\")\n  private long loadDirectoryMetadataAndJournal(InodePath inodePath, boolean recursive)\n      throws FileAlreadyExistsException, FileDoesNotExistException, InvalidPathException,\n      AccessControlException, IOException {\n    CreateDirectoryOptions options = CreateDirectoryOptions.defaults()\n        .setMountPoint(mMountTable.isMountPoint(inodePath.getUri())).setPersisted(true)\n        .setRecursive(recursive).setMetadataLoad(true);\n    long counter = createDirectoryAndJournal(inodePath, options);\n    if (counter == AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n      throw new FileAlreadyExistsException(\n          ExceptionMessage.FILE_ALREADY_EXISTS.getMessage(inodePath.getUri()));\n    }\n    return counter;\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Returns a list {@link FileInfo} for a given path. If the given path is a file, the list only\n   * contains a single object. If it is a directory, the resulting list contains all direct children\n   * of the directory.\n   * <p>\n   * This operation requires users to have\n   * {@link FileSystemAction#READ} permission on the path, and also\n   * {@link FileSystemAction#EXECUTE} permission on the path if it is a directory.\n   *\n   * @param path the path to get the {@link FileInfo} list for\n   * @return the list of {@link FileInfo}s\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws InvalidPathException if the path is invalid\n   */\n  public List<FileInfo> getFileInfoList(AlluxioURI path)\n      throws AccessControlException, FileDoesNotExistException, InvalidPathException {\n    MasterContext.getMasterSource().incGetFileInfoOps(1);\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ)) {\n      mPermissionChecker.checkPermission(FileSystemAction.READ, inodePath);\n      loadMetadataIfNotExist(inodePath);\n      mInodeTree.ensureFullInodePath(inodePath, InodeTree.LockMode.READ);\n      Inode<?> inode = inodePath.getInode();\n\n      List<FileInfo> ret = new ArrayList<>();\n      if (inode.isDirectory()) {\n        TempInodePathWithDescendant tempInodePath = new TempInodePathWithDescendant(inodePath);\n        mPermissionChecker.checkPermission(FileSystemAction.EXECUTE, inodePath);\n        for (Inode<?> child : ((InodeDirectory) inode).getChildren()) {\n          child.lockRead();\n          try {\n            // the path to child for getPath should already be locked.\n            tempInodePath.setDescendant(child, mInodeTree.getPath(child));\n            ret.add(getFileInfoInternal(tempInodePath));\n          } finally {\n            child.unlockRead();\n          }\n        }\n      } else {\n        ret.add(getFileInfoInternal(inodePath));\n      }\n      MasterContext.getMasterSource().incFileInfosGot(ret.size());\n      return ret;\n    }\n  }","id":42880,"modified_method":"/**\n   * Returns a list {@link FileInfo} for a given path. If the given path is a file, the list only\n   * contains a single object. If it is a directory, the resulting list contains all direct children\n   * of the directory.\n   * <p>\n   * This operation requires users to have\n   * {@link FileSystemAction#READ} permission on the path, and also\n   * {@link FileSystemAction#EXECUTE} permission on the path if it is a directory.\n   *\n   * @param path the path to get the {@link FileInfo} list for\n   * @return the list of {@link FileInfo}s\n   * @throws AccessControlException if permission checking fails\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws InvalidPathException if the path is invalid\n   */\n  public List<FileInfo> getFileInfoList(AlluxioURI path)\n      throws AccessControlException, FileDoesNotExistException, InvalidPathException {\n    MasterContext.getMasterSource().incGetFileInfoOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ)) {\n      mPermissionChecker.checkPermission(FileSystemAction.READ, inodePath);\n      flushCounter = loadMetadataIfNotExistAndJournal(inodePath);\n      mInodeTree.ensureFullInodePath(inodePath, InodeTree.LockMode.READ);\n      Inode<?> inode = inodePath.getInode();\n\n      List<FileInfo> ret = new ArrayList<>();\n      if (inode.isDirectory()) {\n        TempInodePathWithDescendant tempInodePath = new TempInodePathWithDescendant(inodePath);\n        mPermissionChecker.checkPermission(FileSystemAction.EXECUTE, inodePath);\n        for (Inode<?> child : ((InodeDirectory) inode).getChildren()) {\n          child.lockRead();\n          try {\n            // the path to child for getPath should already be locked.\n            tempInodePath.setDescendant(child, mInodeTree.getPath(child));\n            ret.add(getFileInfoInternal(tempInodePath));\n          } finally {\n            child.unlockRead();\n          }\n        }\n      } else {\n        ret.add(getFileInfoInternal(inodePath));\n      }\n      MasterContext.getMasterSource().incFileInfosGot(ret.size());\n      return ret;\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * Journals the {@link InodeTree.CreatePathResult}. This does not flush the journal.\n     * Synchronization is required outside of this method.\n     *\n     * @param createResult the {@link InodeTree.CreatePathResult} to journal\n     */\n  private void journalCreatePathResult(InodeTree.CreatePathResult createResult) {\n    for (Inode<?> inode : createResult.getModified()) {\n      InodeLastModificationTimeEntry inodeLastModificationTime =\n          InodeLastModificationTimeEntry.newBuilder()\n          .setId(inode.getId())\n          .setLastModificationTimeMs(inode.getLastModificationTimeMs())\n          .build();\n      writeJournalEntry(JournalEntry.newBuilder()\n          .setInodeLastModificationTime(inodeLastModificationTime).build());\n    }\n    for (Inode<?> inode : createResult.getCreated()) {\n      writeJournalEntry(inode.toJournalEntry());\n    }\n    for (Inode<?> inode : createResult.getPersisted()) {\n      PersistDirectoryEntry persistDirectory = PersistDirectoryEntry.newBuilder()\n          .setId(inode.getId())\n          .build();\n      writeJournalEntry(JournalEntry.newBuilder().setPersistDirectory(persistDirectory).build());\n    }\n  }","id":42881,"modified_method":"/**\n   * Journals the {@link InodeTree.CreatePathResult}. This does not flush the journal.\n   * Synchronization is required outside of this method.\n   *\n   * @param createResult the {@link InodeTree.CreatePathResult} to journal\n   * @return the flush counter for journaling\n   */\n  private long journalCreatePathResult(InodeTree.CreatePathResult createResult) {\n    long counter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    for (Inode<?> inode : createResult.getModified()) {\n      InodeLastModificationTimeEntry inodeLastModificationTime =\n          InodeLastModificationTimeEntry.newBuilder()\n          .setId(inode.getId())\n          .setLastModificationTimeMs(inode.getLastModificationTimeMs())\n          .build();\n      counter = appendJournalEntry(JournalEntry.newBuilder()\n          .setInodeLastModificationTime(inodeLastModificationTime).build());\n    }\n    for (Inode<?> inode : createResult.getCreated()) {\n      counter = appendJournalEntry(inode.toJournalEntry());\n    }\n    for (Inode<?> inode : createResult.getPersisted()) {\n      PersistDirectoryEntry persistDirectory = PersistDirectoryEntry.newBuilder()\n          .setId(inode.getId())\n          .build();\n      counter = appendJournalEntry(\n          JournalEntry.newBuilder().setPersistDirectory(persistDirectory).build());\n    }\n    return counter;\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Deletes a given path.\n   * <p>\n   * This operation requires user to have {@link FileSystemAction#WRITE}\n   * permission on the parent of the path.\n   *\n   * @param path the path to delete\n   * @param recursive if true, will delete all its children\n   * @return true if the file was deleted, false otherwise\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws IOException if an I/O error occurs\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   * @throws AccessControlException if permission checking fails\n   * @throws InvalidPathException if the path is invalid\n   */\n  public boolean delete(AlluxioURI path, boolean recursive)\n      throws IOException, FileDoesNotExistException, DirectoryNotEmptyException,\n          InvalidPathException, AccessControlException {\n    MasterContext.getMasterSource().incDeletePathOps(1);\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(path);\n      deleteAndJournal(inodePath, recursive);\n      return true;\n    }\n  }","id":42882,"modified_method":"/**\n   * Deletes a given path.\n   * <p>\n   * This operation requires user to have {@link FileSystemAction#WRITE}\n   * permission on the parent of the path.\n   *\n   * @param path the path to delete\n   * @param recursive if true, will delete all its children\n   * @return true if the file was deleted, false otherwise\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws IOException if an I/O error occurs\n   * @throws DirectoryNotEmptyException if recursive is false and the file is a nonempty directory\n   * @throws AccessControlException if permission checking fails\n   * @throws InvalidPathException if the path is invalid\n   */\n  public boolean delete(AlluxioURI path, boolean recursive)\n      throws IOException, FileDoesNotExistException, DirectoryNotEmptyException,\n          InvalidPathException, AccessControlException {\n    MasterContext.getMasterSource().incDeletePathOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, inodePath);\n      mMountTable.checkUnderWritableMountPoint(path);\n      flushCounter = deleteAndJournal(inodePath, recursive);\n      return true;\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Sets the file attribute.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the path. In\n   * addition, the client user must be a super user when setting the owner, and must be a super user\n   * or the owner when setting the group or permission.\n   *\n   * @param path the path to set attribute for\n   * @param options attributes to be set, see {@link SetAttributeOptions}\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws AccessControlException if permission checking fails\n   * @throws InvalidPathException if the given path is invalid\n   */\n  public void setAttribute(AlluxioURI path, SetAttributeOptions options)\n      throws FileDoesNotExistException, AccessControlException, InvalidPathException {\n    MasterContext.getMasterSource().incSetAttributeOps(1);\n    // for chown\n    boolean rootRequired = options.getOwner() != null;\n    // for chgrp, chmod\n    boolean ownerRequired =\n        (options.getGroup() != null) || (options.getPermission() != Constants.INVALID_PERMISSION);\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkSetAttributePermission(inodePath, rootRequired, ownerRequired);\n      setAttributeAndJournal(inodePath, options, rootRequired, ownerRequired);\n    }\n  }","id":42883,"modified_method":"/**\n   * Sets the file attribute.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the path. In\n   * addition, the client user must be a super user when setting the owner, and must be a super user\n   * or the owner when setting the group or permission.\n   *\n   * @param path the path to set attribute for\n   * @param options attributes to be set, see {@link SetAttributeOptions}\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws AccessControlException if permission checking fails\n   * @throws InvalidPathException if the given path is invalid\n   */\n  public void setAttribute(AlluxioURI path, SetAttributeOptions options)\n      throws FileDoesNotExistException, AccessControlException, InvalidPathException {\n    MasterContext.getMasterSource().incSetAttributeOps(1);\n    // for chown\n    boolean rootRequired = options.getOwner() != null;\n    // for chgrp, chmod\n    boolean ownerRequired =\n        (options.getGroup() != null) || (options.getPermission() != Constants.INVALID_PERMISSION);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkSetAttributePermission(inodePath, rootRequired, ownerRequired);\n      flushCounter = setAttributeAndJournal(inodePath, options, rootRequired, ownerRequired);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Completes a file. After a file is completed, it cannot be written to.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the path.\n   *\n   * @param path the file path to complete\n   * @param options the method options\n   * @throws BlockInfoException if a block information exception is encountered\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws InvalidFileSizeException if an invalid file size is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws AccessControlException if permission checking fails\n   */\n  public void completeFile(AlluxioURI path, CompleteFileOptions options)\n      throws BlockInfoException, FileDoesNotExistException, InvalidPathException,\n      InvalidFileSizeException, FileAlreadyCompletedException, AccessControlException {\n    MasterContext.getMasterSource().incCompleteFileOps(1);\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkPermission(FileSystemAction.WRITE, inodePath);\n      // Even readonly mount points should be able to complete a file, for UFS reads in CACHE mode.\n      completeFileAndJournal(inodePath, options);\n    }\n  }","id":42884,"modified_method":"/**\n   * Completes a file. After a file is completed, it cannot be written to.\n   * <p>\n   * This operation requires users to have {@link FileSystemAction#WRITE} permission on the path.\n   *\n   * @param path the file path to complete\n   * @param options the method options\n   * @throws BlockInfoException if a block information exception is encountered\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws InvalidFileSizeException if an invalid file size is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws AccessControlException if permission checking fails\n   */\n  public void completeFile(AlluxioURI path, CompleteFileOptions options)\n      throws BlockInfoException, FileDoesNotExistException, InvalidPathException,\n      InvalidFileSizeException, FileAlreadyCompletedException, AccessControlException {\n    MasterContext.getMasterSource().incCompleteFileOps(1);\n    long flushCounter = AsyncJournalWriter.INVALID_FLUSH_COUNTER;\n    try (InodePath inodePath = mInodeTree.lockFullInodePath(path, InodeTree.LockMode.WRITE)) {\n      mPermissionChecker.checkPermission(FileSystemAction.WRITE, inodePath);\n      // Even readonly mount points should be able to complete a file, for UFS reads in CACHE mode.\n      flushCounter = completeFileAndJournal(inodePath, options);\n    } finally {\n      // finally runs after resources are closed (unlocked).\n      if (flushCounter != AsyncJournalWriter.INVALID_FLUSH_COUNTER) {\n        waitForJournalFlush(flushCounter);\n      }\n    }\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Completes a file. After a file is completed, it cannot be written to.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} to complete\n   * @param options the method options\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws BlockInfoException if a block information exception is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws InvalidFileSizeException if an invalid file size is encountered\n   */\n  void completeFileAndJournal(InodePath inodePath, CompleteFileOptions options)\n      throws InvalidPathException, FileDoesNotExistException, BlockInfoException,\n      FileAlreadyCompletedException, InvalidFileSizeException {\n    long opTimeMs = System.currentTimeMillis();\n    Inode<?> inode = inodePath.getInode();\n    if (!inode.isFile()) {\n      throw new FileDoesNotExistException(\n          ExceptionMessage.PATH_MUST_BE_FILE.getMessage(inodePath.getUri()));\n    }\n\n    InodeFile fileInode = (InodeFile) inode;\n    List<Long> blockIdList = fileInode.getBlockIds();\n    List<BlockInfo> blockInfoList = mBlockMaster.getBlockInfoList(blockIdList);\n    if (!fileInode.isPersisted() && blockInfoList.size() != blockIdList.size()) {\n      throw new BlockInfoException(\"Cannot complete a file without all the blocks committed\");\n    }\n\n    // Iterate over all file blocks committed to Alluxio, computing the length and verify that all\n    // the blocks (except the last one) is the same size as the file block size.\n    long inMemoryLength = 0;\n    long fileBlockSize = fileInode.getBlockSizeBytes();\n    for (int i = 0; i < blockInfoList.size(); i++) {\n      BlockInfo blockInfo = blockInfoList.get(i);\n      inMemoryLength += blockInfo.getLength();\n      if (i < blockInfoList.size() - 1 && blockInfo.getLength() != fileBlockSize) {\n        throw new BlockInfoException(\n            \"Block index \" + i + \" has a block size smaller than the file block size (\"\n                + fileInode.getBlockSizeBytes() + \")\");\n      }\n    }\n\n    // If the file is persisted, its length is determined by UFS. Otherwise, its length is\n    // determined by its memory footprint.\n    long length = fileInode.isPersisted() ? options.getUfsLength() : inMemoryLength;\n\n    completeFileInternal(fileInode.getBlockIds(), inodePath, length, opTimeMs);\n    CompleteFileEntry completeFileEntry = CompleteFileEntry.newBuilder()\n        .addAllBlockIds(fileInode.getBlockIds())\n        .setId(inode.getId())\n        .setLength(length)\n        .setOpTimeMs(opTimeMs)\n        .build();\n    writeJournalEntry(JournalEntry.newBuilder().setCompleteFile(completeFileEntry).build());\n    flushJournal();\n  }","id":42885,"modified_method":"/**\n   * Completes a file. After a file is completed, it cannot be written to.\n   * <p>\n   * Writes to the journal.\n   *\n   * @param inodePath the {@link InodePath} to complete\n   * @param options the method options\n   * @return the flush counter for journaling\n   * @throws InvalidPathException if an invalid path is encountered\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws BlockInfoException if a block information exception is encountered\n   * @throws FileAlreadyCompletedException if the file is already completed\n   * @throws InvalidFileSizeException if an invalid file size is encountered\n   */\n  long completeFileAndJournal(InodePath inodePath, CompleteFileOptions options)\n      throws InvalidPathException, FileDoesNotExistException, BlockInfoException,\n      FileAlreadyCompletedException, InvalidFileSizeException {\n    long opTimeMs = System.currentTimeMillis();\n    Inode<?> inode = inodePath.getInode();\n    if (!inode.isFile()) {\n      throw new FileDoesNotExistException(\n          ExceptionMessage.PATH_MUST_BE_FILE.getMessage(inodePath.getUri()));\n    }\n\n    InodeFile fileInode = (InodeFile) inode;\n    List<Long> blockIdList = fileInode.getBlockIds();\n    List<BlockInfo> blockInfoList = mBlockMaster.getBlockInfoList(blockIdList);\n    if (!fileInode.isPersisted() && blockInfoList.size() != blockIdList.size()) {\n      throw new BlockInfoException(\"Cannot complete a file without all the blocks committed\");\n    }\n\n    // Iterate over all file blocks committed to Alluxio, computing the length and verify that all\n    // the blocks (except the last one) is the same size as the file block size.\n    long inMemoryLength = 0;\n    long fileBlockSize = fileInode.getBlockSizeBytes();\n    for (int i = 0; i < blockInfoList.size(); i++) {\n      BlockInfo blockInfo = blockInfoList.get(i);\n      inMemoryLength += blockInfo.getLength();\n      if (i < blockInfoList.size() - 1 && blockInfo.getLength() != fileBlockSize) {\n        throw new BlockInfoException(\n            \"Block index \" + i + \" has a block size smaller than the file block size (\"\n                + fileInode.getBlockSizeBytes() + \")\");\n      }\n    }\n\n    // If the file is persisted, its length is determined by UFS. Otherwise, its length is\n    // determined by its memory footprint.\n    long length = fileInode.isPersisted() ? options.getUfsLength() : inMemoryLength;\n\n    completeFileInternal(fileInode.getBlockIds(), inodePath, length, opTimeMs);\n    CompleteFileEntry completeFileEntry = CompleteFileEntry.newBuilder()\n        .addAllBlockIds(fileInode.getBlockIds())\n        .setId(inode.getId())\n        .setLength(length)\n        .setOpTimeMs(opTimeMs)\n        .build();\n    return appendJournalEntry(JournalEntry.newBuilder().setCompleteFile(completeFileEntry).build());\n  }","commit_id":"f4da6a7e8460260db026c663cfacee35cd620ddd","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void create(String indexName, OIndexDefinition indexDefinition, String clusterIndexName,\n      OStreamSerializer valueSerializer, boolean isAutomatic) {\n    OBinarySerializer keySerializer;\n\n    if (indexDefinition != null) {\n      if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {\n        keySerializer = ((ORuntimeKeyIndexDefinition) indexDefinition).getSerializer();\n      } else {\n        if (indexDefinition.getTypes().length > 1) {\n          keySerializer = OCompositeKeySerializer.INSTANCE;\n        } else {\n          keySerializer = OBinarySerializerFactory.getInstance().getObjectSerializer(indexDefinition.getTypes()[0]);\n        }\n      }\n    } else\n      keySerializer = new OSimpleKeySerializer();\n\n    final ODatabaseRecord database = getDatabase();\n    final ORecordBytes identityRecord = new ORecordBytes();\n    final OStorageLocalAbstract storageLocalAbstract = (OStorageLocalAbstract) database.getStorage();\n\n    database.save(identityRecord, clusterIndexName);\n    identity = identityRecord.getIdentity();\n\n    hashFunction.setValueSerializer(keySerializer);\n    hashTable.create(indexName, keySerializer, (OBinarySerializer<V>) valueSerializer,\n        indexDefinition != null ? indexDefinition.getTypes() : null, storageLocalAbstract, indexDefinition != null\n            && !indexDefinition.isNullValuesIgnored());\n  }","id":42886,"modified_method":"@Override\n  public void create(String indexName, OIndexDefinition indexDefinition, String clusterIndexName,\n      OStreamSerializer valueSerializer, boolean isAutomatic) {\n    OBinarySerializer keySerializer;\n\n    if (indexDefinition != null) {\n      if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {\n        keySerializer = ((ORuntimeKeyIndexDefinition) indexDefinition).getSerializer();\n      } else {\n        if (indexDefinition.getTypes().length > 1) {\n          keySerializer = OCompositeKeySerializer.INSTANCE;\n        } else {\n          keySerializer = OBinarySerializerFactory.getInstance().getObjectSerializer(indexDefinition.getTypes()[0]);\n        }\n      }\n    } else\n      keySerializer = new OSimpleKeySerializer();\n\n    final ODatabaseRecord database = getDatabase();\n    final ORecordBytes identityRecord = new ORecordBytes();\n    final OStorageLocalAbstract storageLocalAbstract = (OStorageLocalAbstract) database.getStorage().getUnderlying();\n\n    database.save(identityRecord, clusterIndexName);\n    identity = identityRecord.getIdentity();\n\n    hashFunction.setValueSerializer(keySerializer);\n    hashTable.create(indexName, keySerializer, (OBinarySerializer<V>) valueSerializer,\n        indexDefinition != null ? indexDefinition.getTypes() : null, storageLocalAbstract, indexDefinition != null\n            && !indexDefinition.isNullValuesIgnored());\n  }","commit_id":"1b3ff1a3580f79bb51850b5afc71ac3d85afd4b0","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Only idempotent query can go at storage level to avoid deadlocks\r\n   */\r\n  private boolean serialScan(final int[] clusterIds) {\r\n\r\n    final ODatabaseDocumentInternal localDatabase = getDatabase();\r\n\r\n    for (final int clusterId : clusterIds) {\r\n      final String clusteName = localDatabase.getClusterNameById(clusterId);\r\n      if (clusteName != null) {\r\n        final ORID[] range = getRange();\r\n        final long from = range[0] != null && range[0].getClusterId() == clusterId ? range[0].getClusterPosition() : -1;\r\n        final long to = range[1] != null && range[1].getClusterId() == clusterId ? range[1].getClusterPosition() : -1;\r\n\r\n        try {\r\n          ((OAbstractPaginatedStorage) localDatabase.getStorage()).scanCluster(clusteName, isBrowsingAscendingOrder(), from, to,\r\n              new OCallable<Boolean, ORecord>() {\r\n                @Override\r\n                public Boolean call(final ORecord iRecord) {\r\n                  if (!executeSearchRecord(iRecord, context)) {\r\n                    return Boolean.FALSE;\r\n                  }\r\n\r\n                  return Boolean.TRUE;\r\n                }\r\n              });\r\n        } catch (IOException e) {\r\n          throw OException.wrapException(new OCommandExecutionException(\"I/O Error on executing query\"), e);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }","id":42887,"modified_method":"/**\r\n   * Only idempotent query can go at storage level to avoid deadlocks\r\n   */\r\n  private boolean serialScan(final int[] clusterIds) {\r\n\r\n    final ODatabaseDocumentInternal localDatabase = getDatabase();\r\n\r\n    for (final int clusterId : clusterIds) {\r\n      final String clusteName = localDatabase.getClusterNameById(clusterId);\r\n      if (clusteName != null) {\r\n        final ORID[] range = getRange();\r\n        final long from = range[0] != null && range[0].getClusterId() == clusterId ? range[0].getClusterPosition() : -1;\r\n        final long to = range[1] != null && range[1].getClusterId() == clusterId ? range[1].getClusterPosition() : -1;\r\n\r\n        try {\r\n          ((OAbstractPaginatedStorage) localDatabase.getStorage().getUnderlying()).scanCluster(clusteName, isBrowsingAscendingOrder(), from, to,\r\n              new OCallable<Boolean, ORecord>() {\r\n                @Override\r\n                public Boolean call(final ORecord iRecord) {\r\n                  if (!executeSearchRecord(iRecord, context)) {\r\n                    return Boolean.FALSE;\r\n                  }\r\n\r\n                  return Boolean.TRUE;\r\n                }\r\n              });\r\n        } catch (IOException e) {\r\n          throw OException.wrapException(new OCommandExecutionException(\"I/O Error on executing query\"), e);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }","commit_id":"f58f2a0d278bbdc47286de3f482a5c9c52f5c9fc","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public void recreateIndexes() {\r\n    acquireExclusiveLock();\r\n    try {\r\n      if (recreateIndexesThread != null && recreateIndexesThread.isAlive())\r\n        // BUILDING ALREADY IN PROGRESS\r\n        return;\r\n\r\n      final ODatabaseRecord db = getDatabase();\r\n      document = db.load(new ORecordId(getDatabase().getStorage().getConfiguration().indexMgrRecordId));\r\n      final ODocument doc = new ODocument();\r\n      document.copyTo(doc);\r\n\r\n      // USE A NEW DB INSTANCE\r\n      final ODatabaseDocumentTx newDb = new ODatabaseDocumentTx(db.getURL());\r\n\r\n      Runnable recreateIndexesTask = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n          try {\r\n            // START IT IN BACKGROUND\r\n            newDb.setProperty(ODatabase.OPTIONS.SECURITY.toString(), Boolean.FALSE);\r\n            newDb.open(\"admin\", \"nopass\");\r\n\r\n            ODatabaseRecordThreadLocal.INSTANCE.set(newDb);\r\n            try {\r\n              // DROP AND RE-CREATE 'INDEX' DATA-SEGMENT AND CLUSTER IF ANY\r\n              final int dataId = newDb.getStorage().getDataSegmentIdByName(OMetadataDefault.DATASEGMENT_INDEX_NAME);\r\n              if (dataId > -1)\r\n                newDb.getStorage().dropDataSegment(OMetadataDefault.DATASEGMENT_INDEX_NAME);\r\n\r\n              final int clusterId = newDb.getStorage().getClusterIdByName(OMetadataDefault.CLUSTER_INDEX_NAME);\r\n              if (clusterId > -1)\r\n                newDb.dropCluster(clusterId, false);\r\n\r\n              newDb.addDataSegment(OMetadataDefault.DATASEGMENT_INDEX_NAME, null);\r\n              newDb.getStorage().addCluster(OClusterLocal.TYPE, OMetadataDefault.CLUSTER_INDEX_NAME, null,\r\n                  OMetadataDefault.DATASEGMENT_INDEX_NAME, true);\r\n\r\n            } catch (IllegalArgumentException ex) {\r\n              // OLD DATABASE: CREATE SEPARATE DATASEGMENT AND LET THE INDEX CLUSTER TO POINT TO IT\r\n              OLogManager.instance().info(this, \"Creating 'index' data-segment to store all the index content...\");\r\n\r\n              newDb.addDataSegment(OMetadataDefault.DATASEGMENT_INDEX_NAME, null);\r\n              final OCluster indexCluster = newDb.getStorage().getClusterById(\r\n                  newDb.getStorage().getClusterIdByName(OMetadataDefault.CLUSTER_INDEX_NAME));\r\n              try {\r\n                indexCluster.set(ATTRIBUTES.DATASEGMENT, OMetadataDefault.DATASEGMENT_INDEX_NAME);\r\n                OLogManager.instance().info(this,\r\n                    \"Data-segment 'index' create correctly. Indexes will store content into this data-segment\");\r\n              } catch (IOException e) {\r\n                OLogManager.instance().error(this, \"Error changing data segment for cluster 'index'\", e);\r\n              }\r\n            }\r\n\r\n            final Collection<ODocument> idxs = doc.field(CONFIG_INDEXES);\r\n            if (idxs == null) {\r\n              OLogManager.instance().warn(this, \"List of indexes is empty.\");\r\n              return;\r\n            }\r\n\r\n            int ok = 0;\r\n            int errors = 0;\r\n            for (ODocument idx : idxs) {\r\n              try {\r\n                String indexType = idx.field(OIndexInternal.CONFIG_TYPE);\r\n                String algorithm = idx.field(OIndexInternal.ALGORITHM);\r\n                String valueContainerAlgorithm = idx.field(OIndexInternal.VALUE_CONTAINER_ALGORITHM);\r\n\r\n                if (indexType == null) {\r\n                  OLogManager.instance().error(this, \"Index type is null, will process other record.\");\r\n                  errors++;\r\n                  continue;\r\n                }\r\n\r\n                final OIndexInternal<?> index = OIndexes.createIndex(newDb, indexType, algorithm, valueContainerAlgorithm);\r\n                OIndexInternal.IndexMetadata indexMetadata = index.loadMetadata(idx);\r\n                OIndexDefinition indexDefinition = indexMetadata.getIndexDefinition();\r\n\r\n                if (indexDefinition == null || !indexDefinition.isAutomatic()) {\r\n                  OLogManager.instance().info(this, \"Index %s is not automatic index and will be added as is.\",\r\n                      indexMetadata.getName());\r\n\r\n                  if (index.loadFromConfiguration(idx)) {\r\n                    addIndexInternal(index);\r\n                    setDirty();\r\n                    save();\r\n\r\n                    ok++;\r\n                  } else {\r\n                    getDatabase().unregisterListener(index.getInternal());\r\n                    index.delete();\r\n                    errors++;\r\n                  }\r\n\r\n                  OLogManager.instance().info(this, \"Index %s was added in DB index list.\", index.getName());\r\n                } else {\r\n                  String indexName = indexMetadata.getName();\r\n                  Set<String> clusters = indexMetadata.getClustersToIndex();\r\n                  String type = indexMetadata.getType();\r\n\r\n                  if (indexName != null && indexDefinition != null && clusters != null && !clusters.isEmpty() && type != null) {\r\n                    OLogManager.instance().info(this, \"Start creation of index %s\", indexName);\r\n\r\n                    index.create(indexName, indexDefinition, defaultClusterName, clusters, false, new OIndexRebuildOutputListener(\r\n                        index));\r\n\r\n                    index.setRebuildingFlag();\r\n                    addIndexInternal(index);\r\n\r\n                    OLogManager.instance().info(this, \"Index %s was successfully created and rebuild is going to be started.\",\r\n                        indexName);\r\n\r\n                    index.rebuild(new OIndexRebuildOutputListener(index));\r\n                    index.flush();\r\n\r\n                    setDirty();\r\n                    save();\r\n\r\n                    ok++;\r\n\r\n                    OLogManager.instance().info(this, \"Rebuild of %s index was successfully finished.\", indexName);\r\n                  } else {\r\n                    errors++;\r\n                    OLogManager.instance().error(\r\n                        this,\r\n                        \"Information about index was restored incorrectly, following data were loaded : \"\r\n                            + \"index name - %s, index definition %s, clusters %s, type %s.\", indexName, indexDefinition, clusters,\r\n                        type);\r\n                  }\r\n                }\r\n\r\n              } catch (Exception e) {\r\n                OLogManager.instance().error(this, \"Error during addition of index %s\", idx);\r\n                errors++;\r\n              }\r\n            }\r\n\r\n            rebuildCompleted = true;\r\n\r\n            newDb.close();\r\n\r\n            OLogManager.instance().info(this, \"%d indexes were restored successfully, %d errors\", ok, errors);\r\n          } catch (Exception e) {\r\n            OLogManager.instance().error(this, \"Error when attempt to restore indexes after crash was performed.\", e);\r\n          }\r\n        }\r\n      };\r\n\r\n      recreateIndexesThread = new Thread(recreateIndexesTask);\r\n      recreateIndexesThread.start();\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":42888,"modified_method":"@Override\r\n  public void recreateIndexes() {\r\n    acquireExclusiveLock();\r\n    try {\r\n      if (recreateIndexesThread != null && recreateIndexesThread.isAlive())\r\n        // BUILDING ALREADY IN PROGRESS\r\n        return;\r\n\r\n      final ODatabaseRecord db = getDatabase();\r\n      document = db.load(new ORecordId(getDatabase().getStorage().getConfiguration().indexMgrRecordId));\r\n      final ODocument doc = new ODocument();\r\n      document.copyTo(doc);\r\n\r\n      // USE A NEW DB INSTANCE\r\n      final ODatabaseDocumentTx newDb = new ODatabaseDocumentTx(db.getURL());\r\n\r\n      Runnable recreateIndexesTask = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n          try {\r\n            // START IT IN BACKGROUND\r\n            newDb.setProperty(ODatabase.OPTIONS.SECURITY.toString(), Boolean.FALSE);\r\n            newDb.open(\"admin\", \"nopass\");\r\n\r\n            ODatabaseRecordThreadLocal.INSTANCE.set(newDb);\r\n            try {\r\n              // DROP AND RE-CREATE 'INDEX' DATA-SEGMENT AND CLUSTER IF ANY\r\n              final int dataId = newDb.getStorage().getDataSegmentIdByName(OMetadataDefault.DATASEGMENT_INDEX_NAME);\r\n              if (dataId > -1)\r\n                newDb.getStorage().dropDataSegment(OMetadataDefault.DATASEGMENT_INDEX_NAME);\r\n\r\n              final int clusterId = newDb.getStorage().getClusterIdByName(OMetadataDefault.CLUSTER_INDEX_NAME);\r\n              if (clusterId > -1)\r\n                newDb.dropCluster(clusterId, false);\r\n\r\n              newDb.addDataSegment(OMetadataDefault.DATASEGMENT_INDEX_NAME, null);\r\n              newDb.getStorage().addCluster(OClusterLocal.TYPE, OMetadataDefault.CLUSTER_INDEX_NAME, null,\r\n                  OMetadataDefault.DATASEGMENT_INDEX_NAME, true);\r\n\r\n            } catch (IllegalArgumentException ex) {\r\n              // OLD DATABASE: CREATE SEPARATE DATASEGMENT AND LET THE INDEX CLUSTER TO POINT TO IT\r\n              OLogManager.instance().info(this, \"Creating 'index' data-segment to store all the index content...\");\r\n\r\n              newDb.addDataSegment(OMetadataDefault.DATASEGMENT_INDEX_NAME, null);\r\n              final OCluster indexCluster = newDb.getStorage().getClusterById(\r\n                  newDb.getStorage().getClusterIdByName(OMetadataDefault.CLUSTER_INDEX_NAME));\r\n              try {\r\n                indexCluster.set(ATTRIBUTES.DATASEGMENT, OMetadataDefault.DATASEGMENT_INDEX_NAME);\r\n                OLogManager.instance().info(this,\r\n                    \"Data-segment 'index' create correctly. Indexes will store content into this data-segment\");\r\n              } catch (IOException e) {\r\n                OLogManager.instance().error(this, \"Error changing data segment for cluster 'index'\", e);\r\n              }\r\n            }\r\n\r\n            final Collection<ODocument> idxs = doc.field(CONFIG_INDEXES);\r\n            if (idxs == null) {\r\n              OLogManager.instance().warn(this, \"List of indexes is empty.\");\r\n              return;\r\n            }\r\n\r\n            int ok = 0;\r\n            int errors = 0;\r\n            for (ODocument idx : idxs) {\r\n              try {\r\n                String indexType = idx.field(OIndexInternal.CONFIG_TYPE);\r\n                String algorithm = idx.field(OIndexInternal.ALGORITHM);\r\n                String valueContainerAlgorithm = idx.field(OIndexInternal.VALUE_CONTAINER_ALGORITHM);\r\n\r\n                if (indexType == null) {\r\n                  OLogManager.instance().error(this, \"Index type is null, will process other record.\");\r\n                  errors++;\r\n                  continue;\r\n                }\r\n\r\n                final OIndexInternal<?> index = OIndexes.createIndex(newDb, indexType, algorithm, valueContainerAlgorithm);\r\n                OIndexInternal.IndexMetadata indexMetadata = index.loadMetadata(idx);\r\n                OIndexDefinition indexDefinition = indexMetadata.getIndexDefinition();\r\n\r\n                if (indexDefinition == null || !indexDefinition.isAutomatic()) {\r\n                  OLogManager.instance().info(this, \"Index %s is not automatic index and will be added as is.\",\r\n                      indexMetadata.getName());\r\n\r\n                  if (index.loadFromConfiguration(idx)) {\r\n                    addIndexInternal(index);\r\n                    setDirty();\r\n                    save();\r\n\r\n                    ok++;\r\n                  } else {\r\n                    getDatabase().unregisterListener(index.getInternal());\r\n                    index.delete();\r\n                    errors++;\r\n                  }\r\n\r\n                  OLogManager.instance().info(this, \"Index %s was added in DB index list.\", index.getName());\r\n                } else {\r\n                  String indexName = indexMetadata.getName();\r\n                  Set<String> clusters = indexMetadata.getClustersToIndex();\r\n                  String type = indexMetadata.getType();\r\n\r\n                  if (indexName != null && indexDefinition != null && clusters != null && !clusters.isEmpty() && type != null) {\r\n                    OLogManager.instance().info(this, \"Start creation of index %s\", indexName);\r\n\r\n                    index.create(indexName, indexDefinition, defaultClusterName, clusters, false, new OIndexRebuildOutputListener(\r\n                        index));\r\n\r\n                    index.setRebuildingFlag();\r\n                    addIndexInternal(index);\r\n\r\n                    OLogManager.instance().info(this, \"Index %s was successfully created and rebuild is going to be started.\",\r\n                        indexName);\r\n\r\n                    index.rebuild(new OIndexRebuildOutputListener(index));\r\n                    index.flush();\r\n\r\n                    setDirty();\r\n                    save();\r\n\r\n                    ok++;\r\n\r\n                    OLogManager.instance().info(this, \"Rebuild of %s index was successfully finished.\", indexName);\r\n                  } else {\r\n                    errors++;\r\n                    OLogManager.instance().error(\r\n                        this,\r\n                        \"Information about index was restored incorrectly, following data were loaded : \"\r\n                            + \"index name - %s, index definition %s, clusters %s, type %s.\", indexName, indexDefinition, clusters,\r\n                        type);\r\n                  }\r\n                }\r\n\r\n              } catch (Exception e) {\r\n                OLogManager.instance().error(this, \"Error during addition of index %s\", idx);\r\n                errors++;\r\n              }\r\n            }\r\n\r\n            rebuildCompleted = true;\r\n\r\n            newDb.close();\r\n\r\n            OLogManager.instance().info(this, \"%d indexes were restored successfully, %d errors\", ok, errors);\r\n          } catch (Exception e) {\r\n            OLogManager.instance().error(this, \"Error when attempt to restore indexes after crash was performed.\", e);\r\n          }\r\n        }\r\n      };\r\n\r\n      recreateIndexesThread = new Thread(recreateIndexesTask);\r\n      recreateIndexesThread.start();\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n\r\n    if (OGlobalConfiguration.INDEX_SYNCHRONOUS_AUTO_REBUILD.getValueAsBoolean())\r\n      waitTillIndexRestore();\r\n  }","commit_id":"7a05708dfc48283174704d67d1c3d78a726d52f2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean autoRecreateIndexesAfterCrash() {\r\n    if (rebuildCompleted)\r\n      return false;\r\n\r\n    final ODatabaseRecord database = ODatabaseRecordThreadLocal.INSTANCE.get();\r\n    if (!OGlobalConfiguration.INDEX_AUTO_REBUILD_AFTER_NOTSOFTCLOSE.getValueAsBoolean())\r\n      return false;\r\n\r\n    OStorage storage = database.getStorage();\r\n\r\n    if (storage instanceof OStorageLocal)\r\n      return !((OStorageLocal) storage).wasClusterSoftlyClosed(OMetadataDefault.CLUSTER_INDEX_NAME);\r\n    else if (storage instanceof OLocalPaginatedStorage) {\r\n      return ((OLocalPaginatedStorage) storage).wereDataRestoredAfterOpen();\r\n    }\r\n\r\n    return false;\r\n  }","id":42889,"modified_method":"public boolean autoRecreateIndexesAfterCrash() {\r\n    if (rebuildCompleted)\r\n      return false;\r\n\r\n    final ODatabaseRecord database = ODatabaseRecordThreadLocal.INSTANCE.get();\r\n    if (!OGlobalConfiguration.INDEX_AUTO_REBUILD_AFTER_NOTSOFTCLOSE.getValueAsBoolean())\r\n      return false;\r\n\r\n    OStorage storage = database.getStorage().getUnderlying();\r\n\r\n    if (storage instanceof OStorageLocal)\r\n      return !((OStorageLocal) storage).wasClusterSoftlyClosed(OMetadataDefault.CLUSTER_INDEX_NAME);\r\n    else if (storage instanceof OLocalPaginatedStorage) {\r\n      return ((OLocalPaginatedStorage) storage).wereDataRestoredAfterOpen();\r\n    }\r\n\r\n    return false;\r\n  }","commit_id":"7a05708dfc48283174704d67d1c3d78a726d52f2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void storageScan(final ODatabaseDocumentTx localDatabase, final OCommandContext iContext, final String iClusterName,\r\n      final int current, final boolean[] results) {\r\n\r\n    final int clusterId = localDatabase.getClusterIdByName(iClusterName);\r\n\r\n    final ORID[] range = getRange();\r\n    final long from = range[0] != null && range[0].getClusterId() == clusterId ? range[0].getClusterPosition() : -1;\r\n    final long to = range[1] != null && range[1].getClusterId() == clusterId ? range[1].getClusterPosition() : -1;\r\n\r\n    try {\r\n      ((OLocalPaginatedStorage) localDatabase.getStorage()).scanCluster(iClusterName, isBrowsingAscendingOrder(), from, to,\r\n          new OCallable<Boolean, ORecord>() {\r\n            @Override\r\n            public Boolean call(final ORecord iRecord) {\r\n              if (!executeSearchRecord(iRecord, iContext)) {\r\n                results[current] = false;\r\n                return Boolean.FALSE;\r\n              }\r\n\r\n              if (parallel && !parallelRunning)\r\n                // EXECUTION ENDED\r\n                return Boolean.FALSE;\r\n\r\n              return Boolean.TRUE;\r\n            }\r\n          });\r\n    } catch (IOException e) {\r\n      throw OException.wrapException(new OCommandExecutionException(\"I/O Error on executing cluster query\"), e);\r\n    }\r\n  }","id":42890,"modified_method":"protected void storageScan(final ODatabaseDocumentTx localDatabase, final OCommandContext iContext, final String iClusterName,\r\n      final int current, final boolean[] results) {\r\n\r\n    final int clusterId = localDatabase.getClusterIdByName(iClusterName);\r\n\r\n    final ORID[] range = getRange();\r\n    final long from = range[0] != null && range[0].getClusterId() == clusterId ? range[0].getClusterPosition() : -1;\r\n    final long to = range[1] != null && range[1].getClusterId() == clusterId ? range[1].getClusterPosition() : -1;\r\n\r\n    try {\r\n      ((OLocalPaginatedStorage) localDatabase.getStorage().getUnderlying()).scanCluster(iClusterName, isBrowsingAscendingOrder(), from, to,\r\n          new OCallable<Boolean, ORecord>() {\r\n            @Override\r\n            public Boolean call(final ORecord iRecord) {\r\n              if (!executeSearchRecord(iRecord, iContext)) {\r\n                results[current] = false;\r\n                return Boolean.FALSE;\r\n              }\r\n\r\n              if (parallel && !parallelRunning)\r\n                // EXECUTION ENDED\r\n                return Boolean.FALSE;\r\n\r\n              return Boolean.TRUE;\r\n            }\r\n          });\r\n    } catch (IOException e) {\r\n      throw OException.wrapException(new OCommandExecutionException(\"I/O Error on executing cluster query\"), e);\r\n    }\r\n  }","commit_id":"ee722c8320f45f334b4a42c0fec64af772fff015","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OIndexInternal<?> createIndex(ODatabaseDocumentInternal database, String indexType, String algorithm,\n      String valueContainerAlgorithm, ODocument metadata) throws OConfigurationException {\n    if (valueContainerAlgorithm == null)\n      valueContainerAlgorithm = ODefaultIndexFactory.NONE_VALUE_CONTAINER;\n\n    OStorage storage = database.getStorage();\n    OIndexEngine indexEngine;\n\n    Boolean durableInNonTxMode;\n    Object durable = null;\n\n    if (metadata != null) {\n      durable = metadata.field(\"durableInNonTxMode\");\n    }\n\n    if (durable instanceof Boolean)\n      durableInNonTxMode = (Boolean) durable;\n    else\n      durableInNonTxMode = null;\n\n    final String storageType = storage.getType();\n    if (storageType.equals(\"memory\") || storageType.equals(\"plocal\"))\n      indexEngine = new OHashTableIndexEngine(durableInNonTxMode, (OAbstractPaginatedStorage) database.getStorage(),\n          getLastVersion());\n    else if (storageType.equals(\"distributed\"))\n      // DISTRIBUTED CASE: HANDLE IT AS FOR LOCAL\n      indexEngine = new OHashTableIndexEngine(durableInNonTxMode, (OAbstractPaginatedStorage) database.getStorage(),\n          getLastVersion());\n    else if (storageType.equals(\"remote\"))\n      indexEngine = new ORemoteIndexEngine();\n    else\n      throw new OIndexException(\"Unsupported storage type : \" + storageType);\n\n    if (OClass.INDEX_TYPE.UNIQUE_HASH_INDEX.toString().equals(indexType))\n      return new OIndexUnique(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n    else if (OClass.INDEX_TYPE.NOTUNIQUE_HASH_INDEX.toString().equals(indexType))\n      return new OIndexNotUnique(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n    else if (OClass.INDEX_TYPE.FULLTEXT_HASH_INDEX.toString().equals(indexType))\n      return new OIndexFullText(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n    else if (OClass.INDEX_TYPE.DICTIONARY_HASH_INDEX.toString().equals(indexType))\n      return new OIndexDictionary(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n\n    throw new OConfigurationException(\"Unsupported type : \" + indexType);\n  }","id":42891,"modified_method":"public OIndexInternal<?> createIndex(ODatabaseDocumentInternal database, String indexType, String algorithm,\n      String valueContainerAlgorithm, ODocument metadata) throws OConfigurationException {\n    if (valueContainerAlgorithm == null)\n      valueContainerAlgorithm = ODefaultIndexFactory.NONE_VALUE_CONTAINER;\n\n    OStorage storage = database.getStorage();\n    OIndexEngine indexEngine;\n\n    Boolean durableInNonTxMode;\n    Object durable = null;\n\n    if (metadata != null) {\n      durable = metadata.field(\"durableInNonTxMode\");\n    }\n\n    if (durable instanceof Boolean)\n      durableInNonTxMode = (Boolean) durable;\n    else\n      durableInNonTxMode = null;\n\n    final String storageType = storage.getType();\n    if (storageType.equals(\"memory\") || storageType.equals(\"plocal\"))\n      indexEngine = new OHashTableIndexEngine(durableInNonTxMode, (OAbstractPaginatedStorage) database.getStorage(),\n          getLastVersion());\n    else if (storageType.equals(\"distributed\"))\n      // DISTRIBUTED CASE: HANDLE IT AS FOR LOCAL\n      indexEngine = new OHashTableIndexEngine(durableInNonTxMode, (OAbstractPaginatedStorage) database.getStorage().getUnderlying(),\n          getLastVersion());\n    else if (storageType.equals(\"remote\"))\n      indexEngine = new ORemoteIndexEngine();\n    else\n      throw new OIndexException(\"Unsupported storage type : \" + storageType);\n\n    if (OClass.INDEX_TYPE.UNIQUE_HASH_INDEX.toString().equals(indexType))\n      return new OIndexUnique(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n    else if (OClass.INDEX_TYPE.NOTUNIQUE_HASH_INDEX.toString().equals(indexType))\n      return new OIndexNotUnique(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n    else if (OClass.INDEX_TYPE.FULLTEXT_HASH_INDEX.toString().equals(indexType))\n      return new OIndexFullText(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n    else if (OClass.INDEX_TYPE.DICTIONARY_HASH_INDEX.toString().equals(indexType))\n      return new OIndexDictionary(indexType, algorithm, indexEngine, valueContainerAlgorithm, metadata);\n\n    throw new OConfigurationException(\"Unsupported type : \" + indexType);\n  }","commit_id":"39e8da7e0b94b5ff1c0e74cdb087f75dfa070ea7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void convertToSbTree() {\n    final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n    final OIndexRIDContainerSBTree tree = new OIndexRIDContainerSBTree(fileId, durableNonTxMode,\n        (OAbstractPaginatedStorage) db.getStorage());\n\n    tree.addAll(underlying);\n\n    underlying = tree;\n    isEmbedded = false;\n  }","id":42892,"modified_method":"private void convertToSbTree() {\n    final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n    final OIndexRIDContainerSBTree tree = new OIndexRIDContainerSBTree(fileId, durableNonTxMode,\n        (OAbstractPaginatedStorage) db.getStorage().getUnderlying());\n\n    tree.addAll(underlying);\n\n    underlying = tree;\n    isEmbedded = false;\n  }","commit_id":"5637137d4e3704a0d1d7d00ed63b831974e7a9c1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n  public ODocument checkEntry(final OIdentifiable iRecord, final Object iKey) {\r\n    // CHECK IF ALREADY EXISTS IN TX\r\n    String storageType = database.getStorage().getType();\r\n    if (!database.getTransaction().isActive()) {\r\n      final OIdentifiable previousRecord = get(iKey);\r\n      if (previousRecord != null && !previousRecord.equals(iRecord)) {\r\n        final ODocument metadata = getMetadata();\r\n        final boolean mergeSameKey = metadata != null && (Boolean) metadata.field(OIndex.MERGE_KEYS);\r\n        if (mergeSameKey) {\r\n          return (ODocument) previousRecord.getRecord();\r\n        } else\r\n          throw new ORecordDuplicatedException(String.format(\r\n              \"Cannot index record %s: found duplicated key '%s' in index '%s' previously assigned to the record %s\", iRecord,\r\n              iKey, getName(), previousRecord), previousRecord.getIdentity());\r\n      }\r\n      return super.checkEntry(iRecord, iKey);\r\n    }\r\n    return null;\r\n  }","id":42893,"modified_method":"@Override\r\n  public ODocument checkEntry(final OIdentifiable iRecord, final Object iKey) {\r\n    // CHECK IF ALREADY EXISTS IN TX\r\n    if (!database.getTransaction().isActive()) {\r\n      final OIdentifiable previousRecord = get(iKey);\r\n      if (previousRecord != null && !previousRecord.equals(iRecord)) {\r\n        final ODocument metadata = getMetadata();\r\n        final boolean mergeSameKey = metadata != null && (Boolean) metadata.field(OIndex.MERGE_KEYS);\r\n        if (mergeSameKey) {\r\n          return (ODocument) previousRecord.getRecord();\r\n        } else\r\n          throw new ORecordDuplicatedException(String.format(\r\n              \"Cannot index record %s: found duplicated key '%s' in index '%s' previously assigned to the record %s\", iRecord,\r\n              iKey, getName(), previousRecord), previousRecord.getIdentity());\r\n      }\r\n      return super.checkEntry(iRecord, iKey);\r\n    }\r\n    return null;\r\n  }","commit_id":"5637137d4e3704a0d1d7d00ed63b831974e7a9c1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSBTreeBonsai<OIdentifiable, Boolean> loadSBTree(String fileName, OBonsaiBucketPointer rootIndex) {\n    OSBTreeBonsai<OIdentifiable, Boolean> tree = treeCache.get(rootIndex);\n    if (tree != null)\n      return tree;\n\n    tree = new OSBTreeBonsai<OIdentifiable, Boolean>(\".sbt\", 1, true);\n    tree.load(fileName, rootIndex, (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage());\n\n    treeCache.put(tree.getRootBucketPointer(), tree);\n\n    return tree;\n  }","id":42894,"modified_method":"public OSBTreeBonsai<OIdentifiable, Boolean> loadSBTree(String fileName, OBonsaiBucketPointer rootIndex) {\n    OSBTreeBonsai<OIdentifiable, Boolean> tree = treeCache.get(rootIndex);\n    if (tree != null)\n      return tree;\n\n    tree = new OSBTreeBonsai<OIdentifiable, Boolean>(\".sbt\", 1, true);\n    tree.load(fileName, rootIndex, (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getUnderlying());\n\n    treeCache.put(tree.getRootBucketPointer(), tree);\n\n    return tree;\n  }","commit_id":"718f5484e0dd1e0b0957944aa027846a1525d48f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSBTreeBonsai<OIdentifiable, Boolean> createSBTree() {\n    OSBTreeBonsai<OIdentifiable, Boolean> tree = new OSBTreeBonsai<OIdentifiable, Boolean>(\".sbt\", 1, true);\n\n    tree.create(FILE_ID, OLinkSerializer.INSTANCE, OBooleanSerializer.INSTANCE,\n        (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage());\n\n    treeCache.put(tree.getRootBucketPointer(), tree);\n\n    return tree;\n  }","id":42895,"modified_method":"public OSBTreeBonsai<OIdentifiable, Boolean> createSBTree() {\n    OSBTreeBonsai<OIdentifiable, Boolean> tree = new OSBTreeBonsai<OIdentifiable, Boolean>(\".sbt\", 1, true);\n\n    tree.create(FILE_ID, OLinkSerializer.INSTANCE, OBooleanSerializer.INSTANCE,\n        (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getUnderlying());\n\n    treeCache.put(tree.getRootBucketPointer(), tree);\n\n    return tree;\n  }","commit_id":"718f5484e0dd1e0b0957944aa027846a1525d48f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void create(String indexName, OIndexDefinition indexDefinition, String clusterIndexName,\n      OStreamSerializer valueSerializer, boolean isAutomatic) {\n    acquireExclusiveLock();\n    try {\n      final OBinarySerializer keySerializer;\n      if (indexDefinition != null) {\n        if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {\n          sbTree = new OSBTree<Object, V>(DATA_FILE_EXTENSION, 1,\n              OGlobalConfiguration.INDEX_DURABLE_IN_NON_TX_MODE.getValueAsBoolean());\n          keySerializer = ((ORuntimeKeyIndexDefinition) indexDefinition).getSerializer();\n        } else {\n          if (indexDefinition.getTypes().length > 1) {\n            keySerializer = OCompositeKeySerializer.INSTANCE;\n          } else {\n            keySerializer = OBinarySerializerFactory.INSTANCE.getObjectSerializer(indexDefinition.getTypes()[0]);\n          }\n          sbTree = new OSBTree<Object, V>(DATA_FILE_EXTENSION, indexDefinition.getTypes().length,\n              OGlobalConfiguration.INDEX_DURABLE_IN_NON_TX_MODE.getValueAsBoolean());\n        }\n      } else {\n        sbTree = new OSBTree<Object, V>(DATA_FILE_EXTENSION, 1,\n            OGlobalConfiguration.INDEX_DURABLE_IN_NON_TX_MODE.getValueAsBoolean());\n        keySerializer = new OSimpleKeySerializer();\n      }\n\n      final ORecordBytes identityRecord = new ORecordBytes();\n      ODatabaseRecord database = getDatabase();\n      final OStorageLocalAbstract storageLocalAbstract = (OStorageLocalAbstract) database.getStorage();\n\n      database.save(identityRecord, clusterIndexName);\n      identity = identityRecord.getIdentity();\n\n      sbTree.create(indexName, keySerializer, (OBinarySerializer<V>) valueSerializer, storageLocalAbstract);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","id":42896,"modified_method":"@Override\n  public void create(String indexName, OIndexDefinition indexDefinition, String clusterIndexName,\n      OStreamSerializer valueSerializer, boolean isAutomatic) {\n    acquireExclusiveLock();\n    try {\n      final OBinarySerializer keySerializer;\n      if (indexDefinition != null) {\n        if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {\n          sbTree = new OSBTree<Object, V>(DATA_FILE_EXTENSION, 1,\n              OGlobalConfiguration.INDEX_DURABLE_IN_NON_TX_MODE.getValueAsBoolean());\n          keySerializer = ((ORuntimeKeyIndexDefinition) indexDefinition).getSerializer();\n        } else {\n          if (indexDefinition.getTypes().length > 1) {\n            keySerializer = OCompositeKeySerializer.INSTANCE;\n          } else {\n            keySerializer = OBinarySerializerFactory.INSTANCE.getObjectSerializer(indexDefinition.getTypes()[0]);\n          }\n          sbTree = new OSBTree<Object, V>(DATA_FILE_EXTENSION, indexDefinition.getTypes().length,\n              OGlobalConfiguration.INDEX_DURABLE_IN_NON_TX_MODE.getValueAsBoolean());\n        }\n      } else {\n        sbTree = new OSBTree<Object, V>(DATA_FILE_EXTENSION, 1,\n            OGlobalConfiguration.INDEX_DURABLE_IN_NON_TX_MODE.getValueAsBoolean());\n        keySerializer = new OSimpleKeySerializer();\n      }\n\n      final ORecordBytes identityRecord = new ORecordBytes();\n      ODatabaseRecord database = getDatabase();\n      final OStorageLocalAbstract storageLocalAbstract = (OStorageLocalAbstract) database.getStorage().getUnderlying();\n\n      database.save(identityRecord, clusterIndexName);\n      identity = identityRecord.getIdentity();\n\n      sbTree.create(indexName, keySerializer, (OBinarySerializer<V>) valueSerializer, storageLocalAbstract);\n    } finally {\n      releaseExclusiveLock();\n    }\n  }","commit_id":"718f5484e0dd1e0b0957944aa027846a1525d48f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSBTreeIndexRIDContainer(String fileName) {\n    tree = new OSBTreeBonsai<OIdentifiable, Boolean>(INDEX_FILE_EXTENSION, 1, false);\n\n    tree.create(fileName, OLinkSerializer.INSTANCE, OBooleanSerializer.INSTANCE,\n        (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage());\n  }","id":42897,"modified_method":"public OSBTreeIndexRIDContainer(String fileName) {\n    tree = new OSBTreeBonsai<OIdentifiable, Boolean>(INDEX_FILE_EXTENSION, 1, false);\n\n    tree.create(fileName, OLinkSerializer.INSTANCE, OBooleanSerializer.INSTANCE,\n        (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getUnderlying());\n  }","commit_id":"718f5484e0dd1e0b0957944aa027846a1525d48f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSBTreeIndexRIDContainer(String fileName, OBonsaiBucketPointer rootPointer) {\n    tree = new OSBTreeBonsai<OIdentifiable, Boolean>(INDEX_FILE_EXTENSION, 1, false);\n    tree.load(fileName, rootPointer, (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage());\n  }","id":42898,"modified_method":"public OSBTreeIndexRIDContainer(String fileName, OBonsaiBucketPointer rootPointer) {\n    tree = new OSBTreeBonsai<OIdentifiable, Boolean>(INDEX_FILE_EXTENSION, 1, false);\n    tree.load(fileName, rootPointer, (OStorageLocalAbstract) ODatabaseRecordThreadLocal.INSTANCE.get().getStorage().getUnderlying());\n  }","commit_id":"718f5484e0dd1e0b0957944aa027846a1525d48f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void create(String indexName, OIndexDefinition indexDefinition, String clusterIndexName,\n      OStreamSerializer valueSerializer, boolean isAutomatic) {\n    OBinarySerializer keySerializer;\n\n    if (indexDefinition != null) {\n      if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {\n        keySerializer = ((ORuntimeKeyIndexDefinition) indexDefinition).getSerializer();\n      } else {\n        if (indexDefinition.getTypes().length > 1) {\n          keySerializer = OCompositeKeySerializer.INSTANCE;\n        } else {\n          keySerializer = OBinarySerializerFactory.getInstance().getObjectSerializer(indexDefinition.getTypes()[0]);\n        }\n      }\n    } else\n      keySerializer = new OSimpleKeySerializer();\n\n    final ODatabaseRecordInternal database = getDatabase();\n    final ORecordBytes identityRecord = new ORecordBytes();\n    final OAbstractPaginatedStorage storageLocalAbstract = (OAbstractPaginatedStorage) database.getStorage();\n\n    database.save(identityRecord, clusterIndexName);\n    identity = identityRecord.getIdentity();\n\n    hashFunction.setValueSerializer(keySerializer);\n    hashTable.create(indexName, keySerializer, (OBinarySerializer<V>) valueSerializer,\n        indexDefinition != null ? indexDefinition.getTypes() : null, storageLocalAbstract, indexDefinition != null\n            && !indexDefinition.isNullValuesIgnored());\n  }","id":42899,"modified_method":"@Override\n  public void create(String indexName, OIndexDefinition indexDefinition, String clusterIndexName,\n      OStreamSerializer valueSerializer, boolean isAutomatic) {\n    OBinarySerializer keySerializer;\n\n    if (indexDefinition != null) {\n      if (indexDefinition instanceof ORuntimeKeyIndexDefinition) {\n        keySerializer = ((ORuntimeKeyIndexDefinition) indexDefinition).getSerializer();\n      } else {\n        if (indexDefinition.getTypes().length > 1) {\n          keySerializer = OCompositeKeySerializer.INSTANCE;\n        } else {\n          keySerializer = OBinarySerializerFactory.getInstance().getObjectSerializer(indexDefinition.getTypes()[0]);\n        }\n      }\n    } else\n      keySerializer = new OSimpleKeySerializer();\n\n    final ODatabaseRecordInternal database = getDatabase();\n    final ORecordBytes identityRecord = new ORecordBytes();\n    final OAbstractPaginatedStorage storageLocalAbstract = (OAbstractPaginatedStorage) database.getStorage().getUnderlying();\n\n    database.save(identityRecord, clusterIndexName);\n    identity = identityRecord.getIdentity();\n\n    hashFunction.setValueSerializer(keySerializer);\n    hashTable.create(indexName, keySerializer, (OBinarySerializer<V>) valueSerializer,\n        indexDefinition != null ? indexDefinition.getTypes() : null, storageLocalAbstract, indexDefinition != null\n            && !indexDefinition.isNullValuesIgnored());\n  }","commit_id":"e167935c3c30de9b665fceccef0fe263e6705f29","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private OIndexRIDContainer containerFromStream(String stream) {\n    stream = stream.substring(OStringSerializerHelper.LINKSET_PREFIX.length(), stream.length() - 1);\n\n    final ODocument doc = new ODocument();\n    doc.fromString(stream);\n    final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer((Long) doc.field(\"rootIndex\"),\n        (Integer) doc.field(\"rootOffset\"));\n    final String fileName = doc.field(\"file\");\n\n    final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n    return new OIndexRIDContainer(fileName, new OIndexRIDContainerSBTree(fileName, rootPointer, false,\n        (OAbstractPaginatedStorage) db.getStorage()), false, false);\n  }","id":42900,"modified_method":"private OIndexRIDContainer containerFromStream(String stream) {\n    stream = stream.substring(OStringSerializerHelper.LINKSET_PREFIX.length(), stream.length() - 1);\n\n    final ODocument doc = new ODocument();\n    doc.fromString(stream);\n    final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer((Long) doc.field(\"rootIndex\"),\n        (Integer) doc.field(\"rootOffset\"));\n    final String fileName = doc.field(\"file\");\n\n    final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n    return new OIndexRIDContainer(fileName, new OIndexRIDContainerSBTree(fileName, rootPointer, false,\n        (OAbstractPaginatedStorage) db.getStorage().getUnderlying()), false, false);\n  }","commit_id":"34ad4a05883cb7ff1d86c096dd9bd3c10d7e0b1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public OIndexRIDContainer deserializeFromDirectMemoryObject(ODirectMemoryPointer pointer, long offset) {\n    final long fileId = LONG_SERIALIZER.deserializeFromDirectMemory(pointer, offset + FILE_ID_OFFSET);\n    final boolean durable = BOOLEAN_SERIALIZER.deserializeFromDirectMemory(pointer, offset + DURABLE_OFFSET);\n\n    if (BOOLEAN_SERIALIZER.deserializeFromDirectMemory(pointer, offset + EMBEDDED_OFFSET)) {\n      final int size = INT_SERIALIZER.deserializeFromDirectMemory(pointer, offset + EMBEDDED_SIZE_OFFSET);\n      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));\n\n      long p = offset + EMBEDDED_VALUES_OFFSET;\n      for (int i = 0; i < size; i++) {\n        underlying.add(LINK_SERIALIZER.deserializeFromDirectMemoryObject(pointer, p));\n        p += RID_SIZE;\n      }\n\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    } else {\n      final long pageIndex = LONG_SERIALIZER.deserializeFromDirectMemory(pointer, offset + SBTREE_ROOTINDEX_OFFSET);\n      final int pageOffset = INT_SERIALIZER.deserializeFromDirectMemory(pointer, offset + SBTREE_ROOTOFFSET_OFFSET);\n      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);\n      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer, durable,\n          (OAbstractPaginatedStorage) db.getStorage());\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    }\n  }","id":42901,"modified_method":"@Override\n  public OIndexRIDContainer deserializeFromDirectMemoryObject(ODirectMemoryPointer pointer, long offset) {\n    final long fileId = LONG_SERIALIZER.deserializeFromDirectMemory(pointer, offset + FILE_ID_OFFSET);\n    final boolean durable = BOOLEAN_SERIALIZER.deserializeFromDirectMemory(pointer, offset + DURABLE_OFFSET);\n\n    if (BOOLEAN_SERIALIZER.deserializeFromDirectMemory(pointer, offset + EMBEDDED_OFFSET)) {\n      final int size = INT_SERIALIZER.deserializeFromDirectMemory(pointer, offset + EMBEDDED_SIZE_OFFSET);\n      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));\n\n      long p = offset + EMBEDDED_VALUES_OFFSET;\n      for (int i = 0; i < size; i++) {\n        underlying.add(LINK_SERIALIZER.deserializeFromDirectMemoryObject(pointer, p));\n        p += RID_SIZE;\n      }\n\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    } else {\n      final long pageIndex = LONG_SERIALIZER.deserializeFromDirectMemory(pointer, offset + SBTREE_ROOTINDEX_OFFSET);\n      final int pageOffset = INT_SERIALIZER.deserializeFromDirectMemory(pointer, offset + SBTREE_ROOTOFFSET_OFFSET);\n      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);\n      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer, durable,\n          (OAbstractPaginatedStorage) db.getStorage().getUnderlying());\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    }\n  }","commit_id":"34ad4a05883cb7ff1d86c096dd9bd3c10d7e0b1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public OIndexRIDContainer deserializeNativeObject(byte[] stream, int offset) {\n    final long fileId = LONG_SERIALIZER.deserializeNative(stream, offset + FILE_ID_OFFSET);\n    final boolean durable = BOOLEAN_SERIALIZER.deserializeNative(stream, offset + DURABLE_OFFSET);\n\n    if (BOOLEAN_SERIALIZER.deserializeNative(stream, offset + EMBEDDED_OFFSET)) {\n      final int size = INT_SERIALIZER.deserializeNative(stream, offset + EMBEDDED_SIZE_OFFSET);\n      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));\n\n      int p = offset + EMBEDDED_VALUES_OFFSET;\n      for (int i = 0; i < size; i++) {\n        underlying.add(LINK_SERIALIZER.deserializeNativeObject(stream, p));\n        p += RID_SIZE;\n      }\n\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    } else {\n      final long pageIndex = LONG_SERIALIZER.deserializeNative(stream, offset + SBTREE_ROOTINDEX_OFFSET);\n      final int pageOffset = INT_SERIALIZER.deserializeNative(stream, offset + SBTREE_ROOTOFFSET_OFFSET);\n      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);\n      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer, durable,\n          (OAbstractPaginatedStorage) db.getStorage());\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    }\n  }","id":42902,"modified_method":"@Override\n  public OIndexRIDContainer deserializeNativeObject(byte[] stream, int offset) {\n    final long fileId = LONG_SERIALIZER.deserializeNative(stream, offset + FILE_ID_OFFSET);\n    final boolean durable = BOOLEAN_SERIALIZER.deserializeNative(stream, offset + DURABLE_OFFSET);\n\n    if (BOOLEAN_SERIALIZER.deserializeNative(stream, offset + EMBEDDED_OFFSET)) {\n      final int size = INT_SERIALIZER.deserializeNative(stream, offset + EMBEDDED_SIZE_OFFSET);\n      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));\n\n      int p = offset + EMBEDDED_VALUES_OFFSET;\n      for (int i = 0; i < size; i++) {\n        underlying.add(LINK_SERIALIZER.deserializeNativeObject(stream, p));\n        p += RID_SIZE;\n      }\n\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    } else {\n      final long pageIndex = LONG_SERIALIZER.deserializeNative(stream, offset + SBTREE_ROOTINDEX_OFFSET);\n      final int pageOffset = INT_SERIALIZER.deserializeNative(stream, offset + SBTREE_ROOTOFFSET_OFFSET);\n      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);\n      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer, durable,\n          (OAbstractPaginatedStorage) db.getStorage().getUnderlying());\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    }\n  }","commit_id":"34ad4a05883cb7ff1d86c096dd9bd3c10d7e0b1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public OIndexRIDContainer deserializeFromDirectMemoryObject(OWALChangesTree.PointerWrapper wrapper, long offset) {\n    final long fileId = LONG_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + FILE_ID_OFFSET);\n    final boolean durable = BOOLEAN_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + DURABLE_OFFSET);\n\n    if (BOOLEAN_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + EMBEDDED_OFFSET)) {\n      final int size = INT_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + EMBEDDED_SIZE_OFFSET);\n      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));\n\n      long p = offset + EMBEDDED_VALUES_OFFSET;\n      for (int i = 0; i < size; i++) {\n        underlying.add(LINK_SERIALIZER.deserializeFromDirectMemoryObject(wrapper, p));\n        p += RID_SIZE;\n      }\n\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    } else {\n      final long pageIndex = LONG_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + SBTREE_ROOTINDEX_OFFSET);\n      final int pageOffset = INT_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + SBTREE_ROOTOFFSET_OFFSET);\n      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);\n      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer, durable,\n          (OAbstractPaginatedStorage) db.getStorage());\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    }\n  }","id":42903,"modified_method":"@Override\n  public OIndexRIDContainer deserializeFromDirectMemoryObject(OWALChangesTree.PointerWrapper wrapper, long offset) {\n    final long fileId = LONG_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + FILE_ID_OFFSET);\n    final boolean durable = BOOLEAN_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + DURABLE_OFFSET);\n\n    if (BOOLEAN_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + EMBEDDED_OFFSET)) {\n      final int size = INT_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + EMBEDDED_SIZE_OFFSET);\n      final Set<OIdentifiable> underlying = new HashSet<OIdentifiable>(Math.max((int) (size / .75f) + 1, 16));\n\n      long p = offset + EMBEDDED_VALUES_OFFSET;\n      for (int i = 0; i < size; i++) {\n        underlying.add(LINK_SERIALIZER.deserializeFromDirectMemoryObject(wrapper, p));\n        p += RID_SIZE;\n      }\n\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    } else {\n      final long pageIndex = LONG_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + SBTREE_ROOTINDEX_OFFSET);\n      final int pageOffset = INT_SERIALIZER.deserializeFromDirectMemory(wrapper, offset + SBTREE_ROOTOFFSET_OFFSET);\n      final OBonsaiBucketPointer rootPointer = new OBonsaiBucketPointer(pageIndex, pageOffset);\n      final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n      final OIndexRIDContainerSBTree underlying = new OIndexRIDContainerSBTree(fileId, rootPointer, durable,\n          (OAbstractPaginatedStorage) db.getStorage().getUnderlying());\n      return new OIndexRIDContainer(fileId, underlying, durable);\n    }\n  }","commit_id":"34ad4a05883cb7ff1d86c096dd9bd3c10d7e0b1e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public byte[] getSignedBinaryToken(final ODatabaseDocumentInternal db, final OSecurityUser user,\n      final ONetworkProtocolData data) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    try {\n      final OBinaryToken token = new OBinaryToken();\n\n      long expiryMinutes = sessionInMills;\n      long currTime = System.currentTimeMillis();\n\n      final OrientJwtHeader header = new OrientJwtHeader();\n      header.setAlgorithm(algorithm);\n      header.setKeyId(keyProvider.getDefaultKey());\n      header.setType(\"OrientDB\");\n      token.setHeader(header);\n      if (db != null) {\n        token.setDatabase(db.getName());\n        token.setDatabaseType(db.getStorage().getType());\n      }\n      if (data.serverUser) {\n        token.setServerUser(true);\n        token.setUserName(data.serverUsername);\n      }\n      if (user != null)\n        token.setUserRid(user.getIdentity().getIdentity());\n      token.setExpiry(currTime + expiryMinutes);\n      token.setProtocolVersion(data.protocolVersion);\n      token.setSerializer(data.serializationImpl);\n      token.setDriverName(data.driverName);\n      token.setDriverVersion(data.driverVersion);\n\n      binarySerializer.serialize(token, baos);\n\n      final byte[] signature = signToken(header, baos.toByteArray());\n      baos.write(signature);\n\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new OException(e);\n    }\n    return baos.toByteArray();\n  }","id":42904,"modified_method":"public byte[] getSignedBinaryToken(final ODatabaseDocumentInternal db, final OSecurityUser user,\n      final ONetworkProtocolData data) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    try {\n      final OBinaryToken token = new OBinaryToken();\n\n      long expiryMinutes = sessionInMills;\n      long currTime = System.currentTimeMillis();\n\n      final OrientJwtHeader header = new OrientJwtHeader();\n      header.setAlgorithm(algorithm);\n      header.setKeyId(keyProvider.getDefaultKey());\n      header.setType(\"OrientDB\");\n      token.setHeader(header);\n      if (db != null) {\n        token.setDatabase(db.getName());\n        token.setDatabaseType(db.getStorage().getUnderlying().getType());\n      }\n      if (data.serverUser) {\n        token.setServerUser(true);\n        token.setUserName(data.serverUsername);\n      }\n      if (user != null)\n        token.setUserRid(user.getIdentity().getIdentity());\n      token.setExpiry(currTime + expiryMinutes);\n      token.setProtocolVersion(data.protocolVersion);\n      token.setSerializer(data.serializationImpl);\n      token.setDriverName(data.driverName);\n      token.setDriverVersion(data.driverVersion);\n\n      binarySerializer.serialize(token, baos);\n\n      final byte[] signature = signToken(header, baos.toByteArray());\n      baos.write(signature);\n\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new OException(e);\n    }\n    return baos.toByteArray();\n  }","commit_id":"99765cc9721aa08ad9216911dda58ea349af6b4e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void load(ORID indexRid, String indexName, OIndexDefinition indexDefinition, boolean isAutomatic) {\n    identity = indexRid;\n    hashTable.load(indexName, (OStorageLocalAbstract) getDatabase().getStorage());\n    hashFunction.setValueSerializer(hashTable.getKeySerializer());\n  }","id":42905,"modified_method":"@Override\n  public void load(ORID indexRid, String indexName, OIndexDefinition indexDefinition, boolean isAutomatic) {\n    identity = indexRid;\n    hashTable.load(indexName, (OStorageLocalAbstract) getDatabase().getStorage().getUnderlying());\n    hashFunction.setValueSerializer(hashTable.getKeySerializer());\n  }","commit_id":"09e058700d0acb3ac9eae9c1f3ffd94c80bf30ab","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void convertToSbTree() {\n    final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n    final OIndexRIDContainerSBTree tree = new OIndexRIDContainerSBTree(fileId, durableNonTxMode,\n        (OAbstractPaginatedStorage) db.getStorage());\n\n    tree.addAll(underlying);\n\n    underlying = tree;\n    isEmbedded = false;\n  }","id":42906,"modified_method":"private void convertToSbTree() {\n    final ODatabaseDocumentInternal db = ODatabaseRecordThreadLocal.INSTANCE.get();\n    final OIndexRIDContainerSBTree tree = new OIndexRIDContainerSBTree(fileId, durableNonTxMode,\n        (OAbstractPaginatedStorage) db.getStorage().getUnderlying());\n\n    tree.addAll(underlying);\n\n    underlying = tree;\n    isEmbedded = false;\n  }","commit_id":"5c17d3e6b2932a796fdf3336d4a538917355c2bf","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Auto register myself as hook.\r\n   */\r\n  @Override\r\n  public void onOpen(final ODatabaseInternal iDatabase) {\r\n    final String dbUrl = OSystemVariableResolver.resolveSystemVariables(iDatabase.getURL());\r\n\r\n    if (dbUrl.startsWith(\"plocal:\")) {\r\n      // CHECK SPECIAL CASE WITH MULTIPLE SERVER INSTANCES ON THE SAME JVM\r\n      final String dbDirectory = serverInstance.getDatabaseDirectory();\r\n      if (!dbUrl.substring(\"plocal:\".length()).startsWith(dbDirectory))\r\n        // SKIP IT: THIS HAPPENS ONLY ON MULTIPLE SERVER INSTANCES ON THE SAME JVM\r\n        return;\r\n    } else if (dbUrl.startsWith(\"remote:\"))\r\n      return;\r\n\r\n    final ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal.INSTANCE.getIfDefined();\r\n    try {\r\n      synchronized (cachedDatabaseConfiguration) {\r\n        final ODistributedConfiguration cfg = getDatabaseConfiguration(iDatabase.getName());\r\n        if (cfg == null)\r\n          return;\r\n\r\n        if (iDatabase instanceof ODatabase<?> && (!(iDatabase.getStorage() instanceof ODistributedStorage)\r\n            || ((ODistributedStorage) iDatabase.getStorage()).getDistributedManager().isOffline())) {\r\n          ODistributedStorage storage = storages.get(iDatabase.getURL());\r\n          if (storage == null) {\r\n            storage = new ODistributedStorage(serverInstance, (OAbstractPaginatedStorage) iDatabase.getStorage());\r\n            final ODistributedStorage oldStorage = storages.putIfAbsent(iDatabase.getURL(), storage);\r\n            if (oldStorage != null)\r\n              storage = oldStorage;\r\n          }\r\n\r\n          iDatabase.replaceStorage(storage);\r\n\r\n          installDbClustersLocalStrategy(iDatabase);\r\n        }\r\n\r\n      }\r\n    } finally {\r\n      // RESTORE ORIGINAL DATABASE INSTANCE IN TL\r\n      ODatabaseRecordThreadLocal.INSTANCE.set(currDb);\r\n    }\r\n  }","id":42907,"modified_method":"/**\r\n   * Auto register myself as hook.\r\n   */\r\n  @Override\r\n  public void onOpen(final ODatabaseInternal iDatabase) {\r\n    final String dbUrl = OSystemVariableResolver.resolveSystemVariables(iDatabase.getURL());\r\n\r\n    if (dbUrl.startsWith(\"plocal:\")) {\r\n      // CHECK SPECIAL CASE WITH MULTIPLE SERVER INSTANCES ON THE SAME JVM\r\n      final String dbDirectory = serverInstance.getDatabaseDirectory();\r\n      if (!dbUrl.substring(\"plocal:\".length()).startsWith(dbDirectory))\r\n        // SKIP IT: THIS HAPPENS ONLY ON MULTIPLE SERVER INSTANCES ON THE SAME JVM\r\n        return;\r\n    } else if (dbUrl.startsWith(\"remote:\"))\r\n      return;\r\n\r\n    final ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal.INSTANCE.getIfDefined();\r\n    try {\r\n      synchronized (cachedDatabaseConfiguration) {\r\n        final ODistributedConfiguration cfg = getDatabaseConfiguration(iDatabase.getName());\r\n        if (cfg == null)\r\n          return;\r\n\r\n        if (!(iDatabase.getStorage() instanceof ODistributedStorage)\r\n            || ((ODistributedStorage) iDatabase.getStorage()).getDistributedManager().isOffline()) {\r\n\r\n          ODistributedStorage storage = storages.get(iDatabase.getURL());\r\n          if (storage == null) {\r\n            storage = new ODistributedStorage(serverInstance, (OAbstractPaginatedStorage) iDatabase.getStorage().getUnderlying());\r\n            final ODistributedStorage oldStorage = storages.putIfAbsent(iDatabase.getURL(), storage);\r\n            if (oldStorage != null)\r\n              storage = oldStorage;\r\n          }\r\n\r\n          iDatabase.replaceStorage(storage);\r\n\r\n          installDbClustersLocalStrategy(iDatabase);\r\n        }\r\n\r\n      }\r\n    } finally {\r\n      // RESTORE ORIGINAL DATABASE INSTANCE IN TL\r\n      ODatabaseRecordThreadLocal.INSTANCE.set(currDb);\r\n    }\r\n  }","commit_id":"d1f6a827e84de16a4498092a5b6da80ec8b6a05e","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String getValue() {\n    return myValue;\n  }","id":42908,"modified_method":"public String getValue() {\n    return myValue.getString();\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AttributeStub(DomStub parent, String name, String value) {\n    super(parent, name);\n    myValue = value;\n  }","id":42909,"modified_method":"public AttributeStub(DomStub parent, StringRef name, StringRef value) {\n    super(parent);\n    myName = name;\n    myValue = value;\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public AttributeStub deserialize(StubInputStream dataStream, TagStub parentStub) throws IOException {\n    return new AttributeStub(parentStub, dataStream.readName().getString(), dataStream.readName().getString());\n  }","id":42910,"modified_method":"@Override\n  public AttributeStub deserialize(StubInputStream dataStream, ElementStub parentStub) throws IOException {\n    return new AttributeStub(parentStub, dataStream.readName(), dataStream.readName());\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String stubTreeToString(final StubElement root) {\n    final LengthBuilder ruler = new LengthBuilder();\n    stubTreeToBuffer(root, ruler, 0);\n    final StringBuilder builder = new StringBuilder(ruler.getLength());\n    stubTreeToBuffer(root, builder, 0);\n    return builder.toString();\n  }","id":42911,"modified_method":"public static String stubTreeToString(final Stub root) {\n    final LengthBuilder ruler = new LengthBuilder();\n    stubTreeToBuffer(root, ruler, 0);\n    final StringBuilder builder = new StringBuilder(ruler.getLength());\n    stubTreeToBuffer(root, builder, 0);\n    return builder.toString();\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void stubTreeToBuffer(final StubElement node, final Appendable buffer, final int indent) {\n    StringUtil.repeatSymbol(buffer, ' ', indent);\n    try {\n      final IStubElementType stubType = node.getStubType();\n      if (stubType != null) {\n        buffer.append(stubType.toString()).append(':');\n      }\n      buffer.append(node.toString()).append('\\n');\n\n      @SuppressWarnings({\"unchecked\"})\n      final List<StubElement> children = node.getChildrenStubs();\n      for (final StubElement child : children) {\n        stubTreeToBuffer(child, buffer, indent + 2);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":42912,"modified_method":"public static void stubTreeToBuffer(final Stub node, final Appendable buffer, final int indent) {\n    StringUtil.repeatSymbol(buffer, ' ', indent);\n    try {\n      final ObjectStubSerializer stubType = node.getStubType();\n      if (stubType != null) {\n        buffer.append(stubType.toString()).append(':');\n      }\n      buffer.append(node.toString()).append('\\n');\n\n      @SuppressWarnings({\"unchecked\"})\n      final List<? extends Stub> children = node.getChildrenStubs();\n      for (final Stub child : children) {\n        stubTreeToBuffer(child, buffer, indent + 2);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DomStub(DomStub parent, String name) {\n    super(parent);\n    myName = name;\n    if (parent != null) {\n      ((TagStub)parent).addChild(this);\n    }\n  }","id":42913,"modified_method":"public DomStub(DomStub parent) {\n    super(parent);\n    if (parent != null) {\n      ((ElementStub)parent).addChild(this);\n    }\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Stub buildStubTree(VirtualFile file, byte[] content, Project project) {\n\n    PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    if (!(psiFile instanceof XmlFile)) return null;\n\n    XmlFile xmlFile = (XmlFile)psiFile;\n    DomManager manager = DomManager.getDomManager(project);\n    DomFileElement<? extends DomElement> fileElement = manager.getFileElement(xmlFile);\n    if (fileElement == null || !fileElement.getFileDescription().hasStubs()) return null;\n\n    return new TagStub(null, fileElement.getRootTag().getLocalName());\n  }","id":42914,"modified_method":"@Override\n  public Stub buildStubTree(VirtualFile file, byte[] content, Project project) {\n\n    PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    if (!(psiFile instanceof XmlFile)) return null;\n\n    XmlFile xmlFile = (XmlFile)psiFile;\n    DomManager manager = DomManager.getDomManager(project);\n    DomFileElement<? extends DomElement> fileElement = manager.getFileElement(xmlFile);\n    if (fileElement == null || !fileElement.getFileDescription().hasStubs()) return null;\n    DomStubBuilderVisitor visitor = new DomStubBuilderVisitor();\n    visitor.visitDomElement(fileElement.getRootElement());\n    return visitor.getRoot();\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testDomLoading() throws Exception {\n\n    PsiFile psiFile = myFixture.configureByFile(\"foo.xml\");\n\n    StubTreeLoader loader = StubTreeLoader.getInstance();\n    VirtualFile file = psiFile.getVirtualFile();\n    assertTrue(loader.canHaveStub(file));\n    ObjectStubTree stubTree = loader.readFromVFile(getProject(), file);\n    assertNotNull(stubTree);\n  }","id":42915,"modified_method":"public void testDomLoading() throws Exception {\n    getRootStub(\"foo.xml\");\n  }","commit_id":"d87891caea65e0484164053510c8e702ff4e6526","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PyQualifiedName deserialize(StubInputStream dataStream) throws IOException {\n    PyQualifiedName qName;\n    int size = dataStream.readVarInt();\n    if (size == 0) {\n      qName = null;\n    }\n    else {\n      qName = new PyQualifiedName(size);\n      for (int i = 0; i < size; i++) {\n        qName.myComponents.add(dataStream.readName().getString());\n      }\n    }\n    return qName;\n  }","id":42916,"modified_method":"@Nullable\n  public static PyQualifiedName deserialize(StubInputStream dataStream) throws IOException {\n    PyQualifiedName qName;\n    int size = dataStream.readVarInt();\n    if (size == 0) {\n      qName = null;\n    }\n    else {\n      qName = new PyQualifiedName(size);\n      for (int i = 0; i < size; i++) {\n        final StringRef name = dataStream.readName();\n        qName.myComponents.add(name == null ? null : name.getString());\n      }\n    }\n    return qName;\n  }","commit_id":"d11a0a6cb0e2ea8d96d6ef06e2f4303f05c9a6be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getStubVersion() {\n    return 15;\n  }","id":42917,"modified_method":"@Override\n  public int getStubVersion() {\n    return 16;\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    // import is per-file\n    if (place.getContainingFile() != getContainingFile()) {\n      return true;\n    }\n    if (isStarImport()) {\n      PyReferenceExpression expr = getImportSource();\n      if (expr != null) {\n        final PsiElement importedFile = PyReferenceExpressionImpl.turnDirIntoInit(ResolveImportUtil.resolveImportReference(expr));\n        if (importedFile != null) {\n          return importedFile.processDeclarations(processor, state, null, place);\n        }\n      }\n    }\n    else {\n      PyImportElement[] importElements = getImportElements();\n      for(PyImportElement element: importElements) {\n        if (!element.processDeclarations(processor, state, lastParent, place)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","id":42918,"modified_method":"public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    // import is per-file\n    if (place.getContainingFile() != getContainingFile()) {\n      return true;\n    }\n    if (isStarImport()) {\n      PyReferenceExpression expr = getImportSource();\n      if (expr != null) {\n        final PsiElement target = ResolveImportUtil.resolveImportReference(expr);\n        final PsiElement importedFile = PyReferenceExpressionImpl.turnDirIntoInit(target);\n        if (importedFile != null) {\n          return importedFile.processDeclarations(processor, state, null, place);\n        }\n      }\n    }\n    else {\n      PyImportElement[] importElements = getImportElements();\n      for(PyImportElement element: importElements) {\n        if (!element.processDeclarations(processor, state, lastParent, place)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PyImportElementStub createStub(PyImportElement psi, StubElement parentStub) {\n    final PyReferenceExpression importReference = psi.getImportReference();\n    final PyTargetExpression asName = psi.getAsName();\n    return new PyImportElementStubImpl(importReference != null ? importReference.getText() : \"\",\n                                       asName != null ? asName.getText() : \"\",\n                                       parentStub);\n  }","id":42919,"modified_method":"@Override\n  public PyImportElementStub createStub(PyImportElement psi, StubElement parentStub) {\n    final PyTargetExpression asName = psi.getAsName();\n    return new PyImportElementStubImpl(psi.getImportedQName(),\n                                       asName != null ? asName.getText() : \"\",\n                                       parentStub);\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void serialize(PyImportElementStub stub, StubOutputStream dataStream) throws IOException {\n    dataStream.writeName(stub.getImportedName());\n    dataStream.writeName(stub.getAsName());\n  }","id":42920,"modified_method":"public void serialize(PyImportElementStub stub, StubOutputStream dataStream) throws IOException {\n    final List<String> qName = stub.getImportedQName();\n    dataStream.writeVarInt(qName.size());\n    for (String s : qName) {\n      dataStream.writeName(s);\n    }\n    dataStream.writeName(stub.getAsName());\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyImportElementStub deserialize(StubInputStream dataStream, StubElement parentStub) throws IOException {\n    StringRef importedName = dataStream.readName();\n    StringRef asName = dataStream.readName();\n    return new PyImportElementStubImpl(importedName.getString(), asName.getString(), parentStub);\n  }","id":42921,"modified_method":"public PyImportElementStub deserialize(StubInputStream dataStream, StubElement parentStub) throws IOException {\n    int size = dataStream.readVarInt();\n    List<String> qName = new ArrayList<String>(size);\n    for (int i = 0; i < size; i++) {\n      qName.add(dataStream.readName().getString());\n    }\n    StringRef asName = dataStream.readName();\n    return new PyImportElementStubImpl(qName, asName.getString(), parentStub);  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getVisibleName() {\n    final PyImportElementStub stub = getStub();\n    if (stub != null) {\n      final String asName = stub.getAsName();\n      if (!StringUtil.isEmpty(asName)) {\n        return asName;\n      }\n      final String importedName = stub.getImportedName();\n      if (!StringUtil.isEmpty(importedName)) {\n        return importedName;\n      }\n      return null;\n    }\n    PyTargetExpression asname = getAsName();\n    if (asname != null) return asname.getName();\n    final PyReferenceExpression import_ref = getImportReference();\n    if (import_ref != null) return PyResolveUtil.toPath(import_ref, \".\");\n    return null; // we might have not found any names\n  }","id":42922,"modified_method":"@Nullable\n  public String getVisibleName() {\n    final PyImportElementStub stub = getStub();\n    if (stub != null) {\n      final String asName = stub.getAsName();\n      if (!StringUtil.isEmpty(asName)) {\n        return asName;\n      }\n      final List<String> importedName = stub.getImportedQName();\n      if (importedName.size() > 0) {\n        return importedName.get(importedName.size()-1);\n      }\n      return null;\n    }\n    PyTargetExpression asname = getAsName();\n    if (asname != null) return asname.getName();\n    final PyReferenceExpression import_ref = getImportReference();\n    if (import_ref != null) return PyResolveUtil.toPath(import_ref, \".\");\n    return null; // we might have not found any names\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getImportedName() {\n    return myImportedName;\n  }","id":42923,"modified_method":"public List<String> getImportedQName() {\n    return myImportedQName;\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyImportElementStubImpl(String importedName, String asName, final StubElement parent) {\n    super(parent, PyElementTypes.IMPORT_ELEMENT);\n    myImportedName = importedName;\n    myAsName = asName;\n  }","id":42924,"modified_method":"public PyImportElementStubImpl(List<String> importedQName, String asName, final StubElement parent) {\n    super(parent, PyElementTypes.IMPORT_ELEMENT);\n    myImportedQName = importedQName;\n    myAsName = asName;\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getAsName() {\n    if (!StringUtil.isEmpty(myAsName)) {\n      return myAsName;\n    }\n    return myImportedName;\n  }","id":42925,"modified_method":"public String getAsName() {\n    return myAsName;\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testImportStatement() throws Exception {\n    final PyFileImpl file = (PyFileImpl) getTestFile();\n\n    final List<PyFromImportStatement> fromImports = file.getFromImports();\n    assertEquals(1, fromImports.size());\n    final PyFromImportStatement fromImport = fromImports.get(0);\n    final PyImportElement[] importElements = fromImport.getImportElements();\n    assertEquals(1, importElements.length);\n    assertEquals(\"argv\", importElements [0].getVisibleName());\n    assertFalse(fromImport.isStarImport());\n    assertEquals(0, fromImport.getRelativeLevel());\n    final List<String> qName = fromImport.getImportSourceQName();\n    assertEquals(1, qName.size());\n    assertEquals(\"sys\", qName.get(0));\n\n    final List<PyImportElement> importTargets = file.getImportTargets();\n    assertEquals(1, importTargets.size());\n\n    assertNotParsed(file);\n  }","id":42926,"modified_method":"public void testImportStatement() throws Exception {\n    final PyFileImpl file = (PyFileImpl) getTestFile();\n\n    final List<PyFromImportStatement> fromImports = file.getFromImports();\n    assertEquals(1, fromImports.size());\n    final PyFromImportStatement fromImport = fromImports.get(0);\n    final PyImportElement[] importElements = fromImport.getImportElements();\n    assertEquals(1, importElements.length);\n    assertEquals(\"argv\", importElements [0].getVisibleName());\n    assertFalse(fromImport.isStarImport());\n    assertEquals(0, fromImport.getRelativeLevel());\n    final List<String> qName = fromImport.getImportSourceQName();\n    assertSameElements(qName, \"sys\");\n\n    final List<PyImportElement> importTargets = file.getImportTargets();\n    assertEquals(1, importTargets.size());\n    final PyImportElement importElement = importTargets.get(0);\n    final List<String> importQName = importElement.getImportedQName();\n    assertSameElements(importQName, \"os\", \"path\");\n\n    assertNotParsed(file);\n  }","commit_id":"65bd4859840a17cd632d26ad3f4f2329b5b4fe1f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void transform(IN input, Emitter<KeyValue<KEY_OUT, VAL_OUT>> emitter) throws Exception {\n    emitter.emit(new KeyValue<KEY_OUT, VAL_OUT>((KEY_OUT) input, null));\n  }","id":42927,"modified_method":"/**\n   * Transform the input received from previous stage to a {@link KeyValue} pair which can be\n   * consumed by the output configured in the Job.\n   *\n   * @param input the input to transform\n   * @param emitter {@link Emitter} to emit data to the next stage\n   * @throws Exception if there's an error during this method invocation\n   */\n  @Override\n  public void transform(IN input, Emitter<KeyValue<KEY_OUT, VAL_OUT>> emitter) throws Exception {\n    emitter.emit(new KeyValue<KEY_OUT, VAL_OUT>((KEY_OUT) input, null));\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void transform(KeyValue<KEY_IN, VAL_IN> input, Emitter<OUT> emitter) throws Exception {\n    emitter.emit((OUT) input.getValue());\n  }","id":42928,"modified_method":"/**\n   * Transform the {@link KeyValue} pair produced by the input, configured in the Job,\n   * to a single object and emit it to the next stage. By default it emits the value.\n   *\n   * @param input the input to transform\n   * @param emitter {@link Emitter} to emit data to the next stage\n   * @throws Exception if there's an error during this method invocation\n   */\n  @Override\n  public void transform(KeyValue<KEY_IN, VAL_IN> input, Emitter<OUT> emitter) throws Exception {\n    emitter.emit((OUT) input.getValue());\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure(ApplicationConfigurer configurer, ApplicationContext context) {\n    configurer.setName(getAppName(\"etl.batch.plugin.name\"));\n    configurer.setDescription(\"Batch Extract-Transform-Load (ETL) Adapter\");\n    configurer.addMapReduce(new ETLMapReduce());\n    configurer.addWorkflow(new ETLWorkflow());\n  }","id":42929,"modified_method":"@Override\n  public void configure(ApplicationConfigurer configurer, ApplicationContext context) {\n    configurer.setName(getAppName(\"etl.batch.plugin.name\"));\n    configurer.setDescription(\"Batch Extract-Transform-Load (ETL) Template\");\n    configurer.addMapReduce(new ETLMapReduce());\n    configurer.addWorkflow(new ETLWorkflow());\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"private void prepareSink(MapReduceContext context, ETLStage sinkStage) throws Exception {\n    String sinkPluginId = context.getRuntimeArguments().get(Constants.Sink.PLUGINID);\n    BatchSink sink = context.newPluginInstance(sinkPluginId);\n    BatchSinkContext sinkContext = new MapReduceSinkContext(context, mrMetrics, sinkPluginId);\n    LOG.info(\"Sink Stage : {}\", sinkStage);\n    LOG.info(\"Sink Class : {}\", sink.getClass().getName());\n    sink.prepareJob(sinkContext);\n  }","id":42930,"modified_method":"private void prepareSink(MapReduceContext context, ETLStage sinkStage) throws Exception {\n    sinkPluginId = context.getRuntimeArguments().get(Constants.Sink.PLUGINID);\n    batchSink = context.newPluginInstance(sinkPluginId);\n    BatchSinkContext sinkContext = new MapReduceSinkContext(context, mrMetrics, sinkPluginId);\n    LOG.info(\"Sink Stage : {}\", sinkStage);\n    LOG.info(\"Sink Class : {}\", batchSink.getClass().getName());\n    batchSink.prepareJob(sinkContext);\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"private void prepareSource(MapReduceContext context, ETLStage sourceStage) throws Exception {\n    String sourcePluginId = context.getRuntimeArguments().get(Constants.Source.PLUGINID);\n    BatchSource source = context.newPluginInstance(sourcePluginId);\n    BatchSourceContext sourceContext = new MapReduceSourceContext(context, mrMetrics, sourcePluginId);\n    LOG.info(\"Source Stage : {}\", sourceStage);\n    LOG.info(\"Source Class : {}\", source.getClass().getName());\n    source.prepareJob(sourceContext);\n  }","id":42931,"modified_method":"private void prepareSource(MapReduceContext context, ETLStage sourceStage) throws Exception {\n    sourcePluginId = context.getRuntimeArguments().get(Constants.Source.PLUGINID);\n    batchSource = context.newPluginInstance(sourcePluginId);\n    BatchSourceContext sourceContext = new MapReduceSourceContext(context, mrMetrics, sourcePluginId);\n    LOG.info(\"Source Stage : {}\", sourceStage);\n    LOG.info(\"Source Class : {}\", batchSource.getClass().getName());\n    batchSource.prepareJob(sourceContext);\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void beforeSubmit(MapReduceContext context) throws Exception {\n    Job job = context.getHadoopJob();\n    Map<String, String> runtimeArgs = context.getRuntimeArguments();\n\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.ADAPTER_NAME));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.CONFIG_KEY));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Source.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Sink.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Transform.PLUGINIDS));\n\n    ETLBatchConfig config = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n\n    prepareSource(context, config.getSource());\n    prepareSink(context, config.getSink());\n\n    if (config.getResources() != null) {\n      context.setMapperResources(config.getResources());\n    }\n    job.setMapperClass(ETLMapper.class);\n    job.setNumReduceTasks(0);\n  }","id":42932,"modified_method":"@Override\n  public void beforeSubmit(MapReduceContext context) throws Exception {\n    Job job = context.getHadoopJob();\n    Map<String, String> runtimeArgs = context.getRuntimeArguments();\n\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.ADAPTER_NAME));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.CONFIG_KEY));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Source.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Sink.PLUGINID));\n    Preconditions.checkArgument(runtimeArgs.containsKey(Constants.Transform.PLUGINIDS));\n\n    ETLBatchConfig etlBatchConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n\n    prepareSource(context, etlBatchConfig.getSource());\n    prepareSink(context, etlBatchConfig.getSink());\n\n    if (etlBatchConfig.getResources() != null) {\n      context.setMapperResources(etlBatchConfig.getResources());\n    }\n    job.setMapperClass(ETLMapper.class);\n    job.setNumReduceTasks(0);\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void onFinish(boolean succeeded, MapReduceContext context) {\n    LOG.info(\"Batch Run for Adapter {} : {}\", context.getRuntimeArguments().get(Constants.ADAPTER_NAME), succeeded);\n  }","id":42933,"modified_method":"@Override\n  public void onFinish(boolean succeeded, MapReduceContext context) throws Exception {\n    teardownSource(context, succeeded);\n    teardownSink(context, succeeded);\n    LOG.info(\"Batch Run for Adapter {} : {}\", context.getRuntimeArguments().get(Constants.ADAPTER_NAME), succeeded);\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure(ApplicationConfigurer configurer, ApplicationContext context) {\n    configurer.setName(getAppName(\"etl.realtime.plugin.name\"));\n    configurer.setDescription(\"Realtime Extract-Transform-Load (ETL) Adapter\");\n    configurer.addWorker(new ETLWorker());\n    configurer.createDataset(STATE_TABLE, KeyValueTable.class, DatasetProperties.EMPTY);\n  }","id":42934,"modified_method":"@Override\n  public void configure(ApplicationConfigurer configurer, ApplicationContext context) {\n    configurer.setName(getAppName(\"etl.realtime.plugin.name\"));\n    configurer.setDescription(\"Realtime Extract-Transform-Load (ETL) Template\");\n    configurer.addWorker(new ETLWorker());\n    configurer.createDataset(STATE_TABLE, KeyValueTable.class, DatasetProperties.EMPTY);\n  }","commit_id":"e4b5535ea186352ece0304f79e5a65535ff8c205","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void initialize(MapReduceContext context) throws Exception {\n      Map<String, String> runtimeArgs = context.getRuntimeArguments();\n      ETLBatchConfig etlConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n      String sourceId = runtimeArgs.get(Constants.Source.PLUGINID);\n      String sinkId = runtimeArgs.get(Constants.Sink.PLUGINID);\n      List<String> transformIds = GSON.fromJson(runtimeArgs.get(Constants.Transform.PLUGINIDS), STRING_LIST_TYPE);\n\n\n      List<ETLStage> stageList = etlConfig.getTransforms();\n      LOG.info(\"Transform Stages : {}\", stageList);\n\n      List<Transform> pipeline = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      List<StageMetrics> stageMetrics = Lists.newArrayListWithCapacity(stageList.size() + 2);\n\n      BatchSource source = context.newPluginInstance(sourceId);\n      source.initialize(etlConfig.getSource());\n      pipeline.add(source);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SOURCE, etlConfig.getSource().getName()));\n\n      addTransforms(stageList, pipeline, stageMetrics, transformIds, context);\n\n      BatchSink sink = context.newPluginInstance(sinkId);\n      sink.initialize(etlConfig.getSink());\n      pipeline.add(sink);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SINK, etlConfig.getSink().getName()));\n\n      transformExecutor = new TransformExecutor<KeyValue, KeyValue>(pipeline, stageMetrics);\n    }","id":42935,"modified_method":"@Override\n    public void initialize(MapReduceContext context) throws Exception {\n      Map<String, String> runtimeArgs = context.getRuntimeArguments();\n      ETLBatchConfig etlConfig = GSON.fromJson(runtimeArgs.get(Constants.CONFIG_KEY), ETLBatchConfig.class);\n      String sourceId = runtimeArgs.get(Constants.Source.PLUGINID);\n      String sinkId = runtimeArgs.get(Constants.Sink.PLUGINID);\n      List<String> transformIds = GSON.fromJson(runtimeArgs.get(Constants.Transform.PLUGINIDS), STRING_LIST_TYPE);\n\n\n      List<ETLStage> stageList = etlConfig.getTransforms();\n      LOG.info(\"Transform Stages : {}\", stageList);\n\n      List<Transform> pipeline = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      List<StageMetrics> stageMetrics = Lists.newArrayListWithCapacity(stageList.size() + 2);\n      transforms = Lists.newArrayListWithCapacity(stageList.size());\n\n      source = context.newPluginInstance(sourceId);\n      source.initialize(context.getPluginProperties(sourceId));\n      pipeline.add(source);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SOURCE, etlConfig.getSource().getName()));\n\n      addTransforms(stageList, pipeline, stageMetrics, transformIds, context);\n\n      sink = context.newPluginInstance(sinkId);\n      sink.initialize(context.getPluginProperties(sinkId));\n      pipeline.add(sink);\n      stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.SINK, etlConfig.getSink().getName()));\n\n      transformExecutor = new TransformExecutor<KeyValue, KeyValue>(pipeline, stageMetrics);\n    }","commit_id":"aaf35edaee1470d6f02b884d54bc4a6724e08a00","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void destroy() {\n      // no-op\n    }","id":42936,"modified_method":"@Override\n    public void destroy() {\n      try {\n        source.destroy();\n      } catch (Exception e) {\n        LOG.warn(\"Destroy of Source {} threw an Exception : \", source.getClass().getName(), e);\n      }\n\n      for (TransformStage transform : transforms) {\n        try {\n          transform.destroy();\n        } catch (Exception e) {\n          LOG.warn(\"Destroy of Transform {} threw an Exception : \", transform.getClass().getName(), e);\n        }\n      }\n\n      try {\n        sink.destroy();\n      } catch (Exception e) {\n        LOG.warn(\"Destroy of Sink {} threw an Exception : \", sink.getClass().getName(), e);\n      }\n    }","commit_id":"aaf35edaee1470d6f02b884d54bc4a6724e08a00","url":"https://github.com/caskdata/cdap"},{"original_method":"private void addTransforms(List<ETLStage> stageConfigs, List<Transform> pipeline,\n                               List<StageMetrics> stageMetrics, List<String> transformIds,\n                               MapReduceContext context) throws InstantiationException {\n      Preconditions.checkArgument(stageConfigs.size() == transformIds.size());\n\n      for (int i = 0; i < stageConfigs.size(); i++) {\n        ETLStage stageConfig = stageConfigs.get(i);\n        String transformId = transformIds.get(i);\n        TransformStage transform = context.newPluginInstance(transformId);\n        BatchStageContext transformContext = new BatchStageContext(context, mapperMetrics, transformId);\n        transform.initialize(transformContext);\n\n        pipeline.add(transform);\n        stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.TRANSFORM, stageConfig.getName()));\n      }\n    }","id":42937,"modified_method":"private void addTransforms(List<ETLStage> stageConfigs, List<Transform> pipeline,\n                               List<StageMetrics> stageMetrics, List<String> transformIds,\n                               MapReduceContext context) throws InstantiationException {\n      Preconditions.checkArgument(stageConfigs.size() == transformIds.size());\n\n      for (int i = 0; i < stageConfigs.size(); i++) {\n        ETLStage stageConfig = stageConfigs.get(i);\n        String transformId = transformIds.get(i);\n        TransformStage transform = context.newPluginInstance(transformId);\n        BatchStageContext transformContext = new BatchStageContext(context, mapperMetrics, transformId);\n        transform.initialize(transformContext);\n\n        pipeline.add(transform);\n        transforms.add(transform);\n        stageMetrics.add(new StageMetrics(mapperMetrics, StageMetrics.Type.TRANSFORM, stageConfig.getName()));\n      }\n    }","commit_id":"aaf35edaee1470d6f02b884d54bc4a6724e08a00","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() {\n    running = false;\n    source.destroy();\n    for (TransformStage transform : transforms) {\n      transform.destroy();\n    }\n    sink.destroy();\n  }","id":42938,"modified_method":"@Override\n  public void stop() {\n    running = false;\n    try {\n      source.destroy();\n    } catch (Exception e) {\n      LOG.warn(\"Destroy of Source {} threw an Exception : \", source.getClass().getName(), e);\n    }\n\n    for (TransformStage transform : transforms) {\n      try {\n        transform.destroy();\n      } catch (Exception e) {\n        LOG.warn(\"Destroy of Transform {} threw an Exception : \", transform.getClass().getName(), e);\n      }\n    }\n\n    try {\n      sink.destroy();\n    } catch (Exception e) {\n      LOG.warn(\"Destroy of Sink {} threw an Exception : \", sink.getClass().getName(), e);\n    }\n  }","commit_id":"aaf35edaee1470d6f02b884d54bc4a6724e08a00","url":"https://github.com/caskdata/cdap"},{"original_method":"private void init( File workingDir )\n    {\n        setDirectory( workingDir );\n        withConfig( GraphDatabaseSettings.auth_enabled, \"false\" );\n        withConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n        withConfig( ServerSettings.webserver_port.name(), Integer.toString( freePort(7474, 10000) ) );\n\n        withConfig( connector( 0, enabled ), \"true\" );\n        withConfig( connector( 0, socket_address ), \"localhost:\" + Integer.toString( freePort(7687, 10000) ) );\n    }","id":42939,"modified_method":"private void init( File workingDir )\n    {\n        setDirectory( workingDir );\n        withConfig( GraphDatabaseSettings.auth_enabled, \"false\" );\n        withConfig( GraphDatabaseSettings.auth_store,\n                ServerTestUtils.getRelativePath( workingDir, GraphDatabaseSettings.auth_store ) );\n        withConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n        withConfig( ServerSettings.webserver_port.name(), Integer.toString( freePort( 7474, 10000 ) ) );\n        withConfig( ServerSettings.tls_key_file,\n                ServerTestUtils.getRelativePath( workingDir, ServerSettings.tls_key_file ) );\n        withConfig( ServerSettings.tls_certificate_file,\n                        ServerTestUtils.getRelativePath( workingDir, ServerSettings.tls_certificate_file ) );\n        withConfig( connector( 0, enabled ), \"true\" );\n        withConfig( connector( 0, socket_address ), \"localhost:\" + Integer.toString( freePort( 7687, 10000 ) ) );\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup()\n    {\n        db = new GraphDatabaseFactory().newEmbeddedDatabase( testDirectory.graphDbDir() );\n    }","id":42940,"modified_method":"@Before\n    public void setup()\n    {\n        db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( testDirectory.graphDbDir() )\n                .setConfig( GraphDatabaseSettings.auth_store, testDirectory.file( \"auth\" ).getAbsolutePath() )\n                .newGraphDatabase();\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"private TestServerBuilder getServerBuilder( File targetFolder ) throws IOException\n    {\n        TestServerBuilder serverBuilder = newInProcessBuilder( targetFolder );\n        serverBuilder.withConfig( ServerSettings.tls_key_file.name(),\n                ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_key_file ) );\n        serverBuilder.withConfig( ServerSettings.tls_certificate_file.name(),\n                ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_certificate_file ) );\n        return serverBuilder;\n    }","id":42941,"modified_method":"private TestServerBuilder getServerBuilder( File targetFolder ) throws IOException\n    {\n        TestServerBuilder serverBuilder = newInProcessBuilder( targetFolder )\n                .withConfig( ServerSettings.tls_key_file.name(),\n                        ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_key_file ) )\n                .withConfig( ServerSettings.tls_certificate_file.name(),\n                        ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_certificate_file ) )\n                .withConfig( GraphDatabaseSettings.auth_store.name(),\n                        ServerTestUtils.getRelativePath( testDir.directory(), GraphDatabaseSettings.auth_store ) );\n        return serverBuilder;\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"private TestServerBuilder getTestServerBuilder( File workDir )\n    {\n        TestServerBuilder serverBuilder = newInProcessBuilder( workDir );\n        serverBuilder.withConfig( ServerSettings.tls_key_file.name(),\n                ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_key_file ) );\n        serverBuilder.withConfig( ServerSettings.tls_certificate_file.name(),\n                ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_certificate_file ) );\n        return serverBuilder;\n    }","id":42942,"modified_method":"private TestServerBuilder getTestServerBuilder( File workDir )\n    {\n        TestServerBuilder serverBuilder = newInProcessBuilder( workDir )\n                .withConfig( ServerSettings.tls_key_file.name(),\n                    ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_key_file ) )\n                .withConfig( ServerSettings.tls_certificate_file.name(),\n                    ServerTestUtils.getRelativePath( testDir.directory(), ServerSettings.tls_certificate_file ) )\n                .withConfig( GraphDatabaseSettings.auth_store.name(), new File(workDir, \"auth\").getAbsolutePath() );\n        return serverBuilder;\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args ) throws IOException\n\t{\n\t\tString path = args[0];\n\t\tfinal GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase(path );\n\t\tfinal Index<Node> index = getIndex( db );\n\t\tfinal String[] keys = new String[] { \"apoc\", \"zion\", \"morpheus\" };\n\t\tfinal String[] values = new String[] { \"hej\", \"yo\", \"something\", \"just a value\", \"anything\" };\n\t\t\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n\t\t\tnew Thread()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void run()\n\t\t\t\t{\n\t\t\t\t\twhile ( true )\n\t\t\t\t\t{\n\t\t\t\t\t\ttry ( Transaction tx = db.beginTx() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor ( int i = 0; i < 100; i++ )\n\t\t\t\t\t\t\t{\n                                String key = keys[i%keys.length];\n                                String value = values[i%values.length]+i;\n                                \n\t\t\t\t\t\t\t\tNode node = db.createNode();\n                                node.setProperty( key, value );\n\t\t\t\t\t\t\t\tindex.add( node, key, value );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttx.success();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}\n\t\tnew File( path, \"started\" ).createNewFile();\n\t}","id":42943,"modified_method":"public static void main( String[] args ) throws IOException\n    {\n        String path = args[0];\n        final GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( path )\n                .setConfig( GraphDatabaseSettings.auth_store, Files.createTempFile(\"auth\", \"\").toString() )\n                .newGraphDatabase();\n        final Index<Node> index = getIndex( db );\n        final String[] keys = new String[]{\"apoc\", \"zion\", \"morpheus\"};\n        final String[] values = new String[]{\"hej\", \"yo\", \"something\", \"just a value\", \"anything\"};\n\n        for ( int i = 0; i < 5; i++ )\n        {\n            new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    while ( true )\n                    {\n                        try ( Transaction tx = db.beginTx() )\n                        {\n                            for ( int i = 0; i < 100; i++ )\n                            {\n                                String key = keys[i % keys.length];\n                                String value = values[i % values.length] + i;\n\n                                Node node = db.createNode();\n                                node.setProperty( key, value );\n                                index.add( node, key, value );\n                            }\n                            tx.success();\n                        }\n                    }\n                }\n            }.start();\n        }\n        new File( path, \"started\" ).createNewFile();\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRuleWorkWithExsitingDirectory()\n    {\n        // given\n\n        GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( testDirectory.absolutePath() );\n        try {\n            db.execute( \"create ()\" );\n        }\n        finally\n        {\n            db.shutdown();\n        }\n\n        // When a rule with an pre-populated graph db directory is used\n        final Neo4jRule ruleWithDirectory = new Neo4jRule(testDirectory.directory()).copyFrom( testDirectory.directory());\n        ruleWithDirectory.apply( new Statement()\n        {\n            @Override\n            public void evaluate() throws Throwable\n            {\n                // Then the database is not empty\n                Result result = ruleWithDirectory.getGraphDatabaseService().execute( \"match (n) return count(n) as \" +\n                                                                                     \"count\" );\n\n                List<Object> column = IteratorUtil.asList( result.columnAs( \"count\" ) );\n                assertEquals( 1, column.size() );\n                assertEquals( 1, column.get( 0 ) );\n            }\n        }, null );\n    }","id":42944,"modified_method":"@Test\n    public void shouldRuleWorkWithExsitingDirectory()\n    {\n        // given\n\n        GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( testDirectory.directory() )\n                .setConfig( GraphDatabaseSettings.auth_store, ServerTestUtils\n                        .getRelativePath( testDirectory.directory(), GraphDatabaseSettings.auth_store ) )\n                .newGraphDatabase();\n        try {\n            db.execute( \"create ()\" );\n        }\n        finally\n        {\n            db.shutdown();\n        }\n\n        // When a rule with an pre-populated graph db directory is used\n        final Neo4jRule ruleWithDirectory = new Neo4jRule(testDirectory.directory()).copyFrom( testDirectory.directory());\n        ruleWithDirectory.apply( new Statement()\n        {\n            @Override\n            public void evaluate() throws Throwable\n            {\n                // Then the database is not empty\n                Result result = ruleWithDirectory.getGraphDatabaseService().execute( \"match (n) return count(n) as \" +\n                                                                                     \"count\" );\n\n                List<Object> column = IteratorUtil.asList( result.columnAs( \"count\" ) );\n                assertEquals( 1, column.size() );\n                assertEquals( 1, column.get( 0 ) );\n            }\n        }, null );\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void runTest( int nodeCount, int run, boolean multiThreaded ) throws Exception\n    {\n        if ( run > 0 )\n        {   // To only have the dedicated stress test run see this message\n            System.out.println( \"Run \" + run );\n        }\n\n        // WHEN creating the indexes under stressful updates\n        final GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( directory.absolutePath() )\n                .setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" )\n                .setConfig( GraphDatabaseSettings.multi_threaded_schema_index_population_enabled, multiThreaded + \"\" )\n                .newGraphDatabase();\n        createIndexes( db );\n        final AtomicBoolean end = new AtomicBoolean();\n        ExecutorService executor = cleanup.add( Executors.newCachedThreadPool() );\n        for ( int i = 0; i < 10; i++ )\n        {\n            executor.submit( () -> {\n                Randoms random = new Randoms();\n                while ( !end.get() )\n                {\n                    changeRandomNode( db, nodeCount, random );\n                }\n            });\n        }\n\n        while ( !indexesAreOnline( db ) )\n        {\n            Thread.sleep( 100 );\n        }\n        end.set( true );\n        executor.shutdown();\n        executor.awaitTermination( 10, SECONDS );\n\n        // THEN the db should be consistent in the end\n        db.shutdown();\n        ConsistencyCheckService cc = new ConsistencyCheckService();\n        Result result = cc.runFullConsistencyCheck( directory.directory(),\n                new Config( stringMap( GraphDatabaseSettings.pagecache_memory.name(), \"8m\" ) ),\n                NONE, NullLogProvider.getInstance(), false );\n        assertTrue( result.isSuccessful() );\n        dropIndexes();\n    }","id":42945,"modified_method":"private void runTest( int nodeCount, int run, boolean multiThreaded ) throws Exception\n    {\n        if ( run > 0 )\n        {   // To only have the dedicated stress test run see this message\n            System.out.println( \"Run \" + run );\n        }\n\n        // WHEN creating the indexes under stressful updates\n        final GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( directory.absolutePath() )\n                .setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" )\n                .setConfig( GraphDatabaseSettings.auth_store, directory.file( \"auth\" ).getAbsolutePath() )\n                .setConfig( GraphDatabaseSettings.multi_threaded_schema_index_population_enabled, multiThreaded + \"\" )\n                .newGraphDatabase();\n        createIndexes( db );\n        final AtomicBoolean end = new AtomicBoolean();\n        ExecutorService executor = cleanup.add( Executors.newCachedThreadPool() );\n        for ( int i = 0; i < 10; i++ )\n        {\n            executor.submit( () -> {\n                Randoms random = new Randoms();\n                while ( !end.get() )\n                {\n                    changeRandomNode( db, nodeCount, random );\n                }\n            });\n        }\n\n        while ( !indexesAreOnline( db ) )\n        {\n            Thread.sleep( 100 );\n        }\n        end.set( true );\n        executor.shutdown();\n        executor.awaitTermination( 10, SECONDS );\n\n        // THEN the db should be consistent in the end\n        db.shutdown();\n        ConsistencyCheckService cc = new ConsistencyCheckService();\n        Result result = cc.runFullConsistencyCheck( directory.directory(),\n                new Config( stringMap( GraphDatabaseSettings.pagecache_memory.name(), \"8m\" ) ),\n                NONE, NullLogProvider.getInstance(), false );\n        assertTrue( result.isSuccessful() );\n        dropIndexes();\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void dropIndexes()\n    {\n        GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( directory.absolutePath() )\n                .setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" )\n                .newGraphDatabase();\n        try ( Transaction tx = db.beginTx() )\n        {\n            for ( IndexDefinition index : db.schema().getIndexes() )\n            {\n                index.drop();\n            }\n            tx.success();\n        }\n        finally\n        {\n            db.shutdown();\n        }\n    }","id":42946,"modified_method":"private void dropIndexes()\n    {\n        GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( directory.absolutePath() )\n                .setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" )\n                .setConfig( GraphDatabaseSettings.auth_store, directory.file( \"auth\" ).getAbsolutePath() )\n                .newGraphDatabase();\n        try ( Transaction tx = db.beginTx() )\n        {\n            for ( IndexDefinition index : db.schema().getIndexes() )\n            {\n                index.drop();\n            }\n            tx.success();\n        }\n        finally\n        {\n            db.shutdown();\n        }\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"private GraphDatabaseService newEmbeddedGraphDatabaseWithSlowJobScheduler()\n    {\n        GraphDatabaseFactoryState graphDatabaseFactoryState = new GraphDatabaseFactoryState();\n        graphDatabaseFactoryState.setUserLogProvider( NullLogService.getInstance().getUserLogProvider() );\n        return new CommunityFacadeFactory()\n        {\n            @Override\n            protected PlatformModule createPlatform( File storeDir, Map<String, String> params, Dependencies dependencies, GraphDatabaseFacade graphDatabaseFacade )\n            {\n                return new PlatformModule( storeDir, params, databaseInfo(), dependencies, graphDatabaseFacade )\n                {\n                    @Override\n                    protected Neo4jJobScheduler createJobScheduler()\n                    {\n                        return newSlowJobScheduler();\n                    }\n\n                    @Override\n                    protected LogService createLogService( LogProvider userLogProvider )\n                    {\n                        return NullLogService.getInstance();\n                    }\n                };\n            }\n        }.newFacade( directory.graphDbDir(), stringMap(),\n                graphDatabaseFactoryState.databaseDependencies() );\n    }","id":42947,"modified_method":"private GraphDatabaseService newEmbeddedGraphDatabaseWithSlowJobScheduler()\n    {\n        GraphDatabaseFactoryState graphDatabaseFactoryState = new GraphDatabaseFactoryState();\n        graphDatabaseFactoryState.setUserLogProvider( NullLogService.getInstance().getUserLogProvider() );\n        return new CommunityFacadeFactory()\n        {\n            @Override\n            protected PlatformModule createPlatform( File storeDir, Map<String, String> params, Dependencies dependencies, GraphDatabaseFacade graphDatabaseFacade )\n            {\n                return new PlatformModule( storeDir, params, databaseInfo(), dependencies, graphDatabaseFacade )\n                {\n                    @Override\n                    protected Neo4jJobScheduler createJobScheduler()\n                    {\n                        return newSlowJobScheduler();\n                    }\n\n                    @Override\n                    protected LogService createLogService( LogProvider userLogProvider )\n                    {\n                        return NullLogService.getInstance();\n                    }\n                };\n            }\n        }.newFacade( directory.graphDbDir(), stringMap( GraphDatabaseSettings.auth_store.name(),\n                directory.file( \"auth\" ).getAbsolutePath()),\n                graphDatabaseFactoryState.databaseDependencies() );\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args ) throws Exception\n    {\n        String storeDir = args[0];\n        boolean setGraphProperty = args.length > 1 ? Boolean.parseBoolean( args[1] ) : false;\n        GraphDatabaseService db = new EmbeddedGraphDatabase(\n                storeDir,\n                stringMap(),\n                GraphDatabaseDependencies.newDependencies().userLogProvider( NullLogProvider.getInstance() ) );\n        try ( Transaction tx = db.beginTx() )\n        {\n            Node node = db.createNode();\n            node.setProperty( \"name\", \"Something\" );\n            if ( setGraphProperty )\n            {\n                //noinspection deprecation\n                ((GraphDatabaseAPI) db).getDependencyResolver().resolveDependency( NodeManager.class )\n                        .newGraphProperties().setProperty( \"prop\", \"Some value\" );\n            }\n            tx.success();\n        }\n        System.exit( 0 );\n    }","id":42948,"modified_method":"public static void main( String[] args ) throws Exception\n    {\n        String storeDir = args[0];\n        boolean setGraphProperty = args.length > 1 ? Boolean.parseBoolean( args[1] ) : false;\n        GraphDatabaseService db = new EmbeddedGraphDatabase(\n                storeDir,\n                stringMap( GraphDatabaseSettings.auth_store.name(), new File(storeDir, \"auth\").getAbsolutePath()),\n                GraphDatabaseDependencies.newDependencies().userLogProvider( NullLogProvider.getInstance() ) );\n        try ( Transaction tx = db.beginTx() )\n        {\n            Node node = db.createNode();\n            node.setProperty( \"name\", \"Something\" );\n            if ( setGraphProperty )\n            {\n                //noinspection deprecation\n                ((GraphDatabaseAPI) db).getDependencyResolver().resolveDependency( NodeManager.class )\n                        .newGraphProperties().setProperty( \"prop\", \"Some value\" );\n            }\n            tx.success();\n        }\n        System.exit( 0 );\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReadNodeWrittenInPreviousTransaction() throws Throwable\n    {\n        File dbDir = temporaryFolder.newFolder();\n        GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( dbDir )\n                .setConfig( GraphDatabaseSettings.pagecache_memory, \"2000M\" )\n                .setConfig( GraphDatabaseSettings.logical_log_rotation_threshold, \"500M\" )\n                .newGraphDatabase();\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().constraintFor( LABEL ).assertPropertyIsUnique( PROPERTY_KEY ).create();\n            tx.success();\n        }\n\n        int threadTxCount = TX_COUNT / THREAD_COUNT;\n        int startOfRange;\n        int endOfRange = -1;\n        CountDownLatch startSignal = new CountDownLatch( 1 );\n        CountDownLatch finishSignal = new CountDownLatch( THREAD_COUNT );\n        AtomicBoolean failed = new AtomicBoolean( false );\n        AtomicLong txs = new AtomicLong( 0 );\n        for ( int i = 0; i < THREAD_COUNT; i++ )\n        {\n            startOfRange = 1 + endOfRange;\n            endOfRange = startOfRange + threadTxCount - 1;\n            System.out.println( format( \"Thread=%s, Txs=%s, %s -> %s\",\n                    COUNT_FORMAT.format( i ),\n                    COUNT_FORMAT.format( threadTxCount ),\n                    COUNT_FORMAT.format( startOfRange ),\n                    COUNT_FORMAT.format( endOfRange ) ) );\n            new LostWritesThread(\n                    startOfRange,\n                    endOfRange,\n                    failed,\n                    LABEL,\n                    PROPERTY_KEY,\n                    db,\n                    startSignal,\n                    finishSignal,\n                    txs\n            ).start();\n        }\n\n        startSignal.countDown();\n        long startTime = System.currentTimeMillis();\n        long finishTime;\n        long prevTxs = 0;\n        while ( !finishSignal.await( 2, TimeUnit.SECONDS ) )\n        {\n            long currTxs = txs.get();\n            finishTime = System.currentTimeMillis();\n            printProgress( currTxs, prevTxs, startTime, finishTime );\n            assertThat( failed.get(), is( false ) );\n            prevTxs = currTxs;\n            startTime = System.currentTimeMillis();\n        }\n        printProgress( txs.get(), prevTxs, startTime, System.currentTimeMillis() );\n        assertThat( failed.get(), is( false ) );\n        db.shutdown();\n    }","id":42949,"modified_method":"@Test\n    public void shouldReadNodeWrittenInPreviousTransaction() throws Throwable\n    {\n        File dbDir = temporaryFolder.newFolder();\n        GraphDatabaseService db = new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( dbDir )\n                .setConfig( GraphDatabaseSettings.pagecache_memory, \"2000M\" )\n                .setConfig( GraphDatabaseSettings.auth_store, temporaryFolder.newFile().getAbsolutePath() )\n                .setConfig( GraphDatabaseSettings.logical_log_rotation_threshold, \"500M\" )\n                .newGraphDatabase();\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.schema().constraintFor( LABEL ).assertPropertyIsUnique( PROPERTY_KEY ).create();\n            tx.success();\n        }\n\n        int threadTxCount = TX_COUNT / THREAD_COUNT;\n        int startOfRange;\n        int endOfRange = -1;\n        CountDownLatch startSignal = new CountDownLatch( 1 );\n        CountDownLatch finishSignal = new CountDownLatch( THREAD_COUNT );\n        AtomicBoolean failed = new AtomicBoolean( false );\n        AtomicLong txs = new AtomicLong( 0 );\n        for ( int i = 0; i < THREAD_COUNT; i++ )\n        {\n            startOfRange = 1 + endOfRange;\n            endOfRange = startOfRange + threadTxCount - 1;\n            System.out.println( format( \"Thread=%s, Txs=%s, %s -> %s\",\n                    COUNT_FORMAT.format( i ),\n                    COUNT_FORMAT.format( threadTxCount ),\n                    COUNT_FORMAT.format( startOfRange ),\n                    COUNT_FORMAT.format( endOfRange ) ) );\n            new LostWritesThread(\n                    startOfRange,\n                    endOfRange,\n                    failed,\n                    LABEL,\n                    PROPERTY_KEY,\n                    db,\n                    startSignal,\n                    finishSignal,\n                    txs\n            ).start();\n        }\n\n        startSignal.countDown();\n        long startTime = System.currentTimeMillis();\n        long finishTime;\n        long prevTxs = 0;\n        while ( !finishSignal.await( 2, TimeUnit.SECONDS ) )\n        {\n            long currTxs = txs.get();\n            finishTime = System.currentTimeMillis();\n            printProgress( currTxs, prevTxs, startTime, finishTime );\n            assertThat( failed.get(), is( false ) );\n            prevTxs = currTxs;\n            startTime = System.currentTimeMillis();\n        }\n        printProgress( txs.get(), prevTxs, startTime, System.currentTimeMillis() );\n        assertThat( failed.get(), is( false ) );\n        db.shutdown();\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static GraphDatabaseService graphdb( String path )\n    {\n        return new GraphDatabaseFactory().newEmbeddedDatabase( path );\n    }","id":42950,"modified_method":"private static GraphDatabaseService graphdb( String path )\n    {\n        return new GraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( path )\n                .setConfig( GraphDatabaseSettings.auth_store, new File(path, \"auth\").getAbsolutePath() )\n                .newGraphDatabase();\n    }","commit_id":"201ca5091300b8e0bd1f06045a3616dd830bc1fe","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void sawOpcode(int seen) {\n\t\tif (seen == INVOKEINTERFACE || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKESTATIC) {\n\t\t\tString signature = getSigConstantOperand();\n\n\t\t\tint numberArguments = PreorderVisitor.getNumberArguments(signature);\n\n\t\t\tfor (int i = 0; i < numberArguments; i++) {\n\t\t\t\tItem item = stack.getStackItem(numberArguments - 1 - i);\n\t\t\t\tif (item.getSpecialKind() == OpcodeStack.Item.RESULT_OF_I2L) {\n\t\t\t\t\tParameterProperty property = database.getProperty(getMethodDescriptorOperand());\n\t\t\t\t\tif (property.hasProperty(i)) {\n\t\t\t\t\t\tBugInstance bug = new BugInstance(this, \"ICAST_INT_2_LONG_AS_INSTANT\", HIGH_PRIORITY).addClassAndMethod(this)\n\t\t\t\t\t\t        .addCalledMethod(this).addValueSource(item, this).addSourceLine(this);\n\t\t\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","id":42951,"modified_method":"public void sawOpcode(int seen) {\n\t\tif (seen == INVOKEINTERFACE || seen == INVOKEVIRTUAL || seen == INVOKESPECIAL || seen == INVOKESTATIC) {\n\t\t\tString signature = getSigConstantOperand();\n\n\t\t\tint numberArguments = PreorderVisitor.getNumberArguments(signature);\n\n\t\t\tfor (int i = 0; i < numberArguments; i++) {\n\t\t\t\tItem item = stack.getStackItem(numberArguments - 1 - i);\n\t\t\t\tif (item.getSpecialKind() == OpcodeStack.Item.RESULT_OF_I2L) {\n\t\t\t\t\tParameterProperty property = database.getProperty(getMethodDescriptorOperand());\n\t\t\t\t\tif (property != null && property.hasProperty(i)) {\n\t\t\t\t\t\tBugInstance bug = new BugInstance(this, \"ICAST_INT_2_LONG_AS_INSTANT\", HIGH_PRIORITY).addClassAndMethod(this)\n\t\t\t\t\t\t        .addCalledMethod(this).addValueSource(item, this).addSourceLine(this);\n\t\t\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"6ef7b0fad7327129ae861bce49239a9f7d2b133b","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"protected void setContentLength(final Property property) throws RepositoryException {\n        if (property.isMultiple()) {\n            return;\n        }\n\n        try {\n            final long length;\n            if (property.getType() == PropertyType.BINARY ) {\n                // we're interested in the number of bytes, not the\n                // number of characters\n                length = property.getLength();\n            } else {\n                length = property.getString().getBytes(\"UTF-8\").length;\n            }\n            getResourceMetadata().setContentLength(length);\n        } catch (UnsupportedEncodingException uee) {\n            LOGGER.warn(\"getPropertyContentLength: Cannot determine length of non-binary property {}: {}\",\n                    toString(), uee);\n        }\n    }","id":42952,"modified_method":"public static long getContentLength(final Property property) throws RepositoryException {\n        if (property.isMultiple()) {\n            return -1;\n        }\n\n        try {\n            long length = -1;\n            if (property.getType() == PropertyType.BINARY ) {\n                // we're interested in the number of bytes, not the\n                // number of characters\n                try {\n                    length =  property.getLength();\n                } catch (final ValueFormatException vfe) {\n                    LOGGER.debug(\n                        \"Length of Property {} cannot be retrieved, ignored ({})\",\n                        property.getPath(), vfe);\n                }\n            } else {\n                length = property.getString().getBytes(\"UTF-8\").length;\n            }\n            return length;\n        } catch (UnsupportedEncodingException uee) {\n            LOGGER.warn(\"getPropertyContentLength: Cannot determine length of non-binary property {}: {}\",\n                    property, uee);\n        }\n        return -1;\n    }","commit_id":"6870e8dd354e1101e94fe561278a9a4ef1615aaa","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns a stream to the <em>jcr:data<\/em> property if the\n     * {@link #getNode() node} is an <em>nt:file<\/em> or <em>nt:resource<\/em>\n     * node. Otherwise returns <code>null<\/code>. If a valid stream can be\n     * returned, this method also sets the content length resource metadata.\n     */\n    private InputStream getInputStream() {\n        // implement this for nt:file only\n        if (node != null) {\n            try {\n                // find the content node: for nt:file it is jcr:content\n                // otherwise it is the node of this resource\n                Node content = node.isNodeType(NT_FILE)\n                        ? node.getNode(JCR_CONTENT)\n                        : node;\n\n                Property data;\n\n                // if the node has a jcr:data property, use that property\n                if (content.hasProperty(JCR_DATA)) {\n                    data = content.getProperty(JCR_DATA);\n                } else {\n                    // otherwise try to follow default item trail\n                    try {\n                        Item item = content.getPrimaryItem();\n                        while (item.isNode()) {\n                            item = ((Node) item).getPrimaryItem();\n                        }\n                        data = ((Property) item);\n\n                        // set the content length property as a side effect\n                        // for resources which are not nt:file based and whose\n                        // data is not in jcr:content/jcr:data this will lazily\n                        // set the correct content length\n                        this.setContentLength(data);\n\n                    } catch (ItemNotFoundException infe) {\n                        // we don't actually care, but log for completeness\n                        LOGGER.debug(\"getInputStream: No primary items for {}\", toString(), infe);\n                        data = null;\n                    }\n                }\n\n                if (data != null) {\n                    return data.getBinary().getStream();\n                }\n\n            } catch (RepositoryException re) {\n                LOGGER.error(\"getInputStream: Cannot get InputStream for \" + this,\n                    re);\n            }\n        }\n\n        // fallback to non-streamable resource\n        return null;\n    }","id":42953,"modified_method":"/**\n     * Returns a stream to the <em>jcr:data<\/em> property if the\n     * {@link #getNode() node} is an <em>nt:file<\/em> or <em>nt:resource<\/em>\n     * node. Otherwise returns <code>null<\/code>.\n     */\n    private InputStream getInputStream() {\n        // implement this for nt:file only\n        if (node != null) {\n            try {\n                // find the content node: for nt:file it is jcr:content\n                // otherwise it is the node of this resource\n                Node content = node.isNodeType(NT_FILE)\n                        ? node.getNode(JCR_CONTENT)\n                        : node;\n\n                Property data;\n\n                // if the node has a jcr:data property, use that property\n                if (content.hasProperty(JCR_DATA)) {\n                    data = content.getProperty(JCR_DATA);\n                } else {\n                    // otherwise try to follow default item trail\n                    try {\n                        Item item = content.getPrimaryItem();\n                        while (item.isNode()) {\n                            item = ((Node) item).getPrimaryItem();\n                        }\n                        data = (Property) item;\n\n                    } catch (ItemNotFoundException infe) {\n                        // we don't actually care, but log for completeness\n                        LOGGER.debug(\"getInputStream: No primary items for {}\", toString(), infe);\n                        data = null;\n                    }\n                }\n\n                if (data != null) {\n                    return data.getBinary().getStream();\n                }\n\n            } catch (RepositoryException re) {\n                LOGGER.error(\"getInputStream: Cannot get InputStream for \" + this,\n                    re);\n            }\n        }\n\n        // fallback to non-streamable resource\n        return null;\n    }","commit_id":"6870e8dd354e1101e94fe561278a9a4ef1615aaa","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public Object get(final Object key) {\n        final Object result = super.get(key);\n        if (result != null) {\n            return result;\n        }\n\n        if (CREATION_TIME.equals(key)) {\n            promoteNode();\n            internalPut(CREATION_TIME, creationTime);\n            return creationTime;\n        } else if (CONTENT_TYPE.equals(key)) {\n            if (contentType == null) {\n                promoteNode();\n                try {\n                    if (getTargetNode().hasProperty(JCR_MIMETYPE)) {\n                        contentType = getTargetNode().getProperty(JCR_MIMETYPE).getString();\n                    }\n                } catch (RepositoryException re) {\n                    report(re);\n                }\n\n                internalPut(CONTENT_TYPE, contentType);\n            }\n            return contentType;\n        } else if (CHARACTER_ENCODING.equals(key)) {\n            if (characterEncoding == null) {\n                promoteNode();\n                try {\n                    if (getTargetNode().hasProperty(JCR_ENCODING)) {\n                        characterEncoding = getTargetNode().getProperty(JCR_ENCODING).getString();\n                    }\n                } catch (RepositoryException re) {\n                    report(re);\n                }\n                internalPut(CHARACTER_ENCODING, characterEncoding);\n            }\n            return characterEncoding;\n        } else if (MODIFICATION_TIME.equals(key)) {\n            if (modificationTime == -1) {\n                promoteNode();\n                try {\n                    if (getTargetNode().hasProperty(JCR_LASTMODIFIED)) {\n                        // We don't check node type, so JCR_LASTMODIFIED might not be a long\n                        final Property prop = getTargetNode().getProperty(JCR_LASTMODIFIED);\n                        try {\n                            modificationTime = prop.getLong();\n                        } catch(ValueFormatException vfe) {\n                            LOGGER.debug(\"Property {} cannot be converted to a long, ignored ({})\",\n                                prop.getPath(), vfe);\n                        }\n                    }\n                } catch (final RepositoryException re) {\n                    report(re);\n                }\n                internalPut(MODIFICATION_TIME, modificationTime);\n            }\n            return modificationTime;\n        } else if (CONTENT_LENGTH.equals(key)) {\n            if (contentLength == -1) {\n                promoteNode();\n                try {\n                    if (getTargetNode().hasProperty(JCR_DATA)) {\n                        final Property prop = getTargetNode().getProperty(JCR_DATA);\n                        try {\n                            contentLength = prop.getLength();\n                        } catch (ValueFormatException vfe) {\n                            LOGGER.debug(\n                                \"Length of Property {} cannot be retrieved, ignored ({})\",\n                                prop.getPath(), vfe);\n                        }\n                    }\n                } catch (final RepositoryException re) {\n                    report(re);\n                }\n                internalPut(CONTENT_LENGTH, contentLength);\n            }\n            return contentLength;\n        }\n        return null;\n    }","id":42954,"modified_method":"@Override\n    public Object get(final Object key) {\n        final Object result = super.get(key);\n        if (result != null) {\n            return result;\n        }\n\n        if (CREATION_TIME.equals(key)) {\n            promoteNode();\n            internalPut(CREATION_TIME, creationTime);\n            return creationTime;\n        } else if (CONTENT_TYPE.equals(key)) {\n            if (contentType == null) {\n                final Node targetNode = promoteNode();\n                try {\n                    if (targetNode.hasProperty(JCR_MIMETYPE)) {\n                        contentType = targetNode.getProperty(JCR_MIMETYPE).getString();\n                    }\n                } catch (final RepositoryException re) {\n                    report(re);\n                }\n\n                internalPut(CONTENT_TYPE, contentType);\n            }\n            return contentType;\n        } else if (CHARACTER_ENCODING.equals(key)) {\n            if (characterEncoding == null) {\n                final Node targetNode = promoteNode();\n                try {\n                    if (targetNode.hasProperty(JCR_ENCODING)) {\n                        characterEncoding = targetNode.getProperty(JCR_ENCODING).getString();\n                    }\n                } catch (final RepositoryException re) {\n                    report(re);\n                }\n                internalPut(CHARACTER_ENCODING, characterEncoding);\n            }\n            return characterEncoding;\n        } else if (MODIFICATION_TIME.equals(key)) {\n            if (modificationTime == -1) {\n                final Node targetNode = promoteNode();\n                try {\n                    if (targetNode.hasProperty(JCR_LASTMODIFIED)) {\n                        // We don't check node type, so JCR_LASTMODIFIED might not be a long\n                        final Property prop = targetNode.getProperty(JCR_LASTMODIFIED);\n                        try {\n                            modificationTime = prop.getLong();\n                        } catch (final ValueFormatException vfe) {\n                            LOGGER.debug(\"Property {} cannot be converted to a long, ignored ({})\",\n                                prop.getPath(), vfe);\n                        }\n                    }\n                } catch (final RepositoryException re) {\n                    report(re);\n                }\n                internalPut(MODIFICATION_TIME, modificationTime);\n            }\n            return modificationTime;\n        } else if (CONTENT_LENGTH.equals(key)) {\n            if (contentLength == -1) {\n                final Node targetNode = promoteNode();\n                try {\n                    // if the node has a jcr:data property, use that property\n                    if (targetNode.hasProperty(JCR_DATA)) {\n                        final Property prop = targetNode.getProperty(JCR_DATA);\n                        contentLength = JcrItemResource.getContentLength(prop);\n                    } else {\n                        // otherwise try to follow default item trail\n                        Item item = targetNode.getPrimaryItem();\n                        while (item.isNode()) {\n                            item = ((Node) item).getPrimaryItem();\n                        }\n                        final Property data = (Property) item;\n\n                        // set the content length property as a side effect\n                        // for resources which are not nt:file based and whose\n                        // data is not in jcr:content/jcr:data this will lazily\n                        // set the correct content length\n                        contentLength = JcrItemResource.getContentLength(data);\n                    }\n                } catch (final RepositoryException re) {\n                    report(re);\n                }\n                internalPut(CONTENT_LENGTH, contentLength);\n            }\n            return contentLength;\n        }\n        return null;\n    }","commit_id":"6870e8dd354e1101e94fe561278a9a4ef1615aaa","url":"https://github.com/apache/sling"},{"original_method":"private void report(final RepositoryException re) {\n        String nodePath = \"<unknown node path>\";\n        try {\n            nodePath = getTargetNode().getPath();\n        } catch (RepositoryException e) {\n            // ignore\n        }\n        LOGGER.info(\n            \"setMetaData: Problem extracting metadata information for \"\n                    + nodePath, re);\n    }","id":42955,"modified_method":"private void report(final RepositoryException re) {\n        String nodePath = \"<unknown node path>\";\n        try {\n            nodePath = contentNode != null ? contentNode.getPath() : node.getPath();\n        } catch (RepositoryException e) {\n            // ignore\n        }\n        LOGGER.info(\n            \"setMetaData: Problem extracting metadata information for \"\n                    + nodePath, re);\n    }","commit_id":"6870e8dd354e1101e94fe561278a9a4ef1615aaa","url":"https://github.com/apache/sling"},{"original_method":"private void promoteNode() {\n        // check stuff for nt:file nodes\n        try {\n            if ( (!nodePromotionChecked) && node.isNodeType(NT_FILE)) {\n                creationTime = node.getProperty(JCR_CREATED).getLong();\n\n                // continue our stuff with the jcr:content node\n                // which might be nt:resource, which we support below\n                // if the node is new, the content node might not exist yet\n                if (!node.isNew() || node.hasNode(JCR_CONTENT) ) {\n                    contentNode = node.getNode(JCR_CONTENT);\n                }\n                nodePromotionChecked = true;\n            }\n        } catch (final RepositoryException re) {\n            report(re);\n        }\n\n    }","id":42956,"modified_method":"private Node promoteNode() {\n        // check stuff for nt:file nodes\n        try {\n            if ( (!nodePromotionChecked) && node.isNodeType(NT_FILE)) {\n                creationTime = node.getProperty(JCR_CREATED).getLong();\n\n                // continue our stuff with the jcr:content node\n                // which might be nt:resource, which we support below\n                // if the node is new, the content node might not exist yet\n                if (!node.isNew() || node.hasNode(JCR_CONTENT) ) {\n                    contentNode = node.getNode(JCR_CONTENT);\n                }\n                nodePromotionChecked = true;\n            }\n        } catch (final RepositoryException re) {\n            report(re);\n        }\n        return contentNode != null ? contentNode : node;\n    }","commit_id":"6870e8dd354e1101e94fe561278a9a4ef1615aaa","url":"https://github.com/apache/sling"},{"original_method":"public JcrPropertyResource(final ResourceResolver resourceResolver,\n                               final String path,\n                               final Property property)\n    throws RepositoryException {\n        super(resourceResolver, path, new ResourceMetadata());\n        this.property = property;\n        this.resourceType = getResourceTypeForNode(property.getParent())\n                + \"/\" + property.getName();\n        if (PropertyType.BINARY != this.property.getType()) {\n            this.getResourceMetadata().setContentType(\"text/plain\");\n            this.getResourceMetadata().setCharacterEncoding(\"UTF-8\");\n        }\n\n        this.setContentLength(property);\n    }","id":42957,"modified_method":"public JcrPropertyResource(final ResourceResolver resourceResolver,\n                               final String path,\n                               final Property property)\n    throws RepositoryException {\n        super(resourceResolver, path, new ResourceMetadata());\n        this.property = property;\n        this.resourceType = getResourceTypeForNode(property.getParent())\n                + \"/\" + property.getName();\n        if (PropertyType.BINARY != this.property.getType()) {\n            this.getResourceMetadata().setContentType(\"text/plain\");\n            this.getResourceMetadata().setCharacterEncoding(\"UTF-8\");\n        }\n\n        this.getResourceMetadata().setContentLength(getContentLength(property));\n    }","commit_id":"6870e8dd354e1101e94fe561278a9a4ef1615aaa","url":"https://github.com/apache/sling"},{"original_method":"public UserProviderImpl(ContentSession contentSession, Root root, UserManagerConfig config) {\n        this.contentSession = contentSession;\n        this.root = root;\n        this.identifierManager = new IdentifierManager(contentSession, root);\n\n        defaultDepth = config.getConfigValue(UserManagerConfig.PARAM_DEFAULT_DEPTH, DEFAULT_DEPTH);\n        int splitValue = config.getConfigValue(UserManagerConfig.PARAM_GROUP_MEMBERSHIP_SPLIT_SIZE, 0);\n        if (splitValue < 4) {\n            log.warn(\"Invalid value {} for {}. Expected integer >= 4\", splitValue, UserManagerConfig.PARAM_GROUP_MEMBERSHIP_SPLIT_SIZE);\n            splitValue = 0;\n        }\n        this.splitSize = splitValue;\n        this.adminId = config.getAdminId();\n\n        groupPath = config.getConfigValue(UserManagerConfig.PARAM_GROUP_PATH, DEFAULT_GROUP_PATH);\n        userPath = config.getConfigValue(UserManagerConfig.PARAM_USER_PATH, DEFAULT_USER_PATH);\n    }","id":42958,"modified_method":"public UserProviderImpl(ContentSession contentSession, Root root, UserManagerConfig config) {\n        this.contentSession = contentSession;\n        this.root = root;\n        this.identifierManager = new IdentifierManager(contentSession, root);\n\n        defaultDepth = config.getConfigValue(UserManagerConfig.PARAM_DEFAULT_DEPTH, DEFAULT_DEPTH);\n        int splitValue = config.getConfigValue(UserManagerConfig.PARAM_GROUP_MEMBERSHIP_SPLIT_SIZE, 4);\n        if (splitValue < 4) {\n            log.warn(\"Invalid value {} for {}. Expected integer >= 4\", splitValue, UserManagerConfig.PARAM_GROUP_MEMBERSHIP_SPLIT_SIZE);\n            splitValue = 0;\n        }\n        this.splitSize = splitValue;\n        this.adminId = config.getAdminId();\n\n        groupPath = config.getConfigValue(UserManagerConfig.PARAM_GROUP_PATH, DEFAULT_GROUP_PATH);\n        userPath = config.getConfigValue(UserManagerConfig.PARAM_USER_PATH, DEFAULT_USER_PATH);\n    }","commit_id":"1f8ec89b002120d03a29fa296d4da73f8471aece","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Create folder structure for the authorizable to be created. The structure\n     * consists of a tree of rep:AuthorizableFolder node(s) starting at the\n     * configured user or group path. Note that Authorizable nodes are never\n     * nested.\n     *\n     * @param authorizableId\n     * @param nodeName\n     * @param isGroup\n     * @param intermediatePath\n     * @return The folder node.\n     * @throws RepositoryException If an error occurs\n     */\n    private NodeUtil createFolderNodes(String authorizableId, String nodeName,\n                                   boolean isGroup, String intermediatePath) throws RepositoryException {\n        String authRoot = (isGroup) ? groupPath : userPath;\n        NodeUtil folder;\n        Tree authTree = root.getTree(authRoot);\n        if (authTree == null) {\n            folder = new NodeUtil(root.getTree(\"\"), contentSession);\n            for (String name : Text.explode(authRoot, '/', false)) {\n                folder = folder.getOrAddChild(name, NT_REP_AUTHORIZABLE_FOLDER);\n            }\n        }  else {\n            folder = new NodeUtil(authTree, contentSession);\n        }\n        String folderPath = getFolderPath(authorizableId, intermediatePath);\n        String[] segmts = Text.explode(folderPath, '/', false);\n        for (String segment : segmts) {\n            folder = folder.getOrAddChild(segment, NT_REP_AUTHORIZABLE_FOLDER);\n            // TODO: remove check once UserValidator is active\n            if (!folder.hasPrimaryNodeTypeName(NT_REP_AUTHORIZABLE_FOLDER)) {\n                String msg = \"Cannot create user/group: Intermediate folders must be of type rep:AuthorizableFolder.\";\n                throw new ConstraintViolationException(msg);\n            }\n        }\n\n        // test for colliding folder child node.\n        while (folder.hasChild(nodeName)) {\n            NodeUtil colliding = folder.getChild(nodeName);\n            // TODO: remove check once UserValidator is active\n            if (colliding.hasPrimaryNodeTypeName(NT_REP_AUTHORIZABLE_FOLDER)) {\n                log.debug(\"Existing folder node collides with user/group to be created. Expanding path by: \" + colliding.getName());\n                folder = colliding;\n            } else {\n                String msg = \"Failed to create authorizable with id '\" + authorizableId + \"' : \" +\n                        \"Detected conflicting node of unexpected node type '\" + colliding.getString(JcrConstants.JCR_PRIMARYTYPE, null) + \"'.\";\n                log.error(msg);\n                throw new ConstraintViolationException(msg);\n            }\n        }\n\n        // TODO: remove check once UserValidator is active\n        if (!Text.isDescendantOrEqual(authRoot, folder.getTree().getPath())) {\n            throw new ConstraintViolationException(\"Attempt to create user/group outside of configured scope \" + authRoot);\n        }\n        return folder;\n    }","id":42959,"modified_method":"/**\n     * Create folder structure for the authorizable to be created. The structure\n     * consists of a tree of rep:AuthorizableFolder node(s) starting at the\n     * configured user or group path. Note that Authorizable nodes are never\n     * nested.\n     *\n     * @param authorizableId\n     * @param nodeName\n     * @param isGroup\n     * @param intermediatePath\n     * @return The folder node.\n     * @throws RepositoryException If an error occurs\n     */\n    private NodeUtil createFolderNodes(String authorizableId, String nodeName,\n                                   boolean isGroup, String intermediatePath) throws RepositoryException {\n        String authRoot = (isGroup) ? groupPath : userPath;\n        NodeUtil folder;\n        Tree authTree = root.getTree(authRoot);\n        if (authTree == null) {\n            folder = new NodeUtil(root.getTree(\"/\"), contentSession);\n            for (String name : Text.explode(authRoot, '/', false)) {\n                folder = folder.getOrAddChild(name, NT_REP_AUTHORIZABLE_FOLDER);\n            }\n        }  else {\n            folder = new NodeUtil(authTree, contentSession);\n        }\n        String folderPath = getFolderPath(authorizableId, intermediatePath);\n        String[] segmts = Text.explode(folderPath, '/', false);\n        for (String segment : segmts) {\n            folder = folder.getOrAddChild(segment, NT_REP_AUTHORIZABLE_FOLDER);\n            // TODO: remove check once UserValidator is active\n            if (!folder.hasPrimaryNodeTypeName(NT_REP_AUTHORIZABLE_FOLDER)) {\n                String msg = \"Cannot create user/group: Intermediate folders must be of type rep:AuthorizableFolder.\";\n                throw new ConstraintViolationException(msg);\n            }\n        }\n\n        // test for colliding folder child node.\n        while (folder.hasChild(nodeName)) {\n            NodeUtil colliding = folder.getChild(nodeName);\n            // TODO: remove check once UserValidator is active\n            if (colliding.hasPrimaryNodeTypeName(NT_REP_AUTHORIZABLE_FOLDER)) {\n                log.debug(\"Existing folder node collides with user/group to be created. Expanding path by: \" + colliding.getName());\n                folder = colliding;\n            } else {\n                String msg = \"Failed to create authorizable with id '\" + authorizableId + \"' : \" +\n                        \"Detected conflicting node of unexpected node type '\" + colliding.getString(JcrConstants.JCR_PRIMARYTYPE, null) + \"'.\";\n                log.error(msg);\n                throw new ConstraintViolationException(msg);\n            }\n        }\n\n        // TODO: remove check once UserValidator is active\n        if (!Text.isDescendantOrEqual(authRoot, folder.getTree().getPath())) {\n            throw new ConstraintViolationException(\"Attempt to create user/group outside of configured scope \" + authRoot);\n        }\n        return folder;\n    }","commit_id":"1f8ec89b002120d03a29fa296d4da73f8471aece","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean isAuthorizableTree(Tree tree, int type) {\n        // FIXME: check for node type according to the specified type constraint\n        if (tree.hasProperty(JcrConstants.JCR_PRIMARYTYPE)) {\n            String ntName = tree.getProperty(JcrConstants.JCR_PRIMARYTYPE).getValue().getString();\n            switch (type) {\n                case UserManager.SEARCH_TYPE_GROUP:\n                    return NT_REP_GROUP.equals(ntName);\n                case UserManager.SEARCH_TYPE_USER:\n                    return NT_REP_USER.equals(ntName);\n                default:\n                    return NT_REP_USER.equals(ntName) || NT_REP_GROUP.equals(ntName);\n            }\n        }\n        return false;\n    }","id":42960,"modified_method":"private boolean isAuthorizableTree(Tree tree, int type) {\n        // FIXME: check for node type according to the specified type constraint\n        if (tree != null && tree.hasProperty(JcrConstants.JCR_PRIMARYTYPE)) {\n            String ntName = tree.getProperty(JcrConstants.JCR_PRIMARYTYPE).getValue().getString();\n            switch (type) {\n                case UserManager.SEARCH_TYPE_GROUP:\n                    return NT_REP_GROUP.equals(ntName);\n                case UserManager.SEARCH_TYPE_USER:\n                    return NT_REP_USER.equals(ntName);\n                default:\n                    return NT_REP_USER.equals(ntName) || NT_REP_GROUP.equals(ntName);\n            }\n        }\n        return false;\n    }","commit_id":"1f8ec89b002120d03a29fa296d4da73f8471aece","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n  public SProperty getProperty(String name) {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return null;\n    }\n\n    return (d.hasProperty(name) ? (myConceptName==null?new SPropertyAdapter(myConceptId, name):new SPropertyAdapter(myConceptName, name)) : null);\n  }","id":42961,"modified_method":"@Override\n  @Deprecated\n  public SProperty getProperty(String name) {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return null;\n    }\n\n    if (myConceptName==null) {\n      SPropertyIdImpl pid = ((DebugRegistryImpl) MPSModuleRepository.getInstance().getDebugRegistry()).getPropertyId(myConceptId, name);\n      return (d.hasProperty(name) ? new SPropertyAdapter(pid) : null);\n    } else{\n      return (d.hasProperty(name) ? new SPropertyAdapter(myConceptName, name) : null);\n    }\n  }","commit_id":"da77c0eba9fd97f6b83d658085b0aaa04cfe4644","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Iterable<SProperty> getProperties() {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return Collections.emptyList();\n    }\n\n    return SetSequence.fromSet(((Set<String>) d.getPropertyNames())).select(new ISelector<String, SProperty>() {\n      public SProperty select(String it) {\n        return (SProperty) (myConceptName==null?new SPropertyAdapter(myConceptId, it):new SPropertyAdapter(myConceptName, it));\n      }\n    });\n  }","id":42962,"modified_method":"@Override\n  public Iterable<SProperty> getProperties() {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return Collections.emptyList();\n    }\n\n    return SetSequence.fromSet(((Set<String>) d.getPropertyNames())).select(new ISelector<String, SProperty>() {\n      public SProperty select(String it) {\n        if (myConceptName==null) {\n          SPropertyIdImpl id = ((DebugRegistryImpl) MPSModuleRepository.getInstance().getDebugRegistry()).getPropertyId(myConceptId, it);\n          return (SProperty) new SPropertyAdapter(id);\n        } else{\n          return (SProperty) (new SPropertyAdapter(myConceptName, it));\n        }\n      }\n    });\n  }","commit_id":"da77c0eba9fd97f6b83d658085b0aaa04cfe4644","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SAbstractLink getLink(String role) {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return null;\n    }\n\n    if (d.hasChild(role)) {\n      return myConceptName==null?new SContainmentLinkAdapter(myConceptId, role):new SContainmentLinkAdapter(myConceptName, role);\n    } else if (d.hasReference(role)) {\n      return myConceptName==null?new SReferenceLinkAdapter(myConceptId, role):new SReferenceLinkAdapter(myConceptName, role);\n    }\n    return null;\n  }","id":42963,"modified_method":"@Override\n  @Deprecated\n  public SAbstractLink getLink(String role) {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return null;\n    }\n\n    SAbstractLinkIdImpl id = ((DebugRegistryImpl) MPSModuleRepository.getInstance().getDebugRegistry()).getLinkId(myConceptId, role);\n    if (d.hasChild(role)) {\n      return myConceptName==null?new SContainmentLinkAdapter(id):new SContainmentLinkAdapter(myConceptName, role);\n    } else if (d.hasReference(role)) {\n      return myConceptName==null?new SReferenceLinkAdapter(id):new SReferenceLinkAdapter(myConceptName, role);\n    }\n    return null;\n  }","commit_id":"da77c0eba9fd97f6b83d658085b0aaa04cfe4644","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Iterable<SAbstractLink> getLinks() {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return Collections.emptyList();\n    }\n\n    Iterable<SAbstractLink> seq = SetSequence.fromSet(((Set<String>) d.getChildrenNames())).select(new ISelector<String, SAbstractLink>() {\n      public SAbstractLink select(String it) {\n        return (SAbstractLink) (myConceptName == null ? new SContainmentLinkAdapter(myConceptId, it) : new SContainmentLinkAdapter(myConceptName, it));\n      }\n    });\n    return Sequence.fromIterable(seq).concat(SetSequence.fromSet(((Set<String>) d.getReferenceNames())).select(new ISelector<String, SReferenceLinkAdapter>() {\n      public SReferenceLinkAdapter select(String it) {\n        return myConceptName==null?new SReferenceLinkAdapter(myConceptId, it):new SReferenceLinkAdapter(myConceptName, it);\n      }\n    }));\n  }","id":42964,"modified_method":"@Override\n  public Iterable<SAbstractLink> getLinks() {\n    ConceptDescriptor d = myConceptName==null?ConceptRegistry.getInstance().getConceptDescriptor(myConceptId):ConceptRegistry.getInstance().getConceptDescriptor(myConceptName);\n    if (d instanceof IllegalConceptDescriptor) {\n      illegalConceptDescriptorWarning();\n      return Collections.emptyList();\n    }\n\n    Iterable<SAbstractLink> seq = SetSequence.fromSet(((Set<String>) d.getChildrenNames())).select(new ISelector<String, SAbstractLink>() {\n      public SAbstractLink select(String it) {\n        if (myConceptName==null) {\n          SAbstractLinkIdImpl id = ((DebugRegistryImpl) MPSModuleRepository.getInstance().getDebugRegistry()).getLinkId(myConceptId, it);\n          return (SAbstractLink) new SContainmentLinkAdapter(id);\n        } else{\n          return (SAbstractLink) (new SContainmentLinkAdapter(myConceptName, it));\n        }\n      }\n    });\n    return Sequence.fromIterable(seq).concat(SetSequence.fromSet(((Set<String>) d.getReferenceNames())).select(new ISelector<String, SReferenceLinkAdapter>() {\n      public SReferenceLinkAdapter select(String it) {\n        if (myConceptName==null) {\n          SAbstractLinkIdImpl id = ((DebugRegistryImpl) MPSModuleRepository.getInstance().getDebugRegistry()).getLinkId(myConceptId, it);\n          return new SReferenceLinkAdapter(id);\n        } else{\n          return new SReferenceLinkAdapter(myConceptName, it);\n        }\n      }\n    }));\n  }","commit_id":"da77c0eba9fd97f6b83d658085b0aaa04cfe4644","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SAbstractLink getLink(String role) {\n    // TODO fix all usages remove this hack \n    if (SNodeUtil.link_BaseConcept_smodelAttribute.equals(role)) {\n      return new SContainmentLinkAdapter(SNodeUtil.concept_BaseConcept, role);\n    }\n    return super.getLink(role);\n  }","id":42965,"modified_method":"@Override\n  public SAbstractLink getLink(String role) {\n    // TODO fix all usages remove this hack \n    if (SNodeUtil.link_BaseConcept_smodelAttribute.equals(role)) {\n      SAbstractLinkIdImpl id = ((DebugRegistryImpl) MPSModuleRepository.getInstance().getDebugRegistry()).getLinkId(myConceptId, role);\n      return new SContainmentLinkAdapter(id);\n    }\n    return super.getLink(role);\n  }","commit_id":"da77c0eba9fd97f6b83d658085b0aaa04cfe4644","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test(timeout = 100000)\n    public void testKeyOwnerDies() throws Exception {\n        final StaticNodeFactory nodeFactory = new StaticNodeFactory(3);\n        final Config config = new Config();\n        final HazelcastInstance keyOwner = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(config);\n        int k = 0;\n        final AtomicInteger atomicInteger = new AtomicInteger(0);\n        while (instance1.getPartitionService().getPartition(k++).equals(keyOwner.getCluster().getLocalMember())) ;\n        final int key = k;\n\n        final ILock lock1 = instance1.getLock(key);\n        lock1.lock();\n\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                final ILock lock = instance2.getLock(key);\n                lock.lock();\n                atomicInteger.incrementAndGet();\n            }\n        });\n        t.start();\n\n        keyOwner.getLifecycleService().shutdown();\n        Assert.assertEquals(true, lock1.isLocked());\n        Assert.assertEquals(true, lock1.tryLock());\n        lock1.unlock();\n        lock1.unlock();\n        Thread.sleep(1000);\n\n        Assert.assertEquals(1, atomicInteger.get());\n        lock1.forceUnlock();\n\n    }","id":42966,"modified_method":"@Test(timeout = 100000)\n    public void testKeyOwnerDies() throws Exception {\n        final StaticNodeFactory nodeFactory = new StaticNodeFactory(3);\n        final Config config = new Config();\n        final HazelcastInstance keyOwner = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(config);\n        int k = 0;\n        final AtomicInteger atomicInteger = new AtomicInteger(0);\n        while (keyOwner.getCluster().getLocalMember().equals(instance1.getPartitionService().getPartition(k++).getOwner()))\n            ;\n        final int key = k;\n\n        final ILock lock1 = instance1.getLock(key);\n        lock1.lock();\n\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                final ILock lock = instance2.getLock(key);\n                lock.lock();\n                atomicInteger.incrementAndGet();\n            }\n        });\n        t.start();\n\n        keyOwner.getLifecycleService().shutdown();\n        Assert.assertEquals(true, lock1.isLocked());\n        Assert.assertEquals(true, lock1.tryLock());\n        lock1.unlock();\n        lock1.unlock();\n        Thread.sleep(1000);\n\n        Assert.assertEquals(1, atomicInteger.get());\n        lock1.forceUnlock();\n\n    }","commit_id":"4f8946a3214df88c4441cc7407eab2a3ebb2036f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(timeout = 100000)\n    public void testKeyOwnerDiesOnCondition() throws Exception {\n        final StaticNodeFactory nodeFactory = new StaticNodeFactory(3);\n        final Config config = new Config();\n        final HazelcastInstance keyOwner = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(config);\n        int k = 0;\n        final AtomicInteger atomicInteger = new AtomicInteger(0);\n        while (instance1.getPartitionService().getPartition(k++).equals(keyOwner.getCluster().getLocalMember())) ;\n        final int key = k;\n\n        final ILock lock1 = instance1.getLock(key);\n        final String name = \"testKeyOwnerDiesOnCondition\";\n        final ICondition condition1 = lock1.newCondition(name);\n\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                final ILock lock = instance2.getLock(key);\n                final ICondition condition = lock.newCondition(name);\n                lock.lock();\n                try {\n                    condition.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n                atomicInteger.incrementAndGet();\n            }\n        });\n        t.start();\n        Thread.sleep(1000);\n        lock1.lock();\n        keyOwner.getLifecycleService().shutdown();\n\n        condition1.signal();\n\n        lock1.unlock();\n        Thread.sleep(1000);\n        t.join();\n        Assert.assertEquals(1, atomicInteger.get());\n\n    }","id":42967,"modified_method":"@Test(timeout = 100000)\n    public void testKeyOwnerDiesOnCondition() throws Exception {\n        final StaticNodeFactory nodeFactory = new StaticNodeFactory(3);\n        final Config config = new Config();\n        final HazelcastInstance keyOwner = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(config);\n        int k = 0;\n        final AtomicInteger atomicInteger = new AtomicInteger(0);\n        while (keyOwner.getCluster().getLocalMember().equals(instance1.getPartitionService().getPartition(k++).getOwner()))\n            ;\n        final int key = k;\n\n        final ILock lock1 = instance1.getLock(key);\n        final String name = \"testKeyOwnerDiesOnCondition\";\n        final ICondition condition1 = lock1.newCondition(name);\n\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                final ILock lock = instance2.getLock(key);\n                final ICondition condition = lock.newCondition(name);\n                lock.lock();\n                try {\n                    condition.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    lock.unlock();\n                }\n                atomicInteger.incrementAndGet();\n            }\n        });\n        t.start();\n        Thread.sleep(1000);\n        lock1.lock();\n        keyOwner.getLifecycleService().shutdown();\n\n        condition1.signal();\n\n        lock1.unlock();\n        Thread.sleep(1000);\n        t.join();\n        Assert.assertEquals(1, atomicInteger.get());\n\n    }","commit_id":"4f8946a3214df88c4441cc7407eab2a3ebb2036f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testLockConditionSignalAllShutDownKeyOwner() throws InterruptedException {\n        final StaticNodeFactory nodeFactory = new StaticNodeFactory(2);\n        final Config config = new Config();\n        final String name = \"testLockConditionSignalAllShutDownKeyOwner\";\n        final HazelcastInstance instance = nodeFactory.newHazelcastInstance(config);\n        final AtomicInteger count = new AtomicInteger(0);\n        final int size = 50;\n        int k = 0;\n        final HazelcastInstance keyOwner = nodeFactory.newHazelcastInstance(config);\n        while (instance.getPartitionService().getPartition(k++).equals(keyOwner.getCluster().getLocalMember())) ;\n\n        final ILock lock = instance.getLock(k);\n        final ICondition condition = lock.newCondition(name);\n\n        final CountDownLatch awaitLatch = new CountDownLatch(size);\n        final CountDownLatch finalLatch = new CountDownLatch(size);\n        for (int i = 0; i < size; i++) {\n            new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        lock.lock();\n                        if (lock.isLocked() && lock.tryLock()) {\n                            count.incrementAndGet();\n                            lock.unlock();\n                        }\n                        awaitLatch.countDown();\n                        condition.await();\n                        Thread.sleep(5);\n                        if (lock.isLocked() && lock.tryLock()) {\n                            count.incrementAndGet();\n                            lock.unlock();\n                        }\n                    } catch (InterruptedException e) {\n                        return;\n                    } finally {\n                        lock.unlock();\n                        finalLatch.countDown();\n                    }\n\n                }\n            }).start();\n        }\n\n\n        final ILock lock1 = keyOwner.getLock(k);\n        final ICondition condition1 = lock1.newCondition(name);\n        awaitLatch.await(1, TimeUnit.MINUTES);\n        lock1.lock();\n        condition1.signalAll();\n        lock1.unlock();\n        keyOwner.getLifecycleService().shutdown();\n\n        finalLatch.await(1, TimeUnit.MINUTES);\n        Assert.assertEquals(size * 2, count.get());\n    }","id":42968,"modified_method":"@Test\n    public void testLockConditionSignalAllShutDownKeyOwner() throws InterruptedException {\n        final StaticNodeFactory nodeFactory = new StaticNodeFactory(2);\n        final Config config = new Config();\n        final String name = \"testLockConditionSignalAllShutDownKeyOwner\";\n        final HazelcastInstance instance = nodeFactory.newHazelcastInstance(config);\n        final AtomicInteger count = new AtomicInteger(0);\n        final int size = 50;\n        int k = 0;\n        final HazelcastInstance keyOwner = nodeFactory.newHazelcastInstance(config);\n        while (keyOwner.getCluster().getLocalMember().equals(instance.getPartitionService().getPartition(k++).getOwner()))\n            ;\n\n        final ILock lock = instance.getLock(k);\n        final ICondition condition = lock.newCondition(name);\n\n        final CountDownLatch awaitLatch = new CountDownLatch(size);\n        final CountDownLatch finalLatch = new CountDownLatch(size);\n        for (int i = 0; i < size; i++) {\n            new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        lock.lock();\n                        if (lock.isLocked() && lock.tryLock()) {\n                            count.incrementAndGet();\n                            lock.unlock();\n                        }\n                        awaitLatch.countDown();\n                        condition.await();\n                        Thread.sleep(5);\n                        if (lock.isLocked() && lock.tryLock()) {\n                            count.incrementAndGet();\n                            lock.unlock();\n                        }\n                    } catch (InterruptedException e) {\n                        return;\n                    } finally {\n                        lock.unlock();\n                        finalLatch.countDown();\n                    }\n\n                }\n            }).start();\n        }\n\n\n        final ILock lock1 = keyOwner.getLock(k);\n        final ICondition condition1 = lock1.newCondition(name);\n        awaitLatch.await(1, TimeUnit.MINUTES);\n        lock1.lock();\n        condition1.signalAll();\n        lock1.unlock();\n        keyOwner.getLifecycleService().shutdown();\n\n        finalLatch.await(1, TimeUnit.MINUTES);\n        Assert.assertEquals(size * 2, count.get());\n    }","commit_id":"4f8946a3214df88c4441cc7407eab2a3ebb2036f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public LocalTopicStats getLocalTopicStatsInternal() {\n        LocalTopicStatsImpl localTopicStats = new LocalTopicStatsImpl();\n        TopicContainer atomicLongContainer = getService().getAtomicLongContainer(name);\n        localTopicStats.setCreationTime(atomicLongContainer.getCreationTime());\n        localTopicStats.setTotalReceivedMessages(atomicLongContainer.getTotalReceivedMessages());\n        localTopicStats.setTotalPublishes(atomicLongContainer.getTotalPublishes());\n        localTopicStats.setLastPublishTime(atomicLongContainer.getLastAccessTime());\n        localTopicStats.setOperationStats(atomicLongContainer.getOperationsCounter().getPublishedStats());\n        return localTopicStats;\n    }","id":42969,"modified_method":"public LocalTopicStats getLocalTopicStatsInternal() {\n        LocalTopicStatsImpl localTopicStats = new LocalTopicStatsImpl();\n        TopicStatsContainer topicStatsContainer = getService().getTopicStatsContainer(name);\n        localTopicStats.setCreationTime(topicStatsContainer.getCreationTime());\n        localTopicStats.setTotalReceivedMessages(topicStatsContainer.getTotalReceivedMessages());\n        localTopicStats.setTotalPublishes(topicStatsContainer.getTotalPublishes());\n        localTopicStats.setLastPublishTime(topicStatsContainer.getLastAccessTime());\n        localTopicStats.setOperationStats(topicStatsContainer.getOperationsCounter().getPublishedStats());\n        return localTopicStats;\n    }","commit_id":"4f8946a3214df88c4441cc7407eab2a3ebb2036f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"TopicProxySupport(String name, NodeEngine nodeEngine, TopicService service) {\n        super(nodeEngine, service);\n        service.getAtomicLongContainer(name);\n        this.name = name;\n        eventService = nodeEngine.getEventService();\n\n    }","id":42970,"modified_method":"TopicProxySupport(String name, NodeEngine nodeEngine, TopicService service) {\n        super(nodeEngine, service);\n        service.getTopicStatsContainer(name);\n        this.name = name;\n        eventService = nodeEngine.getEventService();\n\n    }","commit_id":"4f8946a3214df88c4441cc7407eab2a3ebb2036f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public TopicContainer getAtomicLongContainer(String name) {\n        return ConcurrencyUtil.getOrPutSynchronized(topicContainers, name, topicContainers, topicConstructor);\n    }","id":42971,"modified_method":"public TopicStatsContainer getTopicStatsContainer(String name) {\n        return ConcurrencyUtil.getOrPutSynchronized(topicContainers, name, topicContainers, topicConstructor);\n    }","commit_id":"4f8946a3214df88c4441cc7407eab2a3ebb2036f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n  public void testEdges() throws Exception {\n    OrientGraphFactory factory = getGraphFactory();\n\n    try {\n      factory.getNoTx().createEdgeType(\"some-label\");\n    } catch (OSchemaException ex) {\n      if (!ex.getMessage().contains(\"exists\"))\n        throw (ex);\n    }\n\n    OrientGraph t = factory.getTx();\n\n    Vertex v1 = t.addVertex(null);\n    Vertex v2 = t.addVertex(null);\n    v1.setProperty(\"_id\", \"v1\");\n    v2.setProperty(\"_id\", \"v2\");\n\n    OrientEdge edge = t.addEdge(null, v1, v2, \"some-label\");\n    edge.setProperty(\"some\", \"thing\");\n\n    t.commit();\n    t.shutdown();\n\n    t = factory.getTx();\n\n    assertEquals(2, t.countVertices());\n    assertEquals(1, t.countEdges());\n    assertNotNull(t.getVertices(\"_id\", \"v1\").iterator().next());\n    assertNotNull(t.getVertices(\"_id\", \"v2\").iterator().next());\n    t.commit();\n    t.shutdown();\n\n    t = factory.getTx();\n\n    // works\n    assertEquals(1, t.getVertices(\"_id\", \"v1\").iterator().next().query().labels(\"some-label\").count());\n    // NoSuchElementException\n    assertNotNull(t.getVertices(\"_id\", \"v1\").iterator().next().query().labels(\"some-label\").edges().iterator().next());\n\n    t.commit();\n  }","id":42972,"modified_method":"@Test\n  public void testEdges() throws Exception {\n    OrientGraphFactory factory = getGraphFactory();\n\n    try {\n      factory.getNoTx().createEdgeType(\"some-label\");\n    } catch (OSchemaException ex) {\n      if (!ex.getMessage().contains(\"exists\"))\n        throw (ex);\n      factory.getNoTx().command(new OCommandSQL(\"delete edge some-label\")).execute();\n    }\n\n    try {\n      factory.getNoTx().createVertexType(\"some-v-label\");\n    } catch (OSchemaException ex) {\n      if (!ex.getMessage().contains(\"exists\"))\n        throw (ex);\n      factory.getNoTx().command(new OCommandSQL(\"delete vertex some-v-label\")).execute();\n    }\n\n    OrientGraph t = factory.getTx();\n\n    Vertex v1 = t.addVertex(\"class:some-v-label\");\n    Vertex v2 = t.addVertex(\"class:some-v-label\");\n    v1.setProperty(\"_id\", \"v1\");\n    v2.setProperty(\"_id\", \"v2\");\n\n    OrientEdge edge = t.addEdge(null, v1, v2, \"some-label\");\n    edge.setProperty(\"some\", \"thing\");\n\n    t.commit();\n    t.shutdown();\n\n    t = factory.getTx();\n\n    assertEquals(2, t.countVertices(\"some-v-label\"));\n    assertEquals(1, t.countEdges());\n    assertNotNull(t.getVertices(\"_id\", \"v1\").iterator().next());\n    assertNotNull(t.getVertices(\"_id\", \"v2\").iterator().next());\n    t.commit();\n    t.shutdown();\n\n    t = factory.getTx();\n\n    // works\n    assertEquals(1, t.getVertices(\"_id\", \"v1\").iterator().next().query().labels(\"some-label\").count());\n    // NoSuchElementException\n    assertNotNull(t.getVertices(\"_id\", \"v1\").iterator().next().query().labels(\"some-label\").edges().iterator().next());\n\n    t.commit();\n  }","commit_id":"8401ed63489f461d528aec7f7325891940883db8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected static OrientGraphFactory getGraphFactory() throws Exception {\n    Configuration conf = new BaseConfiguration();\n\n    conf.setProperty(\"storage.url\", \"remote:localhost/test\");\n    conf.setProperty(\"storage.pool-min\", \"1\");\n    conf.setProperty(\"storage.pool-max\", \"10\");\n    conf.setProperty(\"storage.user\", \"admin\");\n    conf.setProperty(\"storage.password\", \"admin\");\n\n    OGlobalConfiguration.CLIENT_CONNECT_POOL_WAIT_TIMEOUT.setValue(15000);\n\n    verifyDatabaseExists(conf);\n\n    return new OrientGraphFactory(conf.getString(\"storage.url\"), conf.getString(\"storage.user\"), conf.getString(\"storage.password\"))\n        .setupPool(conf.getInt(\"storage.pool-min\"), conf.getInt(\"storage.pool-max\"));\n  }","id":42973,"modified_method":"protected static OrientGraphFactory getGraphFactory() throws Exception {\n    Map<String, Object> conf = new HashMap<String, Object>();\n\n    conf.put(\"storage.url\", \"remote:localhost/test\");\n    conf.put(\"storage.pool-min\", 1);\n    conf.put(\"storage.pool-max\", 10);\n    conf.put(\"storage.user\", \"admin\");\n    conf.put(\"storage.password\", \"admin\");\n\n    OGlobalConfiguration.CLIENT_CONNECT_POOL_WAIT_TIMEOUT.setValue(15000);\n\n    verifyDatabaseExists(conf);\n\n    return new OrientGraphFactory((String) conf.get(\"storage.url\"), (String) conf.get(\"storage.user\"),\n        (String) conf.get(\"storage.password\")).setupPool((Integer) conf.get(\"storage.pool-min\"),\n        (Integer) conf.get(\"storage.pool-max\"));\n  }","commit_id":"8401ed63489f461d528aec7f7325891940883db8","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * {@inheritDoc}\n     * @throws InvalidParamException\n     */\n    public void execute(JobExecutionContext context)\n        throws JobExecutionException {\n        Integer days = null;\n        try {\n            days = context.getJobDetail().getJobDataMap().getInt(\"days\");\n        }\n        catch (java.lang.ClassCastException cce) {\n            // do nothing, days stays unset\n        }\n        if (days == null) {\n            throw new JobExecutionException(\"Invalid argument: days\");\n        }\n        Calendar now = Calendar.getInstance();\n        now.add(Calendar.DATE, -days);\n        now.set(Calendar.HOUR_OF_DAY, 0);\n        now.set(Calendar.MINUTE, 0);\n        now.set(Calendar.SECOND, 0);\n        now.set(Calendar.MILLISECOND, 0);\n        Date limitTime = now.getTime();\n\n        log.info(\"Clearing log history older than: \" +\n                LocalizationService.getInstance().formatCustomDate(limitTime));\n        Transaction tx = TaskoFactory.getSession().beginTransaction();\n        // loop accross all the orgs\n        List<TaskoRun> runList = TaskoFactory.listRunsOlderThan(limitTime);\n        for (TaskoRun run : runList) {\n            // delete history of runs\n            TaskoFactory.deleteLogFiles(run);\n            TaskoFactory.delete(run);\n        }\n\n        // delete outdated schedules\n        List<TaskoSchedule> scheduleList = TaskoFactory.listSchedulesOlderThan(limitTime);\n        for (TaskoSchedule schedule : scheduleList) {\n            Date endTime = schedule.getActiveTill();\n            if (TaskoFactory.listRunsBySchedule(schedule.getId()).isEmpty()) {\n                TaskoFactory.delete(schedule);\n            }\n        }\n        tx.commit();\n    }","id":42974,"modified_method":"/**\n     * {@inheritDoc}\n     * @throws InvalidParamException\n     */\n    public void execute(JobExecutionContext context)\n        throws JobExecutionException {\n        Integer days = null;\n        try {\n            days = Integer.parseInt(\n                    (String) context.getJobDetail().getJobDataMap().get(\"days\"));\n        }\n        catch (java.lang.ClassCastException cce) {\n            throw new JobExecutionException(\"Invalid argument: days\");\n        }\n        // if no value given, use default\n        if (days == null) {\n            days = DEFAULT_DAYS_VALUE;\n        }\n        Calendar now = Calendar.getInstance();\n        now.add(Calendar.DATE, -days);\n        now.set(Calendar.HOUR_OF_DAY, 0);\n        now.set(Calendar.MINUTE, 0);\n        now.set(Calendar.SECOND, 0);\n        now.set(Calendar.MILLISECOND, 0);\n        Date limitTime = now.getTime();\n\n        log.info(\"Clearing log history older than: \" +\n                LocalizationService.getInstance().formatCustomDate(limitTime));\n        HibernateFactory.getSession();\n        // loop accross all the orgs\n        List<TaskoRun> runList = TaskoFactory.listRunsOlderThan(limitTime);\n        for (TaskoRun run : runList) {\n            // delete history of runs\n            TaskoFactory.deleteLogFiles(run);\n            TaskoFactory.delete(run);\n        }\n\n        // delete outdated schedules\n        List<TaskoSchedule> scheduleList = TaskoFactory.listSchedulesOlderThan(limitTime);\n        for (TaskoSchedule schedule : scheduleList) {\n            Date endTime = schedule.getActiveTill();\n            if (TaskoFactory.listRunsBySchedule(schedule.getId()).isEmpty()) {\n                TaskoFactory.delete(schedule);\n            }\n        }\n        HibernateFactory.commitTransaction();\n        HibernateFactory.closeSession();\n    }","commit_id":"17c8ca8cf4b18d884a7e1935fbb8e1561a33c888","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute(JobExecutionContext context)\n        throws JobExecutionException {\n        TaskoRun previousRun = null;\n\n        TaskoSchedule schedule = TaskoFactory.lookupScheduleById(scheduleId);\n        if (schedule == null) {\n            // means, that schedule was deleted (in the DB), but quartz still schedules it\n            log.error(\"No such schedule with id  \" + scheduleId);\n            TaskoQuartzHelper.unscheduleTrigger(context.getTrigger());\n            return;\n        }\n\n        log.info(schedule.getJobLabel() + \":\" + \" bunch \" + schedule.getBunch().getName() +\n                \" STARTED\");\n\n        for (TaskoTemplate template : schedule.getBunch().getTemplates()) {\n            if ((previousRun == null) ||    // first run\n                    (template.getStartIf() == null) ||  // do not care\n                    (previousRun.getStatus().equals(template.getStartIf()))) {\n                TaskoTask task = template.getTask();\n\n                Object lock = locks.get(task.getName());\n                synchronized (lock) {\n                    if (isTaskSingleThreaded(task)) {\n                        if (isTaskRunning(task)) {\n                            log.debug(schedule.getJobLabel() + \":\" + \" task \" +\n                                    task.getName() + \" already running ... LEAVING\");\n                            previousRun = null;\n                            continue;\n                        }\n                    }\n                    else {\n                        while (!isTaskThreadAvailable(task)) {\n                            try {\n                                log.debug(schedule.getJobLabel() + \":\" + \" task \" +\n                                        task.getName() +\n                                        \" all allowed threads running ... WAITING\");\n                                lock.wait();\n                                log.debug(schedule.getJobLabel() + \":\" + \" task \" +\n                                        task.getName() + \" ... AWAKE\");\n                            }\n                            catch (InterruptedException e) {\n                                // ok\n                            }\n                        }\n                    }\n                    markTaskRunning(task);\n                }\n                log.debug(schedule.getJobLabel() + \":\" + \" task \" + task.getName() +\n                        \" started\");\n                TaskoRun taskRun = new TaskoRun(schedule.getOrgId(), template, scheduleId);\n                TaskoFactory.save(taskRun);\n                HibernateFactory.commitTransaction();\n                HibernateFactory.closeSession();\n\n                Class jobClass = null;\n                RhnJob job = null;\n                try {\n                    jobClass = Class.forName(template.getTask().getTaskClass());\n                    job = (RhnJob) jobClass.newInstance();\n                }\n                catch (Exception e) {\n                    String errorLog = e.getMessage() + '\\n' + e.getCause() + '\\n';\n                    taskRun.appendToErrorLog(errorLog);\n                    taskRun.saveStatus(TaskoRun.STATUS_FAILED);\n                    HibernateFactory.commitTransaction();\n                    HibernateFactory.closeSession();\n                    return;\n                }\n\n                job.execute(context, taskRun);\n                // rollback everything, what the application changed and didn't committed\n                if (TaskoFactory.getSession().getTransaction().isActive()) {\n                    TaskoFactory.rollbackTransaction();\n                    HibernateFactory.closeSession();\n                }\n\n                log.debug(task.getName() + \" (\" + schedule.getJobLabel() + \") ... \" +\n                        taskRun.getStatus().toLowerCase());\n                if (taskRun.getStatus() != lastStatus.get(task.getName())) {\n                    String email = \"Taskomatic bunch \" + schedule.getBunch().getName() +\n                    \" was scheduled to run within the \" + schedule.getJobLabel() + \" schedule.\\n\\n\" +\n                    \"Subtask \" + task.getName();\n                    if (taskRun.getStatus() == TaskoRun.STATUS_FAILED) {\n                        email += \" failed.\\n\\n\";\n                        email += \"For more information check \" + taskRun.getStdErrorPath() + \".\";\n                    }\n                    else {\n                        email += \" finished successfuly and is back to normal.\";\n                    }\n                    log.info(\"Sending e-mail ... \" + task.getName());\n                    TaskHelper.sendTaskoEmail(taskRun.getOrgId(), email);\n                    lastStatus.put(task.getName(), taskRun.getStatus());\n                }\n                previousRun = taskRun;\n                synchronized (lock) {\n                    unmarkTaskRunning(task);\n                    lock.notify();\n                }\n            }\n            else {\n                log.info(\"Interrupting \" + schedule.getBunch().getName() +\n                        \" (\" + schedule.getJobLabel() + \")\");\n                break;\n            }\n        }\n        HibernateFactory.closeSession();\n        log.info(schedule.getJobLabel() + \":\" + \" bunch \" + schedule.getBunch().getName() +\n                \" FINISHED\");\n    }","id":42975,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void execute(JobExecutionContext context)\n        throws JobExecutionException {\n        TaskoRun previousRun = null;\n\n        TaskoSchedule schedule = TaskoFactory.lookupScheduleById(scheduleId);\n        if (schedule == null) {\n            // means, that schedule was deleted (in the DB), but quartz still schedules it\n            log.error(\"No such schedule with id  \" + scheduleId);\n            TaskoQuartzHelper.unscheduleTrigger(context.getTrigger());\n            return;\n        }\n\n        log.info(schedule.getJobLabel() + \":\" + \" bunch \" + schedule.getBunch().getName() +\n                \" STARTED\");\n\n        for (TaskoTemplate template : schedule.getBunch().getTemplates()) {\n            if ((previousRun == null) ||    // first run\n                    (template.getStartIf() == null) ||  // do not care\n                    (previousRun.getStatus().equals(template.getStartIf()))) {\n                TaskoTask task = template.getTask();\n\n                Object lock = locks.get(task.getName());\n                synchronized (lock) {\n                    if (isTaskSingleThreaded(task)) {\n                        if (isTaskRunning(task)) {\n                            log.debug(schedule.getJobLabel() + \":\" + \" task \" +\n                                    task.getName() + \" already running ... LEAVING\");\n                            previousRun = null;\n                            continue;\n                        }\n                    }\n                    else {\n                        while (!isTaskThreadAvailable(task)) {\n                            try {\n                                log.debug(schedule.getJobLabel() + \":\" + \" task \" +\n                                        task.getName() +\n                                        \" all allowed threads running ... WAITING\");\n                                lock.wait();\n                                log.debug(schedule.getJobLabel() + \":\" + \" task \" +\n                                        task.getName() + \" ... AWAKE\");\n                            }\n                            catch (InterruptedException e) {\n                                // ok\n                            }\n                        }\n                    }\n                    markTaskRunning(task);\n                }\n                log.debug(schedule.getJobLabel() + \":\" + \" task \" + task.getName() +\n                        \" started\");\n                TaskoRun taskRun = new TaskoRun(schedule.getOrgId(), template, scheduleId);\n                TaskoFactory.save(taskRun);\n                HibernateFactory.commitTransaction();\n                HibernateFactory.closeSession();\n\n                Class jobClass = null;\n                RhnJob job = null;\n                try {\n                    jobClass = Class.forName(template.getTask().getTaskClass());\n                    job = (RhnJob) jobClass.newInstance();\n                }\n                catch (Exception e) {\n                    String errorLog = e.getMessage() + '\\n' + e.getCause() + '\\n';\n                    taskRun.appendToErrorLog(errorLog);\n                    taskRun.saveStatus(TaskoRun.STATUS_FAILED);\n                    HibernateFactory.commitTransaction();\n                    HibernateFactory.closeSession();\n                    return;\n                }\n\n                job.execute(context, taskRun);\n                // rollback everything, what the application changed and didn't committed\n                if (TaskoFactory.getSession().getTransaction().isActive()) {\n                    TaskoFactory.rollbackTransaction();\n                    HibernateFactory.closeSession();\n                }\n\n                log.debug(task.getName() + \" (\" + schedule.getJobLabel() + \") ... \" +\n                        taskRun.getStatus().toLowerCase());\n                if (taskRun.getStatus() != lastStatus.get(task.getName())) {\n                    String email = \"Taskomatic bunch \" + schedule.getBunch().getName() +\n                    \" was scheduled to run within the \" + schedule.getJobLabel() +\n                    \" schedule.\\n\\n\" + \"Subtask \" + task.getName();\n                    if (taskRun.getStatus() == TaskoRun.STATUS_FAILED) {\n                        email += \" failed.\\n\\n\" + \"For more information check \";\n                        email += taskRun.getStdErrorPath() + \".\";\n                    }\n                    else {\n                        email += \" finished successfuly and is back to normal.\";\n                    }\n                    log.info(\"Sending e-mail ... \" + task.getName());\n                    TaskHelper.sendTaskoEmail(taskRun.getOrgId(), email);\n                    lastStatus.put(task.getName(), taskRun.getStatus());\n                }\n                previousRun = taskRun;\n                synchronized (lock) {\n                    unmarkTaskRunning(task);\n                    lock.notify();\n                }\n            }\n            else {\n                log.info(\"Interrupting \" + schedule.getBunch().getName() +\n                        \" (\" + schedule.getJobLabel() + \")\");\n                break;\n            }\n        }\n        HibernateFactory.closeSession();\n        log.info(schedule.getJobLabel() + \":\" + \" bunch \" + schedule.getBunch().getName() +\n                \" FINISHED\");\n    }","commit_id":"17c8ca8cf4b18d884a7e1935fbb8e1561a33c888","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n\tprivate void handleReceivedMessage(MapMessage mapMessage) {\r\n    \ttry{\r\n\t\t\tString code = mapMessage.getString(\"returnCode\");\r\n\t    \tString room = mapMessage.getString(\"room\");\r\n\t    \tString presentationName = mapMessage.getString(\"presentationName\");\r\n\t    \tString conference = mapMessage.getString(\"conference\");\r\n\t    \tString messageKey = mapMessage.getString(\"messageKey\");\r\n\t    \t\r\n\t\t\tMap message = new HashMap();\r\n\t    \tmessage.put(\"conference\", conference);\r\n\t\t\tmessage.put(\"room\", room);\r\n\t\t\tmessage.put(\"code\", code);\r\n\t\t\tmessage.put(\"presentationName\", presentationName);\r\n\t\t\tmessage.put(\"messageKey\", messageKey);\r\n\t\t\t\r\n\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\r\n\t\t\tif(messageKey.equalsIgnoreCase(OFFICE_DOC_CONVERSION_SUCCESS_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(OFFICE_DOC_CONVERSION_FAILED_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(SUPPORTED_DOCUMENT_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(UNSUPPORTED_DOCUMENT_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(GENERATING_THUMBNAIL_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(GENERATED_THUMBNAIL_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(PAGE_COUNT_FAILED_KEY)){\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse if(messageKey.equalsIgnoreCase(PAGE_COUNT_EXCEEDED_KEY)){\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tint numberOfPages = mapMessage.getInt(\"numberOfPages\");\r\n\t\t\t\tint maxNumberPages = mapMessage.getInt(\"maxNumberPages\");\r\n\t\t\t\tmessage.put(\"numberOfPages\", numberOfPages);\r\n\t\t\t\tmessage.put(\"maxNumberPages\", maxNumberPages);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse if(messageKey.equalsIgnoreCase(GENERATED_SLIDE_KEY)){\r\n\t\t\t\tint numberOfPages = mapMessage.getInt(\"numberOfPages\");\r\n\t\t\t\tint pagesCompleted = mapMessage.getInt(\"pagesCompleted\");\r\n\t\t\t\tmessage.put(\"numberOfPages\", numberOfPages);\r\n\t\t\t\tmessage.put(\"pagesCompleted\", pagesCompleted);\r\n\t\t\t\t\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse if(messageKey.equalsIgnoreCase(CONVERSION_COMPLETED_KEY)){\r\n\t\t\t\tString slidesInfo = mapMessage.getString(\"slidesInfo\");\r\n\t\t\t\tmessage.put(\"slidesInfo\", slidesInfo);\t\t\t\t\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tlog.error(\"Cannot handle recieved message.\");\r\n\t\t\t}\r\n    \t}catch(JMSException ex){\r\n    \t\tlog.warn(ex.getMessage());\r\n    \t}\t\t\r\n\t}","id":42976,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n\tpublic void handleReceivedMessage(Map mapMessage) {\r\n    \ttry{\r\n\t\t\tString code = (String) mapMessage.get(\"returnCode\");\r\n\t    \tString room = (String) mapMessage.get(\"room\");\r\n\t    \tString presentationName = (String) mapMessage.get(\"presentationName\");\r\n\t    \tString conference = (String) mapMessage.get(\"conference\");\r\n\t    \tString messageKey = (String) mapMessage.get(\"messageKey\");\r\n\t    \t\r\n\t\t\tMap message = new HashMap();\r\n\t    \tmessage.put(\"conference\", conference);\r\n\t\t\tmessage.put(\"room\", room);\r\n\t\t\tmessage.put(\"code\", code);\r\n\t\t\tmessage.put(\"presentationName\", presentationName);\r\n\t\t\tmessage.put(\"messageKey\", messageKey);\r\n\t\t\t\r\n\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\r\n\t\t\tif(messageKey.equalsIgnoreCase(OFFICE_DOC_CONVERSION_SUCCESS_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(OFFICE_DOC_CONVERSION_FAILED_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(SUPPORTED_DOCUMENT_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(UNSUPPORTED_DOCUMENT_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(GENERATING_THUMBNAIL_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(GENERATED_THUMBNAIL_KEY)||\r\n\t\t\t\t\tmessageKey.equalsIgnoreCase(PAGE_COUNT_FAILED_KEY)){\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse if(messageKey.equalsIgnoreCase(PAGE_COUNT_EXCEEDED_KEY)){\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tint numberOfPages = (Integer) mapMessage.get(\"numberOfPages\");\r\n\t\t\t\tint maxNumberPages = (Integer) mapMessage.get(\"maxNumberPages\");\r\n\t\t\t\tmessage.put(\"numberOfPages\", numberOfPages);\r\n\t\t\t\tmessage.put(\"maxNumberPages\", maxNumberPages);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse if(messageKey.equalsIgnoreCase(GENERATED_SLIDE_KEY)){\r\n\t\t\t\tint numberOfPages = (Integer) mapMessage.get(\"numberOfPages\");\r\n\t\t\t\tint pagesCompleted = (Integer) mapMessage.get(\"pagesCompleted\");\r\n\t\t\t\tmessage.put(\"numberOfPages\", numberOfPages);\r\n\t\t\t\tmessage.put(\"pagesCompleted\", pagesCompleted);\r\n\t\t\t\t\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse if(messageKey.equalsIgnoreCase(CONVERSION_COMPLETED_KEY)){\r\n\t\t\t\tString slidesInfo = (String) mapMessage.get(\"slidesInfo\");\r\n\t\t\t\tmessage.put(\"slidesInfo\", slidesInfo);\t\t\t\t\r\n\t\t\t\tlog.debug(\"JMS: {}[{}]\",messageKey,presentationName);\r\n\t\t\t\tconversionUpdatesProcessor.process(message);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tlog.error(\"Cannot handle recieved message.\");\r\n\t\t\t}\r\n    \t}catch(Exception ex){\r\n    \t\tlog.warn(ex.getMessage());\r\n    \t}\t\t\r\n\t}","commit_id":"5bbb607c5df1c0bd8453d128c012e8b20403a880","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public Map getParticipants(String roomName) {\n\t\tlog.debug(\"getParticipants - \" + roomName);\n\t\tif (! roomsManager.hasRoom(roomName)) {\n\t\t\tlog.warn(\"Could not find room \"+roomName);\n\t\t\treturn null;\n\t\t}\n\n\t\treturn roomsManager.getParticipants(roomName);\n\t}","id":42977,"modified_method":"public Map getParticipants(String roomName) {\n\t\tlog.debug(\"getParticipants - \" + roomName);\n\t\tif (! roomsManager.hasRoom(roomName)) {\n\t\t\tlog.warn(\"Could not find room \"+roomName+\" Total rooms \"+roomsManager.numberOfRooms());\n\t\t\treturn null;\n\t\t}\n\n\t\treturn roomsManager.getParticipants(roomName);\n\t}","commit_id":"5bbb607c5df1c0bd8453d128c012e8b20403a880","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic void record(String session, RecordEvent message) {\r\n\t\tJedis jedis = new Jedis(host, port);\r\n\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\tjedis.hmset(\"recording\" + COLON + session + COLON + msgid, message.toMap());\r\n\t\tjedis.rpush(\"meeting\" + COLON + session + COLON + \"recordings\", msgid.toString());\t\t\t\t\t\t\r\n\t}","id":42978,"modified_method":"@Override\r\n\tpublic void record(String session, RecordEvent message) {\r\n\t\t\r\n\t\tJedis jedis = redisPool.getResource();\r\n\t\ttry {\r\n\t\t\tLong msgid = jedis.incr(\"global:nextRecordedMsgId\");\r\n\t\t\tjedis.hmset(\"recording\" + COLON + session + COLON + msgid, message.toMap());\r\n\t\t\tjedis.rpush(\"meeting\" + COLON + session + COLON + \"recordings\", msgid.toString());\r\n\t\t} finally {\r\n\t\t\tredisPool.returnResource(jedis);\r\n\t\t}\r\n\t\t\r\n\t\t//pool.destroy();\t\t\t\t\t\r\n\t}","commit_id":"5bbb607c5df1c0bd8453d128c012e8b20403a880","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public RedisDispatcher(String host, int port){\r\n\t\tthis.host = host;\r\n\t\tthis.port = port;\r\n\t\t\r\n//\t\tjedis = new Jedis(host, port);\t\t\r\n//\t\tConfig poolConfig = new Config();\r\n//\t\tjpool = new JedisPool(poolConfig, host, port);\r\n\t}","id":42979,"modified_method":"public RedisDispatcher(){\r\n\t\tsuper();\r\n\t}","commit_id":"5bbb607c5df1c0bd8453d128c012e8b20403a880","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void endMeetingRequest(Room room) {\n\t\troom = getRoom(room.getName()); // must do this because the room coming in is serialized (no transient values are present)\n\t\tlog.debug(\"End meeting request for room: {} \", room.getName());\n\t\troom.endAndKickAll();\n\t}","id":42980,"modified_method":"public void endMeetingRequest(String roomname) {\n\t\tRoom room = getRoom(roomname); // must do this because the room coming in is serialized (no transient values are present)\n\t\tlog.debug(\"End meeting request for room: {} \", room.getName());\n\t\troom.endAndKickAll();\n\t}","commit_id":"5bbb607c5df1c0bd8453d128c012e8b20403a880","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void consumeException(Exception e, FilterDirector director) {\n        LOG.error(\"Failure when querying limits. Reason: \" + e.getMessage(), e);\n\n        director.setFilterAction(FilterAction.RETURN);\n        director.setResponseStatusCode(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n    }","id":42981,"modified_method":"private void consumeException(Exception e, FilterDirector director) {\n        consumeException(e, director, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n    }","commit_id":"7e1414f4a6345e2207224d2d434cd300d668ce8a","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public FilterDirector handleResponse(HttpServletRequest request, ReadableHttpServletResponse response) {\n        final FilterDirector director = new FilterDirectorImpl();\n        director.setResponseStatusCode(response.getStatus());\n        director.setFilterAction(FilterAction.PASS);\n\n        try {\n            if (response.getContentType() != null) {\n                //If we have a content type to process, then we should do something about it,\n                // else we should ensure that just the repose limits make it through...\n                if (response.getContentType().equalsIgnoreCase(MimeType.APPLICATION_JSON.toString())) {\n                    //Grab the absolute limits out of the structure, glue it into the existing limits structure, and ship it\n                    //get the active limits into a JSON for me -- this is just the repose side of the limits\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    rateLimitingServiceHelper.queryActiveLimits(request,\n                            new MediaType(MimeType.APPLICATION_JSON),\n                            baos);\n\n                    //Convert the absolute limits structure into a JSON object\n                    ObjectMapper mapper = new ObjectMapper();\n                    JsonParser absoluteParser = mapper.getFactory().createParser(response.getInputStream());\n                    ObjectNode rootNode = absoluteParser.readValueAsTree();\n\n                    //Consume our string of output into a JSON tree, and insert the absolute node under the limits node\n                    JsonParser reposeParser = mapper.getFactory().createParser(baos.toString());\n                    ObjectNode reposeNode = reposeParser.readValueAsTree();\n                    jsonMerge(reposeNode, rootNode); //Merge the root node into the repose node!\n\n                    //Write it to the filter director for realsies\n                    mapper.writeValue(director.getResponseOutputStream(), reposeNode);\n                    director.responseHeaderManager().putHeader(CommonHttpHeader.CONTENT_TYPE.toString(), MimeType.APPLICATION_JSON.toString());\n                } else if (response.getContentType().equalsIgnoreCase(MimeType.APPLICATION_XML.toString())) {\n                    //This section is if the upstream responded with XML and we'll do our XML-JSON magic, or not\n                    final MimeType mimeType = rateLimitingServiceHelper.queryCombinedLimits(request, originalPreferredAccept, response.getBufferedOutputAsInputStream(), director.getResponseOutputStream());\n                    director.responseHeaderManager().putHeader(CommonHttpHeader.CONTENT_TYPE.toString(), mimeType.toString());\n                } else {\n                    LOG.error(\"Upstream limits call was not a content type we can understand! {}\", response.getContentType());\n                    //Upstream responded with something we cannot talk, we failed to combine upstream limits, return a 502!\n                    director.setResponseStatusCode(502);\n                }\n            } else {\n                LOG.warn(\"NO DATA RECEIVED FROM UPSTREAM limits, only sending regular rate limits!\");\n                //No data from upstream, so I think we send the regular stuff no matter what\n                noUpstreamResponse(request, director, originalPreferredAccept);\n            }\n\n        } catch (Exception e) {\n            consumeException(e, director);\n        }\n\n        return director;\n    }","id":42982,"modified_method":"@Override\n    public FilterDirector handleResponse(HttpServletRequest request, ReadableHttpServletResponse response) {\n        final FilterDirector director = new FilterDirectorImpl();\n        director.setResponseStatusCode(response.getStatus());\n        director.setFilterAction(FilterAction.PASS);\n\n        try {\n            if (response.getContentType() != null) {\n                //If we have a content type to process, then we should do something about it,\n                // else we should ensure that just the repose limits make it through...\n\n                // I have to use mutable state, and that makes me sad, because If's aren't expressions\n                InputStream absoluteInputStream;\n                if (response.getContentType().equalsIgnoreCase(MimeType.APPLICATION_JSON.toString())) {\n                    //New set up! Grab the upstream json, make it look like XML\n                    String newXml = UpstreamJsonToXml.convert(response.getInputStream());\n\n                    //Now we use the new XML we converted from the JSON as the input to the processing stream\n                    absoluteInputStream = new ByteArrayInputStream(newXml.getBytes(StandardCharsets.UTF_8));\n                } else if (response.getContentType().equalsIgnoreCase(MimeType.APPLICATION_XML.toString())) {\n                    //If we got XML from upstream, just read the stream directly\n                    absoluteInputStream = response.getBufferedOutputAsInputStream();\n                } else {\n                    LOG.error(\"Upstream limits responded with a content type we cannot understand: {}\", response.getContentType());\n                    //Upstream responded with something we cannot talk, we failed to combine upstream limits, return a 502!\n                    throw new UpstreamException(\"Upstream limits responded with a content type we cannot understand: \" + response.getContentType());\n                }\n\n                //We'll get here if we were able to properly parse JSON, or if we had XML from upstream!\n                final MimeType mimeType = rateLimitingServiceHelper.queryCombinedLimits(request, originalPreferredAccept, absoluteInputStream, director.getResponseOutputStream());\n                director.responseHeaderManager().putHeader(CommonHttpHeader.CONTENT_TYPE.toString(), mimeType.toString());\n            } else {\n                LOG.warn(\"NO DATA RECEIVED FROM UPSTREAM limits, only sending regular rate limits!\");\n                //No data from upstream, so we send the regular stuff no matter what\n                noUpstreamResponse(request, director, originalPreferredAccept);\n            }\n\n        } catch (UpstreamException ue) {\n            //I want a 502 returned when upstream didn't respond appropriately\n            consumeException(ue, director, 502);\n        } catch (Exception e) {\n            consumeException(e, director);\n        }\n\n        return director;\n    }","commit_id":"7e1414f4a6345e2207224d2d434cd300d668ce8a","url":"https://github.com/rackerlabs/repose"},{"original_method":"public BufferedServletInputStream(ServletInputStream inputStream) {\n      this.inputStream = new BufferedInputStream(inputStream);\n   }","id":42983,"modified_method":"public BufferedServletInputStream(InputStream inputStream) {\n      this.inputStream = new BufferedInputStream(inputStream);\n   }","commit_id":"129cb18e8f1fff3b6a06788720b53b1878286370","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public FilterDirector handleResponse(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        final FilterDirector filterDirector = new FilterDirectorImpl();\n        filterDirector.setFilterAction(FilterAction.PASS);\n\n        MediaRangeProcessor processor = new MediaRangeProcessor(request.getPreferredHeaderValues(\"Accept\", DEFAULT_TYPE));\n        MimeType contentMimeType = MimeType.getMatchingMimeType(response.getHeader(\"content-type\"));\n        MediaType contentType = new MediaType(contentMimeType);\n        List<MediaType> acceptValues = processor.process();\n\n        XsltChainPool<T> pool = getHandlerChainPool(\"\", contentType, acceptValues, String.valueOf(response.getStatus()), responseProcessors);\n\n        if (pool != null) {\n            try {\n                executePool(request, response, pool, response.getBufferedOutputAsInputStream(), filterDirector.getResponseOutputStream());\n                response.setContentType(pool.getResultContentType());\n                filterDirector.setResponseStatusCode(response.getStatus());\n            } catch (XsltException ex) {\n                LOG.error(\"Error executing response transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                response.setContentLength(0);\n            } catch (IOException ex) {\n                LOG.error(\"Error executing response transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                response.setContentLength(0);\n            }\n        } else {\n            filterDirector.setResponseStatusCode(response.getStatus());\n        }\n\n        return filterDirector;\n    }","id":42984,"modified_method":"@Override\n    public FilterDirector handleResponse(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        final FilterDirector filterDirector = new FilterDirectorImpl();\n        filterDirector.setFilterAction(FilterAction.PASS);\n\n        MediaRangeProcessor processor = new MediaRangeProcessor(request.getPreferredHeaderValues(\"Accept\", DEFAULT_TYPE));\n        MimeType contentMimeType = MimeType.getMatchingMimeType(response.getHeader(\"content-type\"));\n        MediaType contentType = new MediaType(contentMimeType);\n        List<MediaType> acceptValues = processor.process();\n\n        XsltChainPool<T> pool = getHandlerChainPool(\"\", contentType, acceptValues, String.valueOf(response.getStatus()), responseProcessors);\n\n        if (pool != null) {\n            try {\n                if (response.hasBody()) {\n                    InputStream in = response.getBufferedOutputAsInputStream();\n                    if (in.available() > 0) {\n                        executePool(request, response, pool, in, filterDirector.getResponseOutputStream());\n                        response.setContentType(pool.getResultContentType());\n                    }\n                }\n                filterDirector.setResponseStatusCode(response.getStatus());\n            } catch (XsltException ex) {\n                LOG.error(\"Error executing response transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                response.setContentLength(0);\n            } catch (IOException ex) {\n                LOG.error(\"Error executing response transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                response.setContentLength(0);\n            }\n        } else {\n            filterDirector.setResponseStatusCode(response.getStatus());\n        }\n\n        return filterDirector;\n    }","commit_id":"129cb18e8f1fff3b6a06788720b53b1878286370","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        FilterDirector filterDirector = new FilterDirectorImpl();\n\n        MediaRangeProcessor processor = new MediaRangeProcessor(request.getPreferredHeaderValues(\"Accept\", DEFAULT_TYPE));\n        MimeType contentMimeType = MimeType.getMatchingMimeType(request.getHeader(\"content-type\"));\n        MediaType contentType = new MediaType(contentMimeType);\n        List<MediaType> acceptValues = processor.process();\n        XsltChainPool<T> pool = getHandlerChainPool(request.getMethod(), contentType, acceptValues, \"\", requestProcessors);\n\n        if (pool != null) {\n            try {\n                final ByteBuffer internalBuffer = new CyclicByteBuffer(DEFAULT_BUFFER_SIZE, true);\n                executePool(request, response, pool, request.getInputStream(), new ByteBufferServletOutputStream(internalBuffer));\n                request.setInputStream(new ByteBufferServletInputStream(internalBuffer));\n                filterDirector.requestHeaderManager().putHeader(\"content-type\", pool.getResultContentType());\n                filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n            } catch (XsltException ex) {\n                LOG.error(\"Error executing request transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                filterDirector.setFilterAction(FilterAction.RETURN);\n            } catch (IOException ex) {\n                LOG.error(\"Error executing request transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                filterDirector.setFilterAction(FilterAction.RETURN);\n            }\n        } else {\n            filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n        }\n\n\n        return filterDirector;\n    }","id":42985,"modified_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        FilterDirector filterDirector = new FilterDirectorImpl();\n\n        MediaRangeProcessor processor = new MediaRangeProcessor(request.getPreferredHeaderValues(\"Accept\", DEFAULT_TYPE));\n        MimeType contentMimeType = MimeType.getMatchingMimeType(request.getHeader(\"content-type\"));\n        MediaType contentType = new MediaType(contentMimeType);\n        List<MediaType> acceptValues = processor.process();\n        XsltChainPool<T> pool = getHandlerChainPool(request.getMethod(), contentType, acceptValues, \"\", requestProcessors);\n\n        if (pool != null) {\n            try {\n                InputStream in = request.getInputStream();\n                final ByteBuffer internalBuffer = new CyclicByteBuffer(DEFAULT_BUFFER_SIZE, true);\n                executePool(request, response, pool, in, new ByteBufferServletOutputStream(internalBuffer));\n                request.setInputStream(new ByteBufferServletInputStream(internalBuffer));\n                filterDirector.requestHeaderManager().putHeader(\"content-type\", pool.getResultContentType());\n                filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n            } catch (XsltException ex) {\n                LOG.error(\"Error executing request transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                filterDirector.setFilterAction(FilterAction.RETURN);\n            } catch (IOException ex) {\n                LOG.error(\"Error executing request transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                filterDirector.setFilterAction(FilterAction.RETURN);\n            }\n        } else {\n            filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n        }\n\n\n        return filterDirector;\n    }","commit_id":"129cb18e8f1fff3b6a06788720b53b1878286370","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n        public void configurationUpdated(TranslationConfig config) {\n            requestProcessors.clear();\n            responseProcessors.clear();\n\n            if (config.getResponseTranslations() != null) {\n                for (final ResponseTranslation translation : config.getResponseTranslations().getResponseTranslation()) {\n\n                    final List<Parameter> params = new ArrayList<Parameter>();\n                    Pool<XsltChain<T>> pool = new GenericBlockingResourcePool<XsltChain<T>>(\n                            new ConstructionStrategy<XsltChain<T>>() {\n                                @Override\n                                public XsltChain<T> construct() throws ResourceConstructionException {\n                                    List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                    for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                        stylesheets.add(new StyleSheetInfo(sheet.getId(), getXslPath(sheet.getHref())));\n                                        for (StyleParam param: sheet.getParam()) {\n                                            params.add(new Parameter<String>(sheet.getId(), param.getName(), param.getValue()));\n                                        }\n                                    }\n\n                                    return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                                }\n                            });\n\n                    responseProcessors.add(new XsltChainPool(\n                            translation.getContentType(),\n                            translation.getAccept(),\n                            translation.getCodeRegex(),\n                            translation.getTranslatedContentType(),\n                            params,\n                            pool));\n                }\n            }\n\n            if (config.getRequestTranslations() != null) {\n                for (final RequestTranslation translation : config.getRequestTranslations().getRequestTranslation()) {\n\n                    final List<Parameter> params = new ArrayList<Parameter>();\n                    Pool<XsltChain<T>> pool = new GenericBlockingResourcePool<XsltChain<T>>(\n                            new ConstructionStrategy<XsltChain<T>>() {\n                                @Override\n                                public XsltChain<T> construct() throws ResourceConstructionException {\n                                    List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                    for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                        stylesheets.add(new StyleSheetInfo(sheet.getId(), getXslPath(sheet.getHref())));\n                                        for (StyleParam param: sheet.getParam()) {\n                                            params.add(new Parameter<String>(sheet.getId(), param.getName(), param.getValue()));\n                                        }\n                                    }\n\n                                    return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                                }\n                            });\n\n                    requestProcessors.add(new XsltChainPool(\n                            translation.getContentType(),\n                            translation.getAccept(),\n                            translation.getHttpMethods(),\n                            translation.getTranslatedContentType(),\n                            params,\n                            pool));\n                }\n            }\n        }","id":42986,"modified_method":"@Override\n        public void configurationUpdated(TranslationConfig config) {\n            requestProcessors.clear();\n            responseProcessors.clear();\n\n            if (config.getResponseTranslations() != null) {\n                for (final ResponseTranslation translation : config.getResponseTranslations().getResponseTranslation()) {\n\n                    final List<Parameter> params = new ArrayList<Parameter>();\n                    Pool<XsltChain<T>> pool = new GenericBlockingResourcePool<XsltChain<T>>(\n                            new ConstructionStrategy<XsltChain<T>>() {\n                                @Override\n                                public XsltChain<T> construct() throws ResourceConstructionException {\n                                    List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                    if (translation.getStyleSheets() != null) {\n                                        for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                            stylesheets.add(new StyleSheetInfo(sheet.getId(), getXslPath(sheet.getHref())));\n                                            for (StyleParam param : sheet.getParam()) {\n                                                params.add(new Parameter<String>(sheet.getId(), param.getName(), param.getValue()));\n                                            }\n                                        }\n                                    }\n\n                                    return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                                }\n                            });\n\n                    responseProcessors.add(new XsltChainPool(\n                            translation.getContentType(),\n                            translation.getAccept(),\n                            translation.getCodeRegex(),\n                            translation.getTranslatedContentType(),\n                            params,\n                            pool));\n                }\n            }\n\n            if (config.getRequestTranslations() != null) {\n                for (final RequestTranslation translation : config.getRequestTranslations().getRequestTranslation()) {\n\n                    final List<Parameter> params = new ArrayList<Parameter>();\n                    Pool<XsltChain<T>> pool = new GenericBlockingResourcePool<XsltChain<T>>(\n                            new ConstructionStrategy<XsltChain<T>>() {\n                                @Override\n                                public XsltChain<T> construct() throws ResourceConstructionException {\n                                    List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                    if (translation.getStyleSheets() != null) {\n                                        for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                            stylesheets.add(new StyleSheetInfo(sheet.getId(), getXslPath(sheet.getHref())));\n                                            for (StyleParam param : sheet.getParam()) {\n                                                params.add(new Parameter<String>(sheet.getId(), param.getName(), param.getValue()));\n                                            }\n                                        }\n                                    }\n\n                                    return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                                }\n                            });\n\n                    requestProcessors.add(new XsltChainPool(\n                            translation.getContentType(),\n                            translation.getAccept(),\n                            translation.getHttpMethods(),\n                            translation.getTranslatedContentType(),\n                            params,\n                            pool));\n                }\n            }\n        }","commit_id":"129cb18e8f1fff3b6a06788720b53b1878286370","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   public void executeChain(InputStream in, OutputStream output, List<Parameter> inputs, List<Parameter<? extends OutputStream>> outputs) throws XsltException {\n      new XsltFilterChainExecutor(this).executeChain(in, output, inputs, outputs);\n   }","id":42987,"modified_method":"@Override\n   public void executeChain(InputStream in, OutputStream output, List<Parameter> inputs, List<Parameter<? extends OutputStream>> outputs) throws XsltException {\n        if (in == null || output == null) {\n            return;\n        }\n      new XsltFilterChainExecutor(this).executeChain(in, output, inputs, outputs);\n   }","commit_id":"129cb18e8f1fff3b6a06788720b53b1878286370","url":"https://github.com/rackerlabs/repose"},{"original_method":"public DartCommandLineBreakpointsHandler(DartCommandLineDebugProcess process) {\n    myDebugProcess = process;\n\n    List<XBreakpointHandler> handlers = new ArrayList<XBreakpointHandler>(2);\n    handlers.add(new XBreakpointHandler<XLineBreakpoint<XBreakpointProperties>>(JavaScriptBreakpointType.class) {\n      public void registerBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint) {\n        final XSourcePosition position = breakpoint.getSourcePosition();\n        if (position == null)  return;\n        if (position.getFile().getFileType() != DartFileType.INSTANCE) return;\n\n        myDebugProcess.sendCommand(getSetBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n          @Override\n          public boolean processResponse(JsonResponse response) {\n            if (response.getJsonObject().get(\"error\") != null) {\n              myDebugProcess.getSession().updateBreakpointPresentation(breakpoint, AllIcons.Debugger.Db_invalid_breakpoint, null);\n              return true;\n            }\n            final JsonObject result = response.getJsonObject().get(\"result\").getAsJsonObject();\n            final int id = result.get(\"breakpointId\").getAsInt();\n            myBreakpointToIndexMap.put(breakpoint, id);\n            myIndexToBreakpointMap.put(id, breakpoint);\n            myDebugProcess.getSession().updateBreakpointPresentation(breakpoint, AllIcons.Debugger.Db_verified_breakpoint, null);\n            return true;\n          }\n        });\n      }\n\n      private boolean isValidSourceBreakpoint(XSourcePosition position) {\n        ProjectFileIndex projectFileIndex = ProjectRootManager.getInstance(myDebugProcess.getSession().getProject()).getFileIndex();\n        VirtualFile rootForFile = projectFileIndex.getSourceRootForFile(position.getFile());\n        return rootForFile != null;\n      }\n\n      public void unregisterBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint, final boolean temporary) {\n        final XSourcePosition position = breakpoint.getSourcePosition();\n        if (position != null && isValidSourceBreakpoint(position)) {\n          myDebugProcess.sendCommand(getRemoveBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n            @Override\n            public boolean processResponse(JsonResponse response) {\n              final Integer id = myBreakpointToIndexMap.remove(breakpoint);\n              if (myIndexToBreakpointMap.containsKey(id)) {\n                myIndexToBreakpointMap.remove(id);\n              }\n              return true;\n            }\n          });\n        }\n      }\n    });\n\n    myBreakpointHandlers = handlers.toArray(new XBreakpointHandler<?>[handlers.size()]);\n  }","id":42988,"modified_method":"public DartCommandLineBreakpointsHandler(DartCommandLineDebugProcess process) {\n    myDebugProcess = process;\n\n    List<XBreakpointHandler> handlers = new ArrayList<XBreakpointHandler>(2);\n    handlers.add(new XBreakpointHandler<XLineBreakpoint<XBreakpointProperties>>(JavaScriptBreakpointType.class) {\n      public void registerBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint) {\n        final XSourcePosition position = breakpoint.getSourcePosition();\n        if (position == null) return;\n        if (position.getFile().getFileType() != DartFileType.INSTANCE) return;\n\n        myDebugProcess.sendCommand(getSetBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n          @Override\n          public boolean processResponse(JsonResponse response) {\n            if (response.getJsonObject().get(\"error\") != null) {\n              myDebugProcess.getSession().updateBreakpointPresentation(breakpoint, AllIcons.Debugger.Db_invalid_breakpoint, null);\n              return true;\n            }\n            final JsonObject result = response.getJsonObject().get(\"result\").getAsJsonObject();\n            final int id = result.get(\"breakpointId\").getAsInt();\n            myBreakpointToIndexMap.put(breakpoint, id);\n            myIndexToBreakpointMap.put(id, breakpoint);\n            myDebugProcess.getSession().updateBreakpointPresentation(breakpoint, AllIcons.Debugger.Db_verified_breakpoint, null);\n            return true;\n          }\n        });\n      }\n\n      public void unregisterBreakpoint(@NotNull final XLineBreakpoint<XBreakpointProperties> breakpoint, final boolean temporary) {\n        final XSourcePosition position = breakpoint.getSourcePosition();\n        if (position == null) return;\n        if (position.getFile().getFileType() != DartFileType.INSTANCE) return;\n\n        myDebugProcess.sendCommand(getRemoveBreakpointCommand(breakpoint), new AbstractResponseToRequestHandler<JsonResponse>() {\n          @Override\n          public boolean processResponse(JsonResponse response) {\n            final Integer id = myBreakpointToIndexMap.remove(breakpoint);\n            if (myIndexToBreakpointMap.containsKey(id)) {\n              myIndexToBreakpointMap.remove(id);\n            }\n            return true;\n          }\n        });\n      }\n    });\n\n    myBreakpointHandlers = handlers.toArray(new XBreakpointHandler<?>[handlers.size()]);\n  }","commit_id":"516a2a7c275b2e3fb6d93486942d13c36e5d14cc","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static JsonObject getParams(XLineBreakpoint<XBreakpointProperties> breakpoint) {\n    final JsonObject result = new JsonObject();\n    result.addProperty(\"url\", breakpoint.getFileUrl());\n    result.addProperty(\"line\", breakpoint.getLine() + 1);\n    return result;\n  }","id":42989,"modified_method":"private static JsonObject getParams(XLineBreakpoint<XBreakpointProperties> breakpoint) {\n    final JsonObject result = new JsonObject();\n    result.addProperty(\"url\", DartCommandLineDebugProcess.fixFileUrl(breakpoint.getFileUrl()));\n    result.addProperty(\"line\", breakpoint.getLine() + 1);\n    return result;\n  }","commit_id":"516a2a7c275b2e3fb6d93486942d13c36e5d14cc","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static void handleRunToPosition(XSourcePosition position, DartCommandLineDebugProcess process) {\n    final JsonObject command = new JsonObject();\n    command.addProperty(\"command\", \"setBreakpoint\");\n    final JsonObject params = new JsonObject();\n    params.addProperty(\"url\", position.getFile().getUrl());\n    params.addProperty(\"line\", position.getLine());\n    command.add(\"params\", params);\n\n    process.sendCommand(command);\n    process.resume();\n  }","id":42990,"modified_method":"public static void handleRunToPosition(XSourcePosition position, DartCommandLineDebugProcess process) {\n    final JsonObject command = new JsonObject();\n    command.addProperty(\"command\", \"setBreakpoint\");\n    final JsonObject params = new JsonObject();\n    params.addProperty(\"url\", DartCommandLineDebugProcess.fixFileUrl(position.getFile().getUrl()));\n    params.addProperty(\"line\", position.getLine());\n    command.add(\"params\", params);\n\n    process.sendCommand(command);\n    process.resume();\n  }","commit_id":"516a2a7c275b2e3fb6d93486942d13c36e5d14cc","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void initLines(List<DartStackFrame> frames, Runnable runnable) {\n    for (DartStackFrame stackFrame : frames) {\n      JsonObject command = getCommandObject(\"getLineNumberTable\");\n      command.addProperty(\"url\", stackFrame.getFileUrl());\n      sendCommand(command);\n    }\n    runnable.run();\n  }","id":42991,"modified_method":"private void initLines(List<DartStackFrame> frames, Runnable runnable) {\n    for (DartStackFrame stackFrame : frames) {\n      JsonObject command = getCommandObject(\"getLineNumberTable\");\n      command.addProperty(\"url\", fixFileUrl(stackFrame.getFileUrl()));\n      sendCommand(command);\n    }\n    runnable.run();\n  }","commit_id":"516a2a7c275b2e3fb6d93486942d13c36e5d14cc","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static void requestLines(DartCommandLineDebugProcess debugProcess,\n                                  @NotNull List<DartStackFrame> stackFrames,\n                                  @Nullable final Runnable after) {\n    if (stackFrames.isEmpty() && after != null) {\n      after.run();\n      return;\n    }\n    for (int i = 0; i < stackFrames.size(); i++) {\n      final DartStackFrame stackFrame = stackFrames.get(i);\n      JsonObject commandObject = DartCommandLineDebugProcess.getCommandObject(\"getLineNumberTable\");\n      JsonObject params = new JsonObject();\n      params.addProperty(\"url\", stackFrame.getFileUrl());\n      params.addProperty(\"libraryId\", stackFrame.getLibraryId());\n      commandObject.add(\"params\", params);\n      final boolean isLast = i == stackFrames.size() - 1;\n      debugProcess.sendCommand(commandObject, new AbstractResponseToRequestHandler<JsonResponse>() {\n        @Override\n        public boolean processResponse(JsonResponse response) {\n          if (response.getJsonObject().get(\"error\") == null) {\n            JsonObject result = response.getJsonObject().get(\"result\").getAsJsonObject();\n            JsonArray lines = result.get(\"lines\").getAsJsonArray();\n            stackFrame.setLine(findLineByOffset(lines, stackFrame.getOffset()) - 1);\n          }\n          if (isLast && after != null) {\n            after.run();\n          }\n          return true;\n        }\n      });\n    }\n  }","id":42992,"modified_method":"public static void requestLines(DartCommandLineDebugProcess debugProcess,\n                                  @NotNull List<DartStackFrame> stackFrames,\n                                  @Nullable final Runnable after) {\n    if (stackFrames.isEmpty() && after != null) {\n      after.run();\n      return;\n    }\n    for (int i = 0; i < stackFrames.size(); i++) {\n      final DartStackFrame stackFrame = stackFrames.get(i);\n      JsonObject commandObject = DartCommandLineDebugProcess.getCommandObject(\"getLineNumberTable\");\n      JsonObject params = new JsonObject();\n      params.addProperty(\"url\", DartCommandLineDebugProcess.fixFileUrl(stackFrame.getFileUrl()));\n      params.addProperty(\"libraryId\", stackFrame.getLibraryId());\n      commandObject.add(\"params\", params);\n      final boolean isLast = i == stackFrames.size() - 1;\n      debugProcess.sendCommand(commandObject, new AbstractResponseToRequestHandler<JsonResponse>() {\n        @Override\n        public boolean processResponse(JsonResponse response) {\n          if (response.getJsonObject().get(\"error\") == null) {\n            JsonObject result = response.getJsonObject().get(\"result\").getAsJsonObject();\n            JsonArray lines = result.get(\"lines\").getAsJsonArray();\n            stackFrame.setLine(findLineByOffset(lines, stackFrame.getOffset()) - 1);\n          }\n          if (isLast && after != null) {\n            after.run();\n          }\n          return true;\n        }\n      });\n    }\n  }","commit_id":"516a2a7c275b2e3fb6d93486942d13c36e5d14cc","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Creates a rounded avatar image.\n     * \n     * @param avatarBytes The bytes of the initial avatar image.\n     * \n     * @return The rounded corner image.\n     */\n    private Image createRoundImage(byte[] avatarBytes)\n    {\n        BufferedImage destImage\n            = new BufferedImage(AVATAR_ICON_WIDTH,\n                                AVATAR_ICON_HEIGHT,\n                                BufferedImage.TYPE_INT_ARGB);\n\n        BufferedImage avatarImage;\n\n        try\n        {\n            InputStream in = new ByteArrayInputStream(avatarBytes);\n            avatarImage = ImageIO.read(in);\n\n            Graphics2D g = destImage.createGraphics();\n            AntialiasingManager.activateAntialiasing(g);\n            g.setColor(Color.WHITE);\n            g.fillRoundRect(0, 0, AVATAR_ICON_WIDTH, AVATAR_ICON_HEIGHT, 10, 10);\n            g.setComposite(AlphaComposite.SrcIn);\n\n            g.drawImage(avatarImage\n                .getScaledInstance( AVATAR_ICON_WIDTH,\n                                    AVATAR_ICON_HEIGHT,\n                                    Image.SCALE_SMOOTH), 0, 0, null);\n\n            return destImage;\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Could not create image.\", e);\n        }\n\n        return null;\n    }","id":42993,"modified_method":"/**\n     * Creates a rounded avatar image.\n     * \n     * @param avatarBytes The bytes of the initial avatar image.\n     * \n     * @return The rounded corner image.\n     */\n    private Image createRoundImage(byte[] avatarBytes)\n    {\n        BufferedImage destImage = null;\n\n        try\n        {\n            InputStream in = new ByteArrayInputStream(avatarBytes);\n            BufferedImage avatarImage = ImageIO.read(in);\n\n            Image scaledImage = avatarImage.getScaledInstance(\n                                                            -1,\n                                                            AVATAR_ICON_HEIGHT,\n                                                            Image.SCALE_SMOOTH);\n\n            destImage\n                = new BufferedImage(scaledImage.getWidth(null),\n                                    AVATAR_ICON_HEIGHT,\n                                    BufferedImage.TYPE_INT_ARGB);\n\n            Graphics2D g = destImage.createGraphics();\n            AntialiasingManager.activateAntialiasing(g);\n            g.setColor(Color.WHITE);\n            g.fillRoundRect(0, 0, \n                            scaledImage.getWidth(null),\n                            AVATAR_ICON_HEIGHT,\n                            10, 10);\n            g.setComposite(AlphaComposite.SrcIn);\n\n            g.drawImage(scaledImage, 0, 0, null);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Could not create image.\", e);\n        }\n\n        return destImage;\n    }","commit_id":"f2535b8934cdc3b5fb1b3962f68c3bf47f49dd53","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a rounded avatar image.\n     * \n     * @param avatarBytes The bytes of the initial avatar image.\n     * \n     * @return The rounded corner image.\n     */\n    private Image createRoundImage(byte[] avatarBytes)\n    {\n        BufferedImage destImage\n            = new BufferedImage(25, 30, BufferedImage.TYPE_INT_ARGB);\n\n        BufferedImage avatarImage;\n\n        try\n        {\n            InputStream in = new ByteArrayInputStream(avatarBytes);\n            avatarImage = ImageIO.read(in);\n\n            Graphics2D g = destImage.createGraphics();\n            AntialiasingManager.activateAntialiasing(g);\n            g.setColor(Color.WHITE);\n            g.fillRoundRect(0, 0, 25, 30, 10, 10);\n            g.setComposite(AlphaComposite.SrcIn);\n\n            g.drawImage(avatarImage\n                .getScaledInstance(25, 30, Image.SCALE_SMOOTH), 0, 0, null);\n\n            return destImage;\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Could not create image.\", e);\n        }\n\n        return null;\n    }","id":42994,"modified_method":"/**\n     * Creates a rounded avatar image.\n     * \n     * @param avatarBytes The bytes of the initial avatar image.\n     * \n     * @return The rounded corner image.\n     */\n    private Image createRoundImage(byte[] avatarBytes)\n    {\n        BufferedImage destImage = null;\n\n        try\n        {\n            InputStream in = new ByteArrayInputStream(avatarBytes);\n            BufferedImage avatarImage = ImageIO.read(in);\n\n            Image scaledImage = avatarImage.getScaledInstance(\n                                                            -1,\n                                                            AVATAR_HEIGHT,\n                                                            Image.SCALE_SMOOTH);\n\n            destImage\n                = new BufferedImage(scaledImage.getWidth(null),\n                                    AVATAR_HEIGHT,\n                                    BufferedImage.TYPE_INT_ARGB);\n\n            Graphics2D g = destImage.createGraphics();\n            AntialiasingManager.activateAntialiasing(g);\n            g.setColor(Color.WHITE);\n            g.fillRoundRect(0, 0, \n                            scaledImage.getWidth(null),\n                            AVATAR_HEIGHT,\n                            10, 10);\n            g.setComposite(AlphaComposite.SrcIn);\n\n            g.drawImage(scaledImage, 0, 0, null);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Could not create image.\", e);\n        }\n\n        return destImage;\n    }","commit_id":"f2535b8934cdc3b5fb1b3962f68c3bf47f49dd53","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static Image createImageFromSvg(SVGDiagram svg, Dimension dim) {\n        float realWidth = svg.getWidth();\n        float realHeight = svg.getHeight();\n        int width = Math.round(realWidth);\n        int height = Math.round(realHeight);\n        Double scaleX = null, scaleY = null;\n        if (dim.width != -1) {\n            width = dim.width;\n            scaleX = (double) width / realWidth;\n            if (dim.height == -1) {\n                scaleY = scaleX;\n                height = (int) Math.round(realHeight * scaleY);\n            } else {\n                height = dim.height;\n                scaleY = (double) height / realHeight;\n            }\n        } else if (dim.height != -1) {\n            height = dim.height;\n            scaleX = scaleY = (double) height / realHeight;\n            width = (int) Math.round(realWidth * scaleX);\n        }\n        Image img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g = ((BufferedImage) img).createGraphics();\n        g.setClip(0, 0, width, height);\n        if (scaleX != null) {\n            g.scale(scaleX, scaleY);\n        }\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        try {\n            svg.render(g);\n        } catch (SVGException ex) {\n            return null;\n        }\n        return img;\n    }","id":42995,"modified_method":"public static BufferedImage createImageFromSvg(SVGDiagram svg, Dimension dim) {\n        float realWidth = svg.getWidth();\n        float realHeight = svg.getHeight();\n        int width = Math.round(realWidth);\n        int height = Math.round(realHeight);\n        Double scaleX = null, scaleY = null;\n        if (dim.width != -1) {\n            width = dim.width;\n            scaleX = (double) width / realWidth;\n            if (dim.height == -1) {\n                scaleY = scaleX;\n                height = (int) Math.round(realHeight * scaleY);\n            } else {\n                height = dim.height;\n                scaleY = (double) height / realHeight;\n            }\n        } else if (dim.height != -1) {\n            height = dim.height;\n            scaleX = scaleY = (double) height / realHeight;\n            width = (int) Math.round(realWidth * scaleX);\n        }\n        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g = img.createGraphics();\n        g.setClip(0, 0, width, height);\n        if (scaleX != null) {\n            g.scale(scaleX, scaleY);\n        }\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        try {\n            svg.render(g);\n        } catch (SVGException ex) {\n            return null;\n        }\n        return img;\n    }","commit_id":"790715a1e7ab8eb42e4a83c670258a60b1bd5004","url":"https://github.com/openstreetmap/josm"},{"original_method":"private ImageResource getIfAvailableImpl() {\n        if (name == null)\n            return null;\n\n        try {\n            if (name.startsWith(\"data:\")) {\n                Matcher m = dataUrlPattern.matcher(name);\n                if (m.matches()) {\n                    String mediatype = m.group(1);\n                    String base64 = m.group(2);\n                    String data = m.group(3);\n                    byte[] bytes = \";base64\".equals(base64)\n                            ? Base64.decodeBase64(data)\n                            : URLDecoder.decode(data, \"utf-8\").getBytes();\n                    if (mediatype != null && mediatype.contains(\"image/svg+xml\")) {\n                        URI uri = getSvgUniverse().loadSVG(new StringReader(new String(bytes)), name);\n                        return new ImageResource(getSvgUniverse().getDiagram(uri));\n                    } else {\n                        return new ImageResource(new ImageIcon(bytes).getImage());\n                    }\n                }\n            }\n        } catch (UnsupportedEncodingException ex) {\n            throw new RuntimeException(ex.getMessage(), ex);\n        } catch (IOException ex) {\n            throw new RuntimeException(ex.getMessage(), ex);\n        }\n\n        ImageType type = name.toLowerCase().endsWith(\".svg\") ? ImageType.SVG : ImageType.OTHER;\n\n        if (name.startsWith(\"http://\")) {\n            String url = name;\n            ImageResource ir = cache.get(url);\n            if (ir != null) return ir;\n            ir = getIfAvailableHttp(url, type);\n            if (ir != null) {\n                cache.put(url, ir);\n            }\n            return ir;\n        } else if (name.startsWith(\"wiki://\")) {\n            ImageResource ir = cache.get(name);\n            if (ir != null) return ir;\n            ir = getIfAvailableWiki(name, type);\n            if (ir != null) {\n                cache.put(name, ir);\n            }\n            return ir;\n        }\n\n        if (subdir == null) {\n            subdir = \"\";\n        } else if (!subdir.equals(\"\")) {\n            subdir += \"/\";\n        }\n        String[] extensions;\n        if (name.indexOf('.') != -1) {\n            extensions = new String[] { \"\" };\n        } else {\n            extensions = new String[] { \".png\", \".svg\"};\n        }\n        final int ARCHIVE = 0, LOCAL = 1;\n        for (int place : new Integer[] { ARCHIVE, LOCAL }) {\n            for (String ext : extensions) {\n\n                if (\".svg\".equals(ext)) {\n                    type = ImageType.SVG;\n                } else if (\".png\".equals(ext)) {\n                    type = ImageType.OTHER;\n                }\n\n                String full_name = subdir + name + ext;\n                String cache_name = full_name;\n                /* cache separately */\n                if (dirs != null && dirs.size() > 0) {\n                    cache_name = \"id:\" + id + \":\" + full_name;\n                    if(archive != null) {\n                        cache_name += \":\" + archive.getName();\n                    }\n                }\n\n                ImageResource ir = cache.get(cache_name);\n                if (ir != null) return ir;\n\n                switch (place) {\n                    case ARCHIVE:\n                        if (archive != null) {\n                            ir = getIfAvailableZip(full_name, archive, type);\n                            if (ir != null) {\n                                cache.put(cache_name, ir);\n                                return ir;\n                            }\n                        }\n                        break;\n                    case LOCAL:\n                        // getImageUrl() does a ton of \"stat()\" calls and gets expensive\n                        // and redundant when you have a whole ton of objects. So,\n                        // index the cache by the name of the icon we're looking for\n                        // and don't bother to create a URL unless we're actually\n                        // creating the image.\n                        URL path = getImageUrl(full_name, dirs);\n                        if (path == null) {\n                            continue;\n                        }\n                        ir = getIfAvailableLocalURL(path, type);\n                        if (ir != null) {\n                            cache.put(cache_name, ir);\n                            return ir;\n                        }\n                        break;\n                }\n            }\n        }\n        return null;\n    }","id":42996,"modified_method":"private ImageResource getIfAvailableImpl() {\n        if (name == null)\n            return null;\n\n        try {\n            if (name.startsWith(\"data:\")) {\n                Matcher m = dataUrlPattern.matcher(name);\n                if (m.matches()) {\n                    String mediatype = m.group(1);\n                    String base64 = m.group(2);\n                    String data = m.group(3);\n                    byte[] bytes = \";base64\".equals(base64)\n                            ? Base64.decodeBase64(data)\n                            : URLDecoder.decode(data, \"utf-8\").getBytes();\n                    if (mediatype != null && mediatype.contains(\"image/svg+xml\")) {\n                        URI uri = getSvgUniverse().loadSVG(new StringReader(new String(bytes)), name);\n                        return new ImageResource(getSvgUniverse().getDiagram(uri));\n                    } else {\n                        try {\n                            return new ImageResource(ImageIO.read(new ByteArrayInputStream(bytes)));\n                        } catch (IOException e) {}\n                    }\n                }\n            }\n        } catch (UnsupportedEncodingException ex) {\n            throw new RuntimeException(ex.getMessage(), ex);\n        } catch (IOException ex) {\n            throw new RuntimeException(ex.getMessage(), ex);\n        }\n\n        ImageType type = name.toLowerCase().endsWith(\".svg\") ? ImageType.SVG : ImageType.OTHER;\n\n        if (name.startsWith(\"http://\")) {\n            String url = name;\n            ImageResource ir = cache.get(url);\n            if (ir != null) return ir;\n            ir = getIfAvailableHttp(url, type);\n            if (ir != null) {\n                cache.put(url, ir);\n            }\n            return ir;\n        } else if (name.startsWith(\"wiki://\")) {\n            ImageResource ir = cache.get(name);\n            if (ir != null) return ir;\n            ir = getIfAvailableWiki(name, type);\n            if (ir != null) {\n                cache.put(name, ir);\n            }\n            return ir;\n        }\n\n        if (subdir == null) {\n            subdir = \"\";\n        } else if (!subdir.equals(\"\")) {\n            subdir += \"/\";\n        }\n        String[] extensions;\n        if (name.indexOf('.') != -1) {\n            extensions = new String[] { \"\" };\n        } else {\n            extensions = new String[] { \".png\", \".svg\"};\n        }\n        final int ARCHIVE = 0, LOCAL = 1;\n        for (int place : new Integer[] { ARCHIVE, LOCAL }) {\n            for (String ext : extensions) {\n\n                if (\".svg\".equals(ext)) {\n                    type = ImageType.SVG;\n                } else if (\".png\".equals(ext)) {\n                    type = ImageType.OTHER;\n                }\n\n                String full_name = subdir + name + ext;\n                String cache_name = full_name;\n                /* cache separately */\n                if (dirs != null && dirs.size() > 0) {\n                    cache_name = \"id:\" + id + \":\" + full_name;\n                    if(archive != null) {\n                        cache_name += \":\" + archive.getName();\n                    }\n                }\n\n                ImageResource ir = cache.get(cache_name);\n                if (ir != null) return ir;\n\n                switch (place) {\n                    case ARCHIVE:\n                        if (archive != null) {\n                            ir = getIfAvailableZip(full_name, archive, type);\n                            if (ir != null) {\n                                cache.put(cache_name, ir);\n                                return ir;\n                            }\n                        }\n                        break;\n                    case LOCAL:\n                        // getImageUrl() does a ton of \"stat()\" calls and gets expensive\n                        // and redundant when you have a whole ton of objects. So,\n                        // index the cache by the name of the icon we're looking for\n                        // and don't bother to create a URL unless we're actually\n                        // creating the image.\n                        URL path = getImageUrl(full_name, dirs);\n                        if (path == null) {\n                            continue;\n                        }\n                        ir = getIfAvailableLocalURL(path, type);\n                        if (ir != null) {\n                            cache.put(cache_name, ir);\n                            return ir;\n                        }\n                        break;\n                }\n            }\n        }\n        return null;\n    }","commit_id":"790715a1e7ab8eb42e4a83c670258a60b1bd5004","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Get image icon with a certain maximum size. The image is scaled down\n     * to fit maximum dimensions. (Keeps aspect ratio)\n     *\n     * @param maxSize The maximum size. One of the dimensions (widht or height) can be -1,\n     * which means it is not bounded.\n     */\n    public ImageIcon getImageIconBounded(Dimension maxSize) {\n        if (maxSize.width < -1 || maxSize.width == 0 || maxSize.height < -1 || maxSize.height == 0)\n            throw new IllegalArgumentException();\n        float realWidth;\n        float realHeight;\n        if (svg != null) {\n            realWidth = svg.getWidth();\n            realHeight = svg.getHeight();\n        } else {\n            Image base = imgCache.get(DEFAULT_DIMENSION);\n            if (base == null) throw new AssertionError();\n            ImageIcon icon = new ImageIcon(base);\n            realWidth = icon.getIconWidth();\n            realHeight = icon.getIconHeight();\n        }\n        int maxWidth = maxSize.width;\n        int maxHeight = maxSize.height;\n\n        if (realWidth <= maxWidth) {\n            maxWidth = -1;\n        }\n        if (realHeight <= maxHeight) {\n            maxHeight = -1;\n        }\n\n        if (maxWidth == -1 && maxHeight == -1)\n            return getImageIcon(DEFAULT_DIMENSION);\n        else if (maxWidth == -1)\n            return getImageIcon(new Dimension(-1, maxHeight));\n        else if (maxHeight == -1)\n            return getImageIcon(new Dimension(maxWidth, -1));\n        else\n            if (realWidth / maxWidth > realHeight / maxHeight)\n                return getImageIcon(new Dimension(maxWidth, -1));\n            else\n                return getImageIcon(new Dimension(-1, maxHeight));\n   }","id":42997,"modified_method":"/**\n     * Get image icon with a certain maximum size. The image is scaled down\n     * to fit maximum dimensions. (Keeps aspect ratio)\n     *\n     * @param maxSize The maximum size. One of the dimensions (widht or height) can be -1,\n     * which means it is not bounded.\n     */\n    public ImageIcon getImageIconBounded(Dimension maxSize) {\n        if (maxSize.width < -1 || maxSize.width == 0 || maxSize.height < -1 || maxSize.height == 0)\n            throw new IllegalArgumentException();\n        float realWidth;\n        float realHeight;\n        if (svg != null) {\n            realWidth = svg.getWidth();\n            realHeight = svg.getHeight();\n        } else {\n            BufferedImage base = imgCache.get(DEFAULT_DIMENSION);\n            if (base == null) throw new AssertionError();\n            ImageIcon icon = new ImageIcon(base);\n            realWidth = icon.getIconWidth();\n            realHeight = icon.getIconHeight();\n        }\n        int maxWidth = maxSize.width;\n        int maxHeight = maxSize.height;\n\n        if (realWidth <= maxWidth) {\n            maxWidth = -1;\n        }\n        if (realHeight <= maxHeight) {\n            maxHeight = -1;\n        }\n\n        if (maxWidth == -1 && maxHeight == -1)\n            return getImageIcon(DEFAULT_DIMENSION);\n        else if (maxWidth == -1)\n            return getImageIcon(new Dimension(-1, maxHeight));\n        else if (maxHeight == -1)\n            return getImageIcon(new Dimension(maxWidth, -1));\n        else\n            if (realWidth / maxWidth > realHeight / maxHeight)\n                return getImageIcon(new Dimension(maxWidth, -1));\n            else\n                return getImageIcon(new Dimension(-1, maxHeight));\n   }","commit_id":"790715a1e7ab8eb42e4a83c670258a60b1bd5004","url":"https://github.com/openstreetmap/josm"},{"original_method":"public ImageResource(Image img) {\n        CheckParameterUtil.ensureParameterNotNull(img);\n        imgCache.put(DEFAULT_DIMENSION, img);\n    }","id":42998,"modified_method":"public ImageResource(BufferedImage img) {\n        CheckParameterUtil.ensureParameterNotNull(img);\n        imgCache.put(DEFAULT_DIMENSION, img);\n    }","commit_id":"790715a1e7ab8eb42e4a83c670258a60b1bd5004","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Get an ImageIcon object for the image of this resource\n     * @param   dim The requested dimensions. Use (-1,-1) for the original size\n     *          and (width, -1) to set the width, but otherwise scale the image\n     *          proportionally.\n     */\n    public ImageIcon getImageIcon(Dimension dim) {\n        if (dim.width < -1 || dim.width == 0 || dim.height < -1 || dim.height == 0)\n            throw new IllegalArgumentException();\n        Image img = imgCache.get(dim);\n        if (img != null) {\n            return new ImageIcon(img);\n        }\n        if (svg != null) {\n            img = ImageProvider.createImageFromSvg(svg, dim);\n            imgCache.put(dim, img);\n            return new ImageIcon(img);\n        } else {\n            Image base = imgCache.get(DEFAULT_DIMENSION);\n            if (base == null) throw new AssertionError();\n            \n            int width = dim.width;\n            int height = dim.height;\n            ImageIcon icon = new ImageIcon(base);\n            if (width == -1) {\n                width = icon.getIconWidth() * height / icon.getIconHeight();\n            } else if (height == -1) {\n                height = icon.getIconHeight() * width / icon.getIconWidth();\n            }\n            img = icon.getImage().getScaledInstance(width, height, Image.SCALE_SMOOTH);\n            imgCache.put(dim, img);\n            return new ImageIcon(img);\n        }\n    }","id":42999,"modified_method":"/**\n     * Get an ImageIcon object for the image of this resource\n     * @param   dim The requested dimensions. Use (-1,-1) for the original size\n     *          and (width, -1) to set the width, but otherwise scale the image\n     *          proportionally.\n     */\n    public ImageIcon getImageIcon(Dimension dim) {\n        if (dim.width < -1 || dim.width == 0 || dim.height < -1 || dim.height == 0)\n            throw new IllegalArgumentException();\n        BufferedImage img = imgCache.get(dim);\n        if (img != null) {\n            return new ImageIcon(img);\n        }\n        if (svg != null) {\n            img = ImageProvider.createImageFromSvg(svg, dim);\n            imgCache.put(dim, img);\n            return new ImageIcon(img);\n        } else {\n            BufferedImage base = imgCache.get(DEFAULT_DIMENSION);\n            if (base == null) throw new AssertionError();\n            \n            int width = dim.width;\n            int height = dim.height;\n            ImageIcon icon = new ImageIcon(base);\n            if (width == -1) {\n                width = icon.getIconWidth() * height / icon.getIconHeight();\n            } else if (height == -1) {\n                height = icon.getIconHeight() * width / icon.getIconWidth();\n            }\n            Image i = icon.getImage().getScaledInstance(width, height, Image.SCALE_SMOOTH);\n            img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n            img.getGraphics().drawImage(i, 0, 0, null);\n            imgCache.put(dim, img);\n            return new ImageIcon(img);\n        }\n    }","commit_id":"790715a1e7ab8eb42e4a83c670258a60b1bd5004","url":"https://github.com/openstreetmap/josm"}]