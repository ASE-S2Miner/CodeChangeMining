[{"original_method":"@Override\n    public void testGetObjectClass() throws Exception\n    {\n        SingletonObjectFactory factory = (SingletonObjectFactory) getObjectFactory();\n        factory.setObjectClass(Object.class);\n        factory.setMuleContext(muleContext);\n        factory.initialise();\n        assertEquals(Object.class, factory.getObjectClass());\n    }","id":9000,"modified_method":"@Override\n    public void testGetObjectClass() throws Exception\n    {\n        SingletonObjectFactory factory = (SingletonObjectFactory) getUninitialisedObjectFactory();\n        factory.setObjectClass(Object.class);\n        factory.setMuleContext(muleContext);\n        factory.initialise();\n        \n        assertEquals(Object.class, factory.getObjectClass());\n    }","commit_id":"1befc2f2bdd37d580d6693da2d706680cd0e44f6","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public ObjectFactory getObjectFactory()\n    {\n        return new SingletonObjectFactory();\n    }","id":9001,"modified_method":"@Override\n    public AbstractObjectFactory getUninitialisedObjectFactory()\n    {\n        return new SingletonObjectFactory();\n    }","commit_id":"1befc2f2bdd37d580d6693da2d706680cd0e44f6","url":"https://github.com/mulesoft/mule"},{"original_method":"/** \n     * Converts the passed object to the named simple type; supported types\n     * include: String, Boolean, Double, Float, Long, Integer, Date (java.sql.Date),\n     * Time, Timestamp, TimeZone;\n     * @param obj Object to convert\n     * @param type Name of type to convert to\n     * @param format Optional (can be null) format string for Date, Time, Timestamp\n     * @param timeZone Optional (can be null) TimeZone for converting dates and times\n     * @param locale Optional (can be null) Locale for formatting and parsing Double, Float, Long, Integer\n     * @param noTypeFail Fail (Exception) when no type conversion is available, false will return the primary object\n     * @return\n     * @throws GeneralException\n     */\n    public static Object simpleTypeConvert(Object obj, String type, String format, TimeZone timeZone, Locale locale, boolean noTypeFail) throws GeneralException {\n        if (obj == null) {\n            return null;\n        }\n\n        if (obj.getClass().getName().equals(type)) {\n            return obj;\n        }\n        if (\"PlainString\".equals(type)) {\n            return obj.toString();\n        }\n        if (\"Object\".equals(type) || \"java.lang.Object\".equals(type)) {\n            return obj;\n        }\n\n        String fromType = null;\n\n        if ((type.equals(\"List\") || type.equals(\"java.util.List\")) && obj.getClass().isArray()) {\n            List newObj = FastList.newInstance();\n            int len = Array.getLength(obj);\n            for (int i = 0; i < len; i++) {\n                newObj.add(Array.get(obj, i));\n            }\n            return newObj;        \n        } else if (obj instanceof java.lang.String) {\n            fromType = \"String\";\n            String str = (String) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return obj;\n            }\n            if (str.length() == 0) {\n                return null;\n            }\n            \n            if (\"Boolean\".equals(type) || \"java.lang.Boolean\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                return str.equalsIgnoreCase(\"TRUE\") ? Boolean.TRUE : Boolean.FALSE;\n            } else if (\"Locale\".equals(type) || \"java.util.Locale\".equals(type)) {\n                Locale loc = UtilMisc.parseLocale(str);\n                if (loc != null) {\n                    return loc;\n                } else {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \");    \n                }\n            } else if (\"TimeZone\".equals(type) || \"java.util.TimeZone\".equals(type)) {\n                TimeZone tz = UtilDateTime.toTimeZone(str);\n                if (tz != null) {\n                    return tz;\n                } else {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \");    \n                }\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    Number tempNum = nf.parse(str);\n                    return new BigDecimal(tempNum.toString());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    Number tempNum = nf.parse(str);\n\n                    return new Double(tempNum.doubleValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    Number tempNum = nf.parse(str);\n\n                    return new Float(tempNum.floatValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    nf.setMaximumFractionDigits(0);\n                    Number tempNum = nf.parse(str);\n\n                    return new Long(tempNum.longValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    nf.setMaximumFractionDigits(0);\n                    Number tempNum = nf.parse(str);\n\n                    return new Integer(tempNum.intValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateFormat(UtilDateTime.DATE_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toDateFormat(format, timeZone, null);\n                }\n                try {\n                    Date fieldDate = df.parse(str);\n                    return new java.sql.Date(fieldDate.getTime());\n                } catch (ParseException e1) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e1);\n                }\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toTimeFormat(UtilDateTime.TIME_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toTimeFormat(format, timeZone, null);\n                }\n                try {\n                    Date fieldDate = df.parse(str);\n                    return new java.sql.Time(fieldDate.getTime());\n                } catch (ParseException e1) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e1);\n                }\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateTimeFormat(UtilDateTime.DATE_TIME_FORMAT, timeZone, null);\n                    // hack to mimic Timestamp.valueOf() method\n                    if (str.length() > 0 && !str.contains(\".\")) {\n                        str = str + \".0\";\n                    }\n                } else {\n                    df = UtilDateTime.toDateTimeFormat(format, timeZone, null);\n                }\n                try {\n                    Date fieldDate = df.parse(str);\n                    return new java.sql.Timestamp(fieldDate.getTime());\n                } catch (ParseException e1) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e1);\n                }\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n                    return StringUtil.toList(str);\n                } else {\n                    List tempList = FastList.newInstance();\n                    tempList.add(str);\n                    return tempList;\n                }\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n                    return StringUtil.toSet(str);\n                } else {\n                    Set tempSet = FastSet.newInstance();\n                    tempSet.add(str);\n                    return tempSet;\n                }\n            } else if ((\"Map\".equals(type) || \"java.util.Map\".equals(type)) &&\n                    (str.startsWith(\"{\") && str.endsWith(\"}\"))) {\n                return StringUtil.toMap(str);\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Double) {\n            fromType = \"Double\";\n            Double dbl = (Double) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(dbl.doubleValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return new BigDecimal(dbl.doubleValue());\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return obj;\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return new Float(dbl.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return new Long(Math.round(dbl.doubleValue()));\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return new Integer((int) Math.round(dbl.doubleValue()));\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(dbl);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(dbl);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Float) {\n            fromType = \"Float\";\n            Float flt = (Float) obj;\n\n            if (\"String\".equals(type)) {\n                NumberFormat nf = null;\n\n                if (locale == null)\n                    nf = NumberFormat.getNumberInstance();\n                else\n                    nf = NumberFormat.getNumberInstance(locale);\n                return nf.format(flt.doubleValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return new BigDecimal(flt.doubleValue());\n            } else if (\"Double\".equals(type)) {\n                return new Double(flt.doubleValue());\n            } else if (\"Float\".equals(type)) {\n                return obj;\n            } else if (\"Long\".equals(type)) {\n                return new Long(Math.round(flt.doubleValue()));\n            } else if (\"Integer\".equals(type)) {\n                return new Integer((int) Math.round(flt.doubleValue()));\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(flt);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(flt);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Long) {\n            fromType = \"Long\";\n            Long lng = (Long) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(lng.longValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return BigDecimal.valueOf(lng.longValue());\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return new Double(lng.doubleValue());\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return new Float(lng.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return obj;\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return new Integer(lng.intValue());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(lng);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(lng);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Integer) {\n            fromType = \"Integer\";\n            Integer intgr = (Integer) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(intgr.longValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return BigDecimal.valueOf(intgr.longValue());\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return new Double(intgr.doubleValue());\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return new Float(intgr.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return new Long(intgr.longValue());\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return obj;\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(intgr);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(intgr);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof BigDecimal) {\n            fromType = \"BigDecimal\";\n            BigDecimal bigDec = (BigDecimal) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(bigDec.doubleValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return obj;\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return new Double(bigDec.doubleValue());\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return new Float(bigDec.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return new Long(bigDec.longValue());\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return new Integer(bigDec.intValue());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(bigDec);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(bigDec);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.sql.Date) {\n            fromType = \"Date\";\n            java.sql.Date dte = (java.sql.Date) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateFormat(UtilDateTime.DATE_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toDateFormat(format, timeZone, null);\n                }\n                return df.format(new java.util.Date(dte.getTime()));\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                return obj;\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                return new java.sql.Timestamp(dte.getTime());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(dte);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(dte);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.sql.Time) {\n            fromType = \"Time\";\n            java.sql.Time tme = (java.sql.Time) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toTimeFormat(UtilDateTime.TIME_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toTimeFormat(format, timeZone, null);\n                }\n                return df.format(new java.util.Date(tme.getTime()));\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                return obj;\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                return new java.sql.Timestamp(tme.getTime());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(tme);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(tme);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.sql.Timestamp) {\n            fromType = \"Timestamp\";\n            java.sql.Timestamp tme = (java.sql.Timestamp) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateTimeFormat(UtilDateTime.DATE_TIME_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toDateTimeFormat(format, timeZone, null);\n                }\n                return df.format(new java.util.Date(tme.getTime()));\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                return new java.sql.Date(tme.getTime());\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                return new java.sql.Time(tme.getTime());\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                return obj;\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(tme);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(tme);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.lang.Boolean) {\n            fromType = \"Boolean\";\n            Boolean bol = (Boolean) obj;\n            if (\"Boolean\".equals(type) || \"java.lang.Boolean\".equals(type)) {\n                return bol;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return bol.toString();\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                if (bol.booleanValue()) {\n                    return new Integer(1);\n                } else {\n                    return new Integer(0);\n                }\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(bol);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(bol);\n                return tempSet;\n            } else { \n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.util.Locale) {\n            fromType = \"Locale\";\n            Locale loc = (Locale) obj;\n            if (\"Locale\".equals(type) || \"java.util.Locale\".equals(type)) {\n                return loc;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return loc.toString();\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.util.TimeZone) {\n            fromType = \"TimeZone\";\n            TimeZone tz = (TimeZone) obj;\n            if (\"TimeZone\".equals(type) || \"java.util.TimeZone\".equals(type)) {\n                return tz;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return tz.getID();\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj.getClass().getName().equals(\"org.ofbiz.entity.GenericValue\")) {\n            fromType = \"GenericValue\";            \n            if (\"GenericValue\".equals(type) || \"org.ofbiz.entity.GenericValue\".equals(type)) {\n                return obj;\n            } else if (\"Map\".equals(type) || \"java.util.Map\".equals(type)) {\n                return obj;           \n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return obj.toString();   \n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(obj);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(obj);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");            \n            }            \n        } else if (obj instanceof java.util.Map) {\n            fromType = \"Map\";\n            Map map = (Map) obj;\n            if (\"Map\".equals(type) || \"java.util.Map\".equals(type)) {\n                return map;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return map.toString();\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(obj);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(obj);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");            \n            }\n        } else if (obj instanceof java.util.List) {\n            fromType = \"List\";\n            List list = (List) obj;\n            if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                return list;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return list.toString();\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");            \n            }\n        } else {\n            // we can pretty much always do a conversion to a String, so do that here\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                Debug.logWarning(\"No special conversion available for \" + obj.getClass().getName() + \" to String, returning object.toString().\", module);\n                return obj.toString();\n            }\n            \n            if (noTypeFail) {\n                throw new GeneralException(\"Conversion from \" + obj.getClass().getName() + \" to \" + type + \" not currently supported\");\n            } else {\n                if (Debug.infoOn()) Debug.logInfo(\"No type conversion available for \" + obj.getClass().getName() + \" to \" + type + \", returning original object.\", module);\n                return obj;\n            }\n        }\n    }","id":9002,"modified_method":"/** \n     * Converts the passed object to the named simple type; supported types\n     * include: String, Boolean, Double, Float, Long, Integer, Date (java.sql.Date),\n     * Time, Timestamp, TimeZone;\n     * @param obj Object to convert\n     * @param type Name of type to convert to\n     * @param format Optional (can be null) format string for Date, Time, Timestamp\n     * @param timeZone Optional (can be null) TimeZone for converting dates and times\n     * @param locale Optional (can be null) Locale for formatting and parsing Double, Float, Long, Integer\n     * @param noTypeFail Fail (Exception) when no type conversion is available, false will return the primary object\n     * @return\n     * @throws GeneralException\n     */\n    public static Object simpleTypeConvert(Object obj, String type, String format, TimeZone timeZone, Locale locale, boolean noTypeFail) throws GeneralException {\n        if (obj == null) {\n            return null;\n        }\n\n        if (obj.getClass().getName().equals(type)) {\n            return obj;\n        }\n        if (\"PlainString\".equals(type)) {\n            return obj.toString();\n        }\n        if (\"Object\".equals(type) || \"java.lang.Object\".equals(type)) {\n            return obj;\n        }\n\n        String fromType = null;\n\n        if ((type.equals(\"List\") || type.equals(\"java.util.List\")) && obj.getClass().isArray()) {\n            List newObj = FastList.newInstance();\n            int len = Array.getLength(obj);\n            for (int i = 0; i < len; i++) {\n                newObj.add(Array.get(obj, i));\n            }\n            return newObj;        \n        } else if (obj instanceof java.lang.String) {\n            fromType = \"String\";\n            String str = (String) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return obj;\n            }\n            if (str.length() == 0) {\n                return null;\n            }\n            \n            if (\"Boolean\".equals(type) || \"java.lang.Boolean\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                return str.equalsIgnoreCase(\"TRUE\") ? Boolean.TRUE : Boolean.FALSE;\n            } else if (\"Locale\".equals(type) || \"java.util.Locale\".equals(type)) {\n                Locale loc = UtilMisc.parseLocale(str);\n                if (loc != null) {\n                    return loc;\n                } else {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \");    \n                }\n            } else if (\"TimeZone\".equals(type) || \"java.util.TimeZone\".equals(type)) {\n                TimeZone tz = UtilDateTime.toTimeZone(str);\n                if (tz != null) {\n                    return tz;\n                } else {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \");    \n                }\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    Number tempNum = nf.parse(str);\n                    return new BigDecimal(tempNum.toString());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    Number tempNum = nf.parse(str);\n\n                    return Double.valueOf(tempNum.doubleValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    Number tempNum = nf.parse(str);\n\n                    return Float.valueOf(tempNum.floatValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    nf.setMaximumFractionDigits(0);\n                    Number tempNum = nf.parse(str);\n\n                    return Long.valueOf(tempNum.longValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                str = StringUtil.removeSpaces(str);\n                try {\n                    NumberFormat nf = null;\n                    if (locale == null) {\n                        nf = NumberFormat.getNumberInstance();\n                    } else {\n                        nf = NumberFormat.getNumberInstance(locale);\n                    }\n                    nf.setMaximumFractionDigits(0);\n                    Number tempNum = nf.parse(str);\n\n                    return Integer.valueOf(tempNum.intValue());\n                } catch (ParseException e) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e);\n                }\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateFormat(UtilDateTime.DATE_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toDateFormat(format, timeZone, null);\n                }\n                try {\n                    Date fieldDate = df.parse(str);\n                    return new java.sql.Date(fieldDate.getTime());\n                } catch (ParseException e1) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e1);\n                }\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toTimeFormat(UtilDateTime.TIME_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toTimeFormat(format, timeZone, null);\n                }\n                try {\n                    Date fieldDate = df.parse(str);\n                    return new java.sql.Time(fieldDate.getTime());\n                } catch (ParseException e1) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e1);\n                }\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateTimeFormat(UtilDateTime.DATE_TIME_FORMAT, timeZone, null);\n                    // hack to mimic Timestamp.valueOf() method\n                    if (str.length() > 0 && !str.contains(\".\")) {\n                        str = str + \".0\";\n                    }\n                } else {\n                    df = UtilDateTime.toDateTimeFormat(format, timeZone, null);\n                }\n                try {\n                    Date fieldDate = df.parse(str);\n                    return new java.sql.Timestamp(fieldDate.getTime());\n                } catch (ParseException e1) {\n                    throw new GeneralException(\"Could not convert \" + str + \" to \" + type + \": \", e1);\n                }\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n                    return StringUtil.toList(str);\n                } else {\n                    List tempList = FastList.newInstance();\n                    tempList.add(str);\n                    return tempList;\n                }\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                if (str.startsWith(\"[\") && str.endsWith(\"]\")) {\n                    return StringUtil.toSet(str);\n                } else {\n                    Set tempSet = FastSet.newInstance();\n                    tempSet.add(str);\n                    return tempSet;\n                }\n            } else if ((\"Map\".equals(type) || \"java.util.Map\".equals(type)) &&\n                    (str.startsWith(\"{\") && str.endsWith(\"}\"))) {\n                return StringUtil.toMap(str);\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Double) {\n            fromType = \"Double\";\n            Double dbl = (Double) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(dbl.doubleValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return new BigDecimal(dbl.doubleValue());\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return obj;\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return Float.valueOf(dbl.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return Long.valueOf(Math.round(dbl.doubleValue()));\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return Integer.valueOf((int) Math.round(dbl.doubleValue()));\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(dbl);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(dbl);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Float) {\n            fromType = \"Float\";\n            Float flt = (Float) obj;\n\n            if (\"String\".equals(type)) {\n                NumberFormat nf = null;\n\n                if (locale == null)\n                    nf = NumberFormat.getNumberInstance();\n                else\n                    nf = NumberFormat.getNumberInstance(locale);\n                return nf.format(flt.doubleValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return new BigDecimal(flt.doubleValue());\n            } else if (\"Double\".equals(type)) {\n                return Double.valueOf(flt.doubleValue());\n            } else if (\"Float\".equals(type)) {\n                return obj;\n            } else if (\"Long\".equals(type)) {\n                return Long.valueOf(Math.round(flt.doubleValue()));\n            } else if (\"Integer\".equals(type)) {\n                return Integer.valueOf((int) Math.round(flt.doubleValue()));\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(flt);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(flt);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Long) {\n            fromType = \"Long\";\n            Long lng = (Long) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(lng.longValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return BigDecimal.valueOf(lng.longValue());\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return Double.valueOf(lng.doubleValue());\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return Float.valueOf(lng.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return obj;\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return Integer.valueOf(lng.intValue());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(lng);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(lng);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof Integer) {\n            fromType = \"Integer\";\n            Integer intgr = (Integer) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(intgr.longValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return BigDecimal.valueOf(intgr.longValue());\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return Double.valueOf(intgr.doubleValue());\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return Float.valueOf(intgr.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return Long.valueOf(intgr.longValue());\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return obj;\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(intgr);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(intgr);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof BigDecimal) {\n            fromType = \"BigDecimal\";\n            BigDecimal bigDec = (BigDecimal) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                NumberFormat nf = null;\n                if (locale == null) {\n                    nf = NumberFormat.getNumberInstance();\n                } else {\n                    nf = NumberFormat.getNumberInstance(locale);\n                }\n                return nf.format(bigDec.doubleValue());\n            } else if (\"BigDecimal\".equals(type) || \"java.math.BigDecimal\".equals(type)) {\n                return obj;\n            } else if (\"Double\".equals(type) || \"java.lang.Double\".equals(type)) {\n                return Double.valueOf(bigDec.doubleValue());\n            } else if (\"Float\".equals(type) || \"java.lang.Float\".equals(type)) {\n                return Float.valueOf(bigDec.floatValue());\n            } else if (\"Long\".equals(type) || \"java.lang.Long\".equals(type)) {\n                return Long.valueOf(bigDec.longValue());\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                return Integer.valueOf(bigDec.intValue());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(bigDec);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(bigDec);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.sql.Date) {\n            fromType = \"Date\";\n            java.sql.Date dte = (java.sql.Date) obj;\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateFormat(UtilDateTime.DATE_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toDateFormat(format, timeZone, null);\n                }\n                return df.format(new java.util.Date(dte.getTime()));\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                return obj;\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                return new java.sql.Timestamp(dte.getTime());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(dte);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(dte);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.sql.Time) {\n            fromType = \"Time\";\n            java.sql.Time tme = (java.sql.Time) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toTimeFormat(UtilDateTime.TIME_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toTimeFormat(format, timeZone, null);\n                }\n                return df.format(new java.util.Date(tme.getTime()));\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                return obj;\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                return new java.sql.Timestamp(tme.getTime());\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(tme);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(tme);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.sql.Timestamp) {\n            fromType = \"Timestamp\";\n            java.sql.Timestamp tme = (java.sql.Timestamp) obj;\n\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                DateFormat df = null;\n                if (format == null || format.length() == 0) {\n                    df = UtilDateTime.toDateTimeFormat(UtilDateTime.DATE_TIME_FORMAT, timeZone, null);\n                } else {\n                    df = UtilDateTime.toDateTimeFormat(format, timeZone, null);\n                }\n                return df.format(new java.util.Date(tme.getTime()));\n            } else if (\"Date\".equals(type) || \"java.sql.Date\".equals(type)) {\n                return new java.sql.Date(tme.getTime());\n            } else if (\"Time\".equals(type) || \"java.sql.Time\".equals(type)) {\n                return new java.sql.Time(tme.getTime());\n            } else if (\"Timestamp\".equals(type) || \"java.sql.Timestamp\".equals(type)) {\n                return obj;\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(tme);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(tme);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.lang.Boolean) {\n            fromType = \"Boolean\";\n            Boolean bol = (Boolean) obj;\n            if (\"Boolean\".equals(type) || \"java.lang.Boolean\".equals(type)) {\n                return bol;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return bol.toString();\n            } else if (\"Integer\".equals(type) || \"java.lang.Integer\".equals(type)) {\n                if (bol.booleanValue()) {\n                    return Integer.valueOf(1);\n                } else {\n                    return Integer.valueOf(0);\n                }\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(bol);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(bol);\n                return tempSet;\n            } else { \n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.util.Locale) {\n            fromType = \"Locale\";\n            Locale loc = (Locale) obj;\n            if (\"Locale\".equals(type) || \"java.util.Locale\".equals(type)) {\n                return loc;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return loc.toString();\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj instanceof java.util.TimeZone) {\n            fromType = \"TimeZone\";\n            TimeZone tz = (TimeZone) obj;\n            if (\"TimeZone\".equals(type) || \"java.util.TimeZone\".equals(type)) {\n                return tz;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return tz.getID();\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");\n            }\n        } else if (obj.getClass().getName().equals(\"org.ofbiz.entity.GenericValue\")) {\n            fromType = \"GenericValue\";            \n            if (\"GenericValue\".equals(type) || \"org.ofbiz.entity.GenericValue\".equals(type)) {\n                return obj;\n            } else if (\"Map\".equals(type) || \"java.util.Map\".equals(type)) {\n                return obj;           \n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return obj.toString();   \n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(obj);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(obj);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");            \n            }            \n        } else if (obj instanceof java.util.Map) {\n            fromType = \"Map\";\n            Map map = (Map) obj;\n            if (\"Map\".equals(type) || \"java.util.Map\".equals(type)) {\n                return map;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return map.toString();\n            } else if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                List tempList = FastList.newInstance();\n                tempList.add(obj);\n                return tempList;\n            } else if (\"Set\".equals(type) || \"java.util.Set\".equals(type)) {\n                Set tempSet = FastSet.newInstance();\n                tempSet.add(obj);\n                return tempSet;\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");            \n            }\n        } else if (obj instanceof java.util.List) {\n            fromType = \"List\";\n            List list = (List) obj;\n            if (\"List\".equals(type) || \"java.util.List\".equals(type)) {\n                return list;\n            } else if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                return list.toString();\n            } else {\n                throw new GeneralException(\"Conversion from \" + fromType + \" to \" + type + \" not currently supported\");            \n            }\n        } else {\n            // we can pretty much always do a conversion to a String, so do that here\n            if (\"String\".equals(type) || \"java.lang.String\".equals(type)) {\n                Debug.logWarning(\"No special conversion available for \" + obj.getClass().getName() + \" to String, returning object.toString().\", module);\n                return obj.toString();\n            }\n            \n            if (noTypeFail) {\n                throw new GeneralException(\"Conversion from \" + obj.getClass().getName() + \" to \" + type + \" not currently supported\");\n            } else {\n                if (Debug.infoOn()) Debug.logInfo(\"No type conversion available for \" + obj.getClass().getName() + \" to \" + type + \", returning original object.\", module);\n                return obj;\n            }\n        }\n    }","commit_id":"7a8f2167ce13ada9e562c65e915f0d3c3fc9d101","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map addGeneralResults(Map result, GenericValue competitivePriceValue, GenericValue specialPromoPriceValue, GenericValue productStore, \n        String checkIncludeVat, String currencyUomId, String productId, double quantity, String partyId, LocalDispatcher dispatcher) {\n        result.put(\"competitivePrice\", competitivePriceValue != null ? competitivePriceValue.getDouble(\"price\") : null);\n        result.put(\"specialPromoPrice\", specialPromoPriceValue != null ? specialPromoPriceValue.getDouble(\"price\") : null);\n        result.put(\"currencyUsed\", currencyUomId);\n\n        // okay, now we have the calculated price, see if we should add in tax and if so do it\n        if (\"Y\".equals(checkIncludeVat) && productStore != null && \"Y\".equals(productStore.getString(\"showPricesWithVatTax\"))) {\n            Map calcTaxForDisplayContext = UtilMisc.toMap(\"productStoreId\", productStore.get(\"productStoreId\"), \n                    \"productId\", productId, \"quantity\", new BigDecimal(quantity), \n                    \"basePrice\", new BigDecimal(((Double) result.get(\"price\")).doubleValue()));\n            if (UtilValidate.isNotEmpty(partyId)) {\n                calcTaxForDisplayContext.put(\"billToPartyId\", partyId);\n            }\n            \n            try {\n                Map calcTaxForDisplayResult = dispatcher.runSync(\"calcTaxForDisplay\", calcTaxForDisplayContext);\n                if (ServiceUtil.isError(calcTaxForDisplayResult)) {\n                    return ServiceUtil.returnError(\"Error calculating VAT tax (with calcTaxForDisplay service)\", null, null, calcTaxForDisplayResult);\n                }\n                // taxTotal, taxPercentage, priceWithTax\n                result.put(\"price\", new Double(((BigDecimal) calcTaxForDisplayResult.get(\"priceWithTax\")).doubleValue()));\n\n                // based on the taxPercentage calculate the other amounts, including: listPrice, defaultPrice, averageCost, promoPrice, competitivePrice\n                BigDecimal taxPercentage = (BigDecimal) calcTaxForDisplayResult.get(\"taxPercentage\");\n                BigDecimal taxMultiplier = ONE_BASE.add(taxPercentage.divide(PERCENT_SCALE, 3));\n                if (result.get(\"listPrice\") != null) result.put(\"listPrice\", new Double((new BigDecimal (((Double) result.get(\"listPrice\")).doubleValue())).multiply(taxMultiplier).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()));\n                if (result.get(\"defaultPrice\") != null) result.put(\"defaultPrice\", new Double((new BigDecimal (((Double) result.get(\"defaultPrice\")).doubleValue())).multiply(taxMultiplier).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()));\n                if (result.get(\"averageCost\") != null) result.put(\"averageCost\", new Double((new BigDecimal (((Double) result.get(\"averageCost\")).doubleValue())).multiply(taxMultiplier).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()));\n                \n                if (result.get(\"promoPrice\") != null) result.put(\"promoPrice\", new Double((new BigDecimal (((Double) result.get(\"promoPrice\")).doubleValue())).multiply(taxMultiplier).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()));\n                if (result.get(\"competitivePrice\") != null) result.put(\"competitivePrice\", new Double((new BigDecimal (((Double) result.get(\"competitivePrice\")).doubleValue())).multiply(taxMultiplier).setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue()));\n                \n            } catch (GenericServiceException e) {\n                String errMsg = \"Error calculating VAT tax (with calcTaxForDisplay service): \" + e.toString();\n                Debug.logError(e, errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n        \n        return null;\n    }","id":9003,"modified_method":"public static Map addGeneralResults(Map result, GenericValue competitivePriceValue, GenericValue specialPromoPriceValue, GenericValue productStore, \n        String checkIncludeVat, String currencyUomId, String productId, double quantity, String partyId, LocalDispatcher dispatcher) {\n        result.put(\"competitivePrice\", competitivePriceValue != null ? competitivePriceValue.getDouble(\"price\") : null);\n        result.put(\"specialPromoPrice\", specialPromoPriceValue != null ? specialPromoPriceValue.getDouble(\"price\") : null);\n        result.put(\"currencyUsed\", currencyUomId);\n\n        // okay, now we have the calculated price, see if we should add in tax and if so do it\n        if (\"Y\".equals(checkIncludeVat) && productStore != null && \"Y\".equals(productStore.getString(\"showPricesWithVatTax\"))) {\n            Map calcTaxForDisplayContext = UtilMisc.toMap(\"productStoreId\", productStore.get(\"productStoreId\"), \n                    \"productId\", productId, \"quantity\", BigDecimal.valueOf(quantity), \n                    \"basePrice\", BigDecimal.valueOf(((Double) result.get(\"price\")).doubleValue()));\n            if (UtilValidate.isNotEmpty(partyId)) {\n                calcTaxForDisplayContext.put(\"billToPartyId\", partyId);\n            }\n            \n            try {\n                Map calcTaxForDisplayResult = dispatcher.runSync(\"calcTaxForDisplay\", calcTaxForDisplayContext);\n                if (ServiceUtil.isError(calcTaxForDisplayResult)) {\n                    return ServiceUtil.returnError(\"Error calculating VAT tax (with calcTaxForDisplay service)\", null, null, calcTaxForDisplayResult);\n                }\n                // taxTotal, taxPercentage, priceWithTax\n                result.put(\"price\", Double.valueOf(((BigDecimal) calcTaxForDisplayResult.get(\"priceWithTax\")).doubleValue()));\n\n                // based on the taxPercentage calculate the other amounts, including: listPrice, defaultPrice, averageCost, promoPrice, competitivePrice\n                BigDecimal taxPercentage = (BigDecimal) calcTaxForDisplayResult.get(\"taxPercentage\");\n                BigDecimal taxMultiplier = ONE_BASE.add(taxPercentage.divide(PERCENT_SCALE, taxCalcScale));\n                if (result.get(\"listPrice\") != null) {\n                    result.put(\"listPrice\", Double.valueOf( BigDecimal.valueOf(((Double) result.get(\"listPrice\")).doubleValue()).multiply(taxMultiplier).setScale( taxFinalScale, taxRounding ).doubleValue()));\n                }\n                if (result.get(\"defaultPrice\") != null) {                    \n                    result.put(\"defaultPrice\", Double.valueOf( BigDecimal.valueOf(((Double) result.get(\"defaultPrice\")).doubleValue()).multiply(taxMultiplier).setScale( taxFinalScale, taxRounding ).doubleValue()));\n                }\n                if (result.get(\"averageCost\") != null) {\n                    result.put(\"averageCost\", Double.valueOf( BigDecimal.valueOf(((Double) result.get(\"averageCost\")).doubleValue()).multiply(taxMultiplier).setScale( taxFinalScale, taxRounding ).doubleValue()));\n                }               \n                if (result.get(\"promoPrice\") != null) {\n                    result.put(\"promoPrice\", Double.valueOf( BigDecimal.valueOf(((Double) result.get(\"promoPrice\")).doubleValue()).multiply(taxMultiplier).setScale( taxFinalScale, taxRounding ).doubleValue()));\n                }\n                if (result.get(\"competitivePrice\") != null) {\n                    result.put(\"competitivePrice\", Double.valueOf( BigDecimal.valueOf(((Double) result.get(\"competitivePrice\")).doubleValue()).multiply(taxMultiplier).setScale( taxFinalScale, taxRounding ).doubleValue()));\n                }\n            } catch (GenericServiceException e) {\n                String errMsg = \"Error calculating VAT tax (with calcTaxForDisplay service): \" + e.toString();\n                Debug.logError(e, errMsg, module);\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n        \n        return null;\n    }","commit_id":"f8408fa23e31cd04326352d50b8f62649ea24c69","url":"https://github.com/apache/ofbiz"},{"original_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        return game.getOpponents(this.getControllerId()).contains(game.getControllerId(event.getSourceId())) &&\n                StackObject.class.isInstance(game.getObject(event.getSourceId())) &&\n                getSourceId().equals(event.getTargetId());\n    }","id":9004,"modified_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (getSourceId().equals(event.getTargetId())) {\n            StackObject stackObject = game.getStack().getStackObject(event.getSourceId());\n            if (stackObject != null) {\n                return game.getOpponents(this.getControllerId()).contains(stackObject.getControllerId());\n            }\n        }\n        return false;\n    }","commit_id":"af61e8b43b21de6ec6f36807affe46a54a28e105","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        return game.getOpponents(this.getControllerId()).contains(game.getControllerId(event.getSourceId())) &&\r\n                StackObject.class.isInstance(game.getObject(event.getSourceId())) &&\r\n                event.getTargetId().equals(getSourceId());\r\n    }","id":9005,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (getSourceId().equals(event.getTargetId())) {\r\n            StackObject stackObject = game.getStack().getStackObject(event.getSourceId());\r\n            if (stackObject != null\r\n                    && game.getOpponents(this.getControllerId()).contains(stackObject.getControllerId())) {\r\n                for (Effect effect : getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"af61e8b43b21de6ec6f36807affe46a54a28e105","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (game.getOpponents(this.getControllerId()).contains(game.getControllerId(event.getSourceId())) &&\r\n                StackObject.class.isInstance(game.getObject(event.getSourceId()))) {\r\n            Card card = game.getCard(event.getTargetId());\r\n            if (card != null && card.getOwnerId().equals(getControllerId())) {\r\n                for(Effect effect : getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":9006,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        StackObject stackObject = game.getStack().getStackObject(event.getSourceId());\r\n        if (stackObject != null\r\n                && game.getOpponents(this.getControllerId()).contains(stackObject.getControllerId())) {\r\n            Card card = game.getCard(event.getTargetId());\r\n            if (card != null && card.getOwnerId().equals(getControllerId())) {\r\n                for (Effect effect : getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"af61e8b43b21de6ec6f36807affe46a54a28e105","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        return game.getOpponents(this.getControllerId()).contains(game.getControllerId(event.getSourceId())) &&\n                StackObject.class.isInstance(game.getObject(event.getSourceId())) &&\n                getSourceId().equals(event.getTargetId());\n    }","id":9007,"modified_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (getSourceId().equals(event.getTargetId())) {\n            StackObject stackObject = game.getStack().getStackObject(event.getSourceId());\n            if (stackObject != null) {\n                return game.getOpponents(this.getControllerId()).contains(stackObject.getControllerId());\n            }\n        }\n        return false;\n    }","commit_id":"af61e8b43b21de6ec6f36807affe46a54a28e105","url":"https://github.com/magefree/mage"},{"original_method":"protected void pollDirectory(String fileName, List<GenericFile<File>> fileList) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"pollDirectory from fileName: \" + fileName);\n        }\n\n        File directory = new File(fileName);\n        if (!directory.exists() || !directory.isDirectory()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Cannot poll as directory does not exists or its not a directory: \" + directory);\n            }\n            return;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Polling directory: \" + directory.getPath());\n        }\n        File[] files = directory.listFiles();\n        if (files == null || files.length == 0) {\n            // no files in this directory to poll\n            if (log.isTraceEnabled()) {\n                log.trace(\"No files found in directory: \" + directory.getPath());\n            }\n            return;\n        } else {\n            // we found some files\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found \" + files.length + \" in directory: \" + directory.getPath());\n            }\n        }\n\n        for (File file : files) {\n            // trace log as Windows/Unix can have different views what the file is?\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found file: \" + file + \" [isAbsolute: \" + file.isAbsolute() + \", isDirectory: \"\n                        + file.isDirectory() + \", isFile: \" + file.isFile() + \", isHidden: \" + file.isHidden() + \"]\");\n            }\n\n            // creates a generic file\n            GenericFile<File> gf = asGenericFile(endpointPath, file);\n\n            if (file.isDirectory()) {\n                if (endpoint.isRecursive() && isValidFile(gf, true)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = fileName + File.separator + file.getName();\n                    pollDirectory(subDirectory, fileList);\n                }\n            } else {\n                // Windows can report false to a file on a share so regard it always as a file (if its not a directory)\n                if (isValidFile(gf, false)) {\n                    if (isInProgress(gf)) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Skipping as file is already in progress: \" + gf.getFileName());\n                        }\n                    } else {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Adding valid file: \" + file);\n                        }\n                        // matched file so add\n                        fileList.add(gf);\n                    }\n                }\n            }\n        }\n    }","id":9008,"modified_method":"protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileList) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"pollDirectory from fileName: \" + fileName);\n        }\n\n        File directory = new File(fileName);\n        if (!directory.exists() || !directory.isDirectory()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Cannot poll as directory does not exists or its not a directory: \" + directory);\n            }\n            return true;\n        }\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Polling directory: \" + directory.getPath());\n        }\n        File[] files = directory.listFiles();\n        if (files == null || files.length == 0) {\n            // no files in this directory to poll\n            if (log.isTraceEnabled()) {\n                log.trace(\"No files found in directory: \" + directory.getPath());\n            }\n            return true;\n        } else {\n            // we found some files\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found \" + files.length + \" in directory: \" + directory.getPath());\n            }\n        }\n\n        for (File file : files) {\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            // trace log as Windows/Unix can have different views what the file is?\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found file: \" + file + \" [isAbsolute: \" + file.isAbsolute() + \", isDirectory: \"\n                        + file.isDirectory() + \", isFile: \" + file.isFile() + \", isHidden: \" + file.isHidden() + \"]\");\n            }\n\n            // creates a generic file\n            GenericFile<File> gf = asGenericFile(endpointPath, file);\n\n            if (file.isDirectory()) {\n                if (endpoint.isRecursive() && isValidFile(gf, true)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = fileName + File.separator + file.getName();\n                    boolean canPollMore = pollDirectory(subDirectory, fileList);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n            } else {\n                // Windows can report false to a file on a share so regard it always as a file (if its not a directory)\n                if (isValidFile(gf, false)) {\n                    if (isInProgress(gf)) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Skipping as file is already in progress: \" + gf.getFileName());\n                        }\n                    } else {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Adding valid file: \" + file);\n                        }\n                        // matched file so add\n                        fileList.add(gf);\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"9fead2da39120f6c3685b5117d54a5c3a3d1ca9b","url":"https://github.com/apache/camel"},{"original_method":"protected void pollDirectory(String fileName, List<GenericFile<FTPFile>> fileList) {\n        if (fileName == null) {\n            return;\n        }\n\n        // remove trailing /\n        fileName = FileUtil.stripTrailingSeparator(fileName);\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Polling directory: \" + fileName);\n        }\n        List<FTPFile> files = operations.listFiles(fileName);\n        for (FTPFile file : files) {\n            if (file.isDirectory()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(fileName, file);\n                if (endpoint.isRecursive() && isValidFile(remote, true)) {\n                    // recursive scan and add the sub files and folders\n                    String directory = fileName + \"/\" + file.getName();\n                    pollDirectory(directory, fileList);\n                }\n            } else if (file.isFile()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(fileName, file);\n                if (isValidFile(remote, false)) {\n                    if (isInProgress(remote)) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Skipping as file is already in progress: \" + remote.getFileName());\n                        }\n                    } else {\n                        // matched file so add\n                        fileList.add(remote);\n                    }\n                }\n            } else {\n                log.debug(\"Ignoring unsupported remote file type: \" + file);\n            }\n        }\n    }","id":9009,"modified_method":"protected boolean pollDirectory(String fileName, List<GenericFile<FTPFile>> fileList) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"pollDirectory from fileName: \" + fileName);\n        }\n        if (fileName == null) {\n            return true;\n        }\n\n        // remove trailing /\n        fileName = FileUtil.stripTrailingSeparator(fileName);\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Polling directory: \" + fileName);\n        }\n        List<FTPFile> files = operations.listFiles(fileName);\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            if (log.isTraceEnabled()) {\n                log.trace(\"No files found in directory: \" + fileName);\n            }\n            return true;\n        } else {\n            // we found some files\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found \" + files.size() + \" in directory: \" + fileName);\n            }\n        }\n\n        for (FTPFile file : files) {\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.isDirectory()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(fileName, file);\n                if (endpoint.isRecursive() && isValidFile(remote, true)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = fileName + \"/\" + file.getName();\n                    boolean canPollMore = pollDirectory(subDirectory, fileList);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n            } else if (file.isFile()) {\n                RemoteFile<FTPFile> remote = asRemoteFile(fileName, file);\n                if (isValidFile(remote, false)) {\n                    if (isInProgress(remote)) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Skipping as file is already in progress: \" + remote.getFileName());\n                        }\n                    } else {\n                        // matched file so add\n                        fileList.add(remote);\n                    }\n                }\n            } else {\n                log.debug(\"Ignoring unsupported remote file type: \" + file);\n            }\n        }\n\n        return true;\n    }","commit_id":"9fead2da39120f6c3685b5117d54a5c3a3d1ca9b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Poll for files\n     */\n    protected void poll() throws Exception {\n        // must reset for each poll\n        fileExpressionResult = null;\n        shutdownRunningTask = null;\n        pendingExchanges = 0;\n\n        // before we poll is there anything we need to check?\n        // such as are we connected to the FTP Server still?\n        if (!prePollCheck()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Skipping pool as pre poll check returned false\");\n            }\n        }\n\n        // gather list of files to process\n        List<GenericFile<T>> files = new ArrayList<GenericFile<T>>();\n\n        String name = endpoint.getConfiguration().getDirectory();\n        pollDirectory(name, files);\n\n        // sort files using file comparator if provided\n        if (endpoint.getSorter() != null) {\n            Collections.sort(files, endpoint.getSorter());\n        }\n\n        // sort using build in sorters so we can use expressions\n        LinkedList<Exchange> exchanges = new LinkedList<Exchange>();\n        for (GenericFile<T> file : files) {\n            Exchange exchange = endpoint.createExchange(file);\n            endpoint.configureMessage(file, exchange.getIn());\n            exchanges.add(exchange);\n        }\n        // sort files using exchange comparator if provided\n        if (endpoint.getSortBy() != null) {\n            Collections.sort(exchanges, endpoint.getSortBy());\n        }\n\n        // consume files one by one\n        int total = exchanges.size();\n        if (total > 0 && log.isDebugEnabled()) {\n            log.debug(\"Total \" + total + \" files to consume\");\n        }\n\n        Queue<Exchange> q = exchanges;\n        processBatch(CastUtils.cast(q));\n\n        postPollCheck();\n    }","id":9010,"modified_method":"/**\n     * Poll for files\n     */\n    protected void poll() throws Exception {\n        // must reset for each poll\n        fileExpressionResult = null;\n        shutdownRunningTask = null;\n        pendingExchanges = 0;\n\n        // before we poll is there anything we need to check?\n        // such as are we connected to the FTP Server still?\n        if (!prePollCheck()) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Skipping pool as pre poll check returned false\");\n            }\n        }\n\n        // gather list of files to process\n        List<GenericFile<T>> files = new ArrayList<GenericFile<T>>();\n        String name = endpoint.getConfiguration().getDirectory();\n        boolean limitHit = !pollDirectory(name, files);\n\n        // log if we hit the limit\n        if (limitHit) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Limiting maximum messages to poll at \" + maxMessagesPerPoll + \" files as there was more messages in this poll.\");\n            }\n        }\n\n        // sort files using file comparator if provided\n        if (endpoint.getSorter() != null) {\n            Collections.sort(files, endpoint.getSorter());\n        }\n\n        // sort using build in sorters so we can use expressions\n        LinkedList<Exchange> exchanges = new LinkedList<Exchange>();\n        for (GenericFile<T> file : files) {\n            Exchange exchange = endpoint.createExchange(file);\n            endpoint.configureMessage(file, exchange.getIn());\n            exchanges.add(exchange);\n        }\n        // sort files using exchange comparator if provided\n        if (endpoint.getSortBy() != null) {\n            Collections.sort(exchanges, endpoint.getSortBy());\n        }\n\n        // consume files one by one\n        int total = exchanges.size();\n        if (total > 0 && log.isDebugEnabled()) {\n            log.debug(\"Total \" + total + \" files to consume\");\n        }\n\n        Queue<Exchange> q = exchanges;\n        processBatch(CastUtils.cast(q));\n\n        postPollCheck();\n    }","commit_id":"9fead2da39120f6c3685b5117d54a5c3a3d1ca9b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Polls the given directory for files to process\n     *\n     * @param fileName current directory or file\n     * @param fileList current list of files gathered\n     */\n    protected abstract void pollDirectory(String fileName, List<GenericFile<T>> fileList);","id":9011,"modified_method":"/**\n     * Polls the given directory for files to process\n     *\n     * @param fileName current directory or file\n     * @param fileList current list of files gathered\n     * @return whether or not to continue polling, <tt>false<\/tt> means the maxMessagesPerPoll limit has been hit\n     */\n    protected abstract boolean pollDirectory(String fileName, List<GenericFile<T>> fileList);","commit_id":"9fead2da39120f6c3685b5117d54a5c3a3d1ca9b","url":"https://github.com/apache/camel"},{"original_method":"protected void pollDirectory(String fileName, List<GenericFile<ChannelSftp.LsEntry>> fileList) {\n        if (fileName == null) {\n            return;\n        }\n\n        // remove trailing /\n        fileName = FileUtil.stripTrailingSeparator(fileName);\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Polling directory: \" + fileName);\n        }\n        List<ChannelSftp.LsEntry> files = operations.listFiles(fileName);\n        for (ChannelSftp.LsEntry file : files) {\n            if (file.getAttrs().isDir()) {\n                RemoteFile<ChannelSftp.LsEntry> remote = asRemoteFile(fileName, file);\n                if (endpoint.isRecursive() && isValidFile(remote, true)) {\n                    // recursive scan and add the sub files and folders\n                    String directory = fileName + \"/\" + file.getFilename();\n                    pollDirectory(directory, fileList);\n                }\n                // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method\n                // just assuming its a file we should poll\n            } else {\n                RemoteFile<ChannelSftp.LsEntry> remote = asRemoteFile(fileName, file);\n                if (isValidFile(remote, false)) {\n                    if (isInProgress(remote)) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Skipping as file is already in progress: \" + remote.getFileName());\n                        }\n                    } else {\n                        // matched file so add\n                        fileList.add(remote);\n                    }\n                }\n            }\n        }\n    }","id":9012,"modified_method":"protected boolean pollDirectory(String fileName, List<GenericFile<ChannelSftp.LsEntry>> fileList) {\n        if (log.isTraceEnabled()) {\n            log.trace(\"pollDirectory from fileName: \" + fileName);\n        }\n\n        if (fileName == null) {\n            return true;\n        }\n\n        // remove trailing /\n        fileName = FileUtil.stripTrailingSeparator(fileName);\n\n        if (log.isTraceEnabled()) {\n            log.trace(\"Polling directory: \" + fileName);\n        }\n        List<ChannelSftp.LsEntry> files = operations.listFiles(fileName);\n        if (files == null || files.isEmpty()) {\n            // no files in this directory to poll\n            if (log.isTraceEnabled()) {\n                log.trace(\"No files found in directory: \" + fileName);\n            }\n            return true;\n        } else {\n            // we found some files\n            if (log.isTraceEnabled()) {\n                log.trace(\"Found \" + files.size() + \" in directory: \" + fileName);\n            }\n        }\n\n        for (ChannelSftp.LsEntry file : files) {\n\n            // check if we can continue polling in files\n            if (!canPollMoreFiles(fileList)) {\n                return false;\n            }\n\n            if (file.getAttrs().isDir()) {\n                RemoteFile<ChannelSftp.LsEntry> remote = asRemoteFile(fileName, file);\n                if (endpoint.isRecursive() && isValidFile(remote, true)) {\n                    // recursive scan and add the sub files and folders\n                    String subDirectory = fileName + \"/\" + file.getFilename();\n                    boolean canPollMore = pollDirectory(subDirectory, fileList);\n                    if (!canPollMore) {\n                        return false;\n                    }\n                }\n                // we cannot use file.getAttrs().isLink on Windows, so we dont invoke the method\n                // just assuming its a file we should poll\n            } else {\n                RemoteFile<ChannelSftp.LsEntry> remote = asRemoteFile(fileName, file);\n                if (isValidFile(remote, false)) {\n                    if (isInProgress(remote)) {\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Skipping as file is already in progress: \" + remote.getFileName());\n                        }\n                    } else {\n                        // matched file so add\n                        fileList.add(remote);\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"9fead2da39120f6c3685b5117d54a5c3a3d1ca9b","url":"https://github.com/apache/camel"},{"original_method":"protected void addSignatureConfirmation(List<WSEncryptionPart> sigParts) {\n        Wss10 wss10 = getWss10();\n        \n        if (!(wss10 instanceof Wss11) \n            || !((Wss11)wss10).isRequireSignatureConfirmation()) {\n            //If we don't require sig confirmation simply go back :-)\n            return;\n        }\n        \n        List<WSHandlerResult> results = \n            CastUtils.cast((List<?>)\n                message.getExchange().getInMessage().get(WSHandlerConstants.RECV_RESULTS));\n        /*\n         * loop over all results gathered by all handlers in the chain. For each\n         * handler result get the various actions. After that loop we have all\n         * signature results in the signatureActions list\n         */\n        List<WSSecurityEngineResult> signatureActions = new ArrayList<WSSecurityEngineResult>();\n        for (WSHandlerResult wshResult : results) {\n            WSSecurityUtil.fetchAllActionResults(wshResult.getResults(),\n                    WSConstants.SIGN, signatureActions);\n            WSSecurityUtil.fetchAllActionResults(wshResult.getResults(),\n                    WSConstants.ST_SIGNED, signatureActions);\n            WSSecurityUtil.fetchAllActionResults(wshResult.getResults(),\n                    WSConstants.UT_SIGN, signatureActions);\n        }\n        \n        // prepare a SignatureConfirmation token\n        WSSecSignatureConfirmation wsc = new WSSecSignatureConfirmation(wssConfig);\n        if (signatureActions.size() > 0) {\n            for (WSSecurityEngineResult wsr : signatureActions) {\n                byte[] sigVal = (byte[]) wsr.get(WSSecurityEngineResult.TAG_SIGNATURE_VALUE);\n                wsc.setSignatureValue(sigVal);\n                wsc.prepare(saaj.getSOAPPart());\n                addSupportingElement(wsc.getSignatureConfirmationElement());\n                if (sigParts != null) {\n                    sigParts.add(new WSEncryptionPart(wsc.getId()));\n                }\n            }\n        } else {\n            //No Sig value\n            wsc.prepare(saaj.getSOAPPart());\n            addSupportingElement(wsc.getSignatureConfirmationElement());\n            if (sigParts != null) {\n                sigParts.add(new WSEncryptionPart(wsc.getId()));\n            }\n        }\n    }","id":9013,"modified_method":"protected void addSignatureConfirmation(List<WSEncryptionPart> sigParts) {\n        Wss10 wss10 = getWss10();\n        \n        if (!(wss10 instanceof Wss11) \n            || !((Wss11)wss10).isRequireSignatureConfirmation()) {\n            //If we don't require sig confirmation simply go back :-)\n            return;\n        }\n        \n        List<WSHandlerResult> results = \n            CastUtils.cast((List<?>)\n                message.getExchange().getInMessage().get(WSHandlerConstants.RECV_RESULTS));\n        /*\n         * loop over all results gathered by all handlers in the chain. For each\n         * handler result get the various actions. After that loop we have all\n         * signature results in the signatureActions list\n         */\n        List<WSSecurityEngineResult> signatureActions = new ArrayList<WSSecurityEngineResult>();\n        for (WSHandlerResult wshResult : results) {\n            WSSecurityUtil.fetchAllActionResults(wshResult.getResults(),\n                    WSConstants.SIGN, signatureActions);\n            WSSecurityUtil.fetchAllActionResults(wshResult.getResults(),\n                    WSConstants.ST_SIGNED, signatureActions);\n            WSSecurityUtil.fetchAllActionResults(wshResult.getResults(),\n                    WSConstants.UT_SIGN, signatureActions);\n        }\n        \n        sigConfList = new ArrayList<WSEncryptionPart>();\n        // prepare a SignatureConfirmation token\n        WSSecSignatureConfirmation wsc = new WSSecSignatureConfirmation(wssConfig);\n        if (signatureActions.size() > 0) {\n            for (WSSecurityEngineResult wsr : signatureActions) {\n                byte[] sigVal = (byte[]) wsr.get(WSSecurityEngineResult.TAG_SIGNATURE_VALUE);\n                wsc.setSignatureValue(sigVal);\n                wsc.prepare(saaj.getSOAPPart());\n                addSupportingElement(wsc.getSignatureConfirmationElement());\n                if (sigParts != null) {\n                    WSEncryptionPart part = new WSEncryptionPart(wsc.getId(), \"Element\");\n                    part.setElement(wsc.getSignatureConfirmationElement());\n                    sigParts.add(part);\n                    sigConfList.add(part);\n                }\n            }\n        } else {\n            //No Sig value\n            wsc.prepare(saaj.getSOAPPart());\n            addSupportingElement(wsc.getSignatureConfirmationElement());\n            if (sigParts != null) {\n                WSEncryptionPart part = new WSEncryptionPart(wsc.getId(), \"Element\");\n                part.setElement(wsc.getSignatureConfirmationElement());\n                sigParts.add(part);\n                sigConfList.add(part);\n            }\n        }\n    }","commit_id":"e15186233dcb200fd4960f324b86e7e7dc2e73c4","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Check whether all Signature (and SignatureConfirmation) elements were encrypted\n     */\n    protected boolean isSignatureEncrypted() {\n        for (WSSecurityEngineResult result : results) {\n            Integer actInt = (Integer)result.get(WSSecurityEngineResult.TAG_ACTION);\n            if (actInt.intValue() == WSConstants.SIGN) {\n                // TODO || actInt.intValue() == WSConstants.SC) {\n                String sigId = (String)result.get(WSSecurityEngineResult.TAG_ID);\n                if (sigId == null || !isIdEncrypted(sigId)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }","id":9014,"modified_method":"/**\n     * Check whether all Signature (and SignatureConfirmation) elements were encrypted\n     */\n    protected boolean isSignatureEncrypted() {\n        for (WSSecurityEngineResult result : results) {\n            Integer actInt = (Integer)result.get(WSSecurityEngineResult.TAG_ACTION);\n            if (actInt.intValue() == WSConstants.SIGN\n                || actInt.intValue() == WSConstants.SC) {\n                String sigId = (String)result.get(WSSecurityEngineResult.TAG_ID);\n                if (sigId == null || !isIdEncrypted(sigId)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }","commit_id":"e15186233dcb200fd4960f324b86e7e7dc2e73c4","url":"https://github.com/apache/cxf"},{"original_method":"private void doEncryptBeforeSign() {\n        TokenWrapper wrapper;\n        Token encryptionToken = null;\n        if (isRequestor()) {\n            wrapper = abinding.getRecipientToken();\n        } else {\n            wrapper = abinding.getInitiatorToken();\n        }\n        encryptionToken = wrapper.getToken();\n        \n        TokenWrapper initiatorWrapper = abinding.getInitiatorToken();\n        boolean attached = false;\n        if (initiatorWrapper != null) {\n            Token initiatorToken = initiatorWrapper.getToken();\n            if (initiatorToken instanceof IssuedToken) {\n                SecurityToken secToken = getSecurityToken();\n                if (secToken == null) {\n                    policyNotAsserted(initiatorToken, \"No intiator token id\");\n                    return;\n                } else {\n                    policyAsserted(initiatorToken);\n                    \n                    if (includeToken(initiatorToken.getInclusion())) {\n                        Element el = secToken.getToken();\n                        this.addEncryptedKeyElement(cloneElement(el));\n                        attached = true;\n                    } \n                }\n            }\n        }\n        \n        List<WSEncryptionPart> encrParts = null;\n        List<WSEncryptionPart> sigParts = null;\n        try {\n            encrParts = getEncryptedParts();\n            //Signed parts are determined before encryption because encrypted signed  headers\n            //will not be included otherwise\n            sigParts = getSignedParts();\n        } catch (SOAPException ex) {\n            throw new Fault(ex);\n        }\n        \n        //if (encryptionToken == null && encrParts.size() > 0) {\n            //REVISIT - no token to encrypt with  \n        //}\n        \n        if (encryptionToken != null && encrParts.size() > 0) {\n            WSSecBase encrBase = doEncryption(wrapper, encrParts, true);\n            handleEncryptedSignedHeaders(encrParts, sigParts);\n            \n            if (timestampEl != null) {\n                WSEncryptionPart timestampPart = \n                    convertToEncryptionPart(timestampEl.getElement());\n                sigParts.add(timestampPart);\n            }\n            \n            if (isRequestor()) {\n                try {\n                    addSupportingTokens(sigParts);\n                } catch (WSSecurityException ex) {\n                    policyNotAsserted(encryptionToken, ex.getMessage());\n                }\n            } else {\n                addSignatureConfirmation(sigParts);\n            }\n            \n            if ((sigParts.size() > 0 \n                    && isRequestor()\n                    && abinding.getInitiatorToken() != null) \n                || (!isRequestor() && abinding.getRecipientToken() != null)) {\n                try {\n                    doSignature(sigParts, attached);\n                } catch (WSSecurityException ex) {\n                    throw new Fault(ex);\n                } catch (SOAPException ex) {\n                    throw new Fault(ex);\n                }\n            }\n\n            if (isRequestor()) {\n                doEndorse();\n            }\n            \n            // Check for signature protection\n            if (abinding.isSignatureProtection() && mainSigId != null) {\n                List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n\n                // Now encrypt the signature using the above token\n                WSEncryptionPart sigPart = new WSEncryptionPart(mainSigId, \"Element\");\n                sigPart.setElement(bottomUpElement);\n                secondEncrParts.add(sigPart);\n                \n                if (isRequestor()) {\n                    for (String id : encryptedTokensIdList) {\n                        secondEncrParts.add(new WSEncryptionPart(id, \"Element\"));\n                    }\n                }\n\n                if (encryptionToken.isDerivedKeys()) {\n                    try {\n                        Element secondRefList \n                            = ((WSSecDKEncrypt)encrBase).encryptForExternalRef(null, secondEncrParts);\n                        ((WSSecDKEncrypt)encrBase).addExternalRefElement(secondRefList, secHeader);\n\n                    } catch (WSSecurityException ex) {\n                        throw new Fault(ex);\n                    }\n                } else {\n                    try {\n                        // Encrypt, get hold of the ref list and add it\n                        Element secondRefList = saaj.getSOAPPart()\n                            .createElementNS(WSConstants.ENC_NS,\n                                             WSConstants.ENC_PREFIX + \":ReferenceList\");\n                        this.insertBeforeBottomUp(secondRefList);\n                        ((WSSecEncrypt)encrBase).encryptForRef(secondRefList, secondEncrParts);\n                        \n                    } catch (WSSecurityException ex) {\n                        throw new Fault(ex);\n                    }\n                }\n            }\n        }\n    }","id":9015,"modified_method":"private void doEncryptBeforeSign() {\n        TokenWrapper wrapper;\n        Token encryptionToken = null;\n        if (isRequestor()) {\n            wrapper = abinding.getRecipientToken();\n        } else {\n            wrapper = abinding.getInitiatorToken();\n        }\n        encryptionToken = wrapper.getToken();\n        \n        TokenWrapper initiatorWrapper = abinding.getInitiatorToken();\n        boolean attached = false;\n        if (initiatorWrapper != null) {\n            Token initiatorToken = initiatorWrapper.getToken();\n            if (initiatorToken instanceof IssuedToken) {\n                SecurityToken secToken = getSecurityToken();\n                if (secToken == null) {\n                    policyNotAsserted(initiatorToken, \"No intiator token id\");\n                    return;\n                } else {\n                    policyAsserted(initiatorToken);\n                    \n                    if (includeToken(initiatorToken.getInclusion())) {\n                        Element el = secToken.getToken();\n                        this.addEncryptedKeyElement(cloneElement(el));\n                        attached = true;\n                    } \n                }\n            }\n        }\n        \n        List<WSEncryptionPart> encrParts = null;\n        List<WSEncryptionPart> sigParts = null;\n        try {\n            encrParts = getEncryptedParts();\n            //Signed parts are determined before encryption because encrypted signed  headers\n            //will not be included otherwise\n            sigParts = getSignedParts();\n        } catch (SOAPException ex) {\n            throw new Fault(ex);\n        }\n        \n        //if (encryptionToken == null && encrParts.size() > 0) {\n            //REVISIT - no token to encrypt with  \n        //}\n        \n        if (encryptionToken != null && encrParts.size() > 0) {\n            WSSecBase encrBase = doEncryption(wrapper, encrParts, true);\n            handleEncryptedSignedHeaders(encrParts, sigParts);\n            \n            if (timestampEl != null) {\n                WSEncryptionPart timestampPart = \n                    convertToEncryptionPart(timestampEl.getElement());\n                sigParts.add(timestampPart);\n            }\n            \n            if (isRequestor()) {\n                try {\n                    addSupportingTokens(sigParts);\n                } catch (WSSecurityException ex) {\n                    policyNotAsserted(encryptionToken, ex.getMessage());\n                }\n            } else {\n                addSignatureConfirmation(sigParts);\n            }\n            \n            if ((sigParts.size() > 0 \n                    && isRequestor()\n                    && abinding.getInitiatorToken() != null) \n                || (!isRequestor() && abinding.getRecipientToken() != null)) {\n                try {\n                    doSignature(sigParts, attached);\n                } catch (WSSecurityException ex) {\n                    throw new Fault(ex);\n                } catch (SOAPException ex) {\n                    throw new Fault(ex);\n                }\n            }\n\n            if (isRequestor()) {\n                doEndorse();\n            }\n            \n            // Check for signature protection\n            if (abinding.isSignatureProtection()) {\n                List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n\n                // Now encrypt the signature using the above token\n                if (mainSigId != null) {\n                    WSEncryptionPart sigPart = new WSEncryptionPart(mainSigId, \"Element\");\n                    sigPart.setElement(bottomUpElement);\n                    secondEncrParts.add(sigPart);\n                }\n                \n                if (sigConfList != null && !sigConfList.isEmpty()) {\n                    secondEncrParts.addAll(sigConfList);\n                }\n                \n                if (isRequestor()) {\n                    for (String id : encryptedTokensIdList) {\n                        secondEncrParts.add(new WSEncryptionPart(id, \"Element\"));\n                    }\n                }\n\n                if (encryptionToken.isDerivedKeys() && !secondEncrParts.isEmpty()) {\n                    try {\n                        Element secondRefList \n                            = ((WSSecDKEncrypt)encrBase).encryptForExternalRef(null, secondEncrParts);\n                        ((WSSecDKEncrypt)encrBase).addExternalRefElement(secondRefList, secHeader);\n\n                    } catch (WSSecurityException ex) {\n                        throw new Fault(ex);\n                    }\n                } else if (!secondEncrParts.isEmpty()) {\n                    try {\n                        // Encrypt, get hold of the ref list and add it\n                        Element secondRefList = saaj.getSOAPPart()\n                            .createElementNS(WSConstants.ENC_NS,\n                                             WSConstants.ENC_PREFIX + \":ReferenceList\");\n                        this.insertBeforeBottomUp(secondRefList);\n                        ((WSSecEncrypt)encrBase).encryptForRef(secondRefList, secondEncrParts);\n                        \n                    } catch (WSSecurityException ex) {\n                        throw new Fault(ex);\n                    }\n                }\n            }\n        }\n    }","commit_id":"e15186233dcb200fd4960f324b86e7e7dc2e73c4","url":"https://github.com/apache/cxf"},{"original_method":"private void doSignBeforeEncrypt() {\n        try {\n            TokenWrapper initiatorWrapper = abinding.getInitiatorToken();\n            boolean attached = false;\n            if (initiatorWrapper != null) {\n                Token initiatorToken = initiatorWrapper.getToken();\n                if (initiatorToken instanceof IssuedToken) {\n                    SecurityToken secToken = getSecurityToken();\n                    if (secToken == null) {\n                        policyNotAsserted(initiatorToken, \"No intiator token id\");\n                        return;\n                    } else {\n                        policyAsserted(initiatorToken);\n                        \n                        if (includeToken(initiatorToken.getInclusion())) {\n                            Element el = secToken.getToken();\n                            this.addEncryptedKeyElement(cloneElement(el));\n                            attached = true;\n                        } \n                    }\n                }\n            }\n            \n            List<WSEncryptionPart> sigs = new ArrayList<WSEncryptionPart>();\n            if (isRequestor()) {\n                //Add timestamp\n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigs.add(timestampPart);\n                }\n\n                addSupportingTokens(sigs);\n                doSignature(sigs, attached);\n                doEndorse();\n            } else {\n                //confirm sig\n                assertSupportingTokens(sigs);\n                \n                //Add timestamp\n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigs.add(timestampPart);\n                }\n\n                addSignatureConfirmation(sigs);\n                doSignature(sigs, attached);\n            }\n\n            List<WSEncryptionPart> enc = getEncryptedParts();\n            \n            //Check for signature protection\n            if (abinding.isSignatureProtection() && mainSigId != null) {\n                WSEncryptionPart sigPart = new WSEncryptionPart(mainSigId, \"Element\");\n                sigPart.setElement(bottomUpElement);\n                enc.add(sigPart);\n            }\n            \n            if (isRequestor()) {\n                for (String id : encryptedTokensIdList) {\n                    enc.add(new WSEncryptionPart(id, \"Element\"));\n                }\n            }\n\n            //Do encryption\n            RecipientToken recToken = abinding.getRecipientToken();\n            \n            doEncryption(recToken, enc, false);\n        } catch (Exception e) {\n            String reason = e.getMessage();\n            LOG.log(Level.WARNING, \"Sign before encryption failed due to : \" + reason);\n            throw new Fault(e);\n        }\n    }","id":9016,"modified_method":"private void doSignBeforeEncrypt() {\n        try {\n            TokenWrapper initiatorWrapper = abinding.getInitiatorToken();\n            boolean attached = false;\n            if (initiatorWrapper != null) {\n                Token initiatorToken = initiatorWrapper.getToken();\n                if (initiatorToken instanceof IssuedToken) {\n                    SecurityToken secToken = getSecurityToken();\n                    if (secToken == null) {\n                        policyNotAsserted(initiatorToken, \"No intiator token id\");\n                        return;\n                    } else {\n                        policyAsserted(initiatorToken);\n                        \n                        if (includeToken(initiatorToken.getInclusion())) {\n                            Element el = secToken.getToken();\n                            this.addEncryptedKeyElement(cloneElement(el));\n                            attached = true;\n                        } \n                    }\n                }\n            }\n            \n            List<WSEncryptionPart> sigs = new ArrayList<WSEncryptionPart>();\n            if (isRequestor()) {\n                //Add timestamp\n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigs.add(timestampPart);\n                }\n\n                addSupportingTokens(sigs);\n                doSignature(sigs, attached);\n                doEndorse();\n            } else {\n                //confirm sig\n                assertSupportingTokens(sigs);\n                \n                //Add timestamp\n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigs.add(timestampPart);\n                }\n\n                addSignatureConfirmation(sigs);\n                doSignature(sigs, attached);\n            }\n\n            List<WSEncryptionPart> enc = getEncryptedParts();\n            \n            //Check for signature protection\n            if (abinding.isSignatureProtection()) {\n                if (mainSigId != null) {\n                    WSEncryptionPart sigPart = new WSEncryptionPart(mainSigId, \"Element\");\n                    sigPart.setElement(bottomUpElement);\n                    enc.add(sigPart);\n                }\n                if (sigConfList != null && !sigConfList.isEmpty()) {\n                    enc.addAll(sigConfList);\n                }\n            }\n            \n            if (isRequestor()) {\n                for (String id : encryptedTokensIdList) {\n                    enc.add(new WSEncryptionPart(id, \"Element\"));\n                }\n            }\n\n            //Do encryption\n            RecipientToken recToken = abinding.getRecipientToken();\n            \n            doEncryption(recToken, enc, false);\n        } catch (Exception e) {\n            String reason = e.getMessage();\n            LOG.log(Level.WARNING, \"Sign before encryption failed due to : \" + reason);\n            throw new Fault(e);\n        }\n    }","commit_id":"e15186233dcb200fd4960f324b86e7e7dc2e73c4","url":"https://github.com/apache/cxf"},{"original_method":"private void doEncryptBeforeSign() {\n        try {\n            TokenWrapper encryptionWrapper = getEncryptionToken();\n            Token encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            //if (encryptionToken == null && encrParts.size() > 0) {\n                //REVISIT - nothing to encrypt?\n            //}\n            \n            if (encryptionToken != null && encrParts.size() > 0) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken || encryptionToken instanceof KerberosToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                }\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                \n                if (includeToken(encryptionToken.getInclusion())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                if (isRequestor()) {\n                    this.addSupportingTokens(sigParts);\n                } else {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isSignatureProtection() && this.mainSigId != null \n                    || encryptedTokensIdList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isSignatureProtection()) {\n                        WSEncryptionPart sigPart = \n                            new WSEncryptionPart(this.mainSigId, \"Element\");\n                        sigPart.setElement(bottomUpElement);\n                        secondEncrParts.add(sigPart);\n                    }\n                    \n                    if (isRequestor()) {\n                        for (String s : encryptedTokensIdList) {\n                            secondEncrParts.add(new WSEncryptionPart(s, \"Element\"));\n                        }\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.isDerivedKeys()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new Fault(ex);\n        }\n    }","id":9017,"modified_method":"private void doEncryptBeforeSign() {\n        try {\n            TokenWrapper encryptionWrapper = getEncryptionToken();\n            Token encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            //if (encryptionToken == null && encrParts.size() > 0) {\n                //REVISIT - nothing to encrypt?\n            //}\n            \n            if (encryptionToken != null && encrParts.size() > 0) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken || encryptionToken instanceof KerberosToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                }\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                \n                if (includeToken(encryptionToken.getInclusion())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                if (isRequestor()) {\n                    this.addSupportingTokens(sigParts);\n                } else {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isSignatureProtection() \n                    || encryptedTokensIdList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isSignatureProtection()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                    }\n                    \n                    if (isRequestor()) {\n                        for (String s : encryptedTokensIdList) {\n                            secondEncrParts.add(new WSEncryptionPart(s, \"Element\"));\n                        }\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.isDerivedKeys() && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new Fault(ex);\n        }\n    }","commit_id":"e15186233dcb200fd4960f324b86e7e7dc2e73c4","url":"https://github.com/apache/cxf"},{"original_method":"private void doSignBeforeEncrypt() {\n        TokenWrapper sigTokenWrapper = getSignatureToken();\n        Token sigToken = sigTokenWrapper.getToken();\n        \n        \n        String sigTokId = null;\n        Element sigTokElem = null;\n        \n        try {\n            SecurityToken sigTok = null;\n            if (sigToken != null) {\n                if (sigToken instanceof SecureConversationToken\n                    || sigToken instanceof SecurityContextToken) {\n                    sigTok = getSecurityToken();\n                } else if (sigToken instanceof IssuedToken || sigToken instanceof KerberosToken) {\n                    sigTok = getSecurityToken();\n                } else if (sigToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        sigTokId = setupEncryptedKey(sigTokenWrapper, sigToken);\n                    } else {\n                        sigTokId = getEncryptedKey();\n                    }\n                }\n            } else {\n                policyNotAsserted(sbinding, \"No signature token\");\n                return;\n            }\n            \n            if (sigTok == null && StringUtils.isEmpty(sigTokId)) {\n                policyNotAsserted(sigTokenWrapper, \"No signature token id\");\n                return;\n            } else {\n                policyAsserted(sigTokenWrapper);\n            }\n            if (sigTok == null) {\n                sigTok = tokenStore.getToken(sigTokId);\n            }\n            //if (sigTok == null) {\n                //REVISIT - no token?\n            //}\n            \n            boolean tokIncluded = true;\n            if (includeToken(sigToken.getInclusion())) {\n                Element el = sigTok.getToken();\n                sigTokElem = cloneElement(el);\n                this.addEncryptedKeyElement(sigTokElem);\n            } else if (isRequestor() && sigToken instanceof X509Token) {\n                Element el = sigTok.getToken();\n                sigTokElem = cloneElement(el);\n                this.addEncryptedKeyElement(sigTokElem);\n            } else {\n                tokIncluded = false;\n            }\n        \n            List<WSEncryptionPart> sigs = getSignedParts();\n            //Add timestamp\n            if (timestampEl != null) {\n                WSEncryptionPart timestampPart = convertToEncryptionPart(timestampEl.getElement());\n                sigs.add(timestampPart);        \n            }\n\n            if (isRequestor()) {\n                addSupportingTokens(sigs);\n                if (!sigs.isEmpty()) {\n                    signatures.add(doSignature(sigs, sigTokenWrapper, sigToken, sigTok, tokIncluded));\n                }\n                doEndorse();\n            } else {\n                //confirm sig\n                assertSupportingTokens(sigs);\n                addSignatureConfirmation(sigs);\n                if (!sigs.isEmpty()) {\n                    doSignature(sigs, sigTokenWrapper, sigToken, sigTok, tokIncluded);\n                }\n            }\n\n            //Encryption\n            TokenWrapper encrTokenWrapper = getEncryptionToken();\n            Token encrToken = encrTokenWrapper.getToken();\n            SecurityToken encrTok = null;\n            if (sigToken.equals(encrToken)) {\n                //Use the same token\n                encrTok = sigTok;\n            } else {\n                String encrTokId = null;\n                //REVISIT - issued token from trust? \n                encrTok = tokenStore.getToken(encrTokId);\n                \n                if (includeToken(encrToken.getInclusion())) {\n                    Element encrTokElem = (Element)encrTok.getToken();\n                    \n                    //Add the encrToken element before the sigToken element\n                    secHeader.getSecurityHeader().insertBefore(encrTokElem, sigTokElem);\n                }\n            }\n            \n            List<WSEncryptionPart> enc = getEncryptedParts();\n            \n            //Check for signature protection\n            if (sbinding.isSignatureProtection() && mainSigId != null) {\n                WSEncryptionPart sigPart = new WSEncryptionPart(mainSigId, \"Element\");\n                sigPart.setElement(bottomUpElement);\n                enc.add(sigPart);\n            }\n            \n            if (isRequestor()) {\n                for (String id : encryptedTokensIdList) {\n                    enc.add(new WSEncryptionPart(id, \"Element\"));\n                }\n            }\n            doEncryption(encrTokenWrapper,\n                         encrTok,\n                         tokIncluded,\n                         enc,\n                         false);\n        } catch (Exception e) {\n            throw new Fault(e);\n        }\n    }","id":9018,"modified_method":"private void doSignBeforeEncrypt() {\n        TokenWrapper sigTokenWrapper = getSignatureToken();\n        Token sigToken = sigTokenWrapper.getToken();\n        \n        \n        String sigTokId = null;\n        Element sigTokElem = null;\n        \n        try {\n            SecurityToken sigTok = null;\n            if (sigToken != null) {\n                if (sigToken instanceof SecureConversationToken\n                    || sigToken instanceof SecurityContextToken) {\n                    sigTok = getSecurityToken();\n                } else if (sigToken instanceof IssuedToken || sigToken instanceof KerberosToken) {\n                    sigTok = getSecurityToken();\n                } else if (sigToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        sigTokId = setupEncryptedKey(sigTokenWrapper, sigToken);\n                    } else {\n                        sigTokId = getEncryptedKey();\n                    }\n                }\n            } else {\n                policyNotAsserted(sbinding, \"No signature token\");\n                return;\n            }\n            \n            if (sigTok == null && StringUtils.isEmpty(sigTokId)) {\n                policyNotAsserted(sigTokenWrapper, \"No signature token id\");\n                return;\n            } else {\n                policyAsserted(sigTokenWrapper);\n            }\n            if (sigTok == null) {\n                sigTok = tokenStore.getToken(sigTokId);\n            }\n            //if (sigTok == null) {\n                //REVISIT - no token?\n            //}\n            \n            boolean tokIncluded = true;\n            if (includeToken(sigToken.getInclusion())) {\n                Element el = sigTok.getToken();\n                sigTokElem = cloneElement(el);\n                this.addEncryptedKeyElement(sigTokElem);\n            } else if (isRequestor() && sigToken instanceof X509Token) {\n                Element el = sigTok.getToken();\n                sigTokElem = cloneElement(el);\n                this.addEncryptedKeyElement(sigTokElem);\n            } else {\n                tokIncluded = false;\n            }\n        \n            List<WSEncryptionPart> sigs = getSignedParts();\n            //Add timestamp\n            if (timestampEl != null) {\n                WSEncryptionPart timestampPart = convertToEncryptionPart(timestampEl.getElement());\n                sigs.add(timestampPart);        \n            }\n\n            if (isRequestor()) {\n                addSupportingTokens(sigs);\n                if (!sigs.isEmpty()) {\n                    signatures.add(doSignature(sigs, sigTokenWrapper, sigToken, sigTok, tokIncluded));\n                }\n                doEndorse();\n            } else {\n                //confirm sig\n                assertSupportingTokens(sigs);\n                addSignatureConfirmation(sigs);\n                if (!sigs.isEmpty()) {\n                    doSignature(sigs, sigTokenWrapper, sigToken, sigTok, tokIncluded);\n                }\n            }\n\n            //Encryption\n            TokenWrapper encrTokenWrapper = getEncryptionToken();\n            Token encrToken = encrTokenWrapper.getToken();\n            SecurityToken encrTok = null;\n            if (sigToken.equals(encrToken)) {\n                //Use the same token\n                encrTok = sigTok;\n            } else {\n                String encrTokId = null;\n                //REVISIT - issued token from trust? \n                encrTok = tokenStore.getToken(encrTokId);\n                \n                if (includeToken(encrToken.getInclusion())) {\n                    Element encrTokElem = (Element)encrTok.getToken();\n                    \n                    //Add the encrToken element before the sigToken element\n                    secHeader.getSecurityHeader().insertBefore(encrTokElem, sigTokElem);\n                }\n            }\n            \n            List<WSEncryptionPart> enc = getEncryptedParts();\n            \n            //Check for signature protection\n            if (sbinding.isSignatureProtection()) {\n                if (mainSigId != null) {\n                    WSEncryptionPart sigPart = new WSEncryptionPart(mainSigId, \"Element\");\n                    sigPart.setElement(bottomUpElement);\n                    enc.add(sigPart);\n                }\n                if (sigConfList != null && !sigConfList.isEmpty()) {\n                    enc.addAll(sigConfList);\n                }\n            }\n            \n            if (isRequestor()) {\n                for (String id : encryptedTokensIdList) {\n                    enc.add(new WSEncryptionPart(id, \"Element\"));\n                }\n            }\n            doEncryption(encrTokenWrapper,\n                         encrTok,\n                         tokIncluded,\n                         enc,\n                         false);\n        } catch (Exception e) {\n            throw new Fault(e);\n        }\n    }","commit_id":"e15186233dcb200fd4960f324b86e7e7dc2e73c4","url":"https://github.com/apache/cxf"},{"original_method":"public void saveRep(Repository rep, long id_job)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.saveRep(rep, id_job);\n\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename1\", filename1); //$NON-NLS-1$\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename2\", filename2); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"JobEntryFileCompare.ERROR_0003_Unable_To_Save_Job\", Long.toString(id_job)), dbe); //$NON-NLS-1$\n\t\t}\n\t}","id":9019,"modified_method":"public void saveRep(Repository rep, long id_job)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.saveRep(rep, id_job);\n\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename1\", filename1); //$NON-NLS-1$\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename2\", filename2); //$NON-NLS-1$\r\n            rep.saveJobEntryAttribute(id_job, getID(), \"add_filename_result\", addFilenameToResult);\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"JobEntryFileCompare.ERROR_0003_Unable_To_Save_Job\", Long.toString(id_job)), dbe); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadXML(Node entrynode, List<DatabaseMeta> databases, List<SlaveServer> slaveServers, Repository rep)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadXML(entrynode, databases, slaveServers);\n\t\t\tfilename1 = XMLHandler.getTagValue(entrynode, \"filename1\"); //$NON-NLS-1$\n\t\t\tfilename2 = XMLHandler.getTagValue(entrynode, \"filename2\"); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleXMLException xe)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"JobEntryFileCompare.ERROR_0001_Unable_To_Load_From_Xml_Node\"), xe); //$NON-NLS-1$\n\t\t}\n\t}","id":9020,"modified_method":"public void loadXML(Node entrynode, List<DatabaseMeta> databases, List<SlaveServer> slaveServers, Repository rep)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadXML(entrynode, databases, slaveServers);\n\t\t\tfilename1 = XMLHandler.getTagValue(entrynode, \"filename1\"); //$NON-NLS-1$\n\t\t\tfilename2 = XMLHandler.getTagValue(entrynode, \"filename2\"); //$NON-NLS-1$\r\n\t\t\taddFilenameToResult = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"add_filename_result\"));\n\t\t}\n\t\tcatch(KettleXMLException xe)\n\t\t{\n\t\t\tthrow new KettleXMLException(Messages.getString(\"JobEntryFileCompare.ERROR_0001_Unable_To_Load_From_Xml_Node\"), xe); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(50);\n\n\t\tretval.append(super.getXML());\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename1\", filename1)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename2\", filename2)); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\treturn retval.toString();\n\t}","id":9021,"modified_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(50);\n\n\t\tretval.append(super.getXML());\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename1\", filename1)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename2\", filename2)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_filename_result\", addFilenameToResult));\n\t\treturn retval.toString();\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryFileCompare(String n)\n\t{\n\t\tsuper(n, \"\"); //$NON-NLS-1$\n     \tfilename1 = null;\n     \tfilename2=null;\n\t\tsetID(-1L);\n\t\tsetJobEntryType(JobEntryType.FILE_COMPARE);\n\t}","id":9022,"modified_method":"public JobEntryFileCompare(String n)\n\t{\n\t\tsuper(n, \"\"); //$NON-NLS-1$\n     \tfilename1 = null;\n     \tfilename2=null;\r\n     \taddFilenameToResult=false;\n\t\tsetID(-1L);\n\t\tsetJobEntryType(JobEntryType.FILE_COMPARE);\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tResult result = previousResult;\n\t\tresult.setResult( false );\n\n\t\tString realFilename1 = getRealFilename1();\n\t\tString realFilename2 = getRealFilename2();\n\n\t\tFileObject file1 = null;\n\t\tFileObject file2 = null;\n\t\ttry\n\t\t{\n\t\t\tif (filename1!=null && filename2!=null)\n\t\t\t{\n\t\t\t\tfile1 = KettleVFS.getFileObject(realFilename1);\n\t\t\t\tfile2 = KettleVFS.getFileObject(realFilename2);\n\n\t\t\t\tif ( file1.exists() && file2.exists() )\n\t\t\t\t{\n\t\t\t\t\tif ( equalFileContents(file1, file2) )\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.setResult( true );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.setResult( false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( ! file1.exists() )\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0004_File1_Does_Not_Exist\", realFilename1)); //$NON-NLS-1$\n\t\t\t\t\tif ( ! file2.exists() )\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0005_File2_Does_Not_Exist\", realFilename2)); //$NON-NLS-1$\n\t\t\t\t\tresult.setResult( false );\n\t\t\t\t\tresult.setNrErrors(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0006_Need_Two_Filenames\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\tresult.setResult( false );\n\t\t\tresult.setNrErrors(1);\n\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0007_Comparing_Files\", realFilename2, realFilename2, e.getMessage())); //$NON-NLS-1$\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t    if ( file1 != null )\n\t\t\t    \tfile1.close();\n\n\t\t\t    if ( file2 != null )\n\t\t\t    \tfile2.close();\n\t\t    }\n\t\t\tcatch ( IOException e ) { }\n\t\t}\n\n\n\t\treturn result;\n\t}","id":9023,"modified_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\tResult result = previousResult;\n\t\tresult.setResult( false );\n\n\t\tString realFilename1 = getRealFilename1();\n\t\tString realFilename2 = getRealFilename2();\n\n\t\tFileObject file1 = null;\n\t\tFileObject file2 = null;\n\t\ttry\n\t\t{\n\t\t\tif (filename1!=null && filename2!=null)\n\t\t\t{\n\t\t\t\tfile1 = KettleVFS.getFileObject(realFilename1);\n\t\t\t\tfile2 = KettleVFS.getFileObject(realFilename2);\n\n\t\t\t\tif ( file1.exists() && file2.exists() )\n\t\t\t\t{\n\t\t\t\t\tif ( equalFileContents(file1, file2) )\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.setResult( true );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.setResult( false );\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t//add filename to result filenames\r\n\t\t\t\t\tif(addFilenameToResult && file1.getType()==FileType.FILE && file2.getType()==FileType.FILE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL , file1, parentJob.getName(), toString());\r\n\t\t\t\t\t\tresultFile.setComment(Messages.getString(\"JobWaitForFile.FilenameAdded\"));\r\n\t\t\t\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n\t\t\t\t\t\tresultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL , file2, parentJob.getName(), toString());\r\n\t\t\t\t\t\tresultFile.setComment(Messages.getString(\"JobWaitForFile.FilenameAdded\"));\r\n\t\t\t\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( ! file1.exists() )\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0004_File1_Does_Not_Exist\", realFilename1)); //$NON-NLS-1$\n\t\t\t\t\tif ( ! file2.exists() )\n\t\t\t\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0005_File2_Does_Not_Exist\", realFilename2)); //$NON-NLS-1$\n\t\t\t\t\tresult.setResult( false );\n\t\t\t\t\tresult.setNrErrors(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0006_Need_Two_Filenames\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception e )\n\t\t{\n\t\t\tresult.setResult( false );\n\t\t\tresult.setNrErrors(1);\n\t\t\tlog.logError(toString(), Messages.getString(\"JobEntryFileCompare.ERROR_0007_Comparing_Files\", realFilename2, realFilename2, e.getMessage())); //$NON-NLS-1$\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t    if ( file1 != null )\n\t\t\t    \tfile1.close();\n\n\t\t\t    if ( file2 != null )\n\t\t\t    \tfile2.close();\n\t\t    }\n\t\t\tcatch ( IOException e ) { }\n\t\t}\n\n\n\t\treturn result;\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, List<DatabaseMeta> databases, List<SlaveServer> slaveServers) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases, slaveServers);\n\t\t\tfilename1 = rep.getJobEntryAttributeString(id_jobentry, \"filename1\"); //$NON-NLS-1$\n\t\t\tfilename2 = rep.getJobEntryAttributeString(id_jobentry, \"filename2\"); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"JobEntryFileCompare.ERROR_0002_Unable_To_Load_Job_From_Repository\", Long.toString(id_jobentry)), dbe); //$NON-NLS-1$\n\t\t}\n\t}","id":9024,"modified_method":"public void loadRep(Repository rep, long id_jobentry, List<DatabaseMeta> databases, List<SlaveServer> slaveServers) throws KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases, slaveServers);\n\t\t\tfilename1 = rep.getJobEntryAttributeString(id_jobentry, \"filename1\"); //$NON-NLS-1$\n\t\t\tfilename2 = rep.getJobEntryAttributeString(id_jobentry, \"filename2\"); //$NON-NLS-1$\r\n\t\t\taddFilenameToResult = rep.getJobEntryAttributeBoolean(id_jobentry, \"add_filename_result\");\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(Messages.getString(\"JobEntryFileCompare.ERROR_0002_Unable_To_Load_Job_From_Repository\", Long.toString(id_jobentry)), dbe); //$NON-NLS-1$\n\t\t}\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobFileCompare.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Name line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobFileCompare.Name.Label\"));\n \t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Filename 1 line\n\t\twlFilename1=new Label(shell, SWT.RIGHT);\n\t\twlFilename1.setText(Messages.getString(\"JobFileCompare.Filename1.Label\"));\n \t\tprops.setLook(wlFilename1);\n\t\tfdlFilename1=new FormData();\n\t\tfdlFilename1.left = new FormAttachment(0, 0);\n\t\tfdlFilename1.top  = new FormAttachment(wName, margin);\n\t\tfdlFilename1.right= new FormAttachment(middle, -margin);\n\t\twlFilename1.setLayoutData(fdlFilename1);\n\t\twbFilename1=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbFilename1);\n\t\twbFilename1.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename1=new FormData();\n\t\tfdbFilename1.right= new FormAttachment(100, 0);\n\t\tfdbFilename1.top  = new FormAttachment(wName, 0);\n\t\twbFilename1.setLayoutData(fdbFilename1);\n\t\twFilename1=new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename1);\n\t\twFilename1.addModifyListener(lsMod);\n\t\tfdFilename1=new FormData();\n\t\tfdFilename1.left = new FormAttachment(middle, 0);\n\t\tfdFilename1.top  = new FormAttachment(wName, margin);\n\t\tfdFilename1.right= new FormAttachment(wbFilename1, -margin);\n\t\twFilename1.setLayoutData(fdFilename1);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename1.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename1.setToolTipText(jobMeta.environmentSubstitute( wFilename1.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbFilename1.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*\"});\n\t\t\t\t\tif (wFilename1.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename1.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twFilename1.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Filename 2 line\n\t\twlFilename2=new Label(shell, SWT.RIGHT);\n\t\twlFilename2.setText(Messages.getString(\"JobFileCompare.Filename2.Label\"));\n \t\tprops.setLook(wlFilename2);\n\t\tfdlFilename2=new FormData();\n\t\tfdlFilename2.left = new FormAttachment(0, 0);\n\t\tfdlFilename2.top  = new FormAttachment(wFilename1, margin);\n\t\tfdlFilename2.right= new FormAttachment(middle, -margin);\n\t\twlFilename2.setLayoutData(fdlFilename2);\n\t\twbFilename2=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbFilename2);\n\t\twbFilename2.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename2=new FormData();\n\t\tfdbFilename2.right= new FormAttachment(100, 0);\n\t\tfdbFilename2.top  = new FormAttachment(wFilename1, 0);\n\t\twbFilename2.setLayoutData(fdbFilename2);\n\t\twFilename2=new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename2);\n\t\twFilename2.addModifyListener(lsMod);\n\t\tfdFilename2=new FormData();\n\t\tfdFilename2.left = new FormAttachment(middle, 0);\n\t\tfdFilename2.top  = new FormAttachment(wFilename1, margin);\n\t\tfdFilename2.right= new FormAttachment(wbFilename2, -margin);\n\t\twFilename2.setLayoutData(fdFilename2);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename2.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename2.setToolTipText(jobMeta.environmentSubstitute( wFilename2.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbFilename2.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*\"});\n\t\t\t\t\tif (wFilename2.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename2.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twFilename2.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wFilename2);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twFilename1.addSelectionListener( lsDef );\n\t\twFilename2.addSelectionListener( lsDef );\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","id":9025,"modified_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobFileCompare.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Name line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobFileCompare.Name.Label\"));\n \t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Filename 1 line\n\t\twlFilename1=new Label(shell, SWT.RIGHT);\n\t\twlFilename1.setText(Messages.getString(\"JobFileCompare.Filename1.Label\"));\n \t\tprops.setLook(wlFilename1);\n\t\tfdlFilename1=new FormData();\n\t\tfdlFilename1.left = new FormAttachment(0, 0);\n\t\tfdlFilename1.top  = new FormAttachment(wName, margin);\n\t\tfdlFilename1.right= new FormAttachment(middle, -margin);\n\t\twlFilename1.setLayoutData(fdlFilename1);\n\t\twbFilename1=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbFilename1);\n\t\twbFilename1.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename1=new FormData();\n\t\tfdbFilename1.right= new FormAttachment(100, 0);\n\t\tfdbFilename1.top  = new FormAttachment(wName, 0);\n\t\twbFilename1.setLayoutData(fdbFilename1);\n\t\twFilename1=new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename1);\n\t\twFilename1.addModifyListener(lsMod);\n\t\tfdFilename1=new FormData();\n\t\tfdFilename1.left = new FormAttachment(middle, 0);\n\t\tfdFilename1.top  = new FormAttachment(wName, margin);\n\t\tfdFilename1.right= new FormAttachment(wbFilename1, -margin);\n\t\twFilename1.setLayoutData(fdFilename1);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename1.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename1.setToolTipText(jobMeta.environmentSubstitute( wFilename1.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbFilename1.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*\"});\n\t\t\t\t\tif (wFilename1.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename1.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twFilename1.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Filename 2 line\n\t\twlFilename2=new Label(shell, SWT.RIGHT);\n\t\twlFilename2.setText(Messages.getString(\"JobFileCompare.Filename2.Label\"));\n \t\tprops.setLook(wlFilename2);\n\t\tfdlFilename2=new FormData();\n\t\tfdlFilename2.left = new FormAttachment(0, 0);\n\t\tfdlFilename2.top  = new FormAttachment(wFilename1, margin);\n\t\tfdlFilename2.right= new FormAttachment(middle, -margin);\n\t\twlFilename2.setLayoutData(fdlFilename2);\n\t\twbFilename2=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbFilename2);\n\t\twbFilename2.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename2=new FormData();\n\t\tfdbFilename2.right= new FormAttachment(100, 0);\n\t\tfdbFilename2.top  = new FormAttachment(wFilename1, 0);\n\t\twbFilename2.setLayoutData(fdbFilename2);\n\t\twFilename2=new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename2);\n\t\twFilename2.addModifyListener(lsMod);\n\t\tfdFilename2=new FormData();\n\t\tfdFilename2.left = new FormAttachment(middle, 0);\n\t\tfdFilename2.top  = new FormAttachment(wFilename1, margin);\n\t\tfdFilename2.right= new FormAttachment(wbFilename2, -margin);\n\t\twFilename2.setLayoutData(fdFilename2);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename2.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename2.setToolTipText(jobMeta.environmentSubstitute( wFilename2.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbFilename2.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*\"});\n\t\t\t\t\tif (wFilename2.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename2.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twFilename2.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\t// Add filename to result filenames\t\t\r\n        wlAddFilenameResult = new Label(shell, SWT.RIGHT);\r\n        wlAddFilenameResult.setText(Messages.getString(\"JobFileCompare.AddFilenameResult.Label\"));\r\n        props.setLook(wlAddFilenameResult);\r\n        fdlAddFilenameResult = new FormData();\r\n        fdlAddFilenameResult.left = new FormAttachment(0, 0);\r\n        fdlAddFilenameResult.top = new FormAttachment(wbFilename2, margin);\r\n        fdlAddFilenameResult.right = new FormAttachment(middle, -margin);\r\n        wlAddFilenameResult.setLayoutData(fdlAddFilenameResult);\r\n        wAddFilenameResult = new Button(shell, SWT.CHECK);\r\n        props.setLook(wAddFilenameResult);\r\n        wAddFilenameResult.setToolTipText(Messages.getString(\"JobFileCompare.AddFilenameResult.Tooltip\"));\r\n        fdAddFilenameResult = new FormData();\r\n        fdAddFilenameResult.left = new FormAttachment(middle, 0);\r\n        fdAddFilenameResult.top = new FormAttachment(wbFilename2, margin);\r\n        fdAddFilenameResult.right = new FormAttachment(100, 0);\r\n        wAddFilenameResult.setLayoutData(fdAddFilenameResult);\r\n        wAddFilenameResult.addSelectionListener(new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                jobEntry.setChanged();\r\n            }\r\n        }); \r\n        \n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wAddFilenameResult);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twFilename1.addSelectionListener( lsDef );\n\t\twFilename2.addSelectionListener( lsDef );\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\tif (jobEntry.getName()    != null) wName.setText( jobEntry.getName() );\n\t\twName.selectAll();\n\t\tif (jobEntry.getFilename1()!= null) wFilename1.setText( jobEntry.getFilename1() );\n\t\tif (jobEntry.getFilename2()!= null) wFilename2.setText( jobEntry.getFilename2() );\n\t}","id":9026,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\tif (jobEntry.getName()    != null) wName.setText( jobEntry.getName() );\n\t\twName.selectAll();\n\t\tif (jobEntry.getFilename1()!= null) wFilename1.setText( jobEntry.getFilename1() );\n\t\tif (jobEntry.getFilename2()!= null) wFilename2.setText( jobEntry.getFilename2() );\r\n\t\twAddFilenameResult.setSelection(jobEntry.isAddFilenameToResult());\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setFilename1(wFilename1.getText());\n\t\tjobEntry.setFilename2(wFilename2.getText());\n\t\tdispose();\n\t}","id":9027,"modified_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setFilename1(wFilename1.getText());\n\t\tjobEntry.setFilename2(wFilename2.getText());\r\n\t\tjobEntry.setAddFilenameToResult(wAddFilenameResult.getSelection());\n\t\tdispose();\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void saveRep(Repository rep, long id_job)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.saveRep(rep, id_job);\n\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename\", filename);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"maximum_timeout\", maximumTimeout);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"check_cycle_time\", checkCycleTime);\n            rep.saveJobEntryAttribute(id_job, getID(), \"success_on_timeout\", successOnTimeout);\n            rep.saveJobEntryAttribute(id_job, getID(), \"file_size_check\", fileSizeCheck);\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save job entry of type 'wait for file' to the repository for id_job=\"+id_job, dbe);\n\t\t}\n\t}","id":9028,"modified_method":"public void saveRep(Repository rep, long id_job)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.saveRep(rep, id_job);\n\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"filename\", filename);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"maximum_timeout\", maximumTimeout);\n\t\t\trep.saveJobEntryAttribute(id_job, getID(), \"check_cycle_time\", checkCycleTime);\n            rep.saveJobEntryAttribute(id_job, getID(), \"success_on_timeout\", successOnTimeout);\n            rep.saveJobEntryAttribute(id_job, getID(), \"file_size_check\", fileSizeCheck);\r\n            rep.saveJobEntryAttribute(id_job, getID(), \"add_filename_result\", addFilenameToResult);\n\t\t}\n\t\tcatch(KettleDatabaseException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to save job entry of type 'wait for file' to the repository for id_job=\"+id_job, dbe);\n\t\t}\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadRep(Repository rep, long id_jobentry, List<DatabaseMeta> databases, List<SlaveServer> slaveServers)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases, slaveServers);\n\t\t\tfilename = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tmaximumTimeout = rep.getJobEntryAttributeString(id_jobentry, \"maximum_timeout\");\n\t\t\tcheckCycleTime = rep.getJobEntryAttributeString(id_jobentry, \"check_cycle_time\");\n\t\t\tsuccessOnTimeout = rep.getJobEntryAttributeBoolean(id_jobentry, \"success_on_timeout\");\n\t\t\tfileSizeCheck = rep.getJobEntryAttributeBoolean(id_jobentry, \"file_size_check\");\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'wait for file' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","id":9029,"modified_method":"public void loadRep(Repository rep, long id_jobentry, List<DatabaseMeta> databases, List<SlaveServer> slaveServers)\n\t\tthrows KettleException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadRep(rep, id_jobentry, databases, slaveServers);\n\t\t\tfilename = rep.getJobEntryAttributeString(id_jobentry, \"filename\");\n\t\t\tmaximumTimeout = rep.getJobEntryAttributeString(id_jobentry, \"maximum_timeout\");\n\t\t\tcheckCycleTime = rep.getJobEntryAttributeString(id_jobentry, \"check_cycle_time\");\n\t\t\tsuccessOnTimeout = rep.getJobEntryAttributeBoolean(id_jobentry, \"success_on_timeout\");\n\t\t\tfileSizeCheck = rep.getJobEntryAttributeBoolean(id_jobentry, \"file_size_check\");\r\n\t\t\taddFilenameToResult = rep.getJobEntryAttributeBoolean(id_jobentry, \"add_filename_result\");\n\t\t}\n\t\tcatch(KettleException dbe)\n\t\t{\n\t\t\tthrow new KettleException(\"Unable to load job entry of type 'wait for file' from the repository for id_jobentry=\"+id_jobentry, dbe);\n\t\t}\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryWaitForFile(String n)\n\t{\n\t\tsuper(n, \"\");\n\t\tfilename = null;\n\t\tmaximumTimeout   = DEFAULT_MAXIMUM_TIMEOUT;\n\t\tcheckCycleTime   = DEFAULT_CHECK_CYCLE_TIME;\n\t\tsuccessOnTimeout = false;\n\t\tfileSizeCheck    = false;\n\t\tsetID(-1L);\n\t\tsetJobEntryType(JobEntryType.WAIT_FOR_FILE);\n\t}","id":9030,"modified_method":"public JobEntryWaitForFile(String n)\n\t{\n\t\tsuper(n, \"\");\n\t\tfilename = null;\n\t\tmaximumTimeout   = DEFAULT_MAXIMUM_TIMEOUT;\n\t\tcheckCycleTime   = DEFAULT_CHECK_CYCLE_TIME;\n\t\tsuccessOnTimeout = false;\n\t\tfileSizeCheck    = false;\r\n\t\taddFilenameToResult=false;\n\t\tsetID(-1L);\n\t\tsetJobEntryType(JobEntryType.WAIT_FOR_FILE);\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(50);\n\n\t\tretval.append(super.getXML());\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\", filename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"maximum_timeout\", maximumTimeout));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"check_cycle_time\", checkCycleTime));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"success_on_timeout\", successOnTimeout));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"file_size_check\", fileSizeCheck));\n\n\t\treturn retval.toString();\n\t}","id":9031,"modified_method":"public String getXML()\n\t{\n        StringBuffer retval = new StringBuffer(50);\n\n\t\tretval.append(super.getXML());\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"filename\", filename));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"maximum_timeout\", maximumTimeout));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"check_cycle_time\", checkCycleTime));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"success_on_timeout\", successOnTimeout));\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"file_size_check\", fileSizeCheck));\r\n\t\tretval.append(\"      \").append(XMLHandler.addTagValue(\"add_filename_result\", addFilenameToResult));\n\t\treturn retval.toString();\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void loadXML(Node entrynode, List<DatabaseMeta> databases, List<SlaveServer> slaveServers, Repository rep)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadXML(entrynode, databases, slaveServers);\n\t\t\tfilename = XMLHandler.getTagValue(entrynode, \"filename\");\n\t\t\tmaximumTimeout = XMLHandler.getTagValue(entrynode, \"maximum_timeout\");\n\t\t\tcheckCycleTime = XMLHandler.getTagValue(entrynode, \"check_cycle_time\");\n\t\t\tsuccessOnTimeout = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"success_on_timeout\"));\n\t\t\tfileSizeCheck = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"file_size_check\"));\n\t\t}\n\t\tcatch(KettleXMLException xe)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load job entry of type 'wait for file' from XML node\", xe);\n\t\t}\n\t}","id":9032,"modified_method":"public void loadXML(Node entrynode, List<DatabaseMeta> databases, List<SlaveServer> slaveServers, Repository rep)\n\t\tthrows KettleXMLException\n\t{\n\t\ttry\n\t\t{\n\t\t\tsuper.loadXML(entrynode, databases, slaveServers);\n\t\t\tfilename = XMLHandler.getTagValue(entrynode, \"filename\");\n\t\t\tmaximumTimeout = XMLHandler.getTagValue(entrynode, \"maximum_timeout\");\n\t\t\tcheckCycleTime = XMLHandler.getTagValue(entrynode, \"check_cycle_time\");\n\t\t\tsuccessOnTimeout = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"success_on_timeout\"));\n\t\t\tfileSizeCheck = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"file_size_check\"));\r\n\t\t\taddFilenameToResult = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(entrynode, \"add_filename_result\"));\n\t\t}\n\t\tcatch(KettleXMLException xe)\n\t\t{\n\t\t\tthrow new KettleXMLException(\"Unable to load job entry of type 'wait for file' from XML node\", xe);\n\t\t}\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob)\n    {\n    \tLogWriter log = LogWriter.getInstance();\n    \tResult result = previousResult;\n    \tresult.setResult( false );\n\n    \t// starttime (in seconds)\n    \tlong timeStart = System.currentTimeMillis() / 1000;\n\n    \tif (filename!=null)\n    \t{\n    \t\tString realFilename = getRealFilename();\n    \t\ttry\n    \t\t{\n    \t\t\tFileObject fileObject = null;\n\n    \t\t\tfileObject = KettleVFS.getFileObject(realFilename);\n\n    \t\t\tlong iMaximumTimeout = Const.toInt(getMaximumTimeout(),\n    \t\t\t\t\tConst.toInt(DEFAULT_MAXIMUM_TIMEOUT, 0));\n    \t\t\tlong iCycleTime = Const.toInt(getCheckCycleTime(),\n    \t\t\t\t\tConst.toInt(DEFAULT_CHECK_CYCLE_TIME, 0));\n\n    \t\t\t//\n    \t\t\t// Sanity check on some values, and complain on insanity\n    \t\t\t//\n    \t\t\tif ( iMaximumTimeout < 0 )\n    \t\t\t{\n    \t\t\t\tiMaximumTimeout = Const.toInt(DEFAULT_MAXIMUM_TIMEOUT, 0);\n    \t\t\t\tlog.logBasic(toString(), \"Maximum timeout invalid, reset to \" + iMaximumTimeout);\n    \t\t\t}\n\n    \t\t\tif ( iCycleTime < 1 )\n    \t\t\t{\n    \t\t\t\t// If lower than 1 set to the default\n    \t\t\t\tiCycleTime = Const.toInt(DEFAULT_CHECK_CYCLE_TIME, 1);\n    \t\t\t\tlog.logBasic(toString(), \"Check cycle time invalid, reset to \" + iCycleTime);\n    \t\t\t}\n\n    \t\t\tif ( iMaximumTimeout == 0 )\n    \t\t\t{\n    \t\t\t\tlog.logBasic(toString(), \"Waiting indefinitely for file [\" +\n    \t\t\t\t\t\trealFilename + \"]\");\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tlog.logBasic(toString(), \"Waiting \" + iMaximumTimeout + \" seconds for file [\" +\n    \t\t\t\t\t\trealFilename + \"]\");\n    \t\t\t}\n\n    \t\t\tboolean continueLoop = true;\n    \t\t\twhile ( continueLoop && !parentJob.isStopped() )\n    \t\t\t{\n        \t\t\tfileObject = KettleVFS.getFileObject(realFilename);\n\n    \t\t\t\tif ( fileObject.exists() )\n    \t\t\t\t{\n    \t\t\t\t\t// file exists, we're happy to exit\n    \t\t\t\t\tlog.logBasic(toString(), \"Detected file [\" + realFilename + \"] within timeout\");\n    \t\t\t\t\tresult.setResult( true );\n    \t\t\t\t\tcontinueLoop = false;\n    \t\t\t\t}\n    \t\t\t\telse\n    \t\t\t\t{\n    \t\t\t\t\tlong now = System.currentTimeMillis() / 1000;\n\n    \t\t\t\t\tif ( (iMaximumTimeout > 0) &&\n    \t\t\t\t\t\t\t(now > (timeStart + iMaximumTimeout)))\n    \t\t\t\t\t{\n    \t\t\t\t\t\tcontinueLoop = false;\n\n    \t\t\t\t\t\t// file doesn't exist after timeout, either true or false\n    \t\t\t\t\t\tif ( isSuccessOnTimeout() )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tlog.logBasic(toString(), \"Didn't detect file [\" + realFilename + \"] before timeout, success\");\n    \t\t\t\t\t\t\tresult.setResult( true );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tlog.logBasic(toString(), \"Didn't detect file [\" + realFilename + \"] before timeout, failure\");\n    \t\t\t\t\t\t\tresult.setResult( false );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n    \t\t\t\t\t// sleep algorithm\n    \t\t\t\t\tlong sleepTime = 0;\n\n    \t\t\t\t\tif ( iMaximumTimeout == 0 )\n    \t\t\t\t\t{\n    \t\t\t\t\t\tsleepTime = iCycleTime;\n    \t\t\t\t\t}\n    \t\t\t\t\telse\n    \t\t\t\t\t{\n    \t\t\t\t\t\tif ( (now + iCycleTime) < (timeStart + iMaximumTimeout) )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tsleepTime = iCycleTime;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tsleepTime = iCycleTime - ((now + iCycleTime) -\n    \t\t\t\t\t\t\t\t\t(timeStart + iMaximumTimeout));\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tif ( sleepTime > 0 )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tif ( log.isDetailed() )\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\tlog.logDetailed(toString(), \"Sleeping \" + sleepTime + \" seconds before next check for file [\" + realFilename + \"]\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tThread.sleep(sleepTime * 1000);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t} catch (InterruptedException e) {\n    \t\t\t\t\t\t// something strange happened\n    \t\t\t\t\t\tresult.setResult( false );\n    \t\t\t\t\t\tcontinueLoop = false;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif ( !parentJob.isStopped() &&\n    \t\t\t\t\tfileObject.exists() &&\n    \t\t\t\t\tisFileSizeCheck() )\n    \t\t\t{\n    \t\t\t\tlong oldSize = -1;\n    \t\t\t\tlong newSize = fileObject.getContent().getSize();\n\n    \t\t\t\tlog.logDetailed(toString(), \"File [\" + realFilename + \"] is \" + newSize + \" bytes long\");\n    \t\t\t\tlog.logBasic(toString(), \"Waiting until file [\" + realFilename + \"] stops growing for \" + iCycleTime + \" seconds\");\n    \t\t\t\twhile ( oldSize != newSize && !parentJob.isStopped() )\n    \t\t\t\t{\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tif ( log.isDetailed() )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tlog.logDetailed(toString(), \"Sleeping \" + iCycleTime + \" seconds, waiting for file [\" + realFilename + \"] to stop growing\");\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tThread.sleep(iCycleTime * 1000);\n    \t\t\t\t\t} catch (InterruptedException e) {\n    \t\t\t\t\t\t// something strange happened\n    \t\t\t\t\t\tresult.setResult( false );\n    \t\t\t\t\t\tcontinueLoop = false;\n    \t\t\t\t\t}\n    \t\t\t\t\toldSize = newSize;\n    \t\t\t\t\tnewSize = fileObject.getContent().getSize();\n    \t\t\t\t\tif ( log.isDetailed() )\n    \t\t\t\t\t{\n    \t\t\t\t\t\tlog.logDetailed(toString(), \"File [\" + realFilename + \"] is \" + newSize + \" bytes long\");\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tlog.logBasic(toString(), \"Stopped waiting for file [\" + realFilename + \"] to stop growing\");\n    \t\t\t}\n\n    \t\t\tif ( parentJob.isStopped() )\n    \t\t\t{\n    \t\t\t\tresult.setResult( false );\n    \t\t\t}\n    \t\t}\n    \t\tcatch ( IOException e )\n    \t\t{\n    \t\t\tlog.logBasic(toString(), \"Exception while waiting for file [\" + realFilename + \"] to stop growing: \" + e.getMessage());\n    \t\t}\n    \t}\n    \telse\n    \t{\n    \t\tlog.logError(toString(), \"No filename is defined.\");\n    \t}\n\n    \treturn result;\n    }","id":9033,"modified_method":"public Result execute(Result previousResult, int nr, Repository rep, Job parentJob)\n    {\n    \tLogWriter log = LogWriter.getInstance();\n    \tResult result = previousResult;\n    \tresult.setResult( false );\n\n    \t// starttime (in seconds)\n    \tlong timeStart = System.currentTimeMillis() / 1000;\n\n    \tif (filename!=null)\n    \t{\r\n    \t\tFileObject fileObject = null;\n    \t\tString realFilename = getRealFilename();\n    \t\ttry\n    \t\t{\n    \t\t\tfileObject = KettleVFS.getFileObject(realFilename);\n\n    \t\t\tlong iMaximumTimeout = Const.toInt(getMaximumTimeout(),\n    \t\t\t\t\tConst.toInt(DEFAULT_MAXIMUM_TIMEOUT, 0));\n    \t\t\tlong iCycleTime = Const.toInt(getCheckCycleTime(),\n    \t\t\t\t\tConst.toInt(DEFAULT_CHECK_CYCLE_TIME, 0));\n\n    \t\t\t//\n    \t\t\t// Sanity check on some values, and complain on insanity\n    \t\t\t//\n    \t\t\tif ( iMaximumTimeout < 0 )\n    \t\t\t{\n    \t\t\t\tiMaximumTimeout = Const.toInt(DEFAULT_MAXIMUM_TIMEOUT, 0);\n    \t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Maximum timeout invalid, reset to \" + iMaximumTimeout);\n    \t\t\t}\n\n    \t\t\tif ( iCycleTime < 1 )\n    \t\t\t{\n    \t\t\t\t// If lower than 1 set to the default\n    \t\t\t\tiCycleTime = Const.toInt(DEFAULT_CHECK_CYCLE_TIME, 1);\n    \t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Check cycle time invalid, reset to \" + iCycleTime);\n    \t\t\t}\n\n    \t\t\tif ( iMaximumTimeout == 0 )\n    \t\t\t{\n    \t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Waiting indefinitely for file [\" +\n    \t\t\t\t\t\trealFilename + \"]\");\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Waiting \" + iMaximumTimeout + \" seconds for file [\" +\n    \t\t\t\t\t\trealFilename + \"]\");\n    \t\t\t}\n\n    \t\t\tboolean continueLoop = true;\n    \t\t\twhile ( continueLoop && !parentJob.isStopped() )\n    \t\t\t{\n        \t\t\tfileObject = KettleVFS.getFileObject(realFilename);\n\n    \t\t\t\tif ( fileObject.exists() )\n    \t\t\t\t{\n    \t\t\t\t\t// file exists, we're happy to exit\n    \t\t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Detected file [\" + realFilename + \"] within timeout\");\n    \t\t\t\t\tresult.setResult( true );\n    \t\t\t\t\tcontinueLoop = false;\r\n    \t\t\t\t\t\r\n    \t\t\t\t\t//add filename to result filenames\r\n    \t\t\t\t\tif(addFilenameToResult && fileObject.getType()==FileType.FILE){\r\n    \t\t\t\t\t\tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL , fileObject, parentJob.getName(), toString());\r\n    \t\t\t\t\t\tresultFile.setComment(Messages.getString(\"JobWaitForFile.FilenameAdded\"));\r\n    \t\t\t\t\t\tresult.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n    \t\t\t\t\t \t}\n    \t\t\t\t}\n    \t\t\t\telse\n    \t\t\t\t{\n    \t\t\t\t\tlong now = System.currentTimeMillis() / 1000;\n\n    \t\t\t\t\tif ( (iMaximumTimeout > 0) &&\n    \t\t\t\t\t\t\t(now > (timeStart + iMaximumTimeout)))\n    \t\t\t\t\t{\n    \t\t\t\t\t\tcontinueLoop = false;\n\n    \t\t\t\t\t\t// file doesn't exist after timeout, either true or false\n    \t\t\t\t\t\tif ( isSuccessOnTimeout() )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Didn't detect file [\" + realFilename + \"] before timeout, success\");\n    \t\t\t\t\t\t\tresult.setResult( true );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Didn't detect file [\" + realFilename + \"] before timeout, failure\");\n    \t\t\t\t\t\t\tresult.setResult( false );\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n    \t\t\t\t\t// sleep algorithm\n    \t\t\t\t\tlong sleepTime = 0;\n\n    \t\t\t\t\tif ( iMaximumTimeout == 0 )\n    \t\t\t\t\t{\n    \t\t\t\t\t\tsleepTime = iCycleTime;\n    \t\t\t\t\t}\n    \t\t\t\t\telse\n    \t\t\t\t\t{\n    \t\t\t\t\t\tif ( (now + iCycleTime) < (timeStart + iMaximumTimeout) )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tsleepTime = iCycleTime;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tsleepTime = iCycleTime - ((now + iCycleTime) -\n    \t\t\t\t\t\t\t\t\t(timeStart + iMaximumTimeout));\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tif ( sleepTime > 0 )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tif ( log.isDetailed() )\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\tlog.logDetailed(toString(), \"Sleeping \" + sleepTime + \" seconds before next check for file [\" + realFilename + \"]\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tThread.sleep(sleepTime * 1000);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t} catch (InterruptedException e) {\n    \t\t\t\t\t\t// something strange happened\n    \t\t\t\t\t\tresult.setResult( false );\n    \t\t\t\t\t\tcontinueLoop = false;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\tif ( !parentJob.isStopped() &&\n    \t\t\t\t\tfileObject.exists() &&\n    \t\t\t\t\tisFileSizeCheck() )\n    \t\t\t{\n    \t\t\t\tlong oldSize = -1;\n    \t\t\t\tlong newSize = fileObject.getContent().getSize();\n\n    \t\t\t\tif(log.isDetailed()) log.logDetailed(toString(), \"File [\" + realFilename + \"] is \" + newSize + \" bytes long\");\n    \t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Waiting until file [\" + realFilename + \"] stops growing for \" + iCycleTime + \" seconds\");\n    \t\t\t\twhile ( oldSize != newSize && !parentJob.isStopped() )\n    \t\t\t\t{\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tif ( log.isDetailed() )\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\tlog.logDetailed(toString(), \"Sleeping \" + iCycleTime + \" seconds, waiting for file [\" + realFilename + \"] to stop growing\");\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tThread.sleep(iCycleTime * 1000);\n    \t\t\t\t\t} catch (InterruptedException e) {\n    \t\t\t\t\t\t// something strange happened\n    \t\t\t\t\t\tresult.setResult( false );\n    \t\t\t\t\t\tcontinueLoop = false;\n    \t\t\t\t\t}\n    \t\t\t\t\toldSize = newSize;\n    \t\t\t\t\tnewSize = fileObject.getContent().getSize();\n    \t\t\t\t\tif ( log.isDetailed() )\n    \t\t\t\t\t{\n    \t\t\t\t\t\tlog.logDetailed(toString(), \"File [\" + realFilename + \"] is \" + newSize + \" bytes long\");\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif(log.isBasic()) log.logBasic(toString(), \"Stopped waiting for file [\" + realFilename + \"] to stop growing\");\n    \t\t\t}\n\n    \t\t\tif ( parentJob.isStopped() )\n    \t\t\t{\n    \t\t\t\tresult.setResult( false );\n    \t\t\t}\n    \t\t}\n    \t\tcatch ( IOException e )\n    \t\t{\n    \t\t\tlog.logBasic(toString(), \"Exception while waiting for file [\" + realFilename + \"] to stop growing: \" + e.getMessage());\n    \t\t}finally{\r\n    \t\t\tif(fileObject != null){\r\n    \t\t\t\ttry{\r\n    \t\t\t\t\tfileObject.close();\r\n    \t\t\t\t}catch(Exception e){}\r\n    \t\t\t}\r\n    \t\t}\n    \t}\n    \telse\n    \t{\n    \t\tlog.logError(toString(), \"No filename is defined.\");\n    \t}\n\n    \treturn result;\n    }","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setFilename(wFilename.getText());\n\t\tjobEntry.setMaximumTimeout(wMaximumTimeout.getText());\n\t\tjobEntry.setCheckCycleTime(wCheckCycleTime.getText());\n\t\tjobEntry.setSuccessOnTimeout(wSuccesOnTimeout.getSelection());\t\t\n\t\tjobEntry.setFileSizeCheck(wFileSizeCheck.getSelection());\n\t\tdispose();\n\t}","id":9034,"modified_method":"private void ok()\n\t{\n\t\tjobEntry.setName(wName.getText());\n\t\tjobEntry.setFilename(wFilename.getText());\n\t\tjobEntry.setMaximumTimeout(wMaximumTimeout.getText());\n\t\tjobEntry.setCheckCycleTime(wCheckCycleTime.getText());\n\t\tjobEntry.setSuccessOnTimeout(wSuccesOnTimeout.getSelection());\t\t\n\t\tjobEntry.setFileSizeCheck(wFileSizeCheck.getSelection());\r\n\t\tjobEntry.setAddFilenameToResult(wAddFilenameResult.getSelection());\n\t\tdispose();\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\tif (jobEntry.getName() != null) \n\t\t\twName.setText( jobEntry.getName() );\n\t\twName.selectAll();\n\n\t\twFilename.setText(Const.NVL(jobEntry.getFilename(), \"\"));\n\t\twMaximumTimeout.setText(Const.NVL(jobEntry.getMaximumTimeout(), \"\"));\n\t\twCheckCycleTime.setText(Const.NVL(jobEntry.getCheckCycleTime(), \"\"));\n\t\twSuccesOnTimeout.setSelection(jobEntry.isSuccessOnTimeout());\t\t\n\t\twFileSizeCheck.setSelection(jobEntry.isFileSizeCheck());\n\t}","id":9035,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */\n\tpublic void getData()\n\t{\n\t\tif (jobEntry.getName() != null) \n\t\t\twName.setText( jobEntry.getName() );\n\t\twName.selectAll();\n\n\t\twFilename.setText(Const.NVL(jobEntry.getFilename(), \"\"));\n\t\twMaximumTimeout.setText(Const.NVL(jobEntry.getMaximumTimeout(), \"\"));\n\t\twCheckCycleTime.setText(Const.NVL(jobEntry.getCheckCycleTime(), \"\"));\n\t\twSuccesOnTimeout.setSelection(jobEntry.isSuccessOnTimeout());\t\t\n\t\twFileSizeCheck.setSelection(jobEntry.isFileSizeCheck());\r\n\t\twAddFilenameResult.setSelection(jobEntry.isAddFilenameToResult());\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobWaitForFile.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobWaitForFile.Name.Label\"));\n \t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Filename line\n\t\twlFilename=new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"JobWaitForFile.Filename.Label\"));\n \t\tprops.setLook(wlFilename);\n\t\tfdlFilename=new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top  = new FormAttachment(wName, margin);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbFilename);\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename=new FormData();\n\t\tfdbFilename.right= new FormAttachment(100, 0);\n\t\tfdbFilename.top  = new FormAttachment(wName, 0);\n\t\twbFilename.setLayoutData(fdbFilename);\n\n\t\twFilename=new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename=new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.top  = new FormAttachment(wName, margin);\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename.setToolTipText(jobMeta.environmentSubstitute( wFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*\"});\n\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twFilename.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n        // Maximum timeout\n        wlMaximumTimeout = new Label(shell, SWT.RIGHT);\n        wlMaximumTimeout.setText(Messages.getString(\"JobWaitForFile.MaximumTimeout.Label\"));\n        props.setLook(wlMaximumTimeout);\n        fdlMaximumTimeout = new FormData();\n        fdlMaximumTimeout.left = new FormAttachment(0, 0);\n        fdlMaximumTimeout.top = new FormAttachment(wFilename, margin);\n        fdlMaximumTimeout.right = new FormAttachment(middle, -margin);\n        wlMaximumTimeout.setLayoutData(fdlMaximumTimeout);\n        wMaximumTimeout = new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wMaximumTimeout);\n        wMaximumTimeout.setToolTipText(Messages.getString(\"JobWaitForFile.MaximumTimeout.Tooltip\"));\n        wMaximumTimeout.addModifyListener(lsMod);\n        fdMaximumTimeout = new FormData();\n        fdMaximumTimeout.left = new FormAttachment(middle, 0);\n        fdMaximumTimeout.top = new FormAttachment(wFilename, margin);\n        fdMaximumTimeout.right = new FormAttachment(100, 0);\n        wMaximumTimeout.setLayoutData(fdMaximumTimeout);\n\n        // Cycle time\n        wlCheckCycleTime = new Label(shell, SWT.RIGHT);\n        wlCheckCycleTime.setText(Messages.getString(\"JobWaitForFile.CheckCycleTime.Label\"));\n        props.setLook(wlCheckCycleTime);\n        fdlCheckCycleTime = new FormData();\n        fdlCheckCycleTime.left = new FormAttachment(0, 0);\n        fdlCheckCycleTime.top = new FormAttachment(wMaximumTimeout, margin);\n        fdlCheckCycleTime.right = new FormAttachment(middle, -margin);\n        wlCheckCycleTime.setLayoutData(fdlCheckCycleTime);\n        wCheckCycleTime = new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wCheckCycleTime);\n        wCheckCycleTime.setToolTipText(Messages.getString(\"JobWaitForFile.CheckCycleTime.Tooltip\"));\n        wCheckCycleTime.addModifyListener(lsMod);\n        fdCheckCycleTime = new FormData();\n        fdCheckCycleTime.left = new FormAttachment(middle, 0);\n        fdCheckCycleTime.top = new FormAttachment(wMaximumTimeout, margin);\n        fdCheckCycleTime.right = new FormAttachment(100, 0);\n        wCheckCycleTime.setLayoutData(fdCheckCycleTime);\n\t        \n        // Success on timeout\t\t\n        wlSuccesOnTimeout = new Label(shell, SWT.RIGHT);\n        wlSuccesOnTimeout.setText(Messages.getString(\"JobWaitForFile.SuccessOnTimeout.Label\"));\n        props.setLook(wlSuccesOnTimeout);\n        fdlSuccesOnTimeout = new FormData();\n        fdlSuccesOnTimeout.left = new FormAttachment(0, 0);\n        fdlSuccesOnTimeout.top = new FormAttachment(wCheckCycleTime, margin);\n        fdlSuccesOnTimeout.right = new FormAttachment(middle, -margin);\n        wlSuccesOnTimeout.setLayoutData(fdlSuccesOnTimeout);\n        wSuccesOnTimeout = new Button(shell, SWT.CHECK);\n        props.setLook(wSuccesOnTimeout);\n        wSuccesOnTimeout.setToolTipText(Messages.getString(\"JobWaitForFile.SuccessOnTimeout.Tooltip\"));\n        fdSuccesOnTimeout = new FormData();\n        fdSuccesOnTimeout.left = new FormAttachment(middle, 0);\n        fdSuccesOnTimeout.top = new FormAttachment(wCheckCycleTime, margin);\n        fdSuccesOnTimeout.right = new FormAttachment(100, 0);\n        wSuccesOnTimeout.setLayoutData(fdSuccesOnTimeout);\n        wSuccesOnTimeout.addSelectionListener(new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        });\n\n        // Success on timeout\t\t\n        wlFileSizeCheck = new Label(shell, SWT.RIGHT);\n        wlFileSizeCheck.setText(Messages.getString(\"JobWaitForFile.FileSizeCheck.Label\"));\n        props.setLook(wlFileSizeCheck);\n        fdlFileSizeCheck = new FormData();\n        fdlFileSizeCheck.left = new FormAttachment(0, 0);\n        fdlFileSizeCheck.top = new FormAttachment(wSuccesOnTimeout, margin);\n        fdlFileSizeCheck.right = new FormAttachment(middle, -margin);\n        wlFileSizeCheck.setLayoutData(fdlFileSizeCheck);\n        wFileSizeCheck = new Button(shell, SWT.CHECK);\n        props.setLook(wFileSizeCheck);\n        wFileSizeCheck.setToolTipText(Messages.getString(\"JobWaitForFile.FileSizeCheck.Tooltip\"));\n        fdFileSizeCheck = new FormData();\n        fdFileSizeCheck.left = new FormAttachment(middle, 0);\n        fdFileSizeCheck.top = new FormAttachment(wSuccesOnTimeout, margin);\n        fdFileSizeCheck.right = new FormAttachment(100, 0);\n        wFileSizeCheck.setLayoutData(fdFileSizeCheck);\n        wFileSizeCheck.addSelectionListener(new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        });        \n        \n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wFileSizeCheck);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twFilename.addSelectionListener( lsDef );\n\t\twMaximumTimeout.addSelectionListener(lsDef);\n\t\twCheckCycleTime.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","id":9036,"modified_method":"public JobEntryInterface open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n        shell = new Shell(parent, props.getJobsDialogStyle());\n        props.setLook(shell);\n        JobDialog.setShellImage(shell, jobEntry);\n\n\t\tModifyListener lsMod = new ModifyListener()\n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t{\n\t\t\t\tjobEntry.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = jobEntry.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"JobWaitForFile.Title\"));\n\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Filename line\n\t\twlName=new Label(shell, SWT.RIGHT);\n\t\twlName.setText(Messages.getString(\"JobWaitForFile.Name.Label\"));\n \t\tprops.setLook(wlName);\n\t\tfdlName=new FormData();\n\t\tfdlName.left = new FormAttachment(0, 0);\n\t\tfdlName.right= new FormAttachment(middle, -margin);\n\t\tfdlName.top  = new FormAttachment(0, margin);\n\t\twlName.setLayoutData(fdlName);\n\t\twName=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wName);\n\t\twName.addModifyListener(lsMod);\n\t\tfdName=new FormData();\n\t\tfdName.left = new FormAttachment(middle, 0);\n\t\tfdName.top  = new FormAttachment(0, margin);\n\t\tfdName.right= new FormAttachment(100, 0);\n\t\twName.setLayoutData(fdName);\n\n\t\t// Filename line\n\t\twlFilename=new Label(shell, SWT.RIGHT);\n\t\twlFilename.setText(Messages.getString(\"JobWaitForFile.Filename.Label\"));\n \t\tprops.setLook(wlFilename);\n\t\tfdlFilename=new FormData();\n\t\tfdlFilename.left = new FormAttachment(0, 0);\n\t\tfdlFilename.top  = new FormAttachment(wName, margin);\n\t\tfdlFilename.right= new FormAttachment(middle, -margin);\n\t\twlFilename.setLayoutData(fdlFilename);\n\n\t\twbFilename=new Button(shell, SWT.PUSH| SWT.CENTER);\n \t\tprops.setLook(wbFilename);\n\t\twbFilename.setText(Messages.getString(\"System.Button.Browse\"));\n\t\tfdbFilename=new FormData();\n\t\tfdbFilename.right= new FormAttachment(100, 0);\n\t\tfdbFilename.top  = new FormAttachment(wName, 0);\n\t\twbFilename.setLayoutData(fdbFilename);\n\n\t\twFilename=new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wFilename);\n\t\twFilename.addModifyListener(lsMod);\n\t\tfdFilename=new FormData();\n\t\tfdFilename.left = new FormAttachment(middle, 0);\n\t\tfdFilename.top  = new FormAttachment(wName, margin);\n\t\tfdFilename.right= new FormAttachment(wbFilename, -margin);\n\t\twFilename.setLayoutData(fdFilename);\n\n\t\t// Whenever something changes, set the tooltip to the expanded version:\n\t\twFilename.addModifyListener(new ModifyListener()\n\t\t\t{\n\t\t\t\tpublic void modifyText(ModifyEvent e)\n\t\t\t\t{\n\t\t\t\t\twFilename.setToolTipText(jobMeta.environmentSubstitute( wFilename.getText() ) );\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\twbFilename.addSelectionListener\n\t\t(\n\t\t\tnew SelectionAdapter()\n\t\t\t{\n\t\t\t\tpublic void widgetSelected(SelectionEvent e)\n\t\t\t\t{\n\t\t\t\t\tFileDialog dialog = new FileDialog(shell, SWT.OPEN);\n\t\t\t\t\tdialog.setFilterExtensions(new String[] {\"*\"});\n\t\t\t\t\tif (wFilename.getText()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdialog.setFileName(jobMeta.environmentSubstitute(wFilename.getText()) );\n\t\t\t\t\t}\n\t\t\t\t\tdialog.setFilterNames(FILETYPES);\n\t\t\t\t\tif (dialog.open()!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\twFilename.setText(dialog.getFilterPath()+Const.FILE_SEPARATOR+dialog.getFileName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n        // Maximum timeout\n        wlMaximumTimeout = new Label(shell, SWT.RIGHT);\n        wlMaximumTimeout.setText(Messages.getString(\"JobWaitForFile.MaximumTimeout.Label\"));\n        props.setLook(wlMaximumTimeout);\n        fdlMaximumTimeout = new FormData();\n        fdlMaximumTimeout.left = new FormAttachment(0, 0);\n        fdlMaximumTimeout.top = new FormAttachment(wFilename, margin);\n        fdlMaximumTimeout.right = new FormAttachment(middle, -margin);\n        wlMaximumTimeout.setLayoutData(fdlMaximumTimeout);\n        wMaximumTimeout = new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wMaximumTimeout);\n        wMaximumTimeout.setToolTipText(Messages.getString(\"JobWaitForFile.MaximumTimeout.Tooltip\"));\n        wMaximumTimeout.addModifyListener(lsMod);\n        fdMaximumTimeout = new FormData();\n        fdMaximumTimeout.left = new FormAttachment(middle, 0);\n        fdMaximumTimeout.top = new FormAttachment(wFilename, margin);\n        fdMaximumTimeout.right = new FormAttachment(100, 0);\n        wMaximumTimeout.setLayoutData(fdMaximumTimeout);\n\n        // Cycle time\n        wlCheckCycleTime = new Label(shell, SWT.RIGHT);\n        wlCheckCycleTime.setText(Messages.getString(\"JobWaitForFile.CheckCycleTime.Label\"));\n        props.setLook(wlCheckCycleTime);\n        fdlCheckCycleTime = new FormData();\n        fdlCheckCycleTime.left = new FormAttachment(0, 0);\n        fdlCheckCycleTime.top = new FormAttachment(wMaximumTimeout, margin);\n        fdlCheckCycleTime.right = new FormAttachment(middle, -margin);\n        wlCheckCycleTime.setLayoutData(fdlCheckCycleTime);\n        wCheckCycleTime = new TextVar(jobMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        props.setLook(wCheckCycleTime);\n        wCheckCycleTime.setToolTipText(Messages.getString(\"JobWaitForFile.CheckCycleTime.Tooltip\"));\n        wCheckCycleTime.addModifyListener(lsMod);\n        fdCheckCycleTime = new FormData();\n        fdCheckCycleTime.left = new FormAttachment(middle, 0);\n        fdCheckCycleTime.top = new FormAttachment(wMaximumTimeout, margin);\n        fdCheckCycleTime.right = new FormAttachment(100, 0);\n        wCheckCycleTime.setLayoutData(fdCheckCycleTime);\n\t        \n        // Success on timeout\t\t\n        wlSuccesOnTimeout = new Label(shell, SWT.RIGHT);\n        wlSuccesOnTimeout.setText(Messages.getString(\"JobWaitForFile.SuccessOnTimeout.Label\"));\n        props.setLook(wlSuccesOnTimeout);\n        fdlSuccesOnTimeout = new FormData();\n        fdlSuccesOnTimeout.left = new FormAttachment(0, 0);\n        fdlSuccesOnTimeout.top = new FormAttachment(wCheckCycleTime, margin);\n        fdlSuccesOnTimeout.right = new FormAttachment(middle, -margin);\n        wlSuccesOnTimeout.setLayoutData(fdlSuccesOnTimeout);\n        wSuccesOnTimeout = new Button(shell, SWT.CHECK);\n        props.setLook(wSuccesOnTimeout);\n        wSuccesOnTimeout.setToolTipText(Messages.getString(\"JobWaitForFile.SuccessOnTimeout.Tooltip\"));\n        fdSuccesOnTimeout = new FormData();\n        fdSuccesOnTimeout.left = new FormAttachment(middle, 0);\n        fdSuccesOnTimeout.top = new FormAttachment(wCheckCycleTime, margin);\n        fdSuccesOnTimeout.right = new FormAttachment(100, 0);\n        wSuccesOnTimeout.setLayoutData(fdSuccesOnTimeout);\n        wSuccesOnTimeout.addSelectionListener(new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        });\n\n        // Check file size\t\t\n        wlFileSizeCheck = new Label(shell, SWT.RIGHT);\n        wlFileSizeCheck.setText(Messages.getString(\"JobWaitForFile.FileSizeCheck.Label\"));\n        props.setLook(wlFileSizeCheck);\n        fdlFileSizeCheck = new FormData();\n        fdlFileSizeCheck.left = new FormAttachment(0, 0);\n        fdlFileSizeCheck.top = new FormAttachment(wSuccesOnTimeout, margin);\n        fdlFileSizeCheck.right = new FormAttachment(middle, -margin);\n        wlFileSizeCheck.setLayoutData(fdlFileSizeCheck);\n        wFileSizeCheck = new Button(shell, SWT.CHECK);\n        props.setLook(wFileSizeCheck);\n        wFileSizeCheck.setToolTipText(Messages.getString(\"JobWaitForFile.FileSizeCheck.Tooltip\"));\n        fdFileSizeCheck = new FormData();\n        fdFileSizeCheck.left = new FormAttachment(middle, 0);\n        fdFileSizeCheck.top = new FormAttachment(wSuccesOnTimeout, margin);\n        fdFileSizeCheck.right = new FormAttachment(100, 0);\n        wFileSizeCheck.setLayoutData(fdFileSizeCheck);\n        wFileSizeCheck.addSelectionListener(new SelectionAdapter()\n        {\n            public void widgetSelected(SelectionEvent e)\n            {\n                jobEntry.setChanged();\n            }\n        });        \n        // Add filename to result filenames\t\t\r\n        wlAddFilenameResult = new Label(shell, SWT.RIGHT);\r\n        wlAddFilenameResult.setText(Messages.getString(\"JobWaitForFile.AddFilenameResult.Label\"));\r\n        props.setLook(wlAddFilenameResult);\r\n        fdlAddFilenameResult = new FormData();\r\n        fdlAddFilenameResult.left = new FormAttachment(0, 0);\r\n        fdlAddFilenameResult.top = new FormAttachment(wFileSizeCheck, margin);\r\n        fdlAddFilenameResult.right = new FormAttachment(middle, -margin);\r\n        wlAddFilenameResult.setLayoutData(fdlAddFilenameResult);\r\n        wAddFilenameResult = new Button(shell, SWT.CHECK);\r\n        props.setLook(wAddFilenameResult);\r\n        wAddFilenameResult.setToolTipText(Messages.getString(\"JobWaitForFile.AddFilenameResult.Tooltip\"));\r\n        fdAddFilenameResult = new FormData();\r\n        fdAddFilenameResult.left = new FormAttachment(middle, 0);\r\n        fdAddFilenameResult.top = new FormAttachment(wFileSizeCheck, margin);\r\n        fdAddFilenameResult.right = new FormAttachment(100, 0);\r\n        wAddFilenameResult.setLayoutData(fdAddFilenameResult);\r\n        wAddFilenameResult.addSelectionListener(new SelectionAdapter()\r\n        {\r\n            public void widgetSelected(SelectionEvent e)\r\n            {\r\n                jobEntry.setChanged();\r\n            }\r\n        }); \n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(Messages.getString(\"System.Button.OK\"));\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(Messages.getString(\"System.Button.Cancel\"));\n\n\t\tBaseStepDialog.positionBottomButtons(shell, new Button[] { wOK, wCancel }, margin, wAddFilenameResult);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\n\t\twName.addSelectionListener( lsDef );\n\t\twFilename.addSelectionListener( lsDef );\n\t\twMaximumTimeout.addSelectionListener(lsDef);\n\t\twCheckCycleTime.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\t\tgetData();\n\n\t\tBaseStepDialog.setSize(shell);\n\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn jobEntry;\n\t}","commit_id":"3e42646465eaad72d14f0729207a482bcdbd87cc","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void init() {\n    add(new AddCustomLocationDependency_Intention(), \"2798275735916376328\");\n    add(new AddCustomLocationRuntime_Intention(), \"202934866058893735\");\n    add(new AddCustomPackaging_Intention(), \"4034578608468929409\");\n    add(new ToggleCompactMpsModule_Intention(), \"8369506495128778230\");\n  }","id":9037,"modified_method":"public void init() {\n    add(new AddCustomLocationDependency_Intention(), \"2798275735916376328\");\n    add(new AddCustomLocationRuntime_Intention(), \"202934866058893735\");\n    add(new AddCustomPackaging_Intention(), \"4034578608468929409\");\n    add(new ReloadModulesFromDisk_Intention(), \"1753793013241722025\");\n    add(new ToggleCompactMpsModule_Intention(), \"8369506495128778230\");\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void importDependencies(Iterable<SNode> previous) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    Map<SNode, SNode> seen = new HashMap<SNode, SNode>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n\n      ModuleReference moduleRef = dep.getModuleRef();\n      SNode resolved;\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved == null) {\n          report(\"unsatisfied dependency: \" + dep.getModuleRef().toString(), myOriginalModule);\n          continue;\n        }\n      }\n\n      SNode prev = seen.get(resolved);\n      if (prev != null) {\n        if (reexport) {\n          SPropertyOperations.set(prev, \"reexport\", \"\" + (true));\n        }\n        continue;\n      }\n\n      SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n      seen.put(resolved, res);\n      SLinkOperations.setTarget(res, \"module\", resolved, false);\n      SPropertyOperations.set(res, \"reexport\", \"\" + (reexport));\n      SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n      SLinkOperations.setTarget(extr, \"dependency\", res, true);\n      ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n    }\n\n    // java stubs: jars \n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      final SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        SNode oldJarRef = Sequence.fromIterable(previous).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_a6ewnz_a0a0a0a0a0a0a0c0g0j0r(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true)), BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p));\n          }\n        }).select(new ISelector<SNode, SNode>() {\n          public SNode select(SNode it) {\n            return SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"customLocation\", true);\n          }\n        }).first();\n        if (oldJarRef != null) {\n          SLinkOperations.setTarget(jar, \"customLocation\", SConceptOperations.createNewNode(\"jetbrains.mps.build.structure.BuildSource_JavaExternalJarRef\", null), true);\n          SLinkOperations.setTarget(SLinkOperations.getTarget(jar, \"customLocation\", true), \"jar\", SLinkOperations.getTarget(oldJarRef, \"jar\", false), false);\n        }\n        SNode extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SLinkOperations.setTarget(extr, \"dependency\", jar, true);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":9038,"modified_method":"private void importDependencies(List<SNode> previous) {\n    SNode module = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n\n    Iterable<Dependency> dependencies = myModuleDescriptor.getDependencies();\n    if (myModuleDescriptor instanceof LanguageDescriptor) {\n      // see j.m.p.dependency.ModuleDependenciesManager#collectAllCompileTimeDependencies \n      Iterable<GeneratorDescriptor> generators = ((LanguageDescriptor) myModuleDescriptor).getGenerators();\n      dependencies = Sequence.fromIterable(dependencies).union(Sequence.fromIterable(generators).translate(new ITranslator2<GeneratorDescriptor, Dependency>() {\n        public Iterable<Dependency> translate(GeneratorDescriptor it) {\n          return it.getDependencies();\n        }\n      }));\n    }\n\n    Map<SNode, SNode> seen = new HashMap<SNode, SNode>();\n    for (Dependency dep : dependencies) {\n      boolean reexport = dep.isReexport();\n\n      ModuleReference moduleRef = dep.getModuleRef();\n      final Wrappers._T<SNode> resolved = new Wrappers._T<SNode>();\n      String targetName = moduleRef.getModuleFqName();\n      int sharpIndex = targetName.indexOf(\"#\");\n      if (sharpIndex >= 0) {\n        resolved.value = SNodeOperations.as(visible.resolve(targetName.substring(0, sharpIndex), null), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved.value == null) {\n          report(\"cannot resolve reference on generator's containing language by module name: \" + targetName, myOriginalModule);\n          continue;\n        }\n      } else {\n        resolved.value = SNodeOperations.as(visible.resolve(targetName, moduleRef.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Module\");\n        if (resolved.value == null) {\n          report(\"unsatisfied dependency: \" + dep.getModuleRef().toString(), myOriginalModule);\n          continue;\n        }\n      }\n\n      SNode prev = seen.get(resolved.value);\n      if (prev != null) {\n        if (reexport) {\n          SPropertyOperations.set(prev, \"reexport\", \"\" + (true));\n        }\n        continue;\n      }\n\n      SNode extr = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"), \"module\", false) == resolved.value;\n        }\n      });\n\n      if (extr == null) {\n        extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SNode res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\", null);\n        SLinkOperations.setTarget(extr, \"dependency\", res, true);\n        SLinkOperations.setTarget(res, \"module\", resolved.value, false);\n        ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n      } else {\n        ListSequence.fromList(previous).removeElement(extr);\n      }\n      seen.put(resolved.value, SNodeOperations.cast(SLinkOperations.getTarget(extr, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"));\n      SPropertyOperations.set(SNodeOperations.cast(SLinkOperations.getTarget(extr, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyOnModule\"), \"reexport\", \"\" + (reexport));\n    }\n\n    // java stubs: jars \n    for (ModelRoot entry : myModuleDescriptor.getStubModelEntries()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      final SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode extr = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\") && eq_a6ewnz_a0a0a0a0a0a0a0g0j0r(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\"), \"path\", true)), BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p));\n          }\n        });\n\n        if (extr == null) {\n          extr = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n          SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyJar\", null);\n          SLinkOperations.setTarget(jar, \"path\", p, true);\n          SLinkOperations.setTarget(extr, \"dependency\", jar, true);\n          ListSequence.fromList(SLinkOperations.getTargets(module, \"dependencies\", true)).addElement(extr);\n        } else {\n          ListSequence.fromList(previous).removeElement(extr);\n        }\n      } else {\n        report(\"only jar stub libraries are supported, found: \" + path, myOriginalModule);\n      }\n    }\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadLanguageDeps(boolean checkOnly) {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    boolean importsCore = false;\n    for (ModuleReference lang : descriptor.getExtendedLanguages()) {\n      if (!(importsCore) && \"ceab5195-25ea-4f22-9b92-103b95ca8c0c\".equals(lang.getModuleId())) {\n        importsCore = true;\n      }\n      final SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find extended language in dependencies: \" + lang.getModuleFqName(), myModule);\n        continue;\n      }\n      if (!(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"dependencies\", true)).any(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          SNode em = SNodeOperations.as(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          return em != null && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && asOriginal(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(em, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false)) == resolved;\n        }\n      }))) {\n\n        report(\"extends language dependency should be extracted into build script: \" + lang.toString(), myOriginalModule);\n      }\n    }\n    if (!(importsCore) && !(checkOnly)) {\n      SNode resolved = SNodeOperations.as(visible.resolve(\"jetbrains.mps.lang.core\", \"ceab5195-25ea-4f22-9b92-103b95ca8c0c\"), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find jetbrains.mps.lang.core language in dependencies for \" + SPropertyOperations.getString(myModule, \"name\"), myModule);\n      } else {\n        SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).addElement(ul);\n      }\n    }\n    String langName = myModuleDescriptor.getModuleReference().getModuleFqName();\n    for (GeneratorDescriptor generator : descriptor.getGenerators()) {\n      String generatorName = generator.getGeneratorUID();\n      if (generatorName != null && !(generatorName.startsWith(langName + \"#\"))) {\n        report(\"wrong generator name `\" + generatorName + \"', should start with `\" + langName + \"#'\", myOriginalModule);\n      }\n    }\n  }","id":9039,"modified_method":"private void importLanguageDeps(List<SNode> previous) {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference lang : descriptor.getExtendedLanguages()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(lang.getModuleFqName(), lang.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find extended language in dependencies: \" + lang.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode res = ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, \"dependency\", true), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\"), \"language\", false) == resolved;\n        }\n      });\n      if (res == null) {\n        res = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\", null);\n        SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleDependencyExtendLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        SLinkOperations.setTarget(res, \"dependency\", ul, true);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).addElement(res);\n      } else {\n        ListSequence.fromList(previous).removeElement(res);\n      }\n    }\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void importRequired() {\n    loadFile();\n    if (myModuleDescriptor != null) {\n      SPropertyOperations.set(myModule, \"uuid\", myModuleDescriptor.getModuleReference().getModuleId().toString());\n      SPropertyOperations.set(myModule, \"name\", myModuleDescriptor.getModuleReference().getModuleFqName());\n\n      if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\")) {\n        Iterable<SNode> toRemove = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          }\n        });\n        Iterable<SNode> removed = Sequence.fromIterable(toRemove).select(new ISelector<SNode, SNode>() {\n          public SNode select(SNode it) {\n            return SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\"), \"dependency\", true);\n          }\n        });\n\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).removeSequence(Sequence.fromIterable(toRemove));\n        importDependencies(removed);\n        collectSources(true, true);\n        if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\") && myModuleDescriptor instanceof LanguageDescriptor) {\n          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).clear();\n          importRuntime();\n          importLanguageDeps();\n        }\n      }\n\n      if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\")) {\n        importDevkit();\n      }\n    }\n  }","id":9040,"modified_method":"public void importRequired() {\n    loadFile();\n    if (myModuleDescriptor != null) {\n      SPropertyOperations.set(myModule, \"uuid\", myModuleDescriptor.getModuleReference().getModuleId().toString());\n      SPropertyOperations.set(myModule, \"name\", myModuleDescriptor.getModuleReference().getModuleFqName());\n\n      if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\")) {\n        List<SNode> previous = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          }\n        }).select(new ISelector<SNode, SNode>() {\n          public SNode select(SNode it) {\n            return SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ExtractedModuleDependency\");\n          }\n        }).toListSequence();\n\n        importDependencies(previous);\n        if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\") && myModuleDescriptor instanceof LanguageDescriptor) {\n          importRuntime();\n          importLanguageDeps(previous);\n        }\n        collectSources(true, true);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Module\"), \"dependencies\", true)).removeSequence(ListSequence.fromList(previous));\n      }\n\n      if (SNodeOperations.isInstanceOf(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\")) {\n        importDevkit();\n      }\n    }\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_a6ewnz_a0a0a0a0a0a0a0c0g0j0r(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":9041,"modified_method":"private static boolean eq_a6ewnz_a0a0a0a0a0a0a0g0j0r(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void importRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", null);\n      SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(ul);\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\", null);\n        SLinkOperations.setTarget(jar, \"path\", p, true);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(jar);\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n  }","id":9042,"modified_method":"private void importRuntime() {\n    LanguageDescriptor descriptor = ((LanguageDescriptor) myModuleDescriptor);\n    List<SNode> previous = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true));\n\n    for (ModuleReference module : descriptor.getRuntimeModules()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find runtime solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n\n      SNode ul = SNodeOperations.as(ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\"), \"solution\", false) == resolved;\n        }\n      }), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\");\n      if (ul == null) {\n        ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleSolutionRuntime\", null);\n        SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(ul);\n      } else {\n        ListSequence.fromList(previous).removeElement(ul);\n      }\n    }\n    for (ModelRoot entry : descriptor.getRuntimeStubModels()) {\n      if (!(LanguageID.JAVA_MANAGER.equals(entry.getManager()))) {\n        continue;\n      }\n\n      String path = entry.getPath();\n      final SNode p = ListSequence.fromList(convertPath(path, myOriginalModule)).first();\n      if (p == null) {\n        continue;\n      }\n\n      if (path.endsWith(\".jar\")) {\n        SNode jar = SNodeOperations.as(ListSequence.fromList(previous).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\") && eq_a6ewnz_a0a0a0a0a0a0a0a6a4a31(BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\"), \"path\", true)), BuildSourcePath_Behavior.call_getRelativePath_5481553824944787371(p));\n          }\n        }), \"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\");\n        if (jar == null) {\n          jar = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_ModuleJarRuntime\", null);\n          SLinkOperations.setTarget(jar, \"path\", p, true);\n          ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).addElement(jar);\n        } else {\n          ListSequence.fromList(previous).removeElement(jar);\n        }\n      } else {\n        report(\"only jar runtimes are supported in runtime stubs, found: \" + path, myOriginalModule);\n      }\n    }\n    ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_Language\"), \"runtime\", true)).removeSequence(ListSequence.fromList(previous));\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void importDevkit() {\n    DevkitDescriptor descriptor = ((DevkitDescriptor) myModuleDescriptor);\n    SNode devkit = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n    ListSequence.fromList(SLinkOperations.getTargets(devkit, \"extends\", true)).clear();\n    ListSequence.fromList(SLinkOperations.getTargets(devkit, \"exports\", true)).clear();\n\n    for (ModuleReference module : descriptor.getExtendedDevkits()) {\n      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find devkit in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitRef\", null);\n      SLinkOperations.setTarget(ul, \"devkit\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(devkit, \"extends\", true)).addElement(ul);\n    }\n    for (ModuleReference module : descriptor.getExportedLanguages()) {\n      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find exported languages in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\", null);\n      SLinkOperations.setTarget(ul, \"language\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(devkit, \"exports\", true)).addElement(ul);\n    }\n    for (ModuleReference module : descriptor.getExportedSolutions()) {\n      SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find exported solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\", null);\n      SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n      ListSequence.fromList(SLinkOperations.getTargets(devkit, \"exports\", true)).addElement(ul);\n    }\n  }","id":9043,"modified_method":"private void importDevkit() {\n    DevkitDescriptor descriptor = ((DevkitDescriptor) myModuleDescriptor);\n    SNode devkit = SNodeOperations.cast(myModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n\n    List<SNode> prevExt = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(devkit, \"extends\", true));\n    List<SNode> prevExp = ListSequence.fromListWithValues(new ArrayList<SNode>(), SLinkOperations.getTargets(devkit, \"exports\", true));\n\n    for (ModuleReference module : descriptor.getExtendedDevkits()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\");\n      if (resolved == null) {\n        report(\"cannot find devkit in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n\n      SNode ul = ListSequence.fromList(prevExt).findFirst(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SLinkOperations.getTarget(it, \"devkit\", false) == resolved;\n        }\n      });\n      if (ul == null) {\n        ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitRef\", null);\n        SLinkOperations.setTarget(ul, \"devkit\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(devkit, \"extends\", true)).addElement(ul);\n      } else {\n        ListSequence.fromList(prevExt).removeElement(ul);\n      }\n    }\n    for (ModuleReference module : descriptor.getExportedLanguages()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Language\");\n      if (resolved == null) {\n        report(\"cannot find exported languages in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SNodeOperations.as(ListSequence.fromList(prevExp).findFirst(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\"), \"language\", false) == resolved;\n        }\n      }), \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\");\n      if (ul == null) {\n        ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportLanguage\", null);\n        SLinkOperations.setTarget(ul, \"language\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(devkit, \"exports\", true)).addElement(ul);\n      } else {\n        ListSequence.fromList(prevExp).removeElement(ul);\n      }\n    }\n    for (ModuleReference module : descriptor.getExportedSolutions()) {\n      final SNode resolved = SNodeOperations.as(visible.resolve(module.getModuleFqName(), module.getModuleId().toString()), \"jetbrains.mps.build.mps.structure.BuildMps_Solution\");\n      if (resolved == null) {\n        report(\"cannot find exported solution in dependencies: \" + module.getModuleFqName(), myModule);\n        continue;\n      }\n      SNode ul = SNodeOperations.as(ListSequence.fromList(prevExp).findFirst(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\") && SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\"), \"solution\", false) == resolved;\n        }\n      }), \"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\");\n      if (ul == null) {\n        ul = SConceptOperations.createNewNode(\"jetbrains.mps.build.mps.structure.BuildMps_DevKitExportSolution\", null);\n        SLinkOperations.setTarget(ul, \"solution\", resolved, false);\n        ListSequence.fromList(SLinkOperations.getTargets(devkit, \"exports\", true)).addElement(ul);\n      } else {\n        ListSequence.fromList(prevExp).removeElement(ul);\n      }\n    }\n    ListSequence.fromList(SLinkOperations.getTargets(devkit, \"extends\", true)).removeSequence(ListSequence.fromList(prevExt));\n    ListSequence.fromList(SLinkOperations.getTargets(devkit, \"exports\", true)).removeSequence(ListSequence.fromList(prevExp));\n  }","commit_id":"7d78ba3268120f2861952cb85bdd31b882dd71ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Looks for the specified extension on the current results page.\n     * \n     * @param name the extension pretty name\n     * @param version the extension version\n     * @return the pane displaying the specified extension\n     */\n    public ExtensionPane getExtension(String name, String version)\n    {\n        String nameAndVersion = name + \" \" + version;\n        By xpath =\n            By.xpath(\"//div[contains(@class, 'extension-item') and \"\n                + \"descendant::h2[contains(@class, 'extension-name') and . = '\" + nameAndVersion + \"']]\");\n        return new ExtensionPane(getUtil().findElementWithoutWaiting(getDriver(), xpath));\n    }","id":9044,"modified_method":"/**\n     * Looks for the specified extension on the current results page.\n     * \n     * @param name the extension pretty name\n     * @param version the extension version\n     * @return the pane displaying the specified extension, {@code null} if not found\n     */\n    public ExtensionPane getExtension(String name, String version)\n    {\n        String nameAndVersion = name + \" \" + version;\n        By xpath =\n            By.xpath(\"//div[contains(@class, 'extension-item') and \"\n                + \"descendant::h2[contains(@class, 'extension-name') and . = '\" + nameAndVersion + \"']]\");\n        List<WebElement> found = getUtil().findElementsWithoutWaiting(getDriver(), xpath);\n        return found.size() == 1 ? new ExtensionPane(found.get(0)) : null;\n    }","commit_id":"f4d6b27cb1722798c5dd055b92c9de2e8d85e5cd","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Clicks on the given button and waits for a confirmation or for the job/action to be done.\n     * \n     * @param button the button to be clicked\n     * @return the extension pane showing the confirmation or the job log\n     */\n    private ExtensionPane clickAndWaitForConfirmationOrJobDone(WebElement button)\n    {\n        // Wait until the progress section contains a confirmation button or no loading log items.\n        return clickAndWaitUntilElementIsVisible(button, \"/*[@class = 'extension-body']/*\"\n            + \"[@class = 'extension-body-progress extension-body-section' and \"\n            + \"(descendant::input[@name = 'confirm'] or \"\n            + \"not(descendant::div[contains(@class, 'extension-log-item-loading')]))]\");\n    }","id":9045,"modified_method":"/**\n     * Clicks on the given button and waits for a confirmation or for the job/action to be done.\n     * \n     * @param button the button to be clicked\n     * @return the extension pane showing the confirmation or the job log\n     */\n    private ExtensionPane clickAndWaitForConfirmationOrJobDone(WebElement button)\n    {\n        // Wait until the progress section contains a confirmation button or no loading log items.\n        return clickAndWaitUntilElementIsVisible(button, \"/*[@class = 'extension-body']/*\"\n            + \"[@class = 'extension-body-progress extension-body-section' and \"\n            + \"(descendant::input[@name = 'confirm' and not(@disabled)] or \"\n            + \"count(descendant::div[contains(@class, 'extension-log-item-loading')]) = 0)]\");\n    }","commit_id":"804bd9ea5e32d54f84b476cc15ce92a5981fe815","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the progress bar pane\n     */\n    public ProgressBarPane getProgressBar()\n    {\n        return new ProgressBarPane(getUtil().findElementWithoutWaiting(getDriver(), container,\n            By.className(\"ui-progress\")));\n    }","id":9046,"modified_method":"/**\n     * @return the progress bar pane\n     */\n    public ProgressBarPane getProgressBar()\n    {\n        List<WebElement> found =\n            getUtil().findElementsWithoutWaiting(getDriver(), container, By.className(\"ui-progress\"));\n        return found.size() != 1 ? null : new ProgressBarPane(found.get(0));\n    }","commit_id":"804bd9ea5e32d54f84b476cc15ce92a5981fe815","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Clicks on the given button and waits for a confirmation or for the job/action to be done.\n     * \n     * @param button the button to be clicked\n     * @return the extension pane showing the confirmation or the job log\n     */\n    private ExtensionPane clickAndWaitForConfirmationOrJobDone(WebElement button)\n    {\n        // Wait until the progress section contains a confirmation button or no loading log items.\n        return clickAndWaitUntilElementIsVisible(button, \"/*[@class = 'extension-body']/*\"\n            + \"[@class = 'extension-body-progress extension-body-section' and \"\n            + \"(descendant::input[@name = 'confirm'] or \"\n            + \"not(descendant::div[contains(@class, 'extension-log-item-loading')]))]\");\n    }","id":9047,"modified_method":"/**\n     * Clicks on the given button and waits for a confirmation or for the job/action to be done.\n     * \n     * @param button the button to be clicked\n     * @return the extension pane showing the confirmation or the job log\n     */\n    private ExtensionPane clickAndWaitForConfirmationOrJobDone(WebElement button)\n    {\n        // Wait until the progress section contains a confirmation button or no loading log items.\n        return clickAndWaitUntilElementIsVisible(button, \"/*[@class = 'extension-body']/*\"\n            + \"[@class = 'extension-body-progress extension-body-section' and \"\n            + \"(descendant::input[@name = 'confirm' and not(@disabled)] or \"\n            + \"count(descendant::div[contains(@class, 'extension-log-item-loading')]) = 0)]\");\n    }","commit_id":"d6498c7ce32f8cad814428fb18fb8020fac01d74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return the progress bar pane\n     */\n    public ProgressBarPane getProgressBar()\n    {\n        return new ProgressBarPane(getUtil().findElementWithoutWaiting(getDriver(), container,\n            By.className(\"ui-progress\")));\n    }","id":9048,"modified_method":"/**\n     * @return the progress bar pane\n     */\n    public ProgressBarPane getProgressBar()\n    {\n        List<WebElement> found =\n            getUtil().findElementsWithoutWaiting(getDriver(), container, By.className(\"ui-progress\"));\n        return found.size() != 1 ? null : new ProgressBarPane(found.get(0));\n    }","commit_id":"d6498c7ce32f8cad814428fb18fb8020fac01d74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Wait for certain condition to happen.\n     *\n     * For example, wait for a translation updated event gets broadcast to editor.\n     *\n     * @param callable a callable that returns a result\n     * @param matcher a matcher that matches to expected result\n     * @param <T> result type\n     */\n    public <T> void\n            waitFor(final Callable<T> callable, final Matcher<T> matcher) {\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                try {\n                    T result = callable.call();\n                    if (!matcher.matches(result)) {\n                        matcher.describeMismatch(result,\n                                new Description.NullDescription());\n                    }\n                    return matcher.matches(result);\n                } catch (Exception e) {\n                    log.warn(\"exception\", e);\n                    return false;\n                }\n            }\n        });\n    }","id":9049,"modified_method":"/**\n     * Wait for certain condition to happen.\n     *\n     * For example, wait for a translation updated event gets broadcast to editor.\n     *\n     * @param callable a callable that returns a result\n     * @param matcher a matcher that matches to expected result\n     * @param <T> result type\n     */\n    public <T> void\n            waitFor(final Callable<T> callable, final Matcher<T> matcher) {\n        waitForAMoment().withMessage(StringDescription.toString(matcher)).until(\n                new Predicate<WebDriver>() {\n                    @Override\n                    public boolean apply(WebDriver input) {\n                        try {\n                            T result = callable.call();\n                            if (!matcher.matches(result)) {\n                                matcher.describeMismatch(result,\n                                        new Description.NullDescription());\n                            }\n                            return matcher.matches(result);\n                        } catch (Exception e) {\n                            log.warn(\"exception\", e);\n                            return false;\n                        }\n                    }\n                });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait for an element to be visible, and return it\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForWebElement(final By elementBy) {\n        log.info(\"Waiting for element ready {}\", elementBy.toString());\n        waitForPageSilence();\n        return waitForAMoment().until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                WebElement targetElement = getDriver().findElement(elementBy);\n                if (!elementIsReady(targetElement)) {\n                    return null;\n                }\n                return targetElement;\n            }\n        });\n    }","id":9050,"modified_method":"/**\n     * Wait for an element to be visible, and return it\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForWebElement(final By elementBy) {\n        String msg = \"element ready \" + elementBy;\n        logWaiting(msg);\n        waitForPageSilence();\n        return waitForAMoment().withMessage(msg).until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                WebElement targetElement = getDriver().findElement(elementBy);\n                if (!elementIsReady(targetElement)) {\n                    return null;\n                }\n                return targetElement;\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"public Alert switchToAlert() {\n        return waitForAMoment().until(new Function<WebDriver, Alert>() {\n            @Override\n            public Alert apply(WebDriver driver) {\n                try {\n                    return getDriver().switchTo().alert();\n                } catch (NoAlertPresentException noAlertPresent) {\n                    return null;\n                }\n            }\n        });\n    }","id":9051,"modified_method":"public Alert switchToAlert() {\n        return waitForAMoment().withMessage(\"alert\").until(new Function<WebDriver, Alert>() {\n            @Override\n            public Alert apply(WebDriver driver) {\n                try {\n                    return getDriver().switchTo().alert();\n                } catch (NoAlertPresentException noAlertPresent) {\n                    return null;\n                }\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait for an element to exist on the page, and return it.\n     * Generally used for situations where checking on the state of an element,\n     * e.g isVisible, rather than clicking on it or getting its text.\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForElementExists(final By elementBy) {\n        log.info(\"Waiting for element exists {}\", elementBy.toString());\n        waitForPageSilence();\n        return waitForAMoment().until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                return getDriver().findElement(elementBy);\n            }\n        });\n    }","id":9052,"modified_method":"/**\n     * Wait for an element to exist on the page, and return it.\n     * Generally used for situations where checking on the state of an element,\n     * e.g isVisible, rather than clicking on it or getting its text.\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForElementExists(final By elementBy) {\n        String msg = \"element exists \" + elementBy;\n        logWaiting(msg);\n        waitForPageSilence();\n        return waitForAMoment().withMessage(msg).until(\n                new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                return getDriver().findElement(elementBy);\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait for a child element to exist on the page, and return it.\n     * Generally used for situations where checking on the state of an element,\n     * e.g isVisible, rather than clicking on it or getting its text.\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForElementExists(final WebElement parentElement,\n                                           final By elementBy) {\n        log.info(\"Waiting for element exists {}\", elementBy.toString());\n        waitForPageSilence();\n        return waitForAMoment().until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                return parentElement.findElement(elementBy);\n            }\n        });\n    }","id":9053,"modified_method":"/**\n     * Wait for a child element to exist on the page, and return it.\n     * Generally used for situations where checking on the state of an element,\n     * e.g isVisible, rather than clicking on it or getting its text.\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForElementExists(final WebElement parentElement,\n                                           final By elementBy) {\n        String msg = \"element exists \" + elementBy;\n        logWaiting(msg);\n        waitForPageSilence();\n        return waitForAMoment().withMessage(msg).until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                return parentElement.findElement(elementBy);\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected <P extends AbstractPage, T> T refreshPageUntil(P currentPage,\n            Function<WebDriver, T> function) {\n        T done = waitForAMoment().until(function);\n        PageFactory.initElements(driver, currentPage);\n        return done;\n    }","id":9054,"modified_method":"/**\n     * @deprecated Use the overload which includes a message\n     */\n    @Deprecated\n    protected <P extends AbstractPage, T> T refreshPageUntil(P currentPage,\n            Function<WebDriver, T> function) {\n        return refreshPageUntil(currentPage, function, null);\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait for jQuery and Ajax calls to be 0\n     * If either are not defined, they can be assumed to be 0.\n     */\n    public void waitForPageSilence() {\n        // Wait for jQuery calls to be 0\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                int ajaxCalls;\n                try {\n                    ajaxCalls = Integer.parseInt(\n                            ((JavascriptExecutor) getDriver())\n                                    .executeScript(\"return XMLHttpRequest.active\")\n                                    .toString()\n                    );\n                } catch (WebDriverException jCall) {\n                    ajaxCalls = 0;\n                }\n                return ajaxCalls == 0;\n            }\n        });\n    }","id":9055,"modified_method":"/**\n     * Wait for jQuery and Ajax calls to be 0\n     * If either are not defined, they can be assumed to be 0.\n     */\n    public void waitForPageSilence() {\n        // Wait for jQuery calls to be 0\n        waitForAMoment().withMessage(\"page silence\").until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                int ajaxCalls;\n                try {\n                    ajaxCalls = Integer.parseInt(\n                            ((JavascriptExecutor) getDriver())\n                                    .executeScript(\"return XMLHttpRequest.active\")\n                                    .toString()\n                    );\n                } catch (WebDriverException jCall) {\n                    ajaxCalls = 0;\n                }\n                return ajaxCalls == 0;\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected <P extends AbstractPage> P refreshPageUntil(P currentPage,\n            Predicate<WebDriver> predicate) {\n        waitForAMoment().until(predicate);\n        PageFactory.initElements(driver, currentPage);\n        return currentPage;\n    }","id":9056,"modified_method":"/**\n     * @deprecated Use the overload which includes a message\n     */\n    @Deprecated\n    protected <P extends AbstractPage> P refreshPageUntil(P currentPage,\n            Predicate<WebDriver> predicate) {\n        return refreshPageUntil(currentPage, predicate, null);\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait for a child element to be visible, and return it\n     * @param parentElement parent element of target\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForWebElement(final WebElement parentElement,\n                                        final By elementBy) {\n        log.info(\"Waiting for element ready {}\", elementBy.toString());\n        waitForPageSilence();\n        return waitForAMoment().until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                WebElement targetElement = parentElement.findElement(elementBy);\n                if (!elementIsReady(targetElement)) {\n                    return null;\n                }\n                return targetElement;\n            }\n        });\n    }","id":9057,"modified_method":"/**\n     * Wait for a child element to be visible, and return it\n     * @param parentElement parent element of target\n     * @param elementBy WebDriver By locator\n     * @return target WebElement\n     */\n    public WebElement waitForWebElement(final WebElement parentElement,\n                                        final By elementBy) {\n        String msg = \"element ready \" + elementBy;\n        logWaiting(msg);\n        waitForPageSilence();\n        return waitForAMoment().withMessage(msg).until(new Function<WebDriver, WebElement>() {\n            @Override\n            public WebElement apply(WebDriver input) {\n                WebElement targetElement = parentElement.findElement(elementBy);\n                if (!elementIsReady(targetElement)) {\n                    return null;\n                }\n                return targetElement;\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectVersionsPage clickSearchEntry(final String searchEntry) {\n        log.info(\"Click Projects search result {}\", searchEntry);\n        WebElement searchItem =\n                waitForAMoment().until(new Function<WebDriver, WebElement>() {\n                    @Override\n                    public WebElement apply(WebDriver driver) {\n                        List<WebElement> items =\n                                WebElementUtil.getSearchAutocompleteResults(\n                                        driver, \"general-search-form\",\n                                        \"projectAutocomplete\");\n\n                        for (WebElement item : items) {\n                            if (item.getText().equals(searchEntry)) {\n                                return item;\n                            }\n                        }\n                        return null;\n                    }\n                });\n        searchItem.click();\n        return new ProjectVersionsPage(getDriver());\n    }","id":9058,"modified_method":"public ProjectVersionsPage clickSearchEntry(final String searchEntry) {\n        log.info(\"Click Projects search result {}\", searchEntry);\n        String msg = \"search result \" + searchEntry;\n        WebElement searchItem =\n                waitForAMoment().withMessage(msg).until(\n                        new Function<WebDriver, WebElement>() {\n                            @Override\n                            public WebElement apply(WebDriver driver) {\n                                List<WebElement> items =\n                                        WebElementUtil\n                                                .getSearchAutocompleteResults(\n                                                        driver,\n                                                        \"general-search-form\",\n                                                        \"projectAutocomplete\");\n\n                                for (WebElement item : items) {\n                                    if (item.getText().equals(searchEntry)) {\n                                        return item;\n                                    }\n                                }\n                                return null;\n                            }\n                        });\n        searchItem.click();\n        return new ProjectVersionsPage(getDriver());\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void clickWhenTabEnabled(final WebElement tab) {\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                waitForPageSilence();\n                boolean clicked = false;\n                try {\n                    scrollIntoView(tab);\n                    if (tab.isDisplayed() && tab.isEnabled()) {\n                        tab.click();\n                        clicked = true;\n                    }\n                } catch (WebDriverException wde) {\n                    return false;\n                }\n                return clicked;\n            }\n        });\n    }","id":9059,"modified_method":"public void clickWhenTabEnabled(final WebElement tab) {\n        String msg = \"Clickable tab: \" + tab;\n        waitForAMoment().withMessage(msg).until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                waitForPageSilence();\n                boolean clicked = false;\n                try {\n                    scrollIntoView(tab);\n                    if (tab.isDisplayed() && tab.isEnabled()) {\n                        tab.click();\n                        clicked = true;\n                    }\n                } catch (WebDriverException wde) {\n                    return false;\n                }\n                return clicked;\n            }\n        });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void clickNavMenuItem(final WebElement menuItem) {\n        scrollToTop();\n        slightPause();\n        if (!menuItem.isDisplayed()) {\n            // screen is too small the menu become dropdown\n            getDriver().findElement(By.id(\"nav-main\"))\n                    .findElement(By.tagName(\"a\")).click();\n        }\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return menuItem.isDisplayed();\n            }\n        });\n        // The notifications can sometimes get in the way\n        waitForAMoment().until(ExpectedConditions.elementToBeClickable(menuItem));\n        menuItem.click();\n    }","id":9060,"modified_method":"private void clickNavMenuItem(final WebElement menuItem) {\n        scrollToTop();\n        slightPause();\n        if (!menuItem.isDisplayed()) {\n            // screen is too small the menu become dropdown\n            getDriver().findElement(By.id(\"nav-main\"))\n                    .findElement(By.tagName(\"a\")).click();\n        }\n        waitForAMoment().withMessage(\"displayed: \" + menuItem).until(\n                new Predicate<WebDriver>() {\n                    @Override\n                    public boolean apply(WebDriver input) {\n                        return menuItem.isDisplayed();\n                    }\n                });\n        // The notifications can sometimes get in the way\n        waitForAMoment().withMessage(\"clickable: \" + menuItem).until(\n                ExpectedConditions.elementToBeClickable(menuItem));\n        menuItem.click();\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"public BasePage waitForSearchListContains(final String expected) {\n        log.info(\"Wait for Project search list contains {}\", expected);\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getProjectSearchAutocompleteItems().contains(expected);\n            }\n        });\n        return new BasePage(getDriver());\n    }","id":9061,"modified_method":"public BasePage waitForSearchListContains(final String expected) {\n        String msg = \"Project search list contains \" + expected;\n        logWaiting(msg);\n        waitForAMoment().withMessage(msg).until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getProjectSearchAutocompleteItems().contains(expected);\n            }\n        });\n        return new BasePage(getDriver());\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait until an expected error is visible\n     *\n     * @param expected The expected error string\n     * @return The full list of visible errors\n     */\n    public List<String> expectError(final String expected) {\n        log.info(\"Expect error {}\", expected);\n        waitForAMoment().until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getErrors().contains(expected);\n            }\n        });\n        return getErrors();\n    }","id":9062,"modified_method":"/**\n     * Wait until an expected error is visible\n     *\n     * @param expected The expected error string\n     * @return The full list of visible errors\n     */\n    public List<String> expectError(final String expected) {\n        String msg = \"expected error: \" + expected;\n        logWaiting(msg);\n        waitForAMoment().withMessage(msg).until(new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getErrors().contains(expected);\n            }\n        });\n        return getErrors();\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected void clickAndExpectErrors(WebElement button) {\n        button.click();\n        refreshPageUntil(this, new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getErrors().size() > 0;\n            }\n        });\n    }","id":9063,"modified_method":"protected void clickAndExpectErrors(WebElement button) {\n        button.click();\n        refreshPageUntil(this, new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getErrors().size() > 0;\n            }\n        }, \"errors > 0\");\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Wait until expected number of errors presented on page or timeout.\n     *\n     * @param expectedNumber\n     *            expected number of errors on page\n     * @return list of error message\n     */\n    public List<String> getErrors(final int expectedNumber) {\n        log.info(\"Query page errors, expecting {}\", expectedNumber);\n        refreshPageUntil(this, new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getErrors().size() == expectedNumber;\n            }\n        });\n        return getErrors();\n    }","id":9064,"modified_method":"/**\n     * Wait until expected number of errors presented on page or timeout.\n     *\n     * @param expectedNumber\n     *            expected number of errors on page\n     * @return list of error message\n     */\n    public List<String> getErrors(final int expectedNumber) {\n        log.info(\"Query page errors, expecting {}\", expectedNumber);\n        refreshPageUntil(this, new Predicate<WebDriver>() {\n            @Override\n            public boolean apply(WebDriver input) {\n                return getErrors().size() == expectedNumber;\n            }\n        }, \"errors = \" + expectedNumber);\n        return getErrors();\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean expectNotification(final String notification) {\n        log.info(\"Wait for notification {}\", notification);\n        return waitForAMoment().until(new Function<WebDriver, Boolean>() {\n            @Override\n            public Boolean apply(WebDriver driver) {\n                List<WebElement> messages = getDriver()\n                        .findElement(By.id(\"messages\"))\n                        .findElements(By.tagName(\"li\"));\n                List<String> notifications = new ArrayList<String>();\n                for (WebElement message : messages) {\n                    notifications.add(message.getText().trim());\n                }\n                return notifications.contains(notification);\n            }\n        });\n    }","id":9065,"modified_method":"public boolean expectNotification(final String notification) {\n        String msg = \"notification \" + notification;\n        logWaiting(msg);\n        return waitForAMoment().withMessage(msg).until(\n                new Function<WebDriver, Boolean>() {\n                    @Override\n                    public Boolean apply(WebDriver driver) {\n                        List<WebElement> messages = getDriver()\n                                .findElement(By.id(\"messages\"))\n                                .findElements(By.tagName(\"li\"));\n                        List<String> notifications = new ArrayList<String>();\n                        for (WebElement message : messages) {\n                            notifications.add(message.getText().trim());\n                        }\n                        return notifications.contains(notification);\n                    }\n                });\n    }","commit_id":"49b364dc6c6fda846b69d8302621c2d915380f8e","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected Set<Artifact> resolveDependencyArtifacts( final MavenProject theProject )\n        throws ArtifactResolutionException, ArtifactNotFoundException, InvalidDependencyVersionException\n    {\n        final Set<Artifact> artifacts =\n            theProject.createArtifacts( this.factory, Artifact.SCOPE_TEST,\n                                        new ScopeArtifactFilter( Artifact.SCOPE_TEST ) );\n\n        for ( final Artifact artifact : artifacts )\n        {\n            // resolve the new artifact\n            this.resolver.resolve( artifact, this.remoteRepos, this.getLocal() );\n        }\n        return artifacts;\n    }","id":9066,"modified_method":"protected Set<Artifact> resolveDependencyArtifacts( final MavenProject theProject )\n        throws ArtifactResolverException, ArtifactNotFoundException, InvalidDependencyVersionException\n    {\n        final Set<Artifact> artifacts =\n            theProject.createArtifacts( this.factory, Artifact.SCOPE_TEST,\n                                        new ScopeArtifactFilter( Artifact.SCOPE_TEST ) );\n\n        ProjectBuildingRequest buildingRequest =\n            new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n        \n        buildingRequest.setLocalRepository( getLocal() );\n        \n        buildingRequest.setRemoteRepositories( this.remoteRepos );\n        \n        for ( final Artifact artifact : artifacts )\n        {\n            // resolve the new artifact\n            getArtifactResolver().resolveArtifact( buildingRequest, artifact );\n        }\n        return artifacts;\n    }","commit_id":"015df7b93c1e956720334e73a9fb301545d22d79","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     * @return resolved set of dependencies\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     *\n     */\n    protected Set<Artifact> resolveArtifactDependencies( final Artifact artifact )\n        throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException,\n        InvalidDependencyVersionException\n    {\n        final Artifact pomArtifact =\n            this.factory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\",\n                                         \"pom\" );\n\n        final MavenProject pomProject =\n            projectBuilder.build( pomArtifact, session.getProjectBuildingRequest() ).getProject();\n\n        return resolveDependencyArtifacts( pomProject );\n    }","id":9067,"modified_method":"/**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     * @return resolved set of dependencies\n     * @throws ArtifactResolverException\n     * @throws ArtifactNotFoundException\n     * @throws ProjectBuildingException\n     * @throws InvalidDependencyVersionException\n     *\n     */\n    protected Set<Artifact> resolveArtifactDependencies( final Artifact artifact )\n        throws ArtifactResolverException, ArtifactNotFoundException, ProjectBuildingException,\n        InvalidDependencyVersionException\n    {\n        final Artifact pomArtifact =\n            this.factory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\",\n                                         \"pom\" );\n\n        final MavenProject pomProject =\n            projectBuilder.build( pomArtifact, session.getProjectBuildingRequest() ).getProject();\n\n        return resolveDependencyArtifacts( pomProject );\n    }","commit_id":"015df7b93c1e956720334e73a9fb301545d22d79","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * displaying the resolved version.\n     *\n     * @throws MojoExecutionException with a message if an error occurs.\n     */\n    @Override\n    protected void doExecute()\n        throws MojoExecutionException\n    {\n        Writer outputWriter = null;\n\n        try\n        {\n            final Set<Artifact> plugins = resolvePluginArtifacts();\n\n            if ( this.outputFile != null )\n            {\n                outputFile.getParentFile()\n                          .mkdirs();\n\n                outputWriter = new FileWriter( outputFile );\n            }\n\n            for ( final Artifact plugin : plugins )\n            {\n                String logStr = \"Plugin Resolved: \" + DependencyUtil.getFormattedFileName( plugin, false );\n                if ( !silent )\n                {\n                    this.getLog().info( logStr );\n                }\n\n                if ( outputWriter != null )\n                {\n                    outputWriter.write( logStr );\n                    outputWriter.write( \"\\n\" );\n                }\n\n                if ( !excludeTransitive )\n                {\n                    for ( final Artifact artifact : resolveArtifactDependencies( plugin ) )\n                    {\n                        logStr =\n                            \"    Plugin Dependency Resolved: \" + DependencyUtil.getFormattedFileName( artifact, false );\n\n                        if ( !silent )\n                        {\n                            this.getLog().info( logStr );\n                        }\n\n                        if ( outputWriter != null )\n                        {\n                            outputWriter.write( logStr );\n                            outputWriter.write( \"\\n\" );\n                        }\n                    }\n                }\n            }\n        }\n        catch ( final IOException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactResolutionException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ProjectBuildingException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactFilterException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        finally\n        {\n            IOUtil.close( outputWriter );\n        }\n\n    }","id":9068,"modified_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * displaying the resolved version.\n     *\n     * @throws MojoExecutionException with a message if an error occurs.\n     */\n    @Override\n    protected void doExecute()\n        throws MojoExecutionException\n    {\n        Writer outputWriter = null;\n\n        try\n        {\n            final Set<Artifact> plugins = resolvePluginArtifacts();\n\n            if ( this.outputFile != null )\n            {\n                outputFile.getParentFile()\n                          .mkdirs();\n\n                outputWriter = new FileWriter( outputFile );\n            }\n\n            for ( final Artifact plugin : plugins )\n            {\n                String logStr = \"Plugin Resolved: \" + DependencyUtil.getFormattedFileName( plugin, false );\n                if ( !silent )\n                {\n                    this.getLog().info( logStr );\n                }\n\n                if ( outputWriter != null )\n                {\n                    outputWriter.write( logStr );\n                    outputWriter.write( \"\\n\" );\n                }\n\n                if ( !excludeTransitive )\n                {\n                    for ( final Artifact artifact : resolveArtifactDependencies( plugin ) )\n                    {\n                        logStr =\n                            \"    Plugin Dependency Resolved: \" + DependencyUtil.getFormattedFileName( artifact, false );\n\n                        if ( !silent )\n                        {\n                            this.getLog().info( logStr );\n                        }\n\n                        if ( outputWriter != null )\n                        {\n                            outputWriter.write( logStr );\n                            outputWriter.write( \"\\n\" );\n                        }\n                    }\n                }\n            }\n        }\n        catch ( final IOException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ProjectBuildingException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactFilterException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        finally\n        {\n            IOUtil.close( outputWriter );\n        }\n\n    }","commit_id":"015df7b93c1e956720334e73a9fb301545d22d79","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * This method resolves the plugin artifacts from the project.\n     *\n     * @return set of resolved plugin artifacts.\n     * @throws ArtifactResolutionException\n     * @throws ArtifactNotFoundException\n     * @throws ArtifactFilterException \n     */\n    protected Set<Artifact> resolvePluginArtifacts()\n        throws ArtifactResolutionException, ArtifactNotFoundException, ArtifactFilterException\n    {\n        final Set<Artifact> plugins = project.getPluginArtifacts();\n        final Set<Artifact> reports = project.getReportArtifacts();\n\n        Set<Artifact> artifacts = new HashSet<Artifact>();\n        artifacts.addAll( reports );\n        artifacts.addAll( plugins );\n\n        final FilterArtifacts filter = getPluginArtifactsFilter();\n        artifacts = filter.filter( artifacts );\n\n        //        final ArtifactFilter filter = getPluginFilter();\n        for ( final Artifact artifact : new HashSet<Artifact>( artifacts ) )\n        {\n            // if ( !filter.include( artifact ) )\n            // {\n            //     final String logStr =\n            //     String.format( \"    Plugin SKIPPED: %s\", DependencyUtil.getFormattedFileName( artifact, false ) );\n            //\n            //     if ( !silent )\n            //     {\n            //         this.getLog().info( logStr );\n            //     }\n            //\n            //     artifacts.remove( artifact );\n            //     continue;\n            // }\n\n            // resolve the new artifact\n            this.resolver.resolve( artifact, this.remotePluginRepositories, this.getLocal() );\n        }\n        return artifacts;\n    }","id":9069,"modified_method":"/**\n     * This method resolves the plugin artifacts from the project.\n     *\n     * @return set of resolved plugin artifacts.\n     * @throws ArtifactFilterException \n     * @throws ArtifactResolverException \n     */\n    protected Set<Artifact> resolvePluginArtifacts()\n        throws ArtifactFilterException, ArtifactResolverException\n    {\n        final Set<Artifact> plugins = project.getPluginArtifacts();\n        final Set<Artifact> reports = project.getReportArtifacts();\n\n        Set<Artifact> artifacts = new HashSet<Artifact>();\n        artifacts.addAll( reports );\n        artifacts.addAll( plugins );\n\n        final FilterArtifacts filter = getPluginArtifactsFilter();\n        artifacts = filter.filter( artifacts );\n\n        //        final ArtifactFilter filter = getPluginFilter();\n        for ( final Artifact artifact : new HashSet<Artifact>( artifacts ) )\n        {\n            // if ( !filter.include( artifact ) )\n            // {\n            //     final String logStr =\n            //     String.format( \"    Plugin SKIPPED: %s\", DependencyUtil.getFormattedFileName( artifact, false ) );\n            //\n            //     if ( !silent )\n            //     {\n            //         this.getLog().info( logStr );\n            //     }\n            //\n            //     artifacts.remove( artifact );\n            //     continue;\n            // }\n\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            \n            buildingRequest.setLocalRepository( this.getLocal() );\n            \n            buildingRequest.setRemoteRepositories( this.remotePluginRepositories );\n            \n            // resolve the new artifact\n            getArtifactResolver().resolveArtifact( buildingRequest, artifact );\n        }\n        return artifacts;\n    }","commit_id":"015df7b93c1e956720334e73a9fb301545d22d79","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected Artifact getResolvedPomArtifact( Artifact artifact )\n    {\n        Artifact pomArtifact =\n            this.factory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\",\n                                         \"pom\" );\n        // Resolve the pom artifact using repos\n        try\n        {\n            this.resolver.resolve( pomArtifact, this.remoteRepos, this.getLocal() );\n        }\n        catch ( Exception e )\n        {\n            getLog().info( e.getMessage() );\n        }\n        return pomArtifact;\n    }","id":9070,"modified_method":"protected Artifact getResolvedPomArtifact( Artifact artifact )\n    {\n        Artifact pomArtifact =\n            this.factory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), \"\",\n                                         \"pom\" );\n        // Resolve the pom artifact using repos\n        try\n        {\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n\n            buildingRequest.setLocalRepository( this.getLocal() );\n            \n            buildingRequest.setRemoteRepositories( this.remoteRepos );\n            \n            pomArtifact = getArtifactResolver().resolveArtifact( buildingRequest, pomArtifact );\n        }\n        catch ( ArtifactResolverException e )\n        {\n            getLog().info( e.getMessage() );\n        }\n        return pomArtifact;\n    }","commit_id":"493e37eceb715a29d62bc35105d93315cc07c0bc","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testCopyPom()\n        throws Exception\n    {\n        mojo.setCopyPom( true );\n        mojo.setResolver( new StubArtifactResolver( stubFactory, false, false ) );\n        mojo.setLocal( new StubArtifactRepository( this.testDir.getAbsolutePath() ) );\n\n        Set<Artifact> set = new HashSet<Artifact>();\n        set.add( stubFactory.createArtifact( \"org.apache.maven\", \"maven-artifact\", \"2.0.7\", Artifact.SCOPE_COMPILE ) );\n        mojo.getProject().setArtifacts( set );\n        mojo.execute();\n\n        Set<Artifact> artifacts = mojo.getProject().getArtifacts();\n        for ( Artifact artifact : artifacts )\n        {\n            String fileName = DependencyUtil.getFormattedFileName( artifact, false );\n            File file = new File( mojo.outputDirectory, fileName.substring( 0, fileName.length() - 4 ) + \".pom\" );\n            assertTrue( file.exists() );\n        }\n    }","id":9071,"modified_method":"public void testCopyPom()\n        throws Exception\n    {\n        mojo.setCopyPom( true );\n        mojo.setResolver( new StubArtifactResolver( stubFactory, false, false ) );\n        mojo.setLocal( new StubArtifactRepository( this.testDir.getAbsolutePath() ) );\n\n        Set<Artifact> set = new HashSet<Artifact>();\n        set.add( stubFactory.createArtifact( \"org.apache.maven\", \"maven-artifact\", \"2.0.7\", Artifact.SCOPE_COMPILE ) );\n        stubFactory.createArtifact( \"org.apache.maven\", \"maven-artifact\", \"2.0.7\", Artifact.SCOPE_COMPILE, \"pom\", null );\n        mojo.getProject().setArtifacts( set );\n        mojo.execute();\n\n        Set<Artifact> artifacts = mojo.getProject().getArtifacts();\n        for ( Artifact artifact : artifacts )\n        {\n            String fileName = DependencyUtil.getFormattedFileName( artifact, false );\n            File file = new File( mojo.outputDirectory, fileName.substring( 0, fileName.length() - 4 ) + \".pom\" );\n            assertTrue( file + \" doesn't exist\", file.exists() );\n        }\n    }","commit_id":"493e37eceb715a29d62bc35105d93315cc07c0bc","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void setUp()\n        throws Exception\n    {\n        // required for mojo lookups to work\n        super.setUp( \"copy-dependencies\", true );\n\n        File testPom = new File( getBasedir(), \"target/test-classes/unit/copy-dependencies-test/plugin-config.xml\" );\n        mojo = (CopyDependenciesMojo) lookupMojo( \"copy-dependencies\", testPom );\n        mojo.outputDirectory = new File( this.testDir, \"outputDirectory\" );\n        // mojo.silent = true;\n\n        assertNotNull( mojo );\n        assertNotNull( mojo.getProject() );\n        MavenProject project = mojo.getProject();\n\n        Set<Artifact> artifacts = this.stubFactory.getScopedArtifacts();\n        Set<Artifact> directArtifacts = this.stubFactory.getReleaseAndSnapshotArtifacts();\n        artifacts.addAll( directArtifacts );\n\n        project.setArtifacts( artifacts );\n        project.setDependencyArtifacts( directArtifacts );\n        mojo.markersDirectory = new File( this.testDir, \"markers\" );\n\n        LegacySupport legacySupport = lookup( LegacySupport.class );\n        legacySupport.setSession( newMavenSession( new MavenProjectStub() ) );\n        DefaultRepositorySystemSession repoSession =\n            (DefaultRepositorySystemSession) legacySupport.getRepositorySession();\n        repoSession.setLocalRepositoryManager( new SimpleLocalRepositoryManager( testDir.getAbsolutePath() ) );\n    }","id":9072,"modified_method":"protected void setUp()\n        throws Exception\n    {\n        // required for mojo lookups to work\n        super.setUp( \"copy-dependencies\", true );\n\n        File testPom = new File( getBasedir(), \"target/test-classes/unit/copy-dependencies-test/plugin-config.xml\" );\n        mojo = (CopyDependenciesMojo) lookupMojo( \"copy-dependencies\", testPom );\n        mojo.outputDirectory = new File( this.testDir, \"outputDirectory\" );\n        // mojo.silent = true;\n\n        assertNotNull( mojo );\n        assertNotNull( mojo.getProject() );\n        MavenProject project = mojo.getProject();\n\n        Set<Artifact> artifacts = this.stubFactory.getScopedArtifacts();\n        Set<Artifact> directArtifacts = this.stubFactory.getReleaseAndSnapshotArtifacts();\n        artifacts.addAll( directArtifacts );\n\n        project.setArtifacts( artifacts );\n        project.setDependencyArtifacts( directArtifacts );\n        mojo.markersDirectory = new File( this.testDir, \"markers\" );\n\n        LegacySupport legacySupport = lookup( LegacySupport.class );\n        MavenSession session = newMavenSession( project );\n        setVariableValueToObject( mojo, \"session\", session );\n        \n        legacySupport.setSession( session );\n        DefaultRepositorySystemSession repoSession =\n            (DefaultRepositorySystemSession) legacySupport.getRepositorySession();\n        repoSession.setLocalRepositoryManager( new SimpleLocalRepositoryManager( testDir.getAbsolutePath() ) );\n    }","commit_id":"493e37eceb715a29d62bc35105d93315cc07c0bc","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addParentArtifacts( MavenProject project, Set<Artifact> artifacts )\n        throws MojoExecutionException\n    {\n        while ( project.hasParent() )\n        {\n            project = project.getParent();\n\n            if ( !artifacts.add( project.getArtifact() ) )\n            {\n                // artifact already in the set\n                break;\n            }\n            try\n            {\n                resolver.resolve( project.getArtifact(), this.remoteRepos, this.getLocal() );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                throw new MojoExecutionException( e.getMessage(), e );\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                throw new MojoExecutionException( e.getMessage(), e );\n            }\n        }\n    }","id":9073,"modified_method":"private void addParentArtifacts( MavenProject project, Set<Artifact> artifacts )\n        throws MojoExecutionException\n    {\n        while ( project.hasParent() )\n        {\n            project = project.getParent();\n\n            if ( artifacts.contains( project.getArtifact() ) )\n            {\n                // artifact already in the set\n                break;\n            }\n            try\n            {\n                ProjectBuildingRequest buildingRequest =\n                    new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n                \n                buildingRequest.setLocalRepository( this.getLocal() );\n                \n                buildingRequest.setRemoteRepositories( this.remoteRepos );\n                \n                Artifact resolvedArtifact = artifactResolver.resolveArtifact( buildingRequest, project.getArtifact() );\n                \n                artifacts.add( resolvedArtifact );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                throw new MojoExecutionException( e.getMessage(), e );\n            }\n        }\n    }","commit_id":"7d46908f05e8379bc32d79aee5817f4df6a9a63d","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void transformPomToSnapshotVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we will need to incorporate versioning strategies here because it is unlikely\r\n        // that everyone will be able to agree on a standard. This is extremely limited right\r\n        // now and really only works for the way maven is versioned.\r\n\r\n        // releaseVersion = 1.0-beta-4\r\n        // snapshotVersion = 1.0-beta-5-SNAPSHOT\r\n\r\n        String nextVersionString = projectVersion.substring( projectVersion.lastIndexOf( \"-\" ) + 1 );\r\n\r\n        try\r\n        {\r\n            nextVersionString = Integer.toString( Integer.parseInt( nextVersionString ) + 1 );\r\n\r\n            projectVersion = projectVersion.substring( 0, projectVersion.lastIndexOf( \"-\" ) + 1 ) + nextVersionString + SNAPSHOT;\r\n        }\r\n        catch ( NumberFormatException e )\r\n        {\r\n            projectVersion = \"\";\r\n        }\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n\r\n            model.setVersion( projectVersion );\r\n\r\n            model.getScm().setTag( currentTag );\r\n\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its snapshot version form.\", e );\r\n        }\r\n    }","id":9074,"modified_method":"private void transformPomToSnapshotVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we will need to incorporate versioning strategies here because it is unlikely\r\n        // that everyone will be able to agree on a standard. This is extremely limited right\r\n        // now and really only works for the way maven is versioned.\r\n\r\n        // releaseVersion = 1.0-beta-4\r\n        // snapshotVersion = 1.0-beta-5-SNAPSHOT\r\n\r\n        String nextVersionString = projectVersion.substring( projectVersion.lastIndexOf( \"-\" ) + 1 );\r\n\r\n        try\r\n        {\r\n            nextVersionString = Integer.toString( Integer.parseInt( nextVersionString ) + 1 );\r\n\r\n            projectVersion = projectVersion.substring( 0, projectVersion.lastIndexOf( \"-\" ) + 1 ) + nextVersionString + SNAPSHOT;\r\n        }\r\n        catch ( NumberFormatException e )\r\n        {\r\n            projectVersion = \"\";\r\n        }\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n\r\n            model.setVersion( projectVersion );\r\n\r\n            if ( model.getScm() != null )\r\n            {\r\n                model.getScm().setTag( currentTag );\r\n\r\n                model.getScm().setConnection( currentScmConnection );\r\n\r\n                model.getScm().setDeveloperConnection( currentScmDeveloperConnection );\r\n            }\r\n\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its snapshot version form.\", e );\r\n        }\r\n    }","commit_id":"d548066e3f9730fd435600929e4233c6f1f8a8e0","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void transformPomToReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        currentTag = model.getScm().getTag();\r\n\r\n        model.getScm().setTag( getTagLabel() );\r\n\r\n        try\r\n        {\r\n            Properties releaseProperties = new Properties();\r\n\r\n            releaseProperties.setProperty( \"version\", projectVersion );\r\n\r\n            releaseProperties.setProperty( USERNAME, username );\r\n\r\n            releaseProperties.setProperty( TAG, getTagLabel() );\r\n\r\n            releaseProperties.setProperty( SCM_URL, urlScm );\r\n\r\n            FileOutputStream os = new FileOutputStream( new File( project.getFile().getParentFile(), RELEASE_PROPS ) );\r\n\r\n            releaseProperties.store( os, \"maven release plugin info\" );\r\n\r\n            os.close();\r\n        }\r\n        catch ( IOException e )\r\n        {\r\n            throw new MojoExecutionException( \"Cannote write release-version file.\", e );\r\n        }\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its release version form.\", e );\r\n        }\r\n    }","id":9075,"modified_method":"private void transformPomToReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        currentTag = model.getScm().getTag();\r\n\r\n        currentScmConnection = model.getScm().getConnection();\r\n\r\n        currentScmDeveloperConnection = model.getScm().getDeveloperConnection();\r\n\r\n        if ( model.getScm() != null )\r\n        {\r\n            model.getScm().setTag( getTagLabel() );\r\n\r\n            model.getScm().setConnection( rewriteScmConnection( model.getScm().getConnection(), getTagLabel() ) );\r\n\r\n            model.getScm().setDeveloperConnection( rewriteScmConnection( model.getScm().getDeveloperConnection(),\r\n                                                                         getTagLabel() ) );\r\n        }\r\n\r\n        try\r\n        {\r\n            Properties releaseProperties = new Properties();\r\n\r\n            releaseProperties.setProperty( \"version\", projectVersion );\r\n\r\n            releaseProperties.setProperty( USERNAME, username );\r\n\r\n            releaseProperties.setProperty( TAG, getTagLabel() );\r\n\r\n            releaseProperties.setProperty( SCM_URL, urlScm );\r\n\r\n            FileOutputStream os = new FileOutputStream( new File( project.getFile().getParentFile(), RELEASE_PROPS ) );\r\n\r\n            releaseProperties.store( os, \"maven release plugin info\" );\r\n\r\n            os.close();\r\n        }\r\n        catch ( IOException e )\r\n        {\r\n            throw new MojoExecutionException( \"Cannote write release-version file.\", e );\r\n        }\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its release version form.\", e );\r\n        }\r\n    }","commit_id":"d548066e3f9730fd435600929e4233c6f1f8a8e0","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void transformNode( Node node )\r\n    {\r\n        if ( selectProjectNodeXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify project version\r\n            Element project = (Element) node;\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getUpdatedModel().getVersion() );\r\n            }\r\n            else\r\n            {\r\n                project.addElement( \"version\" ).addText( getUpdatedModel().getVersion() );\r\n            }\r\n        }\r\n        else if ( selectDependenciesNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify dependency version\r\n            Element dependency = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node type = node.selectSingleNode( \"type\" );\r\n\r\n            String typeText = \"jar\";\r\n\r\n            if ( type != null )\r\n            {\r\n                typeText = type.getText();\r\n            }\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getDependency( groupId.getText(), artifactId.getText(), typeText ).getVersion() );\r\n            }\r\n            else\r\n            {\r\n                dependency.addElement( \"version\" ).addText( getDependency( groupId.getText(), artifactId.getText(),\r\n                                                                           type.getText() ).getVersion() );\r\n            }\r\n        }\r\n        else if ( selectPluginsNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify plugin version\r\n            Element plugin = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            String groupIdText = \"org.apache.maven.plugins\";\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupIdText = groupId.getText();\r\n            }\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            Plugin p = getPlugin( groupIdText, artifactId.getText() );\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupId.setText( p.getGroupId() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"groupId\" ).addText( p.getGroupId() );\r\n            }\r\n            if ( version != null )\r\n            {\r\n                version.setText( p.getVersion() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"version\" ).addText( p.getVersion() );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // Modify scm tag\r\n            Element scm = (Element) node;\r\n\r\n            Node tag = node.selectSingleNode( \"tag\" );\r\n\r\n            if ( tag == null )\r\n            {\r\n                if ( !\"HEAD\".equals( getUpdatedModel().getScm().getTag() ) )\r\n                {\r\n                    scm.addElement( \"tag\" ).addText( getUpdatedModel().getScm().getTag() );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                tag.setText( getUpdatedModel().getScm().getTag() );\r\n            }\r\n        }\r\n    }","id":9076,"modified_method":"public void transformNode( Node node )\r\n    {\r\n        if ( selectProjectNodeXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify project version\r\n            Element project = (Element) node;\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getUpdatedModel().getVersion() );\r\n            }\r\n            else\r\n            {\r\n                project.addElement( \"version\" ).addText( getUpdatedModel().getVersion() );\r\n            }\r\n        }\r\n        else if ( selectDependenciesNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify dependency version\r\n            Element dependency = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node type = node.selectSingleNode( \"type\" );\r\n\r\n            String typeText = \"jar\";\r\n\r\n            if ( type != null )\r\n            {\r\n                typeText = type.getText();\r\n            }\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getDependency( groupId.getText(), artifactId.getText(), typeText ).getVersion() );\r\n            }\r\n            else\r\n            {\r\n                dependency.addElement( \"version\" ).addText( getDependency( groupId.getText(), artifactId.getText(),\r\n                                                                           type.getText() ).getVersion() );\r\n            }\r\n        }\r\n        else if ( selectPluginsNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify plugin version\r\n            Element plugin = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            String groupIdText = \"org.apache.maven.plugins\";\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupIdText = groupId.getText();\r\n            }\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            Plugin p = getPlugin( groupIdText, artifactId.getText() );\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupId.setText( p.getGroupId() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"groupId\" ).addText( p.getGroupId() );\r\n            }\r\n            if ( version != null )\r\n            {\r\n                version.setText( p.getVersion() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"version\" ).addText( p.getVersion() );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if ( getUpdatedModel().getScm() != null )\r\n            {\r\n                // Modify scm tag\r\n                Element scm = (Element) node;\r\n                \r\n                Node tag = node.selectSingleNode( \"tag\" );\r\n                \r\n                if ( tag == null )\r\n                {\r\n                    if ( !\"HEAD\".equals( getUpdatedModel().getScm().getTag() ) )\r\n                    {\r\n                        scm.addElement( \"tag\" ).addText( getUpdatedModel().getScm().getTag() );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    tag.setText( getUpdatedModel().getScm().getTag() );\r\n                }\r\n                \r\n                // Modify scmConnections\r\n                Node connection = node.selectSingleNode( \"connection\" );\r\n                \r\n                if ( connection != null )\r\n                {\r\n                    if ( !connection.getText().equals( getUpdatedModel().getScm().getConnection() ) )\r\n                    {\r\n                        connection.setText( getUpdatedModel().getScm().getConnection() );\r\n                    }\r\n                }\r\n                \r\n                Node developerConnection = node.selectSingleNode( \"developerConnection\" );\r\n                \r\n                if ( developerConnection != null )\r\n                {\r\n                    if ( !developerConnection.getText().equals( getUpdatedModel().getScm().getDeveloperConnection() ) )\r\n                    {\r\n                        developerConnection.setText( getUpdatedModel().getScm().getDeveloperConnection() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"d548066e3f9730fd435600929e4233c6f1f8a8e0","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void transformPomToReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        currentTag = model.getScm().getTag();\r\n\r\n        model.getScm().setTag( getTagLabel() );\r\n\r\n        try\r\n        {\r\n            Properties releaseProperties = new Properties();\r\n\r\n            releaseProperties.setProperty( \"version\", projectVersion );\r\n\r\n            releaseProperties.setProperty( USERNAME, username );\r\n\r\n            releaseProperties.setProperty( TAG, getTagLabel() );\r\n\r\n            releaseProperties.setProperty( SCM_URL, urlScm );\r\n\r\n            FileOutputStream os = new FileOutputStream( new File( project.getFile().getParentFile(), RELEASE_PROPS ) );\r\n\r\n            releaseProperties.store( os, \"maven release plugin info\" );\r\n\r\n            os.close();\r\n        }\r\n        catch ( IOException e )\r\n        {\r\n            throw new MojoExecutionException( \"Cannote write release-version file.\", e );\r\n        }\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its release version form.\", e );\r\n        }\r\n    }","id":9077,"modified_method":"private void transformPomToReleaseVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        if ( !isSnapshot( model.getVersion() ) )\r\n        {\r\n            throw new MojoExecutionException( \"This project isn't a snapshot (\" + model.getVersion() + \").\" );\r\n        }\r\n\r\n        //Rewrite project version\r\n        projectVersion = model.getVersion().substring( 0, model.getVersion().length() - SNAPSHOT.length() );\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't read user input.\", e );\r\n        }\r\n\r\n        model.setVersion( projectVersion );\r\n\r\n        currentTag = model.getScm().getTag();\r\n\r\n        currentScmConnection = model.getScm().getConnection();\r\n\r\n        currentScmDeveloperConnection = model.getScm().getDeveloperConnection();\r\n\r\n        if ( model.getScm() != null )\r\n        {\r\n            model.getScm().setTag( getTagLabel() );\r\n\r\n            model.getScm().setConnection( rewriteScmConnection( model.getScm().getConnection(), getTagLabel() ) );\r\n\r\n            model.getScm().setDeveloperConnection( rewriteScmConnection( model.getScm().getDeveloperConnection(),\r\n                                                                         getTagLabel() ) );\r\n        }\r\n\r\n        try\r\n        {\r\n            Properties releaseProperties = new Properties();\r\n\r\n            releaseProperties.setProperty( \"version\", projectVersion );\r\n\r\n            releaseProperties.setProperty( USERNAME, username );\r\n\r\n            releaseProperties.setProperty( TAG, getTagLabel() );\r\n\r\n            releaseProperties.setProperty( SCM_URL, urlScm );\r\n\r\n            FileOutputStream os = new FileOutputStream( new File( project.getFile().getParentFile(), RELEASE_PROPS ) );\r\n\r\n            releaseProperties.store( os, \"maven release plugin info\" );\r\n\r\n            os.close();\r\n        }\r\n        catch ( IOException e )\r\n        {\r\n            throw new MojoExecutionException( \"Cannote write release-version file.\", e );\r\n        }\r\n\r\n        //Rewrite parent version\r\n        if ( project.hasParent() )\r\n        {\r\n            if ( isSnapshot( project.getParentArtifact().getBaseVersion() ) )\r\n            {\r\n                model.getParent().setVersion( project.getParentArtifact().getVersion() );\r\n            }\r\n        }\r\n\r\n        //Rewrite dependencies version\r\n        for ( Iterator i = project.getArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getDependencies().iterator(); j.hasNext(); )\r\n                {\r\n                    Dependency dependency = (Dependency) j.next();\r\n                    if ( artifact.getGroupId().equals( dependency.getGroupId() )\r\n                        && artifact.getArtifactId().equals( dependency.getArtifactId() )\r\n                        && artifact.getBaseVersion().equals( dependency.getVersion() )\r\n                        && artifact.getType().equals( dependency.getType() ) )\r\n                    {\r\n                        dependency.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //Rewrite plugins version\r\n        for ( Iterator i = project.getPluginArtifacts().iterator(); i.hasNext(); )\r\n        {\r\n            Artifact artifact = (Artifact) i.next();\r\n            if ( isSnapshot( artifact.getBaseVersion() ) )\r\n            {\r\n                for ( Iterator j = model.getBuild().getPlugins().iterator(); j.hasNext(); )\r\n                {\r\n                    Plugin plugin = (Plugin) j.next();\r\n                    if ( artifact.getGroupId().equals( plugin.getGroupId() )\r\n                        && artifact.getArtifactId().equals( plugin.getArtifactId() ) )\r\n                    {\r\n                        plugin.setGroupId( artifact.getGroupId() );\r\n                        plugin.setVersion( artifact.getVersion() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its release version form.\", e );\r\n        }\r\n    }","commit_id":"f3346df4b8b81538bce02e59fecf5a1aa81885c5","url":"https://github.com/apache/maven"},{"original_method":"private void transformPomToSnapshotVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we will need to incorporate versioning strategies here because it is unlikely\r\n        // that everyone will be able to agree on a standard. This is extremely limited right\r\n        // now and really only works for the way maven is versioned.\r\n\r\n        // releaseVersion = 1.0-beta-4\r\n        // snapshotVersion = 1.0-beta-5-SNAPSHOT\r\n\r\n        String nextVersionString = projectVersion.substring( projectVersion.lastIndexOf( \"-\" ) + 1 );\r\n\r\n        try\r\n        {\r\n            nextVersionString = Integer.toString( Integer.parseInt( nextVersionString ) + 1 );\r\n\r\n            projectVersion = projectVersion.substring( 0, projectVersion.lastIndexOf( \"-\" ) + 1 ) + nextVersionString + SNAPSHOT;\r\n        }\r\n        catch ( NumberFormatException e )\r\n        {\r\n            projectVersion = \"\";\r\n        }\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n\r\n            model.setVersion( projectVersion );\r\n\r\n            model.getScm().setTag( currentTag );\r\n\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its snapshot version form.\", e );\r\n        }\r\n    }","id":9078,"modified_method":"private void transformPomToSnapshotVersionPom()\r\n        throws MojoExecutionException\r\n    {\r\n        // TODO: we will need to incorporate versioning strategies here because it is unlikely\r\n        // that everyone will be able to agree on a standard. This is extremely limited right\r\n        // now and really only works for the way maven is versioned.\r\n\r\n        // releaseVersion = 1.0-beta-4\r\n        // snapshotVersion = 1.0-beta-5-SNAPSHOT\r\n\r\n        String nextVersionString = projectVersion.substring( projectVersion.lastIndexOf( \"-\" ) + 1 );\r\n\r\n        try\r\n        {\r\n            nextVersionString = Integer.toString( Integer.parseInt( nextVersionString ) + 1 );\r\n\r\n            projectVersion = projectVersion.substring( 0, projectVersion.lastIndexOf( \"-\" ) + 1 ) + nextVersionString + SNAPSHOT;\r\n        }\r\n        catch ( NumberFormatException e )\r\n        {\r\n            projectVersion = \"\";\r\n        }\r\n\r\n        try\r\n        {\r\n            getLog().info( \"What is the new version? [\" + projectVersion + \"]\" );\r\n\r\n            InputHandler handler = (InputHandler) getContainer().lookup( InputHandler.ROLE );\r\n\r\n            String inputVersion = handler.readLine();\r\n\r\n            if ( !StringUtils.isEmpty( inputVersion ) )\r\n            {\r\n                projectVersion = inputVersion;\r\n            }\r\n\r\n            model.setVersion( projectVersion );\r\n\r\n            if ( model.getScm() != null )\r\n            {\r\n                model.getScm().setTag( currentTag );\r\n\r\n                model.getScm().setConnection( currentScmConnection );\r\n\r\n                model.getScm().setDeveloperConnection( currentScmDeveloperConnection );\r\n            }\r\n\r\n            PomTransformer transformer = new VersionTransformer();\r\n\r\n            transformer.setOutputFile( project.getFile() );\r\n\r\n            transformer.setProject( project.getFile() );\r\n\r\n            transformer.setUpdatedModel ( model );\r\n\r\n            transformer.transformNodes();\r\n\r\n            transformer.write();\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MojoExecutionException( \"Can't transform pom to its snapshot version form.\", e );\r\n        }\r\n    }","commit_id":"f3346df4b8b81538bce02e59fecf5a1aa81885c5","url":"https://github.com/apache/maven"},{"original_method":"public void transformNode( Node node )\r\n    {\r\n        if ( selectProjectNodeXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify project version\r\n            Element project = (Element) node;\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getUpdatedModel().getVersion() );\r\n            }\r\n            else\r\n            {\r\n                project.addElement( \"version\" ).addText( getUpdatedModel().getVersion() );\r\n            }\r\n        }\r\n        else if ( selectDependenciesNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify dependency version\r\n            Element dependency = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node type = node.selectSingleNode( \"type\" );\r\n\r\n            String typeText = \"jar\";\r\n\r\n            if ( type != null )\r\n            {\r\n                typeText = type.getText();\r\n            }\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getDependency( groupId.getText(), artifactId.getText(), typeText ).getVersion() );\r\n            }\r\n            else\r\n            {\r\n                dependency.addElement( \"version\" ).addText( getDependency( groupId.getText(), artifactId.getText(),\r\n                                                                           type.getText() ).getVersion() );\r\n            }\r\n        }\r\n        else if ( selectPluginsNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify plugin version\r\n            Element plugin = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            String groupIdText = \"org.apache.maven.plugins\";\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupIdText = groupId.getText();\r\n            }\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            Plugin p = getPlugin( groupIdText, artifactId.getText() );\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupId.setText( p.getGroupId() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"groupId\" ).addText( p.getGroupId() );\r\n            }\r\n            if ( version != null )\r\n            {\r\n                version.setText( p.getVersion() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"version\" ).addText( p.getVersion() );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // Modify scm tag\r\n            Element scm = (Element) node;\r\n\r\n            Node tag = node.selectSingleNode( \"tag\" );\r\n\r\n            if ( tag == null )\r\n            {\r\n                if ( !\"HEAD\".equals( getUpdatedModel().getScm().getTag() ) )\r\n                {\r\n                    scm.addElement( \"tag\" ).addText( getUpdatedModel().getScm().getTag() );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                tag.setText( getUpdatedModel().getScm().getTag() );\r\n            }\r\n        }\r\n    }","id":9079,"modified_method":"public void transformNode( Node node )\r\n    {\r\n        if ( selectProjectNodeXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify project version\r\n            Element project = (Element) node;\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getUpdatedModel().getVersion() );\r\n            }\r\n            else\r\n            {\r\n                project.addElement( \"version\" ).addText( getUpdatedModel().getVersion() );\r\n            }\r\n        }\r\n        else if ( selectDependenciesNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify dependency version\r\n            Element dependency = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node type = node.selectSingleNode( \"type\" );\r\n\r\n            String typeText = \"jar\";\r\n\r\n            if ( type != null )\r\n            {\r\n                typeText = type.getText();\r\n            }\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            if ( version != null )\r\n            {\r\n                version.setText( getDependency( groupId.getText(), artifactId.getText(), typeText ).getVersion() );\r\n            }\r\n            else\r\n            {\r\n                dependency.addElement( \"version\" ).addText( getDependency( groupId.getText(), artifactId.getText(),\r\n                                                                           type.getText() ).getVersion() );\r\n            }\r\n        }\r\n        else if ( selectPluginsNodesXPathExpression().equals( node.getPath() ) )\r\n        {\r\n            // Modify plugin version\r\n            Element plugin = (Element) node;\r\n\r\n            Node groupId = node.selectSingleNode( \"groupId\" );\r\n\r\n            String groupIdText = \"org.apache.maven.plugins\";\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupIdText = groupId.getText();\r\n            }\r\n\r\n            Node artifactId = node.selectSingleNode( \"artifactId\" );\r\n\r\n            Node version = node.selectSingleNode( \"version\" );\r\n\r\n            Plugin p = getPlugin( groupIdText, artifactId.getText() );\r\n\r\n            if ( groupId != null )\r\n            {\r\n                groupId.setText( p.getGroupId() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"groupId\" ).addText( p.getGroupId() );\r\n            }\r\n            if ( version != null )\r\n            {\r\n                version.setText( p.getVersion() );\r\n            }\r\n            else\r\n            {\r\n                plugin.addElement( \"version\" ).addText( p.getVersion() );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if ( getUpdatedModel().getScm() != null )\r\n            {\r\n                // Modify scm tag\r\n                Element scm = (Element) node;\r\n                \r\n                Node tag = node.selectSingleNode( \"tag\" );\r\n                \r\n                if ( tag == null )\r\n                {\r\n                    if ( !\"HEAD\".equals( getUpdatedModel().getScm().getTag() ) )\r\n                    {\r\n                        scm.addElement( \"tag\" ).addText( getUpdatedModel().getScm().getTag() );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    tag.setText( getUpdatedModel().getScm().getTag() );\r\n                }\r\n                \r\n                // Modify scmConnections\r\n                Node connection = node.selectSingleNode( \"connection\" );\r\n                \r\n                if ( connection != null )\r\n                {\r\n                    if ( !connection.getText().equals( getUpdatedModel().getScm().getConnection() ) )\r\n                    {\r\n                        connection.setText( getUpdatedModel().getScm().getConnection() );\r\n                    }\r\n                }\r\n                \r\n                Node developerConnection = node.selectSingleNode( \"developerConnection\" );\r\n                \r\n                if ( developerConnection != null )\r\n                {\r\n                    if ( !developerConnection.getText().equals( getUpdatedModel().getScm().getDeveloperConnection() ) )\r\n                    {\r\n                        developerConnection.setText( getUpdatedModel().getScm().getDeveloperConnection() );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"f3346df4b8b81538bce02e59fecf5a1aa81885c5","url":"https://github.com/apache/maven"},{"original_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp(TOKEN);\n    HELPER.dispose();\n    PerformanceMessenger.getInstance().report(\"auditErrors\", HELPER.getNumErrors());\n    PerformanceMessenger.getInstance().report(\"auditWarnings\", HELPER.getNumWarnings());\n    PerformanceMessenger.getInstance().generateReport();\n    System.out.println(HELPER.getNumErrors() + \" errors total\");\n    System.out.println(HELPER.getNumWarnings() + \" warnings total\");\n  }","id":9080,"modified_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp();\n    HELPER.dispose();\n    PerformanceMessenger.getInstance().report(\"auditErrors\", HELPER.getNumErrors());\n    PerformanceMessenger.getInstance().report(\"auditWarnings\", HELPER.getNumWarnings());\n    PerformanceMessenger.getInstance().generateReport();\n    System.out.println(HELPER.getNumErrors() + \" errors total\");\n    System.out.println(HELPER.getNumWarnings() + \" warnings total\");\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BeforeClass\n  public static void init() {\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n    List<IFile> files = new ArrayList<IFile>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      files.add(moduleHandle.getFile());\n    }\n    HELPER.load(files);\n  }","id":9081,"modified_method":"@BeforeClass\n  public static void init() {\n    CheckProjectStructureHelper.loadModules(ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false));\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(1)\n  public void checkTypeSystem() {\n    List<String> errors = HELPER.checkTypeSystem(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Type system errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9082,"modified_method":"@Test\n  @Order(1)\n  public void checkTypeSystem() {\n    List<String> errors = HELPER.checkTypeSystem(handle);\n    Assert.assertTrue(\"Type system errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Audit(String testName, IFile file) {\n    this.file = file;\n  }","id":9083,"modified_method":"public Audit(String testName, ModuleHandle handle) {\n    this.handle = handle;\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String getDescription(ModuleHandle handle) {\n    if (handle.getFile().getName().endsWith(\".mpl\")) {\n      return handle.getDescriptor().getNamespace() + \" [lang]\";\n    } else if (handle.getFile().getName().endsWith(\".msd\")) {\n      return handle.getDescriptor().getNamespace() + \" [solution]\";\n    }\n    return handle.getFile().getName();\n  }","id":9084,"modified_method":"private static String getDescription(ModuleHandle handle) {\n    if (handle.getFile().getName().endsWith(\".mpl\")) {\n      return handle.getDescriptor().getNamespace() + \" [lang]\";\n    } else if (handle.getFile().getName().endsWith(\".msd\")) {\n      return handle.getDescriptor().getNamespace() + \" [solution]\";\n    }\n    return handle.getFile().getName() + \" - \" + handle.getDescriptor().getNamespace();\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    TOKEN = HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle.getFile()});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","id":9085,"modified_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      if (moduleHandle.getFile().getName().endsWith(\".iml\")) {\n        // temporary ignore .iml files\n        continue;\n      }\n\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(3)\n  public void checkGenerationStatus() {\n    List<String> errors = HELPER.checkGenerationStatus(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Try to regenerate models:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9086,"modified_method":"@Test\n  @Order(3)\n  public void checkGenerationStatus() {\n    List<String> errors = HELPER.checkGenerationStatus(handle);\n    Assert.assertTrue(\"Try to regenerate models:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(1)\n  public void checkReferences() {\n    List<String> errors = HELPER.check(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Reference errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9087,"modified_method":"@Test\n  @Order(1)\n  public void checkReferences() {\n    List<String> errors = HELPER.check(handle);\n    Assert.assertTrue(\"Reference errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(2)\n  public void checkStructure() {\n    List<String> errors = HELPER.checkStructure(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Structure errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9088,"modified_method":"@Test\n  @Order(2)\n  public void checkStructure() {\n    List<String> errors = HELPER.checkStructure(handle);\n    Assert.assertTrue(\"Structure errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    TOKEN = HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle.getFile()});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","id":9089,"modified_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      if (moduleHandle.getFile().getName().endsWith(\".iml\")) {\n        // temporary ignore .iml files\n        continue;\n      }\n\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BeforeClass\n  public static void init() {\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n    List<IFile> files = new ArrayList<IFile>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      files.add(moduleHandle.getFile());\n    }\n\n    HELPER.load(files);\n  }","id":9090,"modified_method":"@BeforeClass\n  public static void init() {\n    CheckProjectStructureHelper.loadModules(ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false));\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp(TOKEN);\n    HELPER.dispose();\n  }","id":9091,"modified_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp();\n    HELPER.dispose();\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(4)\n  public void checkModuleProperties() {\n    List<String> errors = HELPER.checkModule(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Module property or dependency errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9092,"modified_method":"@Test\n  @Order(4)\n  public void checkModuleProperties() {\n    List<String> errors = HELPER.checkModule(handle);\n    Assert.assertTrue(\"Module property or dependency errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public CheckProjectStructure(String testName, IFile file) {\n    this.file = file;\n  }","id":9093,"modified_method":"public CheckProjectStructure(String testName, ModuleHandle handle) {\n    this.handle = handle;\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void dispose() {\n    TestMain.disposeMPS();\n    myModelsExtractor.clear();\n  }","id":9094,"modified_method":"public void dispose() {\n    TestMain.disposeMPS();\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void cleanUp(Token tok) {\n    ((PrivToken) tok).cleanUp();\n  }","id":9095,"modified_method":"public void cleanUp() {\n    doCleanUp(myProject);\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Token init(String[][] macros) {\n    BasicConfigurator.configure();\n    Logger.getRootLogger().setLevel(Level.INFO);\n    Testbench.initLogging();\n\n    IdeMain.setTestMode(TestMode.CORE_TEST);\n    TestMain.configureMPS(new String[0]);\n\n    for (String[] macro : macros) {\n      Testbench.setMacro(macro[0], macro[1]);\n    }\n    Testbench.initLibs();\n    Testbench.makeAll();\n    Testbench.reloadAll();\n\n    com.intellij.openapi.project.Project ideaProject = ProjectManager.getInstance().getDefaultProject();\n    File projectFile = FileUtil.createTmpFile();\n    StandaloneMPSProject project = new StandaloneMPSProject(ideaProject);\n    project.setProjectFile(projectFile);\n    project.init(new ProjectDescriptor());\n    myErrors = 0;\n    myWarnings = 0;\n    return new PrivToken(project);\n  }","id":9096,"modified_method":"public void init(String[][] macros) {\n    BasicConfigurator.configure();\n    Logger.getRootLogger().setLevel(Level.INFO);\n    Testbench.initLogging();\n\n    IdeMain.setTestMode(TestMode.CORE_TEST);\n    TestMain.configureMPS(new String[0]);\n\n    for (String[] macro : macros) {\n      Testbench.setMacro(macro[0], macro[1]);\n    }\n    Testbench.initLibs();\n    Testbench.makeAll();\n    Testbench.reloadAll();\n\n    com.intellij.openapi.project.Project ideaProject = ProjectManager.getInstance().getDefaultProject();\n    File projectFile = FileUtil.createTmpFile();\n    StandaloneMPSProject project = new StandaloneMPSProject(ideaProject);\n    project.setProjectFile(projectFile);\n    project.init(new ProjectDescriptor());\n    myErrors = 0;\n    myWarnings = 0;\n    myProject = project;\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelsExtractor(boolean includeDoNotGenerate) {\n    myIncludeDoNotGenerate = includeDoNotGenerate;\n  }","id":9097,"modified_method":"public ModelsExtractor(IModule module, boolean includeDoNotGenerate) {\n    myIncludeDoNotGenerate = includeDoNotGenerate;\n    extractModels(models, module);\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Iterable<SModelDescriptor> getModels() {\n    if (!modelLoaded) throw new IllegalStateException(\"Models not loaded\");\n    return models;\n  }","id":9098,"modified_method":"public Collection<SModelDescriptor> getModels() {\n    return models;\n  }","commit_id":"c4e5d715400e191a58885a72be51e3bed5aed138","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BeforeClass\n  public static void init() {\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n    List<IFile> files = new ArrayList<IFile>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      files.add(moduleHandle.getFile());\n    }\n    HELPER.load(files);\n  }","id":9099,"modified_method":"@BeforeClass\n  public static void init() {\n    CheckProjectStructureHelper.loadModules(ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false));\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(1)\n  public void checkTypeSystem() {\n    List<String> errors = HELPER.checkTypeSystem(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Type system errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9100,"modified_method":"@Test\n  @Order(1)\n  public void checkTypeSystem() {\n    List<String> errors = HELPER.checkTypeSystem(handle);\n    Assert.assertTrue(\"Type system errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static String getDescription(ModuleHandle handle) {\n    if (handle.getFile().getName().endsWith(\".mpl\")) {\n      return handle.getDescriptor().getNamespace() + \" [lang]\";\n    } else if (handle.getFile().getName().endsWith(\".msd\")) {\n      return handle.getDescriptor().getNamespace() + \" [solution]\";\n    }\n    return handle.getFile().getName();\n  }","id":9101,"modified_method":"private static String getDescription(ModuleHandle handle) {\n    if (handle.getFile().getName().endsWith(\".mpl\")) {\n      return handle.getDescriptor().getNamespace() + \" [lang]\";\n    } else if (handle.getFile().getName().endsWith(\".msd\")) {\n      return handle.getDescriptor().getNamespace() + \" [solution]\";\n    }\n    return handle.getFile().getName() + \" - \" + handle.getDescriptor().getNamespace();\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp(TOKEN);\n    HELPER.dispose();\n    PerformanceMessenger.getInstance().report(\"auditErrors\", HELPER.getNumErrors());\n    PerformanceMessenger.getInstance().report(\"auditWarnings\", HELPER.getNumWarnings());\n    PerformanceMessenger.getInstance().generateReport();\n    System.out.println(HELPER.getNumErrors() + \" errors total\");\n    System.out.println(HELPER.getNumWarnings() + \" warnings total\");\n  }","id":9102,"modified_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp();\n    HELPER.dispose();\n    PerformanceMessenger.getInstance().report(\"auditErrors\", HELPER.getNumErrors());\n    PerformanceMessenger.getInstance().report(\"auditWarnings\", HELPER.getNumWarnings());\n    PerformanceMessenger.getInstance().generateReport();\n    System.out.println(HELPER.getNumErrors() + \" errors total\");\n    System.out.println(HELPER.getNumWarnings() + \" warnings total\");\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Audit(String testName, IFile file) {\n    this.file = file;\n  }","id":9103,"modified_method":"public Audit(String testName, ModuleHandle handle) {\n    this.handle = handle;\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    TOKEN = HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle.getFile()});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","id":9104,"modified_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      if (moduleHandle.getFile().getName().endsWith(\".iml\")) {\n        // temporary ignore .iml files\n        continue;\n      }\n\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BeforeClass\n  public static void init() {\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n    List<IFile> files = new ArrayList<IFile>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      files.add(moduleHandle.getFile());\n    }\n\n    HELPER.load(files);\n  }","id":9105,"modified_method":"@BeforeClass\n  public static void init() {\n    CheckProjectStructureHelper.loadModules(ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false));\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(4)\n  public void checkModuleProperties() {\n    List<String> errors = HELPER.checkModule(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Module property or dependency errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9106,"modified_method":"@Test\n  @Order(4)\n  public void checkModuleProperties() {\n    List<String> errors = HELPER.checkModule(handle);\n    Assert.assertTrue(\"Module property or dependency errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(2)\n  public void checkStructure() {\n    List<String> errors = HELPER.checkStructure(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Structure errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9107,"modified_method":"@Test\n  @Order(2)\n  public void checkStructure() {\n    List<String> errors = HELPER.checkStructure(handle);\n    Assert.assertTrue(\"Structure errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp(TOKEN);\n    HELPER.dispose();\n  }","id":9108,"modified_method":"@AfterClass\n  public static void cleanUp() {\n    HELPER.cleanUp();\n    HELPER.dispose();\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(3)\n  public void checkGenerationStatus() {\n    List<String> errors = HELPER.checkGenerationStatus(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Try to regenerate models:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9109,"modified_method":"@Test\n  @Order(3)\n  public void checkGenerationStatus() {\n    List<String> errors = HELPER.checkGenerationStatus(handle);\n    Assert.assertTrue(\"Try to regenerate models:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    TOKEN = HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle.getFile()});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","id":9110,"modified_method":"@Parameters\n  public static List<Object[]> filePaths() {\n    HELPER = new CheckProjectStructureHelper();\n    HELPER.init(new String[][]{{\"samples_home\", System.getProperty(\"user.dir\") + \"/samples\"}});\n\n    List<ModuleHandle> moduleHandles = ModulesMiner.getInstance().collectModules(FileSystem.getInstance().getFileByPath(System.getProperty(\"user.dir\")), false);\n\n    ArrayList<Object[]> res = new ArrayList<Object[]>();\n    for (ModuleHandle moduleHandle : moduleHandles) {\n      if (moduleHandle.getFile().getName().endsWith(\".iml\")) {\n        // temporary ignore .iml files\n        continue;\n      }\n\n      res.add(new Object[]{getDescription(moduleHandle), moduleHandle});\n    }\n\n    Collections.sort(res, new Comparator<Object[]>() {\n      @Override\n      public int compare(Object[] o1, Object[] o2) {\n        return ((String) o1[0]).compareTo((String) o2[0]);\n      }\n    });\n    return res;\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public CheckProjectStructure(String testName, IFile file) {\n    this.file = file;\n  }","id":9111,"modified_method":"public CheckProjectStructure(String testName, ModuleHandle handle) {\n    this.handle = handle;\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  @Order(1)\n  public void checkReferences() {\n    List<String> errors = HELPER.check(TOKEN, Collections.singletonList(file));\n    Assert.assertTrue(\"Reference errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","id":9112,"modified_method":"@Test\n  @Order(1)\n  public void checkReferences() {\n    List<String> errors = HELPER.check(handle);\n    Assert.assertTrue(\"Reference errors:\\n\" + HELPER.formatErrors(errors), errors.isEmpty());\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void cleanUp(Token tok) {\n    ((PrivToken) tok).cleanUp();\n  }","id":9113,"modified_method":"public void cleanUp() {\n    doCleanUp(myProject);\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Token init(String[][] macros) {\n    BasicConfigurator.configure();\n    Logger.getRootLogger().setLevel(Level.INFO);\n    Testbench.initLogging();\n\n    IdeMain.setTestMode(TestMode.CORE_TEST);\n    TestMain.configureMPS(new String[0]);\n\n    for (String[] macro : macros) {\n      Testbench.setMacro(macro[0], macro[1]);\n    }\n    Testbench.initLibs();\n    Testbench.makeAll();\n    Testbench.reloadAll();\n\n    com.intellij.openapi.project.Project ideaProject = ProjectManager.getInstance().getDefaultProject();\n    File projectFile = FileUtil.createTmpFile();\n    StandaloneMPSProject project = new StandaloneMPSProject(ideaProject);\n    project.setProjectFile(projectFile);\n    project.init(new ProjectDescriptor());\n    myErrors = 0;\n    myWarnings = 0;\n    return new PrivToken(project);\n  }","id":9114,"modified_method":"public void init(String[][] macros) {\n    BasicConfigurator.configure();\n    Logger.getRootLogger().setLevel(Level.INFO);\n    Testbench.initLogging();\n\n    IdeMain.setTestMode(TestMode.CORE_TEST);\n    TestMain.configureMPS(new String[0]);\n\n    for (String[] macro : macros) {\n      Testbench.setMacro(macro[0], macro[1]);\n    }\n    Testbench.initLibs();\n    Testbench.makeAll();\n    Testbench.reloadAll();\n\n    com.intellij.openapi.project.Project ideaProject = ProjectManager.getInstance().getDefaultProject();\n    File projectFile = FileUtil.createTmpFile();\n    StandaloneMPSProject project = new StandaloneMPSProject(ideaProject);\n    project.setProjectFile(projectFile);\n    project.init(new ProjectDescriptor());\n    myErrors = 0;\n    myWarnings = 0;\n    myProject = project;\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void dispose() {\n    TestMain.disposeMPS();\n    myModelsExtractor.clear();\n  }","id":9115,"modified_method":"public void dispose() {\n    TestMain.disposeMPS();\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelsExtractor(boolean includeDoNotGenerate) {\n    myIncludeDoNotGenerate = includeDoNotGenerate;\n  }","id":9116,"modified_method":"public ModelsExtractor(IModule module, boolean includeDoNotGenerate) {\n    myIncludeDoNotGenerate = includeDoNotGenerate;\n    extractModels(models, module);\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Iterable<SModelDescriptor> getModels() {\n    if (!modelLoaded) throw new IllegalStateException(\"Models not loaded\");\n    return models;\n  }","id":9117,"modified_method":"public Collection<SModelDescriptor> getModels() {\n    return models;\n  }","commit_id":"a24253443adae88ea5ffae85aab0b96cd6199ca7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addCreateClauseForAttribute(EOAttribute attribute) {\n\t\t\tStringBuffer sql = new StringBuffer();\n\n\t\t\tsql.append(\"\\\"\");\n\t\t\tsql.append(attribute.columnName());\n\t\t\tsql.append(\"\\\" \");\n\t\t\tsql.append(columnTypeStringForAttribute(attribute));\n\n\t\t\tNSDictionary dictionary = attribute.userInfo();\n\t\t\tint internalType = internalTypeForExternal(attribute.externalType());\n\t\t\tboolean isLOB = internalType == FB_BLOB || internalType == FB_CLOB;\n\t\t\tif (dictionary == null) {\n\t\t\t\tif (!attribute.allowsNull()) {\n\t\t\t\t\tsql.append(\" NOT NULL\");\n\t\t\t\t\tif (isLOB)\n\t\t\t\t\t\tsql.append(\" DEFERRABLE INITIALLY DEFERRED\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Default values.\n\t\t\t\tif (dictionary.valueForKey(\"Default\") != null) {\n\t\t\t\t\tsql.append(\" DEFAULT \");\n\t\t\t\t\tsql.append(dictionary.valueForKey(\"Default\"));\n\t\t\t\t}\n\n\t\t\t\tif (dictionary.valueForKey(\"er.extensions.eoattribute.default\") != null) {\n\t\t\t\t\tsql.append(\" DEFAULT \");\n\t\t\t\t\tsql.append(formatValueForAttribute(dictionary.valueForKey(\"er.extensions.eoattribute.default\"), attribute));\n\t\t\t\t}\n\n\t\t\t\t// Column constraints.\n\t\t\t\tif (!attribute.allowsNull()) {\n\t\t\t\t\tsql.append(\" NOT NULL\");\n\t\t\t\t\tif (isLOB)\n\t\t\t\t\t\tsql.append(\" DEFERRABLE INITIALLY DEFERRED\");\n\t\t\t\t}\n\t\t\t\tif (dictionary.valueForKey(\"Unique\") != null && dictionary.valueForKey(\"Unique\").equals(\"true\")) {\n\t\t\t\t\tsql.append(\" UNIQUE\");\n\t\t\t\t}\n\t\t\t\tif (dictionary.valueForKey(\"Check\") != null) {\n\t\t\t\t\tsql.append(\" CHECK \");\n\t\t\t\t\tsql.append(dictionary.valueForKey(\"Check\"));\n\t\t\t\t}\n\t\n\t\t\t\t// Column collation.\n\t\t\t\tif (dictionary.valueForKey(\"Collate\") != null) {\n\t\t\t\t\tsql.append(\" COLLATE \");\n\t\t\t\t\tsql.append(dictionary.valueForKey(\"Collate\"));\n\t\t\t\t}\n\t\t\t}\n\t\t    appendItemToListString(sql.toString(), _listString());\n\t\t}","id":9118,"modified_method":"public void addCreateClauseForAttribute(EOAttribute attribute) {\n\t\t\tStringBuffer sql = new StringBuffer();\n\n\t\t\tsql.append(\"\\\"\");\n\t\t\tsql.append(attribute.columnName());\n\t\t\tsql.append(\"\\\" \");\n\t\t\tsql.append(columnTypeStringForAttribute(attribute));\n\n\t\t\tNSDictionary dictionary = attribute.userInfo();\n\t\t\tint internalType = internalTypeForExternal(attribute.externalType());\n\t\t\tboolean isLOB = internalType == FB_BLOB || internalType == FB_CLOB;\n\t\t\tif (dictionary == null) {\n\t\t\t\t_appendNotNullConstraintIfNecessary(attribute, sql);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Default values.\n\t\t\t\tif (dictionary.valueForKey(\"Default\") != null) {\n\t\t\t\t\tsql.append(\" DEFAULT \");\n\t\t\t\t\tsql.append(dictionary.valueForKey(\"Default\"));\n\t\t\t\t}\n\n\t\t\t\tif (dictionary.valueForKey(\"er.extensions.eoattribute.default\") != null) {\n\t\t\t\t\tsql.append(\" DEFAULT \");\n\t\t\t\t\tsql.append(formatValueForAttribute(dictionary.valueForKey(\"er.extensions.eoattribute.default\"), attribute));\n\t\t\t\t}\n\n\t\t\t\t// Column constraints.\n\t\t\t\t_appendNotNullConstraintIfNecessary(attribute, sql);\n\n\t\t\t\tif (dictionary.valueForKey(\"Unique\") != null && dictionary.valueForKey(\"Unique\").equals(\"true\")) {\n\t\t\t\t\tsql.append(\" UNIQUE\");\n\t\t\t\t}\n\t\t\t\tif (dictionary.valueForKey(\"Check\") != null) {\n\t\t\t\t\tsql.append(\" CHECK \");\n\t\t\t\t\tsql.append(dictionary.valueForKey(\"Check\"));\n\t\t\t\t}\n\t\n\t\t\t\t// Column collation.\n\t\t\t\tif (dictionary.valueForKey(\"Collate\") != null) {\n\t\t\t\t\tsql.append(\" COLLATE \");\n\t\t\t\t\tsql.append(dictionary.valueForKey(\"Collate\"));\n\t\t\t\t}\n\t\t\t}\n\t\t    appendItemToListString(sql.toString(), _listString());\n\t\t}","commit_id":"8737c525a846a492e6885e7aef7714cb98b0cd65","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray primaryKeyConstraintStatementsForEntityGroup(NSArray entityGroup) {\n\t\t\tif (entityGroup.count() != 0) {\n\t\t\t\tEOEntity entity = (EOEntity) entityGroup.objectAtIndex(0);\n\t\t\t\tString tableName = entity.externalName().toUpperCase();\n\t\t\t\tNSArray keys = entity.primaryKeyAttributeNames();\n\t\t\t\tStringBuffer sql = new StringBuffer();\n\n\t\t\t\tif (tableName != null && keys.count() > 0) {\n\t\t\t\t\tsql.append(\"ALTER TABLE \");\n\t\t\t\t\tsql.append(quoteTableName(tableName));\n\t\t\t\t\tsql.append(\" ADD PRIMARY KEY (\");\n\n\t\t\t\t\tfor (int j = 0; j < keys.count(); j++) {\n\t\t\t\t\t\tif (j != 0)\n\t\t\t\t\t\t\tsql.append(\",\");\n\n\t\t\t\t\t\tsql.append(\"\\\"\");\n\t\t\t\t\t\tsql.append(entity.attributeNamed((String) keys.objectAtIndex(j)).columnName().toUpperCase());\n\t\t\t\t\t\tsql.append(\"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t\tsql.append(\") NOT DEFERRABLE INITIALLY IMMEDIATE\");\n\n\t\t\t\t\treturn new NSArray(_expressionForString(sql.toString()));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NSArray.EmptyArray;\n\t\t}","id":9119,"modified_method":"public NSArray primaryKeyConstraintStatementsForEntityGroup(NSArray entityGroup) {\n\t\t\tif (entityGroup.count() != 0) {\n\t\t\t\tEOEntity entity = (EOEntity) entityGroup.objectAtIndex(0);\n\t\t\t\tString tableName = entity.externalName();\n\t\t\t\tNSArray keys = entity.primaryKeyAttributeNames();\n\t\t\t\tStringBuffer sql = new StringBuffer();\n\n\t\t\t\tif (tableName != null && keys.count() > 0) {\n\t\t\t\t\tsql.append(\"ALTER TABLE \");\n\t\t\t\t\tsql.append(quoteTableName(tableName.toUpperCase()));\n\t\t\t\t\tsql.append(\" ADD\");\n\t\t\t\t\t\n\t\t\t\t\tStringBuffer constraint = new StringBuffer(\" CONSTRAINT PRIMARY_KEY_\");\n\t\t\t\t\tconstraint.append(tableName);\n\n\t\t\t\t\tStringBuffer pkSql = new StringBuffer(\" PRIMARY KEY (\");\n\n\t\t\t\t\tfor (int j = 0; j < keys.count(); j++) {\n\t\t\t\t\t\tconstraint.append(\"_\");\n\t\t\t\t\t\tif (j != 0)\n\t\t\t\t\t\t\tpkSql.append(\",\");\n\n\t\t\t\t\t\tpkSql.append(\"\\\"\");\n\t\t\t\t\t\tString columnName = entity.attributeNamed((String) keys.objectAtIndex(j)).columnName();\n\t\t\t\t\t\tpkSql.append(columnName.toUpperCase());\n\t\t\t\t\t\tpkSql.append(\"\\\"\");\n\t\t\t\t\t\tconstraint.append(columnName);\n\t\t\t\t\t}\n\t\t\t\t\tpkSql.append(\") NOT DEFERRABLE INITIALLY IMMEDIATE\");\n\n\t\t\t\t\tif(USE_NAMED_CONSTRAINTS)\n\t\t\t\t\t\tsql.append(constraint);\n\t\t\t\t\tsql.append(pkSql);\n\t\t\t\t\t\n\t\t\t\t\treturn new NSArray(_expressionForString(sql.toString()));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NSArray.EmptyArray;\n\t\t}","commit_id":"8737c525a846a492e6885e7aef7714cb98b0cd65","url":"https://github.com/wocommunity/wonder"},{"original_method":"public NSArray foreignKeyConstraintStatementsForRelationship(EORelationship relationship) {\n\t\t\tif (!relationship.isToMany() && isPrimaryKeyAttributes(relationship.destinationEntity(), relationship.destinationAttributes())) {\n\t\t\t\tStringBuffer sql = new StringBuffer();\n\n\t\t\t\tsql.append(\"ALTER TABLE \");\n\t\t\t\tsql.append(quoteTableName(relationship.entity().externalName().toUpperCase()));\n\t\t\t\tsql.append(\" ADD FOREIGN KEY (\");\n\n\t\t\t\tNSArray attributes = relationship.sourceAttributes();\n\n\t\t\t\tfor (int i = 0; i < attributes.count(); i++) {\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tsql.append(\", \");\n\n\t\t\t\t\tsql.append(\"\\\"\");\n\t\t\t\t\tsql.append(((EOAttribute) attributes.objectAtIndex(i)).columnName().toUpperCase());\n\t\t\t\t\tsql.append(\"\\\"\");\n\t\t\t\t}\n\n\t\t\t\tsql.append(\") REFERENCES \");\n\t\t\t\tsql.append(quoteTableName(relationship.destinationEntity().externalName().toUpperCase()));\n\t\t\t\tsql.append(\" (\");\n\n\t\t\t\tattributes = relationship.destinationAttributes();\n\n\t\t\t\tfor (int i = 0; i < attributes.count(); i++) {\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t\tsql.append(\", \");\n\n\t\t\t\t\tsql.append(\"\\\"\");\n\t\t\t\t\tsql.append(((EOAttribute) attributes.objectAtIndex(i)).columnName().toUpperCase());\n\t\t\t\t\tsql.append(\"\\\"\");\n\t\t\t\t}\n\n\t\t\t\tsql.append(\") DEFERRABLE INITIALLY DEFERRED\");\n\n\t\t\t\treturn new NSArray(_expressionForString(sql.toString()));\n\t\t\t}\n\t\t\treturn NSArray.EmptyArray;\n\t\t}","id":9120,"modified_method":"public NSArray foreignKeyConstraintStatementsForRelationship(EORelationship relationship) {\n\t\t\tif (!relationship.isToMany() && isPrimaryKeyAttributes(relationship.destinationEntity(), relationship.destinationAttributes())) {\n\t\t\t\tStringBuffer sql = new StringBuffer();\n\t\t\t\tString tableName = relationship.entity().externalName();\n\n\t\t\t\tsql.append(\"ALTER TABLE \");\n\t\t\t\tsql.append(quoteTableName(tableName.toUpperCase()));\n\t\t\t\tsql.append(\" ADD\");\n\n\t\t\t\tStringBuffer constraint = new StringBuffer(\" CONSTRAINT FOREIGN_KEY_\");\n\t\t\t\tconstraint.append(tableName);\n\t\t\t\t\n\t\t\t\tStringBuffer fkSql = new StringBuffer(\" FOREIGN KEY (\");\n\t\t\t\tNSArray attributes = relationship.sourceAttributes();\n\n\t\t\t\tfor (int i = 0; i < attributes.count(); i++) {\n\t\t\t\t\tconstraint.append(\"_\");\n\t\t\t\t\tif (i != 0) \n\t\t\t\t\t\tfkSql.append(\", \");\n\n\t\t\t\t\tfkSql.append(\"\\\"\");\n\t\t\t\t\tString columnName = ((EOAttribute) attributes.objectAtIndex(i)).columnName();\n\t\t\t\t\tfkSql.append(columnName.toUpperCase());\n\t\t\t\t\tconstraint.append(columnName);\n\t\t\t\t\tfkSql.append(\"\\\"\");\n\t\t\t\t}\n\n\t\t\t\tfkSql.append(\") REFERENCES \");\n\t\t\t\tconstraint.append(\"_\");\n\t\t\t\t\n\t\t\t\tString referencedExternalName = relationship.destinationEntity().externalName();\n\t\t\t\tfkSql.append(quoteTableName(referencedExternalName.toUpperCase()));\n\t\t\t\tconstraint.append(referencedExternalName);\n\t\t\t\t\n\t\t\t\tfkSql.append(\" (\");\n\n\t\t\t\tattributes = relationship.destinationAttributes();\n\n\t\t\t\tfor (int i = 0; i < attributes.count(); i++) {\n\t\t\t\t\tconstraint.append(\"_\");\n\t\t\t\t\tif (i != 0) \n\t\t\t\t\t\tfkSql.append(\", \");\n\n\t\t\t\t\tfkSql.append(\"\\\"\");\n\t\t\t\t\tString referencedColumnName = ((EOAttribute) attributes.objectAtIndex(i)).columnName();\n\t\t\t\t\tfkSql.append(referencedColumnName.toUpperCase());\n\t\t\t\t\tconstraint.append(referencedColumnName);\n\t\t\t\t\tfkSql.append(\"\\\"\");\n\t\t\t\t}\n\n\t\t\t\tfkSql.append(\") DEFERRABLE INITIALLY DEFERRED\");\n\n\t\t\t\tif(USE_NAMED_CONSTRAINTS)\n\t\t\t\t\tsql.append(constraint);\n\t\t\t\tsql.append(fkSql);\n\t\t\t\t\n\t\t\t\treturn new NSArray(_expressionForString(sql.toString()));\n\t\t\t}\n\t\t\treturn NSArray.EmptyArray;\n\t\t}","commit_id":"8737c525a846a492e6885e7aef7714cb98b0cd65","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public EnterpriseAuthManager newInstance( Config config, LogProvider logProvider, Log allegedSecurityLog,\n            FileSystemAbstraction fileSystem, JobScheduler jobScheduler )\n    {\n//        StaticLoggerBinder.setNeo4jLogProvider( logProvider );\n\n        List<Realm> realms = new ArrayList<>( 2 );\n        SecurityLog securityLog = getSecurityLog( allegedSecurityLog );\n\n        // We always create the internal realm as it is our only UserManager implementation\n        InternalFlatFileRealm internalRealm = createInternalRealm( config, logProvider, fileSystem, jobScheduler );\n\n        if ( config.get( SecuritySettings.internal_authentication_enabled ) ||\n             config.get( SecuritySettings.internal_authorization_enabled ) )\n        {\n            realms.add( internalRealm );\n        }\n\n        if ( config.get( SecuritySettings.ldap_authentication_enabled ) ||\n             config.get( SecuritySettings.ldap_authorization_enabled ) )\n        {\n            realms.add( new LdapRealm( config, securityLog ) );\n        }\n\n        Boolean pluginAuthenticationEnabled = config.get( SecuritySettings.plugin_authentication_enabled );\n        Boolean pluginAuthorizationEnabled = config.get( SecuritySettings.plugin_authorization_enabled );\n\n        if ( pluginAuthenticationEnabled && pluginAuthorizationEnabled )\n        {\n            // Combined authentication and authorization plugins\n            Iterable<AuthPlugin> authPlugins = Service.load( AuthPlugin.class );\n\n            for ( AuthPlugin plugin : authPlugins )\n            {\n                PluginRealm pluginRealm = new PluginRealm( plugin );\n                realms.add( pluginRealm );\n            }\n        }\n\n        if ( pluginAuthenticationEnabled )\n        {\n            // Authentication only plugins\n            Iterable<AuthenticationPlugin> authenticationPlugins = Service.load( AuthenticationPlugin.class );\n\n            for ( AuthenticationPlugin plugin : authenticationPlugins )\n            {\n                PluginRealm pluginRealm = new PluginRealm( plugin, null );\n                realms.add( pluginRealm );\n            }\n        }\n\n        if ( pluginAuthorizationEnabled )\n        {\n            // Authorization only plugins\n            Iterable<AuthorizationPlugin> authorizationPlugins = Service.load( AuthorizationPlugin.class );\n\n            for ( AuthorizationPlugin plugin : authorizationPlugins )\n            {\n                PluginRealm pluginRealm = new PluginRealm( null, plugin );\n                realms.add( pluginRealm );\n            }\n        }\n\n        long ttl = config.get( SecuritySettings.auth_cache_ttl );\n        int maxCapacity = config.get( SecuritySettings.auth_cache_max_capacity );\n\n        return new MultiRealmAuthManager( internalRealm, realms,\n                new ShiroCaffeineCache.Manager( Ticker.systemTicker(), ttl, maxCapacity ),\n                securityLog, config.get( EnterpriseEditionSettings.security_log_successful_authentication ) );\n    }","id":9121,"modified_method":"@Override\n    public EnterpriseAuthManager newInstance( Config config, LogProvider logProvider, Log allegedSecurityLog,\n            FileSystemAbstraction fileSystem, JobScheduler jobScheduler )\n    {\n//        StaticLoggerBinder.setNeo4jLogProvider( logProvider );\n\n        List<Realm> realms = new ArrayList<>( 2 );\n        SecurityLog securityLog = getSecurityLog( allegedSecurityLog );\n\n        // We always create the internal realm as it is our only UserManager implementation\n        InternalFlatFileRealm internalRealm = createInternalRealm( config, logProvider, fileSystem, jobScheduler );\n\n        if ( config.get( SecuritySettings.internal_authentication_enabled ) ||\n             config.get( SecuritySettings.internal_authorization_enabled ) )\n        {\n            realms.add( internalRealm );\n        }\n\n        if ( config.get( SecuritySettings.ldap_authentication_enabled ) ||\n             config.get( SecuritySettings.ldap_authorization_enabled ) )\n        {\n            realms.add( new LdapRealm( config, securityLog ) );\n        }\n\n        // Load plugin realms if we have any\n        realms.addAll( createPluginRealms( config, logProvider ) );\n\n        return new MultiRealmAuthManager( internalRealm, realms, createCacheManager( config ),\n                securityLog, config.get( EnterpriseEditionSettings.security_log_successful_authentication ) );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void assertAuth( String username, String password ) throws Exception\n    {\n        assertAuth( username, password, null );\n    }","id":9122,"modified_method":"protected void assertAuth( String username, String password ) throws Exception\n    {\n        assertConnectionSucceeds( authToken( username, password, null ) );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void assertAuth( String username, String password, String realm ) throws Exception\n    {\n        client.connect( address )\n                .send( TransportTestUtil.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( TransportTestUtil.chunk( init( \"TestClient/1.1\", authToken( username, password, realm ) ) ) );\n\n        assertThat( client, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( client, eventuallyReceives( msgSuccess() ) );\n    }","id":9123,"modified_method":"protected void assertAuth( String username, String password, String realm ) throws Exception\n    {\n        assertConnectionSucceeds( authToken( username, password, realm ) );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void testAuthWithReaderUser( String username, String realm ) throws Exception\n    {\n        // When\n        assertAuth( username, \"abc123\", realm );\n\n        // When\n        client.send( TransportTestUtil.chunk(\n                run( \"MATCH (n) RETURN n\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( client, eventuallyReceives( msgSuccess(), msgSuccess() ) );\n\n        // When\n        client.send( TransportTestUtil.chunk(\n                run( \"CREATE ()\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( client, eventuallyReceives(\n                msgFailure( Status.Security.Forbidden,\n                        String.format( \"Write operations are not allowed for '\" + username + \"'.\" ) ) ) );\n    }","id":9124,"modified_method":"protected void testAuthWithReaderUser( String username, String realm ) throws Exception\n    {\n        assertAuth( username, \"abc123\", realm );\n        assertReadSucceeds();\n        assertWriteFails( username );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void testAuthWithNoPermissionUser( String username ) throws Exception\n    {\n        // When\n        assertAuth( username, \"abc123\" );\n\n        // When\n        client.send( TransportTestUtil.chunk(\n                run( \"MATCH (n) RETURN n\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( client, eventuallyReceives(\n                msgFailure( Status.Security.Forbidden,\n                        String.format( \"Read operations are not allowed for '%s'.\", username ) ) ) );\n    }","id":9125,"modified_method":"protected void testAuthWithNoPermissionUser( String username ) throws Exception\n    {\n        assertAuth( username, \"abc123\" );\n        assertReadFails( username );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void testAuthWithPublisherUser( String username, String realm ) throws Exception\n    {\n        // When\n        assertAuth( username, \"abc123\", realm );\n\n        // When\n        client.send( TransportTestUtil.chunk(\n                run( \"CREATE ()\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( client, eventuallyReceives( msgSuccess(), msgSuccess() ) );\n    }","id":9126,"modified_method":"protected void testAuthWithPublisherUser( String username, String realm ) throws Exception\n    {\n        assertAuth( username, \"abc123\", realm );\n        assertWriteSucceeds();\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void assertAuthFail( String username, String password ) throws Exception\n    {\n        client.connect( address )\n                .send( TransportTestUtil.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( TransportTestUtil.chunk(\n                        init( \"TestClient/1.1\", map( \"principal\", username,\n                                \"credentials\", password, \"scheme\", \"basic\" ) ) ) );\n\n        assertThat( client, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( client, eventuallyReceives( msgFailure( Status.Security.Unauthorized,\n                \"The client is unauthorized due to authentication failure.\" ) ) );\n    }","id":9127,"modified_method":"protected void assertAuthFail( String username, String password ) throws Exception\n    {\n        assertConnectionFails( map( \"principal\", username, \"credentials\", password, \"scheme\", \"basic\" ) );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToLoginWithLdapWhenSelectingRealmFromClient() throws Throwable\n    {\n        //--------------------------\n        // When we have a native 'tank' that is read only, and ldap 'tank' that is publisher\n        testCreateReaderUser(\"tank\");\n\n        //--------------------------\n        // Then native \"tank\" is reader\n        reconnect();\n        testAuthWithReaderUser(\"tank\", \"native\");\n\n        //--------------------------\n        // And ldap \"tank\" is publisher\n        reconnect();\n        testAuthWithPublisherUser(\"tank\", \"ldap\");\n    }","id":9128,"modified_method":"@Test\n    public void shouldBeAbleToLoginWithLdapWhenSelectingRealmFromClient() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings -> {\n            settings.put( SecuritySettings.internal_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.internal_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n        } );\n\n        //--------------------------\n        // When we have a native 'tank' that is read only, and ldap 'tank' that is publisher\n        testCreateReaderUser(\"tank\");\n\n        //--------------------------\n        // Then native \"tank\" is reader\n        reconnect();\n        testAuthWithReaderUser(\"tank\", \"native\");\n\n        //--------------------------\n        // And ldap \"tank\" is publisher\n        reconnect();\n        testAuthWithPublisherUser(\"tank\", \"ldap\");\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAuthenticateAndAuthorizeWithTestAuthPlugin() throws Throwable\n    {\n        // When\n        client.connect( address )\n                .send( TransportTestUtil.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( TransportTestUtil.chunk(\n                        init( \"TestClient/1.1\",\n                                map( \"principal\", \"neo4j\", \"credentials\", \"neo4j\", \"scheme\", \"basic\", \"realm\", \"TestAuthPlugin\" ) ) ) );\n\n        // Then\n        assertThat( client, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( client, eventuallyReceives( msgSuccess() ) );\n\n\n        // When\n        client.send( TransportTestUtil.chunk(\n                run( \"MATCH (n) RETURN n\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( client, eventuallyReceives( msgSuccess(), msgSuccess() ) );\n\n        // When\n        client.send( TransportTestUtil.chunk(\n                run( \"CREATE ()\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( client, eventuallyReceives(\n                msgFailure( Status.Security.Forbidden,\n                        String.format( \"Write operations are not allowed\" ) ) ) );\n\n    }","id":9129,"modified_method":"@Test\n    public void shouldAuthenticateAndAuthorizeWithTestAuthPlugin() throws Throwable\n    {\n        assertConnectionSucceeds(\n                map( \"principal\", \"neo4j\", \"credentials\", \"neo4j\", \"scheme\", \"basic\", \"realm\", \"TestAuthPlugin\" ) );\n        assertReadSucceeds();\n        assertWriteFails( \"neo4j\" );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAuthenticateWithTestAuthenticationPlugin() throws Throwable\n    {\n        // When\n        client.connect( address )\n                .send( TransportTestUtil.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( TransportTestUtil.chunk(\n                        init( \"TestClient/1.1\",\n                                map( \"principal\", \"neo4j\", \"credentials\", \"neo4j\", \"scheme\", \"basic\", \"realm\", \"TestAuthenticationPlugin\" ) ) ) );\n\n        // Then\n        assertThat( client, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( client, eventuallyReceives( msgSuccess() ) );\n    }","id":9130,"modified_method":"@Test\n    public void shouldAuthenticateWithTestAuthenticationPlugin() throws Throwable\n    {\n        assertConnectionSucceeds( map( \"principal\", \"neo4j\", \"credentials\", \"neo4j\", \"scheme\", \"basic\", \"realm\",\n                \"TestAuthenticationPlugin\" ) );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public PluginRealm( AuthenticationPlugin authenticationPlugin, AuthorizationPlugin authorizationPlugin )\n    {\n        this();\n        this.authenticationPlugin = authenticationPlugin;\n        this.authorizationPlugin = authorizationPlugin;\n    }","id":9131,"modified_method":"public PluginRealm( AuthenticationPlugin authenticationPlugin, AuthorizationPlugin authorizationPlugin,\n            LogProvider logProvider )\n    {\n        this( logProvider );\n        this.authenticationPlugin = authenticationPlugin;\n        this.authorizationPlugin = authorizationPlugin;\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public PluginRealm( AuthPlugin authPlugin )\n    {\n        this();\n        this.authPlugin = authPlugin;\n    }","id":9132,"modified_method":"public PluginRealm( AuthPlugin authPlugin, LogProvider logProvider )\n    {\n        this( logProvider );\n        this.authPlugin = authPlugin;\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public PluginRealm()\n    {\n        super();\n        setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        setAuthenticationCachingEnabled( true );\n        setAuthorizationCachingEnabled( true );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n    }","id":9133,"modified_method":"public PluginRealm( LogProvider logProvider )\n    {\n        setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        setAuthenticationCachingEnabled( true );\n        setAuthorizationCachingEnabled( true );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n        log = logProvider.getLog( getClass() );\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public AuthorizationInfo getAuthorizationInfo( Collection<Object> principals )\n    {\n        return null;\n    }","id":9134,"modified_method":"@Override\n    public AuthorizationInfo getAuthorizationInfo( Collection<Object> principals )\n    {\n        if ( principals.contains( \"neo4j\" ) )\n        {\n            return (AuthorizationInfo) () -> Collections.singleton( PredefinedRoles.READER );\n        }\n        return null;\n    }","commit_id":"cad8ca1889e7fb068034c91197b38e7cc8d841d2","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> buildCache(final PsiClass aClass, final boolean includeSynthetic) {\n    return CachedValuesManager.getManager(aClass.getProject()).createCachedValue(new CachedValueProvider<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>>() {\n      public Result<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> compute() {\n        Map<String, CandidateInfo> allFields = new HashMap<String, CandidateInfo>();\n        Map<String, List<CandidateInfo>> allMethods = new HashMap<String, List<CandidateInfo>>();\n        Map<String, CandidateInfo> allInnerClasses = new HashMap<String, CandidateInfo>();\n\n        processClass(aClass, allFields, allMethods, allInnerClasses, new HashSet<PsiClass>(), PsiSubstitutor.EMPTY, includeSynthetic);\n        return Result.create(new Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>(allFields, allMethods, allInnerClasses), PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT);\n      }\n    }, false);\n  }","id":9135,"modified_method":"private static CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> buildCache(final PsiClass aClass, final boolean includeSynthetic) {\n    return CachedValuesManager.getManager(aClass.getProject()).createCachedValue(new CachedValueProvider<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>>() {\n      public Result<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> compute() {\n        Map<String, CandidateInfo> allFields = new HashMap<String, CandidateInfo>();\n        Map<String, List<CandidateInfo>> allMethods = new HashMap<String, List<CandidateInfo>>();\n        Map<String, CandidateInfo> allInnerClasses = new HashMap<String, CandidateInfo>();\n\n        processClass(aClass, allFields, allMethods, allInnerClasses, new HashSet<PsiClass>(), PsiSubstitutor.EMPTY, includeSynthetic);\n        return Result.create(Trinity.create(allFields, allMethods, allInnerClasses), PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT);\n      }\n    }, false);\n  }","commit_id":"76c3ac5bdf67d55b366ac9521cbb04bbe693a8ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Map<String, CandidateInfo> getAllInnerClasses(final PsiClass aClass, boolean includeSynthetic) {\n    Key<CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>>> key = includeSynthetic ?\n        CACHED_MEMBERS_INCLUDING_SYNTHETIC : CACHED_MEMBERS;\n    CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> cachedValue = aClass.getUserData(key);\n    if (cachedValue == null) {\n      cachedValue = buildCache(aClass, includeSynthetic);\n    }\n\n    Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>> value = cachedValue.getValue();\n    assert value != null;\n    return value.getThird();\n  }","id":9136,"modified_method":"public static Map<String, CandidateInfo> getAllInnerClasses(final PsiClass aClass, boolean includeSynthetic) {\n    return getCachedMembers(aClass, includeSynthetic).getThird();\n  }","commit_id":"76c3ac5bdf67d55b366ac9521cbb04bbe693a8ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Map<String, List<CandidateInfo>> getAllMethods(final PsiClass aClass, boolean includeSynthetic) {\n    Key<CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>>> key = includeSynthetic ?\n        CACHED_MEMBERS_INCLUDING_SYNTHETIC : CACHED_MEMBERS;\n    CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> cachedValue = aClass.getUserData(key);\n    if (cachedValue == null) {\n      cachedValue = buildCache(aClass, includeSynthetic);\n    }\n\n    Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>> value = cachedValue.getValue();\n    assert value != null;\n    return value.getSecond();\n  }","id":9137,"modified_method":"public static Map<String, List<CandidateInfo>> getAllMethods(final PsiClass aClass, boolean includeSynthetic) {\n    return getCachedMembers(aClass, includeSynthetic).getSecond();\n  }","commit_id":"76c3ac5bdf67d55b366ac9521cbb04bbe693a8ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Map<String, CandidateInfo> getAllFields(final PsiClass aClass) {\n    CachedValue<Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>>> cachedValue = aClass.getUserData(CACHED_MEMBERS);\n    if (cachedValue == null) {\n      cachedValue = buildCache(aClass, false);\n    }\n\n    Trinity<Map<String, CandidateInfo>, Map<String, List<CandidateInfo>>, Map<String, CandidateInfo>> value = cachedValue.getValue();\n    assert value != null;\n    return value.getFirst();\n  }","id":9138,"modified_method":"public static Map<String, CandidateInfo> getAllFields(final PsiClass aClass) {\n    return getCachedMembers(aClass, false).getFirst();\n  }","commit_id":"76c3ac5bdf67d55b366ac9521cbb04bbe693a8ee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent e) {\n    e.getPresentation().setVisible(getTree(e.getDataContext()) instanceof ThreadsDebuggerTree);\n    e.getPresentation().setText(ActionsBundle.actionText(DebuggerActions.CUSTOMIZE_THREADS_VIEW));\n  }","id":9139,"modified_method":"public void update(AnActionEvent e) {\n    e.getPresentation().setVisible(true);\n    e.getPresentation().setText(ActionsBundle.actionText(DebuggerActions.CUSTOMIZE_THREADS_VIEW));\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Icon getIcon(Object item) {\n    if (item == null) {\n      return null;\n    }\n    if (item instanceof ThreadDescriptorImpl) {\n      ThreadDescriptorImpl descriptor = (ThreadDescriptorImpl)item;\n      return descriptor.getIcon();\n    }\n    if (item instanceof StackFrameDescriptorImpl) {\n      return ((StackFrameDescriptorImpl)item).getIcon();\n    }\n    return null;\n  }","id":9140,"modified_method":"@Nullable\n  private static Icon getIcon(Object item) {\n    if (item instanceof ThreadDescriptorImpl) {\n      ThreadDescriptorImpl descriptor = (ThreadDescriptorImpl)item;\n      return descriptor.getIcon();\n    }\n    if (item instanceof StackFrameDescriptorImpl) {\n      return ((StackFrameDescriptorImpl)item).getIcon();\n    }\n    return null;\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void invokeLater(final Project project, final Runnable runnable) {\n    LOG.assertTrue(runnable != null);\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if(project == null || project.isDisposed()) return;\n\n        runnable.run();\n      }\n    });\n  }","id":9141,"modified_method":"public static void invokeLater(final Project project, final Runnable runnable) {\n    LOG.assertTrue(runnable != null);\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        if (project != null && !project.isDisposed()) {\n          runnable.run();\n        }\n      }\n    });\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void rebuildIfVisible() {\n    if(isViewVisible()) {\n      myRefreshNeeded = false;\n      myRebuildAlarm.cancelAllRequests();\n      myRebuildAlarm.addRequest(new Runnable() {\n        public void run() {\n          try {\n            rebuild();\n          }\n          catch (VMDisconnectedException e) {\n            // ignored\n          }\n        }\n      }, 100);\n    }\n    else {\n      myRefreshNeeded = true;\n    }\n  }","id":9142,"modified_method":"public final void rebuildIfVisible() {\n    if(isUpdateEnabled()) {\n      myRefreshNeeded = false;\n      myRebuildAlarm.cancelAllRequests();\n      myRebuildAlarm.addRequest(new Runnable() {\n        public void run() {\n          try {\n            rebuild();\n          }\n          catch (VMDisconnectedException e) {\n            // ignored\n          }\n        }\n      }, 100);\n    }\n    else {\n      myRefreshNeeded = true;\n    }\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    disposeSession();\n    myThreadsPanel.dispose();\n    myFramePanel.dispose();\n    myWatchPanel.dispose();\n    myViewsContentManager.removeAllContents();\n    for (AdditionalTabComponent tabComponent : myAdditionalContent.keySet()) {\n      tabComponent.dispose();\n    }\n    myAdditionalContent.clear();\n    myManager.unregisterFileMatcher();\n    myConsole = null;\n  }","id":9143,"modified_method":"public void dispose() {\n    DebuggerSettings.getInstance().WATCHES_VISIBLE = myWatchPanel.isUpdateEnabled();\n    disposeSession();\n    //myThreadsPanel.dispose();\n    myFramePanel.dispose();\n    //myWatchPanel.dispose();\n    myViewsContentManager.removeAllContents();\n    for (AdditionalTabComponent tabComponent : myAdditionalContent.keySet()) {\n      tabComponent.dispose();\n    }\n    myAdditionalContent.clear();\n    myManager.unregisterFileMatcher();\n    myConsole = null;\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reuse(DebuggerSessionTab reuseSession) {\n    getDebugProcess().setSuspendPolicy(reuseSession.getDebugProcess().getSuspendPolicy());\n    DebuggerTreeNodeImpl[] watches = reuseSession.getWatchPanel().getWatchTree().getWatches();\n\n    for (DebuggerTreeNodeImpl watch : watches) {\n      getWatchPanel().getWatchTree().addWatch((WatchItemDescriptor)watch.getDescriptor());\n    }\n  }","id":9144,"modified_method":"public void reuse(DebuggerSessionTab reuseSession) {\n    final DebugProcessImpl reuseProcess = reuseSession.getDebugProcess();\n    final DebugProcessImpl process = getDebugProcess();\n    if (process != null && reuseProcess != null) {\n      process.setSuspendPolicy(reuseProcess.getSuspendPolicy());\n    }\n    DebuggerTreeNodeImpl[] watches = reuseSession.getWatchPanel().getWatchTree().getWatches();\n\n    final WatchDebuggerTree watchTree = getWatchPanel().getWatchTree();\n    for (DebuggerTreeNodeImpl watch : watches) {\n      watchTree.addWatch((WatchItemDescriptor)watch.getDescriptor());\n    }\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ActionToolbar createSecondToolbar() {\n    ActionManager actionManager = ActionManager.getInstance();\n    DefaultActionGroup group = new DefaultActionGroup();\n    AnAction action = actionManager.getAction(DebuggerActions.STEP_OVER);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.STEP_INTO);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.STEP_OUT);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.FORCE_STEP_INTO);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.POP_FRAME);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.RUN_TO_CURSOR);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.VIEW_BREAKPOINTS);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.MUTE_BREAKPOINTS);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.TOGGLE_STEP_SUSPEND_POLICY);\n    if (action != null) group.add(action);\n\n    return ActionManager.getInstance().createActionToolbar(ActionPlaces.DEBUGGER_TOOLBAR, group, false);\n  }","id":9145,"modified_method":"private static ActionToolbar createSecondToolbar() {\n    DefaultActionGroup group = new DefaultActionGroup();\n\n    addActionToGroup(group, DebuggerActions.SHOW_EXECUTION_POINT);\n    addActionToGroup(group, DebuggerActions.STEP_OVER);\n    addActionToGroup(group, DebuggerActions.STEP_INTO);\n    addActionToGroup(group, DebuggerActions.STEP_OUT);\n    addActionToGroup(group, DebuggerActions.FORCE_STEP_INTO);\n    addActionToGroup(group, DebuggerActions.POP_FRAME);\n    addActionToGroup(group, DebuggerActions.RUN_TO_CURSOR);\n    addActionToGroup(group, DebuggerActions.VIEW_BREAKPOINTS);\n    addActionToGroup(group, DebuggerActions.MUTE_BREAKPOINTS);\n    addActionToGroup(group, DebuggerActions.TOGGLE_STEP_SUSPEND_POLICY);\n\n    return ActionManager.getInstance().createActionToolbar(ActionPlaces.DEBUGGER_TOOLBAR, group, false);\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ActionToolbar createFirstToolbar(RunContentDescriptor contentDescriptor, JComponent component) {\n    DefaultActionGroup group = new DefaultActionGroup();\n    ActionManager actionManager = ActionManager.getInstance();\n\n    // first toolbar\n\n    RestartAction restarAction = new RestartAction(myRunner, myConfiguration, contentDescriptor.getProcessHandler(), DEBUG_AGAIN_ICON,\n                                                   contentDescriptor, myRunnerSettings, myConfigurationSettings);\n    group.add(restarAction);\n    restarAction.registerShortcut(component);\n    AnAction action = actionManager.getAction(DebuggerActions.RESUME);\n    if (action != null) group.add(action);\n    action = actionManager.getAction(DebuggerActions.PAUSE);\n    if (action != null) group.add(action);\n    AnAction stopAction = actionManager.getAction(IdeActions.ACTION_STOP_PROGRAM);\n    if (action != null) group.add(stopAction);\n    action = actionManager.getAction(DebuggerActions.EVALUATE_EXPRESSION);\n    if (action != null) group.add(action);\n    group.add(new CloseAction(myRunner, contentDescriptor, getProject()));\n    group.add(CommonActionsFactory.getCommonActionsFactory().createContextHelpAction(myRunner.getInfo().getHelpId()));\n    return ActionManager.getInstance().createActionToolbar(ActionPlaces.DEBUGGER_TOOLBAR, group, false);\n  }","id":9146,"modified_method":"private ActionToolbar createFirstToolbar(RunContentDescriptor contentDescriptor, JComponent component) {\n    DefaultActionGroup group = new DefaultActionGroup();\n    RestartAction restarAction = new RestartAction(myRunner, myConfiguration, contentDescriptor.getProcessHandler(), DEBUG_AGAIN_ICON,\n                                                   contentDescriptor, myRunnerSettings, myConfigurationSettings);\n    group.add(restarAction);\n    restarAction.registerShortcut(component);\n\n    addActionToGroup(group, DebuggerActions.RESUME);\n    addActionToGroup(group, DebuggerActions.PAUSE);\n    addActionToGroup(group, IdeActions.ACTION_STOP_PROGRAM);\n    addActionToGroup(group, DebuggerActions.EXPORT_THREADS);\n    addActionToGroup(group, DebuggerActions.EVALUATE_EXPRESSION);\n\n    group.add(new CloseAction(myRunner, contentDescriptor, getProject()));\n    group.add(CommonActionsFactory.getCommonActionsFactory().createContextHelpAction(myRunner.getInfo().getHelpId()));\n    group.add(new ShowWatchesAction());\n    return ActionManager.getInstance().createActionToolbar(ActionPlaces.DEBUGGER_TOOLBAR, group, false);\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DebuggerSessionTab(Project project) {\n    myProject = project;\n    myManager = new LogFilesManager(project, this);\n    myContentPanel = new JPanel(new BorderLayout());\n    if(!ApplicationManager.getApplication().isUnitTestMode()) {\n      getContextManager().addListener(new DebuggerContextListener() {\n        public void changeEvent(DebuggerContextImpl newContext, int event) {\n          switch(event) {\n            case DebuggerSession.EVENT_DETACHED:\n              DebuggerSettings settings = DebuggerSettings.getInstance();\n\n              myFirstToolbar.updateActionsImmediately();\n              mySecondToolbar.updateActionsImmediately();\n\n              if (settings.HIDE_DEBUGGER_ON_PROCESS_TERMINATION) {\n                try {\n                  ExecutionManager.getInstance(getProject()).getContentManager().hideRunContent(myRunner, myRunContentDescriptor);\n                }\n                catch (NullPointerException e) {\n                  //if we can get closeProcess after the project have been closed\n                  LOG.debug(e);\n                }\n              }\n              break;\n\n            case DebuggerSession.EVENT_PAUSE:\n              if (myIsJustStarted) {\n                final Content frameView = findContent(FRAME_CONTENT);\n                final Content watchView = findContent(WATCHES_CONTENT);\n                if (frameView != null) {\n                  Content content = myViewsContentManager.getSelectedContent();\n                  if (content == null || content.equals(frameView) || content.equals(watchView)) {\n                    return;\n                  }\n                  showFramePanel();\n                }\n                myIsJustStarted = false;\n              }\n          }\n        }\n      });\n    }\n\n    myWatchPanel = new MainWatchPanel(getProject(), getContextManager()) {\n      protected boolean isViewVisible() {\n        return myViewsContentManager.getSelectedContent().getComponent() == this;\n      }\n    };\n    updateWatchTreeTab();\n\n    myFramePanel = new FramePanel(getProject(), getContextManager()) {\n      protected boolean isViewVisible() {\n        return myViewsContentManager.getSelectedContent().getComponent() == this;\n      }\n    };\n\n    myThreadsPanel = new ThreadsPanel(getProject(), getContextManager()) {\n      protected boolean isViewVisible() {\n        return myViewsContentManager.getSelectedContent().getComponent() == this;\n      }\n    };\n\n    TabbedPaneContentUI ui = new TabbedPaneContentUI(SwingConstants.TOP);\n    myViewsContentManager = PeerFactory.getInstance().getContentFactory().createContentManager(ui, false, getProject());\n\n    Content content = PeerFactory.getInstance().getContentFactory()\n      .createContent(myThreadsPanel, DebuggerBundle.message(\"debugger.session.tab.threads.title\"), false);\n    content.setIcon(THREADS_ICON);\n    content.putUserData(CONTENT_KIND, THREADS_CONTENT);\n    myViewsContentManager.addContent(content);\n\n    content = PeerFactory.getInstance().getContentFactory().createContent(myFramePanel,\n                                                                          DebuggerBundle.message(\"debugger.session.tab.frames.title\"), false);\n    content.setIcon(FRAME_ICON);\n    content.putUserData(CONTENT_KIND, FRAME_CONTENT);\n    myViewsContentManager.addContent(content);\n\n    content = PeerFactory.getInstance().getContentFactory().createContent(myWatchPanel,\n                                                                          DebuggerBundle.message(\"debugger.session.tab.watches.title\"), false);\n    content.setIcon(WATCHES_ICON);\n    content.putUserData(CONTENT_KIND, WATCHES_CONTENT);\n    myViewsContentManager.addContent(content);\n\n    myViewsContentManager.addContentManagerListener(new ContentManagerAdapter() {\n      public void selectionChanged(ContentManagerEvent event) {\n        Content selectedContent = myViewsContentManager.getSelectedContent();\n        if (selectedContent != null) {\n          JComponent component = selectedContent.getComponent();\n          if (component instanceof DebuggerPanel) {\n            DebuggerPanel panel = (DebuggerPanel)component;\n            if (panel.isRefreshNeeded()) {\n              panel.rebuildIfVisible();\n            }\n          }\n        }\n      }\n    });\n\n    myContentPanel.add(myViewsContentManager.getComponent(), BorderLayout.CENTER);\n  }","id":9147,"modified_method":"public DebuggerSessionTab(Project project) {\n    myProject = project;\n    myManager = new LogFilesManager(project, this);\n    myContentPanel = new JPanel(new BorderLayout());\n    if(!ApplicationManager.getApplication().isUnitTestMode()) {\n      getContextManager().addListener(new DebuggerContextListener() {\n        public void changeEvent(DebuggerContextImpl newContext, int event) {\n          switch(event) {\n            case DebuggerSession.EVENT_DETACHED:\n              DebuggerSettings settings = DebuggerSettings.getInstance();\n\n              myFirstToolbar.updateActionsImmediately();\n              mySecondToolbar.updateActionsImmediately();\n\n              if (settings.HIDE_DEBUGGER_ON_PROCESS_TERMINATION) {\n                try {\n                  ExecutionManager.getInstance(getProject()).getContentManager().hideRunContent(myRunner, myRunContentDescriptor);\n                }\n                catch (NullPointerException e) {\n                  //if we can get closeProcess after the project have been closed\n                  LOG.debug(e);\n                }\n              }\n              break;\n\n            case DebuggerSession.EVENT_PAUSE:\n              if (myIsJustStarted) {\n                final Content frameView = findContent(FRAME_CONTENT);\n                final Content watchView = findContent(WATCHES_CONTENT);\n                if (frameView != null) {\n                  Content content = myViewsContentManager.getSelectedContent();\n                  if (content == null || content.equals(frameView) || content.equals(watchView)) {\n                    return;\n                  }\n                  showFramePanel();\n                }\n                myIsJustStarted = false;\n              }\n          }\n        }\n      });\n    }\n\n    myWatchPanel = new MainWatchPanel(getProject(), getContextManager(), WATCHES_ICON);\n    //updateWatchTreeTab();\n\n    myFramePanel = new FramePanel(getProject(), getContextManager()) {\n      protected boolean isUpdateEnabled() {\n        return myViewsContentManager.getSelectedContent().getComponent() == this;\n      }\n    };\n    if (DebuggerSettings.getInstance().WATCHES_VISIBLE) {\n      myFramePanel.setWatchPanel(myWatchPanel);\n    }\n\n    /*\n    myThreadsPanel = new ThreadsPanel(getProject(), getContextManager()) {\n      protected boolean isUpdateEnabled() {\n        return myViewsContentManager.getSelectedContent().getComponent() == this;\n      }\n    };\n    */\n\n    TabbedPaneContentUI ui = new TabbedPaneContentUI(SwingConstants.TOP);\n    myViewsContentManager = PeerFactory.getInstance().getContentFactory().createContentManager(ui, false, getProject());\n\n    Content content;\n    /*\n    content = PeerFactory.getInstance().getContentFactory().createContent(myThreadsPanel, DebuggerBundle.message(\"debugger.session.tab.threads.title\"), false);\n    content.setIcon(THREADS_ICON);\n    content.putUserData(CONTENT_KIND, THREADS_CONTENT);\n    myViewsContentManager.addContent(content);\n    */\n\n    content = PeerFactory.getInstance().getContentFactory().createContent(myFramePanel,\n                                                                          DebuggerBundle.message(\"debugger.session.tab.frames.title\"), false);\n    content.setIcon(FRAME_ICON);\n    content.putUserData(CONTENT_KIND, FRAME_CONTENT);\n    myViewsContentManager.addContent(content);\n\n    /*\n    content = PeerFactory.getInstance().getContentFactory().createContent(myWatchPanel, DebuggerBundle.message(\"debugger.session.tab.watches.title\"), false);\n    content.setIcon(WATCHES_ICON);\n    content.putUserData(CONTENT_KIND, WATCHES_CONTENT);\n    myViewsContentManager.addContent(content);\n    */\n\n    myViewsContentManager.addContentManagerListener(new ContentManagerAdapter() {\n      public void selectionChanged(ContentManagerEvent event) {\n        Content selectedContent = myViewsContentManager.getSelectedContent();\n        if (selectedContent != null) {\n          JComponent component = selectedContent.getComponent();\n          if (component instanceof DebuggerPanel) {\n            DebuggerPanel panel = (DebuggerPanel)component;\n            if (panel.isRefreshNeeded()) {\n              panel.rebuildIfVisible();\n            }\n          }\n        }\n      }\n    });\n\n    myContentPanel.add(myViewsContentManager.getComponent(), BorderLayout.CENTER);\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private java.util.List<ThreadDescriptorImpl> getThreadList() {\n      final java.util.List<ThreadReferenceProxyImpl> threads = new ArrayList<ThreadReferenceProxyImpl>(getSuspendContext().getDebugProcess().getVirtualMachineProxy().allThreads());\n      Collections.sort(threads, ThreadReferenceProxyImpl.ourComparator);\n\n      final java.util.List<ThreadDescriptorImpl> descriptors = new ArrayList<ThreadDescriptorImpl>(threads.size());\n      EvaluationContextImpl evaluationContext = getDebuggerContext().createEvaluationContext();\n\n      for (Iterator<ThreadReferenceProxyImpl> iterator = threads.iterator(); iterator.hasNext();) {\n        ThreadReferenceProxyImpl thread = iterator.next();\n\n        ThreadDescriptorImpl threadDescriptor = new ThreadDescriptorImpl(thread);\n        threadDescriptor.setContext(evaluationContext);\n        threadDescriptor.updateRepresentation(evaluationContext, DescriptorLabelListener.DUMMY_LISTENER);\n        descriptors.add(threadDescriptor);\n      }\n      return descriptors;\n    }","id":9148,"modified_method":"private List<ThreadDescriptorImpl> getThreadList() {\n      final List<ThreadReferenceProxyImpl> threads = new ArrayList<ThreadReferenceProxyImpl>(getSuspendContext().getDebugProcess().getVirtualMachineProxy().allThreads());\n      Collections.sort(threads, ThreadReferenceProxyImpl.ourComparator);\n\n      final List<ThreadDescriptorImpl> descriptors = new ArrayList<ThreadDescriptorImpl>(threads.size());\n      EvaluationContextImpl evaluationContext = getDebuggerContext().createEvaluationContext();\n\n      for (ThreadReferenceProxyImpl thread : threads) {\n        ThreadDescriptorImpl threadDescriptor = new ThreadDescriptorImpl(thread);\n        threadDescriptor.setContext(evaluationContext);\n        threadDescriptor.updateRepresentation(evaluationContext, DescriptorLabelListener.DUMMY_LISTENER);\n        descriptors.add(threadDescriptor);\n      }\n      return descriptors;\n    }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void threadAction() {\n      final DebuggerContextImpl context = getDebuggerContext();\n\n      final ThreadReferenceProxyImpl threadToSelect = context.getThreadProxy();\n      if(threadToSelect == null) {\n        return;\n      }\n\n      final java.util.List<ThreadDescriptorImpl>  threadItems = getThreadList();\n\n      SuspendContextImpl threadContext = SuspendManagerUtil.getSuspendContextForThread(context.getSuspendContext(), threadToSelect);\n      context.getDebugProcess().getManagerThread().invokeLater(new RefreshFramesListCommand(context, threadContext));\n\n      DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {\n        public void run() {\n          try {\n            myThreadsListener.setEnabled(false);\n\n            myThreadsCombo.removeAllItems();\n            for (Iterator<ThreadDescriptorImpl> iterator = threadItems.iterator(); iterator.hasNext();) {\n              myThreadsCombo.addItem(iterator.next());\n            }\n\n            selectThread(threadToSelect);\n          }\n          finally {\n            myThreadsListener.setEnabled(true);\n          }\n        }\n      });\n    }","id":9149,"modified_method":"public void threadAction() {\n      final DebuggerContextImpl context = getDebuggerContext();\n\n      final ThreadReferenceProxyImpl threadToSelect = context.getThreadProxy();\n      if(threadToSelect == null) {\n        return;\n      }\n\n      final List<ThreadDescriptorImpl>  threadItems = getThreadList();\n\n      SuspendContextImpl threadContext = SuspendManagerUtil.getSuspendContextForThread(context.getSuspendContext(), threadToSelect);\n      context.getDebugProcess().getManagerThread().invokeLater(new RefreshFramesListCommand(context, threadContext));\n\n      DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {\n        public void run() {\n          try {\n            myThreadsListener.setEnabled(false);\n\n            myThreadsCombo.removeAllItems();\n            for (final ThreadDescriptorImpl threadItem : threadItems) {\n              myThreadsCombo.addItem(threadItem);\n            }\n\n            selectThread(threadToSelect);\n          }\n          finally {\n            myThreadsListener.setEnabled(true);\n          }\n        }\n      });\n    }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void selectFrame(StackFrameProxy frame) {\n    int count = myFramesCombo.getItemCount();\n    for (int idx = 0; idx < count; idx++) {\n      StackFrameDescriptorImpl item = (StackFrameDescriptorImpl)myFramesCombo.getItemAt(idx);\n      if (frame.equals(item.getStackFrame())) {\n        if (!item.equals(myFramesCombo.getSelectedItem())) {\n          myFramesCombo.setSelectedIndex(idx);\n        }\n        return;\n      }\n    }\n  }","id":9150,"modified_method":"private void selectFrame(StackFrameProxy frame) {\n    final ListModel listModel = myFramesList.getModel();\n    final int count = listModel.getSize();\n    final StackFrameDescriptorImpl selectedValue = (StackFrameDescriptorImpl)myFramesList.getSelectedValue();\n    for (int idx = 0; idx < count; idx++) {\n      StackFrameDescriptorImpl item = (StackFrameDescriptorImpl)listModel.getElementAt(idx);\n      if (frame.equals(item.getStackFrame())) {\n        if (!item.equals(selectedValue)) {\n          myFramesList.setSelectedIndex(idx);\n        }\n        return;\n      }\n    }\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void showMessage(MessageDescriptor messageDescriptor) {\n    myThreadsCombo.removeAllItems();\n    myFramesCombo.removeAllItems();\n    super.showMessage(messageDescriptor);\n  }","id":9151,"modified_method":"protected void showMessage(MessageDescriptor messageDescriptor) {\n    myThreadsCombo.removeAllItems();\n    ((DefaultListModel)myFramesList.getModel()).clear();\n    super.showMessage(messageDescriptor);\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void contextAction() throws Exception {\n      final java.util.List<StackFrameDescriptorImpl> frameItems  = getFrameList(myDebuggerContext.getThreadProxy());\n\n      DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {\n        public void run() {\n          try {\n            myFramesListener.setEnabled(false);\n            myFramesCombo.removeAllItems();\n            for (Iterator<StackFrameDescriptorImpl> iterator = frameItems.iterator(); iterator.hasNext();) {\n              myFramesCombo.addItem(iterator.next());\n            }\n            if(getDebuggerContext().getFrameProxy() != null) {\n              selectFrame(getDebuggerContext().getFrameProxy());\n            }\n          } finally {\n            myFramesListener.setEnabled(true);\n          }\n        }\n      });\n\n    }","id":9152,"modified_method":"public void contextAction() throws Exception {\n      final List<StackFrameDescriptorImpl> frameItems = getFrameList(myDebuggerContext.getThreadProxy());\n      DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {\n        public void run() {\n          try {\n            myFramesListener.setEnabled(false);\n            final DefaultListModel listModel = (DefaultListModel)myFramesList.getModel();\n            listModel.clear();\n            for (final StackFrameDescriptorImpl frameItem : frameItems) {\n              listModel.addElement(frameItem);\n            }\n            final StackFrameProxyImpl contextFrame = getDebuggerContext().getFrameProxy();\n            if(contextFrame != null) {\n              selectFrame(contextFrame);\n            }\n          }\n          finally {\n            myFramesListener.setEnabled(true);\n          }\n        }\n      });\n\n    }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    super.dispose();\n    myThreadsCombo.removeItemListener(myThreadsListener);\n  }","id":9153,"modified_method":"public void dispose() {\n    final DebuggerSettings settings = DebuggerSettings.getInstance();\n    settings.THREADS_FRAME_SPLITTER_PROPORTION = getFirstProportion();\n    if (mySplitter.getLastComponent() != null) {\n      settings.FRAME_WATCHES_SPLITTER_PROPORTION = getLastProportion();\n    }\n    myThreadsCombo.removeItemListener(myThreadsListener);\n    super.dispose();\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private java.util.List<StackFrameDescriptorImpl> getFrameList(ThreadReferenceProxyImpl thread) {\n      if(!getSuspendContext().getDebugProcess().getSuspendManager().isSuspended(thread)) {\n        return Collections.<StackFrameDescriptorImpl>emptyList();\n      }\n\n      java.util.List<StackFrameProxyImpl> frames;\n      try {\n        frames = thread.frames();\n      }\n      catch (EvaluateException e) {\n        frames = new ArrayList<StackFrameProxyImpl>();\n      }\n\n      final java.util.List<StackFrameDescriptorImpl> frameItems = new ArrayList<StackFrameDescriptorImpl>(frames.size());\n\n      EvaluationContextImpl evaluationContext = getDebuggerContext().createEvaluationContext();\n      for (Iterator<StackFrameProxyImpl> iterator = frames.iterator(); iterator.hasNext();) {\n        StackFrameProxyImpl stackFrameProxy = iterator.next();\n        StackFrameDescriptorImpl descriptor = new StackFrameDescriptorImpl(stackFrameProxy);\n        descriptor.setContext(evaluationContext);\n        descriptor.updateRepresentation(evaluationContext, DescriptorLabelListener.DUMMY_LISTENER);\n        frameItems.add(descriptor);\n      }\n\n      return frameItems;\n    }","id":9154,"modified_method":"private List<StackFrameDescriptorImpl> getFrameList(ThreadReferenceProxyImpl thread) {\n      if(!getSuspendContext().getDebugProcess().getSuspendManager().isSuspended(thread)) {\n        return Collections.emptyList();\n      }\n\n      List<StackFrameProxyImpl> frames;\n      try {\n        frames = thread.frames();\n      }\n      catch (EvaluateException e) {\n        frames = new ArrayList<StackFrameProxyImpl>();\n      }\n\n      final List<StackFrameDescriptorImpl> frameItems = new ArrayList<StackFrameDescriptorImpl>(frames.size());\n\n      EvaluationContextImpl evaluationContext = getDebuggerContext().createEvaluationContext();\n      for (StackFrameProxyImpl stackFrameProxy : frames) {\n        StackFrameDescriptorImpl descriptor = new StackFrameDescriptorImpl(stackFrameProxy);\n        descriptor.setContext(evaluationContext);\n        descriptor.updateRepresentation(evaluationContext, DescriptorLabelListener.DUMMY_LISTENER);\n        frameItems.add(descriptor);\n      }\n\n      return frameItems;\n    }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void rebuild() {\n    myThreadsCombo.removeAllItems();\n    myFramesCombo.removeAllItems();\n\n    getContext().getDebugProcess().getManagerThread().invokeLater(new RefreshFramePanelCommand());\n\n    super.rebuild();\n  }","id":9155,"modified_method":"protected void rebuild() {\n    myThreadsCombo.removeAllItems();\n    ((DefaultListModel)myFramesList.getModel()).clear();\n\n    getContext().getDebugProcess().getManagerThread().invokeLater(new RefreshFramePanelCommand());\n\n    super.rebuild();\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FramePanel(Project project, DebuggerStateManager stateManager) {\n    super(project, stateManager);\n    myThreadsCombo = new JComboBox();\n    myFramesCombo = new JComboBox();\n    myThreadsCombo.setRenderer(new DebuggerComboBoxRenderer());\n    myFramesCombo.setRenderer(new DebuggerComboBoxRenderer());\n    myThreadsListener = new ThreadsListener();\n    myFramesListener = new FramesListener();\n    myThreadsCombo.addItemListener(myThreadsListener);\n    myFramesCombo.addActionListener(myFramesListener);\n\n    Splitter splitter = new Splitter();\n    splitter.setPreferredSize(new Dimension(-1, 23));\n    splitter.setFirstComponent(new ComboPager(myFramesCombo, this));\n    splitter.setSecondComponent(myThreadsCombo);\n\n    this.add(splitter, BorderLayout.NORTH);\n\n    final FrameDebuggerTree frameTree = getFrameTree();\n    add(new JScrollPane(frameTree), BorderLayout.CENTER);\n\n    final Disposable disposable = DebuggerAction.installEditAction(frameTree, DebuggerActions.EDIT_NODE_SOURCE);\n    registerDisposable(disposable);\n\n    final AnAction setValueAction  = ActionManager.getInstance().getAction(DebuggerActions.SET_VALUE);\n    setValueAction.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0)), frameTree);\n    registerDisposable(new Disposable() {\n      public void dispose() {\n        setValueAction.unregisterCustomShortcutSet(frameTree);\n      }\n    });\n  }","id":9156,"modified_method":"public FramePanel(Project project, DebuggerStateManager stateManager) {\n    super(project, stateManager);\n    setBorder(null);\n\n    myThreadsCombo = new JComboBox();\n    myThreadsCombo.setRenderer(new DebuggerComboBoxRenderer());\n    myThreadsListener = new ThreadsListener();\n    myThreadsCombo.addItemListener(myThreadsListener);\n\n    myFramesList = new JList(new DefaultListModel());\n    myFramesList.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myFramesList.setCellRenderer(new DebuggerComboBoxRenderer());\n    myFramesListener = new FramesListener();\n    myFramesList.addListSelectionListener(myFramesListener);\n    registerThreadsPopupMenu(myFramesList);\n\n    final JPanel threadsPanel = new JPanel(new BorderLayout());\n    threadsPanel.setBorder(null);\n    threadsPanel.add(new ComboPager(myThreadsCombo, this), BorderLayout.NORTH);\n    threadsPanel.add(new JScrollPane(myFramesList), BorderLayout.CENTER);\n\n    final FrameDebuggerTree frameTree = getFrameTree();\n\n    mySplitter = new ThreeComponentsSplitter();\n    mySplitter.setFirstComponent(threadsPanel);\n\n    final JPanel treePanel = new JPanel(new BorderLayout());\n    treePanel.add(new JScrollPane(frameTree), BorderLayout.CENTER);\n    final JLabel title = new JLabel(DebuggerBundle.message(\"debugger.session.tab.variables.title\"));\n    title.setIcon(VARIABLES_ICON);\n    treePanel.add(title, BorderLayout.NORTH);\n\n    mySplitter.setInnerComponent(treePanel);\n    mySplitter.setLastComponent(null);\n\n    add(mySplitter, BorderLayout.CENTER);\n\n    registerDisposable(DebuggerAction.installEditAction(frameTree, DebuggerActions.EDIT_NODE_SOURCE));\n\n    final AnAction setValueAction  = ActionManager.getInstance().getAction(DebuggerActions.SET_VALUE);\n    setValueAction.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0)), frameTree);\n    registerDisposable(new Disposable() {\n      public void dispose() {\n        setValueAction.unregisterCustomShortcutSet(frameTree);\n      }\n    });\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MainWatchPanel(Project project, DebuggerStateManager stateManager) {\n    super(project,stateManager);\n    final WatchDebuggerTree watchTree = getWatchTree();\n\n    final AnAction removeWatchesAction = ActionManager.getInstance().getAction(DebuggerActions.REMOVE_WATCH);\n    removeWatchesAction.registerCustomShortcutSet(new CustomShortcutSet(myRemoveWatchAccelerator), watchTree);\n\n    final AnAction newWatchAction  = ActionManager.getInstance().getAction(DebuggerActions.NEW_WATCH);\n    newWatchAction.registerCustomShortcutSet(new CustomShortcutSet(myNewWatchAccelerator), watchTree);\n\n    final MouseAdapter mouseListener = new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 2) {\n          AnAction editWatchAction = ActionManager.getInstance().getAction(DebuggerActions.EDIT_WATCH);\n          Presentation presentation = (Presentation)editWatchAction.getTemplatePresentation().clone();\n          DataContext context = DataManager.getInstance().getDataContext(watchTree);\n\n          AnActionEvent actionEvent = new AnActionEvent(null, context, \"WATCH_TREE\", presentation, ActionManager.getInstance(), 0);\n          editWatchAction.actionPerformed(actionEvent);\n        }\n      }\n    };\n    ListenerUtil.addMouseListener(watchTree, mouseListener);\n\n    final AnAction editWatchAction  = ActionManager.getInstance().getAction(DebuggerActions.EDIT_WATCH);\n    editWatchAction.registerCustomShortcutSet(new CustomShortcutSet(myEditWatchAccelerator), watchTree);\n    registerDisposable(new Disposable() {\n      public void dispose() {\n        ListenerUtil.removeMouseListener(watchTree, mouseListener);\n        removeWatchesAction.unregisterCustomShortcutSet(watchTree);\n        newWatchAction.unregisterCustomShortcutSet(watchTree);\n        editWatchAction.unregisterCustomShortcutSet(watchTree);\n      }\n    });\n  }","id":9157,"modified_method":"public MainWatchPanel(Project project, DebuggerStateManager stateManager, final Icon icon) {\n    super(project,stateManager);\n    final JLabel label = new JLabel(DebuggerBundle.message(\"debugger.session.tab.watches.title\"));\n    label.setIcon(icon);\n    add(label, BorderLayout.NORTH);\n    final WatchDebuggerTree watchTree = getWatchTree();\n\n    final AnAction removeWatchesAction = ActionManager.getInstance().getAction(DebuggerActions.REMOVE_WATCH);\n    removeWatchesAction.registerCustomShortcutSet(new CustomShortcutSet(myRemoveWatchAccelerator), watchTree);\n\n    final AnAction newWatchAction  = ActionManager.getInstance().getAction(DebuggerActions.NEW_WATCH);\n    newWatchAction.registerCustomShortcutSet(new CustomShortcutSet(myNewWatchAccelerator), watchTree);\n\n    final MouseAdapter mouseListener = new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 2) {\n          AnAction editWatchAction = ActionManager.getInstance().getAction(DebuggerActions.EDIT_WATCH);\n          Presentation presentation = (Presentation)editWatchAction.getTemplatePresentation().clone();\n          DataContext context = DataManager.getInstance().getDataContext(watchTree);\n\n          AnActionEvent actionEvent = new AnActionEvent(null, context, \"WATCH_TREE\", presentation, ActionManager.getInstance(), 0);\n          editWatchAction.actionPerformed(actionEvent);\n        }\n      }\n    };\n    ListenerUtil.addMouseListener(watchTree, mouseListener);\n\n    final AnAction editWatchAction  = ActionManager.getInstance().getAction(DebuggerActions.EDIT_WATCH);\n    editWatchAction.registerCustomShortcutSet(new CustomShortcutSet(myEditWatchAccelerator), watchTree);\n    registerDisposable(new Disposable() {\n      public void dispose() {\n        ListenerUtil.removeMouseListener(watchTree, mouseListener);\n        removeWatchesAction.unregisterCustomShortcutSet(watchTree);\n        newWatchAction.unregisterCustomShortcutSet(watchTree);\n        editWatchAction.unregisterCustomShortcutSet(watchTree);\n      }\n    });\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    Project project = (Project)e.getDataContext().getData(DataConstants.PROJECT);\n    StackFrameProxyImpl stackFrame = getStackFrameProxy(e);\n    if(stackFrame == null) return;\n\n    try {\n      DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n\n      DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n\n      if(debugProcess == null) return;\n\n      debugProcess.getManagerThread().invokeLater(debugProcess.createPopFrameCommand(debuggerContext, stackFrame));\n    }\n    catch (NativeMethodException e2){\n      Messages.showMessageDialog(project, DebuggerBundle.message(\"error.native.method.exception\"), ActionsBundle.actionText(DebuggerActions.POP_FRAME), Messages.getErrorIcon());\n    }\n    catch (InvalidStackFrameException ignored) {\n    }\n    catch(VMDisconnectedException vde) {\n    }\n  }","id":9158,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    Project project = e.getData(DataKeys.PROJECT);\n    StackFrameProxyImpl stackFrame = getStackFrameProxy(e);\n    if(stackFrame == null) {\n      return;\n    }\n    try {\n      DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n      DebugProcessImpl debugProcess = debuggerContext.getDebugProcess();\n      if(debugProcess == null) {\n        return;\n      }\n      debugProcess.getManagerThread().invokeLater(debugProcess.createPopFrameCommand(debuggerContext, stackFrame));\n    }\n    catch (NativeMethodException e2){\n      Messages.showMessageDialog(project, DebuggerBundle.message(\"error.native.method.exception\"), ActionsBundle.actionText(DebuggerActions.POP_FRAME), Messages.getErrorIcon());\n    }\n    catch (InvalidStackFrameException ignored) {\n    }\n    catch(VMDisconnectedException vde) {\n    }\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isAtBreakpoint(AnActionEvent e) {\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode != null && selectedNode.getDescriptor() instanceof StackFrameDescriptorImpl) {\n      DebuggerTreeNodeImpl parent = (DebuggerTreeNodeImpl)selectedNode.getParent();\n      if(parent != null) {\n        return ((ThreadDescriptorImpl)parent.getDescriptor()).isAtBreakpoint();\n      }\n    }\n    DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n    SuspendContextImpl suspendContext = debuggerContext.getSuspendContext();\n    return suspendContext != null && debuggerContext.getThreadProxy() == suspendContext.getThread();\n  }","id":9159,"modified_method":"private static boolean isAtBreakpoint(AnActionEvent e) {\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode != null && selectedNode.getDescriptor() instanceof StackFrameDescriptorImpl) {\n      DebuggerTreeNodeImpl parent = selectedNode.getParent();\n      if(parent != null) {\n        return ((ThreadDescriptorImpl)parent.getDescriptor()).isAtBreakpoint();\n      }\n    }\n    DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n    SuspendContextImpl suspendContext = debuggerContext.getSuspendContext();\n    return suspendContext != null && debuggerContext.getThreadProxy() == suspendContext.getThread();\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private StackFrameProxyImpl getStackFrameProxy(AnActionEvent e) {\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode != null) {\n      NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n      if(descriptor instanceof StackFrameDescriptorImpl) {\n        if(selectedNode.getNextSibling() != null) {\n          StackFrameDescriptorImpl frameDescriptor = ((StackFrameDescriptorImpl)descriptor);\n          return frameDescriptor.getStackFrame();\n        }\n        else {\n          return null;\n        }\n      }\n      else if(descriptor instanceof ThreadDescriptorImpl || descriptor instanceof ThreadGroupDescriptorImpl) {\n        return null;\n      }\n    }\n    DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n    StackFrameProxyImpl frameProxy = debuggerContext.getFrameProxy();\n\n    if(frameProxy == null) return null;\n\n    if(frameProxy.isBottom()) return null;\n\n    return frameProxy;\n  }","id":9160,"modified_method":"@Nullable\n  private static StackFrameProxyImpl getStackFrameProxy(AnActionEvent e) {\n    DebuggerTreeNodeImpl selectedNode = getSelectedNode(e.getDataContext());\n    if(selectedNode != null) {\n      NodeDescriptorImpl descriptor = selectedNode.getDescriptor();\n      if(descriptor instanceof StackFrameDescriptorImpl) {\n        if(selectedNode.getNextSibling() != null) {\n          StackFrameDescriptorImpl frameDescriptor = ((StackFrameDescriptorImpl)descriptor);\n          return frameDescriptor.getStackFrame();\n        }\n        return null;\n      }\n      else if(descriptor instanceof ThreadDescriptorImpl || descriptor instanceof ThreadGroupDescriptorImpl) {\n        return null;\n      }\n    }\n    DebuggerContextImpl debuggerContext = DebuggerAction.getDebuggerContext(e.getDataContext());\n    StackFrameProxyImpl frameProxy = debuggerContext.getFrameProxy();\n\n    if(frameProxy == null || frameProxy.isBottom()) {\n      return null;\n    }\n    return frameProxy;\n  }","commit_id":"eee604fdf99765a660276b3ebfa6a879c40c8e11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksEntry entry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (entry.getFolderId() !=\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\ttry {\n\t\t\t\tBookmarksFolder folder =\n\t\t\t\t\tBookmarksFolderLocalServiceUtil.getFolder(\n\t\t\t\t\t\tentry.getFolderId());\n\n\t\t\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE &&\n\t\t\t\t\t!BookmarksFolderPermission.contains(\n\t\t\t\t\t\tpermissionChecker, folder, ActionKeys.ACCESS) &&\n\t\t\t\t\t!BookmarksFolderPermission.contains(\n\t\t\t\t\t\tpermissionChecker, folder, ActionKeys.VIEW)) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (BookmarksFolderPermission.contains(\n\t\t\t\t\t\tpermissionChecker, folder, actionId)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tif (!entry.isInTrash()) {\n\t\t\t\t\tthrow nsfe;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\tentry.getCompanyId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(), entry.getUserId(), actionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tentry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tentry.getEntryId(), actionId);\n\t}","id":9161,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksEntry entry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.VIEW) &&\n\t\t\tPropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\n\t\t\tlong folderId = entry.getFolderId();\n\n\t\t\tif (folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\ttry {\n\t\t\t\t\tBookmarksFolder folder =\n\t\t\t\t\t\tBookmarksFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\t\t\tif (!BookmarksFolderPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, folder, ActionKeys.ACCESS) &&\n\t\t\t\t\t\t!BookmarksFolderPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, folder, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\t\tif (!entry.isInTrash()) {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\tentry.getCompanyId(), BookmarksEntry.class.getName(),\n\t\t\t\tentry.getEntryId(), entry.getUserId(), actionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tentry.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tentry.getEntryId(), actionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksFolder folder,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.ADD_FOLDER)) {\n\t\t\tactionId = ActionKeys.ADD_SUBFOLDER;\n\t\t}\n\n\t\tlong folderId = folder.getFolderId();\n\n\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\tlong originalFolderId = folderId;\n\n\t\t\ttry {\n\t\t\t\twhile (folderId !=\n\t\t\t\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\t\tfolder = BookmarksFolderLocalServiceUtil.getFolder(\n\t\t\t\t\t\tfolderId);\n\n\t\t\t\t\tif (!_hasPermission(permissionChecker, folder, actionId)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfolderId = folder.getParentFolderId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tif (!folder.isInTrash()) {\n\t\t\t\t\tthrow nsfe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfolderId = originalFolderId;\n\t\t}\n\n\t\ttry {\n\t\t\twhile (folderId !=\n\t\t\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\tfolder = BookmarksFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\t\tif (_hasPermission(permissionChecker, folder, actionId)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tfolderId = folder.getParentFolderId();\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\tif (!folder.isInTrash()) {\n\t\t\t\tthrow nsfe;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":9162,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksFolder folder,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.ADD_FOLDER)) {\n\t\t\tactionId = ActionKeys.ADD_SUBFOLDER;\n\t\t}\n\n\t\tif (actionId.equals(ActionKeys.VIEW) &&\n\t\t\tPropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\n\t\t\ttry {\n\t\t\t\tlong folderId = folder.getFolderId();\n\n\t\t\t\twhile (folderId !=\n\t\t\t\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\t\tfolder = BookmarksFolderLocalServiceUtil.getFolder(\n\t\t\t\t\t\tfolderId);\n\n\t\t\t\t\tif (!_hasPermission(permissionChecker, folder, actionId)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfolderId = folder.getParentFolderId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tif (!folder.isInTrash()) {\n\t\t\t\t\tthrow nsfe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn _hasPermission(permissionChecker, folder, actionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, DLFileEntry dlFileEntry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBoolean hasPermission = StagingPermissionUtil.hasPermission(\n\t\t\tpermissionChecker, dlFileEntry.getGroupId(),\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\tPortletKeys.DOCUMENT_LIBRARY, actionId);\n\n\t\tif (hasPermission != null) {\n\t\t\treturn hasPermission.booleanValue();\n\t\t}\n\n\t\tDLFileVersion latestDLFileVersion = dlFileEntry.getLatestFileVersion(\n\t\t\ttrue);\n\n\t\tif (latestDLFileVersion.isPending()) {\n\t\t\thasPermission = WorkflowPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, dlFileEntry.getGroupId(),\n\t\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\t\tactionId);\n\n\t\t\tif (hasPermission != null) {\n\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t}\n\t\t}\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\ttry {\n\t\t\t\tDLFolder dlFolder = DLFolderLocalServiceUtil.getFolder(\n\t\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE &&\n\t\t\t\t\t!DLFolderPermission.contains(\n\t\t\t\t\t\tpermissionChecker, dlFolder, ActionKeys.ACCESS) &&\n\t\t\t\t\t!DLFolderPermission.contains(\n\t\t\t\t\t\tpermissionChecker, dlFolder, ActionKeys.VIEW)) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (!actionId.equals(ActionKeys.OVERRIDE_CHECKOUT) &&\n\t\t\t\t\tDLFolderPermission.contains(\n\t\t\t\t\t\tpermissionChecker, dlFolder, actionId)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tif (!latestDLFileVersion.isInTrash()) {\n\t\t\t\t\tthrow nsfe;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getUserId(),\n\t\t\t\tactionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tdlFileEntry.getGroupId(), DLFileEntry.class.getName(),\n\t\t\tdlFileEntry.getFileEntryId(), actionId);\n\t}","id":9163,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, DLFileEntry dlFileEntry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBoolean hasPermission = StagingPermissionUtil.hasPermission(\n\t\t\tpermissionChecker, dlFileEntry.getGroupId(),\n\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\tPortletKeys.DOCUMENT_LIBRARY, actionId);\n\n\t\tif (hasPermission != null) {\n\t\t\treturn hasPermission.booleanValue();\n\t\t}\n\n\t\tDLFileVersion latestDLFileVersion = dlFileEntry.getLatestFileVersion(\n\t\t\ttrue);\n\n\t\tif (latestDLFileVersion.isPending()) {\n\t\t\thasPermission = WorkflowPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, dlFileEntry.getGroupId(),\n\t\t\t\tDLFileEntry.class.getName(), dlFileEntry.getFileEntryId(),\n\t\t\t\tactionId);\n\n\t\t\tif (hasPermission != null) {\n\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t}\n\t\t}\n\n\t\tif (actionId.equals(ActionKeys.VIEW) &&\n\t\t\tPropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\n\t\t\tlong dlFolderId = dlFileEntry.getFolderId();\n\n\t\t\tif (dlFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\ttry {\n\t\t\t\t\tDLFolder dlFolder = DLFolderLocalServiceUtil.getFolder(\n\t\t\t\t\t\tdlFolderId);\n\n\t\t\t\t\tif (!DLFolderPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, dlFolder, ActionKeys.ACCESS) &&\n\t\t\t\t\t\t!DLFolderPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, dlFolder, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\t\tif (!latestDLFileVersion.isInTrash()) {\n\t\t\t\t\t\tthrow nsfe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\tdlFileEntry.getCompanyId(), DLFileEntry.class.getName(),\n\t\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getUserId(),\n\t\t\t\tactionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tdlFileEntry.getGroupId(), DLFileEntry.class.getName(),\n\t\t\tdlFileEntry.getFileEntryId(), actionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, DLFolder dlFolder,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.ADD_FOLDER)) {\n\t\t\tactionId = ActionKeys.ADD_SUBFOLDER;\n\t\t}\n\n\t\tBoolean hasPermission = StagingPermissionUtil.hasPermission(\n\t\t\tpermissionChecker, dlFolder.getGroupId(), DLFolder.class.getName(),\n\t\t\tdlFolder.getFolderId(), PortletKeys.DOCUMENT_LIBRARY, actionId);\n\n\t\tif (hasPermission != null) {\n\t\t\treturn hasPermission.booleanValue();\n\t\t}\n\n\t\tlong folderId = dlFolder.getFolderId();\n\n\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\tlong originalFolderId = folderId;\n\n\t\t\ttry {\n\t\t\t\twhile (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\t\tdlFolder = DLFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\t\t\tif (!_hasPermission(\n\t\t\t\t\t\t\tpermissionChecker, dlFolder, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfolderId = dlFolder.getParentFolderId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tif (!dlFolder.isInTrash()) {\n\t\t\t\t\tthrow nsfe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfolderId = originalFolderId;\n\t\t}\n\n\t\ttry {\n\t\t\twhile (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tdlFolder = DLFolderLocalServiceUtil.getFolder(folderId);\n\n\t\t\t\tif (_hasPermission(permissionChecker, dlFolder, actionId)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tfolderId = dlFolder.getParentFolderId();\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\tif (!dlFolder.isInTrash()) {\n\t\t\t\tthrow nsfe;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":9164,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, DLFolder dlFolder,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.ADD_FOLDER)) {\n\t\t\tactionId = ActionKeys.ADD_SUBFOLDER;\n\t\t}\n\n\t\tBoolean hasPermission = StagingPermissionUtil.hasPermission(\n\t\t\tpermissionChecker, dlFolder.getGroupId(), DLFolder.class.getName(),\n\t\t\tdlFolder.getFolderId(), PortletKeys.DOCUMENT_LIBRARY, actionId);\n\n\t\tif (hasPermission != null) {\n\t\t\treturn hasPermission.booleanValue();\n\t\t}\n\n\t\tif (actionId.equals(ActionKeys.VIEW) &&\n\t\t\tPropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\n\t\t\ttry {\n\t\t\t\tlong dlFolderId = dlFolder.getFolderId();\n\n\t\t\t\twhile (dlFolderId !=\n\t\t\t\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\t\tdlFolder = DLFolderLocalServiceUtil.getFolder(dlFolderId);\n\n\t\t\t\t\tif (!_hasPermission(\n\t\t\t\t\t\t\tpermissionChecker, dlFolder, actionId)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdlFolderId = dlFolder.getParentFolderId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t\tif (!dlFolder.isInTrash()) {\n\t\t\t\t\tthrow nsfe;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn _hasPermission(permissionChecker, dlFolder, actionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, MBCategory category,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.ADD_CATEGORY)) {\n\t\t\tactionId = ActionKeys.ADD_SUBCATEGORY;\n\t\t}\n\n\t\tif (MBBanLocalServiceUtil.hasBan(\n\t\t\t\tcategory.getGroupId(), permissionChecker.getUserId())) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tlong categoryId = category.getCategoryId();\n\n\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\tlong originalCategoryId = categoryId;\n\n\t\t\ttry {\n\t\t\t\twhile (categoryId !=\n\t\t\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t\t\tcategory = MBCategoryLocalServiceUtil.getCategory(\n\t\t\t\t\t\tcategoryId);\n\n\t\t\t\t\tif (!_hasPermission(\n\t\t\t\t\t\t\tpermissionChecker, category, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tcategoryId = category.getParentCategoryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t\tif (!category.isInTrash()) {\n\t\t\t\t\tthrow nsce;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcategoryId = originalCategoryId;\n\t\t}\n\n\t\ttry {\n\t\t\twhile (categoryId !=\n\t\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t\tcategory = MBCategoryLocalServiceUtil.getCategory(categoryId);\n\n\t\t\t\tif (_hasPermission(permissionChecker, category, actionId)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tcategoryId = category.getParentCategoryId();\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\tif (!category.isInTrash()) {\n\t\t\t\tthrow nsce;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":9165,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, MBCategory category,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (actionId.equals(ActionKeys.ADD_CATEGORY)) {\n\t\t\tactionId = ActionKeys.ADD_SUBCATEGORY;\n\t\t}\n\n\t\tif (MBBanLocalServiceUtil.hasBan(\n\t\t\t\tcategory.getGroupId(), permissionChecker.getUserId())) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (actionId.equals(ActionKeys.VIEW) &&\n\t\t\tPropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\n\t\t\ttry {\n\t\t\t\tlong categoryId = category.getCategoryId();\n\n\t\t\t\twhile (categoryId !=\n\t\t\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t\t\tcategory = MBCategoryLocalServiceUtil.getCategory(\n\t\t\t\t\t\tcategoryId);\n\n\t\t\t\t\tif (!_hasPermission(\n\t\t\t\t\t\t\tpermissionChecker, category, actionId)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tcategoryId = category.getParentCategoryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t\tif (!category.isInTrash()) {\n\t\t\t\t\tthrow nsce;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn _hasPermission(permissionChecker, category, actionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, MBMessage message,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong groupId = message.getGroupId();\n\n\t\tif (message.isPending()) {\n\t\t\tBoolean hasPermission = WorkflowPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, message.getGroupId(),\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\tactionId);\n\n\t\t\tif (hasPermission != null) {\n\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t}\n\t\t}\n\n\t\tif (MBBanLocalServiceUtil.hasBan(\n\t\t\t\tgroupId, permissionChecker.getUserId())) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tlong categoryId = message.getCategoryId();\n\n\t\tif ((categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(categoryId != MBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\ttry {\n\t\t\t\tMBCategory category = MBCategoryLocalServiceUtil.getCategory(\n\t\t\t\t\tcategoryId);\n\n\t\t\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\t\t\tif (!MBCategoryPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, category, ActionKeys.VIEW)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (MBCategoryPermission.contains(\n\t\t\t\t\t\tpermissionChecker, category, actionId)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t\tif (!message.isInTrashThread()) {\n\t\t\t\t\tthrow nsce;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tmessage.getRootMessageId(), message.getUserId(), actionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId, MBMessage.class.getName(), message.getMessageId(),\n\t\t\tactionId);\n\t}","id":9166,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, MBMessage message,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong groupId = message.getGroupId();\n\n\t\tif (message.isPending()) {\n\t\t\tBoolean hasPermission = WorkflowPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, message.getGroupId(),\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\tactionId);\n\n\t\t\tif (hasPermission != null) {\n\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t}\n\t\t}\n\n\t\tif (MBBanLocalServiceUtil.hasBan(\n\t\t\t\tgroupId, permissionChecker.getUserId())) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (actionId.equals(ActionKeys.VIEW) &&\n\t\t\tPropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\n\t\t\tlong categoryId = message.getCategoryId();\n\n\t\t\tif ((categoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t\t(categoryId != MBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\t\ttry {\n\t\t\t\t\tMBCategory category =\n\t\t\t\t\t\tMBCategoryLocalServiceUtil.getCategory(categoryId);\n\n\t\t\t\t\tif (!MBCategoryPermission.contains(\n\t\t\t\t\t\t\tpermissionChecker, category, actionId)) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t\t\tif (!message.isInTrashThread()) {\n\t\t\t\t\t\tthrow nsce;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (permissionChecker.hasOwnerPermission(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tmessage.getRootMessageId(), message.getUserId(), actionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId, MBMessage.class.getName(), message.getMessageId(),\n\t\t\tactionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\tPermissionChecker permissionChecker, WikiPage page, String actionId) {\n\n\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\tWikiPage redirectPage = page.getRedirectPage();\n\n\t\t\tif (redirectPage != null) {\n\t\t\t\tpage = redirectPage;\n\t\t\t}\n\t\t}\n\n\t\tWikiNode node = page.getNode();\n\n\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\tWikiPage originalPage = page;\n\n\t\t\tif (!WikiNodePermission.contains(\n\t\t\t\t\tpermissionChecker, node, ActionKeys.VIEW)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\twhile (page != null) {\n\t\t\t\tif (!_hasPermission(permissionChecker, page, ActionKeys.VIEW)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tpage = page.getParentPage();\n\t\t\t}\n\n\t\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpage = originalPage;\n\t\t}\n\n\t\tif (WikiNodePermission.contains(permissionChecker, node, actionId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\twhile (page != null) {\n\t\t\tif (page.isPending()) {\n\t\t\t\tBoolean hasPermission = WorkflowPermissionUtil.hasPermission(\n\t\t\t\t\tpermissionChecker, page.getGroupId(),\n\t\t\t\t\tWikiPage.class.getName(), page.getResourcePrimKey(),\n\t\t\t\t\tactionId);\n\n\t\t\t\tif ((hasPermission != null) && hasPermission.booleanValue()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page.isDraft() && actionId.equals(ActionKeys.DELETE) &&\n\t\t\t\t(page.getStatusByUserId() == permissionChecker.getUserId())) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (_hasPermission(permissionChecker, page, actionId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tpage = page.getParentPage();\n\t\t}\n\n\t\treturn false;\n\t}","id":9167,"modified_method":"public static boolean contains(\n\t\tPermissionChecker permissionChecker, WikiPage page, String actionId) {\n\n\t\tif (actionId.equals(ActionKeys.VIEW)) {\n\t\t\tWikiPage redirectPage = page.getRedirectPage();\n\n\t\t\tif (redirectPage != null) {\n\t\t\t\tpage = redirectPage;\n\t\t\t}\n\n\t\t\tif (PropsValues.PERMISSIONS_VIEW_DYNAMIC_INHERITANCE) {\n\t\t\t\tWikiNode node = page.getNode();\n\n\t\t\t\tif (!WikiNodePermission.contains(\n\t\t\t\t\t\tpermissionChecker, node, actionId)) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\twhile (page != null) {\n\t\t\t\t\tif (!_hasPermission(permissionChecker, page, actionId)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tpage = page.getParentPage();\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (page.isPending()) {\n\t\t\tBoolean hasPermission = WorkflowPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, page.getGroupId(), WikiPage.class.getName(),\n\t\t\t\tpage.getResourcePrimKey(), actionId);\n\n\t\t\tif ((hasPermission != null) && hasPermission.booleanValue()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (page.isDraft() && actionId.equals(ActionKeys.DELETE) &&\n\t\t\t(page.getStatusByUserId() == permissionChecker.getUserId())) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn _hasPermission(permissionChecker, page, actionId);\n\t}","commit_id":"8eb91f25cbaa75361cb087d69cf30328508c8342","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void flushAndCloseRAF(RandomAccessFile file) {\n\t\ttry {\n\t\t\tif (file != null)\n\t\t\t\tfile.getChannel().force(true);\n\t\t} catch (IOException e) {\n\t\t\t// ignore\n\t\t}\n\t\tcloseRAF(file, false);\n\t}","id":9168,"modified_method":"private static void flushAndCloseRAF(RandomAccessFile file) {\n\t\ttry {\n\t\t\tif (file != null)\n\t\t\t\tfile.getFD().sync();\n\t\t} catch (IOException e) {\n\t\t\t// ignore\n\t\t}\n\t\tcloseRAF(file, false);\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Initializes the datastore\n\t * \n\t * @param env\n\t *            Berkeley DB {@link Environment}.\n\t * @param prefix\n\t *            Database name prefix\n\t * @param storeFile\n\t *            Store file, where the actual data are stored\n\t * @param lruFile\n\t *            LRU data file, flat file store for recovery\n\t * @param keysFile\n\t *            Keys data file, flat file store for recovery, created only if\n\t *            <code>callback.storeFullKeys()<\/code> is <code>true<\/code>\n\t * @param fixSecondaryFile\n\t *            Flag file. Created when secondary database error occur. If\n\t *            this file exist on start, delete it and recreate the secondary\n\t *            database.\n\t * @param maxChkBlocks\n\t *            maximum number of blocks\n\t * @param wipe\n\t *            If <code>true<\/code>, wipe and reconstruct the database.\n\t * @param storeShutdownHook\n\t *            {@link SemiOrderedShutdownHook} for hooking database shutdown\n\t *            hook.\n\t * @param reconstructFile\n\t *            Flag file. Created when database crash.\n\t * @param callback\n\t *            {@link StoreCallback} object for this store.\n\t * @throws IOException\n\t * @throws DatabaseException\n\t */\n\tprivate BerkeleyDBFreenetStore(Environment env, String prefix, File storeFile, File lruFile, File keysFile,\n\t\t\tFile fixSecondaryFile, long maxChkBlocks, boolean wipe, SemiOrderedShutdownHook storeShutdownHook,\n\t\t\tFile reconstructFile,\n\t\t\tStoreCallback callback, RandomSource random) throws IOException, DatabaseException {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tlogDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\t\n\t\tthis.random = random;\n\t\tthis.environment = env;\n\t\tthis.name = prefix;\n\t\tthis.fixSecondaryFile = fixSecondaryFile;\n\t\tthis.maxBlocksInStore = maxChkBlocks;\n\t\tthis.reconstructFile = reconstructFile;\n\t\tthis.callback = callback;\n\t\tthis.collisionPossible = callback.collisionPossible();\n\t\tthis.dataBlockSize = callback.dataLength();\n\t\tthis.headerBlockSize = callback.headerLength();\n\t\tthis.keyLength = callback.fullKeyLength();\n\t\tcallback.setStore(this);\n\t\t\n\t\tOOMHandler.addOOMHook(this);\n\n\t\tthis.freeBlocks = new SortedLongSet();\n\n\t\t// Delete old database(s).\n\t\tif (wipe) {\n\t\t\tSystem.err.println(\"Wiping old database for \" + prefix);\n\t\t\twipeOldDatabases(environment, prefix);\n\t\t}\n\n\t\t// Initialize CHK database\n\t\tDatabaseConfig dbConfig = new DatabaseConfig();\n\t\tdbConfig.setAllowCreate(true);\n\t\tdbConfig.setTransactional(true);\n\n\t\tkeysDB = environment.openDatabase(null,prefix+\"CHK\",dbConfig);\n\t\tSystem.err.println(\"Opened main database for \"+prefix);\n\n\t\tif(fixSecondaryFile.exists()) {\n\t\t\tfixSecondaryFile.delete();\n\t\t\tremoveSecondaryDatabase();\n\t\t}\n\n\t\tstoreBlockTupleBinding = new StoreBlockTupleBinding();\n\n\t\t// Initialize secondary CHK database sorted on accesstime\n\t\taccessTimeDB = openSecondaryDataBase(prefix + \"CHK_accessTime\", keysDB.count() == 0 || wipe, wipe, true, new AccessTimeKeyCreator(\n\t\t\t\tstoreBlockTupleBinding));\n\n\t\t// Initialize other secondary database sorted on block number\n\t\tblockNumDB = openSecondaryDataBase(prefix + \"CHK_blockNum\", keysDB.count() == 0 || wipe, wipe, false, new BlockNumberKeyCreator(\n\t\t\t\tstoreBlockTupleBinding));\n\n\t\t// Initialize the store file\n\t\ttry {\n\t\t\tif(!storeFile.exists())\n\t\t\t\tif(!storeFile.createNewFile())\n\t\t\t\t\tthrow new IOException(\"Can't create a new file \" + storeFile + \" !\");\n\t\t\tstoreRAF = new RandomAccessFile(storeFile,\"rw\");\n\t\t\tstoreFC = storeRAF.getChannel();\n\n\t\t\tif(!lruFile.exists()) \n\t\t\t\tif(!lruFile.createNewFile())\n\t\t\t\t\tthrow new IOException(\"Can't create a new file \" + lruFile + \" !\");\n\t\t\tlruRAF = new RandomAccessFile(lruFile,\"rw\");\n\t\t\tlruFC = lruRAF.getChannel();\n\n\t\t\tif(keysFile != null) {\n\t\t\t\tif(!keysFile.exists())\n\t\t\t\t\tif(!keysFile.createNewFile())\n\t\t\t\t\t\tthrow new IOException(\"Can't create a new file \" + keysFile + \" !\");\n\t\t\t\tkeysRAF = new RandomAccessFile(keysFile,\"rw\");\n\t\t\t\tkeysFC = keysRAF.getChannel();\n\t\t\t} else keysRAF = null;\n\n\t\t\tif (wipe) {\n                                // wipe and reconstruct\n\t\t\t\tblocksInStore = 0;\n\t\t\t\tlastRecentlyUsed = 0;\n\n\t\t\t\treconstruct();\n\n\t\t\t\tblocksInStore = countCHKBlocksFromFile();\n\t\t\t\tlastRecentlyUsed = getMaxRecentlyUsed();\n\n\t\t\t\tmaybeOfflineShrink(true);\n\t\t\t} else {\n                                // just open\n                                boolean dontCheckForHolesShrinking = false;\n\n                                long chkBlocksInDatabase = highestBlockNumberInDatabase();\n                                blocksInStore = chkBlocksInDatabase;\n\t\t\t\tlong chkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\t\tlastRecentlyUsed = getMaxRecentlyUsed();\n\n\t\t\t\tSystem.out.println(\"Keys in store: db \"+chkBlocksInDatabase+\" file \"+chkBlocksFromFile+\" / max \"+maxChkBlocks);\n\n\t\t\t\tif(chkBlocksInDatabase > chkBlocksFromFile) {\n\t\t\t\t\tSystem.out.println(\"More keys in database than in store!\");\n\n\t\t\t\t\t//throw new DatabaseException(\"More keys in database than in store!\");\n\t\t\t\t\t// FIXME reinstate if handling code doesn't work\n\t\t\t\t\t// FIXME we can do a cleverer recovery: Find all keys whose block number is > chkBlocksFromFile and delete them\n\t\t\t\t}\n\n\t\t\t\tif(((blocksInStore == 0) && (chkBlocksFromFile != 0)) ||\n                                            (((blocksInStore + 10) * 1.1) < chkBlocksFromFile)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclose(false);\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLogger.error(this, \"Failed to close: \"+t, t);\n\t\t\t\t\t\tSystem.err.println(\"Failed to close: \"+t);\n\t\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new DatabaseException(\"Keys in database: \"+blocksInStore+\" but keys in file: \"+chkBlocksFromFile);\n\t\t\t\t}\n\n\t\t\t\tblocksInStore = Math.max(blocksInStore, chkBlocksFromFile);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Keys in store: \"+blocksInStore);\n\n\t\t\t\tmaybeOfflineShrink(dontCheckForHolesShrinking);\n\t\t\t\tchkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\t\tblocksInStore = Math.max(blocksInStore, chkBlocksFromFile);\n\t\t\t\t}\n\n\t\t\t// Add shutdownhook\n\t\t\tstoreShutdownHook.addEarlyJob(new ShutdownHook());\n\t\t} catch (DatabaseException t) {\n\t\t\tLogger.error(this, \"Caught exception, closing database: \" + prefix, t);\n\t\t\tSystem.err.println(\"Caught exception, closing database: \" + prefix + \" (\" + t + \")\");\n\t\t\tt.printStackTrace();\n\t\t\tclose(false);\n\t\t\t\n\t\t\tthrow t;\n\t\t} catch (IOException t) {\n\t\t\tSystem.err.println(\"Caught exception, closing database: \" + prefix + \" (\" + t + \")\");\n\t\t\tLogger.error(this, \"Caught exception, closing database: \" + prefix, t);\n\t\t\tclose(false);\n\t\t\t\n\t\t\tthrow t;\n\t\t}\n\t}","id":9169,"modified_method":"/**\n\t * Initializes the datastore\n\t * \n\t * @param env\n\t *            Berkeley DB {@link Environment}.\n\t * @param prefix\n\t *            Database name prefix\n\t * @param storeFile\n\t *            Store file, where the actual data are stored\n\t * @param lruFile\n\t *            LRU data file, flat file store for recovery\n\t * @param keysFile\n\t *            Keys data file, flat file store for recovery, created only if\n\t *            <code>callback.storeFullKeys()<\/code> is <code>true<\/code>\n\t * @param fixSecondaryFile\n\t *            Flag file. Created when secondary database error occur. If\n\t *            this file exist on start, delete it and recreate the secondary\n\t *            database.\n\t * @param maxChkBlocks\n\t *            maximum number of blocks\n\t * @param wipe\n\t *            If <code>true<\/code>, wipe and reconstruct the database.\n\t * @param storeShutdownHook\n\t *            {@link SemiOrderedShutdownHook} for hooking database shutdown\n\t *            hook.\n\t * @param reconstructFile\n\t *            Flag file. Created when database crash.\n\t * @param callback\n\t *            {@link StoreCallback} object for this store.\n\t * @throws IOException\n\t * @throws DatabaseException\n\t */\n\tprivate BerkeleyDBFreenetStore(Environment env, String prefix, File storeFile, File lruFile, File keysFile,\n\t\t\tFile fixSecondaryFile, long maxChkBlocks, boolean wipe, SemiOrderedShutdownHook storeShutdownHook,\n\t\t\tFile reconstructFile,\n\t\t\tStoreCallback callback, RandomSource random) throws IOException, DatabaseException {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tlogDEBUG = Logger.shouldLog(Logger.DEBUG, this);\n\t\t\n\t\tthis.random = random;\n\t\tthis.environment = env;\n\t\tthis.name = prefix;\n\t\tthis.fixSecondaryFile = fixSecondaryFile;\n\t\tthis.maxBlocksInStore = maxChkBlocks;\n\t\tthis.reconstructFile = reconstructFile;\n\t\tthis.callback = callback;\n\t\tthis.collisionPossible = callback.collisionPossible();\n\t\tthis.dataBlockSize = callback.dataLength();\n\t\tthis.headerBlockSize = callback.headerLength();\n\t\tthis.keyLength = callback.fullKeyLength();\n\t\tcallback.setStore(this);\n\t\t\n\t\tOOMHandler.addOOMHook(this);\n\n\t\tthis.freeBlocks = new SortedLongSet();\n\n\t\t// Delete old database(s).\n\t\tif (wipe) {\n\t\t\tSystem.err.println(\"Wiping old database for \" + prefix);\n\t\t\twipeOldDatabases(environment, prefix);\n\t\t}\n\n\t\t// Initialize CHK database\n\t\tDatabaseConfig dbConfig = new DatabaseConfig();\n\t\tdbConfig.setAllowCreate(true);\n\t\tdbConfig.setTransactional(true);\n\n\t\tkeysDB = environment.openDatabase(null,prefix+\"CHK\",dbConfig);\n\t\tSystem.err.println(\"Opened main database for \"+prefix);\n\n\t\tif(fixSecondaryFile.exists()) {\n\t\t\tfixSecondaryFile.delete();\n\t\t\tremoveSecondaryDatabase();\n\t\t}\n\n\t\tstoreBlockTupleBinding = new StoreBlockTupleBinding();\n\n\t\t// Initialize secondary CHK database sorted on accesstime\n\t\taccessTimeDB = openSecondaryDataBase(prefix + \"CHK_accessTime\", keysDB.count() == 0 || wipe, wipe, true, new AccessTimeKeyCreator(\n\t\t\t\tstoreBlockTupleBinding));\n\n\t\t// Initialize other secondary database sorted on block number\n\t\tblockNumDB = openSecondaryDataBase(prefix + \"CHK_blockNum\", keysDB.count() == 0 || wipe, wipe, false, new BlockNumberKeyCreator(\n\t\t\t\tstoreBlockTupleBinding));\n\n\t\t// Initialize the store file\n\t\ttry {\n\t\t\tif(!storeFile.exists())\n\t\t\t\tif(!storeFile.createNewFile())\n\t\t\t\t\tthrow new IOException(\"Can't create a new file \" + storeFile + \" !\");\n\t\t\tstoreRAF = new RandomAccessFile(storeFile,\"rw\");\n\n\t\t\tif(!lruFile.exists()) \n\t\t\t\tif(!lruFile.createNewFile())\n\t\t\t\t\tthrow new IOException(\"Can't create a new file \" + lruFile + \" !\");\n\t\t\tlruRAF = new RandomAccessFile(lruFile,\"rw\");\n\n\t\t\tif(keysFile != null) {\n\t\t\t\tif(!keysFile.exists())\n\t\t\t\t\tif(!keysFile.createNewFile())\n\t\t\t\t\t\tthrow new IOException(\"Can't create a new file \" + keysFile + \" !\");\n\t\t\t\tkeysRAF = new RandomAccessFile(keysFile,\"rw\");\n\t\t\t} else keysRAF = null;\n\n\t\t\tif (wipe) {\n                                // wipe and reconstruct\n\t\t\t\tblocksInStore = 0;\n\t\t\t\tlastRecentlyUsed = 0;\n\n\t\t\t\treconstruct();\n\n\t\t\t\tblocksInStore = countCHKBlocksFromFile();\n\t\t\t\tlastRecentlyUsed = getMaxRecentlyUsed();\n\n\t\t\t\tmaybeOfflineShrink(true);\n\t\t\t} else {\n                                // just open\n                                boolean dontCheckForHolesShrinking = false;\n\n                                long chkBlocksInDatabase = highestBlockNumberInDatabase();\n                                blocksInStore = chkBlocksInDatabase;\n\t\t\t\tlong chkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\t\tlastRecentlyUsed = getMaxRecentlyUsed();\n\n\t\t\t\tSystem.out.println(\"Keys in store: db \"+chkBlocksInDatabase+\" file \"+chkBlocksFromFile+\" / max \"+maxChkBlocks);\n\n\t\t\t\tif(chkBlocksInDatabase > chkBlocksFromFile) {\n\t\t\t\t\tSystem.out.println(\"More keys in database than in store!\");\n\n\t\t\t\t\t//throw new DatabaseException(\"More keys in database than in store!\");\n\t\t\t\t\t// FIXME reinstate if handling code doesn't work\n\t\t\t\t\t// FIXME we can do a cleverer recovery: Find all keys whose block number is > chkBlocksFromFile and delete them\n\t\t\t\t}\n\n\t\t\t\tif(((blocksInStore == 0) && (chkBlocksFromFile != 0)) ||\n                                            (((blocksInStore + 10) * 1.1) < chkBlocksFromFile)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclose(false);\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\tLogger.error(this, \"Failed to close: \"+t, t);\n\t\t\t\t\t\tSystem.err.println(\"Failed to close: \"+t);\n\t\t\t\t\t\tt.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new DatabaseException(\"Keys in database: \"+blocksInStore+\" but keys in file: \"+chkBlocksFromFile);\n\t\t\t\t}\n\n\t\t\t\tblocksInStore = Math.max(blocksInStore, chkBlocksFromFile);\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Keys in store: \"+blocksInStore);\n\n\t\t\t\tmaybeOfflineShrink(dontCheckForHolesShrinking);\n\t\t\t\tchkBlocksFromFile = countCHKBlocksFromFile();\n\t\t\t\tblocksInStore = Math.max(blocksInStore, chkBlocksFromFile);\n\t\t\t\t}\n\n\t\t\t// Add shutdownhook\n\t\t\tstoreShutdownHook.addEarlyJob(new ShutdownHook());\n\t\t} catch (DatabaseException t) {\n\t\t\tLogger.error(this, \"Caught exception, closing database: \" + prefix, t);\n\t\t\tSystem.err.println(\"Caught exception, closing database: \" + prefix + \" (\" + t + \")\");\n\t\t\tt.printStackTrace();\n\t\t\tclose(false);\n\t\t\t\n\t\t\tthrow t;\n\t\t} catch (IOException t) {\n\t\t\tSystem.err.println(\"Caught exception, closing database: \" + prefix + \" (\" + t + \")\");\n\t\t\tLogger.error(this, \"Caught exception, closing database: \" + prefix, t);\n\t\t\tclose(false);\n\t\t\t\n\t\t\tthrow t;\n\t\t}\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic StorableBlock fetch(byte[] routingkey, byte[] fullKey, boolean dontPromote) throws IOException {\n\t\tDatabaseEntry routingkeyDBE = new DatabaseEntry(routingkey);\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tint running;\n\t\tsynchronized(this) {\n\t\t\tif(closed)\n\t\t\t\treturn null;\n\t\t\trunning = runningFetches++;\n\t\t}\n\t\t\n\t\tCursor c = null;\n\t\tTransaction t = null;\n\t\ttry {\n\t\t\tt = environment.beginTransaction(null,null);\n\t\t\tc = keysDB.openCursor(t,null);\n\t\t\t\n\t\t\t/**\n\t\t\t* We will have to write, unless both dontPromote and the key is valid.\n\t\t\t* The lock only applies to this record, so it's not a big problem for our use.\n\t\t\t* What *IS* a big problem is that if we take a LockMode.DEFAULT, and two threads\n\t\t\t* access the same key, they will both take the read lock, and then both try to\n\t\t\t* take the write lock. Neither can relinquish the read in order for the other to\n\t\t\t* take the write, so we're screwed.\n\t\t\t*/\n\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+HexUtil.bytesToHex(routingkey)+\" dontPromote=\"+dontPromote+\" for \"+callback+\" running fetches: \"+running);\n\t\t\tif(c.getSearchKey(routingkeyDBE,blockDBE,LockMode.RMW)\n\t\t\t\t\t!=OperationStatus.SUCCESS) {\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\tt.abort();\n\t\t\t\tt = null;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tmisses++;\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not found\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tStoreBlock storeBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\t\t\t\n\t\t\tStorableBlock block = null;\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Reading block \"+storeBlock.offset+\"...\");\n\t\t\ttry {\n\t\t\t\tbyte[] header = new byte[headerBlockSize];\n\t\t\t\tbyte[] data = new byte[dataBlockSize];\n\t\t\t\ttry {\n\t\t\t\t\tfcReadStore(storeBlock.offset, header, data);\n\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\tLogger.error(this, \"No block\");\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tkeysDB.delete(t, routingkeyDBE);\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\taddFreeBlock(storeBlock.offset, true, \"Data off end of store file\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tblock = callback.construct(data, header, routingkey, fullKey);\n\t\t\t\t\n\t\t\t\tif(!Arrays.equals(block.getRoutingKey(), routingkey)) {\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\tmisses++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tkeysDB.delete(t, routingkeyDBE);\n\t\t\t\t\t\n\t\t\t\t\t// Insert the block into the index.\n\t\t\t\t\t// Set the LRU to minimum - 1.\n\t\t\t\t\t\n\t\t\t\t\tlong lru = getMinRecentlyUsed(t) - 1;\n\t\t\t\t\t\n\t\t\t\t\tLogger.normal(this, \"Does not verify (not the expected key), setting accessTime to \"+lru+\" for : \"+HexUtil.bytesToHex(routingkey));\n\t\t\t\t\t\n\t\t\t\t\tstoreBlock = new StoreBlock(storeBlock.offset, lru);\n\t\t\t\t\t\n\t\t\t\t\troutingkeyDBE = new DatabaseEntry(block.getRoutingKey());\n\t\t\t\t\t\n\t\t\t\t\tblockDBE = new DatabaseEntry();\n\t\t\t\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t\t\t\t\tif(fullKey == null)\n\t\t\t\t\t\t\tfullKey = block.getFullKey();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(keysRAF != null) {\n\t\t\t\t\t\t\t\tfcWriteKey(storeBlock.offset, fullKey);\n\t\t\t\t\t\t\t\tif(logDEBUG)\n\t\t\t\t\t\t\t\t\tLogger.debug(this, \"Written full key length \"+fullKey.length+\" to block \"+storeBlock.offset+\" at \"+(storeBlock.offset * keyLength)+\" for \"+callback);\n\t\t\t\t\t\t\t} else if(logDEBUG) {\n\t\t\t\t\t\t\t\tLogger.debug(this, \"Not writing full key length \"+fullKey.length+\" for block \"+storeBlock.offset+\" for \"+callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (DatabaseException e) {\n\t\t\t\t\t\tLogger.error(this, \"Caught database exception \"+e+\" while replacing element\");\n\t\t\t\t\t\taddFreeBlock(storeBlock.offset, true, \"Bogus key\");\n\t\t\t\t\t\tc.close();\n\t\t\t\t\t\tc = null;\n\t\t\t\t\t\tt.commit();\n\t\t\t\t\t\tt = null;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tLogger.normal(this, \"Successfully replaced entry at block number \"+storeBlock.offset+\" lru \"+lru);\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!dontPromote) {\n\t\t\t\t\tstoreBlock.updateRecentlyUsed();\n\t\t\t\t\tDatabaseEntry updateDBE = new DatabaseEntry();\n\t\t\t\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, updateDBE);\n\t\t\t\t\tc.putCurrent(updateDBE);\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\tfcWriteLRU(storeBlock.offset, storeBlock.recentlyUsed);\n\t\t\t\t} else {\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.abort();\n\t\t\t\t\tt = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Headers: \" + header.length+\" bytes, hash \" + Fields.hashCode(header));\n\t\t\t\t\tLogger.minor(this, \"Data: \" + data.length + \" bytes, hash \" + Fields.hashCode(data) + \" fetching \" + HexUtil.bytesToHex(routingkey));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} catch(KeyVerifyException ex) {\n\t\t\t\tLogger.normal(this, \"Does not verify (\"+ex+\"), setting accessTime to 0 for : \"+HexUtil.bytesToHex(routingkey), ex);\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tmisses++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t// Clear the key in the keys file.\n\t\t\t\t\tbyte[] buf = new byte[keyLength];\n\t\t\t\t\tfor(int i=0;i<buf.length;i++) buf[i] = 0; // FIXME unnecessary?\n\t\t\t\t\tif(keysRAF != null) {\n\t\t\t\t\t\tfcWriteKey(storeBlock.offset, buf);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkeysDB.delete(t, routingkeyDBE);\n\t\t\t\t\n\t\t\t\t// Insert the block into the index with a random key, so that it's part of the LRU.\n\t\t\t\t// Set the LRU to minimum - 1.\n\t\t\t\t\n\t\t\t\tlong lru = getMinRecentlyUsed(t) - 1;\n\t\t\t\t\n\t\t\t\tbyte[] randomKey = new byte[keyLength];\n\t\t\t\trandom.nextBytes(randomKey);\n\t\t\t\t\n\t\t\t\tstoreBlock = new StoreBlock(storeBlock.offset, lru);\n\t\t\t\t\n\t\t\t\troutingkeyDBE = new DatabaseEntry(randomKey);\n\t\t\t\t\n\t\t\t\tblockDBE = new DatabaseEntry();\n\t\t\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\t\t\ttry {\n\t\t\t\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t\t\t} catch (DatabaseException e) {\n\t\t\t\t\tLogger.error(this, \"Caught database exception \"+e+\" while adding corrupt element to LRU\");\n\t\t\t\t\taddFreeBlock(storeBlock.offset, true, \"Bogus key\");\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\tt.commit();\n\t\t\t\tt = null;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tsynchronized(this) {\n\t\t\t\thits++;\n\t\t\t}\n\t\t\treturn block;\n\t\t} catch(Throwable ex) {  // FIXME: ugly\n\t\t\tif(ex instanceof IOException) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(closed) return null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c!=null) {\n\t\t\t\ttry{c.close();}catch(DatabaseException ex2){}\n\t\t\t}\n\t\t\tif(t!=null) {\n\t\t\t\ttry{t.abort();}catch(DatabaseException ex2){}\n\t\t\t}\n\t\t\tcheckSecondaryDatabaseError(ex);\n\t\t\tLogger.error(this, \"Caught \"+ex, ex);\n\t\t\tex.printStackTrace();\n\t\t\tthrow new IOException(ex.getMessage());\n\t\t} finally {\n\t\t\tint x;\n\t\t\tsynchronized(this) {\n\t\t\t\tx = runningFetches--;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Running fetches now \"+x);\n\t\t}\n\t}","id":9170,"modified_method":"/**\n\t * {@inheritDoc}\n\t */\n\tpublic StorableBlock fetch(byte[] routingkey, byte[] fullKey, boolean dontPromote) throws IOException {\n\t\tDatabaseEntry routingkeyDBE = new DatabaseEntry(routingkey);\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tint running;\n\t\tsynchronized(this) {\n\t\t\tif(closed)\n\t\t\t\treturn null;\n\t\t\trunning = runningFetches++;\n\t\t}\n\t\t\n\t\tCursor c = null;\n\t\tTransaction t = null;\n\t\ttry {\n\t\t\tt = environment.beginTransaction(null,null);\n\t\t\tc = keysDB.openCursor(t,null);\n\t\t\t\n\t\t\t/**\n\t\t\t* We will have to write, unless both dontPromote and the key is valid.\n\t\t\t* The lock only applies to this record, so it's not a big problem for our use.\n\t\t\t* What *IS* a big problem is that if we take a LockMode.DEFAULT, and two threads\n\t\t\t* access the same key, they will both take the read lock, and then both try to\n\t\t\t* take the write lock. Neither can relinquish the read in order for the other to\n\t\t\t* take the write, so we're screwed.\n\t\t\t*/\n\t\t\tif(logMINOR) Logger.minor(this, \"Fetching \"+HexUtil.bytesToHex(routingkey)+\" dontPromote=\"+dontPromote+\" for \"+callback+\" running fetches: \"+running);\n\t\t\tif(c.getSearchKey(routingkeyDBE,blockDBE,LockMode.RMW)\n\t\t\t\t\t!=OperationStatus.SUCCESS) {\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\tt.abort();\n\t\t\t\tt = null;\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tmisses++;\n\t\t\t\t}\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Not found\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tStoreBlock storeBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\t\t\t\n\t\t\tStorableBlock block = null;\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Reading block \"+storeBlock.offset+\"...\");\n\t\t\ttry {\n\t\t\t\tbyte[] header = new byte[headerBlockSize];\n\t\t\t\tbyte[] data = new byte[dataBlockSize];\n\t\t\t\ttry {\n\t\t\t\t\tsynchronized(storeRAF) {\n\t\t\t\t\t\tstoreRAF.seek(storeBlock.offset*(long)(dataBlockSize+headerBlockSize));\n\t\t\t\t\t\tstoreRAF.readFully(header);\n\t\t\t\t\t\tstoreRAF.readFully(data);\n\t\t\t\t\t}\n\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\tLogger.error(this, \"No block\");\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tkeysDB.delete(t, routingkeyDBE);\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\taddFreeBlock(storeBlock.offset, true, \"Data off end of store file\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tblock = callback.construct(data, header, routingkey, fullKey);\n\t\t\t\t\n\t\t\t\tif(!Arrays.equals(block.getRoutingKey(), routingkey)) {\n\t\t\t\t\t\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\tmisses++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tkeysDB.delete(t, routingkeyDBE);\n\t\t\t\t\t\n\t\t\t\t\t// Insert the block into the index.\n\t\t\t\t\t// Set the LRU to minimum - 1.\n\t\t\t\t\t\n\t\t\t\t\tlong lru = getMinRecentlyUsed(t) - 1;\n\t\t\t\t\t\n\t\t\t\t\tLogger.normal(this, \"Does not verify (not the expected key), setting accessTime to \"+lru+\" for : \"+HexUtil.bytesToHex(routingkey));\n\t\t\t\t\t\n\t\t\t\t\tstoreBlock = new StoreBlock(storeBlock.offset, lru);\n\t\t\t\t\t\n\t\t\t\t\troutingkeyDBE = new DatabaseEntry(block.getRoutingKey());\n\t\t\t\t\t\n\t\t\t\t\tblockDBE = new DatabaseEntry();\n\t\t\t\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t\t\t\t\tif(fullKey == null)\n\t\t\t\t\t\t\tfullKey = block.getFullKey();\n\t\t\t\t\t\tsynchronized(storeRAF) {\n\t\t\t\t\t\t\tif(keysRAF != null) {\n\t\t\t\t\t\t\t\tkeysRAF.seek(storeBlock.offset * keyLength);\n\t\t\t\t\t\t\t\tkeysRAF.write(fullKey);\n\t\t\t\t\t\t\t\tif(logDEBUG)\n\t\t\t\t\t\t\t\t\tLogger.debug(this, \"Written full key length \"+fullKey.length+\" to block \"+storeBlock.offset+\" at \"+(storeBlock.offset * keyLength)+\" for \"+callback);\n\t\t\t\t\t\t\t} else if(logDEBUG) {\n\t\t\t\t\t\t\t\tLogger.debug(this, \"Not writing full key length \"+fullKey.length+\" for block \"+storeBlock.offset+\" for \"+callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (DatabaseException e) {\n\t\t\t\t\t\tLogger.error(this, \"Caught database exception \"+e+\" while replacing element\");\n\t\t\t\t\t\taddFreeBlock(storeBlock.offset, true, \"Bogus key\");\n\t\t\t\t\t\tc.close();\n\t\t\t\t\t\tc = null;\n\t\t\t\t\t\tt.commit();\n\t\t\t\t\t\tt = null;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tLogger.normal(this, \"Successfully replaced entry at block number \"+storeBlock.offset+\" lru \"+lru);\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!dontPromote) {\n\t\t\t\t\tstoreBlock.updateRecentlyUsed();\n\t\t\t\t\tDatabaseEntry updateDBE = new DatabaseEntry();\n\t\t\t\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, updateDBE);\n\t\t\t\t\tc.putCurrent(updateDBE);\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\tsynchronized(storeRAF) {\n\t\t\t\t\t\tlruRAF.seek(storeBlock.offset * 8);\n\t\t\t\t\t\tlruRAF.writeLong(storeBlock.recentlyUsed);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.abort();\n\t\t\t\t\tt = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) {\n\t\t\t\t\tLogger.minor(this, \"Headers: \" + header.length+\" bytes, hash \" + Fields.hashCode(header));\n\t\t\t\t\tLogger.minor(this, \"Data: \" + data.length + \" bytes, hash \" + Fields.hashCode(data) + \" fetching \" + HexUtil.bytesToHex(routingkey));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} catch(KeyVerifyException ex) {\n\t\t\t\tLogger.normal(this, \"Does not verify (\"+ex+\"), setting accessTime to 0 for : \"+HexUtil.bytesToHex(routingkey), ex);\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tmisses++;\n\t\t\t\t}\n\t\t\t\tsynchronized(storeRAF) {\n\t\t\t\t\t// Clear the key in the keys file.\n\t\t\t\t\tbyte[] buf = new byte[keyLength];\n\t\t\t\t\tfor(int i=0;i<buf.length;i++) buf[i] = 0; // FIXME unnecessary?\n\t\t\t\t\tif(keysRAF != null) {\n\t\t\t\t\t\tkeysRAF.seek(storeBlock.offset * keyLength);\n\t\t\t\t\t\tkeysRAF.write(buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tkeysDB.delete(t, routingkeyDBE);\n\t\t\t\t\n\t\t\t\t// Insert the block into the index with a random key, so that it's part of the LRU.\n\t\t\t\t// Set the LRU to minimum - 1.\n\t\t\t\t\n\t\t\t\tlong lru = getMinRecentlyUsed(t) - 1;\n\t\t\t\t\n\t\t\t\tbyte[] randomKey = new byte[keyLength];\n\t\t\t\trandom.nextBytes(randomKey);\n\t\t\t\t\n\t\t\t\tstoreBlock = new StoreBlock(storeBlock.offset, lru);\n\t\t\t\t\n\t\t\t\troutingkeyDBE = new DatabaseEntry(randomKey);\n\t\t\t\t\n\t\t\t\tblockDBE = new DatabaseEntry();\n\t\t\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\t\t\ttry {\n\t\t\t\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t\t\t} catch (DatabaseException e) {\n\t\t\t\t\tLogger.error(this, \"Caught database exception \"+e+\" while adding corrupt element to LRU\");\n\t\t\t\t\taddFreeBlock(storeBlock.offset, true, \"Bogus key\");\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\tt.commit();\n\t\t\t\tt = null;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tsynchronized(this) {\n\t\t\t\thits++;\n\t\t\t}\n\t\t\treturn block;\n\t\t} catch(Throwable ex) {  // FIXME: ugly\n\t\t\tif(ex instanceof IOException) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(closed) return null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c!=null) {\n\t\t\t\ttry{c.close();}catch(DatabaseException ex2){}\n\t\t\t}\n\t\t\tif(t!=null) {\n\t\t\t\ttry{t.abort();}catch(DatabaseException ex2){}\n\t\t\t}\n\t\t\tcheckSecondaryDatabaseError(ex);\n\t\t\tLogger.error(this, \"Caught \"+ex, ex);\n\t\t\tex.printStackTrace();\n\t\t\tthrow new IOException(ex.getMessage());\n\t\t} finally {\n\t\t\tint x;\n\t\t\tsynchronized(this) {\n\t\t\t\tx = runningFetches--;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Running fetches now \"+x);\n\t\t}\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"private void overwriteLRUBlock(byte[] header, byte[] data, Transaction t, DatabaseEntry routingkeyDBE, byte[] fullKey) throws DatabaseException, IOException {\n\t\t// Overwrite an other block\n\t\tCursor c = accessTimeDB.openCursor(t,null);\n\t\tStoreBlock oldStoreBlock;\n\t\ttry {\n\t\t\tDatabaseEntry keyDBE = new DatabaseEntry();\n\t\t\tDatabaseEntry dataDBE = new DatabaseEntry();\n\t\t\tc.getFirst(keyDBE,dataDBE,LockMode.RMW);\n\t\t\toldStoreBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(dataDBE);\n\t\t\tc.delete();\n\t\t} finally {\n\t\t\tc.close();\n\t\t}\n\t\t// Deleted, so we can now reuse it.\n\t\t// Because we acquired a write lock, nobody else has taken it.\n\t\t// FIXME if this fails we can leak the block??\n\t\tStoreBlock storeBlock = new StoreBlock(this, oldStoreBlock.getOffset());\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t\n\t\tfcWriteStore(storeBlock.getOffset(), header, data);\n\t\tfcWriteLRU( storeBlock.getOffset(),storeBlock.recentlyUsed);\n\t\tif (keysRAF != null)\n\t\t\tfcWriteKey(storeBlock.getOffset(), fullKey);\n\t\tsynchronized (this) {\n\t\t\twrites++;\n\t\t}\n\t}","id":9171,"modified_method":"private void overwriteLRUBlock(byte[] header, byte[] data, Transaction t, DatabaseEntry routingkeyDBE, byte[] fullKey) throws DatabaseException, IOException {\n\t\t// Overwrite an other block\n\t\tCursor c = accessTimeDB.openCursor(t,null);\n\t\tStoreBlock oldStoreBlock;\n\t\ttry {\n\t\t\tDatabaseEntry keyDBE = new DatabaseEntry();\n\t\t\tDatabaseEntry dataDBE = new DatabaseEntry();\n\t\t\tc.getFirst(keyDBE,dataDBE,LockMode.RMW);\n\t\t\toldStoreBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(dataDBE);\n\t\t\tc.delete();\n\t\t} finally {\n\t\t\tc.close();\n\t\t}\n\t\t// Deleted, so we can now reuse it.\n\t\t// Because we acquired a write lock, nobody else has taken it.\n\t\t// FIXME if this fails we can leak the block??\n\t\tStoreBlock storeBlock = new StoreBlock(this, oldStoreBlock.getOffset());\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\tsynchronized(storeRAF) {\n\t\t\tstoreRAF.seek(storeBlock.getOffset()*(long)(dataBlockSize+headerBlockSize));\n\t\t\tstoreRAF.write(header);\n\t\t\tstoreRAF.write(data);\n\t\t\tlruRAF.seek(storeBlock.getOffset() * 8);\n\t\t\tlruRAF.writeLong(storeBlock.recentlyUsed);\n\t\t\tif(keysRAF != null) {\n\t\t\t\tkeysRAF.seek(storeBlock.getOffset() * keyLength);\n\t\t\t\tkeysRAF.write(fullKey);\n\t\t\t}\n\t\t\twrites++;\n\t\t}\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"private void maybeSlowShrink(boolean dontCheckForHoles, boolean inStartUp) throws DatabaseException, IOException {\n\t\tList wantedKeep = new ArrayList(); // keep; content is wanted, and is in the right place\n\t\tList unwantedIgnore = new ArrayList(); // ignore; content is not wanted, and is not in the right place\n\t\tList wantedMove = new ArrayList(); // content is wanted, but is in the wrong part of the store\n\t\tList unwantedMove = new ArrayList(); // content is not wanted, but is in the part of the store we will keep\n\t\tList alreadyDropped = new ArrayList(); // any blocks past the end which have already been truncated, but which there are still database blocks pointing to\n\t\t\n\t\tCursor c = null;\n\t\tTransaction t = null;\n\n\t\tlong newSize = maxBlocksInStore;\n\t\tif(blocksInStore < maxBlocksInStore) return;\n\t\t\n\t\tSystem.err.println(\"Shrinking from \"+blocksInStore+\" to \"+maxBlocksInStore+\" (from db \"+keysDB.count()+\" from file \"+countCHKBlocksFromFile()+ ')');\n\t\t\n\t\tif(!dontCheckForHoles)\n\t\t\tcheckForHoles(maxBlocksInStore, true);\n\t\t\n\t\tWrapperManager.signalStarting((int) (Math.min(Integer.MAX_VALUE, 5 * 60 * 1000 + blocksInStore * 100L))); // 10 per second\n\t\t\n\t\tlong realSize = countCHKBlocksFromFile();\n\t\t\n\t\tlong highestBlock = 0;\n\t\t\n\t\ttry {\n\t\t\tc = accessTimeDB.openCursor(null,null);\n\t\t\t\n\t\t\tDatabaseEntry keyDBE = new DatabaseEntry();\n\t\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\t\tOperationStatus opStat;\n\t\t\topStat = c.getLast(keyDBE, blockDBE, LockMode.RMW);\n\t\t\t\n\t\t\tif(opStat == OperationStatus.NOTFOUND) {\n\t\t\t\tSystem.err.println(\"Database is empty (shrinking).\");\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Logger.minor(this, \"Found first key\");\n\t\t\tint x = 0;\n\t\t\twhile(true) {\n\t\t\t\tStoreBlock storeBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\tlong block = storeBlock.offset;\n\t\t\t\tif(block > highestBlock) highestBlock = block;\n\t\t\t\tif(storeBlock.offset > Integer.MAX_VALUE) {\n\t\t\t\t\t// 2^31 * blockSize; ~ 70TB for CHKs, 2TB for the others\n\t\t\t\t\tSystem.err.println(\"Store too big, doing quick shrink\"); // memory usage would be insane\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tmaybeQuickShrink(true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tInteger blockNum = new Integer((int)storeBlock.offset);\n\t\t\t\t//Long seqNum = new Long(storeBlock.recentlyUsed);\n\t\t\t\t//System.out.println(\"#\"+x+\" seq \"+seqNum+\": block \"+blockNum);\n\t\t\t\tif(blockNum.longValue() >= realSize) {\n\t\t\t\t\t// Truncated already?\n\t\t\t\t\tLogger.minor(this, \"Truncated already? \"+blockNum.longValue());\n\t\t\t\t\talreadyDropped.add(blockNum);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif(x < newSize) {\n\t\t\t\t\t\t// Wanted\n\t\t\t\t\t\tif(block < newSize) {\n\t\t\t\t\t\t\t//System.out.println(\"Keep where it is: block \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\twantedKeep.add(blockNum);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//System.out.println(\"Move to where it should go: \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\twantedMove.add(blockNum);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Unwanted\n\t\t\t\t\t\tif(block < newSize) {\n\t\t\t\t\t\t\t//System.out.println(\"Overwrite: \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\tunwantedMove.add(blockNum);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//System.out.println(\"Ignore, will be wiped: block \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\tunwantedIgnore.add(blockNum);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t\tif(x % 1024 == 0) {\n\t\t\t\t\t\tSystem.out.println(\"Reading store prior to shrink: \"+(x*100L/realSize)+ \"% ( \"+x+ '/' +realSize+ ')');\n\t\t\t\t\t}\n\t\t\t\t\tif(x == Integer.MAX_VALUE) {\n\t\t\t\t\t\tSystem.err.println(\"Key number \"+x+\" - ignoring store after \"+(x*(dataBlockSize+headerBlockSize)+\" bytes\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\topStat = c.getPrev(keyDBE, blockDBE, LockMode.RMW);\n\t\t\t\tif(opStat == OperationStatus.NOTFOUND) {\n\t\t\t\t\tSystem.out.println(\"Read store: \"+x+\" keys.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} finally {\n\t\t\tif(c != null)\n\t\t\t\tc.close();\n\t\t}\n\t\t\n\t\tInteger[] wantedKeepNums = (Integer[]) wantedKeep.toArray(new Integer[wantedKeep.size()]);\n\t\tInteger[] unwantedIgnoreNums = (Integer[]) unwantedIgnore.toArray(new Integer[unwantedIgnore.size()]);\n\t\tInteger[] wantedMoveNums = (Integer[]) wantedMove.toArray(new Integer[wantedMove.size()]);\n\t\tInteger[] unwantedMoveNums = (Integer[]) unwantedMove.toArray(new Integer[unwantedMove.size()]);\n\t\tlong[] freeEarlySlots = freeBlocks.toArray();\n\t\tArrays.sort(wantedKeepNums);\n\t\tArrays.sort(unwantedIgnoreNums);\n\t\tArrays.sort(wantedMoveNums);\n\t\tArrays.sort(unwantedMoveNums);\n\t\t\n\t\tfor(int i=0;i<newSize;i++) {\n\t\t\tInteger ii = new Integer(i);\n\t\t\tif(Arrays.binarySearch(wantedKeepNums, ii) >= 0) continue;\n\t\t\tif(Arrays.binarySearch(unwantedIgnoreNums, ii) >= 0) continue;\n\t\t\tif(Arrays.binarySearch(wantedMoveNums, ii) >= 0) continue;\n\t\t\tif(Arrays.binarySearch(unwantedMoveNums, ii) >= 0) continue;\n\t\t\tunwantedMove.add(ii);\n\t\t}\n\t\tunwantedMoveNums = (Integer[]) unwantedMove.toArray(new Integer[unwantedMove.size()]);\n\t\t\n\t\tSystem.err.println(\"Keys to keep where they are:     \"+wantedKeepNums.length);\n\t\tSystem.err.println(\"Keys which will be wiped anyway: \"+unwantedIgnoreNums.length);\n\t\tSystem.err.println(\"Keys to move:                    \"+wantedMoveNums.length);\n\t\tSystem.err.println(\"Keys to be moved over:           \"+unwantedMoveNums.length);\n\t\tSystem.err.println(\"Free slots to be moved over:     \"+freeEarlySlots.length);\n\t\t\n\t\t// Now move all the wantedMove blocks onto the corresponding unwantedMove's.\n\t\t\n\t\tWrapperManager.signalStarting((int)Math.min(Integer.MAX_VALUE, (5*60*1000 + wantedMoveNums.length*1000L + alreadyDropped.size() * 100L))); // 1 per second\n\t\t\n\t\tbyte[] buf = new byte[headerBlockSize + dataBlockSize];\n\t\tlong lruValue;\n\t\tbyte[] keyBuf = new byte[keyLength];\n\t\tt = null;\n\t\ttry {\n\t\t\tt = environment.beginTransaction(null,null);\n\t\t\tif(alreadyDropped.size() > 0) {\n\t\t\t\tSystem.err.println(\"Deleting \"+alreadyDropped.size()+\" blocks beyond the length of the file\");\n\t\t\t\tfor(int i=0;i<alreadyDropped.size();i++) {\n\t\t\t\t\tint unwantedBlock = ((Integer) alreadyDropped.get(i)).intValue();\n\t\t\t\t\tDatabaseEntry unwantedBlockEntry = new DatabaseEntry();\n\t\t\t\t\tLongBinding.longToEntry(unwantedBlock, unwantedBlockEntry);\n\t\t\t\t\tblockNumDB.delete(t, unwantedBlockEntry);\n\t\t\t\t\tif(i % 1024 == 0) {\n\t\t\t\t\t\tt.commit();\n\t\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(alreadyDropped.size() % 1024 != 0) {\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<wantedMoveNums.length;i++) {\n\t\t\t\tInteger wantedBlock = wantedMoveNums[i];\n\t\t\t\t\n\t\t\t\tInteger unwantedBlock;\n\t\t\t\t\n\t\t\t\t// Can we move over an empty slot?\n\t\t\t\tif(i < freeEarlySlots.length) {\n\t\t\t\t\t// Don't need to delete old block\n\t\t\t\t\tunwantedBlock = new Integer((int) freeEarlySlots[i]); // will fit in an int\n\t\t\t\t} else if(unwantedMoveNums.length + freeEarlySlots.length > i) {\n\t\t\t\t\tunwantedBlock = unwantedMoveNums[i-freeEarlySlots.length];\n\t\t\t\t\t// Delete unwantedBlock from the store\n\t\t\t\t\tDatabaseEntry unwantedBlockEntry = new DatabaseEntry();\n\t\t\t\t\tLongBinding.longToEntry(unwantedBlock.longValue(), unwantedBlockEntry);\n\t\t\t\t\t// Delete the old block from the database.\n\t\t\t\t\tblockNumDB.delete(t, unwantedBlockEntry);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Keys to move but no keys to move over! Moved \"+i);\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Move old data to new location\n\t\t\t\t\n\t\t\t\tDatabaseEntry wantedBlockEntry = new DatabaseEntry();\n\t\t\t\tLongBinding.longToEntry(wantedBlock.longValue(), wantedBlockEntry);\n\t\t\t\tlong entry = wantedBlock.longValue();\n\t\t\t\tboolean readLRU = false;\n\t\t\t\tboolean readKey = false;\n\t\t\t\ttry {\n\t\t\t\t\tstoreFC.read(ByteBuffer.wrap(buf), entry * (headerBlockSize + dataBlockSize));\n\t\t\t\t\tlruValue = 0;\n\t\t\t\t\tif(lruRAF.length() > ((entry + 1) * 8)) {\n\t\t\t\t\t\treadLRU = true;\n\t\t\t\t\t\tlruValue = fcReadLRU(entry);\n\t\t\t\t\t}\n\t\t\t\t\tif(keysRAF != null && keysRAF.length() > ((entry + 1) * keyLength)) {\n\t\t\t\t\t\treadKey = true;\n\t\t\t\t\t\tfcReadKey(entry, keyBuf);\n\t\t\t\t\t}\n\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\tSystem.err.println(\"Was reading \"+wantedBlock+\" to write to \"+unwantedBlock);\n\t\t\t\t\tSystem.err.println(e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tentry = unwantedBlock.longValue();\n\t\t\t\tstoreFC.write(ByteBuffer.wrap(buf), entry * (headerBlockSize + dataBlockSize));\n\t\t\t\tif(readLRU) {\n\t\t\t\t\tfcWriteLRU(entry, lruValue);\n\t\t\t\t}\n\t\t\t\tif(readKey) {\n\t\t\t\t\tfcWriteKey(entry, keyBuf);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update the database w.r.t. the old block.\n\t\t\t\t\n\t\t\t\tDatabaseEntry routingKeyDBE = new DatabaseEntry();\n\t\t\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\t\t\tblockNumDB.get(t, wantedBlockEntry, routingKeyDBE, blockDBE, LockMode.RMW);\n\t\t\t\tStoreBlock block = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\tblock.offset = unwantedBlock.longValue();\n\t\t\t\tstoreBlockTupleBinding.objectToEntry(block, blockDBE);\n\t\t\t\tkeysDB.put(t, routingKeyDBE, blockDBE);\n\t\t\t\t\n\t\t\t\t// Think about committing the transaction.\n\t\t\t\t\n\t\t\t\tif((i+1) % 2048 == 0) {\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t\t\tSystem.out.println(\"Moving blocks: \"+(i*100/wantedMove.size())+ \"% ( \"+i+ '/' +wantedMove.size()+ ')');\n\t\t\t\t}\n\t\t\t\t//System.err.println(\"Moved \"+wantedBlock+\" to \"+unwantedBlock);\n\t\t\t}\n\t\t\tSystem.out.println(\"Moved all \"+wantedMove.size()+\" blocks\");\n\t\t\tif(t != null) {\n\t\t\t\tt.commit();\n\t\t\t\tt = null;\n\t\t\t}\n\t\t} finally {\n\t\t\tif(t != null)\n\t\t\t\tt.abort();\n\t\t\tt = null;\n\t\t}\n\t\tSystem.out.println(\"Completing shrink\"); // FIXME remove\n\t\t\n\t\tint totalUnwantedBlocks = unwantedMoveNums.length+freeEarlySlots.length;\n\t\tWrapperManager.signalStarting((int) Math.min(Integer.MAX_VALUE, 5*60*1000 + (totalUnwantedBlocks-wantedMoveNums.length) * 100L));\n\t\t// If there are any slots left over, they must be free.\n\t\t\n\t\t// FIXME put these into the database as we do in reconstruct().\n\t\t// Not doing that now as its not immediately obvious how to deal with it...\n\t\t\n\t\tfreeBlocks.clear();\n\t\tt = environment.beginTransaction(null,null);\n\t\tfor(int i=wantedMoveNums.length;i<totalUnwantedBlocks;i++) {\n\t\t\tlong blockNo;\n\t\t\tString reason;\n\t\t\tif(i < freeEarlySlots.length) {\n\t\t\t\tblockNo = freeEarlySlots[i];\n\t\t\t\treason = \"early slot \"+i;\n\t\t\t} else {\n\t\t\t\tblockNo = unwantedMoveNums[i-freeEarlySlots.length].longValue();\n\t\t\t\treason = \"unwanted \"+(i-freeEarlySlots.length);\n\t\t\t}\n\t\t\tDatabaseEntry unwantedBlockEntry = new DatabaseEntry();\n\t\t\tLongBinding.longToEntry(blockNo, unwantedBlockEntry);\n\t\t\tblockNumDB.delete(t, unwantedBlockEntry);\n\t\t\tif(i % 1024 == 0) {\n\t\t\t\tSystem.out.println(\"Trimmed surplus keys in database: \"+(i-wantedMoveNums.length)+\"/\"+(totalUnwantedBlocks-wantedMoveNums.length));\n\t\t\t\tt.commit();\n\t\t\t\tif(i == totalUnwantedBlocks-1)\n\t\t\t\t\tt = null;\n\t\t\t\telse\n\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t}\n\t\t\taddFreeBlock(blockNo, true, reason);\n\t\t}\n\t\tif(t != null) t.commit();\n\t\tt = null;\n\t\t\n\t\tSystem.out.println(\"Finishing shrink\"); // FIXME remove\n\t\t\n\t\tstoreRAF.setLength(newSize * (dataBlockSize + headerBlockSize));\n\t\tlruRAF.setLength(newSize * 8);\n\t\tif(keysRAF != null)\n\t\t\tkeysRAF.setLength(newSize * keyLength);\n\t\t\n\t\tsynchronized(this) {\n\t\t\tblocksInStore = newSize;\n\t\t}\n\t\tSystem.err.println(\"Shrunk store, now have \"+blocksInStore+\" of \"+maxBlocksInStore);\n\t}","id":9172,"modified_method":"private void maybeSlowShrink(boolean dontCheckForHoles, boolean inStartUp) throws DatabaseException, IOException {\n\t\tList wantedKeep = new ArrayList(); // keep; content is wanted, and is in the right place\n\t\tList unwantedIgnore = new ArrayList(); // ignore; content is not wanted, and is not in the right place\n\t\tList wantedMove = new ArrayList(); // content is wanted, but is in the wrong part of the store\n\t\tList unwantedMove = new ArrayList(); // content is not wanted, but is in the part of the store we will keep\n\t\tList alreadyDropped = new ArrayList(); // any blocks past the end which have already been truncated, but which there are still database blocks pointing to\n\t\t\n\t\tCursor c = null;\n\t\tTransaction t = null;\n\n\t\tlong newSize = maxBlocksInStore;\n\t\tif(blocksInStore < maxBlocksInStore) return;\n\t\t\n\t\tSystem.err.println(\"Shrinking from \"+blocksInStore+\" to \"+maxBlocksInStore+\" (from db \"+keysDB.count()+\" from file \"+countCHKBlocksFromFile()+ ')');\n\t\t\n\t\tif(!dontCheckForHoles)\n\t\t\tcheckForHoles(maxBlocksInStore, true);\n\t\t\n\t\tWrapperManager.signalStarting((int) (Math.min(Integer.MAX_VALUE, 5 * 60 * 1000 + blocksInStore * 100L))); // 10 per second\n\t\t\n\t\tlong realSize = countCHKBlocksFromFile();\n\t\t\n\t\tlong highestBlock = 0;\n\t\t\n\t\ttry {\n\t\t\tc = accessTimeDB.openCursor(null,null);\n\t\t\t\n\t\t\tDatabaseEntry keyDBE = new DatabaseEntry();\n\t\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\t\tOperationStatus opStat;\n\t\t\topStat = c.getLast(keyDBE, blockDBE, LockMode.RMW);\n\t\t\t\n\t\t\tif(opStat == OperationStatus.NOTFOUND) {\n\t\t\t\tSystem.err.println(\"Database is empty (shrinking).\");\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//Logger.minor(this, \"Found first key\");\n\t\t\tint x = 0;\n\t\t\twhile(true) {\n\t\t\t\tStoreBlock storeBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\tlong block = storeBlock.offset;\n\t\t\t\tif(block > highestBlock) highestBlock = block;\n\t\t\t\tif(storeBlock.offset > Integer.MAX_VALUE) {\n\t\t\t\t\t// 2^31 * blockSize; ~ 70TB for CHKs, 2TB for the others\n\t\t\t\t\tSystem.err.println(\"Store too big, doing quick shrink\"); // memory usage would be insane\n\t\t\t\t\tc.close();\n\t\t\t\t\tc = null;\n\t\t\t\t\tmaybeQuickShrink(true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tInteger blockNum = new Integer((int)storeBlock.offset);\n\t\t\t\t//Long seqNum = new Long(storeBlock.recentlyUsed);\n\t\t\t\t//System.out.println(\"#\"+x+\" seq \"+seqNum+\": block \"+blockNum);\n\t\t\t\tif(blockNum.longValue() >= realSize) {\n\t\t\t\t\t// Truncated already?\n\t\t\t\t\tLogger.minor(this, \"Truncated already? \"+blockNum.longValue());\n\t\t\t\t\talreadyDropped.add(blockNum);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif(x < newSize) {\n\t\t\t\t\t\t// Wanted\n\t\t\t\t\t\tif(block < newSize) {\n\t\t\t\t\t\t\t//System.out.println(\"Keep where it is: block \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\twantedKeep.add(blockNum);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//System.out.println(\"Move to where it should go: \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\twantedMove.add(blockNum);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Unwanted\n\t\t\t\t\t\tif(block < newSize) {\n\t\t\t\t\t\t\t//System.out.println(\"Overwrite: \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\tunwantedMove.add(blockNum);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//System.out.println(\"Ignore, will be wiped: block \"+blockNum+\" seq # \"+x+\" / \"+newSize);\n\t\t\t\t\t\t\tunwantedIgnore.add(blockNum);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t\tif(x % 1024 == 0) {\n\t\t\t\t\t\tSystem.out.println(\"Reading store prior to shrink: \"+(x*100L/realSize)+ \"% ( \"+x+ '/' +realSize+ ')');\n\t\t\t\t\t}\n\t\t\t\t\tif(x == Integer.MAX_VALUE) {\n\t\t\t\t\t\tSystem.err.println(\"Key number \"+x+\" - ignoring store after \"+(x*(dataBlockSize+headerBlockSize)+\" bytes\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\topStat = c.getPrev(keyDBE, blockDBE, LockMode.RMW);\n\t\t\t\tif(opStat == OperationStatus.NOTFOUND) {\n\t\t\t\t\tSystem.out.println(\"Read store: \"+x+\" keys.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} finally {\n\t\t\tif(c != null)\n\t\t\t\tc.close();\n\t\t}\n\t\t\n\t\tInteger[] wantedKeepNums = (Integer[]) wantedKeep.toArray(new Integer[wantedKeep.size()]);\n\t\tInteger[] unwantedIgnoreNums = (Integer[]) unwantedIgnore.toArray(new Integer[unwantedIgnore.size()]);\n\t\tInteger[] wantedMoveNums = (Integer[]) wantedMove.toArray(new Integer[wantedMove.size()]);\n\t\tInteger[] unwantedMoveNums = (Integer[]) unwantedMove.toArray(new Integer[unwantedMove.size()]);\n\t\tlong[] freeEarlySlots = freeBlocks.toArray();\n\t\tArrays.sort(wantedKeepNums);\n\t\tArrays.sort(unwantedIgnoreNums);\n\t\tArrays.sort(wantedMoveNums);\n\t\tArrays.sort(unwantedMoveNums);\n\t\t\n\t\tfor(int i=0;i<newSize;i++) {\n\t\t\tInteger ii = new Integer(i);\n\t\t\tif(Arrays.binarySearch(wantedKeepNums, ii) >= 0) continue;\n\t\t\tif(Arrays.binarySearch(unwantedIgnoreNums, ii) >= 0) continue;\n\t\t\tif(Arrays.binarySearch(wantedMoveNums, ii) >= 0) continue;\n\t\t\tif(Arrays.binarySearch(unwantedMoveNums, ii) >= 0) continue;\n\t\t\tunwantedMove.add(ii);\n\t\t}\n\t\tunwantedMoveNums = (Integer[]) unwantedMove.toArray(new Integer[unwantedMove.size()]);\n\t\t\n\t\tSystem.err.println(\"Keys to keep where they are:     \"+wantedKeepNums.length);\n\t\tSystem.err.println(\"Keys which will be wiped anyway: \"+unwantedIgnoreNums.length);\n\t\tSystem.err.println(\"Keys to move:                    \"+wantedMoveNums.length);\n\t\tSystem.err.println(\"Keys to be moved over:           \"+unwantedMoveNums.length);\n\t\tSystem.err.println(\"Free slots to be moved over:     \"+freeEarlySlots.length);\n\t\t\n\t\t// Now move all the wantedMove blocks onto the corresponding unwantedMove's.\n\t\t\n\t\tWrapperManager.signalStarting((int)Math.min(Integer.MAX_VALUE, (5*60*1000 + wantedMoveNums.length*1000L + alreadyDropped.size() * 100L))); // 1 per second\n\t\t\n\t\tbyte[] buf = new byte[headerBlockSize + dataBlockSize];\n\t\tlong lruValue;\n\t\tbyte[] keyBuf = new byte[keyLength];\n\t\tt = null;\n\t\ttry {\n\t\t\tt = environment.beginTransaction(null,null);\n\t\t\tif(alreadyDropped.size() > 0) {\n\t\t\t\tSystem.err.println(\"Deleting \"+alreadyDropped.size()+\" blocks beyond the length of the file\");\n\t\t\t\tfor(int i=0;i<alreadyDropped.size();i++) {\n\t\t\t\t\tint unwantedBlock = ((Integer) alreadyDropped.get(i)).intValue();\n\t\t\t\t\tDatabaseEntry unwantedBlockEntry = new DatabaseEntry();\n\t\t\t\t\tLongBinding.longToEntry(unwantedBlock, unwantedBlockEntry);\n\t\t\t\t\tblockNumDB.delete(t, unwantedBlockEntry);\n\t\t\t\t\tif(i % 1024 == 0) {\n\t\t\t\t\t\tt.commit();\n\t\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(alreadyDropped.size() % 1024 != 0) {\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<wantedMoveNums.length;i++) {\n\t\t\t\tInteger wantedBlock = wantedMoveNums[i];\n\t\t\t\t\n\t\t\t\tInteger unwantedBlock;\n\t\t\t\t\n\t\t\t\t// Can we move over an empty slot?\n\t\t\t\tif(i < freeEarlySlots.length) {\n\t\t\t\t\t// Don't need to delete old block\n\t\t\t\t\tunwantedBlock = new Integer((int) freeEarlySlots[i]); // will fit in an int\n\t\t\t\t} else if(unwantedMoveNums.length + freeEarlySlots.length > i) {\n\t\t\t\t\tunwantedBlock = unwantedMoveNums[i-freeEarlySlots.length];\n\t\t\t\t\t// Delete unwantedBlock from the store\n\t\t\t\t\tDatabaseEntry unwantedBlockEntry = new DatabaseEntry();\n\t\t\t\t\tLongBinding.longToEntry(unwantedBlock.longValue(), unwantedBlockEntry);\n\t\t\t\t\t// Delete the old block from the database.\n\t\t\t\t\tblockNumDB.delete(t, unwantedBlockEntry);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.err.println(\"Keys to move but no keys to move over! Moved \"+i);\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = null;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Move old data to new location\n\t\t\t\t\n\t\t\t\tDatabaseEntry wantedBlockEntry = new DatabaseEntry();\n\t\t\t\tLongBinding.longToEntry(wantedBlock.longValue(), wantedBlockEntry);\n\t\t\t\tlong entry = wantedBlock.longValue();\n\t\t\t\tboolean readLRU = false;\n\t\t\t\tboolean readKey = false;\n\t\t\t\ttry {\n\t\t\t\t\tstoreRAF.seek(entry * (headerBlockSize + dataBlockSize));\n\t\t\t\t\tstoreRAF.readFully(buf);\n\t\t\t\t\tlruValue = 0;\n\t\t\t\t\tif(lruRAF.length() > ((entry + 1) * 8)) {\n\t\t\t\t\t\treadLRU = true;\n\t\t\t\t\t\tlruRAF.seek(entry * 8);\n\t\t\t\t\t\tlruValue = lruRAF.readLong();\n\t\t\t\t\t}\n\t\t\t\t\tif(keysRAF != null && keysRAF.length() > ((entry + 1) * keyLength)) {\n\t\t\t\t\t\treadKey = true;\n\t\t\t\t\t\tkeysRAF.seek(entry * keyLength);\n\t\t\t\t\t\tkeysRAF.readFully(keyBuf);\n\t\t\t\t\t}\n\t\t\t\t} catch (EOFException e) {\n\t\t\t\t\tSystem.err.println(\"Was reading \"+wantedBlock+\" to write to \"+unwantedBlock);\n\t\t\t\t\tSystem.err.println(e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tentry = unwantedBlock.longValue();\n\t\t\t\tstoreRAF.seek(entry * (headerBlockSize + dataBlockSize));\n\t\t\t\tstoreRAF.write(buf);\n\t\t\t\tif(readLRU) {\n\t\t\t\t\tlruRAF.seek(entry * 8);\n\t\t\t\t\tlruRAF.writeLong(lruValue);\n\t\t\t\t}\n\t\t\t\tif(readKey) {\n\t\t\t\t\tkeysRAF.seek(entry * keyLength);\n\t\t\t\t\tkeysRAF.write(keyBuf);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update the database w.r.t. the old block.\n\t\t\t\t\n\t\t\t\tDatabaseEntry routingKeyDBE = new DatabaseEntry();\n\t\t\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\t\t\tblockNumDB.get(t, wantedBlockEntry, routingKeyDBE, blockDBE, LockMode.RMW);\n\t\t\t\tStoreBlock block = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\tblock.offset = unwantedBlock.longValue();\n\t\t\t\tstoreBlockTupleBinding.objectToEntry(block, blockDBE);\n\t\t\t\tkeysDB.put(t, routingKeyDBE, blockDBE);\n\t\t\t\t\n\t\t\t\t// Think about committing the transaction.\n\t\t\t\t\n\t\t\t\tif((i+1) % 2048 == 0) {\n\t\t\t\t\tt.commit();\n\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t\t\tSystem.out.println(\"Moving blocks: \"+(i*100/wantedMove.size())+ \"% ( \"+i+ '/' +wantedMove.size()+ ')');\n\t\t\t\t}\n\t\t\t\t//System.err.println(\"Moved \"+wantedBlock+\" to \"+unwantedBlock);\n\t\t\t}\n\t\t\tSystem.out.println(\"Moved all \"+wantedMove.size()+\" blocks\");\n\t\t\tif(t != null) {\n\t\t\t\tt.commit();\n\t\t\t\tt = null;\n\t\t\t}\n\t\t} finally {\n\t\t\tif(t != null)\n\t\t\t\tt.abort();\n\t\t\tt = null;\n\t\t}\n\t\tSystem.out.println(\"Completing shrink\"); // FIXME remove\n\t\t\n\t\tint totalUnwantedBlocks = unwantedMoveNums.length+freeEarlySlots.length;\n\t\tWrapperManager.signalStarting((int) Math.min(Integer.MAX_VALUE, 5*60*1000 + (totalUnwantedBlocks-wantedMoveNums.length) * 100L));\n\t\t// If there are any slots left over, they must be free.\n\t\t\n\t\t// FIXME put these into the database as we do in reconstruct().\n\t\t// Not doing that now as its not immediately obvious how to deal with it...\n\t\t\n\t\tfreeBlocks.clear();\n\t\tt = environment.beginTransaction(null,null);\n\t\tfor(int i=wantedMoveNums.length;i<totalUnwantedBlocks;i++) {\n\t\t\tlong blockNo;\n\t\t\tString reason;\n\t\t\tif(i < freeEarlySlots.length) {\n\t\t\t\tblockNo = freeEarlySlots[i];\n\t\t\t\treason = \"early slot \"+i;\n\t\t\t} else {\n\t\t\t\tblockNo = unwantedMoveNums[i-freeEarlySlots.length].longValue();\n\t\t\t\treason = \"unwanted \"+(i-freeEarlySlots.length);\n\t\t\t}\n\t\t\tDatabaseEntry unwantedBlockEntry = new DatabaseEntry();\n\t\t\tLongBinding.longToEntry(blockNo, unwantedBlockEntry);\n\t\t\tblockNumDB.delete(t, unwantedBlockEntry);\n\t\t\tif(i % 1024 == 0) {\n\t\t\t\tSystem.out.println(\"Trimmed surplus keys in database: \"+(i-wantedMoveNums.length)+\"/\"+(totalUnwantedBlocks-wantedMoveNums.length));\n\t\t\t\tt.commit();\n\t\t\t\tif(i == totalUnwantedBlocks-1)\n\t\t\t\t\tt = null;\n\t\t\t\telse\n\t\t\t\t\tt = environment.beginTransaction(null,null);\n\t\t\t}\n\t\t\taddFreeBlock(blockNo, true, reason);\n\t\t}\n\t\tif(t != null) t.commit();\n\t\tt = null;\n\t\t\n\t\tSystem.out.println(\"Finishing shrink\"); // FIXME remove\n\t\t\n\t\tstoreRAF.setLength(newSize * (dataBlockSize + headerBlockSize));\n\t\tlruRAF.setLength(newSize * 8);\n\t\tif(keysRAF != null)\n\t\t\tkeysRAF.setLength(newSize * keyLength);\n\t\t\n\t\tsynchronized(this) {\n\t\t\tblocksInStore = newSize;\n\t\t}\n\t\tSystem.err.println(\"Shrunk store, now have \"+blocksInStore+\" of \"+maxBlocksInStore);\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Overwrite a block with a new block which has the same key.\n\t */\n\tprivate boolean overwriteKeyUnchanged(StorableBlock block, byte[] routingkey, byte[] fullKey, byte[] data, byte[] header) throws IOException {\n\t\tsynchronized(this) {\n\t\t\tif(closed)\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tDatabaseEntry routingkeyDBE = new DatabaseEntry(routingkey);\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tCursor c = null;\n\t\tTransaction t = null;\n\t\ttry {\n\t\t\tt = environment.beginTransaction(null,null);\n\t\t\tc = keysDB.openCursor(t,null);\n\n\t\t\t// Lock the record.\n\t\t\tif(c.getSearchKey(routingkeyDBE,blockDBE,LockMode.RMW)\n\t\t\t\t\t!=OperationStatus.SUCCESS) {\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\tt.abort();\n\t\t\t\tt = null;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tStoreBlock storeBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\t\t\t\n\t\t\tfcWriteStore(storeBlock.offset, header, data);\n\t\t\tif (keysRAF != null) {\n\t\t\t\tfcWriteKey(storeBlock.offset, fullKey);\n\t\t\t}\n\t\t\t\n\t\t\t// Unlock record.\n\t\t\tc.close();\n\t\t\tc = null;\n\t\t\tt.commit();\n\t\t\tt = null;\n\t\t\t\n\t\t} catch(Throwable ex) {  // FIXME: ugly\n\t\t\tcheckSecondaryDatabaseError(ex);\n\t\t\tLogger.error(this, \"Caught \"+ex, ex);\n\t\t\tex.printStackTrace();\n\t\t\tthrow new IOException(ex.getMessage());\n\t\t} finally {\n\t\t\tif(c!=null) {\n\t\t\t\ttry{c.close();}catch(DatabaseException ex2){}\n\t\t\t\n\t\t\t}\n\t\t\tif(t!=null) {\n\t\t\t\ttry{t.abort();}catch(DatabaseException ex2){}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","id":9173,"modified_method":"/**\n\t * Overwrite a block with a new block which has the same key.\n\t */\n\tprivate boolean overwriteKeyUnchanged(StorableBlock block, byte[] routingkey, byte[] fullKey, byte[] data, byte[] header) throws IOException {\n\t\tsynchronized(this) {\n\t\t\tif(closed)\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tDatabaseEntry routingkeyDBE = new DatabaseEntry(routingkey);\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tCursor c = null;\n\t\tTransaction t = null;\n\t\ttry {\n\t\t\tt = environment.beginTransaction(null,null);\n\t\t\tc = keysDB.openCursor(t,null);\n\n\t\t\t// Lock the record.\n\t\t\tif(c.getSearchKey(routingkeyDBE,blockDBE,LockMode.RMW)\n\t\t\t\t\t!=OperationStatus.SUCCESS) {\n\t\t\t\tc.close();\n\t\t\t\tc = null;\n\t\t\t\tt.abort();\n\t\t\t\tt = null;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tStoreBlock storeBlock = (StoreBlock) storeBlockTupleBinding.entryToObject(blockDBE);\n\t\t\t\t\t\t\n\t\t\tsynchronized(storeRAF) {\n\t\t\t\tstoreRAF.seek(storeBlock.offset*(long)(dataBlockSize+headerBlockSize));\n\t\t\t\tstoreRAF.write(header);\n\t\t\t\tstoreRAF.write(data);\n\t\t\t\tif(keysRAF != null) {\n\t\t\t\t\tkeysRAF.seek(storeBlock.offset * keyLength);\n\t\t\t\t\tkeysRAF.write(fullKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Unlock record.\n\t\t\tc.close();\n\t\t\tc = null;\n\t\t\tt.commit();\n\t\t\tt = null;\n\t\t\t\n\t\t} catch(Throwable ex) {  // FIXME: ugly\n\t\t\tcheckSecondaryDatabaseError(ex);\n\t\t\tLogger.error(this, \"Caught \"+ex, ex);\n\t\t\tex.printStackTrace();\n\t\t\tthrow new IOException(ex.getMessage());\n\t\t} finally {\n\t\t\tif(c!=null) {\n\t\t\t\ttry{c.close();}catch(DatabaseException ex2){}\n\t\t\t\n\t\t\t}\n\t\t\tif(t!=null) {\n\t\t\t\ttry{t.abort();}catch(DatabaseException ex2){}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"private boolean writeNewBlock(long blockNum, byte[] header, byte[] data, Transaction t, DatabaseEntry routingkeyDBE, byte[] fullKey) throws DatabaseException, IOException {\n\t\tStoreBlock storeBlock = new StoreBlock(this, blockNum);\n\t\tlong lruValue = storeBlock.recentlyUsed;\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\ttry {\n\t\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t} catch (DatabaseException e) {\n\t\t\tDatabaseEntry blockNumEntry = new DatabaseEntry();\n\t\t\tDatabaseEntry found = new DatabaseEntry();\n\t\t\tLongBinding.longToEntry(blockNum, blockNumEntry);\n\t\t\t\n\t\t\tOperationStatus success =\n\t\t\t\tblockNumDB.get(t, blockNumEntry, found, LockMode.DEFAULT);\n\n\t\t\tif(success == OperationStatus.KEYEXIST || success == OperationStatus.SUCCESS) {\n\t\t\t\tSystem.err.println(\"Trying to overwrite block \"+blockNum+\" but already used: \"+getName()+\" for \"+e);\n\t\t\t\te.printStackTrace();\n\t\t\t\tLogger.error(this, \"Trying to overwrite block \"+blockNum+\" but already used: \"+getName()+\" for \"+e);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tLogger.minor(this, \"Key doesn't exist for block num \"+blockNum+\" but caught \"+e, e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tfcWriteStore(blockNum, header, data);\n\t\t\tfcWriteLRU(blockNum, lruValue);\n\t\t\tif(keysRAF != null) {\n\t\t\t\tfcWriteKey(blockNum, fullKey);\n\t\t\t\tif(logDEBUG)\n\t\t\t\t\tLogger.debug(this, \"Written full key length \"+fullKey.length+\" to block \"+blockNum+\" at \"+(blockNum * keyLength)+\" for \"+callback);\n\t\t\t} else if(logDEBUG) {\n\t\t\t\tLogger.debug(this, \"Not writing full key length \"+fullKey.length+\" for block \"+blockNum+\" for \"+callback);\n\t\t\t}\n\t\t\tsynchronized (this) {\n\t\t\twrites++;\n\t\t}\n\t\t\n\t\treturn true;\n\t}","id":9174,"modified_method":"private boolean writeNewBlock(long blockNum, byte[] header, byte[] data, Transaction t, DatabaseEntry routingkeyDBE, byte[] fullKey) throws DatabaseException, IOException {\n\t\tlong byteOffset = blockNum*(dataBlockSize+headerBlockSize);\n\t\tStoreBlock storeBlock = new StoreBlock(this, blockNum);\n\t\tlong lruValue = storeBlock.recentlyUsed;\n\t\tDatabaseEntry blockDBE = new DatabaseEntry();\n\t\tstoreBlockTupleBinding.objectToEntry(storeBlock, blockDBE);\n\t\ttry {\n\t\t\tkeysDB.put(t,routingkeyDBE,blockDBE);\n\t\t} catch (DatabaseException e) {\n\t\t\tDatabaseEntry blockNumEntry = new DatabaseEntry();\n\t\t\tDatabaseEntry found = new DatabaseEntry();\n\t\t\tLongBinding.longToEntry(blockNum, blockNumEntry);\n\t\t\t\n\t\t\tOperationStatus success =\n\t\t\t\tblockNumDB.get(t, blockNumEntry, found, LockMode.DEFAULT);\n\n\t\t\tif(success == OperationStatus.KEYEXIST || success == OperationStatus.SUCCESS) {\n\t\t\t\tSystem.err.println(\"Trying to overwrite block \"+blockNum+\" but already used: \"+getName()+\" for \"+e);\n\t\t\t\te.printStackTrace();\n\t\t\t\tLogger.error(this, \"Trying to overwrite block \"+blockNum+\" but already used: \"+getName()+\" for \"+e);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tLogger.minor(this, \"Key doesn't exist for block num \"+blockNum+\" but caught \"+e, e);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\tsynchronized(storeRAF) {\n\t\t\ttry {\n\t\t\t\tstoreRAF.seek(byteOffset);\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tif(byteOffset > (2l*1024*1024*1024)) {\n\t\t\t\t\tLogger.error(this, \"Environment does not support files bigger than 2 GB?\");\n\t\t\t\t\tSystem.out.println(\"Environment does not support files bigger than 2 GB? (exception to follow)\");\n\t\t\t\t}\n\t\t\t\tLogger.error(this, \"Caught IOException on storeRAF.seek(\"+byteOffset+ ')');\n\t\t\t\tthrow ioe;\n\t\t\t}\n\t\t\tstoreRAF.write(header);\n\t\t\tstoreRAF.write(data);\n\t\t\tlruRAF.seek(blockNum * 8);\n\t\t\tlruRAF.writeLong(lruValue);\n\t\t\tif(keysRAF != null) {\n\t\t\t\tkeysRAF.seek(blockNum * keyLength);\n\t\t\t\tkeysRAF.write(fullKey);\n\t\t\t\tif(logDEBUG)\n\t\t\t\t\tLogger.debug(this, \"Written full key length \"+fullKey.length+\" to block \"+blockNum+\" at \"+(blockNum * keyLength)+\" for \"+callback);\n\t\t\t} else if(logDEBUG) {\n\t\t\t\tLogger.debug(this, \"Not writing full key length \"+fullKey.length+\" for block \"+blockNum+\" for \"+callback);\n\t\t\t}\n\t\t\twrites++;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"129bb10ea1516f7b9d29a390a200f5d45cfb3060","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type. \n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws MarshalException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException\n     * @throws ValidationException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a ValidationException\n     * @throws IOException if the resource could not be opened\n     */\n    public static <T> T unmarshal(Class<T> clazz, Resource resource) throws MarshalException, ValidationException, IOException {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            IOException newE = new IOException(\"Failed to open XML configuration file for resource '\" + resource + \"': \" + e);\n            newE.initCause(e);\n            throw newE;\n        }\n    \n        try {\n            return unmarshal(clazz, reader);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }","id":9175,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type. \n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws MarshalException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException\n     * @throws ValidationException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a ValidationException\n     * @throws IOException if the resource could not be opened\n     */\n    public static <T> T unmarshal(Class<T> clazz, Resource resource) throws MarshalException, ValidationException, IOException {\n        InputStream in;\n        try {\n            in = resource.getInputStream();\n        } catch (IOException e) {\n            IOException newE = new IOException(\"Failed to open XML configuration file for resource '\" + resource + \"': \" + e);\n            newE.initCause(e);\n            throw newE;\n        }\n    \n        try {\n            InputSource source = new InputSource(in);\n            try {\n                source.setSystemId(resource.getURL().toString());\n            } catch (Throwable t) {\n                // ignore\n            }\n            return unmarshal(clazz, source);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"fe5a01b060eb42821e5cecfa6ff8faa32bf9b9b0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param reader the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Reader reader) throws DataAccessException {\n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"Unmarshalling XML file\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"Unmarshalling XML file\", e);\n        }\n    }","id":9176,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param reader the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator.\n     * @deprecated Use a Resource or InputStream-based method instead to avoid\n     *             character set issues.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Reader reader) throws DataAccessException {\n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file\", e);\n        }\n    }","commit_id":"fe5a01b060eb42821e5cecfa6ff8faa32bf9b9b0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the resource could not be opened or the\n     *      underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator and will include information about\n     *      the resource from its {@link Resource#toString() toString()} method.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Resource resource) {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }","id":9177,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the resource could not be opened or the\n     *      underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator and will include information about\n     *      the resource from its {@link Resource#toString() toString()} method.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Resource resource) {\n        InputStream in;\n        try {\n            in = resource.getInputStream();\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        try {\n            InputSource source = new InputSource(in);\n            try {\n                source.setSystemId(resource.getURL().toString());\n            } catch (Throwable t) {\n                // ignore\n            }\n            return unmarshal(clazz, source);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"fe5a01b060eb42821e5cecfa6ff8faa32bf9b9b0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Protected constructor\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    protected DatabaseChecker(String configFile) throws IOException,\n\t\t\t\t\t\t      MarshalException,\n\t\t\t\t\t\t      ValidationException,\n\t\t\t\t\t\t      ClassNotFoundException {\n        /*\n         * Set the system identifier for the source of the input stream.\n         * This is necessary so that any location information can\n         * positively identify the source of the error.\n         */\n        InputSource dbIn = new InputSource(new FileInputStream(configFile));\n        dbIn.setSystemId(configFile);\n\n        // Attempt to load the database reference.\n        DataSourceConfiguration m_database = (DataSourceConfiguration) Unmarshaller.unmarshal(DataSourceConfiguration.class, dbIn);\n\n        /*\n        Param[] parms = m_database.getDatabaseChoice().getDriver().getParam();\n        for (int i = 0; i < parms.length; i++) {\n        \tif (parms[i].getName().equals(\"user\")) {\n        \t\tm_driverUser = parms[i].getValue();\n        \t} else if (parms[i].getName().equals(\"password\")) {\n        \t\tm_driverPass = parms[i].getValue();\n        \t} else {\n        \t\tthrow new ValidationException(\"Unsupported JDO parameter: \" +\n        \t\t\t\tparms[i].getName());\n        \t}\n        }\n        */\n        \n        for (JdbcDataSource jdbcDataSource : getJdbcDataSources(m_database)) {\n            m_driverUrl = jdbcDataSource.getUrl();\n            m_driverUser = jdbcDataSource.getUserName();\n            m_driverPass = jdbcDataSource.getPassword();\n            String driverCN = jdbcDataSource.getClassName();\n            Class.forName(driverCN);\n        }\n    }","id":9178,"modified_method":"/**\n     * Protected constructor\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    protected DatabaseChecker(String configFile) throws IOException,\n\t\t\t\t\t\t      MarshalException,\n\t\t\t\t\t\t      ValidationException,\n\t\t\t\t\t\t      ClassNotFoundException {\n        DataSourceConfiguration m_database = CastorUtils.unmarshal(DataSourceConfiguration.class, new FileSystemResource(configFile));\n        \n        for (JdbcDataSource jdbcDataSource : m_database.getJdbcDataSourceCollection()) {\n            m_driverUrl = jdbcDataSource.getUrl();\n            m_driverUser = jdbcDataSource.getUserName();\n            m_driverPass = jdbcDataSource.getPassword();\n            Class.forName(jdbcDataSource.getClassName());\n        }\n    }","commit_id":"fe5a01b060eb42821e5cecfa6ff8faa32bf9b9b0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void loadResource(Resource resource) throws ModelImportException, IOException {\n        InputStream inputStream = null;\n        try {\n            inputStream = resource.getInputStream();\n            unmarshall(inputStream);\n        } finally {\n            closeQuietly(inputStream);\n        }\n    }","id":9179,"modified_method":"public void loadResource(Resource resource) throws ModelImportException, IOException {\n        try {\n            m_mi = CastorUtils.unmarshal(ModelImport.class, resource);\n        } catch (MarshalException e) {\n            throw new ModelImportException(\"Exception while marshalling import: \"+e, e);\n        } catch (ValidationException e) {\n            throw new ModelImportException(\"Exception while validating import \"+e);\n        }\n    }","commit_id":"fe5a01b060eb42821e5cecfa6ff8faa32bf9b9b0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param reader the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Reader reader) throws DataAccessException {\n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"Unmarshalling XML file\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"Unmarshalling XML file\", e);\n        }\n    }","id":9180,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param reader the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator.\n     * @deprecated Use a Resource or InputStream-based method instead to avoid\n     *             character set issues.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Reader reader) throws DataAccessException {\n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file\", e);\n        }\n    }","commit_id":"3620aeaecd07b117bccca29244a9e65860051d92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the resource could not be opened or the\n     *      underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator and will include information about\n     *      the resource from its {@link Resource#toString() toString()} method.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Resource resource) {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }","id":9181,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the resource could not be opened or the\n     *      underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator and will include information about\n     *      the resource from its {@link Resource#toString() toString()} method.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Resource resource) {\n        InputStream in;\n        try {\n            in = resource.getInputStream();\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        try {\n            InputSource source = new InputSource(in);\n            try {\n                source.setSystemId(resource.getURL().toString());\n            } catch (Throwable t) {\n                // ignore\n            }\n            return unmarshal(clazz, source);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"3620aeaecd07b117bccca29244a9e65860051d92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type. \n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws MarshalException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException\n     * @throws ValidationException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a ValidationException\n     * @throws IOException if the resource could not be opened\n     */\n    public static <T> T unmarshal(Class<T> clazz, Resource resource) throws MarshalException, ValidationException, IOException {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            IOException newE = new IOException(\"Failed to open XML configuration file for resource '\" + resource + \"': \" + e);\n            newE.initCause(e);\n            throw newE;\n        }\n    \n        try {\n            return unmarshal(clazz, reader);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }","id":9182,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type. \n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws MarshalException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException\n     * @throws ValidationException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a ValidationException\n     * @throws IOException if the resource could not be opened\n     */\n    public static <T> T unmarshal(Class<T> clazz, Resource resource) throws MarshalException, ValidationException, IOException {\n        InputStream in;\n        try {\n            in = resource.getInputStream();\n        } catch (IOException e) {\n            IOException newE = new IOException(\"Failed to open XML configuration file for resource '\" + resource + \"': \" + e);\n            newE.initCause(e);\n            throw newE;\n        }\n    \n        try {\n            InputSource source = new InputSource(in);\n            try {\n                source.setSystemId(resource.getURL().toString());\n            } catch (Throwable t) {\n                // ignore\n            }\n            return unmarshal(clazz, source);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"3620aeaecd07b117bccca29244a9e65860051d92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Protected constructor\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    protected DatabaseChecker(String configFile) throws IOException,\n\t\t\t\t\t\t      MarshalException,\n\t\t\t\t\t\t      ValidationException,\n\t\t\t\t\t\t      ClassNotFoundException {\n        /*\n         * Set the system identifier for the source of the input stream.\n         * This is necessary so that any location information can\n         * positively identify the source of the error.\n         */\n        InputSource dbIn = new InputSource(new FileInputStream(configFile));\n        dbIn.setSystemId(configFile);\n\n        // Attempt to load the database reference.\n        DataSourceConfiguration m_database = (DataSourceConfiguration) Unmarshaller.unmarshal(DataSourceConfiguration.class, dbIn);\n\n        /*\n        Param[] parms = m_database.getDatabaseChoice().getDriver().getParam();\n        for (int i = 0; i < parms.length; i++) {\n        \tif (parms[i].getName().equals(\"user\")) {\n        \t\tm_driverUser = parms[i].getValue();\n        \t} else if (parms[i].getName().equals(\"password\")) {\n        \t\tm_driverPass = parms[i].getValue();\n        \t} else {\n        \t\tthrow new ValidationException(\"Unsupported JDO parameter: \" +\n        \t\t\t\tparms[i].getName());\n        \t}\n        }\n        */\n        \n        for (JdbcDataSource jdbcDataSource : getJdbcDataSources(m_database)) {\n            m_driverUrl = jdbcDataSource.getUrl();\n            m_driverUser = jdbcDataSource.getUserName();\n            m_driverPass = jdbcDataSource.getPassword();\n            String driverCN = jdbcDataSource.getClassName();\n            Class.forName(driverCN);\n        }\n    }","id":9183,"modified_method":"/**\n     * Protected constructor\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    protected DatabaseChecker(String configFile) throws IOException,\n\t\t\t\t\t\t      MarshalException,\n\t\t\t\t\t\t      ValidationException,\n\t\t\t\t\t\t      ClassNotFoundException {\n        DataSourceConfiguration m_database = CastorUtils.unmarshal(DataSourceConfiguration.class, new FileSystemResource(configFile));\n        \n        for (JdbcDataSource jdbcDataSource : m_database.getJdbcDataSourceCollection()) {\n            m_driverUrl = jdbcDataSource.getUrl();\n            m_driverUser = jdbcDataSource.getUserName();\n            m_driverPass = jdbcDataSource.getPassword();\n            Class.forName(jdbcDataSource.getClassName());\n        }\n    }","commit_id":"3620aeaecd07b117bccca29244a9e65860051d92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void loadResource(Resource resource) throws ModelImportException, IOException {\n        InputStream inputStream = null;\n        try {\n            inputStream = resource.getInputStream();\n            unmarshall(inputStream);\n        } finally {\n            closeQuietly(inputStream);\n        }\n    }","id":9184,"modified_method":"public void loadResource(Resource resource) throws ModelImportException, IOException {\n        try {\n            m_mi = CastorUtils.unmarshal(ModelImport.class, resource);\n        } catch (MarshalException e) {\n            throw new ModelImportException(\"Exception while marshalling import: \"+e, e);\n        } catch (ValidationException e) {\n            throw new ModelImportException(\"Exception while validating import \"+e);\n        }\n    }","commit_id":"3620aeaecd07b117bccca29244a9e65860051d92","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param reader the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Reader reader) throws DataAccessException {\n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"Unmarshalling XML file\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"Unmarshalling XML file\", e);\n        }\n    }","id":9185,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param reader the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator.\n     * @deprecated Use a Resource or InputStream-based method instead to avoid\n     *             character set issues.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Reader reader) throws DataAccessException {\n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file\", e);\n        }\n    }","commit_id":"c812a50e1ff8dcfaecbeb350439097d34564da9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type. \n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws MarshalException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException\n     * @throws ValidationException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a ValidationException\n     * @throws IOException if the resource could not be opened\n     */\n    public static <T> T unmarshal(Class<T> clazz, Resource resource) throws MarshalException, ValidationException, IOException {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            IOException newE = new IOException(\"Failed to open XML configuration file for resource '\" + resource + \"': \" + e);\n            newE.initCause(e);\n            throw newE;\n        }\n    \n        try {\n            return unmarshal(clazz, reader);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }","id":9186,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type. \n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws MarshalException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException\n     * @throws ValidationException if the underlying Castor\n     *      Unmarshaller.unmarshal() call throws a ValidationException\n     * @throws IOException if the resource could not be opened\n     */\n    public static <T> T unmarshal(Class<T> clazz, Resource resource) throws MarshalException, ValidationException, IOException {\n        InputStream in;\n        try {\n            in = resource.getInputStream();\n        } catch (IOException e) {\n            IOException newE = new IOException(\"Failed to open XML configuration file for resource '\" + resource + \"': \" + e);\n            newE.initCause(e);\n            throw newE;\n        }\n    \n        try {\n            InputSource source = new InputSource(in);\n            try {\n                source.setSystemId(resource.getURL().toString());\n            } catch (Throwable t) {\n                // ignore\n            }\n            return unmarshal(clazz, source);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"c812a50e1ff8dcfaecbeb350439097d34564da9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the resource could not be opened or the\n     *      underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator and will include information about\n     *      the resource from its {@link Resource#toString() toString()} method.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Resource resource) {\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        try {\n            return unmarshal(clazz, reader);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n    }","id":9187,"modified_method":"/**\n     * Unmarshal a Castor XML configuration file.  Uses Java 5 generics for\n     * return type and throws DataAccessExceptions.\n     * \n     * @param <T> the class representing the marshalled XML configuration\n     *      file.  This will be the return time form the method.\n     * @param clazz the class representing the marshalled XML configuration\n     *      file\n     * @param resource the marshalled XML configuration file to unmarshal\n     * @return Unmarshalled object representing XML file\n     * @throws DataAccessException if the resource could not be opened or the\n     *      underlying Castor\n     *      Unmarshaller.unmarshal() call throws a MarshalException or\n     *      ValidationException.  The underlying exception will be translated\n     *      using CastorExceptionTranslator and will include information about\n     *      the resource from its {@link Resource#toString() toString()} method.\n     */\n    public static <T> T unmarshalWithTranslatedExceptions(Class<T> clazz, Resource resource) {\n        InputStream in;\n        try {\n            in = resource.getInputStream();\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"'\", e);\n        }\n    \n        try {\n            InputSource source = new InputSource(in);\n            try {\n                source.setSystemId(resource.getURL().toString());\n            } catch (Throwable t) {\n                // ignore\n            }\n            return unmarshal(clazz, source);\n        } catch (MarshalException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } catch (ValidationException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"unmarshalling XML file for resource '\" + resource + \"'\", e);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n    }","commit_id":"c812a50e1ff8dcfaecbeb350439097d34564da9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Protected constructor\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    protected DatabaseChecker(String configFile) throws IOException,\n\t\t\t\t\t\t      MarshalException,\n\t\t\t\t\t\t      ValidationException,\n\t\t\t\t\t\t      ClassNotFoundException {\n        /*\n         * Set the system identifier for the source of the input stream.\n         * This is necessary so that any location information can\n         * positively identify the source of the error.\n         */\n        InputSource dbIn = new InputSource(new FileInputStream(configFile));\n        dbIn.setSystemId(configFile);\n\n        // Attempt to load the database reference.\n        DataSourceConfiguration m_database = (DataSourceConfiguration) Unmarshaller.unmarshal(DataSourceConfiguration.class, dbIn);\n\n        /*\n        Param[] parms = m_database.getDatabaseChoice().getDriver().getParam();\n        for (int i = 0; i < parms.length; i++) {\n        \tif (parms[i].getName().equals(\"user\")) {\n        \t\tm_driverUser = parms[i].getValue();\n        \t} else if (parms[i].getName().equals(\"password\")) {\n        \t\tm_driverPass = parms[i].getValue();\n        \t} else {\n        \t\tthrow new ValidationException(\"Unsupported JDO parameter: \" +\n        \t\t\t\tparms[i].getName());\n        \t}\n        }\n        */\n        \n        for (JdbcDataSource jdbcDataSource : getJdbcDataSources(m_database)) {\n            m_driverUrl = jdbcDataSource.getUrl();\n            m_driverUser = jdbcDataSource.getUserName();\n            m_driverPass = jdbcDataSource.getPassword();\n            String driverCN = jdbcDataSource.getClassName();\n            Class.forName(driverCN);\n        }\n    }","id":9188,"modified_method":"/**\n     * Protected constructor\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    protected DatabaseChecker(String configFile) throws IOException,\n\t\t\t\t\t\t      MarshalException,\n\t\t\t\t\t\t      ValidationException,\n\t\t\t\t\t\t      ClassNotFoundException {\n        DataSourceConfiguration m_database = CastorUtils.unmarshal(DataSourceConfiguration.class, new FileSystemResource(configFile));\n        \n        for (JdbcDataSource jdbcDataSource : m_database.getJdbcDataSourceCollection()) {\n            m_driverUrl = jdbcDataSource.getUrl();\n            m_driverUser = jdbcDataSource.getUserName();\n            m_driverPass = jdbcDataSource.getPassword();\n            Class.forName(jdbcDataSource.getClassName());\n        }\n    }","commit_id":"c812a50e1ff8dcfaecbeb350439097d34564da9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void loadResource(Resource resource) throws ModelImportException, IOException {\n        InputStream inputStream = null;\n        try {\n            inputStream = resource.getInputStream();\n            unmarshall(inputStream);\n        } finally {\n            closeQuietly(inputStream);\n        }\n    }","id":9189,"modified_method":"public void loadResource(Resource resource) throws ModelImportException, IOException {\n        try {\n            m_mi = CastorUtils.unmarshal(ModelImport.class, resource);\n        } catch (MarshalException e) {\n            throw new ModelImportException(\"Exception while marshalling import: \"+e, e);\n        } catch (ValidationException e) {\n            throw new ModelImportException(\"Exception while validating import \"+e);\n        }\n    }","commit_id":"c812a50e1ff8dcfaecbeb350439097d34564da9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t\tpublic void run() {\n            // TODO: Remove. Added because I don't have windows, and need a stack trace from here to fix broken test\n            // Should be removed in 2 hrs or so. /jake\n            new Throwable().printStackTrace(  );\n\t\t\twasExecuted = true;\n\t\t\tthreadToInterrupt.interrupt();\n\t\t}","id":9190,"modified_method":"@Override\n\t\tpublic void run() {\n\t\t\twasExecuted = true;\n\t\t\tthreadToInterrupt.interrupt();\n\t\t}","commit_id":"f7bfcbc24a6ed58636f3990b3f260111ab8a5aa6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n\t@Ignore\n\tpublic void shouldNotTimeOutIfTimeoutDisabled() throws IOException \n\t{\n\t\tConfigurator configurator = buildProperties();\n\t\tconfigurator.configuration().setProperty(Configurator.STARTUP_TIMEOUT, 0);\n\t\tserver = createSlowServer(configurator);\n\n        // When\n        server.start();\n\n        // Then\n        // No exceptions should have been thrown\n\t}","id":9191,"modified_method":"@Test\n\tpublic void shouldNotTimeOutIfTimeoutDisabled() throws IOException\n\t{\n\t\tConfigurator configurator = buildProperties().withStartupTimeout( 0 ).atPort( 7480 ).build();\n        server = createSlowServer( configurator, false );\n\n        // When\n        server.start();\n\n        // Then\n        // No exceptions should have been thrown\n\t}","commit_id":"f7bfcbc24a6ed58636f3990b3f260111ab8a5aa6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n\tpublic void shouldTimeoutIfStartupTakesLongerThanTimeout() throws IOException \n\t{\n\t\tConfigurator configurator = buildProperties();\n\t\tconfigurator.configuration().setProperty(Configurator.STARTUP_TIMEOUT, 1);\n\t\tserver = createSlowServer(configurator);\n\t\t\n\t\ttry {\n\t\t\tserver.start();\n\t\t\tfail(\"Should have been interrupted.\");\n\t\t} catch(ServerStartupException e) {\n\t\t\t// ok!\n\t\t}\n\t\t\n\t}","id":9192,"modified_method":"@Test\n    public void shouldTimeoutIfStartupTakesLongerThanTimeout() throws IOException\n    {\n        // GIVEN\n        Configurator configurator = buildProperties().withStartupTimeout( 1 ).atPort( 7480 ).build();\n        server = createSlowServer( configurator, true );\n\n        // WHEN\n        try\n        {\n            server.start();\n            fail( \"Should have been interrupted.\" );\n        }\n        catch ( ServerStartupException e )\n        {\n            // THEN\n            assertThat( e.getMessage(), containsString( \"Startup took longer than\" ) );\n        }\n    }","commit_id":"f7bfcbc24a6ed58636f3990b3f260111ab8a5aa6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n\tpublic void shouldNotFailIfStartupTakesLessTimeThanTimeout() throws IOException \n\t{\n\t\tConfigurator configurator = buildProperties();\n\t\tconfigurator.configuration().setProperty(Configurator.STARTUP_TIMEOUT, 100);\n\t\tserver = new CommunityNeoServer(configurator){\n\t\t\t@Override\n\t\t\tprotected Iterable<ServerModule> createServerModules(){\n\t\t\t\treturn Arrays.asList();\n\t\t\t}\n\t\t};\n\n        // When\n\t\ttry {\n\t\t\tserver.start();\n\t\t} catch(ServerStartupException e) {\n\t\t\tfail(\"Should not have been interupted.\");\n\t\t}\n\n        // Then\n        InterruptThreadTimer timer = server.getDependencyResolver().resolveDependency( InterruptThreadTimer.class );\n\n        assertThat(timer.getState(), is( InterruptThreadTimer.State.IDLE));\n\t}","id":9193,"modified_method":"@Test\n\tpublic void shouldNotFailIfStartupTakesLessTimeThanTimeout() throws IOException\n\t{\n\t\tConfigurator configurator = buildProperties().withStartupTimeout( 100 ).atPort( 7480 ).build();\n        server = new CommunityNeoServer( configurator )\n        {\n            @Override\n            protected Iterable<ServerModule> createServerModules()\n            {\n                return Arrays.asList();\n            }\n        };\n\n        // When\n        try\n        {\n            server.start();\n        }\n        catch ( ServerStartupException e )\n        {\n            fail( \"Should not have been interupted.\" );\n        }\n\n        // Then\n        InterruptThreadTimer timer = server.getDependencyResolver().resolveDependency( InterruptThreadTimer.class );\n\n        assertThat( timer.getState(), is( InterruptThreadTimer.State.IDLE ) );\n\t}","commit_id":"f7bfcbc24a6ed58636f3990b3f260111ab8a5aa6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Configurator buildProperties() throws IOException\n    {\n        new File( test.directory().getAbsolutePath() + DIRSEP + \"conf\" ).mkdirs();\n\n        Properties databaseProperties = new Properties();\n        String databasePropertiesFileName = test.directory().getAbsolutePath() + DIRSEP + \"conf\"+ DIRSEP +\"neo4j.properties\";\n        databaseProperties.store( new FileWriter( databasePropertiesFileName ), null );\n\n        Properties serverProperties = new Properties();\n        String serverPropertiesFilename = test.directory().getAbsolutePath() + DIRSEP + \"conf\"+ DIRSEP +\"neo4j-server.properties\";\n        serverProperties.setProperty( Configurator.DATABASE_LOCATION_PROPERTY_KEY, test.directory().getAbsolutePath()\n                + DIRSEP + \"data\"+ DIRSEP +\"graph.db\" );\n\n        serverProperties.setProperty( Configurator.DB_TUNING_PROPERTY_FILE_KEY, databasePropertiesFileName );\n        serverProperties.setProperty( Configurator.NEO_SERVER_CONFIG_FILE_KEY, serverPropertiesFilename );\n        serverProperties.store( new FileWriter(serverPropertiesFilename), null);\n        \t\n        return new PropertyFileConfigurator(new File(serverPropertiesFilename));\n    }","id":9194,"modified_method":"private ConfiguratorBuilder buildProperties() throws IOException\n    {\n        new File( test.directory().getAbsolutePath() + DIRSEP + \"conf\" ).mkdirs();\n\n        Properties databaseProperties = new Properties();\n        String databasePropertiesFileName = test.directory().getAbsolutePath() + DIRSEP + \"conf\"+ DIRSEP +\"neo4j.properties\";\n        databaseProperties.store( new FileWriter( databasePropertiesFileName ), null );\n\n        Properties serverProperties = new Properties();\n        String serverPropertiesFilename = test.directory().getAbsolutePath() + DIRSEP + \"conf\"+ DIRSEP +\"neo4j-server.properties\";\n        serverProperties.setProperty( Configurator.DATABASE_LOCATION_PROPERTY_KEY, test.directory().getAbsolutePath()\n                + DIRSEP + \"data\"+ DIRSEP +\"graph.db\" );\n\n        serverProperties.setProperty( Configurator.DB_TUNING_PROPERTY_FILE_KEY, databasePropertiesFileName );\n        serverProperties.setProperty( Configurator.NEO_SERVER_CONFIG_FILE_KEY, serverPropertiesFilename );\n        serverProperties.store( new FileWriter(serverPropertiesFilename), null);\n\n        return new ConfiguratorBuilder( new PropertyFileConfigurator( new File( serverPropertiesFilename ) ) );\n    }","commit_id":"f7bfcbc24a6ed58636f3990b3f260111ab8a5aa6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private CommunityNeoServer createSlowServer(Configurator configurator) {\n\t\tCommunityNeoServer server = new CommunityNeoServer(configurator){\n\t\t\t@Override\n\t\t\tprotected Iterable<ServerModule> createServerModules(){\n\t\t\t\tServerModule slowModule = new ServerModule() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void start(StringLogger logger) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(1000 * 5);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n                            throw new RuntimeException( e );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void stop() { }\n        \t\t};\n\t\t\t\treturn Arrays.asList(slowModule);\n\t\t\t}\n\t\t};\n\t\treturn server;\n\t}","id":9195,"modified_method":"private CommunityNeoServer createSlowServer( Configurator configurator, final boolean preventMovingFurtherThanStartingModules )\n    {\n        final AtomicReference<Runnable> timerStartSignal = new AtomicReference<Runnable>();\n        CommunityNeoServer server = new CommunityNeoServer( configurator )\n        {\n            @Override\n            protected InterruptThreadTimer createInterruptStartupTimer()\n            {\n                /* Create an InterruptThreadTimer that won't start its count down until server modules have\n                 * started to load (and in the case of these tests wait long enough for the timer to trigger.\n                 * This makes it deterministic precisely where in the startup sequence the interrupt happens.\n                 * Whereas this is a bit too deterministic compared to the real world, this is a test that must\n                 * complete in the same way every time. Another test should verify that an interrupt happening\n                 * anywhere in the startup sequence still aborts the startup and cleans up properly. */\n\n                InterruptThreadTimer realTimer = super.createInterruptStartupTimer();\n                return timerThatStartsWhenModulesStartsLoading( realTimer );\n            }\n\n            private InterruptThreadTimer timerThatStartsWhenModulesStartsLoading( final InterruptThreadTimer realTimer )\n            {\n                return new InterruptThreadTimer()\n                {\n                    @Override\n                    public boolean wasTriggered()\n                    {\n                        return realTimer.wasTriggered();\n                    }\n\n                    @Override\n                    public void stopCountdown()\n                    {\n                        realTimer.stopCountdown();\n                    }\n\n                    @Override\n                    public void startCountdown()\n                    {\n                        timerStartSignal.set( new Runnable()\n                        {\n                            @Override\n                            public void run()\n                            {\n                                realTimer.startCountdown();\n                            }\n                        } );\n                    }\n\n                    @Override\n                    public long getTimeoutMillis()\n                    {\n                        return realTimer.getTimeoutMillis();\n                    }\n\n                    @Override\n                    public State getState()\n                    {\n                        return realTimer.getState();\n                    }\n                };\n            }\n\n            @Override\n            protected Iterable<ServerModule> createServerModules()\n            {\n                ServerModule slowModule = new ServerModule()\n                {\n                    @Override\n                    public void start( StringLogger logger )\n                    {\n                        timerStartSignal.get().run();\n                        try\n                        {\n                            Thread.sleep( 1000 * 5 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            throw new RuntimeException( e );\n                        }\n\n                        if ( preventMovingFurtherThanStartingModules )\n                        {\n                            fail( \"Should not get here\" );\n                        }\n                    }\n\n                    @Override\n                    public void stop()\n                    {\n                    }\n                };\n                return Arrays.asList( slowModule );\n            }\n        };\n        return server;\n    }","commit_id":"f7bfcbc24a6ed58636f3990b3f260111ab8a5aa6","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * \n     */\n    public String getIfAlias(int ifIndex) {\n        String snmpIfAlias = null;\n\n        if (hasIfXTable()) {\n            snmpIfAlias = m_ifXTable.getIfAlias(ifIndex);\n        }\n\n        // Debug\n        if (snmpIfAlias != null) {\n            log().debug(\"getIfAlias: ifIndex \" + ifIndex + \" has ifAlias '\" + snmpIfAlias + \"'\");\n        } else {\n            log().debug(\"getIfAlias: no ifAlias found for ifIndex \" + ifIndex);\n        }\n\n        return snmpIfAlias;\n    }","id":9196,"modified_method":"/**\n     * \n     */\n    public String getIfAlias(int ifIndex) {\n        String snmpIfAlias = null;\n\n        if (hasIfXTable()) {\n            snmpIfAlias = m_ifXTable.getIfAlias(ifIndex);\n\n            if (log().isDebugEnabled()) {\n                if (snmpIfAlias != null) {\n                    log().debug(\"getIfAlias: ifIndex \" + ifIndex + \" has ifAlias '\" + snmpIfAlias + \"'\");\n                } else {\n                    log().debug(\"getIfAlias: no ifAlias found for ifIndex \" + ifIndex);\n                }\n            }\n        } else {\n            if (log().isDebugEnabled()) {\n                log().debug(\"getIfAlias: no ifXTable retrieved from \" + m_address);\n            }\n        }\n\n        return snmpIfAlias;\n    }","commit_id":"0e4bca62f3aff6a1cc76c6426c69833572756b35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public final void FIXMEtestGetIfAlias() {\n        String ifAlias = m_ifSnmpc.getIfAlias(1);\n        assertNotNull(\"ifAlias should not be null\", ifAlias);\n        assertEquals(\"ifAlias\", \"We don't need no stinkin' ifAlias!\", ifAlias);\n    }","id":9197,"modified_method":"public final void testGetIfAlias() {\n        String ifAlias = m_ifSnmpc.getIfAlias(1);\n        assertNotNull(\"ifAlias should not be null\", ifAlias);\n        assertEquals(\"ifAlias\", \"We don't need no stinkin' ifAlias!\", ifAlias);\n    }","commit_id":"0e4bca62f3aff6a1cc76c6426c69833572756b35","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public String getIfAlias(int ifIndex) {\n        String snmpIfAlias = null;\n\n        if (hasIfXTable()) {\n            snmpIfAlias = m_ifXTable.getIfAlias(ifIndex);\n        }\n\n        // Debug\n        if (snmpIfAlias != null) {\n            log().debug(\"getIfAlias: ifIndex \" + ifIndex + \" has ifAlias '\" + snmpIfAlias + \"'\");\n        } else {\n            log().debug(\"getIfAlias: no ifAlias found for ifIndex \" + ifIndex);\n        }\n\n        return snmpIfAlias;\n    }","id":9198,"modified_method":"/**\n     * \n     */\n    public String getIfAlias(int ifIndex) {\n        String snmpIfAlias = null;\n\n        if (hasIfXTable()) {\n            snmpIfAlias = m_ifXTable.getIfAlias(ifIndex);\n\n            if (log().isDebugEnabled()) {\n                if (snmpIfAlias != null) {\n                    log().debug(\"getIfAlias: ifIndex \" + ifIndex + \" has ifAlias '\" + snmpIfAlias + \"'\");\n                } else {\n                    log().debug(\"getIfAlias: no ifAlias found for ifIndex \" + ifIndex);\n                }\n            }\n        } else {\n            if (log().isDebugEnabled()) {\n                log().debug(\"getIfAlias: no ifXTable retrieved from \" + m_address);\n            }\n        }\n\n        return snmpIfAlias;\n    }","commit_id":"71083be6471bc8d4d7351e5c8845d2497987366b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public final void FIXMEtestGetIfAlias() {\n        String ifAlias = m_ifSnmpc.getIfAlias(1);\n        assertNotNull(\"ifAlias should not be null\", ifAlias);\n        assertEquals(\"ifAlias\", \"We don't need no stinkin' ifAlias!\", ifAlias);\n    }","id":9199,"modified_method":"public final void testGetIfAlias() {\n        String ifAlias = m_ifSnmpc.getIfAlias(1);\n        assertNotNull(\"ifAlias should not be null\", ifAlias);\n        assertEquals(\"ifAlias\", \"We don't need no stinkin' ifAlias!\", ifAlias);\n    }","commit_id":"71083be6471bc8d4d7351e5c8845d2497987366b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * \n     */\n    public String getIfAlias(int ifIndex) {\n        String snmpIfAlias = null;\n\n        if (hasIfXTable()) {\n            snmpIfAlias = m_ifXTable.getIfAlias(ifIndex);\n        }\n\n        // Debug\n        if (snmpIfAlias != null) {\n            log().debug(\"getIfAlias: ifIndex \" + ifIndex + \" has ifAlias '\" + snmpIfAlias + \"'\");\n        } else {\n            log().debug(\"getIfAlias: no ifAlias found for ifIndex \" + ifIndex);\n        }\n\n        return snmpIfAlias;\n    }","id":9200,"modified_method":"/**\n     * \n     */\n    public String getIfAlias(int ifIndex) {\n        String snmpIfAlias = null;\n\n        if (hasIfXTable()) {\n            snmpIfAlias = m_ifXTable.getIfAlias(ifIndex);\n\n            if (log().isDebugEnabled()) {\n                if (snmpIfAlias != null) {\n                    log().debug(\"getIfAlias: ifIndex \" + ifIndex + \" has ifAlias '\" + snmpIfAlias + \"'\");\n                } else {\n                    log().debug(\"getIfAlias: no ifAlias found for ifIndex \" + ifIndex);\n                }\n            }\n        } else {\n            if (log().isDebugEnabled()) {\n                log().debug(\"getIfAlias: no ifXTable retrieved from \" + m_address);\n            }\n        }\n\n        return snmpIfAlias;\n    }","commit_id":"61d2796839b2953529bdca54feaca7c8d4685807","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public final void FIXMEtestGetIfAlias() {\n        String ifAlias = m_ifSnmpc.getIfAlias(1);\n        assertNotNull(\"ifAlias should not be null\", ifAlias);\n        assertEquals(\"ifAlias\", \"We don't need no stinkin' ifAlias!\", ifAlias);\n    }","id":9201,"modified_method":"public final void testGetIfAlias() {\n        String ifAlias = m_ifSnmpc.getIfAlias(1);\n        assertNotNull(\"ifAlias should not be null\", ifAlias);\n        assertEquals(\"ifAlias\", \"We don't need no stinkin' ifAlias!\", ifAlias);\n    }","commit_id":"61d2796839b2953529bdca54feaca7c8d4685807","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override public void toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(name);\n        builder.field(\"type\", CONTENT_TYPE);\n        builder.field(\"path\", pathType.name().toLowerCase());\n        builder.field(\"lat_lon\", enableLatLon);\n        builder.field(\"geohash\", enableGeohash);\n        builder.field(\"resolution\", resolution);\n        builder.field(\"store\", latMapper.name().toLowerCase());\n        builder.field(\"geohash_precision\", geohashPrecision);\n        if (precisionStep != null) {\n            builder.field(\"precision_step\", precisionStep);\n        }\n\n        builder.endObject();\n    }","id":9202,"modified_method":"@Override public void toXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(name);\n        builder.field(\"type\", CONTENT_TYPE);\n        builder.field(\"path\", pathType.name().toLowerCase());\n        builder.field(\"lat_lon\", enableLatLon);\n        builder.field(\"geohash\", enableGeohash);\n        builder.field(\"resolution\", resolution);\n        if (latMapper != null) {\n            builder.field(\"store\", latMapper.store().name().toLowerCase());\n        } else if (geohashMapper != null) {\n            builder.field(\"store\", geohashMapper.store().name().toLowerCase());\n        }\n        builder.field(\"geohash_precision\", geohashPrecision);\n        if (precisionStep != null) {\n            builder.field(\"precision_step\", precisionStep);\n        }\n\n        builder.endObject();\n    }","commit_id":"31362e4c601ff49b8dd37ef04283cce6fa1f130c","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public FacetCollector parse(String facetName, XContentParser parser, SearchContext context) throws IOException {\n        String keyField = null;\n        String valueField = null;\n        String keyScript = null;\n        String valueScript = null;\n        String scriptLang = null;\n        Map<String, Object> params = null;\n        long interval = 0;\n        HistogramFacet.ComparatorType comparatorType = HistogramFacet.ComparatorType.KEY;\n        XContentParser.Token token;\n        String fieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                fieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"params\".equals(fieldName)) {\n                    params = parser.map();\n                }\n            } else if (token.isValue()) {\n                if (\"field\".equals(fieldName)) {\n                    keyField = parser.text();\n                } else if (\"key_field\".equals(fieldName) || \"keyField\".equals(fieldName)) {\n                    keyField = parser.text();\n                } else if (\"value_field\".equals(fieldName) || \"valueField\".equals(fieldName)) {\n                    valueField = parser.text();\n                } else if (\"interval\".equals(fieldName)) {\n                    interval = parser.longValue();\n                } else if (\"time_interval\".equals(fieldName)) {\n                    interval = TimeValue.parseTimeValue(parser.text(), null).millis();\n                } else if (\"key_script\".equals(fieldName) || \"keyScript\".equals(fieldName)) {\n                    keyScript = parser.text();\n                } else if (\"value_script\".equals(fieldName) || \"valueScript\".equals(fieldName)) {\n                    valueScript = parser.text();\n                } else if (\"order\".equals(fieldName) || \"comparator\".equals(fieldName)) {\n                    comparatorType = HistogramFacet.ComparatorType.fromString(parser.text());\n                } else if (\"lang\".equals(fieldName)) {\n                    scriptLang = parser.text();\n                }\n            }\n        }\n\n        if (keyScript != null && valueScript != null) {\n            return new ScriptHistogramFacetCollector(facetName, scriptLang, keyScript, valueScript, params, interval, comparatorType, context);\n        }\n\n        if (keyField == null) {\n            throw new FacetPhaseExecutionException(facetName, \"key field is required to be set for histogram facet, either using [field] or using [key_field]\");\n        }\n\n        if (interval <= 0) {\n            throw new FacetPhaseExecutionException(facetName, \"[interval] is required to be set for histogram facet\");\n        }\n\n        if (interval < 0) {\n            throw new FacetPhaseExecutionException(facetName, \"[interval] is required to be positive for histogram facet\");\n        }\n\n        if (valueField == null || keyField.equals(valueField)) {\n            return new HistogramFacetCollector(facetName, keyField, interval, comparatorType, context);\n        } else {\n            // we have a value field, and its different than the key\n            return new KeyValueHistogramFacetCollector(facetName, keyField, valueField, interval, comparatorType, context);\n        }\n    }","id":9203,"modified_method":"@Override public FacetCollector parse(String facetName, XContentParser parser, SearchContext context) throws IOException {\n        String keyField = null;\n        String valueField = null;\n        String keyScript = null;\n        String valueScript = null;\n        String scriptLang = null;\n        Map<String, Object> params = null;\n        long interval = 0;\n        HistogramFacet.ComparatorType comparatorType = HistogramFacet.ComparatorType.KEY;\n        XContentParser.Token token;\n        String fieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                fieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"params\".equals(fieldName)) {\n                    params = parser.map();\n                }\n            } else if (token.isValue()) {\n                if (\"field\".equals(fieldName)) {\n                    keyField = parser.text();\n                } else if (\"key_field\".equals(fieldName) || \"keyField\".equals(fieldName)) {\n                    keyField = parser.text();\n                } else if (\"value_field\".equals(fieldName) || \"valueField\".equals(fieldName)) {\n                    valueField = parser.text();\n                } else if (\"interval\".equals(fieldName)) {\n                    interval = parser.longValue();\n                } else if (\"time_interval\".equals(fieldName)) {\n                    interval = TimeValue.parseTimeValue(parser.text(), null).millis();\n                } else if (\"key_script\".equals(fieldName) || \"keyScript\".equals(fieldName)) {\n                    keyScript = parser.text();\n                } else if (\"value_script\".equals(fieldName) || \"valueScript\".equals(fieldName)) {\n                    valueScript = parser.text();\n                } else if (\"order\".equals(fieldName) || \"comparator\".equals(fieldName)) {\n                    comparatorType = HistogramFacet.ComparatorType.fromString(parser.text());\n                } else if (\"lang\".equals(fieldName)) {\n                    scriptLang = parser.text();\n                }\n            }\n        }\n\n        if (keyScript != null && valueScript != null) {\n            return new ScriptHistogramFacetCollector(facetName, scriptLang, keyScript, valueScript, params, interval, comparatorType, context);\n        }\n\n        if (keyField == null) {\n            throw new FacetPhaseExecutionException(facetName, \"key field is required to be set for histogram facet, either using [field] or using [key_field]\");\n        }\n\n        if (interval <= 0) {\n            throw new FacetPhaseExecutionException(facetName, \"[interval] is required to be set for histogram facet\");\n        }\n\n        if (valueScript != null) {\n            return new KeyValueScriptHistogramFacetCollector(facetName, keyField, scriptLang, valueScript, params, interval, comparatorType, context);\n        } else if (valueField == null || keyField.equals(valueField)) {\n            return new HistogramFacetCollector(facetName, keyField, interval, comparatorType, context);\n        } else {\n            // we have a value field, and its different than the key\n            return new KeyValueHistogramFacetCollector(facetName, keyField, valueField, interval, comparatorType, context);\n        }\n    }","commit_id":"5c6c4bfb5a8571fde0d290fce7dcade235722189","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void toXContent(XContentBuilder builder, Params params) throws IOException {\n        if (keyScript == null) {\n            throw new SearchSourceBuilderException(\"key_script must be set on histogram script facet for facet [\" + name + \"]\");\n        }\n        if (valueScript == null) {\n            throw new SearchSourceBuilderException(\"value_script must be set on histogram script facet for facet [\" + name + \"]\");\n        }\n        builder.startObject(name);\n\n        builder.startObject(HistogramFacetCollectorParser.NAME);\n        builder.field(\"key_script\", keyScript);\n        builder.field(\"value_script\", valueScript);\n        if (lang != null) {\n            builder.field(\"lang\", lang);\n        }\n        if (interval > 0) { // interval is optional in script facet, can be defined by the key script\n            builder.field(\"interval\", interval);\n        }\n        if (this.params != null) {\n            builder.field(\"params\", this.params);\n        }\n        if (comparatorType != null) {\n            builder.field(\"comparator\", comparatorType.description());\n        }\n        builder.endObject();\n\n        addFilterFacetAndGlobal(builder, params);\n\n        builder.endObject();\n    }","id":9204,"modified_method":"@Override public void toXContent(XContentBuilder builder, Params params) throws IOException {\n        if (keyScript == null && keyFieldName == null) {\n            throw new SearchSourceBuilderException(\"key_script or key_field must be set on histogram script facet for facet [\" + name + \"]\");\n        }\n        if (valueScript == null) {\n            throw new SearchSourceBuilderException(\"value_script must be set on histogram script facet for facet [\" + name + \"]\");\n        }\n        builder.startObject(name);\n\n        builder.startObject(HistogramFacetCollectorParser.NAME);\n        if (keyFieldName != null) {\n            builder.field(\"key_field\", keyFieldName);\n        } else if (keyScript != null) {\n            builder.field(\"key_script\", keyScript);\n        }\n        builder.field(\"value_script\", valueScript);\n        if (lang != null) {\n            builder.field(\"lang\", lang);\n        }\n        if (interval > 0) { // interval is optional in script facet, can be defined by the key script\n            builder.field(\"interval\", interval);\n        }\n        if (this.params != null) {\n            builder.field(\"params\", this.params);\n        }\n        if (comparatorType != null) {\n            builder.field(\"comparator\", comparatorType.description());\n        }\n        builder.endObject();\n\n        addFilterFacetAndGlobal(builder, params);\n\n        builder.endObject();\n    }","commit_id":"5c6c4bfb5a8571fde0d290fce7dcade235722189","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test public void testHistoFacets() throws Exception {\n        try {\n            client.admin().indices().prepareDelete(\"test\").execute().actionGet();\n        } catch (Exception e) {\n            // ignore\n        }\n        client.admin().indices().prepareCreate(\"test\").execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\").setSource(jsonBuilder().startObject()\n                .field(\"num\", 1055)\n                .field(\"date\", \"1970-01-01T00:00:00\")\n                .startArray(\"multi_num\").value(13.0f).value(23.f).endArray()\n                .endObject()).execute().actionGet();\n        client.admin().indices().prepareFlush().setRefresh(true).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\").setSource(jsonBuilder().startObject()\n                .field(\"num\", 1065)\n                .field(\"date\", \"1970-01-01T00:00:25\")\n                .startArray(\"multi_num\").value(15.0f).value(31.0f).endArray()\n                .endObject()).execute().actionGet();\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\").setSource(jsonBuilder().startObject()\n                .field(\"num\", 1175)\n                .field(\"date\", \"1970-01-01T00:02:00\")\n                .startArray(\"multi_num\").value(17.0f).value(25.0f).endArray()\n                .endObject()).execute().actionGet();\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch()\n                .setQuery(matchAllQuery())\n                .addFacet(histogramFacet(\"stats1\").field(\"num\").interval(100))\n                .addFacet(histogramFacet(\"stats2\").field(\"multi_num\").interval(10))\n                .addFacet(histogramFacet(\"stats3\").keyField(\"num\").valueField(\"multi_num\").interval(100))\n                .addFacet(histogramScriptFacet(\"stats4\").keyScript(\"doc['date'].date.minuteOfHour\").valueScript(\"doc['num'].value\"))\n                .addFacet(histogramFacet(\"stats5\").field(\"date\").interval(1, TimeUnit.MINUTES))\n                .execute().actionGet();\n\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n\n        HistogramFacet facet = searchResponse.facets().facet(\"stats1\");\n        assertThat(facet.name(), equalTo(\"stats1\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(1000l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(0).total(), equalTo(2120d));\n        assertThat(facet.entries().get(0).mean(), equalTo(1060d));\n        assertThat(facet.entries().get(1).key(), equalTo(1100l));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n        assertThat(facet.entries().get(1).total(), equalTo(1175d));\n        assertThat(facet.entries().get(1).mean(), equalTo(1175d));\n\n        facet = searchResponse.facets().facet(\"stats2\");\n        assertThat(facet.name(), equalTo(\"stats2\"));\n        assertThat(facet.entries().size(), equalTo(3));\n        assertThat(facet.entries().get(0).key(), equalTo(10l));\n        assertThat(facet.entries().get(0).count(), equalTo(3l));\n        assertThat(facet.entries().get(0).total(), equalTo(45d));\n        assertThat(facet.entries().get(0).mean(), equalTo(15d));\n        assertThat(facet.entries().get(1).key(), equalTo(20l));\n        assertThat(facet.entries().get(1).count(), equalTo(2l));\n        assertThat(facet.entries().get(1).total(), equalTo(48d));\n        assertThat(facet.entries().get(1).mean(), equalTo(24d));\n        assertThat(facet.entries().get(2).key(), equalTo(30l));\n        assertThat(facet.entries().get(2).count(), equalTo(1l));\n        assertThat(facet.entries().get(2).total(), equalTo(31d));\n        assertThat(facet.entries().get(2).mean(), equalTo(31d));\n\n        facet = searchResponse.facets().facet(\"stats3\");\n        assertThat(facet.name(), equalTo(\"stats3\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(1000l));\n        assertThat(facet.entries().get(0).count(), equalTo(4l));\n        assertThat(facet.entries().get(0).total(), equalTo(82d));\n        assertThat(facet.entries().get(0).mean(), equalTo(20.5d));\n        assertThat(facet.entries().get(1).key(), equalTo(1100l));\n        assertThat(facet.entries().get(1).count(), equalTo(2l));\n        assertThat(facet.entries().get(1).total(), equalTo(42d));\n        assertThat(facet.entries().get(1).mean(), equalTo(21d));\n\n        facet = searchResponse.facets().facet(\"stats4\");\n        assertThat(facet.name(), equalTo(\"stats4\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(0l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(0).total(), equalTo(2120d));\n        assertThat(facet.entries().get(0).mean(), equalTo(1060d));\n        assertThat(facet.entries().get(1).key(), equalTo(2l));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n        assertThat(facet.entries().get(1).total(), equalTo(1175d));\n        assertThat(facet.entries().get(1).mean(), equalTo(1175d));\n\n        facet = searchResponse.facets().facet(\"stats5\");\n        assertThat(facet.name(), equalTo(\"stats5\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(0l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(1).key(), equalTo(TimeValue.timeValueMinutes(2).millis()));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n    }","id":9205,"modified_method":"@Test public void testHistoFacets() throws Exception {\n        try {\n            client.admin().indices().prepareDelete(\"test\").execute().actionGet();\n        } catch (Exception e) {\n            // ignore\n        }\n        client.admin().indices().prepareCreate(\"test\").execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\").setSource(jsonBuilder().startObject()\n                .field(\"num\", 1055)\n                .field(\"date\", \"1970-01-01T00:00:00\")\n                .startArray(\"multi_num\").value(13.0f).value(23.f).endArray()\n                .endObject()).execute().actionGet();\n        client.admin().indices().prepareFlush().setRefresh(true).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\").setSource(jsonBuilder().startObject()\n                .field(\"num\", 1065)\n                .field(\"date\", \"1970-01-01T00:00:25\")\n                .startArray(\"multi_num\").value(15.0f).value(31.0f).endArray()\n                .endObject()).execute().actionGet();\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\").setSource(jsonBuilder().startObject()\n                .field(\"num\", 1175)\n                .field(\"date\", \"1970-01-01T00:02:00\")\n                .startArray(\"multi_num\").value(17.0f).value(25.0f).endArray()\n                .endObject()).execute().actionGet();\n        client.admin().indices().prepareRefresh().execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch()\n                .setQuery(matchAllQuery())\n                .addFacet(histogramFacet(\"stats1\").field(\"num\").interval(100))\n                .addFacet(histogramFacet(\"stats2\").field(\"multi_num\").interval(10))\n                .addFacet(histogramFacet(\"stats3\").keyField(\"num\").valueField(\"multi_num\").interval(100))\n                .addFacet(histogramScriptFacet(\"stats4\").keyScript(\"doc['date'].date.minuteOfHour\").valueScript(\"doc['num'].value\"))\n                .addFacet(histogramFacet(\"stats5\").field(\"date\").interval(1, TimeUnit.MINUTES))\n                .addFacet(histogramScriptFacet(\"stats6\").keyField(\"num\").valueScript(\"doc['num'].value\").interval(100))\n                .execute().actionGet();\n\n        if (searchResponse.failedShards() > 0) {\n            logger.warn(\"Failed shards:\");\n            for (ShardSearchFailure shardSearchFailure : searchResponse.shardFailures()) {\n                logger.warn(\"-> {}\", shardSearchFailure);\n            }\n        }\n        assertThat(searchResponse.failedShards(), equalTo(0));\n\n        HistogramFacet facet = searchResponse.facets().facet(\"stats1\");\n        assertThat(facet.name(), equalTo(\"stats1\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(1000l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(0).total(), equalTo(2120d));\n        assertThat(facet.entries().get(0).mean(), equalTo(1060d));\n        assertThat(facet.entries().get(1).key(), equalTo(1100l));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n        assertThat(facet.entries().get(1).total(), equalTo(1175d));\n        assertThat(facet.entries().get(1).mean(), equalTo(1175d));\n\n        facet = searchResponse.facets().facet(\"stats2\");\n        assertThat(facet.name(), equalTo(\"stats2\"));\n        assertThat(facet.entries().size(), equalTo(3));\n        assertThat(facet.entries().get(0).key(), equalTo(10l));\n        assertThat(facet.entries().get(0).count(), equalTo(3l));\n        assertThat(facet.entries().get(0).total(), equalTo(45d));\n        assertThat(facet.entries().get(0).mean(), equalTo(15d));\n        assertThat(facet.entries().get(1).key(), equalTo(20l));\n        assertThat(facet.entries().get(1).count(), equalTo(2l));\n        assertThat(facet.entries().get(1).total(), equalTo(48d));\n        assertThat(facet.entries().get(1).mean(), equalTo(24d));\n        assertThat(facet.entries().get(2).key(), equalTo(30l));\n        assertThat(facet.entries().get(2).count(), equalTo(1l));\n        assertThat(facet.entries().get(2).total(), equalTo(31d));\n        assertThat(facet.entries().get(2).mean(), equalTo(31d));\n\n        facet = searchResponse.facets().facet(\"stats3\");\n        assertThat(facet.name(), equalTo(\"stats3\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(1000l));\n        assertThat(facet.entries().get(0).count(), equalTo(4l));\n        assertThat(facet.entries().get(0).total(), equalTo(82d));\n        assertThat(facet.entries().get(0).mean(), equalTo(20.5d));\n        assertThat(facet.entries().get(1).key(), equalTo(1100l));\n        assertThat(facet.entries().get(1).count(), equalTo(2l));\n        assertThat(facet.entries().get(1).total(), equalTo(42d));\n        assertThat(facet.entries().get(1).mean(), equalTo(21d));\n\n        facet = searchResponse.facets().facet(\"stats4\");\n        assertThat(facet.name(), equalTo(\"stats4\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(0l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(0).total(), equalTo(2120d));\n        assertThat(facet.entries().get(0).mean(), equalTo(1060d));\n        assertThat(facet.entries().get(1).key(), equalTo(2l));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n        assertThat(facet.entries().get(1).total(), equalTo(1175d));\n        assertThat(facet.entries().get(1).mean(), equalTo(1175d));\n\n        facet = searchResponse.facets().facet(\"stats5\");\n        assertThat(facet.name(), equalTo(\"stats5\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(0l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(1).key(), equalTo(TimeValue.timeValueMinutes(2).millis()));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n\n        facet = searchResponse.facets().facet(\"stats6\");\n        assertThat(facet.name(), equalTo(\"stats6\"));\n        assertThat(facet.entries().size(), equalTo(2));\n        assertThat(facet.entries().get(0).key(), equalTo(1000l));\n        assertThat(facet.entries().get(0).count(), equalTo(2l));\n        assertThat(facet.entries().get(0).total(), equalTo(2120d));\n        assertThat(facet.entries().get(0).mean(), equalTo(1060d));\n        assertThat(facet.entries().get(1).key(), equalTo(1100l));\n        assertThat(facet.entries().get(1).count(), equalTo(1l));\n        assertThat(facet.entries().get(1).total(), equalTo(1175d));\n        assertThat(facet.entries().get(1).mean(), equalTo(1175d));\n    }","commit_id":"5c6c4bfb5a8571fde0d290fce7dcade235722189","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static HasParentFilterBuilder hasParentFilter(String parentType, QueryBuilder query) {\n        return new HasParentFilterBuilder(parentType, query);\n    }","id":9206,"modified_method":"/**\n     * Constructs a parent filter, with the parent type and the query to run against parent documents, with\n     * the result of the filter being the *child* documents.\n     *\n     * @param parentType The parent type\n     * @param query      The query to run against the parent type\n     */\n    public static HasParentFilterBuilder hasParentFilter(String parentType, QueryBuilder query) {\n        return new HasParentFilterBuilder(parentType, query);\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public HasChildFilterBuilder(String type, QueryBuilder queryBuilder) {\n        this.childType = type;\n        this.queryBuilder = queryBuilder;\n    }","id":9207,"modified_method":"public HasChildFilterBuilder(String type, QueryBuilder queryBuilder) {\n        this.childType = type;\n        this.queryBuilder = queryBuilder;\n        this.filterBuilder = null;\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasChildFilterParser.NAME);\n        builder.field(\"query\");\n        queryBuilder.toXContent(builder, params);\n        builder.field(\"child_type\", childType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (filterName != null) {\n            builder.field(\"_name\", filterName);\n        }\n        if (executionType != null) {\n            builder.field(\"execution_type\", executionType);\n        }\n        builder.endObject();\n    }","id":9208,"modified_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasChildFilterParser.NAME);\n        if (queryBuilder != null) {\n            builder.field(\"query\");\n            queryBuilder.toXContent(builder, params);\n        } else if (filterBuilder != null) {\n            builder.field(\"filter\");\n            filterBuilder.toXContent(builder, params);\n        }\n        builder.field(\"child_type\", childType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (filterName != null) {\n            builder.field(\"_name\", filterName);\n        }\n        if (executionType != null) {\n            builder.field(\"execution_type\", executionType);\n        }\n        builder.endObject();\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        String childType = null;\n        String scope = null;\n\n        String executionType = \"uid\";\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO we need to set the type, but, `query` can come before `type`...\n                    // since we switch types, make sure we change the context\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName) || \"child_type\".equals(currentFieldName) || \"childType\".equals(currentFieldName)) {\n                    childType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"execution_type\".equals(currentFieldName) || \"executionType\".equals(currentFieldName)) {// This option is experimental and will most likely be removed.\n                    executionType = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n        if (childType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'type' field\");\n        }\n\n        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);\n        if (childDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"No mapping for for type [\" + childType + \"]\");\n        }\n        if (childDocMapper.parentFieldMapper() == null) {\n            throw new QueryParsingException(parseContext.index(), \"Type [\" + childType + \"] does not have parent mapping\");\n        }\n        String parentType = childDocMapper.parentFieldMapper().type();\n\n        // wrap the query with type query\n        query = new XFilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n\n        HasChildFilter childFilter = HasChildFilter.create(query, scope, parentType, childType, searchContext, executionType);\n        searchContext.addScopePhase(childFilter);\n\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, childFilter);\n        }\n        return childFilter;\n    }","id":9209,"modified_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        String childType = null;\n        String scope = null;\n\n        String executionType = \"uid\";\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO we need to set the type, but, `query` can come before `type`...\n                    // since we switch types, make sure we change the context\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else if (\"filter\".equals(currentFieldName)) {\n                    // TODO handle `filter` element before `type` element...\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});\n                    try {\n                        Filter innerFilter = parseContext.parseInnerFilter();\n                        query = new XConstantScoreQuery(innerFilter);\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName) || \"child_type\".equals(currentFieldName) || \"childType\".equals(currentFieldName)) {\n                    childType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"execution_type\".equals(currentFieldName) || \"executionType\".equals(currentFieldName)) {// This option is experimental and will most likely be removed.\n                    executionType = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_child] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n        if (childType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[child] filter requires 'type' field\");\n        }\n\n        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);\n        if (childDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"No mapping for for type [\" + childType + \"]\");\n        }\n        if (childDocMapper.parentFieldMapper() == null) {\n            throw new QueryParsingException(parseContext.index(), \"Type [\" + childType + \"] does not have parent mapping\");\n        }\n        String parentType = childDocMapper.parentFieldMapper().type();\n\n        // wrap the query with type query\n        query = new XFilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n\n        HasChildFilter childFilter = HasChildFilter.create(query, scope, parentType, childType, searchContext, executionType);\n        searchContext.addScopePhase(childFilter);\n\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, childFilter);\n        }\n        return childFilter;\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * @param parentType The parent type\n     * @param parentQuery The query that will be matched with parent documents\n     */\n    public HasParentFilterBuilder(String parentType, QueryBuilder parentQuery) {\n        this.parentType = parentType;\n        this.queryBuilder = parentQuery;\n    }","id":9210,"modified_method":"/**\n     * @param parentType  The parent type\n     * @param parentQuery The query that will be matched with parent documents\n     */\n    public HasParentFilterBuilder(String parentType, QueryBuilder parentQuery) {\n        this.parentType = parentType;\n        this.queryBuilder = parentQuery;\n        this.filterBuilder = null;\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasParentFilterParser.NAME);\n        builder.field(\"query\");\n        queryBuilder.toXContent(builder, params);\n        builder.field(\"parent_type\", parentType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (filterName != null) {\n            builder.field(\"_name\", filterName);\n        }\n        if (executionType != null) {\n            builder.field(\"execution_type\", executionType);\n        }\n        builder.endObject();\n    }","id":9211,"modified_method":"@Override\n    protected void doXContent(XContentBuilder builder, Params params) throws IOException {\n        builder.startObject(HasParentFilterParser.NAME);\n        if (queryBuilder != null) {\n            builder.field(\"query\");\n            queryBuilder.toXContent(builder, params);\n        } else if (filterBuilder != null) {\n            builder.field(\"filter\");\n            filterBuilder.toXContent(builder, params);\n        }\n        builder.field(\"parent_type\", parentType);\n        if (scope != null) {\n            builder.field(\"_scope\", scope);\n        }\n        if (filterName != null) {\n            builder.field(\"_name\", filterName);\n        }\n        if (executionType != null) {\n            builder.field(\"execution_type\", executionType);\n        }\n        builder.endObject();\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        String parentType = null;\n        String executionType = \"uid\";\n        String scope = null;\n\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO handle `query` element before `type` element...\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(parentType == null ? null : new String[]{parentType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_parent] filter does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName) || \"parent_type\".equals(currentFieldName) || \"parentType\".equals(currentFieldName)) {\n                    parentType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"execution_type\".equals(currentFieldName) || \"executionType\".equals(currentFieldName)) { // This option is experimental and will most likely be removed.\n                    executionType = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_parent] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[parent] filter requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n\n        if (parentType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[parent] filter requires 'parent_type' field\");\n        }\n\n        DocumentMapper parentDocMapper = parseContext.mapperService().documentMapper(parentType);\n        if (parentDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"[parent] filter configured 'parent_type' [\" + parentType + \"] is not a valid type\");\n        }\n\n        // wrap the query with type query\n        query = new XFilteredQuery(query, parseContext.cacheFilter(parentDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n\n        HasParentFilter parentFilter = HasParentFilter.create(executionType, query, scope, parentType, searchContext);\n        searchContext.addScopePhase(parentFilter);\n\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, parentFilter);\n        }\n        return parentFilter;\n    }","id":9212,"modified_method":"@Override\n    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {\n        XContentParser parser = parseContext.parser();\n\n        Query query = null;\n        boolean queryFound = false;\n        String parentType = null;\n        String executionType = \"uid\";\n        String scope = null;\n\n        String filterName = null;\n        String currentFieldName = null;\n        XContentParser.Token token;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                if (\"query\".equals(currentFieldName)) {\n                    // TODO handle `query` element before `type` element...\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(parentType == null ? null : new String[]{parentType});\n                    try {\n                        query = parseContext.parseInnerQuery();\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else if (\"filter\".equals(currentFieldName)) {\n                    // TODO handle `filter` element before `type` element...\n                    String[] origTypes = QueryParseContext.setTypesWithPrevious(parentType == null ? null : new String[]{parentType});\n                    try {\n                        Filter innerFilter = parseContext.parseInnerFilter();\n                        query = new XConstantScoreQuery(innerFilter);\n                        queryFound = true;\n                    } finally {\n                        QueryParseContext.setTypes(origTypes);\n                    }\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_parent] filter does not support [\" + currentFieldName + \"]\");\n                }\n            } else if (token.isValue()) {\n                if (\"type\".equals(currentFieldName) || \"parent_type\".equals(currentFieldName) || \"parentType\".equals(currentFieldName)) {\n                    parentType = parser.text();\n                } else if (\"_scope\".equals(currentFieldName)) {\n                    scope = parser.text();\n                } else if (\"_name\".equals(currentFieldName)) {\n                    filterName = parser.text();\n                } else if (\"execution_type\".equals(currentFieldName) || \"executionType\".equals(currentFieldName)) { // This option is experimental and will most likely be removed.\n                    executionType = parser.text();\n                } else {\n                    throw new QueryParsingException(parseContext.index(), \"[has_parent] filter does not support [\" + currentFieldName + \"]\");\n                }\n            }\n        }\n        if (!queryFound) {\n            throw new QueryParsingException(parseContext.index(), \"[parent] filter requires 'query' field\");\n        }\n        if (query == null) {\n            return null;\n        }\n\n        if (parentType == null) {\n            throw new QueryParsingException(parseContext.index(), \"[parent] filter requires 'parent_type' field\");\n        }\n\n        DocumentMapper parentDocMapper = parseContext.mapperService().documentMapper(parentType);\n        if (parentDocMapper == null) {\n            throw new QueryParsingException(parseContext.index(), \"[parent] filter configured 'parent_type' [\" + parentType + \"] is not a valid type\");\n        }\n\n        // wrap the query with type query\n        query = new XFilteredQuery(query, parseContext.cacheFilter(parentDocMapper.typeFilter(), null));\n\n        SearchContext searchContext = SearchContext.current();\n\n        HasParentFilter parentFilter = HasParentFilter.create(executionType, query, scope, parentType, searchContext);\n        searchContext.addScopePhase(parentFilter);\n\n        if (filterName != null) {\n            parseContext.addNamedFilter(filterName, parentFilter);\n        }\n        return parentFilter;\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testHasChildAndHasParentFailWhenSomeSegmentsDontContainAnyParentOrChildDocs() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(\n                ImmutableSettings.settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 0)\n        ).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(\n                jsonBuilder()\n                        .startObject()\n                        .startObject(\"type\")\n                        .startObject(\"_parent\")\n                        .field(\"type\", \"parent\")\n                        .endObject()\n                        .endObject()\n                        .endObject()\n        ).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"parent\", \"1\").setSource(\"p_field\", 1).execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"1\").setParent(\"1\").setSource(\"c_field\", 1).execute().actionGet();\n        client.admin().indices().prepareFlush(\"test\").execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\", \"1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.admin().indices().prepareFlush(\"test\").execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\")\n                .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", matchAllQuery())))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n\n        client.prepareSearch(\"test\")\n                .setQuery(filteredQuery(matchAllQuery(), hasParentFilter(\"parent\", matchAllQuery())))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n    }","id":9213,"modified_method":"@Test\n    public void testHasChildAndHasParentFailWhenSomeSegmentsDontContainAnyParentOrChildDocs() throws Exception {\n        client.admin().indices().prepareDelete().execute().actionGet();\n\n        client.admin().indices().prepareCreate(\"test\").setSettings(\n                ImmutableSettings.settingsBuilder()\n                        .put(\"index.number_of_shards\", 1)\n                        .put(\"index.number_of_replicas\", 0)\n        ).execute().actionGet();\n        client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();\n        client.admin().indices().preparePutMapping(\"test\").setType(\"child\").setSource(\n                jsonBuilder()\n                        .startObject()\n                        .startObject(\"type\")\n                        .startObject(\"_parent\")\n                        .field(\"type\", \"parent\")\n                        .endObject()\n                        .endObject()\n                        .endObject()\n        ).execute().actionGet();\n\n        client.prepareIndex(\"test\", \"parent\", \"1\").setSource(\"p_field\", 1).execute().actionGet();\n        client.prepareIndex(\"test\", \"child\", \"1\").setParent(\"1\").setSource(\"c_field\", 1).execute().actionGet();\n        client.admin().indices().prepareFlush(\"test\").execute().actionGet();\n\n        client.prepareIndex(\"test\", \"type1\", \"1\").setSource(\"p_field\", \"p_value1\").execute().actionGet();\n        client.admin().indices().prepareFlush(\"test\").execute().actionGet();\n\n        SearchResponse searchResponse = client.prepareSearch(\"test\")\n                .setQuery(filteredQuery(matchAllQuery(), hasChildFilter(\"child\", matchAllQuery())))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n\n        searchResponse = client.prepareSearch(\"test\")\n                .setQuery(filteredQuery(matchAllQuery(), hasParentFilter(\"parent\", matchAllQuery())))\n                .execute().actionGet();\n        assertThat(\"Failures \" + Arrays.toString(searchResponse.shardFailures()), searchResponse.shardFailures().length, equalTo(0));\n        assertThat(searchResponse.failedShards(), equalTo(0));\n        assertThat(searchResponse.hits().totalHits(), equalTo(1l));\n    }","commit_id":"9013eeae8ab0af6ca88ba966439b6b6789cab316","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private DocIdSetIterator getDISI(ArrayList<Filter> filters, int index, IndexReader reader)\n            throws IOException {\n        DocIdSet docIdSet = filters.get(index).getDocIdSet(reader);\n        if (docIdSet == null) {\n            return DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        DocIdSetIterator iterator = docIdSet.iterator();\n        if (iterator == null) {\n            return DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        return iterator;\n    }","id":9214,"modified_method":"private DocIdSet getDISI(ArrayList<Filter> filters, int index, IndexReader reader)\n            throws IOException {\n        DocIdSet docIdSet = filters.get(index).getDocIdSet(reader);\n        if (docIdSet == DocIdSet.EMPTY_DOCIDSET || docIdSet == DocSet.EMPTY_DOC_SET) {\n            return null;\n        }\n        return docIdSet;\n    }","commit_id":"62bc0836c1a584fa31f741b26a2f8f86cee595c7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Returns the a DocIdSetIterator representing the Boolean composition\n     * of the filters that have been added.\n     */\n    @Override\n    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        FixedBitSet res = null;\n\n        if (shouldFilters != null) {\n            for (int i = 0; i < shouldFilters.size(); i++) {\n                if (res == null) {\n                    res = DocSets.createFixedBitSet(getDISI(shouldFilters, i, reader), reader.maxDoc());\n                } else {\n                    DocIdSet dis = shouldFilters.get(i).getDocIdSet(reader);\n                    DocSets.or(res, dis);\n                }\n            }\n        }\n\n        if (notFilters != null) {\n            for (int i = 0; i < notFilters.size(); i++) {\n                if (res == null) {\n                    res = DocSets.createFixedBitSet(getDISI(notFilters, i, reader), reader.maxDoc());\n                    res.flip(0, reader.maxDoc()); // NOTE: may set bits on deleted docs\n                } else {\n                    DocIdSet dis = notFilters.get(i).getDocIdSet(reader);\n                    DocSets.andNot(res, dis);\n                }\n            }\n        }\n\n        if (mustFilters != null) {\n            for (int i = 0; i < mustFilters.size(); i++) {\n                if (res == null) {\n                    res = DocSets.createFixedBitSet(getDISI(mustFilters, i, reader), reader.maxDoc());\n                } else {\n                    DocIdSet dis = mustFilters.get(i).getDocIdSet(reader);\n                    DocSets.and(res, dis);\n                }\n            }\n        }\n\n        return res;\n    }","id":9215,"modified_method":"/**\n     * Returns the a DocIdSetIterator representing the Boolean composition\n     * of the filters that have been added.\n     */\n    @Override\n    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {\n        FixedBitSet res = null;\n\n        if (shouldFilters != null) {\n            for (int i = 0; i < shouldFilters.size(); i++) {\n                final DocIdSet disi = getDISI(shouldFilters, i, reader);\n                if (disi == null) continue;\n                if (res == null) {\n                    res = new FixedBitSet(reader.maxDoc());\n                }\n                DocSets.or(res, disi);\n            }\n        }\n\n        if (notFilters != null) {\n            for (int i = 0; i < notFilters.size(); i++) {\n                if (res == null) {\n                    res = new FixedBitSet(reader.maxDoc());\n                    res.set(0, reader.maxDoc()); // NOTE: may set bits on deleted docs\n                }\n                final DocIdSet disi = getDISI(notFilters, i, reader);\n                if (disi != null) {\n                    DocSets.andNot(res, disi);\n                }\n            }\n        }\n\n        if (mustFilters != null) {\n            for (int i = 0; i < mustFilters.size(); i++) {\n                final DocIdSet disi = getDISI(mustFilters, i, reader);\n                if (disi == null) {\n                    return null;\n                }\n                if (res == null) {\n                    res = new FixedBitSet(reader.maxDoc());\n                    DocSets.or(res, disi);\n                } else {\n                    DocSets.and(res, disi);\n                }\n            }\n        }\n\n        return res;\n    }","commit_id":"62bc0836c1a584fa31f741b26a2f8f86cee595c7","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n                    ConcurrentMap<Address,ConnectionHandler> map;\n\n                    if(log.isTraceEnabled())\n                        log.trace(\"Received \" + request + \" on socket \" + sock);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(\"received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(\"failed routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","id":9216,"modified_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n                    ConcurrentMap<Address,ConnectionHandler> map;\n\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" received \" + request);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(this +\" received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(this +\" failed in routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            if(log.isDebugEnabled())\n                                log.debug(this + \" responded to GOSSIP_GET with \" + mbrs);\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                                if(log.isDebugEnabled())\n                                    log.debug(this + \" disconnect completed\");\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" processed  \" + request);\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","commit_id":"dd6dd7cac76803141cb879f52b80729da4219435","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            if(active.compareAndSet(false, true)) {\n                try {\n                    readLoop();\n                }\n                finally {\n                    close();\n                }\n            }\n        }","id":9217,"modified_method":"public void run() {\n            if(active.compareAndSet(false, true)) {\n                try {\n                    if(log.isDebugEnabled())\n                        log.debug(this + \" entering receive loop\");\n                    readLoop();\n                }\n                finally {\n                    close();\n                }\n            }\n        }","commit_id":"dd6dd7cac76803141cb879f52b80729da4219435","url":"https://github.com/belaban/JGroups"},{"original_method":"void close() {\n            if(active.compareAndSet(true, false)) {\n                if(log.isDebugEnabled())\n                    log.debug(\"Closing connection handler \" + this.toString());\n                \n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n                for(Address addr: logical_addrs) {\n                    removeEntry(null, addr);\n                }\n            }\n        }","id":9218,"modified_method":"void close() {\n            if(active.compareAndSet(true, false)) {\n                if(log.isDebugEnabled())\n                    log.debug(this + \" is being closed\");\n                \n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n                for(Address addr: logical_addrs) {\n                    removeEntry(null, addr);\n                }\n            }\n        }","commit_id":"dd6dd7cac76803141cb879f52b80729da4219435","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleConnect(GossipData request, Address addr, String group) throws Exception {\n            ConcurrentMap<Address, ConnectionHandler> map = null;\n            try {               \n                String logical_name = request.getLogicalName();\n                if (logical_name != null && addr instanceof org.jgroups.util.UUID)\n                    org.jgroups.util.UUID.add((org.jgroups.util.UUID) addr, logical_name);\n\n                // group name, logical address, logical name, physical addresses (could be null)\n                logical_addrs.add(addr); // allows us to remove the entries for this connection on\n                                         // socket close\n\n                map = routingTable.get(group);\n                if (map == null) {\n                    map = new ConcurrentHashMap<Address, ConnectionHandler>();\n                    routingTable.put(group, map); // no concurrent requests on the same connection\n                }\n                map.put(addr, this);\n\n                Set<PhysicalAddress> physical_addrs;\n                if (request.getPhysicalAddresses() != null) {\n                    physical_addrs = address_mappings.get(addr);\n                    if (physical_addrs == null) {\n                        physical_addrs = new HashSet<PhysicalAddress>();\n                        address_mappings.put(addr, physical_addrs);\n                    }\n                    physical_addrs.addAll(request.getPhysicalAddresses());\n                }\n                sendStatus(CONNECT_OK);\n                \n                if(log.isTraceEnabled())\n                    log.trace(\"Connection established, added  \" +addr + \" to group \"+ group);\n                \n            } catch (Exception e) {\n                removeEntry(group, addr);\n                sendStatus(OP_FAIL);\n                throw new Exception(\"Unsuccessful connection setup handshake\");\n            }\n        }","id":9219,"modified_method":"private void handleConnect(GossipData request, Address addr, String group) throws Exception {\n            ConcurrentMap<Address, ConnectionHandler> map = null;                       \n            try {               \n                \n                checkExistingConnection(addr,group);\n                \n                String logical_name = request.getLogicalName();\n                if (logical_name != null && addr instanceof org.jgroups.util.UUID)\n                    org.jgroups.util.UUID.add((org.jgroups.util.UUID) addr, logical_name);\n\n                // group name, logical address, logical name, physical addresses (could be null)\n                logical_addrs.add(addr); // allows us to remove the entries for this connection on\n                                         // socket close\n\n                map = routingTable.get(group);\n                if (map == null) {\n                    map = new ConcurrentHashMap<Address, ConnectionHandler>();\n                    routingTable.put(group, map); // no concurrent requests on the same connection\n                }\n                map.put(addr, this);\n\n                Set<PhysicalAddress> physical_addrs;\n                if (request.getPhysicalAddresses() != null) {\n                    physical_addrs = address_mappings.get(addr);\n                    if (physical_addrs == null) {\n                        physical_addrs = new HashSet<PhysicalAddress>();\n                        address_mappings.put(addr, physical_addrs);\n                    }\n                    physical_addrs.addAll(request.getPhysicalAddresses());\n                }\n                sendStatus(CONNECT_OK);\n                \n                if(log.isDebugEnabled())\n                    log.debug(this + \" connection handshake completed, added \" +addr + \" to group \"+ group);\n                \n            } catch (Exception e) {\n                removeEntry(group, addr);\n                sendStatus(OP_FAIL);\n                throw new Exception(\"Unsuccessful connection setup handshake for \" + this);\n            }\n        }","commit_id":"dd6dd7cac76803141cb879f52b80729da4219435","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            StringBuilder sb=new StringBuilder();\n            sb.append(\"peer: \" + sock.getInetAddress());\n            if(!logical_addrs.isEmpty())\n                sb.append(\", logical_addrs: \" + Util.printListWithDelimiter(logical_addrs, \", \"));\n            return sb.toString();\n        }","id":9220,"modified_method":"public String toString() {\n            StringBuilder sb=new StringBuilder();\n            sb.append(\"ConnectionHandler[peer: \" + sock.getInetAddress());\n            if(!logical_addrs.isEmpty())\n                sb.append(\", logical_addrs: \" + Util.printListWithDelimiter(logical_addrs, \", \"));\n            sb.append(\"]\");\n            return sb.toString();\n        }","commit_id":"dd6dd7cac76803141cb879f52b80729da4219435","url":"https://github.com/belaban/JGroups"},{"original_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n       }","id":9221,"modified_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n\n           conn_creations.decrementAndGet();\n       }","commit_id":"ce9a946f32df0a4b0a9803c46d90fb7daaafe074","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Acceptor thread. Continuously accept new connections. Create a new thread for each new\n    * connection and put it in conns. When the thread should stop, it is\n    * interrupted by the thread creator.\n    */\n   public void run() {\n       Socket     client_sock=null;\n       Connection conn=null;\n       Address    peer_addr;\n\n       while(srv_sock != null) {\n           try {\n               conn=null;\n               client_sock=srv_sock.accept();\n               if(!running) {\n                   if(log.isWarnEnabled())\n                       log.warn(\"cannot accept connection from \" + client_sock.getRemoteSocketAddress() + \" as I'm closed\");\n                   break;\n               }\n               if(log.isTraceEnabled())\n                   log.trace(\"[\" +local_addr + \"] accepted connection from \" + client_sock.getInetAddress() + \":\" + client_sock.getPort());\n               try {\n                   client_sock.setSendBufferSize(send_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n               try {\n                   client_sock.setReceiveBufferSize(recv_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n\n               client_sock.setKeepAlive(true);\n               client_sock.setTcpNoDelay(tcp_nodelay);\n               if(linger > 0)\n                   client_sock.setSoLinger(true, linger);\n               else\n                   client_sock.setSoLinger(false, -1);\n\n               // create new thread and add to conn table\n               conn=new Connection(client_sock, null); // will call receive(msg)\n               // get peer's address\n               peer_addr=conn.readPeerAddress(client_sock);\n\n               // client_addr=new IpAddress(client_sock.getInetAddress(), client_port);\n               conn.setPeerAddress(peer_addr);\n\n               synchronized(conns) {\n                   if(conns.containsKey(peer_addr)) {\n                       if(log.isTraceEnabled())\n                           log.trace(peer_addr + \" is already there, will reuse connection\");\n                       //conn.destroy();\n                       //continue; // return; // we cannot terminate the thread (bela Sept 2 2004)\n                   }\n                   else {\n                       // conns.put(peer_addr, conn);\n                       addConnection(peer_addr, conn);\n                       notifyConnectionOpened(peer_addr);\n                   }\n               }\n\n               conn.init(); // starts handler thread on this socket\n           }\n           catch(SocketTimeoutException timeout_ex) {\n               if(log.isWarnEnabled()) log.warn(\"timed out waiting for peer address, closing connection \" + conn + \": \" + timeout_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(SocketException sock_ex) {\n               if(log.isWarnEnabled() && srv_sock != null) log.warn(\"exception is \" + sock_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(Throwable ex) {\n               if(log.isWarnEnabled()) log.warn(\"exception is \" + ex);\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n       }\n       if(client_sock != null)\n           try {client_sock.close();} catch(IOException e) {}\n       if(log.isTraceEnabled())\n           log.trace(Thread.currentThread().getName() + \" terminated\");\n   }","id":9222,"modified_method":"/**\n    * Acceptor thread. Continuously accept new connections. Create a new thread for each new\n    * connection and put it in conns. When the thread should stop, it is\n    * interrupted by the thread creator.\n    */\n   public void run() {\n       Socket     client_sock=null;\n       Connection conn=null;\n       Address    peer_addr;\n\n       while(srv_sock != null) {\n           try {\n               conn=null;\n               client_sock=srv_sock.accept();\n               if(!running) {\n                   if(log.isWarnEnabled())\n                       log.warn(\"cannot accept connection from \" + client_sock.getRemoteSocketAddress() + \" as I'm closed\");\n                   break;\n               }\n               if(log.isTraceEnabled())\n                   log.trace(\"[\" +local_addr + \"] accepted connection from \" + client_sock.getInetAddress() + \":\" + client_sock.getPort());\n               try {\n                   client_sock.setSendBufferSize(send_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n               try {\n                   client_sock.setReceiveBufferSize(recv_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n\n               client_sock.setKeepAlive(true);\n               client_sock.setTcpNoDelay(tcp_nodelay);\n               if(linger > 0)\n                   client_sock.setSoLinger(true, linger);\n               else\n                   client_sock.setSoLinger(false, -1);\n\n               // create new thread and add to conn table\n               conn=new Connection(client_sock, null); // will call receive(msg)\n               // get peer's address\n               peer_addr=conn.readPeerAddress(client_sock);\n\n               // client_addr=new IpAddress(client_sock.getInetAddress(), client_port);\n               conn.setPeerAddress(peer_addr);\n\n               synchronized(conns) {\n                   Connection tmp=conns.get(peer_addr);\n                   if(tmp != null) {\n                       if(peer_addr.compareTo(local_addr) > 0) {\n                           if(log.isTraceEnabled())\n                               log.trace(\"peer's address (\" + peer_addr + \") is greater than our local address (\" +\n                                       local_addr + \"), replacing our existing connection\");\n                           // peer's address is greater, add peer's connection to ConnectionTable, destroy existing connection\n                           addConnection(peer_addr,  conn);\n                           tmp.destroy();\n                           notifyConnectionOpened(peer_addr);\n                       }\n                       else {\n                           if(log.isTraceEnabled())\n                               log.trace(\"peer's address (\" + peer_addr + \") is smaller than our local address (\" +\n                                       local_addr + \"), rejecting peer connection request\");\n                           conn.destroy();\n                           continue;\n                       }\n                   }\n                   else {\n                       // conns.put(peer_addr, conn);\n                       addConnection(peer_addr, conn);\n                       notifyConnectionOpened(peer_addr);\n                   }\n               }\n\n               conn.init(); // starts handler thread on this socket\n           }\n           catch(SocketTimeoutException timeout_ex) {\n               if(log.isWarnEnabled()) log.warn(\"timed out waiting for peer address, closing connection \" + conn + \": \" + timeout_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(SocketException sock_ex) {\n               if(log.isWarnEnabled() && srv_sock != null) log.warn(\"exception is \" + sock_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(Throwable ex) {\n               if(log.isWarnEnabled()) log.warn(\"exception is \" + ex);\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n       }\n       if(client_sock != null)\n           try {client_sock.close();} catch(IOException e) {}\n       if(log.isTraceEnabled())\n           log.trace(Thread.currentThread().getName() + \" terminated\");\n   }","commit_id":"ce9a946f32df0a4b0a9803c46d90fb7daaafe074","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * A connects to B and B connects to A at the same time. This test makes sure we only have <em>one<\/em> connection,\n     * not two, e.g. a spurious connection. Tests http://jira.jboss.com/jira/browse/JGRP-549\n     */\n    public void testConcurrentConnect() throws Exception {\n        Sender sender1, sender2;\n        CyclicBarrier barrier=new CyclicBarrier(3);\n\n        ct1=new ConnectionTable(loopback_addr, PORT1);\n        ct2=new ConnectionTable(loopback_addr, PORT2);\n        BasicConnectionTable.Receiver dummy=new BasicConnectionTable.Receiver() {\n            public void receive(Address sender, byte[] data, int offset, int length) {}\n        };\n        ct1.setReceiver(dummy);\n        ct2.setReceiver(dummy);\n\n        sender1=new Sender((ConnectionTable)ct1, barrier, addr2, 0);\n        sender2=new Sender((ConnectionTable)ct2, barrier, addr1, 0);\n\n        sender1.start(); sender2.start();\n        Util.sleep(100);\n\n        int num_conns;\n        System.out.println(\"ct1: \" + ct1 + \"\\nct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(0, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(0, num_conns);\n\n        barrier.await(10000, TimeUnit.MILLISECONDS);\n        sender1.join();\n        sender2.join();\n\n        System.out.println(\"ct1: \" + ct1 + \"\\nct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(1, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(1, num_conns);\n\n\n        int num_creations=BasicConnectionTable.getNumberOfConnectionCreations();\n        System.out.println(\"Number of connection creations=\" + num_creations);\n        assertEquals(\"2 connections should have been created only, but we have \" + num_creations, 2, num_creations);\n    }","id":9223,"modified_method":"/**\n     * A connects to B and B connects to A at the same time. This test makes sure we only have <em>one<\/em> connection,\n     * not two, e.g. a spurious connection. Tests http://jira.jboss.com/jira/browse/JGRP-549\n     */\n    public void testConcurrentConnect() throws Exception {\n        Sender sender1, sender2;\n        CyclicBarrier barrier=new CyclicBarrier(3);\n\n        ct1=new ConnectionTable(loopback_addr, PORT1);\n        ct2=new ConnectionTable(loopback_addr, PORT2);\n        BasicConnectionTable.Receiver dummy=new BasicConnectionTable.Receiver() {\n            public void receive(Address sender, byte[] data, int offset, int length) {}\n        };\n        ct1.setReceiver(dummy);\n        ct2.setReceiver(dummy);\n\n        sender1=new Sender((ConnectionTable)ct1, barrier, addr2, 0);\n        sender2=new Sender((ConnectionTable)ct2, barrier, addr1, 0);\n\n        sender1.start(); sender2.start();\n        Util.sleep(100);\n\n        int num_conns;\n        System.out.println(\"ct1: \" + ct1 + \"ct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(0, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(0, num_conns);\n\n        barrier.await(10000, TimeUnit.MILLISECONDS);\n        sender1.join();\n        sender2.join();\n\n        System.out.println(\"ct1: \" + ct1 + \"\\nct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(1, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(1, num_conns);\n\n\n        int num_creations=BasicConnectionTable.getNumberOfConnectionCreations();\n        System.out.println(\"Number of connection creations=\" + num_creations);\n        assertEquals(\"2 connections should have been created only, but we have \" + num_creations, 2, num_creations);\n    }","commit_id":"ce9a946f32df0a4b0a9803c46d90fb7daaafe074","url":"https://github.com/belaban/JGroups"},{"original_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n                    ConcurrentMap<Address,ConnectionHandler> map;\n\n                    if(log.isTraceEnabled())\n                        log.trace(\"Received \" + request + \" on socket \" + sock);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(\"received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(\"failed routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","id":9224,"modified_method":"private void readLoop() {\n            while(isRunning()) {\n                GossipData request;\n                Address addr;\n                String group;\n                try {                   \n                    request=new GossipData();\n                    request.readFrom(input);\n                    byte command=request.getType();\n                    addr=request.getAddress();\n                    group=request.getGroup();\n                    known_groups.add(group);\n                    ConcurrentMap<Address,ConnectionHandler> map;\n\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" received \" + request);\n                    \n                    switch(command) {\n\n                        case GossipRouter.CONNECT:\n                            handleConnect(request, addr, group);\n                            break;\n\n                        case GossipRouter.PING:\n                            // do nothing here - client doesn't expect response data\n                            break;\n\n                        case GossipRouter.MESSAGE:\n                            if(request.buffer == null || request.buffer.length == 0) {\n                                if(log.isWarnEnabled())\n                                    log.warn(this +\" received null message\");\n                                break;\n                            }\n\n                            try {\n                                route(addr, request.getGroup(), request.getBuffer());\n                            }\n                            catch(Exception e) {\n                                if(log.isErrorEnabled())\n                                    log.error(this +\" failed in routing request to \" + addr, e);\n                            }\n                            break;\n\n                        case GossipRouter.GOSSIP_GET:\n                            Set<PhysicalAddress> physical_addrs;\n                            List<PingData> mbrs=new ArrayList<PingData>();\n                            map=routingTable.get(group);\n                            if(map != null) {\n                                for(Address logical_addr: map.keySet()) {\n                                    physical_addrs=address_mappings.get(logical_addr);\n                                    PingData rsp=new PingData(logical_addr, null, true, UUID.get(logical_addr),\n                                                              physical_addrs != null? new ArrayList<PhysicalAddress>(physical_addrs) : null);\n                                    mbrs.add(rsp);\n                                }\n                            }\n                            output.writeShort(mbrs.size());\n                            for(PingData data: mbrs)\n                                data.writeTo(output);\n                            output.flush();\n                            if(log.isDebugEnabled())\n                                log.debug(this + \" responded to GOSSIP_GET with \" + mbrs);\n                            break;\n\n                        case GossipRouter.DISCONNECT:\n                            try {\n                                removeEntry(group, addr);\n                                sendData(new GossipData(DISCONNECT_OK));\n                                if(log.isDebugEnabled())\n                                    log.debug(this + \" disconnect completed\");\n                            }\n                            catch(Exception e) {\n                                sendData(new GossipData(OP_FAIL));\n                            }\n                            break;\n                            \n                        case GossipRouter.CLOSE:\n                            close();\n                            break;\n                            \n                        case -1: // EOF\n                            notifyAbnormalConnectionTear(this, new EOFException(\"Connection broken\"));\n                            break;\n                    }\n                    if(log.isTraceEnabled())\n                        log.trace(this + \" processed  \" + request);\n                }\n                catch(SocketTimeoutException ste) {\n                }                \n                catch(IOException ioex) {\n                    notifyAbnormalConnectionTear(this, ioex);\n                    break;\n                }                \n                catch(Exception ex) {\n                    if (active.get()) {\n                        if (log.isWarnEnabled())\n                            log.warn(\"Exception in ConnectionHandler thread\", ex);\n                    }\n                    break;\n                }\n            }\n        }","commit_id":"e3a6b8b56fb6e6be2ce30a5539be0484f1aa8020","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleConnect(GossipData request, Address addr, String group) throws Exception {\n            ConcurrentMap<Address, ConnectionHandler> map = null;\n            try {               \n                String logical_name = request.getLogicalName();\n                if (logical_name != null && addr instanceof org.jgroups.util.UUID)\n                    org.jgroups.util.UUID.add((org.jgroups.util.UUID) addr, logical_name);\n\n                // group name, logical address, logical name, physical addresses (could be null)\n                logical_addrs.add(addr); // allows us to remove the entries for this connection on\n                                         // socket close\n\n                map = routingTable.get(group);\n                if (map == null) {\n                    map = new ConcurrentHashMap<Address, ConnectionHandler>();\n                    routingTable.put(group, map); // no concurrent requests on the same connection\n                }\n                map.put(addr, this);\n\n                Set<PhysicalAddress> physical_addrs;\n                if (request.getPhysicalAddresses() != null) {\n                    physical_addrs = address_mappings.get(addr);\n                    if (physical_addrs == null) {\n                        physical_addrs = new HashSet<PhysicalAddress>();\n                        address_mappings.put(addr, physical_addrs);\n                    }\n                    physical_addrs.addAll(request.getPhysicalAddresses());\n                }\n                sendStatus(CONNECT_OK);\n                \n                if(log.isTraceEnabled())\n                    log.trace(\"Connection established, added  \" +addr + \" to group \"+ group);\n                \n            } catch (Exception e) {\n                removeEntry(group, addr);\n                sendStatus(OP_FAIL);\n                throw new Exception(\"Unsuccessful connection setup handshake\");\n            }\n        }","id":9225,"modified_method":"private void handleConnect(GossipData request, Address addr, String group) throws Exception {\n            ConcurrentMap<Address, ConnectionHandler> map = null;                       \n            try {               \n                \n                checkExistingConnection(addr,group);\n                \n                String logical_name = request.getLogicalName();\n                if (logical_name != null && addr instanceof org.jgroups.util.UUID)\n                    org.jgroups.util.UUID.add((org.jgroups.util.UUID) addr, logical_name);\n\n                // group name, logical address, logical name, physical addresses (could be null)\n                logical_addrs.add(addr); // allows us to remove the entries for this connection on\n                                         // socket close\n\n                map = routingTable.get(group);\n                if (map == null) {\n                    map = new ConcurrentHashMap<Address, ConnectionHandler>();\n                    routingTable.put(group, map); // no concurrent requests on the same connection\n                }\n                map.put(addr, this);\n\n                Set<PhysicalAddress> physical_addrs;\n                if (request.getPhysicalAddresses() != null) {\n                    physical_addrs = address_mappings.get(addr);\n                    if (physical_addrs == null) {\n                        physical_addrs = new HashSet<PhysicalAddress>();\n                        address_mappings.put(addr, physical_addrs);\n                    }\n                    physical_addrs.addAll(request.getPhysicalAddresses());\n                }\n                sendStatus(CONNECT_OK);\n                \n                if(log.isDebugEnabled())\n                    log.debug(this + \" connection handshake completed, added \" +addr + \" to group \"+ group);\n                \n            } catch (Exception e) {\n                removeEntry(group, addr);\n                sendStatus(OP_FAIL);\n                throw new Exception(\"Unsuccessful connection setup handshake for \" + this);\n            }\n        }","commit_id":"e3a6b8b56fb6e6be2ce30a5539be0484f1aa8020","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            StringBuilder sb=new StringBuilder();\n            sb.append(\"peer: \" + sock.getInetAddress());\n            if(!logical_addrs.isEmpty())\n                sb.append(\", logical_addrs: \" + Util.printListWithDelimiter(logical_addrs, \", \"));\n            return sb.toString();\n        }","id":9226,"modified_method":"public String toString() {\n            StringBuilder sb=new StringBuilder();\n            sb.append(\"ConnectionHandler[peer: \" + sock.getInetAddress());\n            if(!logical_addrs.isEmpty())\n                sb.append(\", logical_addrs: \" + Util.printListWithDelimiter(logical_addrs, \", \"));\n            sb.append(\"]\");\n            return sb.toString();\n        }","commit_id":"e3a6b8b56fb6e6be2ce30a5539be0484f1aa8020","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            if(active.compareAndSet(false, true)) {\n                try {\n                    readLoop();\n                }\n                finally {\n                    close();\n                }\n            }\n        }","id":9227,"modified_method":"public void run() {\n            if(active.compareAndSet(false, true)) {\n                try {\n                    if(log.isDebugEnabled())\n                        log.debug(this + \" entering receive loop\");\n                    readLoop();\n                }\n                finally {\n                    close();\n                }\n            }\n        }","commit_id":"e3a6b8b56fb6e6be2ce30a5539be0484f1aa8020","url":"https://github.com/belaban/JGroups"},{"original_method":"void close() {\n            if(active.compareAndSet(true, false)) {\n                if(log.isDebugEnabled())\n                    log.debug(\"Closing connection handler \" + this.toString());\n                \n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n                for(Address addr: logical_addrs) {\n                    removeEntry(null, addr);\n                }\n            }\n        }","id":9228,"modified_method":"void close() {\n            if(active.compareAndSet(true, false)) {\n                if(log.isDebugEnabled())\n                    log.debug(this + \" is being closed\");\n                \n                Util.close(input);\n                Util.close(output);\n                Util.close(sock);\n                for(Address addr: logical_addrs) {\n                    removeEntry(null, addr);\n                }\n            }\n        }","commit_id":"e3a6b8b56fb6e6be2ce30a5539be0484f1aa8020","url":"https://github.com/belaban/JGroups"},{"original_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n       }","id":9229,"modified_method":"void destroy() {\n           is_running=false;\n           closeSocket(); // should terminate handler as well\n           if(sender != null)\n               sender.stop();\n           Thread tmp=receiverThread;\n           receiverThread=null;\n           if(tmp != null) {\n               Util.interruptAndWaitToDie(tmp);\n           }\n\n           conn_creations.decrementAndGet();\n       }","commit_id":"00c3735293d578c04894763b4ffe556b9c8092fa","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Acceptor thread. Continuously accept new connections. Create a new thread for each new\n    * connection and put it in conns. When the thread should stop, it is\n    * interrupted by the thread creator.\n    */\n   public void run() {\n       Socket     client_sock=null;\n       Connection conn=null;\n       Address    peer_addr;\n\n       while(srv_sock != null) {\n           try {\n               conn=null;\n               client_sock=srv_sock.accept();\n               if(!running) {\n                   if(log.isWarnEnabled())\n                       log.warn(\"cannot accept connection from \" + client_sock.getRemoteSocketAddress() + \" as I'm closed\");\n                   break;\n               }\n               if(log.isTraceEnabled())\n                   log.trace(\"[\" +local_addr + \"] accepted connection from \" + client_sock.getInetAddress() + \":\" + client_sock.getPort());\n               try {\n                   client_sock.setSendBufferSize(send_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n               try {\n                   client_sock.setReceiveBufferSize(recv_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n\n               client_sock.setKeepAlive(true);\n               client_sock.setTcpNoDelay(tcp_nodelay);\n               if(linger > 0)\n                   client_sock.setSoLinger(true, linger);\n               else\n                   client_sock.setSoLinger(false, -1);\n\n               // create new thread and add to conn table\n               conn=new Connection(client_sock, null); // will call receive(msg)\n               // get peer's address\n               peer_addr=conn.readPeerAddress(client_sock);\n\n               // client_addr=new IpAddress(client_sock.getInetAddress(), client_port);\n               conn.setPeerAddress(peer_addr);\n\n               synchronized(conns) {\n                   if(conns.containsKey(peer_addr)) {\n                       if(log.isTraceEnabled())\n                           log.trace(peer_addr + \" is already there, will reuse connection\");\n                       //conn.destroy();\n                       //continue; // return; // we cannot terminate the thread (bela Sept 2 2004)\n                   }\n                   else {\n                       // conns.put(peer_addr, conn);\n                       addConnection(peer_addr, conn);\n                       notifyConnectionOpened(peer_addr);\n                   }\n               }\n\n               conn.init(); // starts handler thread on this socket\n           }\n           catch(SocketTimeoutException timeout_ex) {\n               if(log.isWarnEnabled()) log.warn(\"timed out waiting for peer address, closing connection \" + conn + \": \" + timeout_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(SocketException sock_ex) {\n               if(log.isWarnEnabled() && srv_sock != null) log.warn(\"exception is \" + sock_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(Throwable ex) {\n               if(log.isWarnEnabled()) log.warn(\"exception is \" + ex);\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n       }\n       if(client_sock != null)\n           try {client_sock.close();} catch(IOException e) {}\n       if(log.isTraceEnabled())\n           log.trace(Thread.currentThread().getName() + \" terminated\");\n   }","id":9230,"modified_method":"/**\n    * Acceptor thread. Continuously accept new connections. Create a new thread for each new\n    * connection and put it in conns. When the thread should stop, it is\n    * interrupted by the thread creator.\n    */\n   public void run() {\n       Socket     client_sock=null;\n       Connection conn=null;\n       Address    peer_addr;\n\n       while(srv_sock != null) {\n           try {\n               conn=null;\n               client_sock=srv_sock.accept();\n               if(!running) {\n                   if(log.isWarnEnabled())\n                       log.warn(\"cannot accept connection from \" + client_sock.getRemoteSocketAddress() + \" as I'm closed\");\n                   break;\n               }\n               if(log.isTraceEnabled())\n                   log.trace(\"[\" +local_addr + \"] accepted connection from \" + client_sock.getInetAddress() + \":\" + client_sock.getPort());\n               try {\n                   client_sock.setSendBufferSize(send_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n               try {\n                   client_sock.setReceiveBufferSize(recv_buf_size);\n               }\n               catch(IllegalArgumentException ex) {\n                   if(log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" + send_buf_size + \" bytes\", ex);\n               }\n\n               client_sock.setKeepAlive(true);\n               client_sock.setTcpNoDelay(tcp_nodelay);\n               if(linger > 0)\n                   client_sock.setSoLinger(true, linger);\n               else\n                   client_sock.setSoLinger(false, -1);\n\n               // create new thread and add to conn table\n               conn=new Connection(client_sock, null); // will call receive(msg)\n               // get peer's address\n               peer_addr=conn.readPeerAddress(client_sock);\n\n               // client_addr=new IpAddress(client_sock.getInetAddress(), client_port);\n               conn.setPeerAddress(peer_addr);\n\n               synchronized(conns) {\n                   Connection tmp=conns.get(peer_addr);\n                   if(tmp != null) {\n                       if(peer_addr.compareTo(local_addr) > 0) {\n                           if(log.isTraceEnabled())\n                               log.trace(\"peer's address (\" + peer_addr + \") is greater than our local address (\" +\n                                       local_addr + \"), replacing our existing connection\");\n                           // peer's address is greater, add peer's connection to ConnectionTable, destroy existing connection\n                           addConnection(peer_addr,  conn);\n                           tmp.destroy();\n                           notifyConnectionOpened(peer_addr);\n                       }\n                       else {\n                           if(log.isTraceEnabled())\n                               log.trace(\"peer's address (\" + peer_addr + \") is smaller than our local address (\" +\n                                       local_addr + \"), rejecting peer connection request\");\n                           conn.destroy();\n                           continue;\n                       }\n                   }\n                   else {\n                       // conns.put(peer_addr, conn);\n                       addConnection(peer_addr, conn);\n                       notifyConnectionOpened(peer_addr);\n                   }\n               }\n\n               conn.init(); // starts handler thread on this socket\n           }\n           catch(SocketTimeoutException timeout_ex) {\n               if(log.isWarnEnabled()) log.warn(\"timed out waiting for peer address, closing connection \" + conn + \": \" + timeout_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(SocketException sock_ex) {\n               if(log.isWarnEnabled() && srv_sock != null) log.warn(\"exception is \" + sock_ex);\n               if(conn != null)\n                   conn.destroy();\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n           catch(Throwable ex) {\n               if(log.isWarnEnabled()) log.warn(\"exception is \" + ex);\n               if(srv_sock == null)\n                   break;  // socket was closed, therefore stop\n           }\n       }\n       if(client_sock != null)\n           try {client_sock.close();} catch(IOException e) {}\n       if(log.isTraceEnabled())\n           log.trace(Thread.currentThread().getName() + \" terminated\");\n   }","commit_id":"00c3735293d578c04894763b4ffe556b9c8092fa","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * A connects to B and B connects to A at the same time. This test makes sure we only have <em>one<\/em> connection,\n     * not two, e.g. a spurious connection. Tests http://jira.jboss.com/jira/browse/JGRP-549\n     */\n    public void testConcurrentConnect() throws Exception {\n        Sender sender1, sender2;\n        CyclicBarrier barrier=new CyclicBarrier(3);\n\n        ct1=new ConnectionTable(loopback_addr, PORT1);\n        ct2=new ConnectionTable(loopback_addr, PORT2);\n        BasicConnectionTable.Receiver dummy=new BasicConnectionTable.Receiver() {\n            public void receive(Address sender, byte[] data, int offset, int length) {}\n        };\n        ct1.setReceiver(dummy);\n        ct2.setReceiver(dummy);\n\n        sender1=new Sender((ConnectionTable)ct1, barrier, addr2, 0);\n        sender2=new Sender((ConnectionTable)ct2, barrier, addr1, 0);\n\n        sender1.start(); sender2.start();\n        Util.sleep(100);\n\n        int num_conns;\n        System.out.println(\"ct1: \" + ct1 + \"\\nct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(0, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(0, num_conns);\n\n        barrier.await(10000, TimeUnit.MILLISECONDS);\n        sender1.join();\n        sender2.join();\n\n        System.out.println(\"ct1: \" + ct1 + \"\\nct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(1, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(1, num_conns);\n\n\n        int num_creations=BasicConnectionTable.getNumberOfConnectionCreations();\n        System.out.println(\"Number of connection creations=\" + num_creations);\n        assertEquals(\"2 connections should have been created only, but we have \" + num_creations, 2, num_creations);\n    }","id":9231,"modified_method":"/**\n     * A connects to B and B connects to A at the same time. This test makes sure we only have <em>one<\/em> connection,\n     * not two, e.g. a spurious connection. Tests http://jira.jboss.com/jira/browse/JGRP-549\n     */\n    public void testConcurrentConnect() throws Exception {\n        Sender sender1, sender2;\n        CyclicBarrier barrier=new CyclicBarrier(3);\n\n        ct1=new ConnectionTable(loopback_addr, PORT1);\n        ct2=new ConnectionTable(loopback_addr, PORT2);\n        BasicConnectionTable.Receiver dummy=new BasicConnectionTable.Receiver() {\n            public void receive(Address sender, byte[] data, int offset, int length) {}\n        };\n        ct1.setReceiver(dummy);\n        ct2.setReceiver(dummy);\n\n        sender1=new Sender((ConnectionTable)ct1, barrier, addr2, 0);\n        sender2=new Sender((ConnectionTable)ct2, barrier, addr1, 0);\n\n        sender1.start(); sender2.start();\n        Util.sleep(100);\n\n        int num_conns;\n        System.out.println(\"ct1: \" + ct1 + \"ct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(0, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(0, num_conns);\n\n        barrier.await(10000, TimeUnit.MILLISECONDS);\n        sender1.join();\n        sender2.join();\n\n        System.out.println(\"ct1: \" + ct1 + \"\\nct2: \" + ct2);\n        num_conns=ct1.getNumConnections();\n        assertEquals(1, num_conns);\n        num_conns=ct2.getNumConnections();\n        assertEquals(1, num_conns);\n\n\n        int num_creations=BasicConnectionTable.getNumberOfConnectionCreations();\n        System.out.println(\"Number of connection creations=\" + num_creations);\n        assertEquals(\"2 connections should have been created only, but we have \" + num_creations, 2, num_creations);\n    }","commit_id":"00c3735293d578c04894763b4ffe556b9c8092fa","url":"https://github.com/belaban/JGroups"},{"original_method":"private ConstraintsDescriptor getMethodUsingInheritance(String conceptFqName, InheritanceCalculateParameters parameters) {\n    for (String parent : ConceptRegistry.getInstance().getConceptDescriptor(conceptFqName).getParentsNames()) {\n      ConstraintsDescriptor parentDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptorNew(parent);\n\n      if (parentDescriptor instanceof BaseConstraintsDescriptor) {\n        return parameters.getParentCalculatedDescriptor((BaseConstraintsDescriptor) parentDescriptor);\n      } else if (parentDescriptor instanceof ConstraintsDispatchable) {\n        if (parameters.hasOwn((ConstraintsDispatchable) parentDescriptor)) {\n          return parentDescriptor;\n        } else {\n          ConstraintsDescriptor parentGetter = getMethodUsingInheritance(conceptFqName, parameters);\n          if (parentGetter != null) {\n            return parentGetter;\n          }\n        }\n      } else {\n        return parentDescriptor;\n      }\n    }\n\n    return null;\n  }","id":9232,"modified_method":"private ConstraintsDescriptor getMethodUsingInheritance(String conceptFqName, InheritanceCalculateParameters parameters) {\n    for (String parent : ConceptRegistry.getInstance().getConceptDescriptor(conceptFqName).getParentsNames()) {\n      ConstraintsDescriptor parentDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptorNew(parent);\n\n      ConstraintsDescriptor parentCalculated;\n\n      if (parentDescriptor instanceof BaseConstraintsDescriptor) {\n        parentCalculated = parameters.getParentCalculatedDescriptor((BaseConstraintsDescriptor) parentDescriptor);\n      } else if (parentDescriptor instanceof ConstraintsDispatchable) {\n        if (parameters.hasOwn((ConstraintsDispatchable) parentDescriptor)) {\n          parentCalculated = parentDescriptor;\n        } else {\n          parentCalculated = getMethodUsingInheritance(conceptFqName, parameters);\n        }\n      } else {\n        parentCalculated = parentDescriptor;\n      }\n\n      if (parentCalculated != null) {\n        return parentCalculated;\n      }\n    }\n\n    return null;\n  }","commit_id":"0497a55c2603274f2920d24bb21ac70c0d77e8ef","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private static PropertyConstraintsDescriptor getSomethingUsingInheritance(String conceptFqName, String propertyName, InheritanceCalculateParameters parameters) {\n    for (String parent : ConceptRegistry.getInstance().getConceptDescriptor(conceptFqName).getParentsNames()) {\n      ConstraintsDescriptor parentDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptorNew(parent);\n      PropertyConstraintsDescriptor parentPropertyDescriptor = parentDescriptor.getProperty(propertyName);\n      if (parentPropertyDescriptor == null) {\n        continue;\n      }\n\n      if (parentPropertyDescriptor instanceof BasePropertyConstraintsDescriptor) {\n        return parameters.getParentCalculatedDescriptor((BasePropertyConstraintsDescriptor) parentPropertyDescriptor);\n      } else if (parentPropertyDescriptor instanceof PropertyConstraintsDispatchable) {\n        if (parameters.hasOwn((PropertyConstraintsDispatchable) parentPropertyDescriptor)) {\n          return parentPropertyDescriptor;\n        } else {\n          PropertyConstraintsDescriptor parentGetter = getSomethingUsingInheritance(parent, propertyName, parameters);\n          if (parentGetter != null) {\n            return parentGetter;\n          }\n        }\n      } else {\n        return parentPropertyDescriptor;\n      }\n    }\n\n    return null;\n  }","id":9233,"modified_method":"@Nullable\n  private static PropertyConstraintsDescriptor getSomethingUsingInheritance(String conceptFqName, String propertyName, InheritanceCalculateParameters parameters) {\n    for (String parent : ConceptRegistry.getInstance().getConceptDescriptor(conceptFqName).getParentsNames()) {\n      if (!ConceptRegistry.getInstance().getConceptDescriptor(parent).hasProperty(propertyName)) {\n        continue;\n      }\n\n      ConstraintsDescriptor parentDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptorNew(parent);\n      PropertyConstraintsDescriptor parentPropertyDescriptor = parentDescriptor.getProperty(propertyName);\n\n      // todo: rename getter -> ?\n      PropertyConstraintsDescriptor parentCalculated;\n\n      if (parentPropertyDescriptor instanceof BasePropertyConstraintsDescriptor) {\n        parentCalculated = parameters.getParentCalculatedDescriptor((BasePropertyConstraintsDescriptor) parentPropertyDescriptor);\n      } else if (parentPropertyDescriptor instanceof PropertyConstraintsDispatchable) {\n        if (parameters.hasOwn((PropertyConstraintsDispatchable) parentPropertyDescriptor)) {\n          parentCalculated = parentPropertyDescriptor;\n        } else {\n          parentCalculated = getSomethingUsingInheritance(parent, propertyName, parameters);\n        }\n      } else {\n        parentCalculated = parentPropertyDescriptor;\n      }\n\n      if (parentCalculated != null) {\n        return parentCalculated;\n      }\n    }\n\n    return null;\n  }","commit_id":"0497a55c2603274f2920d24bb21ac70c0d77e8ef","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  private static ReferenceConstraintsDescriptor getSomethingUsingInheritance(String conceptFqName, String roleName, InheritanceCalculateParameters parameters) {\n    for (String parent : ConceptRegistry.getInstance().getConceptDescriptor(conceptFqName).getParentsNames()) {\n      ConstraintsDescriptor parentDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptorNew(parent);\n      ReferenceConstraintsDescriptor parentReferenceDescriptor = parentDescriptor.getReference(roleName);\n      if (parentReferenceDescriptor == null) {\n        continue;\n      }\n\n      if (parentReferenceDescriptor instanceof BaseReferenceConstraintsDescriptor) {\n        return parameters.getParentCalculatedDescriptor((BaseReferenceConstraintsDescriptor) parentReferenceDescriptor);\n      } else if (parentReferenceDescriptor instanceof PropertyConstraintsDispatchable) {\n        if (parameters.hasOwn((ReferenceConstraintsDispatchable) parentReferenceDescriptor)) {\n          return parentReferenceDescriptor;\n        } else {\n          ReferenceConstraintsDescriptor parentGetter = getSomethingUsingInheritance(parent, roleName, parameters);\n          if (parentGetter != null) {\n            return parentGetter;\n          }\n        }\n      } else {\n        return parentReferenceDescriptor;\n      }\n    }\n\n    return null;\n  }","id":9234,"modified_method":"@Nullable\n  private static ReferenceConstraintsDescriptor getSomethingUsingInheritance(String conceptFqName, String roleName, InheritanceCalculateParameters parameters) {\n    for (String parent : ConceptRegistry.getInstance().getConceptDescriptor(conceptFqName).getParentsNames()) {\n      if (!ConceptRegistry.getInstance().getConceptDescriptor(parent).hasReference(roleName)) {\n        continue;\n      }\n\n      ConstraintsDescriptor parentDescriptor = ConceptRegistry.getInstance().getConstraintsDescriptorNew(parent);\n      ReferenceConstraintsDescriptor parentReferenceDescriptor = parentDescriptor.getReference(roleName);\n\n      ReferenceConstraintsDescriptor parentCalculated;\n\n      if (parentReferenceDescriptor instanceof BaseReferenceConstraintsDescriptor) {\n        parentCalculated = parameters.getParentCalculatedDescriptor((BaseReferenceConstraintsDescriptor) parentReferenceDescriptor);\n      } else if (parentReferenceDescriptor instanceof PropertyConstraintsDispatchable) {\n        if (parameters.hasOwn((ReferenceConstraintsDispatchable) parentReferenceDescriptor)) {\n          parentCalculated = parentReferenceDescriptor;\n        } else {\n          parentCalculated = getSomethingUsingInheritance(parent, roleName, parameters);\n        }\n      } else {\n        parentCalculated = parentReferenceDescriptor;\n      }\n\n      if (parentCalculated != null) {\n        return parentCalculated;\n      }\n    }\n\n    return null;\n  }","commit_id":"0497a55c2603274f2920d24bb21ac70c0d77e8ef","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Add watched resources to the specified Context.\n     * @param app HostConfig deployed app\n     * @param docBase web app docBase\n     * @param context web application context\n     */\n    protected void addWatchedResources(DeployedApplication app, String docBase,\n            Context context) {\n        // FIXME: Feature idea. Add support for patterns (ex: WEB-INF/*,\n        //        WEB-INF/*.xml), where we would only check if at least one\n        //        resource is newer than app.timestamp\n        File docBaseFile = null;\n        if (docBase != null) {\n            docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(appBase(), docBase);\n            }\n        }\n        String[] watchedResources = context.findWatchedResources();\n        for (int i = 0; i < watchedResources.length; i++) {\n            File resource = new File(watchedResources[i]);\n            if (!resource.isAbsolute()) {\n                if (docBase != null) {\n                    resource = new File(docBaseFile, watchedResources[i]);\n                } else {\n                    if(log.isDebugEnabled())\n                        log.debug(\"Ignoring non-existent WatchedResource '\" +\n                                resource.getAbsolutePath() + \"'\");\n                    continue;\n                }\n            }\n            if(log.isDebugEnabled())\n                log.debug(\"Watching WatchedResource '\" +\n                        resource.getAbsolutePath() + \"'\");\n            app.reloadResources.put(resource.getAbsolutePath(), \n                    new Long(resource.lastModified()));\n        }\n    }","id":9235,"modified_method":"/**\n     * Add watched resources to the specified Context.\n     * @param app HostConfig deployed app\n     * @param docBase web app docBase\n     * @param context web application context\n     */\n    protected void addWatchedResources(DeployedApplication app, String docBase,\n            Context context) {\n        // FIXME: Feature idea. Add support for patterns (ex: WEB-INF/*,\n        //        WEB-INF/*.xml), where we would only check if at least one\n        //        resource is newer than app.timestamp\n        File docBaseFile = null;\n        if (docBase != null) {\n            docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(appBase(), docBase);\n            }\n        }\n        String[] watchedResources = context.findWatchedResources();\n        for (int i = 0; i < watchedResources.length; i++) {\n            File resource = new File(watchedResources[i]);\n            if (!resource.isAbsolute()) {\n                if (docBase != null) {\n                    resource = new File(docBaseFile, watchedResources[i]);\n                } else {\n                    if(log.isDebugEnabled())\n                        log.debug(\"Ignoring non-existent WatchedResource '\" +\n                                resource.getAbsolutePath() + \"'\");\n                    continue;\n                }\n            }\n            if(log.isDebugEnabled())\n                log.debug(\"Watching WatchedResource '\" +\n                        resource.getAbsolutePath() + \"'\");\n            app.reloadResources.put(resource.getAbsolutePath(), \n                    Long.valueOf(resource.lastModified()));\n        }\n    }","commit_id":"4b41600fa6dca93ac5011655e15f71a20e53cfd6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add a new Context to be managed by us.\n     * Entry point for the admin webapp, and other JMX Context controllers.\n     */\n    public void manageApp(Context context)  {    \n\n        String contextName = context.getName();\n        \n        if (deployed.containsKey(contextName))\n            return;\n\n        DeployedApplication deployedApp = new DeployedApplication(contextName);\n        \n        // Add the associated docBase to the redeployed list if it's a WAR\n        boolean isWar = false;\n        if (context.getDocBase() != null) {\n            File docBase = new File(context.getDocBase());\n            if (!docBase.isAbsolute()) {\n                docBase = new File(appBase(), context.getDocBase());\n            }\n            deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                                          new Long(docBase.lastModified()));\n            if (docBase.getAbsolutePath().toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                isWar = true;\n            }\n        }\n        host.addChild(context);\n        // Add the eventual unpacked WAR and all the resources which will be\n        // watched inside it\n        if (isWar && unpackWARs) {\n            File docBase = new File(appBase(), context.getBaseName());\n            deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        new Long(docBase.lastModified()));\n            addWatchedResources(deployedApp, docBase.getAbsolutePath(), context);\n        } else {\n            addWatchedResources(deployedApp, null, context);\n        }\n        deployed.put(contextName, deployedApp);\n    }","id":9236,"modified_method":"/**\n     * Add a new Context to be managed by us.\n     * Entry point for the admin webapp, and other JMX Context controllers.\n     */\n    public void manageApp(Context context)  {    \n\n        String contextName = context.getName();\n        \n        if (deployed.containsKey(contextName))\n            return;\n\n        DeployedApplication deployedApp = new DeployedApplication(contextName);\n        \n        // Add the associated docBase to the redeployed list if it's a WAR\n        boolean isWar = false;\n        if (context.getDocBase() != null) {\n            File docBase = new File(context.getDocBase());\n            if (!docBase.isAbsolute()) {\n                docBase = new File(appBase(), context.getDocBase());\n            }\n            deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                    Long.valueOf(docBase.lastModified()));\n            if (docBase.getAbsolutePath().toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                isWar = true;\n            }\n        }\n        host.addChild(context);\n        // Add the eventual unpacked WAR and all the resources which will be\n        // watched inside it\n        if (isWar && unpackWARs) {\n            File docBase = new File(appBase(), context.getBaseName());\n            deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        Long.valueOf(docBase.lastModified()));\n            addWatchedResources(deployedApp, docBase.getAbsolutePath(), context);\n        } else {\n            addWatchedResources(deployedApp, null, context);\n        }\n        deployed.put(contextName, deployedApp);\n    }","commit_id":"4b41600fa6dca93ac5011655e15f71a20e53cfd6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param cn\n     * @param contextXml\n     * @param file\n     */\n    protected void deployDescriptor(ContextName cn, File contextXml, String file) {\n        if (deploymentExists(cn.getName())) {\n            return;\n        }\n        \n        DeployedApplication deployedApp = new DeployedApplication(cn.getName());\n\n        // Assume this is a configuration descriptor and deploy it\n        if(log.isInfoEnabled()) {\n            log.info(sm.getString(\"hostConfig.deployDescriptor\", file,\n                    configBase.getPath()));\n        }\n\n        Context context = null;\n        try {\n            synchronized (digester) {\n                try {\n                    context = (Context) digester.parse(contextXml);\n                    if (context == null) {\n                        log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                                file));\n                        return;\n                    }\n                } finally {\n                    digester.reset();\n                }\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setConfigFile(contextXml.toURI().toURL());\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            // Add the associated docBase to the redeployed list if it's a WAR\n            boolean isExternalWar = false;\n            boolean isExternal = false;\n            if (context.getDocBase() != null) {\n                File docBase = new File(context.getDocBase());\n                if (!docBase.isAbsolute()) {\n                    docBase = new File(appBase(), context.getDocBase());\n                }\n                // If external docBase, register .xml as redeploy first\n                if (!docBase.getCanonicalPath().startsWith(\n                        appBase().getAbsolutePath() + File.separator)) {\n                    isExternal = true;\n                    deployedApp.redeployResources.put\n                        (contextXml.getAbsolutePath(), new Long(contextXml.lastModified()));\n                    deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        new Long(docBase.lastModified()));\n                    if (docBase.getAbsolutePath().toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                        isExternalWar = true;\n                    }\n                } else {\n                    log.warn(sm.getString(\"hostConfig.deployDescriptor.localDocBaseSpecified\",\n                             docBase));\n                    // Ignore specified docBase\n                    context.setDocBase(null);\n                }\n            }\n            host.addChild(context);\n            // Get paths for WAR and expanded WAR in appBase\n\n            // default to appBase dir + name\n            File expandedDocBase = new File(appBase(), cn.getBaseName());\n            if (context.getDocBase() != null) {\n                // first assume docBase is absolute\n                expandedDocBase = new File(context.getDocBase());\n                if (!expandedDocBase.isAbsolute()) {\n                    // if docBase specified and relative, it must be relative to appBase\n                    expandedDocBase = new File(appBase(), context.getDocBase());\n                }\n            }\n            // Add the eventual unpacked WAR and all the resources which will be\n            // watched inside it\n            if (isExternalWar && unpackWARs) {\n                deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(),\n                        new Long(expandedDocBase.lastModified()));\n                deployedApp.redeployResources.put\n                    (contextXml.getAbsolutePath(), new Long(contextXml.lastModified()));\n                addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context);\n            } else {\n                // Find an existing matching war and expanded folder\n                if (!isExternal) {\n                    File warDocBase = new File(expandedDocBase.getAbsolutePath() + \".war\");\n                    if (warDocBase.exists()) {\n                        deployedApp.redeployResources.put(warDocBase.getAbsolutePath(),\n                                new Long(warDocBase.lastModified()));\n                    }\n                }\n                if (expandedDocBase.exists()) {\n                    deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(),\n                            new Long(expandedDocBase.lastModified()));\n                    addWatchedResources(deployedApp, \n                            expandedDocBase.getAbsolutePath(), context);\n                } else {\n                    addWatchedResources(deployedApp, null, context);\n                }\n                // Add the context XML to the list of files which should trigger a redeployment\n                if (!isExternal) {\n                    deployedApp.redeployResources.put\n                        (contextXml.getAbsolutePath(), new Long(contextXml.lastModified()));\n                }\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                                   file), t);\n        }\n\n        if (context != null && host.findChild(context.getName()) != null) {\n            deployed.put(context.getName(), deployedApp);\n        }\n    }","id":9237,"modified_method":"/**\n     * @param cn\n     * @param contextXml\n     * @param file\n     */\n    protected void deployDescriptor(ContextName cn, File contextXml, String file) {\n        if (deploymentExists(cn.getName())) {\n            return;\n        }\n        \n        DeployedApplication deployedApp = new DeployedApplication(cn.getName());\n\n        // Assume this is a configuration descriptor and deploy it\n        if(log.isInfoEnabled()) {\n            log.info(sm.getString(\"hostConfig.deployDescriptor\", file,\n                    configBase.getPath()));\n        }\n\n        Context context = null;\n        try {\n            synchronized (digester) {\n                try {\n                    context = (Context) digester.parse(contextXml);\n                    if (context == null) {\n                        log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                                file));\n                        return;\n                    }\n                } finally {\n                    digester.reset();\n                }\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setConfigFile(contextXml.toURI().toURL());\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            // Add the associated docBase to the redeployed list if it's a WAR\n            boolean isExternalWar = false;\n            boolean isExternal = false;\n            if (context.getDocBase() != null) {\n                File docBase = new File(context.getDocBase());\n                if (!docBase.isAbsolute()) {\n                    docBase = new File(appBase(), context.getDocBase());\n                }\n                // If external docBase, register .xml as redeploy first\n                if (!docBase.getCanonicalPath().startsWith(\n                        appBase().getAbsolutePath() + File.separator)) {\n                    isExternal = true;\n                    deployedApp.redeployResources.put(\n                            contextXml.getAbsolutePath(),\n                            Long.valueOf(contextXml.lastModified()));\n                    deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                            Long.valueOf(docBase.lastModified()));\n                    if (docBase.getAbsolutePath().toLowerCase(Locale.ENGLISH).endsWith(\".war\")) {\n                        isExternalWar = true;\n                    }\n                } else {\n                    log.warn(sm.getString(\"hostConfig.deployDescriptor.localDocBaseSpecified\",\n                             docBase));\n                    // Ignore specified docBase\n                    context.setDocBase(null);\n                }\n            }\n            host.addChild(context);\n            // Get paths for WAR and expanded WAR in appBase\n\n            // default to appBase dir + name\n            File expandedDocBase = new File(appBase(), cn.getBaseName());\n            if (context.getDocBase() != null) {\n                // first assume docBase is absolute\n                expandedDocBase = new File(context.getDocBase());\n                if (!expandedDocBase.isAbsolute()) {\n                    // if docBase specified and relative, it must be relative to appBase\n                    expandedDocBase = new File(appBase(), context.getDocBase());\n                }\n            }\n            // Add the eventual unpacked WAR and all the resources which will be\n            // watched inside it\n            if (isExternalWar && unpackWARs) {\n                deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(),\n                        Long.valueOf(expandedDocBase.lastModified()));\n                deployedApp.redeployResources.put(contextXml.getAbsolutePath(),\n                        Long.valueOf(contextXml.lastModified()));\n                addWatchedResources(deployedApp, expandedDocBase.getAbsolutePath(), context);\n            } else {\n                // Find an existing matching war and expanded folder\n                if (!isExternal) {\n                    File warDocBase = new File(expandedDocBase.getAbsolutePath() + \".war\");\n                    if (warDocBase.exists()) {\n                        deployedApp.redeployResources.put(warDocBase.getAbsolutePath(),\n                                Long.valueOf(warDocBase.lastModified()));\n                    }\n                }\n                if (expandedDocBase.exists()) {\n                    deployedApp.redeployResources.put(expandedDocBase.getAbsolutePath(),\n                            Long.valueOf(expandedDocBase.lastModified()));\n                    addWatchedResources(deployedApp, \n                            expandedDocBase.getAbsolutePath(), context);\n                } else {\n                    addWatchedResources(deployedApp, null, context);\n                }\n                // Add the context XML to the list of files which should trigger a redeployment\n                if (!isExternal) {\n                    deployedApp.redeployResources.put(\n                            contextXml.getAbsolutePath(),\n                            Long.valueOf(contextXml.lastModified()));\n                }\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                                   file), t);\n        }\n\n        if (context != null && host.findChild(context.getName()) != null) {\n            deployed.put(context.getName(), deployedApp);\n        }\n    }","commit_id":"4b41600fa6dca93ac5011655e15f71a20e53cfd6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param cn\n     * @param dir\n     * @param file\n     */\n    protected void deployDirectory(ContextName cn, File dir, String file) {\n        \n        if (deploymentExists(cn.getName()))\n            return;\n\n        DeployedApplication deployedApp = new DeployedApplication(cn.getName());\n\n        // Deploy the application in this directory\n        if( log.isInfoEnabled() ) \n            log.info(sm.getString(\"hostConfig.deployDir\", file));\n        try {\n            Context context = null;\n            File xml = new File(dir, Constants.ApplicationContextXml);\n            File xmlCopy = null;\n            if (deployXML && xml.exists()) {\n                synchronized (digester) {\n                    try {\n                        context = (Context) digester.parse(xml);\n                        if (context == null) {\n                            log.error(sm.getString(\n                                    \"hostConfig.deployDescriptor.error\",\n                                    xml));\n                            return;\n                        }\n                    } finally {\n                        digester.reset();\n                    }\n                }\n                if (copyXML) {\n                    xmlCopy = new File(configBase(), file + \".xml\");\n                    InputStream is = null;\n                    OutputStream os = null;\n                    try {\n                        is = new FileInputStream(xml);\n                        os = new FileOutputStream(xmlCopy);\n                        IOTools.flow(is, os);\n                        // Don't catch IOE - let the outer try/catch handle it\n                    } finally {\n                        try {\n                            if (is != null) is.close();\n                        } catch (IOException e){\n                            // Ignore\n                        }\n                        try {\n                            if (os != null) os.close();\n                        } catch (IOException e){\n                            // Ignore\n                        }\n                    }\n                    context.setConfigFile(xmlCopy.toURI().toURL());\n                } else {\n                    context.setConfigFile(xml.toURI().toURL());\n                }\n            } else {\n                context = (Context) Class.forName(contextClass).newInstance();\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            context.setDocBase(file);\n            host.addChild(context);\n            deployedApp.redeployResources.put(dir.getAbsolutePath(),\n                    new Long(dir.lastModified()));\n            if (xmlCopy != null) {\n                deployedApp.redeployResources.put\n                (xmlCopy.getAbsolutePath(), new Long(xmlCopy.lastModified()));\n            }\n            addWatchedResources(deployedApp, dir.getAbsolutePath(), context);\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployDir.error\", file), t);\n        }\n\n        deployed.put(cn.getName(), deployedApp);\n    }","id":9238,"modified_method":"/**\n     * @param cn\n     * @param dir\n     * @param file\n     */\n    protected void deployDirectory(ContextName cn, File dir, String file) {\n        \n        if (deploymentExists(cn.getName()))\n            return;\n\n        DeployedApplication deployedApp = new DeployedApplication(cn.getName());\n\n        // Deploy the application in this directory\n        if( log.isInfoEnabled() ) \n            log.info(sm.getString(\"hostConfig.deployDir\", file));\n        try {\n            Context context = null;\n            File xml = new File(dir, Constants.ApplicationContextXml);\n            File xmlCopy = null;\n            if (deployXML && xml.exists()) {\n                synchronized (digester) {\n                    try {\n                        context = (Context) digester.parse(xml);\n                        if (context == null) {\n                            log.error(sm.getString(\n                                    \"hostConfig.deployDescriptor.error\",\n                                    xml));\n                            return;\n                        }\n                    } finally {\n                        digester.reset();\n                    }\n                }\n                if (copyXML) {\n                    xmlCopy = new File(configBase(), file + \".xml\");\n                    InputStream is = null;\n                    OutputStream os = null;\n                    try {\n                        is = new FileInputStream(xml);\n                        os = new FileOutputStream(xmlCopy);\n                        IOTools.flow(is, os);\n                        // Don't catch IOE - let the outer try/catch handle it\n                    } finally {\n                        try {\n                            if (is != null) is.close();\n                        } catch (IOException e){\n                            // Ignore\n                        }\n                        try {\n                            if (os != null) os.close();\n                        } catch (IOException e){\n                            // Ignore\n                        }\n                    }\n                    context.setConfigFile(xmlCopy.toURI().toURL());\n                } else {\n                    context.setConfigFile(xml.toURI().toURL());\n                }\n            } else {\n                context = (Context) Class.forName(contextClass).newInstance();\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            context.setDocBase(file);\n            host.addChild(context);\n            deployedApp.redeployResources.put(dir.getAbsolutePath(),\n                    Long.valueOf(dir.lastModified()));\n            if (xmlCopy != null) {\n                deployedApp.redeployResources.put(\n                        xmlCopy.getAbsolutePath(),\n                        Long.valueOf(xmlCopy.lastModified()));\n            }\n            addWatchedResources(deployedApp, dir.getAbsolutePath(), context);\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployDir.error\", file), t);\n        }\n\n        deployed.put(cn.getName(), deployedApp);\n    }","commit_id":"4b41600fa6dca93ac5011655e15f71a20e53cfd6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param cn\n     * @param war\n     * @param file\n     */\n    protected void deployWAR(ContextName cn, File war, String file) {\n        \n        if (deploymentExists(cn.getName()))\n            return;\n        \n        // Checking for a nested /META-INF/context.xml\n        JarFile jar = null;\n        JarEntry entry = null;\n        InputStream istream = null;\n        BufferedOutputStream ostream = null;\n        File xml = new File\n            (configBase(), file.substring(0, file.lastIndexOf(\".\")) + \".xml\");\n        boolean xmlInWar = false;\n        \n        if (deployXML && !xml.exists()) {\n            try {\n                jar = new JarFile(war);\n                entry = jar.getJarEntry(Constants.ApplicationContextXml);\n                if (entry != null) {\n                    xmlInWar = true;\n                }\n                if (copyXML && xmlInWar) {\n                    istream = jar.getInputStream(entry);\n                    \n                    ostream =\n                        new BufferedOutputStream\n                        (new FileOutputStream(xml), 1024);\n                    byte buffer[] = new byte[1024];\n                    while (true) {\n                        int n = istream.read(buffer);\n                        if (n < 0) {\n                            break;\n                        }\n                        ostream.write(buffer, 0, n);\n                    }\n                    ostream.flush();\n                    ostream.close();\n                    ostream = null;\n                    istream.close();\n                    istream = null;\n                }\n            } catch (Exception e) {\n                // Ignore and continue\n                if (ostream != null) {\n                    try {\n                        ostream.close();\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                    }\n                    ostream = null;\n                }\n                if (istream != null) {\n                    try {\n                        istream.close();\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                    }\n                    istream = null;\n                }\n            } finally {\n                entry = null;\n                if (jar != null) {\n                    try {\n                        jar.close();\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                    }\n                    jar = null;\n                }\n            }\n        }\n        \n        DeployedApplication deployedApp = new DeployedApplication(cn.getName());\n        \n        // Deploy the application in this WAR file\n        if(log.isInfoEnabled()) \n            log.info(sm.getString(\"hostConfig.deployWar\", file));\n\n        try {\n            Context context = null;\n            if (deployXML && xml.exists()) {\n                synchronized (digester) {\n                    try {\n                        context = (Context) digester.parse(xml);\n                        if (context == null) {\n                            log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                                    file));\n                            return;\n                        }\n                    } finally {\n                        digester.reset();\n                    }\n                }\n                context.setConfigFile(xml.toURI().toURL());\n            } else if (deployXML && xmlInWar) {\n                synchronized (digester) {\n                    try {\n                        jar = new JarFile(war);\n                        entry =\n                            jar.getJarEntry(Constants.ApplicationContextXml);\n                        istream = jar.getInputStream(entry);\n                        context = (Context) digester.parse(istream);\n\n                        if (context == null) {\n                            log.error(sm.getString(\n                                    \"hostConfig.deployDescriptor.error\",\n                                    file));\n                            return;\n                        }\n                        context.setConfigFile(new URL(\"jar:\" +\n                                war.toURI().toString() + \"!/\" +\n                                Constants.ApplicationContextXml));\n                    } catch (Exception e) {\n                        if (istream != null) {\n                            try {\n                                istream.close();\n                            } catch (Throwable t) {\n                                ExceptionUtils.handleThrowable(t);\n                            }\n                            istream = null;\n                        }\n                    } finally {\n                        entry = null;\n                        if (jar != null) {\n                            try {\n                                jar.close();\n                            } catch (Throwable t) {\n                                ExceptionUtils.handleThrowable(t);\n                            }\n                            jar = null;\n                        }\n                        digester.reset();\n                    }\n                }\n                if (context == null) {\n                    log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                            file));\n                    return;\n                }\n            } else {\n                context = (Context) Class.forName(contextClass).newInstance();\n            }\n\n            // Populate redeploy resources with the WAR file\n            deployedApp.redeployResources.put\n                (war.getAbsolutePath(), new Long(war.lastModified()));\n\n            if (deployXML && xml.exists()) {\n                deployedApp.redeployResources.put\n                (xml.getAbsolutePath(), new Long(xml.lastModified()));\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            context.setDocBase(file);\n            host.addChild(context);\n            // If we're unpacking WARs, the docBase will be mutated after\n            // starting the context\n            if (unpackWARs && (context.getDocBase() != null)) {\n                File docBase = new File(appBase(), cn.getBaseName());\n                deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        new Long(docBase.lastModified()));\n                addWatchedResources(deployedApp, docBase.getAbsolutePath(),\n                        context);\n            } else {\n                addWatchedResources(deployedApp, null, context);\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployWar.error\", file), t);\n        }\n        \n        deployed.put(cn.getName(), deployedApp);\n    }","id":9239,"modified_method":"/**\n     * @param cn\n     * @param war\n     * @param file\n     */\n    protected void deployWAR(ContextName cn, File war, String file) {\n        \n        if (deploymentExists(cn.getName()))\n            return;\n        \n        // Checking for a nested /META-INF/context.xml\n        JarFile jar = null;\n        JarEntry entry = null;\n        InputStream istream = null;\n        BufferedOutputStream ostream = null;\n        File xml = new File\n            (configBase(), file.substring(0, file.lastIndexOf(\".\")) + \".xml\");\n        boolean xmlInWar = false;\n        \n        if (deployXML && !xml.exists()) {\n            try {\n                jar = new JarFile(war);\n                entry = jar.getJarEntry(Constants.ApplicationContextXml);\n                if (entry != null) {\n                    xmlInWar = true;\n                }\n                if (copyXML && xmlInWar) {\n                    istream = jar.getInputStream(entry);\n                    \n                    ostream =\n                        new BufferedOutputStream\n                        (new FileOutputStream(xml), 1024);\n                    byte buffer[] = new byte[1024];\n                    while (true) {\n                        int n = istream.read(buffer);\n                        if (n < 0) {\n                            break;\n                        }\n                        ostream.write(buffer, 0, n);\n                    }\n                    ostream.flush();\n                    ostream.close();\n                    ostream = null;\n                    istream.close();\n                    istream = null;\n                }\n            } catch (IOException e) {\n                /* Ignore */\n            } finally {\n                if (ostream != null) {\n                    try {\n                        ostream.close();\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                    }\n                    ostream = null;\n                }\n                if (istream != null) {\n                    try {\n                        istream.close();\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                    }\n                    istream = null;\n                }\n                entry = null;\n                if (jar != null) {\n                    try {\n                        jar.close();\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                    }\n                    jar = null;\n                }\n            }\n        }\n        \n        DeployedApplication deployedApp = new DeployedApplication(cn.getName());\n        \n        // Deploy the application in this WAR file\n        if(log.isInfoEnabled()) \n            log.info(sm.getString(\"hostConfig.deployWar\", file));\n\n        try {\n            Context context = null;\n            if (deployXML && xml.exists()) {\n                synchronized (digester) {\n                    try {\n                        context = (Context) digester.parse(xml);\n                        if (context == null) {\n                            log.error(sm.getString(\"hostConfig.deployDescriptor.error\",\n                                    file));\n                            return;\n                        }\n                    } finally {\n                        digester.reset();\n                    }\n                }\n                context.setConfigFile(xml.toURI().toURL());\n            } else if (deployXML && xmlInWar) {\n                synchronized (digester) {\n                    try {\n                        jar = new JarFile(war);\n                        entry =\n                            jar.getJarEntry(Constants.ApplicationContextXml);\n                        istream = jar.getInputStream(entry);\n                        context = (Context) digester.parse(istream);\n\n                        if (context == null) {\n                            log.error(sm.getString(\n                                    \"hostConfig.deployDescriptor.error\",\n                                    file));\n                            return;\n                        }\n                        context.setConfigFile(new URL(\"jar:\" +\n                                war.toURI().toString() + \"!/\" +\n                                Constants.ApplicationContextXml));\n                    } finally {\n                        if (istream != null) {\n                            try {\n                                istream.close();\n                            } catch (IOException e) {\n                                /* Ignore */\n                            }\n                            istream = null;\n                        }\n                        entry = null;\n                        if (jar != null) {\n                            try {\n                                jar.close();\n                            } catch (IOException e) {\n                                /* Ignore */\n                            }\n                            jar = null;\n                        }\n                        digester.reset();\n                    }\n                }\n            } else {\n                context = (Context) Class.forName(contextClass).newInstance();\n            }\n\n            // Populate redeploy resources with the WAR file\n            deployedApp.redeployResources.put\n                (war.getAbsolutePath(), Long.valueOf(war.lastModified()));\n\n            if (deployXML && xml.exists()) {\n                deployedApp.redeployResources.put(xml.getAbsolutePath(),\n                        Long.valueOf(xml.lastModified()));\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            context.setDocBase(file);\n            host.addChild(context);\n            // If we're unpacking WARs, the docBase will be mutated after\n            // starting the context\n            if (unpackWARs && (context.getDocBase() != null)) {\n                File docBase = new File(appBase(), cn.getBaseName());\n                deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        Long.valueOf(docBase.lastModified()));\n                addWatchedResources(deployedApp, docBase.getAbsolutePath(),\n                        context);\n            } else {\n                addWatchedResources(deployedApp, null, context);\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployWar.error\", file), t);\n        }\n        \n        deployed.put(cn.getName(), deployedApp);\n    }","commit_id":"4b41600fa6dca93ac5011655e15f71a20e53cfd6","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Check resources for redeployment and reloading.\n     */\n    protected synchronized void checkResources(DeployedApplication app) {\n        String[] resources =\n            app.redeployResources.keySet().toArray(new String[0]);\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled())\n                log.debug(\"Checking context[\" + app.name +\n                        \"] redeploy resource \" + resource);\n            if (resource.exists()) {\n                long lastModified =\n                    app.redeployResources.get(resources[i]).longValue();\n                if ((!resource.isDirectory()) &&\n                        resource.lastModified() > lastModified) {\n                    // Undeploy application\n                    if (log.isInfoEnabled())\n                        log.info(sm.getString(\"hostConfig.undeploy\", app.name));\n                    ContainerBase context =\n                        (ContainerBase) host.findChild(app.name);\n                    try {\n                        host.removeChild(context);\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                        log.warn(sm.getString\n                                 (\"hostConfig.context.remove\", app.name), t);\n                    }\n                    // Delete other redeploy resources\n                    for (int j = i + 1; j < resources.length; j++) {\n                        try {\n                            File current = new File(resources[j]);\n                            current = current.getCanonicalFile();\n                            if ((current.getAbsolutePath().startsWith(\n                                    appBase().getAbsolutePath() +\n                                    File.separator))\n                                    || (current.getAbsolutePath().startsWith(\n                                            configBase().getAbsolutePath()))) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Delete \" + current);\n                                ExpandWar.delete(current);\n                            }\n                        } catch (IOException e) {\n                            log.warn(sm.getString\n                                    (\"hostConfig.canonicalizing\", app.name), e);\n                        }\n                    }\n                    deployed.remove(app.name);\n                    return;\n                }\n            } else {\n                // There is a chance the the resource was only missing\n                // temporarily eg renamed during a text editor save\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e1) {\n                    // Ignore\n                }\n                // Recheck the resource to see if it was really deleted\n                if (resource.exists()) {\n                    continue;\n                }\n                long lastModified =\n                    app.redeployResources.get(resources[i]).longValue();\n                if (lastModified == 0L) {\n                    continue;\n                }\n                // Undeploy application\n                if (log.isInfoEnabled())\n                    log.info(sm.getString(\"hostConfig.undeploy\", app.name));\n                ContainerBase context = \n                    (ContainerBase) host.findChild(app.name);\n                try {\n                    host.removeChild(context);\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.warn(sm.getString\n                             (\"hostConfig.context.remove\", app.name), t);\n                }\n                // Delete all redeploy resources\n                for (int j = i + 1; j < resources.length; j++) {\n                    try {\n                        File current = new File(resources[j]);\n                        current = current.getCanonicalFile();\n                        if ((current.getAbsolutePath().startsWith(\n                                appBase().getAbsolutePath() + File.separator))\n                            || (current.getAbsolutePath().startsWith(\n                                    configBase().getAbsolutePath()))) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"Delete \" + current);\n                            ExpandWar.delete(current);\n                        }\n                    } catch (IOException e) {\n                        log.warn(sm.getString\n                                (\"hostConfig.canonicalizing\", app.name), e);\n                    }\n                }\n                // Delete reload resources as well (to remove any remaining .xml\n                // descriptor)\n                String[] resources2 =\n                    app.reloadResources.keySet().toArray(new String[0]);\n                for (int j = 0; j < resources2.length; j++) {\n                    try {\n                        File current = new File(resources2[j]);\n                        current = current.getCanonicalFile();\n                        if ((current.getAbsolutePath().startsWith(\n                                appBase().getAbsolutePath() + File.separator))\n                            || ((current.getAbsolutePath().startsWith(\n                                    configBase().getAbsolutePath())\n                                 && (current.getAbsolutePath().endsWith(\".xml\"))))) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"Delete \" + current);\n                            ExpandWar.delete(current);\n                        }\n                    } catch (IOException e) {\n                        log.warn(sm.getString\n                                (\"hostConfig.canonicalizing\", app.name), e);\n                    }\n                }\n                deployed.remove(app.name);\n                return;\n            }\n        }\n        resources = app.reloadResources.keySet().toArray(new String[0]);\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled())\n                log.debug(\"Checking context[\" + app.name +\n                        \"] reload resource \" + resource);\n            long lastModified =\n                app.reloadResources.get(resources[i]).longValue();\n            if ((!resource.exists() && lastModified != 0L) \n                || (resource.lastModified() != lastModified)) {\n                // Reload application\n                if(log.isInfoEnabled())\n                    log.info(sm.getString(\"hostConfig.reload\", app.name));\n                Container context = host.findChild(app.name);\n                try {\n                    context.stop();\n                } catch (Exception e) {\n                    log.warn(sm.getString\n                             (\"hostConfig.context.restart\", app.name), e);\n                }\n                // If the context was not started (for example an error \n                // in web.xml) we'll still get to try to start\n                try {\n                    context.start();\n                } catch (Exception e) {\n                    log.warn(sm.getString\n                             (\"hostConfig.context.restart\", app.name), e);\n                }\n                // Update times\n                app.reloadResources.put(resources[i],\n                        new Long(resource.lastModified()));\n                app.timestamp = System.currentTimeMillis();\n                return;\n            }\n        }\n    }","id":9240,"modified_method":"/**\n     * Check resources for redeployment and reloading.\n     */\n    protected synchronized void checkResources(DeployedApplication app) {\n        String[] resources =\n            app.redeployResources.keySet().toArray(new String[0]);\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled())\n                log.debug(\"Checking context[\" + app.name +\n                        \"] redeploy resource \" + resource);\n            if (resource.exists()) {\n                long lastModified =\n                    app.redeployResources.get(resources[i]).longValue();\n                if ((!resource.isDirectory()) &&\n                        resource.lastModified() > lastModified) {\n                    // Undeploy application\n                    if (log.isInfoEnabled())\n                        log.info(sm.getString(\"hostConfig.undeploy\", app.name));\n                    ContainerBase context =\n                        (ContainerBase) host.findChild(app.name);\n                    try {\n                        host.removeChild(context);\n                    } catch (Throwable t) {\n                        ExceptionUtils.handleThrowable(t);\n                        log.warn(sm.getString\n                                 (\"hostConfig.context.remove\", app.name), t);\n                    }\n                    // Delete other redeploy resources\n                    for (int j = i + 1; j < resources.length; j++) {\n                        try {\n                            File current = new File(resources[j]);\n                            current = current.getCanonicalFile();\n                            if ((current.getAbsolutePath().startsWith(\n                                    appBase().getAbsolutePath() +\n                                    File.separator))\n                                    || (current.getAbsolutePath().startsWith(\n                                            configBase().getAbsolutePath()))) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"Delete \" + current);\n                                ExpandWar.delete(current);\n                            }\n                        } catch (IOException e) {\n                            log.warn(sm.getString\n                                    (\"hostConfig.canonicalizing\", app.name), e);\n                        }\n                    }\n                    deployed.remove(app.name);\n                    return;\n                }\n            } else {\n                // There is a chance the the resource was only missing\n                // temporarily eg renamed during a text editor save\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e1) {\n                    // Ignore\n                }\n                // Recheck the resource to see if it was really deleted\n                if (resource.exists()) {\n                    continue;\n                }\n                long lastModified =\n                    app.redeployResources.get(resources[i]).longValue();\n                if (lastModified == 0L) {\n                    continue;\n                }\n                // Undeploy application\n                if (log.isInfoEnabled())\n                    log.info(sm.getString(\"hostConfig.undeploy\", app.name));\n                ContainerBase context = \n                    (ContainerBase) host.findChild(app.name);\n                try {\n                    host.removeChild(context);\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.warn(sm.getString\n                             (\"hostConfig.context.remove\", app.name), t);\n                }\n                // Delete all redeploy resources\n                for (int j = i + 1; j < resources.length; j++) {\n                    try {\n                        File current = new File(resources[j]);\n                        current = current.getCanonicalFile();\n                        if ((current.getAbsolutePath().startsWith(\n                                appBase().getAbsolutePath() + File.separator))\n                            || (current.getAbsolutePath().startsWith(\n                                    configBase().getAbsolutePath()))) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"Delete \" + current);\n                            ExpandWar.delete(current);\n                        }\n                    } catch (IOException e) {\n                        log.warn(sm.getString\n                                (\"hostConfig.canonicalizing\", app.name), e);\n                    }\n                }\n                // Delete reload resources as well (to remove any remaining .xml\n                // descriptor)\n                String[] resources2 =\n                    app.reloadResources.keySet().toArray(new String[0]);\n                for (int j = 0; j < resources2.length; j++) {\n                    try {\n                        File current = new File(resources2[j]);\n                        current = current.getCanonicalFile();\n                        if ((current.getAbsolutePath().startsWith(\n                                appBase().getAbsolutePath() + File.separator))\n                            || ((current.getAbsolutePath().startsWith(\n                                    configBase().getAbsolutePath())\n                                 && (current.getAbsolutePath().endsWith(\".xml\"))))) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"Delete \" + current);\n                            ExpandWar.delete(current);\n                        }\n                    } catch (IOException e) {\n                        log.warn(sm.getString\n                                (\"hostConfig.canonicalizing\", app.name), e);\n                    }\n                }\n                deployed.remove(app.name);\n                return;\n            }\n        }\n        resources = app.reloadResources.keySet().toArray(new String[0]);\n        for (int i = 0; i < resources.length; i++) {\n            File resource = new File(resources[i]);\n            if (log.isDebugEnabled())\n                log.debug(\"Checking context[\" + app.name +\n                        \"] reload resource \" + resource);\n            long lastModified =\n                app.reloadResources.get(resources[i]).longValue();\n            if ((!resource.exists() && lastModified != 0L) \n                || (resource.lastModified() != lastModified)) {\n                // Reload application\n                if(log.isInfoEnabled())\n                    log.info(sm.getString(\"hostConfig.reload\", app.name));\n                Container context = host.findChild(app.name);\n                try {\n                    context.stop();\n                } catch (Exception e) {\n                    log.warn(sm.getString\n                             (\"hostConfig.context.restart\", app.name), e);\n                }\n                // If the context was not started (for example an error \n                // in web.xml) we'll still get to try to start\n                try {\n                    context.start();\n                } catch (Exception e) {\n                    log.warn(sm.getString\n                             (\"hostConfig.context.restart\", app.name), e);\n                }\n                // Update times\n                app.reloadResources.put(resources[i],\n                        Long.valueOf(resource.lastModified()));\n                app.timestamp = System.currentTimeMillis();\n                return;\n            }\n        }\n    }","commit_id":"4b41600fa6dca93ac5011655e15f71a20e53cfd6","url":"https://github.com/apache/tomcat"},{"original_method":"public BuildInfo(Element node) {\n    myNumber = BuildNumber.fromString(node.getAttributeValue(\"number\"));\n    myVersion = node.getAttributeValue(\"version\");\n\n    Date releaseDate = null;\n    String date = node.getAttributeValue(\"date\");\n    if (date != null) {\n      try {\n        releaseDate = new SimpleDateFormat(\"dd.MM.yyyy\").parse(date);\n      }\n      catch (ParseException e) {\n        LOG.info(\"Failed to parse build release date \" + date);\n      }\n    }\n    myReleaseDate = releaseDate;\n\n    myPatches = new ArrayList<PatchInfo>();\n    for (Object patchNode : node.getChildren(\"patch\")) {\n      myPatches.add(new PatchInfo((Element)patchNode));\n    }\n\n    Element messageTag = node.getChild(\"message\");\n    myMessage = messageTag != null ? messageTag.getValue() : \"\";\n  }","id":9241,"modified_method":"public BuildInfo(Element node) {\n    myNumber = BuildNumber.fromString(node.getAttributeValue(\"number\"));\n    myVersion = node.getAttributeValue(\"version\");\n\n    Date releaseDate = null;\n    String date = node.getAttributeValue(\"date\");\n    if (date != null) {\n      try {\n        releaseDate = new SimpleDateFormat(\"dd.MM.yyyy\").parse(date);\n      }\n      catch (ParseException e) {\n        LOG.info(\"Failed to parse build release date \" + date);\n      }\n    }\n    myReleaseDate = releaseDate;\n\n    myPatches = new ArrayList<PatchInfo>();\n    for (Object patchNode : node.getChildren(\"patch\")) {\n      myPatches.add(new PatchInfo((Element)patchNode));\n    }\n    \n    myButtons = new ArrayList<ButtonInfo>();\n    for (Object buttonNode : node.getChildren(\"button\")) {\n      myButtons.add(new ButtonInfo((Element) buttonNode));\n    }\n\n    Element messageTag = node.getChild(\"message\");\n    myMessage = messageTag != null ? messageTag.getValue() : \"\";\n  }","commit_id":"cd375080d83bf1ae7b5c70818f8c97c03b0dd696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected Action[] createActions() {\n    AbstractAction ignore = new AbstractAction(\"&Ignore This Update\") {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        UpdateSettings.getInstance().getIgnoredBuildNumbers().add(myLatestBuild.getNumber().asStringWithoutProductCode());\n        doCancelAction();\n      }\n    };\n    if (hasPatch()) {\n      AbstractAction moreInfo = new AbstractAction(IdeBundle.message(\"updates.more.info.button\")) {\n        public void actionPerformed(ActionEvent e) {\n          openDownloadPage();\n        }\n      };\n      return new Action[]{getOKAction(), moreInfo, getCancelAction(), ignore };\n    }\n\n    return new Action[] { getOKAction(), getCancelAction(), ignore };\n  }","id":9242,"modified_method":"@Override\n  protected Action[] createActions() {\n    List<Action> actions = new ArrayList<Action>();\n    actions.add(getOKAction());\n\n    final List<ButtonInfo> buttons = myLatestBuild.getButtons();\n\n    if (hasPatch()) {\n      if (buttons.isEmpty()) {\n        actions.add(new AbstractAction(IdeBundle.message(\"updates.more.info.button\")) {\n          public void actionPerformed(ActionEvent e) {\n            openDownloadPage();\n          }\n        });\n      }\n      else {\n        for (ButtonInfo info : buttons) {\n          actions.add(new ButtonAction(info));\n        }\n      }\n    }\n    else {\n      for (int i = 1; i < buttons.size(); i++) {\n        actions.add(new ButtonAction(buttons.get(i)));\n      }\n    }\n    actions.add(getCancelAction());\n    actions.add(new AbstractAction(\"&Ignore This Update\") {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            UpdateSettings.getInstance().getIgnoredBuildNumbers().add(myLatestBuild.getNumber().asStringWithoutProductCode());\n            doCancelAction();\n          }\n        });\n\n    return actions.toArray(new Action[buttons.size()]);\n  }","commit_id":"cd375080d83bf1ae7b5c70818f8c97c03b0dd696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    if (hasPatch()) {\n      super.doOKAction();\n      return;\n    }\n\n    openDownloadPage();\n    super.doOKAction();\n  }","id":9243,"modified_method":"@Override\n  protected void doOKAction() {\n    if (hasPatch()) {\n      super.doOKAction();\n      return;\n    }\n\n    if (myLatestBuild.getButtons().size() > 0) {\n      BrowserUtil.launchBrowser(myLatestBuild.getButtons().get(0).getUrl());\n    }\n    else {\n      openDownloadPage();\n    }\n    super.doOKAction();\n  }","commit_id":"cd375080d83bf1ae7b5c70818f8c97c03b0dd696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getOkButtonText() {\n    if (hasPatch()) {\n      return ApplicationManager.getApplication().isRestartCapable()\n             ? IdeBundle.message(\"updates.download.and.install.patch.button.restart\")\n             : IdeBundle.message(\"updates.download.and.install.patch.button\");\n    }\n    else {\n      return IdeBundle.message(\"updates.more.info.button\");\n    }\n  }","id":9244,"modified_method":"protected String getOkButtonText() {\n    if (hasPatch()) {\n      return ApplicationManager.getApplication().isRestartCapable()\n             ? IdeBundle.message(\"updates.download.and.install.patch.button.restart\")\n             : IdeBundle.message(\"updates.download.and.install.patch.button\");\n    }\n    else if (myLatestBuild.getButtons().size() > 0) {\n      return myLatestBuild.getButtons().get(0).getName();\n    }\n    else {\n      return IdeBundle.message(\"updates.more.info.button\");\n    }\n  }","commit_id":"cd375080d83bf1ae7b5c70818f8c97c03b0dd696","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(@Nullable Project project) {\n    if (project == null || ProjectLevelVcsManager.getInstance(project).getAllVcss().length == 0) {\n      return Collections.emptyList();\n    }\n    return Collections.unmodifiableCollection(Arrays.asList(\n      option(project, \"checkbox.use.read.only.flag.for.not.edited.files\", \"MAKE_NEW_FILES_READONLY\"),\n      option(project, \"checkbox.show.cvs.server.output\", \"SHOW_OUTPUT\")));\n  }","id":9245,"modified_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(@Nullable Project project) {\n    if (project != null) {\n      for (VcsDescriptor descriptor : ProjectLevelVcsManager.getInstance(project).getAllVcss()) {\n        if (\"CVS\".equals(descriptor.getDisplayName())) {\n          return Collections.unmodifiableCollection(Arrays.asList(\n            option(project, \"checkbox.use.read.only.flag.for.not.edited.files\", \"MAKE_NEW_FILES_READONLY\"),\n            option(project, \"checkbox.show.cvs.server.output\", \"SHOW_OUTPUT\")));\n        }\n      }\n    }\n    return Collections.emptyList();\n  }","commit_id":"7fd50b0ccd1c7b9228cbc6c929b4f4398052b544","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(Project project) {\n    if (ProjectLevelVcsManager.getInstance(project).getAllVcss().length == 0) {\n      return Collections.emptyList();\n    }\n    return Collections.unmodifiableCollection(Arrays.asList(\n      option(project, \"Git: Commit automatically on cherry-pick\", \"isAutoCommitOnCherryPick\", \"setAutoCommitOnCherryPick\"),\n      option(project, \"Git: Auto-update if push of the current branch was rejected\", \"autoUpdateIfPushRejected\", \"setAutoUpdateIfPushRejected\"),\n      option(project, \"Git: Warn if CRLF line separators are about to be committed\", \"warnAboutCrlf\", \"setWarnAboutCrlf\"),\n      option(project, \"Git: Warn when committing in detached HEAD or during rebase\", \"warnAboutDetachedHead\", \"setWarnAboutDetachedHead\")));\n  }","id":9246,"modified_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(@Nullable Project project) {\n    if (project != null) {\n      for (VcsDescriptor descriptor : ProjectLevelVcsManager.getInstance(project).getAllVcss()) {\n        if (\"Git\".equals(descriptor.getDisplayName())) {\n          return Collections.unmodifiableCollection(Arrays.asList(\n            option(project, \"Git: Commit automatically on cherry-pick\", \"isAutoCommitOnCherryPick\", \"setAutoCommitOnCherryPick\"),\n            option(project, \"Git: Auto-update if push of the current branch was rejected\", \"autoUpdateIfPushRejected\", \"setAutoUpdateIfPushRejected\"),\n            option(project, \"Git: Warn if CRLF line separators are about to be committed\", \"warnAboutCrlf\", \"setWarnAboutCrlf\"),\n            option(project, \"Git: Warn when committing in detached HEAD or during rebase\", \"warnAboutDetachedHead\", \"setWarnAboutDetachedHead\")));\n        }\n      }\n    }\n    return Collections.emptyList();\n  }","commit_id":"7fd50b0ccd1c7b9228cbc6c929b4f4398052b544","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(Project project) {\n    if (ProjectLevelVcsManager.getInstance(project).getAllVcss().length == 0) {\n      return Collections.emptyList();\n    }\n    return Collections.unmodifiableCollection(Arrays.asList(\n      option(project, \"Mercurial: Check for incoming and outgoing changesets\", \"isCheckIncomingOutgoing\", \"setCheckIncomingOutgoing\"),\n      option(project, \"Mercurial: Ignore whitespace differences in annotations\", \"isWhitespacesIgnoredInAnnotations\", \"setIgnoreWhitespacesInAnnotations\")));\n  }","id":9247,"modified_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(@Nullable Project project) {\n    if (project != null) {\n      for (VcsDescriptor descriptor : ProjectLevelVcsManager.getInstance(project).getAllVcss()) {\n        if (\"Mercurial\".equals(descriptor.getDisplayName())) {\n          return Collections.unmodifiableCollection(Arrays.asList(\n            option(project, \"Mercurial: Check for incoming and outgoing changesets\", \"isCheckIncomingOutgoing\", \"setCheckIncomingOutgoing\"),\n            option(project, \"Mercurial: Ignore whitespace differences in annotations\", \"isWhitespacesIgnoredInAnnotations\", \"setIgnoreWhitespacesInAnnotations\")));\n        }\n      }\n    }\n    return Collections.emptyList();\n  }","commit_id":"7fd50b0ccd1c7b9228cbc6c929b4f4398052b544","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Get commit encoding for the specified root\n   *\n   * @param project the context project\n   * @param root    the project root\n   * @return the commit encoding or UTF-8 if the encoding is note explicitly specified\n   */\n  public static String getCommitEncoding(final Project project, VirtualFile root) {\n    @NonNls String encoding = null;\n    try {\n      encoding = getValue(project, root, \"i18n.commitencoding\");\n    }\n    catch (VcsException e) {\n      // ignore exception\n    }\n    if (encoding == null || encoding.length() == 0) {\n      encoding = \"UTF-8\";\n    }\n    return encoding;\n  }","id":9248,"modified_method":"/**\n   * Get commit encoding for the specified root\n   *\n   * @param project the context project\n   * @param root    the project root\n   * @return the commit encoding or UTF-8 if the encoding is note explicitly specified\n   */\n  public static String getCommitEncoding(final Project project, VirtualFile root) {\n    @NonNls String encoding = null;\n    try {\n      encoding = getValue(project, root, \"i18n.commitencoding\");\n    }\n    catch (VcsException e) {\n      // ignore exception\n    }\n    if (encoding == null || encoding.length() == 0) {\n      encoding = UTF8_ENCODING;\n    }\n    return encoding;\n  }","commit_id":"dd42e9917e734a66249c96a5e7c0306faacbb7c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Collect changes\n   *\n   * @param exceptions a list of exceptions\n   */\n  public void collect(List<VcsException> exceptions) {\n    try {\n      // collect unmerged\n      String root = myRoot.getPath();\n      GitSimpleHandler h = new GitSimpleHandler(myProject, myRoot, GitHandler.LS_FILES);\n      h.setNoSSH(true);\n      h.setSilent(true);\n      h.addParameters(\"--unmerged\");\n      for (String line : h.run().split(\"\\n\")) {\n        if (line.length() == 0) {\n          continue;\n        }\n        String[] tk = line.split(\"[\\t ]+\");\n        final String relative = tk[tk.length - 1];\n        if (!myUnmergedPaths.add(relative)) {\n          continue;\n        }\n        String path = root + \"/\" + GitUtil.unescapePath(relative);\n        myUpdates.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID).add(path);\n      }\n      // collect other changes (ignoring unmerged)\n      h = new GitSimpleHandler(myProject, myRoot, GitHandler.DIFF);\n      h.setSilent(true);\n      h.setNoSSH(true);\n      // note that moves are not detected here\n      h.addParameters(\"--name-status\", \"--diff-filter=ADMRUX\", myStart.getRev());\n      for (String line : h.run().split(\"\\n\")) {\n        if (line.length() == 0) {\n          continue;\n        }\n        String[] tk = line.split(\"[\\t ]+\");\n        final String relative = tk[tk.length - 1];\n        if (myUnmergedPaths.contains(relative)) {\n          continue;\n        }\n        String path = root + \"/\" + GitUtil.unescapePath(relative);\n        switch (tk[0].charAt(0)) {\n          case 'M':\n            myUpdates.getGroupById(FileGroup.UPDATED_ID).add(path);\n            break;\n          case 'A':\n            myUpdates.getGroupById(FileGroup.CREATED_ID).add(path);\n            break;\n          case 'D':\n            myUpdates.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).add(path);\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected status: \" + line);\n        }\n      }\n    }\n    catch (VcsException e) {\n      exceptions.add(e);\n    }\n  }","id":9249,"modified_method":"/**\n   * Collect changes\n   *\n   * @param exceptions a list of exceptions\n   */\n  public void collect(List<VcsException> exceptions) {\n    try {\n      // collect unmerged\n      String root = myRoot.getPath();\n      GitSimpleHandler h = new GitSimpleHandler(myProject, myRoot, GitHandler.LS_FILES);\n      h.setNoSSH(true);\n      h.setSilent(true);\n      h.addParameters(\"--unmerged\");\n      for (String line : h.run().split(\"\\n\")) {\n        if (line.length() == 0) {\n          continue;\n        }\n        String[] tk = line.split(\"[\\t ]+\");\n        final String relative = tk[tk.length - 1];\n        if (!myUnmergedPaths.add(relative)) {\n          continue;\n        }\n        String path = root + \"/\" + GitUtil.unescapePath(relative);\n        myUpdates.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID).add(path);\n      }\n      GitRevisionNumber currentHead = GitRevisionNumber.resolve(myProject, myRoot, \"HEAD\");\n      // collect other changes (ignoring unmerged)\n      TreeSet<String> updated = new TreeSet<String>();\n      TreeSet<String> created = new TreeSet<String>();\n      TreeSet<String> removed = new TreeSet<String>();\n      if (currentHead.equals(myStart)) {\n        // The head has not advanced. This means that this is a merge that did not commit.\n        // This could be caused by --no-commit option or by failed two-head merge. The MERGE_HEAD\n        // should be available. In case of --no-commit option, the MERGE_HEAD might contain\n        // multiple heads separated by newline. The changes are collected separately for each head\n        // and they are merged using TreeSet class (that also sorts the changes).\n        File mergeHeadsFile = new File(root, \".git/MERGE_HEAD\");\n        try {\n          String mergeHeads = new String(FileUtil.loadFileText(mergeHeadsFile, GitConfigUtil.UTF8_ENCODING));\n          for (StringScanner s = new StringScanner(mergeHeads); s.hasMoreData();) {\n            String head = s.line();\n            if (head.length() == 0) {\n              continue;\n            }\n            // note that \"...\" cause the diff to start from common parent between head and merge head\n            processDiff(root, updated, created, removed, myStart.getRev() + \"...\" + head);\n          }\n        }\n        catch (IOException e) {\n          //noinspection ThrowableInstanceNeverThrown\n          exceptions.add(new VcsException(\"Unable to read the file \" + mergeHeadsFile + \": \" + e.getMessage(), e));\n        }\n      }\n      else {\n        // Otherwise this is a merge that did created a commit. And because of this the incoming changes\n        // are diffs between old head and new head. The commit could have been multihead commit,\n        // and the expression below considers it as well.\n        processDiff(root, updated, created, removed, myStart.getRev() + \"..HEAD\");\n      }\n      addAll(FileGroup.UPDATED_ID, updated);\n      addAll(FileGroup.CREATED_ID, created);\n      addAll(FileGroup.REMOVED_FROM_REPOSITORY_ID, removed);\n    }\n    catch (VcsException e) {\n      exceptions.add(e);\n    }\n  }","commit_id":"dd42e9917e734a66249c96a5e7c0306faacbb7c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getContent() throws VcsException {\n    if (myFile.isDirectory()) {\n      return null;\n    }\n    VirtualFile root = GitUtil.getGitRoot(myFile);\n    GitBinaryHandler h = new GitBinaryHandler(myProject, root, GitCommand.SHOW);\n    h.setCharset(myCharset);\n    h.setNoSSH(true);\n    h.setSilent(true);\n    h.addParameters(myRevision.getRev() + \":\" + GitUtil.relativePath(root, myFile));\n    byte[] result = h.run();\n    return new String(result, h.getCharset());\n  }","id":9250,"modified_method":"@Nullable\n  public String getContent() throws VcsException {\n    if (myFile.isDirectory()) {\n      return null;\n    }\n    VirtualFile root = GitUtil.getGitRoot(myFile);\n    byte[] result = GitFileUtils.getFileContent(myProject, root, myRevision.getRev(), GitUtil.relativePath(root, myFile));\n    return result == null ? null : new String(result, myCharset);\n  }","commit_id":"6c395fb3edac990dd6862f65a906a94bf10207a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void loadContent() throws VcsException {\n    final VirtualFile root = GitUtil.getGitRoot(path);\n    GitBinaryHandler h = new GitBinaryHandler(project, root, GitCommand.SHOW);\n    h.setNoSSH(true);\n    h.setSilent(true);\n    h.addParameters(revision.getRev() + \":\" + GitUtil.relativePath(root, path));\n    content = h.run();\n  }","id":9251,"modified_method":"public synchronized void loadContent() throws VcsException {\n    final VirtualFile root = GitUtil.getGitRoot(path);\n    if (content == null) {\n      content = GitFileUtils.getFileContent(project, root, revision.getRev(), GitUtil.relativePath(root, path));\n      if (content == null) {\n        content = new byte[0];\n      }\n    }\n  }","commit_id":"6c395fb3edac990dd6862f65a906a94bf10207a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean check(String uri, Resource resource)\n    {\n        // Only support PathResource alias checking\n        if (!(resource instanceof PathResource))\n            return false;\n        \n        PathResource pathResource = (PathResource)resource;\n\n        try\n        {\n            Path path = pathResource.getPath();\n            Path alias = pathResource.getAliasPath();\n            \n            // is the file itself a symlink?\n            if (Files.isSymbolicLink(path))\n            {        \n                alias = path.getParent().resolve(alias);\n                if (LOG.isDebugEnabled())\n                {\n                    LOG.debug(\"path ={}\",path);\n                    LOG.debug(\"alias={}\",alias);\n                }\n                if (Files.isSameFile(path,alias))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                    return true;\n                }\n            }\n            \n            // No, so let's check each element ourselves\n            Path d = path.getRoot();\n            for (Path e:path)\n            {\n                d=d.resolve(e);\n                \n                while (Files.exists(d) && Files.isSymbolicLink(d))\n                {\n                    Path link=Files.readSymbolicLink(d);                    \n                    if (!link.isAbsolute())\n                        link=d.resolve(link);\n                    d=link;\n                }\n            }\n            if (pathResource.getAliasPath().equals(d))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Allow path symlink {} --> {}\",resource,d);\n                return true;\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.ignore(e);\n        }\n        \n        return false;\n    }","id":9252,"modified_method":"@Override\n    public boolean check(String uri, Resource resource)\n    {\n        // Only support PathResource alias checking\n        if (!(resource instanceof PathResource))\n            return false;\n        \n        PathResource pathResource = (PathResource)resource;\n\n        try\n        {\n            Path path = pathResource.getPath();\n            Path alias = pathResource.getAliasPath();\n            \n            // is the file itself a symlink?\n            if (Files.isSymbolicLink(path))\n            {        \n                alias = path.getParent().resolve(alias);\n                if (LOG.isDebugEnabled())\n                {\n                    LOG.debug(\"path ={}\",path);\n                    LOG.debug(\"alias={}\",alias);\n                }\n                if (Files.isSameFile(path,alias))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                    return true;\n                }\n            }\n            \n            // No, so let's check each element ourselves\n            boolean linked=true;\n            Path target=path;\n            int loops=0;\n            while (linked)\n            {\n                if (++loops>100)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Too many symlinks {} --> {}\",resource,target);\n                    return false;\n                }\n                linked=false;\n                Path d = target.getRoot();\n                for (Path e:target)\n                {\n                    d=d.resolve(e);\n\n                    while (Files.exists(d) && Files.isSymbolicLink(d))\n                    {\n                        Path link=Files.readSymbolicLink(d);                    \n                        if (!link.isAbsolute())\n                            link=d.resolve(link);\n                        d=link;\n                        linked=true;\n                    }\n                }\n                target=d;\n            }\n            \n            if (pathResource.getAliasPath().equals(target))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Allow path symlink {} --> {}\",resource,target);\n                return true;\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.ignore(e);\n        }\n        \n        return false;\n    }","commit_id":"4bb63b9e03047f3f1991152b814aadfbaeba0411","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@BeforeClass\n    public static void beforeClass()  throws Exception\n    {\n        File testRoot = MavenTestingUtils.getTargetTestingDir(ContextHandlerGetResourceTest.class.getSimpleName());\n        FS.ensureEmpty(testRoot);\n        docroot = new File(testRoot,\"docroot\").getCanonicalFile().getAbsoluteFile();\n        FS.ensureEmpty(docroot);\n        File index = new File(docroot,\"index.html\");\n        index.createNewFile();\n        File sub = new File(docroot,\"subdir\");\n        sub.mkdir();\n        File data = new File(sub,\"data.txt\");\n        data.createNewFile();\n        File verylong = new File(sub,\"TextFile.Long.txt\");\n        verylong.createNewFile();\n\n        otherroot = new File(testRoot, \"otherroot\").getCanonicalFile().getAbsoluteFile();\n        FS.ensureEmpty(otherroot);\n        File other = new File(otherroot,\"other.txt\");\n        other.createNewFile();\n        \n        File transit = new File(docroot.getParentFile(),\"transit\");\n        transit.delete();\n        \n        if (OS.IS_UNIX)\n        {\n            // Create alias as 8.3 name so same test will produce an alias on both windows an normal systems\n            File eightDotThree=new File(sub,\"TEXTFI~1.TXT\");\n            Files.createSymbolicLink(eightDotThree.toPath(),verylong.toPath());\n            \n            Files.createSymbolicLink(new File(docroot,\"other\").toPath(),new File(\"../transit\").toPath());\n            Files.createSymbolicLink(transit.toPath(),otherroot.toPath());\n        }\n        \n        OS_ALIAS_SUPPORTED = new File(sub, \"TEXTFI~1.TXT\").exists(); \n        \n        server = new Server();\n        context =new ContextHandler(\"/\");\n        context.clearAliasChecks();\n        context.addAliasCheck(new ContextHandler.ApproveNonExistentDirectoryAliases());\n        context.setBaseResource(Resource.newResource(docroot));\n        context.addAliasCheck(new ContextHandler.AliasCheck()\n        {\n            final AllowSymLinkAliasChecker symlinkcheck = new AllowSymLinkAliasChecker();\n            @Override\n            public boolean check(String path, Resource resource)\n            {\n                if (allowAliases.get())\n                    return true;\n                if (allowSymlinks.get())\n                    return symlinkcheck.check(path,resource);\n                return allowAliases.get();\n            }\n        });\n        \n        server.setHandler(context);\n        server.start();\n    }","id":9253,"modified_method":"@BeforeClass\n    public static void beforeClass()  throws Exception\n    {\n        File testRoot = MavenTestingUtils.getTargetTestingDir(ContextHandlerGetResourceTest.class.getSimpleName());\n        FS.ensureEmpty(testRoot);\n        docroot = new File(testRoot,\"docroot\").getCanonicalFile().getAbsoluteFile();\n        FS.ensureEmpty(docroot);\n        File index = new File(docroot,\"index.html\");\n        index.createNewFile();\n        File sub = new File(docroot,\"subdir\");\n        sub.mkdir();\n        File data = new File(sub,\"data.txt\");\n        data.createNewFile();\n        File verylong = new File(sub,\"TextFile.Long.txt\");\n        verylong.createNewFile();\n\n        otherroot = new File(testRoot, \"otherroot\").getCanonicalFile().getAbsoluteFile();\n        FS.ensureEmpty(otherroot);\n        File other = new File(otherroot,\"other.txt\");\n        other.createNewFile();\n        \n        File transit = new File(docroot.getParentFile(),\"transit\");\n        transit.delete();\n        \n        if (OS.IS_UNIX)\n        {\n            // Create alias as 8.3 name so same test will produce an alias on both windows an normal systems\n            File eightDotThree=new File(sub,\"TEXTFI~1.TXT\");\n            Files.createSymbolicLink(eightDotThree.toPath(),verylong.toPath());\n            \n            Files.createSymbolicLink(new File(docroot,\"other\").toPath(),new File(\"../transit\").toPath());\n            Files.createSymbolicLink(transit.toPath(),otherroot.toPath());\n            \n            // /web/logs -> /var/logs -> /media/internal/logs\n            // where /media/internal -> /media/internal-physical/\n            new File(docroot,\"media/internal-physical/logs\").mkdirs();\n            Files.createSymbolicLink(new File(docroot,\"media/internal\").toPath(),new File(docroot,\"media/internal-physical\").toPath());\n            new File(docroot,\"var\").mkdir();\n            Files.createSymbolicLink(new File(docroot,\"var/logs\").toPath(),new File(docroot,\"media/internal/logs\").toPath());\n            new File(docroot,\"web\").mkdir();\n            Files.createSymbolicLink(new File(docroot,\"web/logs\").toPath(),new File(docroot,\"var/logs\").toPath()); \n            new File(docroot,\"media/internal-physical/logs/file.log\").createNewFile();\n            \n            System.err.println(\"docroot=\"+docroot);\n        }\n        \n        OS_ALIAS_SUPPORTED = new File(sub, \"TEXTFI~1.TXT\").exists(); \n        \n        server = new Server();\n        context =new ContextHandler(\"/\");\n        context.clearAliasChecks();\n        context.addAliasCheck(new ContextHandler.ApproveNonExistentDirectoryAliases());\n        context.setBaseResource(Resource.newResource(docroot));\n        context.addAliasCheck(new ContextHandler.AliasCheck()\n        {\n            final AllowSymLinkAliasChecker symlinkcheck = new AllowSymLinkAliasChecker();\n            @Override\n            public boolean check(String path, Resource resource)\n            {\n                if (allowAliases.get())\n                    return true;\n                if (allowSymlinks.get())\n                    return symlinkcheck.check(path,resource);\n                return allowAliases.get();\n            }\n        });\n        \n        server.setHandler(context);\n        server.start();\n    }","commit_id":"4bb63b9e03047f3f1991152b814aadfbaeba0411","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** {@inheritDoc} */\r\n  @Override\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    if (rowKey == null) {\r\n      if (this.stopRowKey == null) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }    \r\n    boolean result = this.stopRowKey.compareTo(rowKey) < 0;\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"Filter result for rowKey: \" + rowKey + \".  Result: \" + \r\n        result);\r\n    }\r\n    return result;\r\n  }","id":9254,"modified_method":"/** {@inheritDoc} */\r\n  @Override\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    if (rowKey == null) {\r\n      if (this.stopRowKey == null) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }    \r\n    return this.stopRowKey.compareTo(rowKey) < 0;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterAllRemaining() {\r\n    boolean result = this.rowsAccepted > this.pageSize;\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filtering decision is \" + result + \" with rowsAccepted: \" + \r\n        this.rowsAccepted);\r\n    }\r\n    return result;\r\n  }","id":9255,"modified_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterAllRemaining() {\r\n    return this.rowsAccepted > this.pageSize;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterRow(final SortedMap<Text, byte[]> columns) {\r\n    for (Entry<Text, byte[]> col : columns.entrySet()) {\r\n      if (nullColumns.contains(col.getKey())\r\n          && !HLogEdit.isDeleted(col.getValue())) {\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"filterNotNull returning true for colKey: \" + col.getKey()\r\n            + \", column should be null.\");\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    for (Text col : equalsMap.keySet()) {\r\n      if (!columns.containsKey(col)) {\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"filterNotNull returning true for colKey: \" + col + \r\n            \", column not found in given SortedMap<Text, byte[]>.\");\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filterNotNull returning false.\");\r\n    }\r\n    return false;\r\n  }","id":9256,"modified_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterRow(final SortedMap<Text, byte[]> columns) {\r\n    for (Entry<Text, byte[]> col : columns.entrySet()) {\r\n      if (nullColumns.contains(col.getKey())\r\n          && !HLogEdit.isDeleted(col.getValue())) {\r\n        return true;\r\n      }\r\n    }\r\n    for (Text col : equalsMap.keySet()) {\r\n      if (!columns.containsKey(col)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterColumn(final Text rowKey, final Text colKey,\r\n      final byte[] data) {\r\n    if (filterRowKey(rowKey)) {\r\n      return true;\r\n    }\r\n    if (filtersByColumnValue()) {\r\n      byte[] filterValue = equalsMap.get(colKey);\r\n      if (null != filterValue) {\r\n        boolean result = !Arrays.equals(filterValue, data);\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"filter returning \" + result + \" for rowKey: \" + rowKey + \r\n            \" colKey: \" + colKey);\r\n        }\r\n        return result;\r\n      }\r\n    }\r\n    if (nullColumns.contains(colKey)) {\r\n      if (data != null && !HLogEdit.isDeleted(data)) {\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"filter returning true for rowKey: \" + rowKey + \r\n            \" colKey: \" + colKey);\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filter returning false for rowKey: \" + rowKey + \" colKey: \" + \r\n        colKey);\r\n    }\r\n    return false;\r\n  }","id":9257,"modified_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterColumn(final Text rowKey, final Text colKey,\r\n      final byte[] data) {\r\n    if (filterRowKey(rowKey)) {\r\n      return true;\r\n    }\r\n    if (filtersByColumnValue()) {\r\n      byte[] filterValue = equalsMap.get(colKey);\r\n      if (null != filterValue) {\r\n        return !Arrays.equals(filterValue, data);\r\n      }\r\n    }\r\n    if (nullColumns.contains(colKey)) {\r\n      if (data != null && !HLogEdit.isDeleted(data)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    if (filtersByRowKey() && rowKey != null) {\r\n      boolean result = !getRowKeyPattern().matcher(rowKey.toString()).matches();\r\n      if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"filter returning \" + result + \" for rowKey: \" + rowKey);\r\n      }\r\n      return result;\r\n    }\r\n    return false;\r\n  }","id":9258,"modified_method":"/**\r\n   * \r\n   * {@inheritDoc}\r\n   */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    if (filtersByRowKey() && rowKey != null) {\r\n      return !getRowKeyPattern().matcher(rowKey.toString()).matches();\r\n    }\r\n    return false;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    boolean resultFound = false;\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (!resultFound) {\r\n        if (operator == Operator.MUST_PASS_ALL) {\r\n          if (filter.filterAllRemaining() || filter.filterRowKey(rowKey)) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"op.MPALL filter(Text) will return true due\" + \r\n                \" to subfilter of type \" + filter.getClass().getSimpleName());\r\n            }\r\n            result = true;\r\n            resultFound = true;\r\n          }\r\n        } else if (operator == Operator.MUST_PASS_ONE) {\r\n          if (!filter.filterAllRemaining() && !filter.filterRowKey(rowKey)) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"op.MPONE filter(Text) will return false due\" + \r\n                \" to subfilter of type \" + filter.getClass().getSimpleName());\r\n            }\r\n            result = false;\r\n            resultFound = true;\r\n          }\r\n        }\r\n      } else if (filter.processAlways()) {\r\n        filter.filterRowKey(rowKey);\r\n      }\r\n    }\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filter(Text) returning \" + result);\r\n    }\r\n    return result;\r\n  }","id":9259,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    boolean resultFound = false;\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (!resultFound) {\r\n        if (operator == Operator.MUST_PASS_ALL) {\r\n          if (filter.filterAllRemaining() || filter.filterRowKey(rowKey)) {\r\n            result = true;\r\n            resultFound = true;\r\n          }\r\n        } else if (operator == Operator.MUST_PASS_ONE) {\r\n          if (!filter.filterAllRemaining() && !filter.filterRowKey(rowKey)) {\r\n            result = false;\r\n            resultFound = true;\r\n          }\r\n        }\r\n      } else if (filter.processAlways()) {\r\n        filter.filterRowKey(rowKey);\r\n      }\r\n    }\r\n    return result;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public void readFields(final DataInput in) throws IOException {\r\n    Configuration conf = new HBaseConfiguration();\r\n    byte opByte = in.readByte();\r\n    operator = Operator.values()[opByte];\r\n    int size = in.readInt();\r\n    if (size > 0) {\r\n      filters = new HashSet<RowFilterInterface>();\r\n      for (int i = 0; i < size; i++) {\r\n\tRowFilterInterface filter = (RowFilterInterface) ObjectWritable\r\n\t    .readObject(in, conf);\r\n\tfilters.add(filter);\r\n\tif (LOG.isDebugEnabled()) {\r\n\t  LOG.debug(\"Successfully read in subfilter of type \"\r\n\t      + filter.getClass().getSimpleName());\r\n\t}\r\n      }\r\n    }\r\n  }","id":9260,"modified_method":"/** {@inheritDoc} */\r\n  public void readFields(final DataInput in) throws IOException {\r\n    Configuration conf = new HBaseConfiguration();\r\n    byte opByte = in.readByte();\r\n    operator = Operator.values()[opByte];\r\n    int size = in.readInt();\r\n    if (size > 0) {\r\n      filters = new HashSet<RowFilterInterface>();\r\n      for (int i = 0; i < size; i++) {\r\n\tRowFilterInterface filter = (RowFilterInterface) ObjectWritable\r\n\t    .readObject(in, conf);\r\n\tfilters.add(filter);\r\n      }\r\n    }\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean processAlways() {\r\n    for (RowFilterInterface filter : filters) {\r\n      if (filter.processAlways()) {\r\n        if (LOG.isDebugEnabled()) {\r\n          LOG.debug(\"processAlways() is true due to subfilter of type \" + \r\n            filter.getClass().getSimpleName());\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }","id":9261,"modified_method":"/** {@inheritDoc} */\r\n  public boolean processAlways() {\r\n    for (RowFilterInterface filter : filters) {\r\n      if (filter.processAlways()) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public void rowProcessed(boolean filtered, Text rowKey) {\r\n    for (RowFilterInterface filter : filters) {\r\n      filter.rowProcessed(filtered, rowKey);\r\n      if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Called rowProcessed on subfilter of type \" + \r\n          filter.getClass().getSimpleName());\r\n      }\r\n    }\r\n  }","id":9262,"modified_method":"/** {@inheritDoc} */\r\n  public void rowProcessed(boolean filtered, Text rowKey) {\r\n    for (RowFilterInterface filter : filters) {\r\n      filter.rowProcessed(filtered, rowKey);\r\n    }\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public void reset() {\r\n    for (RowFilterInterface filter : filters) {\r\n      filter.reset();\r\n      if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Reset subfilter of type \" + \r\n          filter.getClass().getSimpleName());\r\n      }\r\n    }\r\n  }","id":9263,"modified_method":"/** {@inheritDoc} */\r\n  public void reset() {\r\n    for (RowFilterInterface filter : filters) {\r\n      filter.reset();\r\n    }\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterColumn(final Text rowKey, final Text colKey, \r\n    final byte[] data) {\r\n    boolean resultFound = false;\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (!resultFound) {\r\n        if (operator == Operator.MUST_PASS_ALL) {\r\n          if (filter.filterAllRemaining() || \r\n            filter.filterColumn(rowKey, colKey, data)) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"op.MPALL filter(Text, Text, byte[]) will\" + \r\n                \" return true due to subfilter of type \" + \r\n                filter.getClass().getSimpleName());\r\n            }\r\n            result = true;\r\n            resultFound = true;\r\n          }\r\n        } else if (operator == Operator.MUST_PASS_ONE) {\r\n          if (!filter.filterAllRemaining() && \r\n            !filter.filterColumn(rowKey, colKey, data)) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"op.MPONE filter(Text, Text, byte[]) will\" + \r\n                \" return false due to subfilter of type \" + \r\n                filter.getClass().getSimpleName());\r\n            }\r\n            result = false;\r\n            resultFound = true;\r\n          }\r\n        }\r\n      } else if (filter.processAlways()) {\r\n        filter.filterColumn(rowKey, colKey, data);\r\n      }\r\n    }\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filter(Text, Text, byte[]) returning \" + result);\r\n    }\r\n    return result;\r\n  }","id":9264,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterColumn(final Text rowKey, final Text colKey, \r\n    final byte[] data) {\r\n    boolean resultFound = false;\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (!resultFound) {\r\n        if (operator == Operator.MUST_PASS_ALL) {\r\n          if (filter.filterAllRemaining() || \r\n            filter.filterColumn(rowKey, colKey, data)) {\r\n            result = true;\r\n            resultFound = true;\r\n          }\r\n        } else if (operator == Operator.MUST_PASS_ONE) {\r\n          if (!filter.filterAllRemaining() && \r\n            !filter.filterColumn(rowKey, colKey, data)) {\r\n            result = false;\r\n            resultFound = true;\r\n          }\r\n        }\r\n      } else if (filter.processAlways()) {\r\n        filter.filterColumn(rowKey, colKey, data);\r\n      }\r\n    }\r\n    return result;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public void validate(final Text[] columns) {\r\n    for (RowFilterInterface filter : filters) {\r\n      filter.validate(columns);\r\n      if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Validated subfilter of type \" + \r\n          filter.getClass().getSimpleName());\r\n      }\r\n    }\r\n  }","id":9265,"modified_method":"/** {@inheritDoc} */\r\n  public void validate(final Text[] columns) {\r\n    for (RowFilterInterface filter : filters) {\r\n      filter.validate(columns);\r\n    }\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterAllRemaining() {\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (operator == Operator.MUST_PASS_ALL) {\r\n        if (filter.filterAllRemaining()) {\r\n          if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"op.MPALL filterAllRemaining returning true due\" + \r\n              \" to subfilter of type \" + filter.getClass().getSimpleName());\r\n          }\r\n          return true;\r\n        }\r\n      } else if (operator == Operator.MUST_PASS_ONE) {\r\n        if (!filter.filterAllRemaining()) {\r\n          if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"op.MPONE filterAllRemaining returning false due\" + \r\n              \" to subfilter of type \" + filter.getClass().getSimpleName());\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filterAllRemaining default returning \" + result);\r\n    }\r\n    return result;\r\n  }","id":9266,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterAllRemaining() {\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (operator == Operator.MUST_PASS_ALL) {\r\n        if (filter.filterAllRemaining()) {\r\n          return true;\r\n        }\r\n      } else if (operator == Operator.MUST_PASS_ONE) {\r\n        if (!filter.filterAllRemaining()) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterRow(final SortedMap<Text, byte[]> columns) {\r\n    boolean resultFound = false;\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (!resultFound) {\r\n        if (operator == Operator.MUST_PASS_ALL) {\r\n          if (filter.filterAllRemaining() || filter.filterRow(columns)) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"op.MPALL filterNotNull will return true due\" + \r\n                \" to subfilter of type \" + filter.getClass().getSimpleName());\r\n            }\r\n            result = true;\r\n            resultFound = true;\r\n          }\r\n        } else if (operator == Operator.MUST_PASS_ONE) {\r\n          if (!filter.filterAllRemaining() && !filter.filterRow(columns)) {\r\n            if (LOG.isDebugEnabled()) {\r\n              LOG.debug(\"op.MPONE filterNotNull will return false due\" + \r\n                \" to subfilter of type \" + filter.getClass().getSimpleName());\r\n            }\r\n            result = false;\r\n            resultFound = true;\r\n          }\r\n        }\r\n      } else if (filter.processAlways()) {\r\n        filter.filterRow(columns);\r\n      }\r\n    }\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"filterNotNull returning \" + result);\r\n    }\r\n    return result;\r\n  }","id":9267,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterRow(final SortedMap<Text, byte[]> columns) {\r\n    boolean resultFound = false;\r\n    boolean result = operator == Operator.MUST_PASS_ONE;\r\n    for (RowFilterInterface filter : filters) {\r\n      if (!resultFound) {\r\n        if (operator == Operator.MUST_PASS_ALL) {\r\n          if (filter.filterAllRemaining() || filter.filterRow(columns)) {\r\n            result = true;\r\n            resultFound = true;\r\n          }\r\n        } else if (operator == Operator.MUST_PASS_ONE) {\r\n          if (!filter.filterAllRemaining() && !filter.filterRow(columns)) {\r\n            result = false;\r\n            resultFound = true;\r\n          }\r\n        }\r\n      } else if (filter.processAlways()) {\r\n        filter.filterRow(columns);\r\n      }\r\n    }\r\n    return result;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    if (rowKey == null) {\r\n      if (this.stopRowKey == null) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    boolean result = this.stopRowKey.compareTo(rowKey) <= 0;\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"Filter result for rowKey: \" + rowKey + \".  Result: \" + \r\n        result);\r\n    }\r\n    return result;\r\n  }","id":9268,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    if (rowKey == null) {\r\n      if (this.stopRowKey == null) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    return this.stopRowKey.compareTo(rowKey) <= 0;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public void reset() {\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"Resetting.\");\r\n    }\r\n    this.filterAllRemaining = false;\r\n    this.filter.reset();\r\n  }","id":9269,"modified_method":"/** {@inheritDoc} */\r\n  public void reset() {\r\n    this.filterAllRemaining = false;\r\n    this.filter.reset();\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/**\r\n   * Change filterAllRemaining from false to true if value is true, otherwise \r\n   * leave as is.\r\n   * \r\n   * @param value\r\n   */\r\n  private void changeFAR(boolean value) {\r\n    this.filterAllRemaining = this.filterAllRemaining || value;\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"this.filterAllRemaining is now: \" + \r\n        this.filterAllRemaining);\r\n    }\r\n  }","id":9270,"modified_method":"/**\r\n   * Change filterAllRemaining from false to true if value is true, otherwise \r\n   * leave as is.\r\n   * \r\n   * @param value\r\n   */\r\n  private void changeFAR(boolean value) {\r\n    this.filterAllRemaining = this.filterAllRemaining || value;\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public void readFields(DataInput in) throws IOException {\r\n    String className = in.readUTF();\r\n    \r\n    try {\r\n      this.filter = (RowFilterInterface)(Class.forName(className).\r\n        newInstance());\r\n      this.filter.readFields(in);\r\n      if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Successfully read a sub-filter of type: \" + \r\n          className);\r\n      }\r\n    } catch (InstantiationException e) {\r\n      throw new RuntimeException(\"Failed to deserialize WhileMatchRowFilter.\",\r\n          e);\r\n    } catch (IllegalAccessException e) {\r\n      throw new RuntimeException(\"Failed to deserialize WhileMatchRowFilter.\",\r\n          e);\r\n    } catch (ClassNotFoundException e) {\r\n      throw new RuntimeException(\"Failed to deserialize WhileMatchRowFilter.\",\r\n          e);\r\n    }\r\n  }","id":9271,"modified_method":"/** {@inheritDoc} */\r\n  public void readFields(DataInput in) throws IOException {\r\n    String className = in.readUTF();\r\n    \r\n    try {\r\n      this.filter = (RowFilterInterface)(Class.forName(className).\r\n        newInstance());\r\n      this.filter.readFields(in);\r\n    } catch (InstantiationException e) {\r\n      throw new RuntimeException(\"Failed to deserialize WhileMatchRowFilter.\",\r\n          e);\r\n    } catch (IllegalAccessException e) {\r\n      throw new RuntimeException(\"Failed to deserialize WhileMatchRowFilter.\",\r\n          e);\r\n    } catch (ClassNotFoundException e) {\r\n      throw new RuntimeException(\"Failed to deserialize WhileMatchRowFilter.\",\r\n          e);\r\n    }\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    changeFAR(this.filter.filterRowKey(rowKey));\r\n    boolean result = filterAllRemaining();\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"Filter on rowKey:\" + rowKey + \".  Result = \" + result);\r\n    }\r\n    return result;\r\n  }","id":9272,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterRowKey(final Text rowKey) {\r\n    changeFAR(this.filter.filterRowKey(rowKey));\r\n    return filterAllRemaining();\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterColumn(final Text rowKey, final Text colKey,\r\n    final byte[] data) {\r\n    changeFAR(this.filter.filterColumn(rowKey, colKey, data));\r\n    boolean result = filterAllRemaining();\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"Filter on rowKey:\" + rowKey + \", colKey: \" + colKey + \r\n        \", data: \" + data + \".  Result = \" + result);\r\n    }\r\n    return result;\r\n  }","id":9273,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterColumn(final Text rowKey, final Text colKey,\r\n    final byte[] data) {\r\n    changeFAR(this.filter.filterColumn(rowKey, colKey, data));\r\n    return filterAllRemaining();\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\r\n  public boolean filterRow(final SortedMap<Text, byte[]> columns) {\r\n    changeFAR(this.filter.filterRow(columns));\r\n    boolean result = filterAllRemaining();\r\n    if (LOG.isDebugEnabled()) {\r\n      LOG.debug(\"FilterNotNull on cols:\" + columns + \".  Result = \" + \r\n        result);\r\n    }\r\n    return result;\r\n  }","id":9274,"modified_method":"/** {@inheritDoc} */\r\n  public boolean filterRow(final SortedMap<Text, byte[]> columns) {\r\n    changeFAR(this.filter.filterRow(columns));\r\n    return filterAllRemaining();\r\n  }","commit_id":"eaa03f245b095b907f820323125cad63586de282","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\n    public ReportParameters getParameters(String reportId) {\n\n        ReportParameters reportParameters = new ReportParameters();\n        ArrayList<ReportIntParm> intParms;\n        ArrayList<ReportStringParm> stringParms;\n        ArrayList<ReportDateParm> dateParms;\n\n        JRParameter[] reportParms;\n\n        JasperReport jasperReport = null;\n\n        String sourceFileName = m_jasperReportConfigDao.getTemplateLocation(reportId);\n        if (sourceFileName != null) {\n            try {\n                jasperReport = JasperCompileManager.compileReport(System.getProperty(\"opennms.home\")\n                        + \"/etc/report-templates/\" + sourceFileName);\n            } catch (JRException e) {\n                log.error(\"unable to compile jasper report\", e);\n                // throw new ReportException(\"unable to compile jasperReport\",\n                // e);\n            }\n        }\n\n        reportParms = jasperReport.getParameters();\n\n        intParms = new ArrayList<ReportIntParm>();\n        reportParameters.setIntParms(intParms);\n        stringParms = new ArrayList<ReportStringParm>();\n        reportParameters.setStringParms(stringParms);\n        dateParms = new ArrayList<ReportDateParm>();\n        reportParameters.setDateParms(dateParms);\n\n        for (JRParameter reportParm : reportParms) {\n\n            if (reportParm.isSystemDefined() == false) {\n\n                if (reportParm.getValueClassName().equals(\"java.lang.String\")) {\n                    log.debug(\"adding a string parm name \"\n                            + reportParm.getName());\n                    ReportStringParm stringParm = new ReportStringParm();\n                    stringParm.setDisplayName(reportParm.getName());\n                    stringParm.setName(reportParm.getName());\n                    // stringParm.setInputType(strings[i].getInputType());\n                    stringParm.setValue(new String());\n                    stringParms.add(stringParm);\n                    continue;\n                }\n\n                if (reportParm.getValueClassName().equals(\"java.lang.Integer\")) {\n                    log.debug(\"adding a Integer parm name \"\n                            + reportParm.getName());\n                    ReportIntParm intParm = new ReportIntParm();\n                    intParm.setDisplayName(reportParm.getName());\n                    intParm.setName(reportParm.getName());\n                    // intParm.setInputType(integers[i].getInputType());\n                    intParm.setValue(new Integer(0));\n                    intParms.add(intParm);\n                    continue;\n                }\n\n                if (reportParm.getValueClassName().equals(\"java.util.Date\")) {\n                    log.debug(\"adding a java.util.Date parm name \"\n                            + reportParm.getName());\n                    ReportDateParm dateParm = new ReportDateParm();\n                    dateParm.setUseAbsoluteDate(false);\n                    dateParm.setDisplayName(reportParm.getName());\n                    dateParm.setName(reportParm.getName());\n                    dateParm.setCount(new Integer(1));\n                    dateParm.setInterval(\"day\");\n                    dateParm.setHours(0);\n                    dateParm.setMinutes(0);\n                    Calendar cal = Calendar.getInstance();\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\n                    cal.set(Calendar.MINUTE, 0);\n                    cal.set(Calendar.SECOND, 0);\n                    cal.set(Calendar.MILLISECOND, 0);\n                    dateParm.setValue(cal.getTime());\n                    dateParms.add(dateParm);\n                    continue;\n                }\n\n                if (reportParm.getValueClassName().equals(\"java.sql.Date\")) {\n                    log.debug(\"adding a java.sql.Date parm name \"\n                            + reportParm.getName());\n                    ReportDateParm dateParm = new ReportDateParm();\n                    dateParm.setUseAbsoluteDate(false);\n                    dateParm.setDisplayName(reportParm.getName());\n                    dateParm.setName(reportParm.getName());\n                    dateParm.setCount(new Integer(1));\n                    dateParm.setInterval(\"day\");\n                    dateParm.setHours(0);\n                    dateParm.setMinutes(0);\n                    Calendar cal = Calendar.getInstance();\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\n                    cal.set(Calendar.MINUTE, 0);\n                    cal.set(Calendar.SECOND, 0);\n                    cal.set(Calendar.MILLISECOND, 0);\n                    dateParm.setValue(cal.getTime());\n                    dateParms.add(dateParm);\n                    continue;\n                }\n\n                // throw new\n                // ReportException(\"Unsupported report parameter type \"\n                // + reportParm.getValueClassName());\n\n            }\n        }\n\n        return reportParameters;\n    }","id":9275,"modified_method":"/** {@inheritDoc} */\n    public ReportParameters getParameters(String reportId) {\n\n        ReportParameters reportParameters = new ReportParameters();\n        ArrayList<ReportIntParm> intParms;\n        ArrayList<ReportStringParm> stringParms;\n        ArrayList<ReportDateParm> dateParms;\n\n        JRParameter[] reportParms;\n\n        JasperReport jasperReport = null;\n\n        String sourceFileName = m_jasperReportConfigDao.getTemplateLocation(reportId);\n        if (sourceFileName != null) {\n            try {\n                jasperReport = JasperCompileManager.compileReport(System.getProperty(\"opennms.home\")\n                        + \"/etc/report-templates/\" + sourceFileName);\n            } catch (JRException e) {\n                log.error(\"unable to compile jasper report\", e);\n                // throw new ReportException(\"unable to compile jasperReport\",\n                // e);\n            }\n        }\n\n        reportParms = jasperReport.getParameters();\n\n        intParms = new ArrayList<ReportIntParm>();\n        reportParameters.setIntParms(intParms);\n        stringParms = new ArrayList<ReportStringParm>();\n        reportParameters.setStringParms(stringParms);\n        dateParms = new ArrayList<ReportDateParm>();\n        reportParameters.setDateParms(dateParms);\n\n        for (JRParameter reportParm : reportParms) {\n\n            if (reportParm.isSystemDefined() == false) {\n\n                if (reportParm.getValueClassName().equals(\"java.lang.String\")) {\n                    log.debug(\"adding a string parm name \"\n                            + reportParm.getName());\n                    ReportStringParm stringParm = new ReportStringParm();\n                    if (reportParm.getDescription() != null) {\n                        stringParm.setDisplayName(reportParm.getDescription());\n                    } else {\n                        stringParm.setDisplayName(reportParm.getName());\n                    }\n                    stringParm.setName(reportParm.getName());\n                    stringParm.setValue(new String());\n                    stringParms.add(stringParm);\n                    continue;\n                }\n\n                if (reportParm.getValueClassName().equals(\"java.lang.Integer\")) {\n                    log.debug(\"adding a Integer parm name \"\n                            + reportParm.getName());\n                    ReportIntParm intParm = new ReportIntParm();\n                    if (reportParm.getDescription() != null) {\n                        intParm.setDisplayName(reportParm.getDescription());\n                    } else {\n                        intParm.setDisplayName(reportParm.getName());\n                    }\n                    intParm.setName(reportParm.getName());\n                    intParm.setValue(new Integer(0));\n                    intParms.add(intParm);\n                    continue;\n                }\n\n                if (reportParm.getValueClassName().equals(\"java.util.Date\")) {\n                    log.debug(\"adding a java.util.Date parm name \"\n                            + reportParm.getName());\n                    ReportDateParm dateParm = new ReportDateParm();\n                    dateParm.setUseAbsoluteDate(false);\n                    if (reportParm.getDescription() != null) {\n                        dateParm.setDisplayName(reportParm.getDescription());\n                    } else {\n                        dateParm.setDisplayName(reportParm.getName());\n                    }\n                    dateParm.setName(reportParm.getName());\n                    dateParm.setCount(new Integer(1));\n                    dateParm.setInterval(\"day\");\n                    dateParm.setHours(0);\n                    dateParm.setMinutes(0);\n                    Calendar cal = Calendar.getInstance();\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\n                    cal.set(Calendar.MINUTE, 0);\n                    cal.set(Calendar.SECOND, 0);\n                    cal.set(Calendar.MILLISECOND, 0);\n                    dateParm.setValue(cal.getTime());\n                    dateParms.add(dateParm);\n                    continue;\n                }\n\n                if (reportParm.getValueClassName().equals(\"java.sql.Date\")) {\n                    log.debug(\"adding a java.sql.Date parm name \"\n                            + reportParm.getName());\n                    ReportDateParm dateParm = new ReportDateParm();\n                    dateParm.setUseAbsoluteDate(false);\n                    if (reportParm.getDescription() != null) {\n                        dateParm.setDisplayName(reportParm.getDescription());\n                    } else {\n                        dateParm.setDisplayName(reportParm.getName());\n                    }\n                    dateParm.setName(reportParm.getName());\n                    dateParm.setCount(new Integer(1));\n                    dateParm.setInterval(\"day\");\n                    dateParm.setHours(0);\n                    dateParm.setMinutes(0);\n                    Calendar cal = Calendar.getInstance();\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\n                    cal.set(Calendar.MINUTE, 0);\n                    cal.set(Calendar.SECOND, 0);\n                    cal.set(Calendar.MILLISECOND, 0);\n                    dateParm.setValue(cal.getTime());\n                    dateParms.add(dateParm);\n                    continue;\n                }\n\n                // throw new\n                // ReportException(\"Unsupported report parameter type \"\n                // + reportParm.getValueClassName());\n\n            }\n        }\n\n        return reportParameters;\n    }","commit_id":"690970d93fb3bff18f1ac62f91087bcc148be5a5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n\tpublic void testRunAndRender() {\n\t\tHashMap<String, Object> reportParms;\n\t\treportParms = new HashMap<String, Object>();\n\t\treportParms.put(\"stringParameter\", new String(\"report\"));\n\t\treportParms.put(\"integerParameter\", new Integer(1));\n\t\treportParms.put(\"dateParameter\", new java.util.Date());\n\t\tjava.util.Date date = new java.util.Date();\n\t\treportParms.put(\"dateParamter\", date);\n\t\treportParms.put(\"sqlDateParameter\", new java.util.Date(date.getTime()));\n\t\ttry {\n\t\t\tm_reportService.runAndRender(reportParms, REPORTID,\n\t\t\t\t\tReportFormat.PDF, new NullOutputStream());\n\t\t} catch (ReportException e) {\n\t\t\tAssert.fail(e.toString());\n\t\t}\n\n\t}","id":9276,"modified_method":"@Test\n\tpublic void testRunAndRender() {\n\t\tHashMap<String, Object> reportParms;\n\t\treportParms = new HashMap<String, Object>();\n\t\treportParms.put(\"stringParameter1\", new String(\"string1\"));\n\t        reportParms.put(\"stringParameter2\", new String(\"string2\"));\n\t\treportParms.put(\"integerParameter\", new Integer(1));\n\t\treportParms.put(\"dateParameter\", new java.util.Date());\n\t\tjava.util.Date date = new java.util.Date();\n\t\treportParms.put(\"dateParamter\", date);\n\t\treportParms.put(\"sqlDateParameter\", new java.util.Date(date.getTime()));\n\t\ttry {\n\t\t\tm_reportService.runAndRender(reportParms, REPORTID,\n\t\t\t\t\tReportFormat.PDF, new NullOutputStream());\n\t\t} catch (ReportException e) {\n\t\t\tAssert.fail(e.toString());\n\t\t}\n\n\t}","commit_id":"690970d93fb3bff18f1ac62f91087bcc148be5a5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n\tpublic void testGetParmeters() {\n\t\tReportParameters reportParameters = m_reportService\n\t\t\t\t.getParameters(REPORTID);\n\t\tAssert.assertNotNull(reportParameters);\n\t\tAssert.assertEquals(1, reportParameters.getIntParms().size());\n\t\tAssert.assertEquals(1, reportParameters.getStringParms().size());\n\t\tAssert.assertEquals(2, reportParameters.getDateParms().size());\n\t}","id":9277,"modified_method":"@Test\n\tpublic void testGetParmeters() {\n\t\tReportParameters reportParameters = m_reportService\n\t\t\t\t.getParameters(REPORTID);\n\t\tAssert.assertNotNull(reportParameters);\n\t\tAssert.assertEquals(1, reportParameters.getIntParms().size());\n\t\tAssert.assertEquals(2, reportParameters.getStringParms().size());\n\t\tAssert.assertEquals(2, reportParameters.getDateParms().size());\n\t}","commit_id":"690970d93fb3bff18f1ac62f91087bcc148be5a5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List ueiList = new ArrayList();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n\n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","id":9278,"modified_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n\n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"675234366581d90e7d0f98b2c4d8105e665f709a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void refreshServicePackages() {\n        Iterator serviceIterator = m_collectableServices.iterator();\n        while (serviceIterator.hasNext()) {\n            CollectableService thisService = (CollectableService) serviceIterator.next();\n            thisService.refreshPackage();\n        }\n    }","id":9279,"modified_method":"private void refreshServicePackages() {\n    \tfor (CollectableService thisService : m_collectableServices) {\n            thisService.refreshPackage();\n        }\n    }","commit_id":"675234366581d90e7d0f98b2c4d8105e665f709a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor.\n     */\n    public Collectd() {\n        super(LOG4J_CATEGORY);\n\n        m_collectableServices = Collections.synchronizedList(new LinkedList());\n    }","id":9280,"modified_method":"/**\n     * Constructor.\n     */\n    public Collectd() {\n        super(LOG4J_CATEGORY);\n\n        m_collectableServices = Collections.synchronizedList(new LinkedList<CollectableService>());\n    }","commit_id":"675234366581d90e7d0f98b2c4d8105e665f709a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if specified address/pkg pair is already represented in\n     * the collectable services list. False otherwise.\n     * \n     * @param iface\n     *            TODO\n     * @param spec\n     *            TODO\n     * @param svcName\n     *            TODO\n     */\n    private boolean alreadyScheduled(OnmsIpInterface iface,\n            CollectionSpecification spec) {\n        String ipAddress = iface.getIpAddress();\n        String svcName = spec.getServiceName();\n        String pkgName = spec.getPackageName();\n        StringBuffer sb;\n        boolean isScheduled = false;\n        \n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: determining if interface: \");\n            sb.append(iface);\n            sb.append(\" is already scheduled.\");\n        }\n        \n        synchronized (m_collectableServices) {\n            CollectableService cSvc = null;\n            Iterator iter = m_collectableServices.iterator();\n            while (iter.hasNext()) {\n                cSvc = (CollectableService) iter.next();\n\n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (addr.getHostAddress().equals(ipAddress)\n                        && cSvc.getPackageName().equals(pkgName)\n                        && cSvc.getServiceName().equals(svcName)) {\n                    isScheduled = true;\n                    break;\n                }\n            }\n        }\n\n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: interface \");\n            sb.append(iface);\n            sb.append(\"already scheduled check: \");\n            sb.append(isScheduled);\n        }\n        return isScheduled;\n    }","id":9281,"modified_method":"/**\n     * Returns true if specified address/pkg pair is already represented in\n     * the collectable services list. False otherwise.\n     * \n     * @param iface\n     *            TODO\n     * @param spec\n     *            TODO\n     * @param svcName\n     *            TODO\n     */\n    private boolean alreadyScheduled(OnmsIpInterface iface,\n            CollectionSpecification spec) {\n        String ipAddress = iface.getIpAddress();\n        String svcName = spec.getServiceName();\n        String pkgName = spec.getPackageName();\n        StringBuffer sb;\n        boolean isScheduled = false;\n        \n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: determining if interface: \");\n            sb.append(iface);\n            sb.append(\" is already scheduled.\");\n        }\n        \n        synchronized (m_collectableServices) {\n        \tfor (CollectableService cSvc : m_collectableServices) {\n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (addr.getHostAddress().equals(ipAddress)\n                        && cSvc.getPackageName().equals(pkgName)\n                        && cSvc.getServiceName().equals(svcName)) {\n                    isScheduled = true;\n                    break;\n                }\n            }\n        }\n\n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: interface \");\n            sb.append(iface);\n            sb.append(\"already scheduled check: \");\n            sb.append(isScheduled);\n        }\n        return isScheduled;\n    }","commit_id":"675234366581d90e7d0f98b2c4d8105e665f709a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void refreshServicePackages() {\n        Iterator serviceIterator = m_collectableServices.iterator();\n        while (serviceIterator.hasNext()) {\n            CollectableService thisService = (CollectableService) serviceIterator.next();\n            thisService.refreshPackage();\n        }\n    }","id":9282,"modified_method":"private void refreshServicePackages() {\n    \tfor (CollectableService thisService : m_collectableServices) {\n            thisService.refreshPackage();\n        }\n    }","commit_id":"749441c7cf937d4733766f514a3a79034f46f9f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructor.\n     */\n    public Collectd() {\n        super(LOG4J_CATEGORY);\n\n        m_collectableServices = Collections.synchronizedList(new LinkedList());\n    }","id":9283,"modified_method":"/**\n     * Constructor.\n     */\n    public Collectd() {\n        super(LOG4J_CATEGORY);\n\n        m_collectableServices = Collections.synchronizedList(new LinkedList<CollectableService>());\n    }","commit_id":"749441c7cf937d4733766f514a3a79034f46f9f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns true if specified address/pkg pair is already represented in\n     * the collectable services list. False otherwise.\n     * \n     * @param iface\n     *            TODO\n     * @param spec\n     *            TODO\n     * @param svcName\n     *            TODO\n     */\n    private boolean alreadyScheduled(OnmsIpInterface iface,\n            CollectionSpecification spec) {\n        String ipAddress = iface.getIpAddress();\n        String svcName = spec.getServiceName();\n        String pkgName = spec.getPackageName();\n        StringBuffer sb;\n        boolean isScheduled = false;\n        \n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: determining if interface: \");\n            sb.append(iface);\n            sb.append(\" is already scheduled.\");\n        }\n        \n        synchronized (m_collectableServices) {\n            CollectableService cSvc = null;\n            Iterator iter = m_collectableServices.iterator();\n            while (iter.hasNext()) {\n                cSvc = (CollectableService) iter.next();\n\n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (addr.getHostAddress().equals(ipAddress)\n                        && cSvc.getPackageName().equals(pkgName)\n                        && cSvc.getServiceName().equals(svcName)) {\n                    isScheduled = true;\n                    break;\n                }\n            }\n        }\n\n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: interface \");\n            sb.append(iface);\n            sb.append(\"already scheduled check: \");\n            sb.append(isScheduled);\n        }\n        return isScheduled;\n    }","id":9284,"modified_method":"/**\n     * Returns true if specified address/pkg pair is already represented in\n     * the collectable services list. False otherwise.\n     * \n     * @param iface\n     *            TODO\n     * @param spec\n     *            TODO\n     * @param svcName\n     *            TODO\n     */\n    private boolean alreadyScheduled(OnmsIpInterface iface,\n            CollectionSpecification spec) {\n        String ipAddress = iface.getIpAddress();\n        String svcName = spec.getServiceName();\n        String pkgName = spec.getPackageName();\n        StringBuffer sb;\n        boolean isScheduled = false;\n        \n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: determining if interface: \");\n            sb.append(iface);\n            sb.append(\" is already scheduled.\");\n        }\n        \n        synchronized (m_collectableServices) {\n        \tfor (CollectableService cSvc : m_collectableServices) {\n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (addr.getHostAddress().equals(ipAddress)\n                        && cSvc.getPackageName().equals(pkgName)\n                        && cSvc.getServiceName().equals(svcName)) {\n                    isScheduled = true;\n                    break;\n                }\n            }\n        }\n\n        if (log().isDebugEnabled()) {\n            sb = new StringBuffer();\n            sb.append(\"alreadyScheduled: interface \");\n            sb.append(iface);\n            sb.append(\"already scheduled check: \");\n            sb.append(isScheduled);\n        }\n        return isScheduled;\n    }","commit_id":"749441c7cf937d4733766f514a3a79034f46f9f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List ueiList = new ArrayList();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n\n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","id":9285,"modified_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n\n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"749441c7cf937d4733766f514a3a79034f46f9f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        ModelAndView modelAndView = new ModelAndView(\"report/database/batchList\"); \n        PagedListHolder pagedListHolder = new PagedListHolder(m_reportListService.getAll());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(request, \"p\", 0);\n        pagedListHolder.setPage(page); \n        modelAndView.addObject(\"pagedListHolder\", pagedListHolder);  \n\n        return modelAndView;\n        \n    }","id":9286,"modified_method":"/** {@inheritDoc} */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        ModelAndView modelAndView = new ModelAndView(\"report/database/batchList\"); \n        PagedListHolder<DatabaseReportDescription> pagedListHolder = new PagedListHolder<DatabaseReportDescription>(m_reportListService.getAll());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(request, \"p\", 0);\n        pagedListHolder.setPage(page); \n        modelAndView.addObject(\"pagedListHolder\", pagedListHolder);  \n\n        return modelAndView;\n        \n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>Constructor for CalendarEntry.<\/p>\n     *\n     * @param start a {@link java.util.Date} object.\n     * @param end a {@link java.util.Date} object.\n     * @param descr a {@link java.lang.String} object.\n     * @param labels a {@link java.util.List} object.\n     */\n    public CalendarEntry(Date start, Date end, String descr, List labels) {\n        m_start = start;\n        m_end = end;\n        m_descr = descr;\n        m_labels = labels;\n    }","id":9287,"modified_method":"/**\n     * <p>Constructor for CalendarEntry.<\/p>\n     *\n     * @param start a {@link java.util.Date} object.\n     * @param end a {@link java.util.Date} object.\n     * @param descr a {@link java.lang.String} object.\n     * @param labels a {@link java.util.List} object.\n     */\n    public CalendarEntry(Date start, Date end, String descr, List<Owner> labels) {\n        m_start = start;\n        m_end = end;\n        m_descr = descr;\n        m_labels = labels;\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the availability percentage for all managed services on the given\n     * nodes from the given start time until the given end time. If there are no\n     * managed services on these nodes, then a value of -1 is returned.\n     *\n     * @param nodeIds a {@link java.util.Set} object.\n     * @param start a {@link java.util.Date} object.\n     * @param end a {@link java.util.Date} object.\n     * @return a {@link java.util.Map} object.\n     * @throws java.sql.SQLException if any.\n     */\n    public Map<Integer, Double> getNodeAvailability(Set nodeIds, Date start, Date end) throws SQLException {\n    \tif(nodeIds==null || nodeIds.size()==0){\n    \t\tthrow new IllegalArgumentException(\"Cannot take nodeIds null or with length 0.\");\n    \t}\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (end.before(start)) {\n            throw new IllegalArgumentException(\"Cannot have an end time before the start time.\");\n        }\n\n        if (end.equals(start)) {\n            throw new IllegalArgumentException(\"Cannot have an end time equal to the start time.\");\n        }\n\n        double avail = -1;\n        int nodeid = 0;\n        Map<Integer, Double> retMap = new TreeMap<Integer, Double>();\n\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            Connection conn = Vault.getDbConnection();\n            d.watch(conn);\n        \tStringBuffer sb = new StringBuffer(\"select nodeid, getManagePercentAvailNodeWindow(nodeid, ?, ?)  from node where nodeid in (\");\n        \tIterator it = nodeIds.iterator();\n        \twhile (it.hasNext()){\n        \t\tsb.append(it.next());\n        \t\tif (it.hasNext()) {\n        \t\t\tsb.append(\", \");\n        \t\t}\n        \t}\n        \tsb.append(\")\");\n            PreparedStatement stmt = conn.prepareStatement(sb.toString());\n            d.watch(stmt);\n            \n            // yes, these are supposed to be backwards, the end time first\n            stmt.setTimestamp(1, new Timestamp(end.getTime()));\n            stmt.setTimestamp(2, new Timestamp(start.getTime()));\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n\n            while (rs.next()) {\n            \tnodeid = rs.getInt(1);\n                avail = rs.getDouble(2);\n                retMap.put(new Integer(nodeid), new Double(avail));\n            }\n        } finally {\n            d.cleanUp();\n        }\n\n        return retMap;\n    }","id":9288,"modified_method":"/**\n     * Return the availability percentage for all managed services on the given\n     * nodes from the given start time until the given end time. If there are no\n     * managed services on these nodes, then a value of -1 is returned.\n     *\n     * @param nodeIds a {@link java.util.Set} object.\n     * @param start a {@link java.util.Date} object.\n     * @param end a {@link java.util.Date} object.\n     * @return a {@link java.util.Map} object.\n     * @throws java.sql.SQLException if any.\n     */\n    public Map<Integer, Double> getNodeAvailability(Set<Integer> nodeIds, Date start, Date end) throws SQLException {\n    \tif(nodeIds==null || nodeIds.size()==0){\n    \t\tthrow new IllegalArgumentException(\"Cannot take nodeIds null or with length 0.\");\n    \t}\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (end.before(start)) {\n            throw new IllegalArgumentException(\"Cannot have an end time before the start time.\");\n        }\n\n        if (end.equals(start)) {\n            throw new IllegalArgumentException(\"Cannot have an end time equal to the start time.\");\n        }\n\n        double avail = -1;\n        int nodeid = 0;\n        Map<Integer, Double> retMap = new TreeMap<Integer, Double>();\n\n        final DBUtils d = new DBUtils(getClass());\n        try {\n            Connection conn = Vault.getDbConnection();\n            d.watch(conn);\n        \tStringBuffer sb = new StringBuffer(\"select nodeid, getManagePercentAvailNodeWindow(nodeid, ?, ?)  from node where nodeid in (\");\n        \tIterator<Integer> it = nodeIds.iterator();\n        \twhile (it.hasNext()){\n        \t\tsb.append(it.next());\n        \t\tif (it.hasNext()) {\n        \t\t\tsb.append(\", \");\n        \t\t}\n        \t}\n        \tsb.append(\")\");\n            PreparedStatement stmt = conn.prepareStatement(sb.toString());\n            d.watch(stmt);\n            \n            // yes, these are supposed to be backwards, the end time first\n            stmt.setTimestamp(1, new Timestamp(end.getTime()));\n            stmt.setTimestamp(2, new Timestamp(start.getTime()));\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n\n            while (rs.next()) {\n            \tnodeid = rs.getInt(1);\n                avail = rs.getDouble(2);\n                retMap.put(new Integer(nodeid), new Double(avail));\n            }\n        } finally {\n            d.cleanUp();\n        }\n\n        return retMap;\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Return the availability percentage for all managed services on the given\n     * nodes for the last 24 hours. If there are no managed services on these\n     * nodes, then a value of -1 is returned.\n     *\n     * @param nodeIds a {@link java.util.Set} object.\n     * @return a {@link java.util.Map} object.\n     * @throws java.sql.SQLException if any.\n     */\n    public Map<Integer, Double> getNodeAvailability(Set nodeIds) throws SQLException {\n        Calendar cal = new GregorianCalendar();\n        Date now = cal.getTime();\n        cal.add(Calendar.DATE, -1);\n        Date yesterday = cal.getTime();\n\n        return getNodeAvailability(nodeIds, yesterday, now);\n    }","id":9289,"modified_method":"/**\n     * Return the availability percentage for all managed services on the given\n     * nodes for the last 24 hours. If there are no managed services on these\n     * nodes, then a value of -1 is returned.\n     *\n     * @param nodeIds a {@link java.util.Set} object.\n     * @return a {@link java.util.Map} object.\n     * @throws java.sql.SQLException if any.\n     */\n    public Map<Integer, Double> getNodeAvailability(Set<Integer> nodeIds) throws SQLException {\n        Calendar cal = new GregorianCalendar();\n        Date now = cal.getTime();\n        cal.add(Calendar.DATE, -1);\n        Date yesterday = cal.getTime();\n\n        return getNodeAvailability(nodeIds, yesterday, now);\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        ModelAndView modelAndView = new ModelAndView(\"report/database/list\"); \n        PagedListHolder pagedListHolder = new PagedListHolder(m_reportListService.getAll());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(request, \"p\", 0);\n        pagedListHolder.setPage(page); \n        modelAndView.addObject(\"pagedListHolder\", pagedListHolder);  \n\n        return modelAndView;\n        \n    }","id":9290,"modified_method":"/** {@inheritDoc} */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        ModelAndView modelAndView = new ModelAndView(\"report/database/list\"); \n        PagedListHolder<DatabaseReportDescription> pagedListHolder = new PagedListHolder<DatabaseReportDescription>(m_reportListService.getAll());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(request, \"p\", 0);\n        pagedListHolder.setPage(page); \n        modelAndView.addObject(\"pagedListHolder\", pagedListHolder);  \n\n        return modelAndView;\n        \n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * Use the filter parameters to filter out the table.\n     */\n    public boolean evaluate(Object bean)\n    {\n        boolean match = false;\n\n        try\n        {\n            Iterator iter = model.getColumnHandler().getColumns().iterator();\n\n            while (iter.hasNext())\n            {\n                Column column = (Column) iter.next();\n                String alias = column.getAlias();\n                String filterValue = model.getLimit().getFilterSet()\n                                          .getFilterValue(alias);\n\n                if (StringUtils.isEmpty(filterValue))\n                {\n                    continue;\n                }\n\n                String property = column.getProperty();\n                Object value = PropertyUtils.getProperty(bean, property);\n\n                if (value == null)\n                {\n                    continue;\n                }\n\n                if (column.isDate())\n                {\n                    Locale locale = model.getLocale();\n                    value = ExtremeUtils.formatDate(column.getParse(),\n                            column.getFormat(), value, locale);\n                }\n                else if (column.isCurrency())\n                {\n                    Locale locale = model.getLocale();\n                    value = ExtremeUtils.formatNumber(column.getFormat(),\n                            value, locale);\n                }\n\n                if (!isSearchMatch(value, filterValue, column.isDate(),\n                            column.getFormat(), model.getLocale()))\n                {\n                    match = false; // as soon as fail just short circuit\n\n                    break;\n                }\n\n                match = true;\n            }\n        }\n        catch (Exception e)\n        {\n            logger.error(\"FilterPredicate.evaluate() had problems\", e);\n        }\n\n        return match;\n    }","id":9291,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * Use the filter parameters to filter out the table.\n     */\n    public boolean evaluate(Object bean)\n    {\n        boolean match = false;\n\n        try\n        {\n            Iterator<Column> iter = model.getColumnHandler().getColumns().iterator();\n\n            while (iter.hasNext())\n            {\n                Column column = iter.next();\n                String alias = column.getAlias();\n                String filterValue = model.getLimit().getFilterSet()\n                                          .getFilterValue(alias);\n\n                if (StringUtils.isEmpty(filterValue))\n                {\n                    continue;\n                }\n\n                String property = column.getProperty();\n                Object value = PropertyUtils.getProperty(bean, property);\n\n                if (value == null)\n                {\n                    continue;\n                }\n\n                if (column.isDate())\n                {\n                    Locale locale = model.getLocale();\n                    value = ExtremeUtils.formatDate(column.getParse(),\n                            column.getFormat(), value, locale);\n                }\n                else if (column.isCurrency())\n                {\n                    Locale locale = model.getLocale();\n                    value = ExtremeUtils.formatNumber(column.getFormat(),\n                            value, locale);\n                }\n\n                if (!isSearchMatch(value, filterValue, column.isDate(),\n                            column.getFormat(), model.getLocale()))\n                {\n                    match = false; // as soon as fail just short circuit\n\n                    break;\n                }\n\n                match = true;\n            }\n        }\n        catch (Exception e)\n        {\n            logger.error(\"FilterPredicate.evaluate() had problems\", e);\n        }\n\n        return match;\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>findAll<\/p>\n\t *\n\t * @return a {@link java.util.Collection} object.\n\t */\n\tpublic Collection<Category> findAll() {\n\t\t\n\t\tList<Category> catList = new ArrayList<Category>();\n\t\tCatinfo catInfo = CategoryFactory.getInstance().getConfig();\n\t\tList catGroupList = catInfo.getCategorygroupCollection();\n\t\tif (catGroupList != null) {\n\t\t\tIterator catIter = catGroupList.iterator();\n\t\t\twhile(catIter.hasNext()){\n\t\t\t\tCategorygroup cg = (Categorygroup)catIter.next();\n\t\t\t\tCategories cats = cg.getCategories();\n\t\t\t\tCategory[] categories = cats.getCategory();\n\t\t\t\tint i = 0;\n\t\t\t\tfor (i = 0; i < categories.length; i++) {\n\t\t\t\t\tcatList.add(categories[i]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn catList;\t\t\t\t\n\t}","id":9292,"modified_method":"/**\n\t * <p>findAll<\/p>\n\t *\n\t * @return a {@link java.util.Collection} object.\n\t */\n\tpublic Collection<Category> findAll() {\n\t\t\n\t\tList<Category> catList = new ArrayList<Category>();\n\t\tCatinfo catInfo = CategoryFactory.getInstance().getConfig();\n\t\tList<Categorygroup> catGroupList = catInfo.getCategorygroupCollection();\n\t\tif (catGroupList != null) {\n\t\t\tIterator<Categorygroup> catIter = catGroupList.iterator();\n\t\t\twhile(catIter.hasNext()){\n\t\t\t\tCategorygroup cg = catIter.next();\n\t\t\t\tCategories cats = cg.getCategories();\n\t\t\t\tCategory[] categories = cats.getCategory();\n\t\t\t\tint i = 0;\n\t\t\t\tfor (i = 0; i < categories.length; i++) {\n\t\t\t\t\tcatList.add(categories[i]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn catList;\t\t\t\t\n\t}","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>parseXML<\/p>\n     *\n     * @param reader a {@link java.io.Reader} object.\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     */\n    @Deprecated\n    protected void parseXML(Reader reader) throws MarshalException, ValidationException {\n        allPaths = CastorUtils.unmarshal(DestinationPaths.class, reader);\n        oldHeader = allPaths.getHeader();\n        initializeDestinationPaths();\n    }","id":9293,"modified_method":"/**\n     * <p>parseXML<\/p>\n     *\n     * @param reader a {@link java.io.Reader} object.\n     * @throws org.exolab.castor.xml.MarshalException if any.\n     * @throws org.exolab.castor.xml.ValidationException if any.\n     */\n    protected void parseXML(Reader reader) throws MarshalException, ValidationException {\n        allPaths = CastorUtils.unmarshal(DestinationPaths.class, reader, CastorUtils.PRESERVE_WHITESPACE);\n        oldHeader = allPaths.getHeader();\n        initializeDestinationPaths();\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    protected Map<String, Object> referenceData(HttpServletRequest req) throws Exception {\n        Map<String, Object> data = new HashMap<String, Object>();\n        List<ReportCatalogEntry> reportCatalog = m_reportStoreService.getAll();\n        Map<String, Object> formatMap = m_reportStoreService.getFormatMap();\n        PagedListHolder pagedListHolder = new PagedListHolder(reportCatalog);\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(req, \"p\", 0);\n        pagedListHolder.setPage(page); \n        data.put(\"formatMap\", formatMap);\n        data.put(\"pagedListHolder\", pagedListHolder);\n        return data;\n\n    }","id":9294,"modified_method":"/** {@inheritDoc} */\n    @Override\n    protected Map<String, Object> referenceData(HttpServletRequest req) throws Exception {\n        Map<String, Object> data = new HashMap<String, Object>();\n        List<ReportCatalogEntry> reportCatalog = m_reportStoreService.getAll();\n        Map<String, Object> formatMap = m_reportStoreService.getFormatMap();\n        PagedListHolder<ReportCatalogEntry> pagedListHolder = new PagedListHolder<ReportCatalogEntry>(reportCatalog);\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(req, \"p\", 0);\n        pagedListHolder.setPage(page); \n        data.put(\"formatMap\", formatMap);\n        data.put(\"pagedListHolder\", pagedListHolder);\n        return data;\n\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    protected Map<String, Object> referenceData(HttpServletRequest req) throws Exception {\n        Map<String, Object> data = new HashMap<String, Object>();\n        PagedListHolder pagedListHolder = new PagedListHolder(m_reportSchedulerService.getTriggerDescriptions());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(req, \"p\", 0);\n        pagedListHolder.setPage(page); \n        data.put(\"pagedListHolder\", pagedListHolder);\n        return data;\n\n    }","id":9295,"modified_method":"/** {@inheritDoc} */\n    @Override\n    protected Map<String, Object> referenceData(HttpServletRequest req) throws Exception {\n        Map<String, Object> data = new HashMap<String, Object>();\n        PagedListHolder<TriggerDescription> pagedListHolder = new PagedListHolder<TriggerDescription>(m_reportSchedulerService.getTriggerDescriptions());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(req, \"p\", 0);\n        pagedListHolder.setPage(page); \n        data.put(\"pagedListHolder\", pagedListHolder);\n        return data;\n\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        ModelAndView modelAndView = new ModelAndView(\"report/database/onlineList\"); \n        PagedListHolder pagedListHolder = new PagedListHolder(m_reportListService.getAllOnline());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(request, \"p\", 0);\n        pagedListHolder.setPage(page); \n        modelAndView.addObject(\"pagedListHolder\", pagedListHolder);  \n\n        return modelAndView;\n        \n    }","id":9296,"modified_method":"/** {@inheritDoc} */\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request,\n            HttpServletResponse response) throws Exception {\n        ModelAndView modelAndView = new ModelAndView(\"report/database/onlineList\"); \n        PagedListHolder<DatabaseReportDescription> pagedListHolder = new PagedListHolder<DatabaseReportDescription>(m_reportListService.getAllOnline());\n        pagedListHolder.setPageSize(m_pageSize);\n        int page = ServletRequestUtils.getIntParameter(request, \"p\", 0);\n        pagedListHolder.setPage(page); \n        modelAndView.addObject(\"pagedListHolder\", pagedListHolder);  \n\n        return modelAndView;\n        \n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>refreshServicePackages<\/p>\n     */\n    public void refreshServicePackages() {\n\tIterator serviceIterator=m_thresholdableServices.iterator();\n\twhile(serviceIterator.hasNext()) {\n\t\tThresholdableService thisService=(ThresholdableService)serviceIterator.next();\n\t\tthisService.refreshPackage();\n\t}\n    }","id":9297,"modified_method":"/**\n     * <p>refreshServicePackages<\/p>\n     */\n    public void refreshServicePackages() {\n\tfor (ThresholdableService thisService : m_thresholdableServices) {\n\t\tthisService.refreshPackage();\n\t}\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for scheduling the specified\n     * node/address/svcname tuple for thresholding.\n     * \n     * @param nodeId\n     *            Node id\n     * @param ipAddress\n     *            IP address\n     * @param svcName\n     *            Service name\n     * @param existing\n     *            True if called by scheduleExistingInterfaces(), false\n     *            otheriwse\n     */\n    void scheduleService(int nodeId, String ipAddress, String svcName, boolean existing) {\n        Enumeration epkgs = m_threshdConfig.getConfiguration().enumeratePackage();\n        \n        // Compare interface/service pair against each threshd package\n        // For each match, create new ThresholdableService object and\n        // schedule it for collection\n        //\n        while (epkgs.hasMoreElements()) {\n            org.opennms.netmgt.config.threshd.Package pkg = (org.opennms.netmgt.config.threshd.Package) epkgs.nextElement();\n\n            // Make certain the the current service is in the package\n            // and enabled!\n            //\n            if (!m_threshdConfig.serviceInPackageAndEnabled(svcName, pkg)) {\n                if (log().isDebugEnabled())\n                    log().debug(\"scheduleService: address/service: \" + ipAddress + \"/\" + svcName + \" not scheduled, service is not enabled or does not exist in package: \" + pkg.getName());\n                continue;\n            }\n\n            // Is the interface in the package?\n            //\n            log().debug(\"scheduleService: checking ipaddress \" + ipAddress + \" for inclusion in pkg \" + pkg.getName());\n            boolean foundInPkg = m_threshdConfig.interfaceInPackage(ipAddress, pkg);\n            if (!foundInPkg && existing == false) {\n                // The interface might be a newly added one, rebuild the package\n                // to ipList mapping and again to verify if the interface is in\n                // the package.\n                m_threshdConfig.rebuildPackageIpListMap();\n                foundInPkg = m_threshdConfig.interfaceInPackage(ipAddress, pkg);\n            }\n            if (!foundInPkg) {\n                if (log().isDebugEnabled())\n                    log().debug(\"scheduleInterface: address/service: \" + ipAddress + \"/\" + svcName + \" not scheduled, interface does not belong to package: \" + pkg.getName());\n                continue;\n            }\n\n            log().debug(\"scheduleService: ipaddress \" + ipAddress + \" IS in pkg \" + pkg.getName());\n\n            if (existing == false) {\n                // It is possible that both a nodeGainedService and a\n                // primarySnmpInterfaceChanged\n                // event are generated for an interface during a rescan. To\n                // handle\n                // this scenario we must verify that the ipAddress/pkg pair\n                // identified by\n                // this event does not already exist in the thresholdable\n                // services list.\n                //\n                if (alreadyScheduled(ipAddress, pkg.getName())) {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"scheduleService: ipAddr/pkgName \" + ipAddress + \"/\" + pkg.getName() + \" already in thresholdable service list, skipping.\");\n                    }\n                    continue;\n                }\n            }\n\n            try {\n                // Criteria checks have all passed. The interface/service pair\n                // can be scheduled.\n                //\n                ThresholdableService tSvc = null;\n\n                // Create a new SnmpThresholder object representing this node,\n                // interface,\n                // service and package pairing\n                //\n                tSvc = new ThresholdableService(this, nodeId, InetAddress.getByName(ipAddress), svcName, pkg);\n\n                // Initialize the thresholder with the service.\n                //\n                ServiceThresholder thresholder = this.getServiceThresholder(svcName);\n                if (thresholder == null) {\n                    // no thresholder exists for this service so go on to the next one\n                    log().warn(\"Unable to find a Thresholder for service \"+svcName+\"! But it is configured for Thresholding!\");\n                    continue;\n                }\n                thresholder.initialize(tSvc, tSvc.getPropertyMap());\n\n                // Add new service to the thresholdable service list.\n                //\n                m_thresholdableServices.add(tSvc);\n\n                // Schedule the service for threshold checking\n                //\n                // NOTE: Service will be scheduled at the configured\n                // interval (default is 5 minutes). This should give\n                // the collector a chance to update the RRD file so\n                // there is data available to be fetched.\n                m_scheduler.schedule(tSvc, tSvc.getInterval());\n\n                if (log().isDebugEnabled())\n                    log().debug(\"scheduleService: \" + nodeId + \"/\" + ipAddress + \" scheduled for \" + svcName + \" threshold checking\");\n            } catch (UnknownHostException ex) {\n                log().error(\"scheduleService: Failed to schedule interface \" + ipAddress + \" for service \" + svcName + \", illegal address\", ex);\n            } catch (RuntimeException rE) {\n                log().warn(\"scheduleService: Unable to schedule \" + ipAddress + \" for service \" + svcName + \", reason: \" + rE.getMessage(), rE);\n            } catch (Throwable t) {\n                log().error(\"scheduleService: Uncaught exception, failed to schedule interface \" + ipAddress + \" for service \" + svcName, t);\n            }\n        } // end while more packages exist\n    }","id":9298,"modified_method":"/**\n     * This method is responsible for scheduling the specified\n     * node/address/svcname tuple for thresholding.\n     * \n     * @param nodeId\n     *            Node id\n     * @param ipAddress\n     *            IP address\n     * @param svcName\n     *            Service name\n     * @param existing\n     *            True if called by scheduleExistingInterfaces(), false\n     *            otheriwse\n     */\n    void scheduleService(int nodeId, String ipAddress, String svcName, boolean existing) {\n        Enumeration<org.opennms.netmgt.config.threshd.Package> epkgs = m_threshdConfig.getConfiguration().enumeratePackage();\n        \n        // Compare interface/service pair against each threshd package\n        // For each match, create new ThresholdableService object and\n        // schedule it for collection\n        //\n        while (epkgs.hasMoreElements()) {\n            org.opennms.netmgt.config.threshd.Package pkg = epkgs.nextElement();\n\n            // Make certain the the current service is in the package\n            // and enabled!\n            //\n            if (!m_threshdConfig.serviceInPackageAndEnabled(svcName, pkg)) {\n                if (log().isDebugEnabled())\n                    log().debug(\"scheduleService: address/service: \" + ipAddress + \"/\" + svcName + \" not scheduled, service is not enabled or does not exist in package: \" + pkg.getName());\n                continue;\n            }\n\n            // Is the interface in the package?\n            //\n            log().debug(\"scheduleService: checking ipaddress \" + ipAddress + \" for inclusion in pkg \" + pkg.getName());\n            boolean foundInPkg = m_threshdConfig.interfaceInPackage(ipAddress, pkg);\n            if (!foundInPkg && existing == false) {\n                // The interface might be a newly added one, rebuild the package\n                // to ipList mapping and again to verify if the interface is in\n                // the package.\n                m_threshdConfig.rebuildPackageIpListMap();\n                foundInPkg = m_threshdConfig.interfaceInPackage(ipAddress, pkg);\n            }\n            if (!foundInPkg) {\n                if (log().isDebugEnabled())\n                    log().debug(\"scheduleInterface: address/service: \" + ipAddress + \"/\" + svcName + \" not scheduled, interface does not belong to package: \" + pkg.getName());\n                continue;\n            }\n\n            log().debug(\"scheduleService: ipaddress \" + ipAddress + \" IS in pkg \" + pkg.getName());\n\n            if (existing == false) {\n                // It is possible that both a nodeGainedService and a\n                // primarySnmpInterfaceChanged\n                // event are generated for an interface during a rescan. To\n                // handle\n                // this scenario we must verify that the ipAddress/pkg pair\n                // identified by\n                // this event does not already exist in the thresholdable\n                // services list.\n                //\n                if (alreadyScheduled(ipAddress, pkg.getName())) {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"scheduleService: ipAddr/pkgName \" + ipAddress + \"/\" + pkg.getName() + \" already in thresholdable service list, skipping.\");\n                    }\n                    continue;\n                }\n            }\n\n            try {\n                // Criteria checks have all passed. The interface/service pair\n                // can be scheduled.\n                //\n                ThresholdableService tSvc = null;\n\n                // Create a new SnmpThresholder object representing this node,\n                // interface,\n                // service and package pairing\n                //\n                tSvc = new ThresholdableService(this, nodeId, InetAddress.getByName(ipAddress), svcName, pkg);\n\n                // Initialize the thresholder with the service.\n                //\n                ServiceThresholder thresholder = this.getServiceThresholder(svcName);\n                if (thresholder == null) {\n                    // no thresholder exists for this service so go on to the next one\n                    log().warn(\"Unable to find a Thresholder for service \"+svcName+\"! But it is configured for Thresholding!\");\n                    continue;\n                }\n                thresholder.initialize(tSvc, tSvc.getPropertyMap());\n\n                // Add new service to the thresholdable service list.\n                //\n                m_thresholdableServices.add(tSvc);\n\n                // Schedule the service for threshold checking\n                //\n                // NOTE: Service will be scheduled at the configured\n                // interval (default is 5 minutes). This should give\n                // the collector a chance to update the RRD file so\n                // there is data available to be fetched.\n                m_scheduler.schedule(tSvc, tSvc.getInterval());\n\n                if (log().isDebugEnabled())\n                    log().debug(\"scheduleService: \" + nodeId + \"/\" + ipAddress + \" scheduled for \" + svcName + \" threshold checking\");\n            } catch (UnknownHostException ex) {\n                log().error(\"scheduleService: Failed to schedule interface \" + ipAddress + \" for service \" + svcName + \", illegal address\", ex);\n            } catch (RuntimeException rE) {\n                log().warn(\"scheduleService: Unable to schedule \" + ipAddress + \" for service \" + svcName + \", reason: \" + rE.getMessage(), rE);\n            } catch (Throwable t) {\n                log().error(\"scheduleService: Uncaught exception, failed to schedule interface \" + ipAddress + \" for service \" + svcName, t);\n            }\n        } // end while more packages exist\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void initializeThresholders() {\n        Enumeration eiter = m_threshdConfig.getConfiguration().enumerateThresholder();\n        while (eiter.hasMoreElements()) {\n            Thresholder thresholder = (Thresholder) eiter.nextElement();\n            try {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"start: Loading thresholder \" + thresholder.getService() + \", classname \" + thresholder.getClassName());\n                }\n                Class tc = Class.forName(thresholder.getClassName());\n                ServiceThresholder st = (ServiceThresholder) tc.newInstance();\n\n                // Attempt to initialize the service thresholder\n                //\n\n                // Store service name in map keyed by \"svcName\"\n                Map<String, String> properties = new HashMap<String, String>();\n                properties.put(\"svcName\", thresholder.getService());\n\n                st.initialize(properties);\n\n                m_svcThresholders.put(thresholder.getService(), st);\n            } catch (Throwable t) {\n                log().warn(\"start: Failed to load thresholder \" + thresholder.getClassName() + \" for service \" + thresholder.getService(), t);\n            }\n        }\n    }","id":9299,"modified_method":"private void initializeThresholders() {\n        Enumeration<Thresholder> eiter = m_threshdConfig.getConfiguration().enumerateThresholder();\n        while (eiter.hasMoreElements()) {\n            Thresholder thresholder = eiter.nextElement();\n            try {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"start: Loading thresholder \" + thresholder.getService() + \", classname \" + thresholder.getClassName());\n                }\n                Class tc = Class.forName(thresholder.getClassName());\n                ServiceThresholder st = (ServiceThresholder) tc.newInstance();\n\n                // Attempt to initialize the service thresholder\n                //\n\n                // Store service name in map keyed by \"svcName\"\n                Map<String, String> properties = new HashMap<String, String>();\n                properties.put(\"svcName\", thresholder.getService());\n\n                st.initialize(properties);\n\n                m_svcThresholders.put(thresholder.getService(), st);\n            } catch (Throwable t) {\n                log().warn(\"start: Failed to load thresholder \" + thresholder.getClassName() + \" for service \" + thresholder.getService(), t);\n            }\n        }\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * Collect data, via XMP, from a particular agent EventProxy is\n     *       used to send opennms events into the system in case a\n     *       collection fails or if a system is back working again after a\n     *       failure (suceed event).  But otherwise, no events sent if\n     *       collection succeeds.  Collect is called once per agent per\n     *       collection cycle.  Parameters are a map of String Key/String\n     *       Value passed in.  Keys come from collectd config\n     */\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, \n            Map<String, String> parameters)\n    {\n        XmpCollectionSet collectionSet;\n        XmpSession session;\n        long oldUptime;\n        int i;\n        XmpCollection collection;\n        XmpCollectionResource scalarResource;\n\n        log().debug(\"collect agent \"+agent);\n\n        oldUptime = 0;\n        \n        // First go to the peer factory\n        XmpAgentConfig peerConfig = XmpPeerFactory.getInstance().getAgentConfig(agent.getInetAddress());\n        authenUser = peerConfig.getAuthenUser();\n        timeout = (int)peerConfig.getTimeout();\n        retries = peerConfig.getRetry();\n        xmpPort = peerConfig.getPort();\n\n        if (parameters.get(\"authenUser\") != null)\n            authenUser = (String)parameters.get(\"authenUser\");\n\n        if (parameters.get(\"timeout\") != null) {\n            timeout = Integer.valueOf(parameters.get(\"timeout\"));\n        }\n        \n        if (parameters.get(\"retry\") != null) {\n            retries = Integer.valueOf(parameters.get(\"retries\"));\n        }\n        parameters.get(\"collection\");\n\n        if (parameters.get(\"port\") != null) {\n            xmpPort = Integer.valueOf((String)parameters.get(\"port\"));\n        }\n\n        //log().debug(\"collect got parameters for \"+agent);\n\n        String collectionName = parameters.get(\"collection\");\n\n        //log().debug(\"XMP collection name \"+collectionName);\n\n        // collectionName tells us what set of data to get \n        // this would/will come from xmp-datacollection.xml\n        if (collectionName == null) {\n            // log this!\n            log().warn(\"collect found no collectionName for \"+agent);\n            return null;\n        }\n\n        //log().debug(\"collect got collectionName for \"+agent);\n        log().debug(\"XmpCollector: collect \"+collectionName+\" from \"+agent);\n\n        // get/create our collections set\n        collectionSet = new XmpCollectionSet(agent);\n        collectionSet.setStatusFailed(); // default\n        collectionSet.ignorePersistTrue(); // default not to persist\n\n        // default collection resource for putting scalars in\n        scalarResource = new XmpCollectionResource(agent,null,\"node\",null);\n        collectionSet.addResource(scalarResource);\n\n        // get the collection, again, from the data config file factory\n        // because it could have changed; its not necessarily re-parsed,\n        // but we are getting another copy of it for each agent\n        // that we are queried each time we are invoked\n\n        collection = XmpCollectionFactory.getInstance().getXmpCollection(collectionName);\n        if (collection == null) {\n            log().warn(\"collect found no matching collection for \"+agent);\n            return collectionSet;\n        }\n\n        oldUptime = agent.getSavedSysUpTime();\n\n        // open/get a session with the target agent\n\n        log().debug(\"collect: attempting to open XMP session with \"+agent.getInetAddress()+\":\"+xmpPort+\",\"+authenUser);\n\n        // Set the SO_TIMEOUT, why don't we...\n        sockopts.setConnectTimeout(timeout);\n\n        session = new XmpSession(sockopts,\n                                 agent.getInetAddress(),\n                                 xmpPort,authenUser);\n\n        if (session == null) {\n            // send event saying collection failed\n            log().warn(\"collect unable to get XMP session with \"+agent);\n            return collectionSet;\n        }\n\n        if (session.isClosed()) {\n            log().warn(\"collect unable to open XMP session with \"+agent);\n            return collectionSet;\n        }\n\n        log().debug(\"collect: successfully opened XMP session with\"+agent);\n\n        // for each group within the collection (from data config)\n        // query agent\n\n        for (Group group : collection.getGroups().getGroup()) {\n\n            // get name of group and MIB objects in group\n            String groupName = group.getName();\n            String groupResourceType = group.getResourceType();\n            MibObj[] mibObjects = group.getMibObj();\n            XmpVar[] vars = new XmpVar[mibObjects.length];\n\n            log().debug(\"collecting XMP group \"+groupName+\" with \"+mibObjects.length+\" mib objects\");\n\n            // prepare the query vars\n            for (i=0 ; i< mibObjects.length; i++) {\n\n                vars[i] = new XmpVar(mibObjects[i].getMib(),\n                                     mibObjects[i].getVar(), \n                                     mibObjects[i].getInstance(),\n                                     \"\",\n                                     Xmp.SYNTAX_NULLSYNTAX);\n\n            } /* for each MIB object in a particular group */\n\n            if ((mibObjects[0].getTable() != null) && \n                    (mibObjects[0].getTable().length() != 0)) {\n\n                String[] tableInfo = new String[3];\n                tableInfo[0] = mibObjects[0].getMib();\n                tableInfo[1] = mibObjects[0].getTable();\n                tableInfo[2] = mibObjects[0].getInstance();\n\n                // tabular query               \n                if (handleTableQuery(group.getName(),\n                                     group.getResourceType(),\n                                     collectionSet,\n                                     tableInfo,\n                                     session,\n                                     vars) == false) {\n                    session.closeSession();\n                    return collectionSet;\n                }\n            }\n            else {\n                // scalar query\n                if (handleScalarQuery(group.getName(),\n                                      collectionSet,\n                                      oldUptime,\n                                      session,\n                                      scalarResource,\n                                      vars) == false) {\n                    session.closeSession();\n                    return collectionSet;\n                }\n            }\n\n        } /* for each Group in collection Group list */\n\n        // done talking to this agent; close session\n        session.closeSession();\n\n        // Did agent restart since last query?  If so, set\n        // ignorePersist to true; our scalar\n        // query will have handled this by searching returned\n        // MIB objects for sysUpTime\n\n        // WARNING, EACH COLLECTION SHOULD HAVE A SCALAR QUERY THAT\n        // INCLUDES Core.sysUpTime \n\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n\n        log().debug(\"XMP collect finished for \"+collectionName+\", uptime for \"+agent+\" is \"+agent.getSavedSysUpTime());\n\n        return collectionSet;\n    }","id":9300,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * Collect data, via XMP, from a particular agent EventProxy is\n     *       used to send opennms events into the system in case a\n     *       collection fails or if a system is back working again after a\n     *       failure (suceed event).  But otherwise, no events sent if\n     *       collection succeeds.  Collect is called once per agent per\n     *       collection cycle.  Parameters are a map of String Key/String\n     *       Value passed in.  Keys come from collectd config\n     */\n    public CollectionSet collect(CollectionAgent agent, EventProxy eproxy, \n            Map<String, String> parameters)\n    {\n        XmpCollectionSet collectionSet;\n        XmpSession session;\n        long oldUptime;\n        int i;\n        XmpCollection collection;\n        XmpCollectionResource scalarResource;\n\n        log().debug(\"collect agent \"+agent);\n\n        oldUptime = 0;\n        \n        // First go to the peer factory\n        XmpAgentConfig peerConfig = XmpPeerFactory.getInstance().getAgentConfig(agent.getInetAddress());\n        authenUser = peerConfig.getAuthenUser();\n        timeout = (int)peerConfig.getTimeout();\n        retries = peerConfig.getRetry();\n        xmpPort = peerConfig.getPort();\n\n        if (parameters.get(\"authenUser\") != null)\n            authenUser = (String)parameters.get(\"authenUser\");\n\n        if (parameters.get(\"timeout\") != null) {\n            timeout = Integer.valueOf(parameters.get(\"timeout\"));\n        }\n        \n        if (parameters.get(\"retry\") != null) {\n            retries = Integer.valueOf(parameters.get(\"retries\"));\n        }\n        parameters.get(\"collection\");\n\n        if (parameters.get(\"port\") != null) {\n            xmpPort = Integer.valueOf((String)parameters.get(\"port\"));\n        }\n\n        //log().debug(\"collect got parameters for \"+agent);\n\n        String collectionName = parameters.get(\"collection\");\n\n        //log().debug(\"XMP collection name \"+collectionName);\n\n        // collectionName tells us what set of data to get \n        // this would/will come from xmp-datacollection.xml\n        if (collectionName == null) {\n            // log this!\n            log().warn(\"collect found no collectionName for \"+agent);\n            return null;\n        }\n\n        //log().debug(\"collect got collectionName for \"+agent);\n        log().debug(\"XmpCollector: collect \"+collectionName+\" from \"+agent);\n\n        // get/create our collections set\n        collectionSet = new XmpCollectionSet(agent);\n        collectionSet.setStatusFailed(); // default\n        collectionSet.ignorePersistTrue(); // default not to persist\n\n        // default collection resource for putting scalars in\n        scalarResource = new XmpCollectionResource(agent,null,\"node\",null);\n        collectionSet.addResource(scalarResource);\n\n        // get the collection, again, from the data config file factory\n        // because it could have changed; its not necessarily re-parsed,\n        // but we are getting another copy of it for each agent\n        // that we are queried each time we are invoked\n\n        collection = XmpCollectionFactory.getInstance().getXmpCollection(collectionName);\n        if (collection == null) {\n            log().warn(\"collect found no matching collection for \"+agent);\n            return collectionSet;\n        }\n\n        oldUptime = agent.getSavedSysUpTime();\n\n        // open/get a session with the target agent\n\n        log().debug(\"collect: attempting to open XMP session with \"+agent.getInetAddress()+\":\"+xmpPort+\",\"+authenUser);\n\n        // Set the SO_TIMEOUT, why don't we...\n        sockopts.setConnectTimeout(timeout);\n\n        session = new XmpSession(sockopts,\n                                 agent.getInetAddress(),\n                                 xmpPort,authenUser);\n\n        if (session == null) {\n            // send event saying collection failed\n            log().warn(\"collect unable to get XMP session with \"+agent);\n            return collectionSet;\n        }\n\n        if (session.isClosed()) {\n            log().warn(\"collect unable to open XMP session with \"+agent);\n            return collectionSet;\n        }\n\n        log().debug(\"collect: successfully opened XMP session with\"+agent);\n\n        // for each group within the collection (from data config)\n        // query agent\n\n        for (Group group : collection.getGroups().getGroup()) {\n\n            // get name of group and MIB objects in group\n            String groupName = group.getName();\n            MibObj[] mibObjects = group.getMibObj();\n            XmpVar[] vars = new XmpVar[mibObjects.length];\n\n            log().debug(\"collecting XMP group \"+groupName+\" with \"+mibObjects.length+\" mib objects\");\n\n            // prepare the query vars\n            for (i=0 ; i< mibObjects.length; i++) {\n\n                vars[i] = new XmpVar(mibObjects[i].getMib(),\n                                     mibObjects[i].getVar(), \n                                     mibObjects[i].getInstance(),\n                                     \"\",\n                                     Xmp.SYNTAX_NULLSYNTAX);\n\n            } /* for each MIB object in a particular group */\n\n            if ((mibObjects[0].getTable() != null) && \n                    (mibObjects[0].getTable().length() != 0)) {\n\n                String[] tableInfo = new String[3];\n                tableInfo[0] = mibObjects[0].getMib();\n                tableInfo[1] = mibObjects[0].getTable();\n                tableInfo[2] = mibObjects[0].getInstance();\n\n                // tabular query               \n                if (handleTableQuery(group.getName(),\n                                     group.getResourceType(),\n                                     collectionSet,\n                                     tableInfo,\n                                     session,\n                                     vars) == false) {\n                    session.closeSession();\n                    return collectionSet;\n                }\n            }\n            else {\n                // scalar query\n                if (handleScalarQuery(group.getName(),\n                                      collectionSet,\n                                      oldUptime,\n                                      session,\n                                      scalarResource,\n                                      vars) == false) {\n                    session.closeSession();\n                    return collectionSet;\n                }\n            }\n\n        } /* for each Group in collection Group list */\n\n        // done talking to this agent; close session\n        session.closeSession();\n\n        // Did agent restart since last query?  If so, set\n        // ignorePersist to true; our scalar\n        // query will have handled this by searching returned\n        // MIB objects for sysUpTime\n\n        // WARNING, EACH COLLECTION SHOULD HAVE A SCALAR QUERY THAT\n        // INCLUDES Core.sysUpTime \n\n        collectionSet.setStatus(ServiceCollector.COLLECTION_SUCCEEDED);\n\n        log().debug(\"XMP collect finished for \"+collectionName+\", uptime for \"+agent+\" is \"+agent.getSavedSysUpTime());\n\n        return collectionSet;\n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>Constructor for XmpCollector.<\/p>\n     */\n    public XmpCollector() \n    {\n        log().debug(\"XmpCollector created\");\n\n        // initialize collections and containers for storing\n        // list of systems to query \n        setOfNodes = new HashSet();\n\n        // defaults\n        xmpPort = Xmp.XMP_PORT;\n        sockopts = new SocketOpts();\n        authenUser = new String(\"xmpUser\"); \n        timeout = 3000; /* millseconds */\n\n        return; \n    }","id":9301,"modified_method":"/**\n     * <p>Constructor for XmpCollector.<\/p>\n     */\n    public XmpCollector() \n    {\n        log().debug(\"XmpCollector created\");\n\n        // initialize collections and containers for storing\n        // list of systems to query \n        setOfNodes = new HashSet<CollectionAgent>();\n\n        // defaults\n        xmpPort = Xmp.XMP_PORT;\n        sockopts = new SocketOpts();\n        authenUser = new String(\"xmpUser\"); \n        timeout = 3000; /* millseconds */\n\n        return; \n    }","commit_id":"505cc922995d0d54016b690195541fd16835aea2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void onTestStart(ITestResult res) {\n        log.info(\"Starting test {}\", getTestDesc(res));\n        threadTestClass.set(res.getTestClass());\n        threadTestStart.set(System.currentTimeMillis());\n    }","id":9302,"modified_method":"public void onTestStart(ITestResult res) {\n        System.out.println(\"Starting test \" + getTestDesc(res));\n        threadTestClass.set(res.getTestClass());\n        threadTestStart.set(System.currentTimeMillis());\n    }","commit_id":"48ee6c4a237804666e285590092caa8a6ebfc022","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"synchronized public void onTestSkipped(ITestResult arg0) {\n        log.info(\"{} Test {} skipped.\", getThreadId(), getTestDesc(arg0));\n        skipped.incrementAndGet();\n        printStatus();\n    }","id":9303,"modified_method":"synchronized public void onTestSkipped(ITestResult arg0) {\n        System.out.println(getThreadId() + \" Test \" + getTestDesc(arg0) + \" skipped.\");\n        skipped.incrementAndGet();\n        printStatus();\n    }","commit_id":"48ee6c4a237804666e285590092caa8a6ebfc022","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"synchronized public void onTestFailure(ITestResult arg0) {\n        log.info(\"{} Test {} failed.\", getThreadId(), getTestDesc(arg0));\n        failed.incrementAndGet();\n        printStatus();\n    }","id":9304,"modified_method":"synchronized public void onTestFailure(ITestResult arg0) {\n        System.out.println(getThreadId() + \" Test \" + getTestDesc(arg0) + \" failed.\");\n        failed.incrementAndGet();\n        printStatus();\n    }","commit_id":"48ee6c4a237804666e285590092caa8a6ebfc022","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void printStatus() {\n        log.info(\"Test suite progress: tests succeeded: {}, failed: {}, skipped: {}\",\n                new Object[] { succeded.get(), failed.get(), skipped.get() });\n    }","id":9305,"modified_method":"private void printStatus() {\n        System.out.println(\"Test suite progress: tests succeeded: \" + succeded.get() + \", failed: \" + failed.get() + \", skipped: \" + skipped.get() + \".\");\n    }","commit_id":"48ee6c4a237804666e285590092caa8a6ebfc022","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"synchronized public void onTestSuccess(ITestResult arg0) {\n        log.info(\"{} Test {} succeeded: {} ms\",\n                new Object[] { getThreadId(), getTestDesc(arg0), (System.currentTimeMillis() - threadTestStart.get()) });\n        succeded.incrementAndGet();\n        printStatus();\n    }","id":9306,"modified_method":"synchronized public void onTestSuccess(ITestResult arg0) {\n        System.out.println(getThreadId() + \" Test \" + getTestDesc(arg0) + \" succeeded: \" + (System.currentTimeMillis() - threadTestStart.get()) + \"ms\");\n        succeded.incrementAndGet();\n        printStatus();\n    }","commit_id":"48ee6c4a237804666e285590092caa8a6ebfc022","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void resetStats() {\n        super.resetStats();\n        num_blockings=0;\n        num_credit_responses_sent=num_credit_responses_received=num_credit_requests_received=num_credit_requests_sent=0;\n        total_time_blocking=0;\n        last_blockings.clear();\n    }","id":9307,"modified_method":"public void resetStats() {\n        super.resetStats();\n        num_blockings=0;\n        num_credit_responses_sent=num_credit_responses_received=num_credit_requests_received=num_credit_requests_sent=0;\n        total_time_blocking=0;\n        // last_blockings.clear();\n    }","commit_id":"f76256539518ac44b3a7c327fc471c506f91f9b7","url":"https://github.com/belaban/JGroups"},{"original_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest != null && !dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle unicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        if(max_block_times != null) {\n            long tmp=getMaxBlockTime(length);\n            if(tmp > 0)\n                end_time.set(System.currentTimeMillis() + tmp);\n        }\n\n        lock.lock();\n        try {\n            if(length > lowest_credit) { // then block and loop asking for credits until enough credits are available\n                if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n                    if(log.isTraceEnabled())\n                        log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n                }\n                else {\n                    determineCreditors(length);\n                    long start_blocking=System.currentTimeMillis();\n                    num_blockings++; // we count overall blockings, not blockings for *all* threads\n                    if(log.isTraceEnabled())\n                        log.trace(\"Starting blocking. lowest_credit=\" + lowest_credit + \"; msg length =\" + length);\n\n                    while(length > lowest_credit && running) {\n                        try {\n                            long block_time=max_block_time;\n                            if(max_block_times != null) {\n                                Long tmp=end_time.get();\n                                if(tmp != null) {\n                                    // A negative block_time means we don't wait at all ! If the end_time already elapsed\n                                    // (because we waited for other threads to get processed), the message will not\n                                    // block at all and get sent immediately\n                                    block_time=tmp - start_blocking;\n                                }\n                            }\n\n                            boolean rc=credits_available.await(block_time, TimeUnit.MILLISECONDS);\n                            if(length <= lowest_credit || rc || !running)\n                                break;\n\n                            // if we use max_block_times, then we do *not* send credit requests, even if we run\n                            // into timeouts: in this case, it is up to the receivers to send new credits\n                            if(!rc && max_block_times != null)\n                                break;\n\n                            long wait_time=System.currentTimeMillis() - last_credit_request;\n                            if(wait_time >= max_block_time) {\n\n                                // we have to set this var now, because we release the lock below (for sending a\n                                // credit request), so all blocked threads would send a credit request, leading to\n                                // a credit request storm\n                                last_credit_request=System.currentTimeMillis();\n\n                                // we need to send the credit requests down *without* holding the lock, otherwise we might\n                                // run into the deadlock described in http://jira.jboss.com/jira/browse/JGRP-292\n                                Map<Address,Credit> sent_copy=new HashMap<Address,Credit>(sent);\n                                sent_copy.keySet().retainAll(creditors);\n                                lock.unlock();\n                                try {\n                                    for(Map.Entry<Address,Credit> entry: sent_copy.entrySet())\n                                        sendCreditRequest(entry.getKey(), entry.getValue().get());\n                                }\n                                finally {\n                                    lock.lock();\n                                }\n                            }\n                        }\n                        catch(InterruptedException e) {\n                            // bela June 15 2007: don't interrupt the thread again, as this will trigger an infinite loop !!\n                            // (http://jira.jboss.com/jira/browse/JGRP-536)\n                            // Thread.currentThread().interrupt();\n                        }\n                    }\n                    long block_time=System.currentTimeMillis() - start_blocking;\n                    if(log.isTraceEnabled())\n                        log.trace(\"total time blocked: \" + block_time + \" ms\");\n                    total_time_blocking+=block_time;\n                    last_blockings.add(block_time);\n                }\n            }\n\n            long tmp=decrementCredit(sent, length);\n            if(tmp != -1)\n                lowest_credit=Math.min(tmp, lowest_credit);\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","id":9308,"modified_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest != null && !dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle unicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        lock.lock();\n        try {\n            if(length > lowest_credit) { // then block and loop asking for credits until enough credits are available\n                if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n                    if(log.isTraceEnabled())\n                        log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n                }\n                else {\n                    determineCreditors(length);\n                    num_blockings++; // we count overall blockings, not blockings for *all* threads\n                    if(log.isTraceEnabled())\n                        log.trace(\"Starting blocking. lowest_credit=\" + lowest_credit + \"; msg length =\" + length);\n\n                    long block_time=max_block_times != null? getMaxBlockTime(length) : max_block_time;\n                    while(length > lowest_credit && running) {\n                        try {\n                            long start=System.currentTimeMillis();\n                            boolean rc=credits_available.await(block_time, TimeUnit.MILLISECONDS);\n                            total_time_blocking+=System.currentTimeMillis() - start;\n                            if(length <= lowest_credit || rc || !running)\n                                break;\n\n                            // if we use max_block_times, then we do *not* send credit requests, even if we run\n                            // into timeouts: in this case, it is up to the receivers to send new credits\n                            if(!rc && max_block_times != null)\n                                break;\n\n                            long curr_time=System.currentTimeMillis();\n                            long wait_time=curr_time - last_credit_request;\n                            if(wait_time >= max_block_time) {\n\n                                // we have to set this var now, because we release the lock below (for sending a\n                                // credit request), so all blocked threads would send a credit request, leading to\n                                // a credit request storm\n                                last_credit_request=curr_time;\n\n                                // we need to send the credit requests down *without* holding the lock, otherwise we might\n                                // run into the deadlock described in http://jira.jboss.com/jira/browse/JGRP-292\n                                Map<Address,Credit> sent_copy=new HashMap<Address,Credit>(sent);\n                                sent_copy.keySet().retainAll(creditors);\n                                lock.unlock();\n                                try {\n                                    for(Map.Entry<Address,Credit> entry: sent_copy.entrySet())\n                                        sendCreditRequest(entry.getKey(), entry.getValue().get());\n                                }\n                                finally {\n                                    lock.lock();\n                                }\n                            }\n                        }\n                        catch(InterruptedException e) {\n                            // bela June 15 2007: don't interrupt the thread again, as this will trigger an infinite loop !!\n                            // (http://jira.jboss.com/jira/browse/JGRP-536)\n                            // Thread.currentThread().interrupt();\n                        }\n                    }\n                }\n            }\n\n            long tmp=decrementCredit(sent, length);\n            if(tmp != -1)\n                lowest_credit=Math.min(tmp, lowest_credit);\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","commit_id":"f76256539518ac44b3a7c327fc471c506f91f9b7","url":"https://github.com/belaban/JGroups"},{"original_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle multicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n            if(log.isTraceEnabled())\n                log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n            return down_prot.down(evt);\n        }\n\n        if(max_block_times != null) {\n            long tmp=getMaxBlockTime(length);\n            if(tmp > 0)\n                end_time.set(System.currentTimeMillis() + tmp);\n        }\n\n        UfcCredit cred=(UfcCredit)sent.get(dest);\n        if(cred == null) {\n            log.error(\"destination \" + dest + \" not found; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        while(running) {\n            if(cred.decrementIfEnoughCredits(length, 0)) // timeout == 0: don't block\n                break;\n\n            long start_blocking=System.currentTimeMillis();\n            long block_time=max_block_time;\n            if(max_block_times != null) {\n                Long tmp=end_time.get();\n                if(tmp != null) {\n                    // A negative block_time means we don't wait at all ! If the end_time already elapsed\n                    // (because we waited for other threads to get processed), the message will not\n                    // block at all and get sent immediately\n                    block_time=tmp - start_blocking;\n                }\n            }\n\n            if(log.isTraceEnabled())\n                log.trace(\"blocking for credits (for \" + block_time + \" ms)\");\n            boolean rc=cred.decrementIfEnoughCredits(length, block_time);\n            if(rc && log.isTraceEnabled())\n                log.trace(\"unblocking (received credits)\");\n            last_blockings.add(System.currentTimeMillis() - start_blocking);\n            \n            if(rc || !running || max_block_times != null)\n                break;\n\n            if(cred.sendCreditRequest(System.currentTimeMillis()))\n                sendCreditRequest(dest, cred.get());\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","id":9309,"modified_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle multicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n            if(log.isTraceEnabled())\n                log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n            return down_prot.down(evt);\n        }\n\n        UfcCredit cred=(UfcCredit)sent.get(dest);\n        if(cred == null) {\n            log.error(\"destination \" + dest + \" not found; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        long block_time=max_block_times != null? getMaxBlockTime(length) : max_block_time;\n        \n        while(running) {\n            if(cred.decrementIfEnoughCredits(length, 0)) // timeout == 0: don't block\n                break;\n\n            if(log.isTraceEnabled())\n                log.trace(\"blocking for credits (for \" + block_time + \" ms)\");\n            boolean rc=cred.decrementIfEnoughCredits(length, block_time);\n            if(rc && log.isTraceEnabled())\n                log.trace(\"unblocking (received credits)\");\n            \n            if(rc || !running || max_block_times != null)\n                break;\n\n            if(cred.sendCreditRequest(System.currentTimeMillis()))\n                sendCreditRequest(dest, cred.get());\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","commit_id":"f76256539518ac44b3a7c327fc471c506f91f9b7","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        super.stop();\n        for(final Credit cred: sent.values()) {\n            synchronized(cred) {\n                cred.notifyAll();\n            }\n        }\n    }","id":9310,"modified_method":"public void stop() {\n        super.stop();\n        for(final Credit cred: sent.values()) {\n            synchronized(cred) {\n                cred.set(max_credits);\n                cred.notifyAll();\n            }\n        }\n    }","commit_id":"f76256539518ac44b3a7c327fc471c506f91f9b7","url":"https://github.com/belaban/JGroups"},{"original_method":"public void resetStats() {\n        super.resetStats();\n        num_blockings=0;\n        num_credit_responses_sent=num_credit_responses_received=num_credit_requests_received=num_credit_requests_sent=0;\n        total_time_blocking=0;\n        last_blockings.clear();\n    }","id":9311,"modified_method":"public void resetStats() {\n        super.resetStats();\n        num_blockings=0;\n        num_credit_responses_sent=num_credit_responses_received=num_credit_requests_received=num_credit_requests_sent=0;\n        total_time_blocking=0;\n        // last_blockings.clear();\n    }","commit_id":"25b2c04e9ac1ad4ede1ffca8e179768048cae480","url":"https://github.com/belaban/JGroups"},{"original_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest != null && !dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle unicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        if(max_block_times != null) {\n            long tmp=getMaxBlockTime(length);\n            if(tmp > 0)\n                end_time.set(System.currentTimeMillis() + tmp);\n        }\n\n        lock.lock();\n        try {\n            if(length > lowest_credit) { // then block and loop asking for credits until enough credits are available\n                if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n                    if(log.isTraceEnabled())\n                        log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n                }\n                else {\n                    determineCreditors(length);\n                    long start_blocking=System.currentTimeMillis();\n                    num_blockings++; // we count overall blockings, not blockings for *all* threads\n                    if(log.isTraceEnabled())\n                        log.trace(\"Starting blocking. lowest_credit=\" + lowest_credit + \"; msg length =\" + length);\n\n                    while(length > lowest_credit && running) {\n                        try {\n                            long block_time=max_block_time;\n                            if(max_block_times != null) {\n                                Long tmp=end_time.get();\n                                if(tmp != null) {\n                                    // A negative block_time means we don't wait at all ! If the end_time already elapsed\n                                    // (because we waited for other threads to get processed), the message will not\n                                    // block at all and get sent immediately\n                                    block_time=tmp - start_blocking;\n                                }\n                            }\n\n                            boolean rc=credits_available.await(block_time, TimeUnit.MILLISECONDS);\n                            if(length <= lowest_credit || rc || !running)\n                                break;\n\n                            // if we use max_block_times, then we do *not* send credit requests, even if we run\n                            // into timeouts: in this case, it is up to the receivers to send new credits\n                            if(!rc && max_block_times != null)\n                                break;\n\n                            long wait_time=System.currentTimeMillis() - last_credit_request;\n                            if(wait_time >= max_block_time) {\n\n                                // we have to set this var now, because we release the lock below (for sending a\n                                // credit request), so all blocked threads would send a credit request, leading to\n                                // a credit request storm\n                                last_credit_request=System.currentTimeMillis();\n\n                                // we need to send the credit requests down *without* holding the lock, otherwise we might\n                                // run into the deadlock described in http://jira.jboss.com/jira/browse/JGRP-292\n                                Map<Address,Credit> sent_copy=new HashMap<Address,Credit>(sent);\n                                sent_copy.keySet().retainAll(creditors);\n                                lock.unlock();\n                                try {\n                                    for(Map.Entry<Address,Credit> entry: sent_copy.entrySet())\n                                        sendCreditRequest(entry.getKey(), entry.getValue().get());\n                                }\n                                finally {\n                                    lock.lock();\n                                }\n                            }\n                        }\n                        catch(InterruptedException e) {\n                            // bela June 15 2007: don't interrupt the thread again, as this will trigger an infinite loop !!\n                            // (http://jira.jboss.com/jira/browse/JGRP-536)\n                            // Thread.currentThread().interrupt();\n                        }\n                    }\n                    long block_time=System.currentTimeMillis() - start_blocking;\n                    if(log.isTraceEnabled())\n                        log.trace(\"total time blocked: \" + block_time + \" ms\");\n                    total_time_blocking+=block_time;\n                    last_blockings.add(block_time);\n                }\n            }\n\n            long tmp=decrementCredit(sent, length);\n            if(tmp != -1)\n                lowest_credit=Math.min(tmp, lowest_credit);\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","id":9312,"modified_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest != null && !dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle unicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        lock.lock();\n        try {\n            if(length > lowest_credit) { // then block and loop asking for credits until enough credits are available\n                if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n                    if(log.isTraceEnabled())\n                        log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n                }\n                else {\n                    determineCreditors(length);\n                    num_blockings++; // we count overall blockings, not blockings for *all* threads\n                    if(log.isTraceEnabled())\n                        log.trace(\"Starting blocking. lowest_credit=\" + lowest_credit + \"; msg length =\" + length);\n\n                    long block_time=max_block_times != null? getMaxBlockTime(length) : max_block_time;\n                    while(length > lowest_credit && running) {\n                        try {\n                            long start=System.currentTimeMillis();\n                            boolean rc=credits_available.await(block_time, TimeUnit.MILLISECONDS);\n                            total_time_blocking+=System.currentTimeMillis() - start;\n                            if(length <= lowest_credit || rc || !running)\n                                break;\n\n                            // if we use max_block_times, then we do *not* send credit requests, even if we run\n                            // into timeouts: in this case, it is up to the receivers to send new credits\n                            if(!rc && max_block_times != null)\n                                break;\n\n                            long curr_time=System.currentTimeMillis();\n                            long wait_time=curr_time - last_credit_request;\n                            if(wait_time >= max_block_time) {\n\n                                // we have to set this var now, because we release the lock below (for sending a\n                                // credit request), so all blocked threads would send a credit request, leading to\n                                // a credit request storm\n                                last_credit_request=curr_time;\n\n                                // we need to send the credit requests down *without* holding the lock, otherwise we might\n                                // run into the deadlock described in http://jira.jboss.com/jira/browse/JGRP-292\n                                Map<Address,Credit> sent_copy=new HashMap<Address,Credit>(sent);\n                                sent_copy.keySet().retainAll(creditors);\n                                lock.unlock();\n                                try {\n                                    for(Map.Entry<Address,Credit> entry: sent_copy.entrySet())\n                                        sendCreditRequest(entry.getKey(), entry.getValue().get());\n                                }\n                                finally {\n                                    lock.lock();\n                                }\n                            }\n                        }\n                        catch(InterruptedException e) {\n                            // bela June 15 2007: don't interrupt the thread again, as this will trigger an infinite loop !!\n                            // (http://jira.jboss.com/jira/browse/JGRP-536)\n                            // Thread.currentThread().interrupt();\n                        }\n                    }\n                }\n            }\n\n            long tmp=decrementCredit(sent, length);\n            if(tmp != -1)\n                lowest_credit=Math.min(tmp, lowest_credit);\n        }\n        finally {\n            lock.unlock();\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","commit_id":"25b2c04e9ac1ad4ede1ffca8e179768048cae480","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        super.stop();\n        for(final Credit cred: sent.values()) {\n            synchronized(cred) {\n                cred.notifyAll();\n            }\n        }\n    }","id":9313,"modified_method":"public void stop() {\n        super.stop();\n        for(final Credit cred: sent.values()) {\n            synchronized(cred) {\n                cred.set(max_credits);\n                cred.notifyAll();\n            }\n        }\n    }","commit_id":"25b2c04e9ac1ad4ede1ffca8e179768048cae480","url":"https://github.com/belaban/JGroups"},{"original_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle multicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n            if(log.isTraceEnabled())\n                log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n            return down_prot.down(evt);\n        }\n\n        if(max_block_times != null) {\n            long tmp=getMaxBlockTime(length);\n            if(tmp > 0)\n                end_time.set(System.currentTimeMillis() + tmp);\n        }\n\n        UfcCredit cred=(UfcCredit)sent.get(dest);\n        if(cred == null) {\n            log.error(\"destination \" + dest + \" not found; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        while(running) {\n            if(cred.decrementIfEnoughCredits(length, 0)) // timeout == 0: don't block\n                break;\n\n            long start_blocking=System.currentTimeMillis();\n            long block_time=max_block_time;\n            if(max_block_times != null) {\n                Long tmp=end_time.get();\n                if(tmp != null) {\n                    // A negative block_time means we don't wait at all ! If the end_time already elapsed\n                    // (because we waited for other threads to get processed), the message will not\n                    // block at all and get sent immediately\n                    block_time=tmp - start_blocking;\n                }\n            }\n\n            if(log.isTraceEnabled())\n                log.trace(\"blocking for credits (for \" + block_time + \" ms)\");\n            boolean rc=cred.decrementIfEnoughCredits(length, block_time);\n            if(rc && log.isTraceEnabled())\n                log.trace(\"unblocking (received credits)\");\n            last_blockings.add(System.currentTimeMillis() - start_blocking);\n            \n            if(rc || !running || max_block_times != null)\n                break;\n\n            if(cred.sendCreditRequest(System.currentTimeMillis()))\n                sendCreditRequest(dest, cred.get());\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","id":9314,"modified_method":"protected Object handleDownMessage(final Event evt, final Message msg, int length) {\n        Address dest=msg.getDest();\n        if(dest == null || dest.isMulticastAddress()) {\n            log.error(getClass().getSimpleName() + \" doesn't handle multicast messages; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        if(ignore_synchronous_response && ignore_thread.get()) { // JGRP-465\n            if(log.isTraceEnabled())\n                log.trace(\"bypassing blocking to avoid deadlocking \" + Thread.currentThread());\n            return down_prot.down(evt);\n        }\n\n        UfcCredit cred=(UfcCredit)sent.get(dest);\n        if(cred == null) {\n            log.error(\"destination \" + dest + \" not found; passing message down\");\n            return down_prot.down(evt);\n        }\n\n        long block_time=max_block_times != null? getMaxBlockTime(length) : max_block_time;\n        \n        while(running) {\n            if(cred.decrementIfEnoughCredits(length, 0)) // timeout == 0: don't block\n                break;\n\n            if(log.isTraceEnabled())\n                log.trace(\"blocking for credits (for \" + block_time + \" ms)\");\n            boolean rc=cred.decrementIfEnoughCredits(length, block_time);\n            if(rc && log.isTraceEnabled())\n                log.trace(\"unblocking (received credits)\");\n            \n            if(rc || !running || max_block_times != null)\n                break;\n\n            if(cred.sendCreditRequest(System.currentTimeMillis()))\n                sendCreditRequest(dest, cred.get());\n        }\n\n        // send message - either after regular processing, or after blocking (when enough credits available again)\n        return down_prot.down(evt);\n    }","commit_id":"25b2c04e9ac1ad4ede1ffca8e179768048cae480","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event instanceof DamagedPlayerEvent) {\r\n            DamagedPlayerEvent damageEvent = (DamagedPlayerEvent)event;\r\n            Permanent p = game.getPermanent(event.getSourceId());\r\n            if (damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId())) {\r\n                getTargets().get(0).add(event.getPlayerId(), game);\r\n\t\t\t    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":9315,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event instanceof DamagedPlayerEvent) {\r\n            DamagedPlayerEvent damageEvent = (DamagedPlayerEvent)event;\r\n            Permanent p = game.getPermanent(event.getSourceId());\r\n            if (damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId())) {\r\n                for (Effect effect : this.getEffects()) {\r\n                        effect.setTargetPointer(new FixedTarget(event.getPlayerId()));\r\n                }\r\n\t\t\t    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"ea9045e08c354f295ac1e49f09f22f99cd2b9909","url":"https://github.com/magefree/mage"},{"original_method":"public SwordOfBodyAndMindAbility() {\r\n        super(Zone.BATTLEFIELD, new CreateTokenEffect(new WolfToken()));\r\n        this.addEffect(new PutLibraryIntoGraveTargetEffect(10));\r\n        this.addTarget(new TargetPlayer());\r\n    }","id":9316,"modified_method":"public SwordOfBodyAndMindAbility() {\r\n        super(Zone.BATTLEFIELD, new CreateTokenEffect(new WolfToken()));\r\n        this.addEffect(new PutLibraryIntoGraveTargetEffect(10));\r\n    }","commit_id":"ea9045e08c354f295ac1e49f09f22f99cd2b9909","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (event.getType() == EventType.DISCARDED_CARD && game.getOpponents(controllerId).contains(event.getPlayerId())) {\n            this.addTarget(new TargetPlayer());\n            getTargets().get(0).add(event.getPlayerId(), game);\n            return true;\n        }\n        return false;\n    }","id":9317,"modified_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (event.getType() == EventType.DISCARDED_CARD && game.getOpponents(controllerId).contains(event.getPlayerId())) {\n            for (Effect effect :this.getEffects()) {\n                effect.setTargetPointer(new FixedTarget(event.getPlayerId()));\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"213f8e707174f811361e5734a9b2de9cd9aeea54","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\n\t\tif (event.getType() == EventType.DAMAGED_PLAYER && event.getSourceId().equals(this.sourceId)) {\n\t\t\tgetTargets().clear();\n\t\t\tthis.addTarget(new TargetPlayer());\n\t\t\tgetTargets().get(0).add(event.getPlayerId(), game);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":9318,"modified_method":"@Override\n\tpublic boolean checkTrigger(GameEvent event, Game game) {\n\t\tif (event.getType() == EventType.DAMAGED_PLAYER && event.getSourceId().equals(this.sourceId)) {\n            if (setTargetPointer) {\n                for (Effect effect : this.getEffects()) {\n                        effect.setTargetPointer(new FixedTarget(event.getPlayerId()));\n                }\n            }\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"0633a2667fac16300c2223b4d2c12c442575ba4e","url":"https://github.com/magefree/mage"},{"original_method":"public DealsCombatDamageToAPlayerTriggeredAbility(final DealsCombatDamageToAPlayerTriggeredAbility ability) {\n\t\tsuper(ability);\n\t}","id":9319,"modified_method":"public DealsCombatDamageToAPlayerTriggeredAbility(final DealsCombatDamageToAPlayerTriggeredAbility ability) {\n\t\tsuper(ability);\n        this.setTargetPointer = ability.setTargetPointer;\n\t}","commit_id":"0633a2667fac16300c2223b4d2c12c442575ba4e","url":"https://github.com/magefree/mage"},{"original_method":"public DealsCombatDamageToAPlayerTriggeredAbility(Effect effect, boolean optional) {\n\t\tsuper(Zone.BATTLEFIELD, effect, optional);\n\t}","id":9320,"modified_method":"public DealsCombatDamageToAPlayerTriggeredAbility(Effect effect, boolean optional) {\n\t\tthis(effect, optional, false);\n\t}","commit_id":"0633a2667fac16300c2223b4d2c12c442575ba4e","url":"https://github.com/magefree/mage"},{"original_method":"public MerfolkSpy(UUID ownerId) {\n\t\tsuper(ownerId, 66, \"Merfolk Spy\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{U}\");\n\t\tthis.expansionSetCode = \"M11\";\n\t\tthis.subtype.add(\"Merfolk\");\n\t\tthis.subtype.add(\"Rogue\");\n\t\tthis.color.setBlue(true);\n\t\tthis.power = new MageInt(1);\n\t\tthis.toughness = new MageInt(1);\n\n\t\tthis.addAbility(new IslandwalkAbility());\n\t\tthis.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new MerfolkSpyEffect(), false));\n\t}","id":9321,"modified_method":"public MerfolkSpy(UUID ownerId) {\n\t\tsuper(ownerId, 66, \"Merfolk Spy\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{U}\");\n\t\tthis.expansionSetCode = \"M11\";\n\t\tthis.subtype.add(\"Merfolk\");\n\t\tthis.subtype.add(\"Rogue\");\n\t\tthis.color.setBlue(true);\n\t\tthis.power = new MageInt(1);\n\t\tthis.toughness = new MageInt(1);\n\n\t\tthis.addAbility(new IslandwalkAbility());\n\t\tthis.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new MerfolkSpyEffect(), false, true));\n\t}","commit_id":"0633a2667fac16300c2223b4d2c12c442575ba4e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tif (player != null && player.getHand().size() > 0) {\n\t\t\tCards revealed = new CardsImpl();\n\t\t\trevealed.add(player.getHand().getRandom(game));\n\t\t\tplayer.revealCards(\"Merfolk Spy\", revealed, game);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":9322,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(targetPointer.getFirst(source));\n\t\tif (player != null && player.getHand().size() > 0) {\n\t\t\tCards revealed = new CardsImpl();\n\t\t\trevealed.add(player.getHand().getRandom(game));\n\t\t\tplayer.revealCards(\"Merfolk Spy\", revealed, game);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"0633a2667fac16300c2223b4d2c12c442575ba4e","url":"https://github.com/magefree/mage"},{"original_method":"public ScreechingSilcaw(UUID ownerId) {\r\n        super(ownerId, 42, \"Screeching Silcaw\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{U}\");\r\n        this.expansionSetCode = \"SOM\";\r\n        this.subtype.add(\"Bird\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(2);\r\n\r\n        this.addAbility(FlyingAbility.getInstance());\r\n\r\n        TriggeredAbility conditional = new ConditionalTriggeredAbility(\r\n                new DealsCombatDamageToAPlayerTriggeredAbility(new PutLibraryIntoGraveTargetEffect(4), false),\r\n                Metalcraft.getInstance(), text);\r\n        this.addAbility(conditional);\r\n    }","id":9323,"modified_method":"public ScreechingSilcaw(UUID ownerId) {\r\n        super(ownerId, 42, \"Screeching Silcaw\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{U}\");\r\n        this.expansionSetCode = \"SOM\";\r\n        this.subtype.add(\"Bird\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(2);\r\n\r\n        this.addAbility(FlyingAbility.getInstance());\r\n\r\n        TriggeredAbility conditional = new ConditionalTriggeredAbility(\r\n                new DealsCombatDamageToAPlayerTriggeredAbility(new PutLibraryIntoGraveTargetEffect(4), false, true),\r\n                Metalcraft.getInstance(), text);\r\n        this.addAbility(conditional);\r\n    }","commit_id":"0633a2667fac16300c2223b4d2c12c442575ba4e","url":"https://github.com/magefree/mage"},{"original_method":"public Date freshdate() {\n        return new Date(86400000 * entry.getColLong(col_fresh));\n    }","id":9324,"modified_method":"public Date freshdate() {\n        return decodeDate(col_fresh);\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static byte[] encodeDate(Date d) {\n        // calculates the number of days since 1.1.1970 and returns this as 4-byte array\n        return kelondroNaturalOrder.encodeLong(d.getTime() / 86400000, 4);\n    }","id":9325,"modified_method":"private void encodeDate(int col, Date d) {\n        // calculates the number of days since 1.1.1970 and returns this as 4-byte array\n        this.entry.setCol(col, kelondroNaturalOrder.encodeLong(d.getTime() / 86400000, 4));\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public indexURLEntry(Properties prop){\n        // generates an plasmaLURLEntry using the properties from the argument\n        // the property names must correspond to the one from toString\n        //System.out.println(\"DEBUG-ENTRY: prop=\" + prop.toString());\n        yacyURL url;\n        try {\n            url = new yacyURL(crypt.simpleDecode(prop.getProperty(\"url\", \"\"), null), prop.getProperty(\"hash\"));\n        } catch (MalformedURLException e) {\n            url = null;\n        }\n        String descr = crypt.simpleDecode(prop.getProperty(\"descr\", \"\"), null); if (descr == null) descr = \"\";\n        String author = crypt.simpleDecode(prop.getProperty(\"author\", \"\"), null); if (author == null) author = \"\";\n        String tags = crypt.simpleDecode(prop.getProperty(\"tags\", \"\"), null); if (tags == null) tags = \"\";\n        String ETag = crypt.simpleDecode(prop.getProperty(\"ETag\", \"\"), null); if (ETag == null) ETag = \"\";\n        \n        this.entry = rowdef.newEntry();\n        this.entry.setCol(col_hash, url.hash(), null);\n        this.entry.setCol(col_comp, encodeComp(url, descr, author, tags, ETag));\n        try {\n            this.entry.setCol(col_mod, encodeDate(serverDate.shortDayFormatter.parse(prop.getProperty(\"mod\", \"20000101\"))));\n        } catch (ParseException e) {\n            this.entry.setCol(col_mod, encodeDate(new Date()));\n        }\n        try {\n            this.entry.setCol(col_load, encodeDate(serverDate.shortDayFormatter.parse(prop.getProperty(\"load\", \"20000101\"))));\n        } catch (ParseException e) {\n            this.entry.setCol(col_load, encodeDate(new Date()));\n        }\n        try {\n            this.entry.setCol(col_fresh, encodeDate(serverDate.shortDayFormatter.parse(prop.getProperty(\"fresh\", \"20000101\"))));\n        } catch (ParseException e) {\n            this.entry.setCol(col_fresh, encodeDate(new Date()));\n        }\n        this.entry.setCol(col_referrer, prop.getProperty(\"referrer\", yacyURL.dummyHash).getBytes());\n        this.entry.setCol(col_md5, serverCodings.decodeHex(prop.getProperty(\"md5\", \"\")));\n        this.entry.setCol(col_size, Integer.parseInt(prop.getProperty(\"size\", \"0\")));\n        this.entry.setCol(col_wc, Integer.parseInt(prop.getProperty(\"wc\", \"0\")));\n        this.entry.setCol(col_dt, new byte[]{(byte) prop.getProperty(\"dt\", \"t\").charAt(0)});\n        String flags = prop.getProperty(\"flags\", \"AAAAAA\");\n        this.entry.setCol(col_flags, (flags.length() > 6) ? plasmaSearchQuery.empty_constraint.bytes() : (new kelondroBitfield(4, flags)).bytes());\n        this.entry.setCol(col_lang, prop.getProperty(\"lang\", \"uk\").getBytes());\n        this.entry.setCol(col_llocal, Integer.parseInt(prop.getProperty(\"llocal\", \"0\")));\n        this.entry.setCol(col_lother, Integer.parseInt(prop.getProperty(\"lother\", \"0\")));\n        this.entry.setCol(col_limage, Integer.parseInt(prop.getProperty(\"limage\", \"0\")));\n        this.entry.setCol(col_laudio, Integer.parseInt(prop.getProperty(\"laudio\", \"0\")));\n        this.entry.setCol(col_lvideo, Integer.parseInt(prop.getProperty(\"lvideo\", \"0\")));\n        this.entry.setCol(col_lapp, Integer.parseInt(prop.getProperty(\"lapp\", \"0\")));\n        this.snippet = crypt.simpleDecode(prop.getProperty(\"snippet\", \"\"), null);\n        this.word = null;\n        if (prop.containsKey(\"word\")) throw new kelondroException(\"old database structure is not supported\");\n        if (prop.containsKey(\"wi\")) {\n            this.word = new indexRWIRowEntry(kelondroBase64Order.enhancedCoder.decodeString(prop.getProperty(\"wi\", \"\")));\n        }\n    }","id":9326,"modified_method":"public indexURLEntry(Properties prop){\n        // generates an plasmaLURLEntry using the properties from the argument\n        // the property names must correspond to the one from toString\n        //System.out.println(\"DEBUG-ENTRY: prop=\" + prop.toString());\n        yacyURL url;\n        try {\n            url = new yacyURL(crypt.simpleDecode(prop.getProperty(\"url\", \"\"), null), prop.getProperty(\"hash\"));\n        } catch (MalformedURLException e) {\n            url = null;\n        }\n        String descr = crypt.simpleDecode(prop.getProperty(\"descr\", \"\"), null); if (descr == null) descr = \"\";\n        String author = crypt.simpleDecode(prop.getProperty(\"author\", \"\"), null); if (author == null) author = \"\";\n        String tags = crypt.simpleDecode(prop.getProperty(\"tags\", \"\"), null); if (tags == null) tags = \"\";\n        String ETag = crypt.simpleDecode(prop.getProperty(\"ETag\", \"\"), null); if (ETag == null) ETag = \"\";\n        \n        this.entry = rowdef.newEntry();\n        this.entry.setCol(col_hash, url.hash(), null);\n        this.entry.setCol(col_comp, encodeComp(url, descr, author, tags, ETag));\n        try {\n            encodeDate(col_mod, serverDate.shortDayFormatter.parse(prop.getProperty(\"mod\", \"20000101\")));\n        } catch (ParseException e) {\n            encodeDate(col_mod, new Date());\n        }\n        try {\n            encodeDate(col_load, serverDate.shortDayFormatter.parse(prop.getProperty(\"load\", \"20000101\")));\n        } catch (ParseException e) {\n            encodeDate(col_load, new Date());\n        }\n        try {\n            encodeDate(col_fresh, serverDate.shortDayFormatter.parse(prop.getProperty(\"fresh\", \"20000101\")));\n        } catch (ParseException e) {\n            encodeDate(col_fresh, new Date());\n        }\n        this.entry.setCol(col_referrer, prop.getProperty(\"referrer\", yacyURL.dummyHash).getBytes());\n        this.entry.setCol(col_md5, serverCodings.decodeHex(prop.getProperty(\"md5\", \"\")));\n        this.entry.setCol(col_size, Integer.parseInt(prop.getProperty(\"size\", \"0\")));\n        this.entry.setCol(col_wc, Integer.parseInt(prop.getProperty(\"wc\", \"0\")));\n        this.entry.setCol(col_dt, new byte[]{(byte) prop.getProperty(\"dt\", \"t\").charAt(0)});\n        String flags = prop.getProperty(\"flags\", \"AAAAAA\");\n        this.entry.setCol(col_flags, (flags.length() > 6) ? plasmaSearchQuery.empty_constraint.bytes() : (new kelondroBitfield(4, flags)).bytes());\n        this.entry.setCol(col_lang, prop.getProperty(\"lang\", \"uk\").getBytes());\n        this.entry.setCol(col_llocal, Integer.parseInt(prop.getProperty(\"llocal\", \"0\")));\n        this.entry.setCol(col_lother, Integer.parseInt(prop.getProperty(\"lother\", \"0\")));\n        this.entry.setCol(col_limage, Integer.parseInt(prop.getProperty(\"limage\", \"0\")));\n        this.entry.setCol(col_laudio, Integer.parseInt(prop.getProperty(\"laudio\", \"0\")));\n        this.entry.setCol(col_lvideo, Integer.parseInt(prop.getProperty(\"lvideo\", \"0\")));\n        this.entry.setCol(col_lapp, Integer.parseInt(prop.getProperty(\"lapp\", \"0\")));\n        this.snippet = crypt.simpleDecode(prop.getProperty(\"snippet\", \"\"), null);\n        this.word = null;\n        if (prop.containsKey(\"word\")) throw new kelondroException(\"old database structure is not supported\");\n        if (prop.containsKey(\"wi\")) {\n            this.word = new indexRWIRowEntry(kelondroBase64Order.enhancedCoder.decodeString(prop.getProperty(\"wi\", \"\")));\n        }\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Date loaddate() {\n        return new Date(86400000 * entry.getColLong(col_load));\n    }","id":9327,"modified_method":"public Date loaddate() {\n        return decodeDate(col_load);\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public indexURLEntry(\n            yacyURL url,\n            String descr,\n            String author,\n            String tags,\n            String ETag,\n            Date mod,\n            Date load,\n            Date fresh,\n            String referrer,\n            byte[] md5,\n            long size,\n            int wc,\n            char dt,\n            kelondroBitfield flags,\n            String lang,\n            int llocal,\n            int lother,\n            int laudio,\n            int limage,\n            int lvideo,\n            int lapp) {\n        // create new entry and store it into database\n        this.entry = rowdef.newEntry();\n        this.entry.setCol(col_hash, url.hash(), null);\n        this.entry.setCol(col_comp, encodeComp(url, descr, author, tags, ETag));\n        this.entry.setCol(col_mod, encodeDate(mod));\n        this.entry.setCol(col_load, encodeDate(load));\n        this.entry.setCol(col_fresh, encodeDate(fresh));\n        this.entry.setCol(col_referrer, (referrer == null) ? null : referrer.getBytes());\n        this.entry.setCol(col_md5, md5);\n        this.entry.setCol(col_size, size);\n        this.entry.setCol(col_wc, wc);\n        this.entry.setCol(col_dt, new byte[]{(byte) dt});\n        this.entry.setCol(col_flags, flags.bytes());\n        this.entry.setCol(col_lang, lang.getBytes());\n        this.entry.setCol(col_llocal, llocal);\n        this.entry.setCol(col_lother, lother);\n        this.entry.setCol(col_limage, limage);\n        this.entry.setCol(col_laudio, laudio);\n        this.entry.setCol(col_lvideo, lvideo);\n        this.entry.setCol(col_lapp, lapp);\n        this.snippet = null;\n        this.word = null;\n    }","id":9328,"modified_method":"public indexURLEntry(\n            yacyURL url,\n            String descr,\n            String author,\n            String tags,\n            String ETag,\n            Date mod,\n            Date load,\n            Date fresh,\n            String referrer,\n            byte[] md5,\n            long size,\n            int wc,\n            char dt,\n            kelondroBitfield flags,\n            String lang,\n            int llocal,\n            int lother,\n            int laudio,\n            int limage,\n            int lvideo,\n            int lapp) {\n        // create new entry and store it into database\n        this.entry = rowdef.newEntry();\n        this.entry.setCol(col_hash, url.hash(), null);\n        this.entry.setCol(col_comp, encodeComp(url, descr, author, tags, ETag));\n        encodeDate(col_mod, mod);\n        encodeDate(col_load, load);\n        encodeDate(col_fresh, fresh);\n        this.entry.setCol(col_referrer, (referrer == null) ? null : referrer.getBytes());\n        this.entry.setCol(col_md5, md5);\n        this.entry.setCol(col_size, size);\n        this.entry.setCol(col_wc, wc);\n        this.entry.setCol(col_dt, new byte[]{(byte) dt});\n        this.entry.setCol(col_flags, flags.bytes());\n        this.entry.setCol(col_lang, lang.getBytes());\n        this.entry.setCol(col_llocal, llocal);\n        this.entry.setCol(col_lother, lother);\n        this.entry.setCol(col_limage, limage);\n        this.entry.setCol(col_laudio, laudio);\n        this.entry.setCol(col_lvideo, lvideo);\n        this.entry.setCol(col_lapp, lapp);\n        System.out.println(\"===DEBUG=== \" + load.toString() + \", \" + decodeDate(col_load).toString());\n        this.snippet = null;\n        this.word = null;\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Date moddate() {\n        return new Date(86400000 * entry.getColLong(col_mod));\n    }","id":9329,"modified_method":"public Date moddate() {\n        return decodeDate(col_mod);\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public synchronized final void sort() {\n        assert (this.rowdef.objectOrder != null);\n        if (this.sortBound == this.chunkcount) return; // this is already sorted\n        if (this.chunkcount < isortlimit) {\n            isort(0, this.chunkcount, new byte[this.rowdef.objectsize]);\n            return;\n        }\n        byte[] swapspace = new byte[this.rowdef.objectsize];\n        int p = partition(0, this.chunkcount, this.sortBound, swapspace);\n        if ((processors > 1) && (this.chunkcount >= 10000)) {\n        \t// sort this using multi-threading; use one second thread\n        \tqsortthread qs = new qsortthread(0, p, 0);\n            qs.start();\n        \tqsort(p, this.chunkcount, 0, swapspace);\n        \ttry {qs.join();} catch (InterruptedException e) {e.printStackTrace();}\n        } else {\n        \tqsort(0, p, 0, swapspace);\n        \tqsort(p, this.chunkcount, 0, swapspace);\n        }\n        this.sortBound = this.chunkcount;\n        //assert this.isSorted();\n    }","id":9330,"modified_method":"public synchronized final void sort() {\n        assert (this.rowdef.objectOrder != null);\n        if (this.sortBound == this.chunkcount) return; // this is already sorted\n        if (this.chunkcount < isortlimit) {\n            isort(0, this.chunkcount, new byte[this.rowdef.objectsize]);\n            this.sortBound = this.chunkcount;\n            return;\n        }\n        byte[] swapspace = new byte[this.rowdef.objectsize];\n        int p = partition(0, this.chunkcount, this.sortBound, swapspace);\n        if ((processors > 1) && (this.chunkcount >= 10000)) {\n        \t// sort this using multi-threading; use one second thread\n        \tqsortthread qs = new qsortthread(0, p, 0);\n            qs.start();\n        \tqsort(p, this.chunkcount, 0, swapspace);\n        \ttry {qs.join();} catch (InterruptedException e) {e.printStackTrace();}\n        } else {\n        \tqsort(0, p, 0, swapspace);\n        \tqsort(p, this.chunkcount, 0, swapspace);\n        }\n        this.sortBound = this.chunkcount;\n        //assert this.isSorted();\n    }","commit_id":"ec7ba0d3d0f35489685159175e38b51258cb3c6b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Test\n    public void test_mutable_properties_returned_public() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties.return.public\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        checkProperties( serviceReference, 8, \"otherValue\", \"p1\", \"p2\" );\n\n        //update theValue\n        MutatingService s = ( MutatingService ) bundleContext.getService( serviceReference );\n        Assert.assertNotNull(s);\n        checkProperties( serviceReference, 8, \"anotherValue1\", \"p1\", \"p2\" );\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.ACTIVE);\n        Dictionary d = new Hashtable(Collections.singletonMap( PROP_NAME, \"anotherValue\" ));\n        s.updateProperties(d);\n        checkProperties(serviceReference, 5, \"anotherValue\", \"p1\", \"p2\");\n\n        //configure with configAdmin\n        configure( componentName );\n        delay();\n        delay();\n        //no change\n        checkProperties(serviceReference, 8, \"anotherValue2\", \"p1\", \"p2\");\n\n        //check that removing config switches back to defaults modified by config admin\n        s.updateProperties(null);\n        checkProperties( serviceReference, 8, \"theValue\", \"p1\", \"p2\" );\n\n        bundleContext.ungetService(serviceReference);\n    }","id":9331,"modified_method":"@Test\n    public void test_mutable_properties_returned_public() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties.return.public\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        Assert.assertEquals(\"otherValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        //update theValue\n        MutatingService s = ( MutatingService ) bundleContext.getService( serviceReference );\n        Assert.assertNotNull(s);\n        Assert.assertEquals(\"anotherValue1\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.ACTIVE);\n        Dictionary d = new Hashtable(Collections.singletonMap( PROP_NAME, \"anotherValue\" ));\n        s.updateProperties(d);\n        Assert.assertEquals(\"anotherValue\", serviceReference.getProperty(PROP_NAME));\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n\n        //configure with configAdmin\n        configure( componentName );\n        delay();\n        delay();\n        //no change\n        Assert.assertEquals(\"anotherValue2\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        //check that removing config switches back to defaults modified by config admin\n        s.updateProperties(null);\n        Assert.assertEquals(\"theValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        bundleContext.ungetService(serviceReference);\n    }","commit_id":"3765acbede54dae7584120f55ebd673386e36407","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void test_mutable_properties_bind_returned() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties.bind\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        checkProperties( serviceReference, 8, \"otherValue\", \"p1\", \"p2\" );\n        MutatingService s = ( MutatingService ) bundleContext.getService( serviceReference );\n\n        SimpleServiceImpl srv1 = SimpleServiceImpl.create( bundleContext, \"srv1\" );\n        checkProperties( serviceReference, 5, null, \"p1\", \"p2\" );\n        Assert.assertEquals(\"bound\", serviceReference.getProperty(\"SimpleService\"));\n\n        srv1.update( \"foo\" );\n        checkProperties( serviceReference, 5, null, \"p1\", \"p2\" );\n        Assert.assertEquals(\"updated\", serviceReference.getProperty(\"SimpleService\"));\n\n        srv1.drop();\n        checkProperties( serviceReference, 5, null, \"p1\", \"p2\" );\n        Assert.assertEquals(\"unbound\", serviceReference.getProperty(\"SimpleService\"));\n\n        bundleContext.ungetService(serviceReference);\n    }","id":9332,"modified_method":"@Test\n    public void test_mutable_properties_bind_returned() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties.bind\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        Assert.assertEquals(\"otherValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n        MutatingService s = ( MutatingService ) bundleContext.getService( serviceReference );\n\n        SimpleServiceImpl srv1 = SimpleServiceImpl.create( bundleContext, \"srv1\" );\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n        Assert.assertEquals(\"bound\", serviceReference.getProperty(\"SimpleService\"));\n\n        srv1.update( \"foo\" );\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n        Assert.assertEquals(\"updated\", serviceReference.getProperty(\"SimpleService\"));\n\n        srv1.drop();\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n        Assert.assertEquals(\"unbound\", serviceReference.getProperty(\"SimpleService\"));\n\n        bundleContext.ungetService(serviceReference);\n    }","commit_id":"3765acbede54dae7584120f55ebd673386e36407","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void test_mutable_properties() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        checkProperties( serviceReference, 8, \"otherValue\", \"p1\", \"p2\" );\n\n        //update theValue\n        MutatingService s = ( MutatingService ) bundleContext.getService(serviceReference );\n        Assert.assertNotNull(s);\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.ACTIVE);\n        Dictionary d = new Hashtable(Collections.singletonMap( PROP_NAME, \"anotherValue\" ));\n        s.updateProperties(d);\n        checkProperties(serviceReference, 5, \"anotherValue\", \"p1\", \"p2\");\n\n        //configure with configAdmin\n        configure( componentName );\n        delay();\n        //no change\n        checkProperties(serviceReference, 5, \"anotherValue\", \"p1\", \"p2\");\n\n        //check that removing config switches back to defaults modified by config admin\n        s.updateProperties(null);\n        checkProperties( serviceReference, 8, \"theValue\", \"p1\", \"p2\" );\n\n        bundleContext.ungetService(serviceReference);\n    }","id":9333,"modified_method":"@Test\n    public void test_mutable_properties() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        Assert.assertEquals(\"otherValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        //update theValue\n        MutatingService s = ( MutatingService ) bundleContext.getService(serviceReference );\n        Assert.assertNotNull(s);\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.ACTIVE);\n        Dictionary d = new Hashtable(Collections.singletonMap( PROP_NAME, \"anotherValue\" ));\n        s.updateProperties(d);\n        Assert.assertEquals(\"anotherValue\", serviceReference.getProperty(PROP_NAME));\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n\n        //configure with configAdmin\n        configure( componentName );\n        delay();\n        //no change\n        Assert.assertEquals(\"anotherValue\", serviceReference.getProperty(PROP_NAME));\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n\n        //check that removing config switches back to defaults modified by config admin\n        s.updateProperties(null);\n        Assert.assertEquals(\"theValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        bundleContext.ungetService(serviceReference);\n    }","commit_id":"3765acbede54dae7584120f55ebd673386e36407","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void test_mutable_properties_returned() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties.return\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        checkProperties( serviceReference, 8, \"otherValue\", \"p1\", \"p2\" );\n\n        //update theValue\n        MutatingService s = ( MutatingService ) bundleContext.getService( serviceReference );\n        Assert.assertNotNull(s);\n        checkProperties( serviceReference, 8, \"anotherValue1\", \"p1\", \"p2\" );\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.ACTIVE);\n        Dictionary d = new Hashtable(Collections.singletonMap( PROP_NAME, \"anotherValue\" ));\n        s.updateProperties(d);\n        checkProperties(serviceReference, 5, \"anotherValue\", \"p1\", \"p2\");\n\n        //configure with configAdmin\n        configure( componentName );\n        delay();\n        delay();\n        //no change\n        checkProperties(serviceReference, 8, \"anotherValue2\", \"p1\", \"p2\");\n\n        //check that removing config switches back to defaults modified by config admin\n        s.updateProperties(null);\n        checkProperties( serviceReference, 8, \"theValue\", \"p1\", \"p2\" );\n\n        bundleContext.ungetService(serviceReference);\n    }","id":9334,"modified_method":"@Test\n    public void test_mutable_properties_returned() throws InvalidSyntaxException\n    {\n        String componentName = \"components.mutable.properties.return\";\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.SATISFIED);\n\n        ServiceReference[] serviceReferences = bundleContext.getServiceReferences( MutatingService.class.getName(), \"(service.pid=\" + componentName + \")\" );\n        TestCase.assertEquals( 1, serviceReferences.length );\n        ServiceReference serviceReference = serviceReferences[0];\n        Assert.assertEquals(\"otherValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        //update theValue\n        MutatingService s = ( MutatingService ) bundleContext.getService( serviceReference );\n        Assert.assertNotNull(s);\n        Assert.assertEquals(\"anotherValue1\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n        findComponentConfigurationByName(componentName, ComponentConfigurationDTO.ACTIVE);\n        Dictionary d = new Hashtable(Collections.singletonMap( PROP_NAME, \"anotherValue\" ));\n        s.updateProperties(d);\n        Assert.assertEquals(\"anotherValue\", serviceReference.getProperty(PROP_NAME));\n        checkPropertiesNotPresent(serviceReference, \"p1\", \"p2\");\n\n        //configure with configAdmin\n        configure( componentName );\n        delay();\n        delay();\n        //no change\n        Assert.assertEquals(\"anotherValue2\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        //check that removing config switches back to defaults modified by config admin\n        s.updateProperties(null);\n        Assert.assertEquals(\"theValue\", serviceReference.getProperty(PROP_NAME));\n        Assert.assertEquals(\"p1\", serviceReference.getProperty(\"p1\"));\n        Assert.assertEquals(\"p2\", serviceReference.getProperty(\"p2\"));\n\n        bundleContext.ungetService(serviceReference);\n    }","commit_id":"3765acbede54dae7584120f55ebd673386e36407","url":"https://github.com/apache/felix"},{"original_method":"private void checkProperties(ServiceReference serviceReference, int count, String otherValue, String p1, String p2) {\n        Assert.assertEquals(\"wrong property count\", count, serviceReference.getPropertyKeys().length);\n        if ( otherValue != null )\n        {\n            Assert.assertEquals(otherValue, serviceReference.getProperty(PROP_NAME));\n        }\n        if ( count > 5 ) {\n            Assert.assertEquals(p1, serviceReference.getProperty(\"p1\"));\n            Assert.assertEquals(p2, serviceReference.getProperty(\"p2\"));\n        }\n    }","id":9335,"modified_method":"private void checkPropertiesNotPresent(ServiceReference<?> serviceReference, String ... props) {\n        for (String p : props) {\n            Assert.assertFalse(\"Should not contain property \" + p, Arrays.asList(serviceReference.getPropertyKeys()).contains(p));\n        }\n    }","commit_id":"3765acbede54dae7584120f55ebd673386e36407","url":"https://github.com/apache/felix"},{"original_method":"/**\r\n   * Parses the command-line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args);\r\n    boolean ok = true;\r\n    try {\r\n      while(arg.more() && ok) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'q') {\r\n            quiet = true;\r\n          } else {\r\n            ok = false;\r\n          }\r\n        } else {\r\n          quindex = arg.num();\r\n        }\r\n      }\r\n    } catch(final Exception ex) {\r\n      ok = false;\r\n    }\r\n    if(!ok || quindex == -1)\r\n      Main.outln(\"Usage: \" + Main.name(this) + \" [options] query\" + NL +\r\n          \"  -q     quiet mode (suppress output)\" + NL +\r\n          \"  query  perform specified query (1-#queries)\");\r\n    return ok;\r\n  }","id":9336,"modified_method":"/**\r\n   * Parses the command-line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args, this,\r\n        \" [options] query\" + NL +\r\n        \"  -q     quiet mode (suppress output)\" + NL +\r\n        \"  query  perform specified query (1-#queries)\");\r\n    try {\r\n      while(arg.more()) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'q') {\r\n            quiet = true;\r\n          } else {\r\n            arg.check(false);\r\n          }\r\n        } else {\r\n          quindex = arg.num();\r\n        }\r\n      }\r\n    } catch(final Exception ex) {\r\n      arg.check(false);\r\n    }\r\n    if(quindex == -1) arg.check(false);\r\n    \r\n    return arg.finish();\r\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Parses the command line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args);\r\n    boolean ok = true;\r\n    try {\r\n      while(arg.more() && ok) {\r\n        if(arg.dash()) {\r\n          final char ca = arg.next();\r\n          if(ca == 'u') {\r\n            updateTimes(Arrays.copyOfRange(args, 1, args.length));\r\n            return false;\r\n          } else if(ca == 'x') {\r\n            convertTopics();\r\n            return false;\r\n          }\r\n          ok = false;\r\n        }\r\n      }\r\n      if(ok) {\r\n        session = new ClientSession(ctx, ADMIN, ADMIN);\r\n        session.execute(new Set(Prop.INFO, true));\r\n      } else {\r\n        Main.outln(\"Usage: \" + Main.name(this) + \" [options]\" + NL +\r\n          \"  -u[...] update submission times\" + NL +\r\n          \"  -x      convert queries\");\r\n      }\r\n    } catch(final Exception ex) {\r\n      ok = false;\r\n      Main.errln(\"Please run BaseXServer for using server mode.\");\r\n      ex.printStackTrace();\r\n    }\r\n\r\n    return ok;\r\n  }","id":9337,"modified_method":"/**\r\n   * Parses the command line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args, this, \" [-ux]\" + NL +\r\n        \"  -u[...] update submission times\" + NL +\r\n        \"  -x      convert queries\");\r\n    try {\r\n      while(arg.more()) {\r\n        if(arg.dash()) {\r\n          final char ca = arg.next();\r\n          if(ca == 'u') {\r\n            updateTimes(Arrays.copyOfRange(args, 1, args.length));\r\n            return false;\r\n          } else if(ca == 'x') {\r\n            convertTopics();\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      if(!arg.finish()) return false;\r\n\r\n      session = new ClientSession(ctx, ADMIN, ADMIN);\r\n      session.execute(new Set(Prop.INFO, true));\r\n      return true;\r\n    } catch(final Exception ex) {\r\n      Main.errln(\"Please run BaseXServer for using server mode.\");\r\n      ex.printStackTrace();\r\n      return false;\r\n    }\r\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Parses the command line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args);\r\n    boolean ok = true;\r\n    try {\r\n      while(arg.more() && ok) {\r\n        if(arg.dash()) {\r\n          final char ca = arg.next();\r\n          if(ca == 'd') {\r\n            databases.add(arg.string());\r\n          } else ok = false;\r\n        }\r\n      }\r\n      if(ok) {\r\n        session = new ClientSession(ctx, ADMIN, ADMIN);\r\n        session.execute(new Set(Prop.INFO, true));\r\n        session.execute(new Set(Prop.ALLINFO, false));\r\n      } else {\r\n        Main.outln(\"Usage: \" + Main.name(this) + \" [options]\" + NL +\r\n          \"  -d database\");\r\n      }\r\n    } catch(final Exception ex) {\r\n      ok = false;\r\n      Main.errln(\"Please run BaseXServer for using server mode.\");\r\n      ex.printStackTrace();\r\n    }\r\n\r\n    return ok;\r\n  }","id":9338,"modified_method":"/**\r\n   * Parses the command line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args, this, \" [options]\" + NL +\r\n      \"  -d database\");\r\n    while(arg.more()) {\r\n      if(arg.dash()) {\r\n        final char ca = arg.next();\r\n        if(ca == 'd') {\r\n          databases.add(arg.string());\r\n        } else {\r\n          arg.check(false);\r\n        }\r\n      }\r\n    }\r\n    if(!arg.finish()) return false;\r\n\r\n    try {\r\n      session = new ClientSession(ctx, ADMIN, ADMIN);\r\n      session.execute(new Set(Prop.INFO, true));\r\n      session.execute(new Set(Prop.ALLINFO, false));\r\n      return true;\r\n    } catch(final Exception ex) {\r\n      Main.outln(\"Please run BaseXServer for using server mode.\");\r\n      ex.printStackTrace();\r\n      return false;\r\n    }\r\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Parses the command-line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args);\r\n    boolean ok = true;\r\n    try {\r\n      while(arg.more() && ok) {\r\n        if(arg.dash()) {\r\n          final char c = arg.next();\r\n          if(c == 'd') {\r\n            dbindex = arg.num();\r\n          } else if(c == 'q') {\r\n            quindex = arg.num();\r\n          } else if(c == 'r') {\r\n            runs = arg.num();\r\n          } else if(c == 'v') {\r\n            info = true;\r\n          } else if(c == 'b') {\r\n            budget = arg.num();\r\n          } else {\r\n            ok = false;\r\n          }\r\n        } else {\r\n          ok = false;\r\n        }\r\n      }\r\n\r\n      session = new ClientSession(ctx, ADMIN, ADMIN);\r\n      session.execute(new Set(Prop.INFO, true));\r\n      session.execute(new Set(Prop.ALLINFO, info));\r\n    } catch(final Exception ex) {\r\n      ex.printStackTrace();\r\n      ok = false;\r\n    }\r\n\r\n    if(!ok) {\r\n      Main.outln(\"Usage: \" + Main.name(this) + \" [options]\" + NL +\r\n        \"  -d<no>  use specified database (0-9)\" + NL +\r\n        \"  -q<no>  perform specified query (1-#queries)\" + NL +\r\n        \"  -r<no>  number of runs\" + NL +\r\n        \"  -v      show process info\");\r\n    }\r\n    return ok;\r\n  }","id":9339,"modified_method":"/**\r\n   * Parses the command-line arguments.\r\n   * @param args command-line arguments\r\n   * @return true if all arguments have been correctly parsed\r\n   */\r\n  private boolean parseArguments(final String[] args) {\r\n    final Args arg = new Args(args, this,\r\n        \" [options]\" + NL +\r\n        \"  -d<no>  use specified database (0-9)\" + NL +\r\n        \"  -q<no>  perform specified query (1-#queries)\" + NL +\r\n        \"  -r<no>  number of runs\" + NL +\r\n        \"  -v      show process info\");\r\n\r\n    while(arg.more()) {\r\n      if(arg.dash()) {\r\n        final char c = arg.next();\r\n        if(c == 'd') {\r\n          dbindex = arg.num();\r\n        } else if(c == 'q') {\r\n          quindex = arg.num();\r\n        } else if(c == 'r') {\r\n          runs = arg.num();\r\n        } else if(c == 'v') {\r\n          info = true;\r\n        } else if(c == 'b') {\r\n          budget = arg.num();\r\n        } else {\r\n          arg.check(false);\r\n        }\r\n      } else {\r\n        arg.check(false);\r\n      }\r\n    }\r\n    if(!arg.finish()) return false;\r\n    \r\n    try {\r\n      session = new ClientSession(ctx, ADMIN, ADMIN);\r\n      session.execute(new Set(Prop.INFO, true));\r\n      session.execute(new Set(Prop.ALLINFO, info));\r\n      return true;\r\n    } catch(final Exception ex) {\r\n      ex.printStackTrace();\r\n      return false;\r\n    }\r\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Initializes the code.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  void init(final String[] args) throws Exception {\n    final Args arg = new Args(args);\n    boolean o = true;\n    while(arg.more() && o) {\n      if(arg.dash()) {\n        final char c = arg.next();\n        if(c == 'r') {\n          reporting = true;\n          currTime = true;\n        } else if(c == 'c') {\n          compile = true;\n        } else if(c == 'd') {\n          debug = true;\n        } else if(c == 'm') {\n          minimum = true;\n        } else if(c == 'p') {\n          path = arg.string() + \"/\";\n        } else if(c == 'v') {\n          verbose = true;\n        } else {\n          o = false;\n        }\n      } else {\n        single = arg.string();\n        maxout = Integer.MAX_VALUE;\n      }\n    }\n\n    if(!o) {\n      Main.outln(NL + Main.name(this) + \" Test Suite [pat]\" + NL +\n          \" [pat] perform only tests with the specified pattern\" + NL +\n          \" -c print compilation steps\" + NL +\n          \" -d show debugging info\" + NL +\n          \" -h show this help\" + NL +\n          \" -m minimum conformance\" + NL +\n          \" -p change path\" + NL +\n          \" -r create report\" + NL +\n          \" -v verbose output\");\n      return;\n    }\n\n    queries = path + \"Queries/XQuery/\";\n    expected = path + \"ExpectedTestResults/\";\n    results = path + \"ReportingResults/Results/\";\n    report = path + \"ReportingResults/\";\n    sources = path + \"TestSources/\";\n\n    final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    final String dat = sdf.format(Calendar.getInstance().getTime());\n\n    final Performance perf = new Performance();\n    context.prop.set(Prop.MAINMEM, false);\n    context.prop.set(Prop.TABLEMEM, false);\n    context.prop.set(Prop.CHOP, false);\n\n    new CreateDB(path + input).exec(context);\n    data = context.data;\n\n    final Nodes root = new Nodes(0, data);\n    Main.outln(NL + Main.name(this) + \" Test Suite \" +\n        text(\"/*:test-suite/@version\", root));\n\n    Main.outln(NL + \"Caching Sources...\");\n    for(final int s : nodes(\"//*:source\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      srcs.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Modules...\");\n    for(final int s : nodes(\"//*:module\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      mods.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Collections...\");\n    for(final int c : nodes(\"//*:collection\", root).nodes) {\n      final Nodes nodes = new Nodes(c, data);\n      final String cname = text(\"@ID\", nodes);\n\n      final TokenList dl = new TokenList();\n      final Nodes doc = nodes(\"*:input-document\", nodes);\n      for(int d = 0; d < doc.size(); d++) {\n        dl.add(token(sources + string(data.atom(doc.nodes[d])) + IO.XMLSUFFIX));\n      }\n      colls.put(cname, dl.finish());\n    }\n    init(root);\n\n    if(reporting) {\n      Main.outln(\"Delete old results...\");\n      delete(new File[] { new File(results) });\n    }\n\n    if(verbose) Main.outln();\n    final Nodes nodes = minimum ?\n      nodes(\"//*:test-group[starts-with(@name, 'Minim')]//*:test-case\", root) :\n      nodes(\"//*:test-case\", root);\n\n    int total = nodes.size();\n    Main.out(\"Parsing \" + total + \" Queries\");\n    for(int t = 0; t < total; t++) {\n      if(!parse(new Nodes(nodes.nodes[t], data))) break;\n      if(!verbose && t % 500 == 0) Main.out(\".\");\n    }\n    Main.outln();\n    total = ok + ok2 + err + err2;\n\n    final String time = perf.getTimer();\n    Main.outln(\"Writing log file...\" + NL);\n    BufferedWriter bw = new BufferedWriter(\n        new OutputStreamWriter(new FileOutputStream(path + pathlog), UTF8));\n    bw.write(\"TEST RESULTS ==================================================\");\n    bw.write(NL + NL + \"Total #Queries: \" + total + NL);\n    bw.write(\"Correct / Empty Results: \" + ok + \" / \" + ok2 + NL);\n    bw.write(\"Conformance (w/Empty Results): \");\n    bw.write(pc(ok, total) + \" / \" + pc(ok + ok2, total) + NL);\n    bw.write(\"Wrong Results / Errors: \" + err + \" / \" + err2 + NL);\n    bw.write(\"WRONG =========================================================\");\n    bw.write(NL + NL + logErr + NL);\n    bw.write(\"WRONG (ERRORS) ================================================\");\n    bw.write(NL + NL + logErr2 + NL);\n    bw.write(\"CORRECT? (EMPTY) ==============================================\");\n    bw.write(NL + NL + logOK2 + NL);\n    bw.write(\"CORRECT =======================================================\");\n    bw.write(NL + NL + logOK + NL);\n    bw.write(\"===============================================================\");\n    bw.close();\n\n    bw = new BufferedWriter(new FileWriter(path + pathhis, true));\n    bw.write(dat + \"\\t\" + ok + \"\\t\" + ok2 + \"\\t\" + err + \"\\t\" + err2 + NL);\n    bw.close();\n\n    if(reporting) {\n      bw = new BufferedWriter(new OutputStreamWriter(\n          new FileOutputStream(report + NAME + IO.XMLSUFFIX), UTF8));\n      write(bw, report + NAME + \"Pre\" + IO.XMLSUFFIX);\n      bw.write(logReport.toString());\n      write(bw, report + NAME + \"Pos\" + IO.XMLSUFFIX);\n      bw.close();\n    }\n\n    Main.outln(\"Total #Queries: \" + total);\n    Main.outln(\"Correct / Empty results: \" + ok + \" / \" + ok2);\n    Main.out(\"Conformance (w/empty results): \");\n    Main.outln(pc(ok, total) + \" / \" + pc(ok + ok2, total));\n    Main.outln(\"Total Time: \" + time);\n\n    context.close();\n  }","id":9340,"modified_method":"/**\n   * Runs the test suite.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  void run(final String[] args) throws Exception {\n    final Args arg = new Args(args, this,\n        \" Test Suite [options] [pat]\" + NL +\n        \" [pat] perform only tests with the specified pattern\" + NL +\n        \" -c print compilation steps\" + NL +\n        \" -d show debugging info\" + NL +\n        \" -h show this help\" + NL +\n        \" -m minimum conformance\" + NL +\n        \" -p change path\" + NL +\n        \" -r create report\" + NL +\n        \" -v verbose output\");\n\n    while(arg.more()) {\n      if(arg.dash()) {\n        final char c = arg.next();\n        if(c == 'r') {\n          reporting = true;\n          currTime = true;\n        } else if(c == 'c') {\n          compile = true;\n        } else if(c == 'd') {\n          debug = true;\n        } else if(c == 'm') {\n          minimum = true;\n        } else if(c == 'p') {\n          path = arg.string() + \"/\";\n        } else if(c == 'v') {\n          verbose = true;\n        } else {\n          arg.check(false);\n        }\n      } else {\n        single = arg.string();\n        maxout = Integer.MAX_VALUE;\n      }\n    }\n    if(!arg.finish()) return;\n\n    queries = path + \"Queries/XQuery/\";\n    expected = path + \"ExpectedTestResults/\";\n    results = path + \"ReportingResults/Results/\";\n    report = path + \"ReportingResults/\";\n    sources = path + \"TestSources/\";\n\n    final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    final String dat = sdf.format(Calendar.getInstance().getTime());\n\n    final Performance perf = new Performance();\n    context.prop.set(Prop.MAINMEM, false);\n    context.prop.set(Prop.TABLEMEM, false);\n    context.prop.set(Prop.CHOP, false);\n\n    new CreateDB(path + input).exec(context);\n    data = context.data;\n\n    final Nodes root = new Nodes(0, data);\n    Main.outln(NL + Main.name(this) + \" Test Suite \" +\n        text(\"/*:test-suite/@version\", root));\n\n    Main.outln(NL + \"Caching Sources...\");\n    for(final int s : nodes(\"//*:source\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      srcs.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Modules...\");\n    for(final int s : nodes(\"//*:module\", root).nodes) {\n      final Nodes srcRoot = new Nodes(s, data);\n      final String val = (path + text(\"@FileName\", srcRoot)).replace('\\\\', '/');\n      mods.put(text(\"@ID\", srcRoot), val);\n    }\n\n    Main.outln(\"Caching Collections...\");\n    for(final int c : nodes(\"//*:collection\", root).nodes) {\n      final Nodes nodes = new Nodes(c, data);\n      final String cname = text(\"@ID\", nodes);\n\n      final TokenList dl = new TokenList();\n      final Nodes doc = nodes(\"*:input-document\", nodes);\n      for(int d = 0; d < doc.size(); d++) {\n        dl.add(token(sources + string(data.atom(doc.nodes[d])) + IO.XMLSUFFIX));\n      }\n      colls.put(cname, dl.finish());\n    }\n    init(root);\n\n    if(reporting) {\n      Main.outln(\"Delete old results...\");\n      delete(new File[] { new File(results) });\n    }\n\n    if(verbose) Main.outln();\n    final Nodes nodes = minimum ?\n      nodes(\"//*:test-group[starts-with(@name, 'Minim')]//*:test-case\", root) :\n      nodes(\"//*:test-case\", root);\n\n    int total = nodes.size();\n    Main.out(\"Parsing \" + total + \" Queries\");\n    for(int t = 0; t < total; t++) {\n      if(!parse(new Nodes(nodes.nodes[t], data))) break;\n      if(!verbose && t % 500 == 0) Main.out(\".\");\n    }\n    Main.outln();\n    total = ok + ok2 + err + err2;\n\n    final String time = perf.getTimer();\n    Main.outln(\"Writing log file...\" + NL);\n    BufferedWriter bw = new BufferedWriter(\n        new OutputStreamWriter(new FileOutputStream(path + pathlog), UTF8));\n    bw.write(\"TEST RESULTS ==================================================\");\n    bw.write(NL + NL + \"Total #Queries: \" + total + NL);\n    bw.write(\"Correct / Empty Results: \" + ok + \" / \" + ok2 + NL);\n    bw.write(\"Conformance (w/Empty Results): \");\n    bw.write(pc(ok, total) + \" / \" + pc(ok + ok2, total) + NL);\n    bw.write(\"Wrong Results / Errors: \" + err + \" / \" + err2 + NL);\n    bw.write(\"WRONG =========================================================\");\n    bw.write(NL + NL + logErr + NL);\n    bw.write(\"WRONG (ERRORS) ================================================\");\n    bw.write(NL + NL + logErr2 + NL);\n    bw.write(\"CORRECT? (EMPTY) ==============================================\");\n    bw.write(NL + NL + logOK2 + NL);\n    bw.write(\"CORRECT =======================================================\");\n    bw.write(NL + NL + logOK + NL);\n    bw.write(\"===============================================================\");\n    bw.close();\n\n    bw = new BufferedWriter(new FileWriter(path + pathhis, true));\n    bw.write(dat + \"\\t\" + ok + \"\\t\" + ok2 + \"\\t\" + err + \"\\t\" + err2 + NL);\n    bw.close();\n\n    if(reporting) {\n      bw = new BufferedWriter(new OutputStreamWriter(\n          new FileOutputStream(report + NAME + IO.XMLSUFFIX), UTF8));\n      write(bw, report + NAME + \"Pre\" + IO.XMLSUFFIX);\n      bw.write(logReport.toString());\n      write(bw, report + NAME + \"Pos\" + IO.XMLSUFFIX);\n      bw.close();\n    }\n\n    Main.outln(\"Total #Queries: \" + total);\n    Main.outln(\"Correct / Empty results: \" + ok + \" / \" + ok2);\n    Main.out(\"Conformance (w/empty results): \");\n    Main.outln(pc(ok, total) + \" / \" + pc(ok + ok2, total));\n    Main.outln(\"Total Time: \" + time);\n\n    context.close();\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Main method of the test class.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  public static void main(final String[] args) throws Exception {\n    new XQFTTS().init(args);\n  }","id":9341,"modified_method":"/**\n   * Main method of the test class.\n   * @param args command-line arguments\n   * @throws Exception exception\n   */\n  public static void main(final String[] args) throws Exception {\n    new XQFTTS().run(args);\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Main method of the test class.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  public static void main(final String[] args) throws Exception {\r\n    new XQTS().init(args);\r\n  }","id":9342,"modified_method":"/**\r\n   * Main method of the test class.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  public static void main(final String[] args) throws Exception {\r\n    new XQTS().run(args);\r\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Main method of the test class.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  public static void main(final String[] args) throws Exception {\r\n    new XQUTS().init(args);\r\n  }","id":9343,"modified_method":"/**\r\n   * Main method of the test class.\r\n   * @param args command-line arguments\r\n   * @throws Exception exception\r\n   */\r\n  public static void main(final String[] args) throws Exception {\r\n    new XQUTS().run(args);\r\n  }","commit_id":"d18bc08945e277cfa4923c036a420cbd85a75fe7","url":"https://github.com/BaseXdb/basex"},{"original_method":"public boolean performAction( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n\n        // should actually apply the configuration before redirecting\n        if ( request.getParameter( \"apply\" ) != null )\n        {\n            return applyConfiguration( request );\n        }\n\n        JSONObject result = new JSONObject();\n\n        String pid = request.getParameter( ConfigManager.PID );\n        boolean isFactory = pid == null;\n        if ( isFactory )\n        {\n            pid = request.getParameter( \"factoryPid\" );\n        }\n\n        if ( pid != null )\n        {\n            try\n            {\n                this.configForm( result, pid, isFactory, getLocale( request ) );\n            }\n            catch ( Exception e )\n            {\n                // add message\n            }\n        }\n\n        // send the result\n        response.setContentType( \"text/javascript\" );\n        response.getWriter().print( result.toString() );\n\n        return false;\n    }","id":9344,"modified_method":"public boolean performAction( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n\n        // needed multiple times below\n        String pid = request.getParameter( ConfigManager.PID );\n\n        // should actually apply the configuration before redirecting\n        if ( request.getParameter( \"create\" ) != null && pid != null )\n        {\n            ConfigurationAdmin ca = this.getConfigurationAdmin();\n            if ( ca != null )\n            {\n                Configuration config = ca.createFactoryConfiguration( pid, null );\n                pid = config.getPid();\n            }\n        }\n        else if ( request.getParameter( \"apply\" ) != null )\n        {\n            return applyConfiguration( request );\n        }\n\n        boolean isFactory = pid == null;\n        if ( isFactory )\n        {\n            pid = request.getParameter( \"factoryPid\" );\n        }\n\n        // send the result\n        response.setContentType( \"text/javascript\" );\n        response.setCharacterEncoding( \"UTF-8\" );\n\n        JSONWriter result = new JSONWriter( response.getWriter() );\n\n        if ( pid != null )\n        {\n            try\n            {\n                result.object();\n                this.configForm( result, pid, isFactory, getLocale( request ) );\n                result.endObject();\n            }\n            catch ( Exception e )\n            {\n                // add message\n            }\n        }\n\n        return false;\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"private void configForm( JSONObject json, String pid, boolean isFactory, Locale loc ) throws IOException,\n        JSONException\n    {\n        String locale = ( loc == null ) ? null : loc.toString();\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            // should print message\n            return;\n        }\n\n        Configuration config = null;\n        try\n        {\n            Configuration[] configs = ca.listConfigurations( \"(\" + Constants.SERVICE_PID + \"=\" + pid + \")\" );\n            if ( configs != null && configs.length > 0 )\n            {\n                config = configs[0];\n            }\n        }\n        catch ( InvalidSyntaxException ise )\n        {\n            // should print message\n            return;\n        }\n\n        json.put( ConfigManager.PID, pid );\n        json.put( \"isFactory\", isFactory );\n\n        Dictionary props = null;\n        ObjectClassDefinition ocd;\n        if ( config != null )\n        {\n            props = config.getProperties();\n            ocd = this.getObjectClassDefinition( config, locale );\n        }\n        else\n        {\n            ocd = this.getObjectClassDefinition( pid, locale );\n        }\n\n        props = this.mergeWithMetaType( props, ocd, json );\n\n        if ( props != null )\n        {\n            JSONObject properties = new JSONObject();\n            for ( Enumeration pe = props.keys(); pe.hasMoreElements(); )\n            {\n                Object key = pe.nextElement();\n\n                // ignore well known special properties\n                if ( !key.equals( Constants.SERVICE_PID ) && !key.equals( Constants.SERVICE_DESCRIPTION )\n                    && !key.equals( Constants.SERVICE_ID ) && !key.equals( Constants.SERVICE_RANKING )\n                    && !key.equals( Constants.SERVICE_VENDOR )\n                    && !key.equals( ConfigurationAdmin.SERVICE_BUNDLELOCATION )\n                    && !key.equals( ConfigurationAdmin.SERVICE_FACTORYPID ) )\n                {\n                    properties.put( String.valueOf( key ), props.get( key ) );\n                }\n\n            }\n\n            json.put( \"title\", pid );\n            json\n                .put(\n                    \"description\",\n                    \"Please enter configuration properties for this configuration in the field below. This configuration has no associated description\" );\n\n            json.put( \"propertylist\", \"properties\" );\n            json.put( \"properties\", properties );\n\n        }\n\n        if ( config != null )\n        {\n            this.addConfigurationInfo( config, json, locale );\n        }\n    }","id":9345,"modified_method":"private void configForm( JSONWriter json, String pid, boolean isFactory, Locale loc ) throws IOException,\n        JSONException\n    {\n        String locale = ( loc == null ) ? null : loc.toString();\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            // should print message\n            return;\n        }\n\n        Configuration config = null;\n        try\n        {\n            Configuration[] configs = ca.listConfigurations( \"(\" + Constants.SERVICE_PID + \"=\" + pid + \")\" );\n            if ( configs != null && configs.length > 0 )\n            {\n                config = configs[0];\n            }\n        }\n        catch ( InvalidSyntaxException ise )\n        {\n            // should print message\n            return;\n        }\n\n        json.key( ConfigManager.PID );\n        json.value( pid );\n        json.key( \"isFactory\" );\n        json.value( isFactory );\n\n        Dictionary props = null;\n        ObjectClassDefinition ocd;\n        if ( config != null )\n        {\n            props = config.getProperties();\n            ocd = this.getObjectClassDefinition( config, locale );\n        }\n        else\n        {\n            ocd = this.getObjectClassDefinition( pid, locale );\n        }\n\n        props = this.mergeWithMetaType( props, ocd, json );\n\n        if ( props != null )\n        {\n\n            json.key( \"title\" );\n            json.value( pid );\n            json.key( \"description\" );\n            json\n                .value( \"Please enter configuration properties for this configuration in the field below. This configuration has no associated description\" );\n\n            json.key( \"propertylist\" );\n            json.value( \"properties\" );\n\n            json.key( \"properties\" );\n            json.object();\n            for ( Enumeration pe = props.keys(); pe.hasMoreElements(); )\n            {\n                Object key = pe.nextElement();\n\n                // ignore well known special properties\n                if ( !key.equals( Constants.SERVICE_PID ) && !key.equals( Constants.SERVICE_DESCRIPTION )\n                    && !key.equals( Constants.SERVICE_ID ) && !key.equals( Constants.SERVICE_RANKING )\n                    && !key.equals( Constants.SERVICE_VENDOR )\n                    && !key.equals( ConfigurationAdmin.SERVICE_BUNDLELOCATION )\n                    && !key.equals( ConfigurationAdmin.SERVICE_FACTORYPID ) )\n                {\n                    json.key( String.valueOf( key ) );\n                    json.value( props.get( key ) );\n                }\n            }\n            json.endObject();\n\n        }\n\n        if ( config != null )\n        {\n            this.addConfigurationInfo( config, json, locale );\n        }\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"private Dictionary mergeWithMetaType( Dictionary props, ObjectClassDefinition ocd, JSONObject json )\n        throws JSONException\n    {\n\n        if ( props == null )\n        {\n            props = new Hashtable();\n        }\n\n        if ( ocd != null )\n        {\n\n            json.put( \"title\", ocd.getName() );\n\n            if ( ocd.getDescription() != null )\n            {\n                json.put( \"description\", ocd.getDescription() );\n            }\n\n            AttributeDefinition[] ad = ocd.getAttributeDefinitions( ObjectClassDefinition.ALL );\n            if ( ad != null )\n            {\n\n                JSONArray propertyList = new JSONArray();\n\n                for ( int i = 0; i < ad.length; i++ )\n                {\n                    JSONObject entry = new JSONObject();\n\n                    Object value = props.get( ad[i].getID() );\n                    if ( value == null )\n                    {\n                        value = ad[i].getDefaultValue();\n                        if ( value == null )\n                        {\n                            if ( ad[i].getCardinality() == 0 )\n                            {\n                                value = \"\";\n                            }\n                            else\n                            {\n                                value = new String[0];\n                            }\n                        }\n                    }\n\n                    entry.put( \"name\", ad[i].getName() );\n\n                    if ( ad[i].getOptionLabels() != null && ad[i].getOptionLabels().length > 0 )\n                    {\n                        JSONObject type = new JSONObject();\n                        type.put( \"labels\", Arrays.asList( ad[i].getOptionLabels() ) );\n                        type.put( \"values\", Arrays.asList( ad[i].getOptionValues() ) );\n                        entry.put( \"type\", type );\n                    }\n                    else\n                    {\n                        entry.put( \"type\", ad[i].getType() );\n                    }\n\n                    if ( ad[i].getCardinality() == 0 )\n                    {\n                        // scalar\n                        if ( value instanceof Vector )\n                        {\n                            value = ( ( Vector ) value ).get( 0 );\n                        }\n                        else if ( value.getClass().isArray() )\n                        {\n                            value = Array.get( value, 0 );\n                        }\n                        entry.put( \"value\", value );\n                    }\n                    else\n                    {\n                        if ( value instanceof Vector )\n                        {\n                            value = new JSONArray( ( Vector ) value );\n                        }\n                        else if ( value.getClass().isArray() )\n                        {\n                            value = new JSONArray( Arrays.asList( ( Object[] ) value ) );\n                        }\n                        else\n                        {\n                            JSONArray tmp = new JSONArray();\n                            tmp.put( value );\n                            value = tmp;\n                        }\n                        entry.put( \"values\", value );\n                    }\n\n                    if ( ad[i].getDescription() != null )\n                    {\n                        entry.put( \"description\", ad[i].getDescription() );\n                    }\n\n                    json.put( ad[i].getID(), entry );\n                    propertyList.put( ad[i].getID() );\n                }\n\n                json.put( \"propertylist\", propertyList );\n            }\n\n            // nothing more to display\n            props = null;\n        }\n\n        return props;\n    }","id":9346,"modified_method":"private Dictionary mergeWithMetaType( Dictionary props, ObjectClassDefinition ocd, JSONWriter json )\n        throws JSONException\n    {\n\n        if ( props == null )\n        {\n            props = new Hashtable();\n        }\n\n        if ( ocd != null )\n        {\n\n            json.key( \"title\" );\n            json.value( ocd.getName() );\n\n            if ( ocd.getDescription() != null )\n            {\n                json.key( \"description\" );\n                json.value( ocd.getDescription() );\n            }\n\n            AttributeDefinition[] ad = ocd.getAttributeDefinitions( ObjectClassDefinition.ALL );\n            if ( ad != null )\n            {\n\n                JSONArray propertyList = new JSONArray();\n\n                for ( int i = 0; i < ad.length; i++ )\n                {\n                    json.key( ad[i].getID() );\n                    json.object();\n\n                    Object value = props.get( ad[i].getID() );\n                    if ( value == null )\n                    {\n                        value = ad[i].getDefaultValue();\n                        if ( value == null )\n                        {\n                            if ( ad[i].getCardinality() == 0 )\n                            {\n                                value = \"\";\n                            }\n                            else\n                            {\n                                value = new String[0];\n                            }\n                        }\n                    }\n\n                    json.key( \"name\" );\n                    json.value( ad[i].getName() );\n\n                    json.key( \"type\" );\n                    if ( ad[i].getOptionLabels() != null && ad[i].getOptionLabels().length > 0 )\n                    {\n                        json.object();\n                        json.key( \"labels\" );\n                        json.value( Arrays.asList( ad[i].getOptionLabels() ) );\n                        json.key( \"values\" );\n                        json.value( Arrays.asList( ad[i].getOptionValues() ) );\n                        json.endObject();\n                    }\n                    else\n                    {\n                        json.value( ad[i].getType() );\n                    }\n\n                    if ( ad[i].getCardinality() == 0 )\n                    {\n                        // scalar\n                        if ( value instanceof Vector )\n                        {\n                            value = ( ( Vector ) value ).get( 0 );\n                        }\n                        else if ( value.getClass().isArray() )\n                        {\n                            value = Array.get( value, 0 );\n                        }\n                        json.key( \"value\" );\n                        json.value( value );\n                    }\n                    else\n                    {\n                        if ( value instanceof Vector )\n                        {\n                            value = new JSONArray( ( Vector ) value );\n                        }\n                        else if ( value.getClass().isArray() )\n                        {\n                            value = new JSONArray( Arrays.asList( ( Object[] ) value ) );\n                        }\n                        else\n                        {\n                            JSONArray tmp = new JSONArray();\n                            tmp.put( value );\n                            value = tmp;\n                        }\n                        json.key( \"values\" );\n                        json.value( value );\n                    }\n\n                    if ( ad[i].getDescription() != null )\n                    {\n                        json.key( \"description\" );\n                        json.value( ad[i].getDescription() );\n                    }\n\n                    json.endObject();\n                    propertyList.put( ad[i].getID() );\n                }\n\n                json.key( \"propertylist\" );\n                json.value( propertyList );\n            }\n\n            // nothing more to display\n            props = null;\n        }\n\n        return props;\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"private boolean applyConfiguration( HttpServletRequest request ) throws IOException\n    {\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            return false;\n        }\n\n        String pid = request.getParameter( \"pid\" );\n\n        if ( request.getParameter( \"delete\" ) != null )\n        {\n            // TODO: should log this here !!\n            Configuration config = ca.getConfiguration( pid, null );\n            config.delete();\n            return true;\n        }\n        else if ( request.getParameter( \"create\" ) != null )\n        {\n            // pid is a factory PID and we have to create a new configuration\n            // we should actually also display that one !\n            Configuration config = ca.createFactoryConfiguration( pid, null );\n\n            // request.setAttribute(ATTR_REDIRECT_PARAMETERS, \"pid=\" +\n            // config.getPid());\n            return true;\n        }\n\n        String propertyList = request.getParameter( \"propertylist\" );\n        if ( propertyList == null )\n        {\n            String propertiesString = request.getParameter( \"properties\" );\n\n            if ( propertiesString != null )\n            {\n                byte[] propBytes = propertiesString.getBytes( \"ISO-8859-1\" );\n                ByteArrayInputStream bin = new ByteArrayInputStream( propBytes );\n                Properties props = new Properties();\n                props.load( bin );\n\n                Configuration config = ca.getConfiguration( pid, null );\n                config.update( props );\n            }\n        }\n        else\n        {\n            Configuration config = ca.getConfiguration( pid, null );\n            Dictionary props = config.getProperties();\n            if ( props == null )\n            {\n                props = new Hashtable();\n            }\n\n            Map adMap = ( Map ) this.getAttributeDefinitionMap( config, null );\n            if ( adMap != null )\n            {\n                StringTokenizer propTokens = new StringTokenizer( propertyList, \",\" );\n                while ( propTokens.hasMoreTokens() )\n                {\n                    String propName = propTokens.nextToken();\n                    AttributeDefinition ad = ( AttributeDefinition ) adMap.get( propName );\n                    if ( ad == null || ( ad.getCardinality() == 0 && ad.getType() == AttributeDefinition.STRING ) )\n                    {\n                        String prop = request.getParameter( propName );\n                        if ( prop != null )\n                        {\n                            props.put( propName, prop );\n                        }\n                    }\n                    else if ( ad.getCardinality() == 0 )\n                    {\n                        // scalar of non-string\n                        String prop = request.getParameter( propName );\n                        props.put( propName, this.toType( ad.getType(), prop ) );\n                    }\n                    else\n                    {\n                        // array or vector of any type\n                        Vector vec = new Vector();\n\n                        String[] properties = request.getParameterValues( propName );\n                        if ( properties != null )\n                        {\n                            for ( int i = 0; i < properties.length; i++ )\n                            {\n                                vec.add( this.toType( ad.getType(), properties[i] ) );\n                            }\n                        }\n\n                        // but ensure size\n                        int maxSize = Math.abs( ad.getCardinality() );\n                        if ( vec.size() > maxSize )\n                        {\n                            vec.setSize( maxSize );\n                        }\n\n                        if ( ad.getCardinality() < 0 )\n                        {\n                            // keep the vector\n                            props.put( propName, vec );\n                        }\n                        else\n                        {\n                            // convert to an array\n                            props.put( propName, this.toArray( ad.getType(), vec ) );\n                        }\n                    }\n                }\n            }\n\n            config.update( props );\n        }\n\n        // request.setAttribute(ATTR_REDIRECT_PARAMETERS, \"pid=\" + pid);\n        return true;\n    }","id":9347,"modified_method":"private boolean applyConfiguration( HttpServletRequest request ) throws IOException\n    {\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            return false;\n        }\n\n        String pid = request.getParameter( \"pid\" );\n\n        if ( request.getParameter( \"delete\" ) != null )\n        {\n            // TODO: should log this here !!\n            Configuration config = ca.getConfiguration( pid, null );\n            config.delete();\n            return true;\n        }\n        else if ( request.getParameter( \"create\" ) != null )\n        {\n            // pid is a factory PID and we have to create a new configuration\n            // we should actually also display that one !\n            Configuration config = ca.createFactoryConfiguration( pid, null );\n\n            // request.setAttribute(ATTR_REDIRECT_PARAMETERS, \"pid=\" +\n            // config.getPid());\n            return false;\n        }\n\n        String propertyList = request.getParameter( \"propertylist\" );\n        if ( propertyList == null )\n        {\n            String propertiesString = request.getParameter( \"properties\" );\n\n            if ( propertiesString != null )\n            {\n                byte[] propBytes = propertiesString.getBytes( \"ISO-8859-1\" );\n                ByteArrayInputStream bin = new ByteArrayInputStream( propBytes );\n                Properties props = new Properties();\n                props.load( bin );\n\n                Configuration config = ca.getConfiguration( pid, null );\n                config.update( props );\n            }\n        }\n        else\n        {\n            Configuration config = ca.getConfiguration( pid, null );\n            Dictionary props = config.getProperties();\n            if ( props == null )\n            {\n                props = new Hashtable();\n            }\n\n            Map adMap = ( Map ) this.getAttributeDefinitionMap( config, null );\n            if ( adMap != null )\n            {\n                StringTokenizer propTokens = new StringTokenizer( propertyList, \",\" );\n                while ( propTokens.hasMoreTokens() )\n                {\n                    String propName = propTokens.nextToken();\n                    AttributeDefinition ad = ( AttributeDefinition ) adMap.get( propName );\n                    if ( ad == null || ( ad.getCardinality() == 0 && ad.getType() == AttributeDefinition.STRING ) )\n                    {\n                        String prop = request.getParameter( propName );\n                        if ( prop != null )\n                        {\n                            props.put( propName, prop );\n                        }\n                    }\n                    else if ( ad.getCardinality() == 0 )\n                    {\n                        // scalar of non-string\n                        String prop = request.getParameter( propName );\n                        props.put( propName, this.toType( ad.getType(), prop ) );\n                    }\n                    else\n                    {\n                        // array or vector of any type\n                        Vector vec = new Vector();\n\n                        String[] properties = request.getParameterValues( propName );\n                        if ( properties != null )\n                        {\n                            for ( int i = 0; i < properties.length; i++ )\n                            {\n                                vec.add( this.toType( ad.getType(), properties[i] ) );\n                            }\n                        }\n\n                        // but ensure size\n                        int maxSize = Math.abs( ad.getCardinality() );\n                        if ( vec.size() > maxSize )\n                        {\n                            vec.setSize( maxSize );\n                        }\n\n                        if ( ad.getCardinality() < 0 )\n                        {\n                            // keep the vector\n                            props.put( propName, vec );\n                        }\n                        else\n                        {\n                            // convert to an array\n                            props.put( propName, this.toArray( ad.getType(), vec ) );\n                        }\n                    }\n                }\n            }\n\n            config.update( props );\n        }\n\n        // request.setAttribute(ATTR_REDIRECT_PARAMETERS, \"pid=\" + pid);\n        return true;\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"private void addConfigurationInfo( Configuration config, JSONObject json, String locale ) throws JSONException\n    {\n\n        if ( config.getFactoryPid() != null )\n        {\n            json.put( \"factoryPID\", config.getFactoryPid() );\n        }\n\n        String location;\n        if ( config.getBundleLocation() == null )\n        {\n            location = \"None\";\n        }\n        else\n        {\n            Bundle bundle = this.getBundle( config.getBundleLocation() );\n\n            Dictionary headers = bundle.getHeaders( locale );\n            String name = ( String ) headers.get( Constants.BUNDLE_NAME );\n            if ( name == null )\n            {\n                location = bundle.getSymbolicName();\n            }\n            else\n            {\n                location = name + \" (\" + bundle.getSymbolicName() + \")\";\n            }\n\n            Version v = Version.parseVersion( ( String ) headers.get( Constants.BUNDLE_VERSION ) );\n            location += \", Version \" + v.toString();\n        }\n        json.put( \"bundleLocation\", location );\n    }","id":9348,"modified_method":"private void addConfigurationInfo( Configuration config, JSONWriter json, String locale ) throws JSONException\n    {\n\n        if ( config.getFactoryPid() != null )\n        {\n            json.key( \"factoryPID\" );\n            json.value( config.getFactoryPid() );\n        }\n\n        String location;\n        if ( config.getBundleLocation() == null )\n        {\n            location = \"None\";\n        }\n        else\n        {\n            Bundle bundle = this.getBundle( config.getBundleLocation() );\n\n            Dictionary headers = bundle.getHeaders( locale );\n            String name = ( String ) headers.get( Constants.BUNDLE_NAME );\n            if ( name == null )\n            {\n                location = bundle.getSymbolicName();\n            }\n            else\n            {\n                location = name + \" (\" + bundle.getSymbolicName() + \")\";\n            }\n\n            Version v = Version.parseVersion( ( String ) headers.get( Constants.BUNDLE_VERSION ) );\n            location += \", Version \" + v.toString();\n        }\n        json.key( \"bundleLocation\" );\n        json.value( location );\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"public void render( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n\n        // true if MetaType service information is not required\n        boolean optionalMetaType = false;\n\n        PrintWriter pw = response.getWriter();\n\n        pw.println( \"<script type='text/javascript' src='res/ui/configmanager.js'><\/script>\" );\n\n        pw.println( \"<table class='content' cellpadding='0' cellspacing='0' width='100%'>\" );\n\n        pw.println( \"<tr class='content' id='configField'>\" );\n        pw.println( \"<td class='content'>Configurations<\/th>\" );\n        pw.println( \"<td class='content'>\" );\n        this.listConfigurations( pw, optionalMetaType, getLocale( request ) );\n        pw.println( \"<\/td>\" );\n        pw.println( \"<\/tr>\" );\n\n        pw.println( \"<\/table>\" );\n    }","id":9349,"modified_method":"public void render( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n\n        // true if MetaType service information is not required\n        boolean optionalMetaType = false;\n\n        PrintWriter pw = response.getWriter();\n\n        pw.println( \"<script type='text/javascript' src='res/ui/configmanager.js'><\/script>\" );\n\n        pw.println( \"<table class='content' cellpadding='0' cellspacing='0' width='100%'>\" );\n\n        pw.println( \"<tr class='content' id='configField'>\" );\n        pw.println( \"<td class='content'>Configurations<\/th>\" );\n        pw.println( \"<td class='content'>\" );\n        this.listConfigurations( pw, optionalMetaType, getLocale( request ) );\n        pw.println( \"<\/td>\" );\n        pw.println( \"<\/tr>\" );\n\n        pw.println( \"<tr class='content' id='factoryField'>\" );\n        pw.println( \"<td class='content'>Factory Configurations<\/th>\" );\n        pw.println( \"<td class='content'>\" );\n        this.listFactoryConfigurations( pw, optionalMetaType, getLocale( request ) );\n        pw.println( \"<\/td>\" );\n        pw.println( \"<\/tr>\" );\n        \n        pw.println( \"<\/table>\" );\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"private void listConfigurations( PrintWriter pw, boolean optionalMetaType, Locale loc )\n    {\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            pw.print( \"Configuration Admin Service not available\" );\n            return;\n        }\n\n        String locale = ( loc != null ) ? loc.toString() : null;\n\n        try\n        {\n            // get a list of all pids for which MetaData exists\n            Map metaDataPids = this.getMetadataPids();\n\n            // sorted map of options\n            SortedMap options = new TreeMap( String.CASE_INSENSITIVE_ORDER );\n\n            // find all ManagedServiceFactories to get the factoryPIDs\n            ServiceReference[] refs = this.getBundleContext().getServiceReferences(\n                ManagedServiceFactory.class.getName(), null );\n            for ( int i = 0; refs != null && i < refs.length; i++ )\n            {\n                Object factoryPid = refs[i].getProperty( Constants.SERVICE_PID );\n                if ( factoryPid instanceof String )\n                {\n                    String pid = ( String ) factoryPid;\n                    String name;\n                    ObjectClassDefinition ocd = this.getObjectClassDefinition( refs[i].getBundle(), pid, locale );\n                    if ( ocd != null )\n                    {\n                        name = ocd.getName() + \" (\";\n                        name += pid + \")\";\n                    }\n                    else\n                    {\n                        name = pid;\n                    }\n\n                    if ( ocd != null || optionalMetaType )\n                    {\n                        options.put( \"factoryPid=\" + pid, name );\n                    }\n                }\n            }\n\n            // get a sorted list of configuration PIDs\n            Configuration[] cfgs = ca.listConfigurations( null );\n            for ( int i = 0; cfgs != null && i < cfgs.length; i++ )\n            {\n\n                // ignore configuration object if an entry already exists in the\n                // map\n                String pid = cfgs[i].getPid();\n                if ( options.containsKey( \"pid=\" + pid ) || options.containsKey( \"factoryPid=\" + pid ) )\n                {\n                    continue;\n                }\n\n                Dictionary props = cfgs[i].getProperties();\n\n                // insert and entry for the pid\n                ObjectClassDefinition ocd = this.getObjectClassDefinition( cfgs[i], locale );\n                String name;\n                if ( ocd != null )\n                {\n                    name = ocd.getName() + \" (\";\n                    name += pid + \")\";\n\n                    // remove from the list of known pids\n                    metaDataPids.remove( pid );\n\n                }\n                else\n                {\n                    name = pid;\n                }\n\n                if ( ocd != null || optionalMetaType )\n                {\n                    options.put( \"pid=\" + pid, name );\n                }\n\n                // if the configuration is part of a factory, ensure an entry\n                // for the factory\n                if ( cfgs[i].getFactoryPid() != null )\n                {\n                    pid = cfgs[i].getFactoryPid();\n                    if ( options.containsValue( \"factoryPid=\" + pid ) )\n                    {\n                        continue;\n                    }\n\n                    String existing = ( String ) options.remove( \"pid=\" + pid );\n                    if ( existing != null )\n                    {\n                        options.put( \"factoryPid=\" + pid, existing );\n                    }\n                    else\n                    {\n                        Bundle bundle = this.getBundle( cfgs[i].getBundleLocation() );\n                        ocd = this.getObjectClassDefinition( bundle, pid, locale );\n                        if ( ocd != null )\n                        {\n                            options.put( \"factoryPid=\" + pid, ocd.getName() );\n                        }\n                        else if ( optionalMetaType )\n                        {\n                            options.put( \"factoryPid=\" + pid, pid );\n                        }\n                    }\n                }\n            }\n\n            // If there are any meta data PIDs for which there is no existing\n            // configuration, we add them to the list to create configuration\n            if ( !metaDataPids.isEmpty() )\n            {\n                for ( Iterator mdpi = metaDataPids.entrySet().iterator(); mdpi.hasNext(); )\n                {\n                    Entry mdp = ( Entry ) mdpi.next();\n                    ObjectClassDefinition ocd = this.getObjectClassDefinition( ( Bundle ) mdp.getValue(),\n                        ( String ) mdp.getKey(), locale );\n                    options.put( \"pid=\" + mdp.getKey(), ocd.getName() + \" (\" + mdp.getKey() + \")\" );\n                }\n            }\n\n            pw.println( \"<form method='post' name='configSelection' onSubmit='configure(); return false;'\" );\n            pw.println( \"<input type='hidden' name='\" + Util.PARAM_ACTION + \"' value='\" + SetStartLevelAction.NAME\n                + \"'>\" );\n            pw.println( \"<select class='select' name='pid' onChange='configure();'>\" );\n            for ( Iterator ei = options.entrySet().iterator(); ei.hasNext(); )\n            {\n                Entry entry = ( Entry ) ei.next();\n                pw.print( \"<option value='\" + entry.getKey() + \"'>\" );\n                pw.print( entry.getValue() );\n                pw.println( \"<\/option>\" );\n            }\n            pw.println( \"<\/select>\" );\n            pw.println( \"&nbsp;&nbsp;\" );\n            pw.println( \"<input class='submit' type='submit' value='Configure' />\" );\n            pw.println( \"<\/form>\" );\n\n        }\n        catch ( Exception e )\n        {\n            // write a message or ignore\n        }\n    }","id":9350,"modified_method":"private void listConfigurations( PrintWriter pw, boolean optionalMetaType, Locale loc )\n    {\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            pw.print( \"Configuration Admin Service not available\" );\n            return;\n        }\n\n        String locale = ( loc != null ) ? loc.toString() : null;\n\n        try\n        {\n            // sorted map of options\n            SortedMap optionsPlain = new TreeMap( String.CASE_INSENSITIVE_ORDER );\n\n            // find all ManagedServices to get the PIDs\n            ServiceReference[] refs = this.getBundleContext().getServiceReferences( ManagedService.class.getName(),\n                null );\n            for ( int i = 0; refs != null && i < refs.length; i++ )\n            {\n                Object pidObject = refs[i].getProperty( Constants.SERVICE_PID );\n                if ( pidObject instanceof String )\n                {\n                    String pid = ( String ) pidObject;\n                    String name;\n                    ObjectClassDefinition ocd = this.getObjectClassDefinition( refs[i].getBundle(), pid, locale );\n                    if ( ocd != null )\n                    {\n                        name = ocd.getName() + \" (\";\n                        name += pid + \")\";\n                    }\n                    else\n                    {\n                        name = pid;\n                    }\n\n                    if ( ocd != null || optionalMetaType )\n                    {\n                        optionsPlain.put( pid, name );\n                    }\n                }\n            }\n\n            // get a sorted list of configuration PIDs\n            Configuration[] cfgs = ca.listConfigurations( null );\n            for ( int i = 0; cfgs != null && i < cfgs.length; i++ )\n            {\n\n                // ignore configuration object if an entry already exists in the\n                // map\n                String pid = cfgs[i].getPid();\n                if ( optionsPlain.containsKey( pid ) )\n                {\n                    continue;\n                }\n\n                // insert and entry for the pid\n                ObjectClassDefinition ocd = this.getObjectClassDefinition( cfgs[i], locale );\n                String name;\n                if ( ocd != null )\n                {\n                    name = ocd.getName() + \" (\";\n                    name += pid + \")\";\n                }\n                else\n                {\n                    name = pid;\n                }\n\n                if ( ocd != null || optionalMetaType )\n                {\n                    optionsPlain.put( pid, name );\n                }\n            }\n\n            //            pw.println( \"<form method='post' name='configSelection' onSubmit='configure(); return false;'\" );\n            pw.println( \"<select class='select' name='pid' id='configSelection_pid' onChange='configure();'>\" );\n            for ( Iterator ei = optionsPlain.entrySet().iterator(); ei.hasNext(); )\n            {\n                Entry entry = ( Entry ) ei.next();\n                pw.print( \"<option value='\" + entry.getKey() + \"'>\" );\n                pw.print( entry.getValue() );\n                pw.println( \"<\/option>\" );\n            }\n            pw.println( \"<\/select>\" );\n            pw.println( \"&nbsp;&nbsp;\" );\n            pw.println( \"<input class='submit' type='button' value='Configure' onClick='configure();' />\" );\n            //            pw.println( \"<\/form>\" );\n        }\n        catch ( Exception e )\n        {\n            // write a message or ignore\n        }\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"protected ObjectClassDefinition getObjectClassDefinition( Configuration config, String locale )\n    {\n\n        // if the configuration is not bound, search in the bundles\n        if ( config.getBundleLocation() == null )\n        {\n            ObjectClassDefinition ocd = this.getObjectClassDefinition( config.getPid(), locale );\n            if ( ocd != null )\n            {\n                return ocd;\n            }\n\n            // if none, check whether there might be one for the factory PID\n            if ( config.getFactoryPid() != null )\n            {\n                return this.getObjectClassDefinition( config.getFactoryPid(), locale );\n            }\n        }\n\n        MetaTypeService mts = this.getMetaTypeService();\n        if ( mts != null )\n        {\n            Bundle bundle = this.getBundle( config.getBundleLocation() );\n            if ( bundle != null )\n            {\n                MetaTypeInformation mti = mts.getMetaTypeInformation( bundle );\n                if ( mti != null )\n                {\n                    // try OCD by PID first\n                    ObjectClassDefinition ocd = mti.getObjectClassDefinition( config.getPid(), locale );\n                    if ( ocd != null )\n                    {\n                        return ocd;\n                    }\n\n                    // if none, check whether there might be one for the factory\n                    // PID\n                    if ( config.getFactoryPid() != null )\n                    {\n                        return mti.getObjectClassDefinition( config.getFactoryPid(), locale );\n                    }\n                }\n            }\n        }\n\n        // fallback to nothing found\n        return null;\n    }","id":9351,"modified_method":"protected ObjectClassDefinition getObjectClassDefinition( Configuration config, String locale )\n    {\n\n        // if the configuration is not bound, search in the bundles\n        if ( config.getBundleLocation() == null )\n        {\n            // if the configuration is a factory one, use the factory PID\n            if ( config.getFactoryPid() != null )\n            {\n                return this.getObjectClassDefinition( config.getFactoryPid(), locale );\n            }\n\n            // otherwise use the configuration PID\n            return this.getObjectClassDefinition( config.getPid(), locale );\n        }\n\n        MetaTypeService mts = this.getMetaTypeService();\n        if ( mts != null )\n        {\n            Bundle bundle = this.getBundle( config.getBundleLocation() );\n            if ( bundle != null )\n            {\n                MetaTypeInformation mti = mts.getMetaTypeInformation( bundle );\n                if ( mti != null )\n                {\n                    // check by factory PID\n                    if ( config.getFactoryPid() != null )\n                    {\n                        return mti.getObjectClassDefinition( config.getFactoryPid(), locale );\n                    }\n                    \n                    // otherwise check by configuration PID\n                    return mti.getObjectClassDefinition( config.getPid(), locale );\n                }\n            }\n        }\n\n        // fallback to nothing found\n        return null;\n    }","commit_id":"cd169b2cd64d9876bbc7c7756064681ecc98684b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Reconfigures the replica set that this client is the primary member of to\n     * remove the given server.\n     * @param server The server to remove\n     * @return True if successful\n     */\n    public boolean removeMemberFromReplicaSet(MongoDBServer server) {\n        BSONObject existingConfig = getReplicaSetConfig();\n        if (existingConfig == null) {\n            LOG.warn(\"Couldn't load existing config for replica set from {}. Server {} not removed.\",\n                    getServerAddress(), server);\n            return false;\n        }\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(existingConfig)\n                .remove(server)\n                .build();\n        return reconfigureReplicaSet(newConfig);\n    }","id":9352,"modified_method":"/**\n     * Reconfigures the replica set that this client is the primary member of to\n     * remove the given server.\n     * @param server The server to remove\n     * @return True if successful\n     */\n    public boolean removeMemberFromReplicaSet(MongoDBServer server) {\n        BSONObject existingConfig = getReplicaSetConfig();\n        if (existingConfig == null) {\n            LOG.warn(\"Couldn't load existing config for replica set from {}. Server {} not removed.\",\n                    getServerAddress(), server);\n            return false;\n        }\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(existingConfig)\n                .primary(getServerHostAndPort())\n                .remove(server)\n                .build();\n        return reconfigureReplicaSet(newConfig);\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Reconfigures the replica set that this client is the primary member of to include a new member.\n     * <p/>\n     * Note that this can cause long downtime (typically 10-20s, even up to a minute).\n     *\n     * @param secondary New member of the set.\n     * @param id The id for the new set member. Must be unique within the set.\n     * @return True if successful\n     */\n    public boolean addMemberToReplicaSet(MongoDBServer secondary, Integer id) {\n        // We need to:\n        // - get the existing configuration\n        // - update its version\n        // - add the new member to its list of members\n        // - run replSetReconfig with the new configuration.\n        BSONObject existingConfig = getReplicaSetConfig();\n        if (existingConfig == null) {\n            LOG.warn(\"Couldn't load existing config for replica set from {}. Server {} not added.\",\n                    getServerAddress(), secondary);\n            return false;\n        }\n\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(existingConfig)\n                .member(secondary, id)\n                .build();\n        return reconfigureReplicaSet(newConfig);\n    }","id":9353,"modified_method":"/**\n     * Reconfigures the replica set that this client is the primary member of to include a new member.\n     * <p/>\n     * Note that this can cause long downtime (typically 10-20s, even up to a minute).\n     *\n     * @param secondary New member of the set.\n     * @param id The id for the new set member. Must be unique within the set.\n     * @return True if successful\n     */\n    public boolean addMemberToReplicaSet(MongoDBServer secondary, Integer id) {\n        // We need to:\n        // - get the existing configuration\n        // - update its version\n        // - add the new member to its list of members\n        // - run replSetReconfig with the new configuration.\n        BSONObject existingConfig = getReplicaSetConfig();\n        if (existingConfig == null) {\n            LOG.warn(\"Couldn't load existing config for replica set from {}. Server {} not added.\",\n                    getServerAddress(), secondary);\n            return false;\n        }\n\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(existingConfig)\n                .primary(getServerHostAndPort())\n                .member(secondary, id)\n                .build();\n        return reconfigureReplicaSet(newConfig);\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Test replacing the primary succeeds. More interesting than replacing a secondary\n     * because the removal of a primary must happen _through_ the primary. The flow is:\n     *  - Brooklyn removes the server from the set and stops it\n     *  - The remaining members of the set elect a new primary\n     *  - We remove the original primary from the new primary.\n     */\n    @Test(groups = \"Integration\"/*, dependsOnMethods = { \"testCanStartAndStopAReplicaSet\" }*/)\n    public void testReplacePrimary() {\n        final MongoDBReplicaSet replicaSet = makeAndStartReplicaSet(3, \"replace-primary\");\n        final MongoDBServer replaced = replicaSet.getPrimary();\n        replicaSet.replaceMember(replaced.getId());\n        Asserts.succeedsEventually(ImmutableMap.of(\"timeout\", TIMEOUT), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize().intValue(), 3);\n                for (Entity member : replicaSet.getMembers()) {\n                    assertNotEquals(member.getId(), replaced.getId());\n                }\n                assertNotNull(replicaSet.getPrimary());\n            }\n        });\n    }","id":9354,"modified_method":"/**\n     * Test replacing the primary succeeds. More interesting than replacing a secondary\n     * because the removal of a primary must happen _through_ the primary. The flow is:\n     *  - Brooklyn removes the server from the set and stops it\n     *  - The remaining members of the set elect a new primary\n     *  - We remove the original primary from the new primary.\n     */\n    @Test(groups = \"Integration\")\n    public void testReplacePrimary() {\n        final MongoDBReplicaSet replicaSet = makeAndStartReplicaSet(3, \"replace-primary\");\n        final MongoDBServer replaced = replicaSet.getPrimary();\n        replicaSet.replaceMember(replaced.getId());\n        Asserts.succeedsEventually(ImmutableMap.of(\"timeout\", TIMEOUT), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize().intValue(), 3);\n                for (Entity member : replicaSet.getMembers()) {\n                    assertNotEquals(member.getId(), replaced.getId());\n                }\n                assertNotNull(replicaSet.getPrimary());\n                assertNotEquals(replicaSet.getPrimary().getId(), replaced.getId(), \"Expected a new primary to have been elected\");\n            }\n        });\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Creates and starts a replica set, asserts it reaches the given size\n     * and that the primary and secondaries are non-null.\n     */\n    private MongoDBReplicaSet makeAndStartReplicaSet(final Integer size, final String testDescription) {\n        // Sets secondaryPreferred so we can read from slaves.\n        final MongoDBReplicaSet replicaSet = app.createAndManageChild(EntitySpec.create(MongoDBReplicaSet.class)\n                .configure(DynamicCluster.INITIAL_SIZE, size)\n                .configure(\"replicaSetName\", \"test-rs-\"+testDescription)\n                .configure(\"memberSpec\", EntitySpec.create(MongoDBServer.class)\n                        .configure(\"mongodbConfTemplateUrl\", \"classpath:///test-mongodb.conf\")\n                        .configure(\"port\", \"27017+\")));\n        app.start(localhostMachineProvisioningLocation);\n\n        Asserts.succeedsEventually(ImmutableMap.of(\"timeout\", TIMEOUT), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize(), size);\n                assertNotNull(replicaSet.getPrimary());\n                assertEquals(replicaSet.getPrimary().getReplicaSet().getName(), \"test-rs-\"+testDescription);\n                assertEquals(replicaSet.getSecondaries().size(), size-1);\n            }\n        });\n        return replicaSet;\n    }","id":9355,"modified_method":"/**\n     * Creates and starts a replica set, asserts it reaches the given size\n     * and that the primary and secondaries are non-null.\n     */\n    private MongoDBReplicaSet makeAndStartReplicaSet(final Integer size, final String testDescription) {\n        // Sets secondaryPreferred so we can read from slaves.\n        final MongoDBReplicaSet replicaSet = app.createAndManageChild(EntitySpec.create(MongoDBReplicaSet.class)\n                .configure(DynamicCluster.INITIAL_SIZE, size)\n                .configure(\"replicaSetName\", \"test-rs-\"+testDescription)\n                .configure(\"memberSpec\", EntitySpec.create(MongoDBServer.class)\n                        .configure(\"mongodbConfTemplateUrl\", \"classpath:///test-mongodb.conf\")\n                        .configure(\"port\", \"27017+\")));\n        app.start(localhostMachineProvisioningLocation);\n\n        Asserts.succeedsEventually(ImmutableMap.of(\"timeout\", TIMEOUT), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize(), size);\n                assertNotNull(replicaSet.getPrimary(), \"replica set has no primary\");\n                assertEquals(replicaSet.getPrimary().getReplicaSet().getName(), \"test-rs-\"+testDescription);\n                assertEquals(replicaSet.getSecondaries().size(), size-1);\n            }\n        });\n        return replicaSet;\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\"/*, dependsOnMethods = { \"testCanStartAndStopAReplicaSet\" }*/)\n    public void testRemovePrimary() {\n        final MongoDBReplicaSet replicaSet = makeAndStartReplicaSet(3, \"remove-primary\");\n        final MongoDBServer removed = replicaSet.getPrimary();\n\n        replicaSet.removeMember(removed);\n        removed.stop();\n        Asserts.succeedsEventually(ImmutableMap.of(\"timeout\", TIMEOUT), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize().intValue(), 2);\n                for (Entity member : replicaSet.getMembers()) {\n                    assertNotEquals(member.getId(), removed.getId());\n                }\n                assertNotNull(replicaSet.getPrimary());\n            }\n        });\n    }","id":9356,"modified_method":"@Test(groups = \"Integration\")\n    public void testRemovePrimary() {\n        final MongoDBReplicaSet replicaSet = makeAndStartReplicaSet(3, \"remove-primary\");\n        final MongoDBServer removed = replicaSet.getPrimary();\n\n        replicaSet.removeMember(removed);\n        removed.stop();\n        Asserts.succeedsEventually(ImmutableMap.of(\"timeout\", TIMEOUT), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize().intValue(), 2);\n                for (Entity member : replicaSet.getMembers()) {\n                    assertNotEquals(member.getId(), removed.getId());\n                }\n                assertNotNull(replicaSet.getPrimary());\n                assertNotEquals(replicaSet.getPrimary().getId(), removed.getId(), \"Expected a new primary to have been elected\");\n            }\n        });\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(groups = \"Integration\", dependsOnMethods = { \"testCanStartAndStopAReplicaSet\" })\n    public void testResizeToEvenNumberOfMembersIgnored() {\n        final MongoDBReplicaSet replicaSet = makeAndStartReplicaSet(3, \"resize-even-ignored\");\n        try {\n            replicaSet.resize(4);\n        } catch (Exception e) {\n            log.info(\"Test \"+JavaClassNames.niceClassAndMethod()+\" resize threw error (not unexpected): \"+e);\n            return ;\n        }\n        TimeDuration thirtySeconds = new TimeDuration(0, 0, 30, 0);\n        Asserts.succeedsContinually(ImmutableMap.of(\"timeout\", thirtySeconds), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize().intValue(), 3);\n            }\n        });\n    }","id":9357,"modified_method":"@Test(groups = \"Integration\")\n    public void testResizeToEvenNumberOfMembers() {\n        final MongoDBReplicaSet replicaSet = makeAndStartReplicaSet(3, \"resize-even-ignored\");\n        assertEquals(replicaSet.getCurrentSize().intValue(), 3);\n        replicaSet.resize(4);\n        Asserts.succeedsEventually(new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(replicaSet.getCurrentSize().intValue(), 4);\n            }\n        });\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * @return A {@link BasicBSONObject} representing the configuration that is suitable for a MongoDB server.\n     */\n    public BasicBSONObject build() {\n        BasicBSONObject config = new BasicBSONObject();\n        config.put(\"_id\", name);\n        config.put(\"version\", version);\n        config.put(\"members\", members);\n        return config;\n    }","id":9358,"modified_method":"/**\n     * @return A {@link BasicBSONObject} representing the configuration that is suitable for a MongoDB server.\n     */\n    public BasicBSONObject build() {\n        setVotingMembers();\n        BasicBSONObject config = new BasicBSONObject();\n        config.put(\"_id\", name);\n        config.put(\"version\", version);\n        config.put(\"members\", members);\n        return config;\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Creates a configuration from an existing configuration.\n     * <p/>\n     * Auto-incrememnts the replica set's version number.\n     *\n     * @see MongoClientSupport#getReplicaSetConfig()\n     */\n    public static ReplicaSetConfig fromExistingConfig(BSONObject config) {\n        checkNotNull(config);\n        checkArgument(config.containsField(\"_id\"), \"_id missing from replica set config\");\n        checkArgument(config.containsField(\"version\"), \"version missing from replica set config\");\n        checkArgument(config.containsField(\"members\"), \"members missing from replica set config\");\n\n        String name = (String) config.get(\"_id\");\n        Integer version = (Integer) config.get(\"version\");\n        BasicBSONList members = (BasicBSONList) config.get(\"members\");\n\n        return new ReplicaSetConfig(name, members).version(++version);\n    }","id":9359,"modified_method":"/**\n     * Creates a configuration from an existing configuration.\n     * <p/>\n     * Automatically increments the replica set's version number.\n     */\n    public static ReplicaSetConfig fromExistingConfig(BSONObject config) {\n        checkNotNull(config);\n        checkArgument(config.containsField(\"_id\"), \"_id missing from replica set config\");\n        checkArgument(config.containsField(\"version\"), \"version missing from replica set config\");\n        checkArgument(config.containsField(\"members\"), \"members missing from replica set config\");\n\n        String name = (String) config.get(\"_id\");\n        Integer version = (Integer) config.get(\"version\");\n        BasicBSONList members = (BasicBSONList) config.get(\"members\");\n\n        return new ReplicaSetConfig(name, members).version(++version);\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Adds a new member to the replica set config with the given hostname, port and id. Doesn't attempt to check\n     * that the id is free.\n     */\n    public ReplicaSetConfig member(String hostname, Integer port, Integer id) {\n        BasicBSONObject member = new BasicBSONObject();\n        member.put(\"_id\", id);\n        member.put(\"host\", String.format(\"%s:%s\", hostname, port));\n        members.add(member);\n        return this;\n    }","id":9360,"modified_method":"/**\n     * Adds a new member to the replica set config with the given hostname, port and id. Doesn't attempt to check\n     * that the id is free.\n     */\n    public ReplicaSetConfig member(String hostname, Integer port, Integer id) {\n        if (members.size() == MAXIMUM_REPLICA_SET_SIZE) {\n            throw new IllegalStateException(String.format(\n                    \"Replica set {} exceeds maximum size of {} with addition of member at {}:{}\",\n                    new Object[]{name, MAXIMUM_REPLICA_SET_SIZE, hostname, port}));\n        }\n        BasicBSONObject member = new BasicBSONObject();\n        member.put(\"_id\", id);\n        member.put(\"host\", String.format(\"%s:%s\", hostname, port));\n        members.add(member);\n        return this;\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testRemoveNonExistentMemberHasNoEffect() {\n        // Replica set of two members\n        BasicBSONObject memberA = makeSetMember(33, \"example.com:7777\");\n        BasicBSONObject memberB = makeSetMember(34, \"example.com:7778\");\n        BasicBSONList initialMembers = new BasicBSONList();\n        initialMembers.add(memberA);\n        initialMembers.add(memberB);\n        BasicBSONObject config = new BasicBSONObject(\n                ImmutableMap.of(\"_id\", \"replica-set-name\", \"version\", 1, \"members\", initialMembers));\n\n        BasicBSONList members = (BasicBSONList) config.get(\"members\");\n        assertEquals(members.size(), 2);\n\n        BasicBSONObject altered = ReplicaSetConfig.fromExistingConfig(config)\n                .remove(\"foo\", 99)\n                .build();\n\n        members = (BasicBSONList) altered.get(\"members\");\n        assertEquals(members.size(), 2);\n    }","id":9361,"modified_method":"@Test\n    public void testRemoveNonExistentMemberHasNoEffect() {\n        BasicBSONObject config = makeSetConfig(\"replica-set-name\", 1,\n                makeSetMember(33, \"example.com:7777\"),\n                makeSetMember(34, \"example.com:7778\"));\n\n        BasicBSONList members = (BasicBSONList) config.get(\"members\");\n        assertEquals(members.size(), 2);\n\n        BasicBSONObject altered = ReplicaSetConfig.fromExistingConfig(config)\n                .remove(\"foo\", 99)\n                .build();\n\n        members = (BasicBSONList) altered.get(\"members\");\n        assertEquals(members.size(), 2);\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testRemoveMember() {\n        // Replica set of two members\n        int version = 44;\n        BasicBSONObject memberA = makeSetMember(33, \"example.com:7777\");\n        BasicBSONObject memberB = makeSetMember(34, \"example.com:7778\");\n        BasicBSONList initialMembers = new BasicBSONList();\n        initialMembers.add(memberA);\n        initialMembers.add(memberB);\n        BasicBSONObject config = new BasicBSONObject(\n                ImmutableMap.of(\"_id\", \"replica-set-name\", \"version\", version, \"members\", initialMembers));\n\n        // Use existing set to add two more members\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(config)\n            .remove(\"example.com\", 7777)\n            .build();\n\n        assertEquals(newConfig.get(\"version\"), version + 1);\n        BasicBSONList members = (BasicBSONList) newConfig.get(\"members\");\n        assertEquals(members.size(), 1);\n        assertEquals(BSONObject.class.cast(members.get(0)).get(\"host\"), \"example.com:7778\");\n\n        newConfig = ReplicaSetConfig.fromExistingConfig(newConfig)\n            .remove(\"example.com\", 7778)\n            .build();\n\n        members = (BasicBSONList) newConfig.get(\"members\");\n        assertTrue(members.isEmpty());\n    }","id":9362,"modified_method":"@Test\n    public void testRemoveMember() {\n        int version = 44;\n        BasicBSONObject config = makeSetConfig(\"replica-set-name\", version,\n                makeSetMember(33, \"example.com:7777\"),\n                makeSetMember(34, \"example.com:7778\"));\n\n        // Use existing set to add two more members\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(config)\n            .remove(\"example.com\", 7777)\n            .build();\n\n        assertEquals(newConfig.get(\"version\"), version + 1);\n        BasicBSONList members = (BasicBSONList) newConfig.get(\"members\");\n        assertEquals(members.size(), 1);\n        assertEquals(BSONObject.class.cast(members.get(0)).get(\"host\"), \"example.com:7778\");\n\n        newConfig = ReplicaSetConfig.fromExistingConfig(newConfig)\n            .remove(\"example.com\", 7778)\n            .build();\n\n        members = (BasicBSONList) newConfig.get(\"members\");\n        assertTrue(members.isEmpty());\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n    public void testCreateFromExistingConfig() {\n        // Replica set of one member\n        int version = 44;\n        BasicBSONObject initialMember = makeSetMember(33, \"example.com:7777\");\n        BasicBSONList initialMembers = new BasicBSONList();\n        initialMembers.add(initialMember);\n        BasicBSONObject config = new BasicBSONObject(\n                ImmutableMap.of(\"_id\", \"replica-set-name\", \"version\", version, \"members\", initialMembers));\n\n        // Use existing set to add two more members\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(config)\n            .member(\"foo\", 8888, 34)\n            .member(\"bar\", 9999, 35)\n            .build();\n\n        assertEquals(newConfig.get(\"_id\"), \"replica-set-name\");\n        assertEquals(newConfig.get(\"version\"), version + 1);\n        BasicBSONList members = (BasicBSONList) newConfig.get(\"members\");\n        assertEquals(members.size(), 3);\n\n        BSONObject original = (BSONObject) members.get(0);\n        assertEquals(original.get(\"_id\"), 33);\n        assertEquals(original.get(\"host\"), \"example.com:7777\");\n\n        BSONObject second = (BSONObject) members.get(1);\n        assertEquals(second.get(\"_id\"), 34);\n        assertEquals(second.get(\"host\"), \"foo:8888\");\n\n        BSONObject third = (BSONObject) members.get(2);\n        assertEquals(third.get(\"_id\"), 35);\n        assertEquals(third.get(\"host\"), \"bar:9999\");\n    }","id":9363,"modified_method":"@Test\n    public void testCreateFromExistingConfig() {\n        // Replica set of one member\n        int version = 44;\n        BasicBSONObject config = makeSetConfig(\"replica-set-name\", version, makeSetMember(33, \"example.com:7777\"));\n\n        // Use existing set to add two more members\n        BasicBSONObject newConfig = ReplicaSetConfig.fromExistingConfig(config)\n            .member(\"foo\", 8888, 34)\n            .member(\"bar\", 9999, 35)\n            .build();\n\n        assertEquals(newConfig.get(\"_id\"), \"replica-set-name\");\n        assertEquals(newConfig.get(\"version\"), version + 1);\n        BasicBSONList members = (BasicBSONList) newConfig.get(\"members\");\n        assertEquals(members.size(), 3);\n\n        BSONObject original = (BSONObject) members.get(0);\n        assertEquals(original.get(\"_id\"), 33);\n        assertEquals(original.get(\"host\"), \"example.com:7777\");\n\n        BSONObject second = (BSONObject) members.get(1);\n        assertEquals(second.get(\"_id\"), 34);\n        assertEquals(second.get(\"host\"), \"foo:8888\");\n\n        BSONObject third = (BSONObject) members.get(2);\n        assertEquals(third.get(\"_id\"), 35);\n        assertEquals(third.get(\"host\"), \"bar:9999\");\n    }","commit_id":"6578ad4abf1df231c1ffd824c84df871f957f62d","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value double value.\n   */\n  public void addMeta(final MetaElem elem, final double value) {\n    if(!elem.getType().instance(Type.DBL)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (double).\");\n    else addMeta(elem, Token.token(value), Type.DBL);\n  }","id":9364,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value double value.\n   */\n  public void addMeta(final MetaElem elem, final double value) {\n    if(!checkType(elem, Type.DBL)) return;\n    addMeta(elem, Token.token(value), Type.DBL);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value long value.\n   */\n  public void addMeta(final MetaElem elem, final long value) {\n    if(!elem.getType().instance(Type.LNG)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (long).\");\n    else addMeta(elem, Token.token(value), Type.LNG);\n  }","id":9365,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value long value.\n   */\n  public void addMeta(final MetaElem elem, final long value) {\n    if(!Type.LNG.instance(elem.getType())) {\n      if(value <= Integer.MAX_VALUE) addMeta(elem, (int) value);\n      else metaDebug(elem, \"long\");\n    } else addMeta(elem, Token.token(value), Type.LNG);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add the metadata to the TreeMap.\n   * @param e metadata element (the key).\n   * @param value value as byte array. Must contain only correct UTF-8 values!\n   */\n  private void addMeta0(final MetaElem e, final byte[] value) {\n    final TokenBuilder tb = new TokenBuilder(value);\n    tb.chop();\n    final byte[] data = tb.finish();\n    if(data.length == 0) return;\n    final ArrayList<byte[]> vals;\n    if(metaElements.containsKey(e)) {\n      if(!e.isMultiVal()) {\n        Main.debug(\n            \"Failed to add metadata value. Multiple values are forbidden for \"\n            + \"metadata element % (%).\", e, bfc.getFileName());\n        return;\n      }\n      vals = metaElements.get(e);\n    } else {\n      vals = new ArrayList<byte[]>();\n      metaElements.put(e, vals);\n    }\n    vals.add(data);\n  }","id":9366,"modified_method":"/**\n   * Add the metadata to the TreeMap.\n   * @param e metadata element (the key).\n   * @param value value as byte array. Must contain only correct UTF-8 values!\n   */\n  private void addMeta0(final MetaElem e, final byte[] value) {\n    final TokenBuilder tb = new TokenBuilder(value);\n    tb.chop();\n    final byte[] data = tb.finish();\n    if(data.length == 0) return;\n    final ArrayList<byte[]> vals;\n    if(metaElements.containsKey(e)) {\n      if(!e.isMultiVal()) {\n        Main.debug(\n            \"DeepFile: Failed to add metadata value. Multiple values are \" +\n            \"forbidden for \" + \"metadata element % (%).\", e, bfc.getFileName());\n        return;\n      }\n      vals = metaElements.get(e);\n    } else {\n      vals = new ArrayList<byte[]>();\n      metaElements.put(e, vals);\n    }\n    vals.add(data);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param xgc calendar value.\n   */\n  public void addMeta(final MetaElem elem, final XMLGregorianCalendar xgc) {\n    Type t = elem.getType();\n    QName st = xgc.getXMLSchemaType();\n    if((t.instance(Type.DAT) && !st.equals(DatatypeConstants.DATE))\n        || (t.instance(Type.YEA) && !st.equals(DatatypeConstants.GYEAR)))\n      Main.debug(\"Invalid data type for metadata element \"\n          + elem + \" (expected \" + t + \" got \" + st.getLocalPart() + \").\");\n    else addMeta(elem, token(xgc.toXMLFormat()), null);\n  }","id":9367,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param xgc calendar value.\n   */\n  public void addMeta(final MetaElem elem, final XMLGregorianCalendar xgc) {\n    Type t = elem.getType();\n    QName st = xgc.getXMLSchemaType();\n    if((Type.DAT.instance(t) && !st.equals(DatatypeConstants.DATE))\n        || (Type.YEA.instance(t) && !st.equals(DatatypeConstants.GYEAR)))\n      metaDebug(elem, st.getLocalPart());\n    else addMeta(elem, token(xgc.toXMLFormat()), null);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key). Must be a string attribute.\n   * @param value string value as byte array.\n   */\n  public void addMeta(final MetaElem elem, final byte[] value) {\n    if(!elem.getType().instance(Type.STR)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (string - as byte array).\");\n    else addMeta(elem, ParserUtil.checkUTF(value), null);\n  }","id":9368,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key). Must be a string attribute.\n   * @param value string value as byte array.\n   */\n  public void addMeta(final MetaElem elem, final byte[] value) {\n    if(!Type.STR.instance(elem.getType()))\n      metaDebug(elem, \"string - as byte array\");\n    else addMeta(elem, ParserUtil.checkUTF(value), null);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value integer value.\n   */\n  public void addMeta(final MetaElem elem, final int value) {\n    if(!elem.getType().instance(Type.ITR)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (int).\");\n    else addMeta(elem, Token.token(value), null);\n  }","id":9369,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value integer value.\n   */\n  public void addMeta(final MetaElem elem, final int value) {\n    if(!Type.INT.instance(elem.getType())) {\n      if(value <= Short.MAX_VALUE) addMeta(elem, (short) value);\n      else metaDebug(elem, \"integer\");\n    } else addMeta(elem, Token.token(value), null);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value integer value.\n   */\n  public void addMeta(final MetaElem elem, final short value) {\n    if(!elem.getType().instance(Type.SHR)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (short).\");\n    else addMeta(elem, Token.token(value), Type.SHR);\n  }","id":9370,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value integer value.\n   */\n  public void addMeta(final MetaElem elem, final short value) {\n    if(!checkType(elem, Type.SHR)) return;\n    addMeta(elem, Token.token(value), Type.SHR);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value string value.\n   */\n  public void addMeta(final MetaElem elem, final String value) {\n    if(!elem.getType().instance(Type.STR)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (string).\");\n    else addMeta(elem, ParserUtil.checkUTF(Token.token(value)), null);\n  }","id":9371,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value string value.\n   */\n  public void addMeta(final MetaElem elem, final String value) {\n    if(!checkType(elem, Type.STR)) return; \n    addMeta(elem, ParserUtil.checkUTF(Token.token(value)), null);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value duration value.\n   */\n  public void addMeta(final MetaElem elem, final Duration value) {\n    if(!elem.getType().instance(Type.DUR)) Main.debug(\"Invalid data type for \" +\n        \"metadata element \" + elem + \" (date).\");\n    else addMeta(elem, Token.token(value.toString()), null);\n  }","id":9372,"modified_method":"/**\n   * Add a metadata key-value pair for the current file.\n   * @param elem metadata element (the key).\n   * @param value duration value.\n   */\n  public void addMeta(final MetaElem elem, final Duration value) {\n    if(!checkType(elem, Type.DUR)) return;\n    addMeta(elem, Token.token(value.toString()), null);\n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Removes all illegal chars from the byte array. ID3 track numbers may be of\n   * the form <code>X/Y<\/code> (X is the track number, Y represents the number\n   * of tracks in the whole set). Everything after '/' is deleted.\n   * @param s number of bytes to read\n   * @return a byte array that contains only ASCII bytes that are valid integer\n   *         numbers.\n   * @throws IOException if any error occurs while reading the file.\n   */\n  byte[] readTrack(final int s) throws IOException {\n    final byte[] value = readText(s);\n    final int size = value.length;\n    int i = 0;\n    while(i < size && (value[i] < '1' || value[i] > '9'))\n      value[i++] = 0;\n\n    final int start = i; // first byte of the number\n    while(i < size && value[i] >= '0' && value[i] <= '9')\n      i++;\n    // number of bytes of the number\n    return Arrays.copyOfRange(value, start, i);\n  }","id":9373,"modified_method":"/**\n   * Removes all illegal chars from the byte array. ID3 track numbers may be of\n   * the form <code>X/Y<\/code> (X is the track number, Y represents the number\n   * of tracks in the whole set). Everything after '/' is deleted.\n   * @param s number of bytes to read\n   * @return a byte array that contains only ASCII bytes that are valid integer\n   *         numbers.\n   * @throws IOException if any error occurs while reading the file.\n   * @throws ParserException if the track number could not be parsed.\n   */\n  int readTrack(final int s) throws IOException, ParserException {\n    final byte[] value = readText(s);\n    final int size = value.length;\n    int i = 0;\n    while(i < size && (value[i] < '1' || value[i] > '9'))\n      value[i++] = 0;\n\n    final int start = i; // first byte of the number\n    while(i < size && value[i] >= '0' && value[i] <= '9')\n      i++;\n    // number of bytes of the number\n    final int track = Token.toInt(value, start, i);\n    if(track == Integer.MIN_VALUE) throw new ParserException(\n        \"Failed to parse track number\");\n    return track; \n  }","commit_id":"dfd977197ef39e16c7ac0c0c4c96f9298cced20d","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks db for start time and returns it if it exists.  If it doesn't\n   * exist, writes the suggested start time (if it is not null).  This is\n   * only called when the start time is not found in the cache,\n   * so it adds it back into the cache if it is found. Should only be called\n   * when a lock has been obtained on the entity.\n   */\n  private StartAndInsertTime checkStartTimeInDb(EntityIdentifier entity,\n      Long suggestedStartTime) throws IOException {\n    StartAndInsertTime startAndInsertTime = null;\n    // create lookup key for start time\n    byte[] b = createStartTimeLookupKey(entity.getId(), entity.getType());\n    // retrieve value for key\n    byte[] v = db.get(b);\n    if (v == null) {\n      // start time doesn't exist in db\n      if (suggestedStartTime == null) {\n        return null;\n      }\n      startAndInsertTime = new StartAndInsertTime(suggestedStartTime,\n          System.currentTimeMillis());\n\n      // write suggested start time\n      v = new byte[16];\n      writeReverseOrderedLong(suggestedStartTime, v, 0);\n      writeReverseOrderedLong(startAndInsertTime.insertTime, v, 8);\n      WriteOptions writeOptions = new WriteOptions();\n      writeOptions.sync(true);\n      db.put(b, v, writeOptions);\n    } else {\n      // found start time in db, so ignore suggested start time\n      startAndInsertTime = new StartAndInsertTime(readReverseOrderedLong(v, 0),\n          readReverseOrderedLong(v, 8));\n    }\n    startTimeWriteCache.put(entity, startAndInsertTime);\n    startTimeReadCache.put(entity, startAndInsertTime.startTime);\n    return startAndInsertTime;\n  }","id":9374,"modified_method":"/**\n   * Checks db for start time and returns it if it exists.  If it doesn't\n   * exist, writes the suggested start time (if it is not null).  This is\n   * only called when the start time is not found in the cache,\n   * so it adds it back into the cache if it is found. Should only be called\n   * when a lock has been obtained on the entity.\n   */\n  private StartAndInsertTime checkStartTimeInDb(EntityIdentifier entity,\n      Long suggestedStartTime) throws IOException {\n    StartAndInsertTime startAndInsertTime = null;\n    // create lookup key for start time\n    byte[] b = createStartTimeLookupKey(entity.getId(), entity.getType());\n    try {\n      // retrieve value for key\n      byte[] v = db.get(b);\n      if (v == null) {\n        // start time doesn't exist in db\n        if (suggestedStartTime == null) {\n          return null;\n        }\n        startAndInsertTime = new StartAndInsertTime(suggestedStartTime,\n            System.currentTimeMillis());\n        \n        // write suggested start time\n        v = new byte[16];\n        writeReverseOrderedLong(suggestedStartTime, v, 0);\n        writeReverseOrderedLong(startAndInsertTime.insertTime, v, 8);\n        WriteOptions writeOptions = new WriteOptions();\n        writeOptions.sync(true);\n        db.put(b, v, writeOptions);\n      } else {\n        // found start time in db, so ignore suggested start time\n        startAndInsertTime = new StartAndInsertTime(readReverseOrderedLong(v, 0),\n            readReverseOrderedLong(v, 8));\n      }\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } \n    startTimeWriteCache.put(entity, startAndInsertTime);\n    startTimeReadCache.put(entity, startAndInsertTime.startTime);\n    return startAndInsertTime;\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public TimelineEvents getEntityTimelines(String entityType,\n      SortedSet<String> entityIds, Long limit, Long windowStart,\n      Long windowEnd, Set<String> eventType) throws IOException {\n    TimelineEvents events = new TimelineEvents();\n    if (entityIds == null || entityIds.isEmpty()) {\n      return events;\n    }\n    // create a lexicographically-ordered map from start time to entities\n    Map<byte[], List<EntityIdentifier>> startTimeMap = new TreeMap<byte[],\n        List<EntityIdentifier>>(new Comparator<byte[]>() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                o2.length);\n          }\n        });\n    DBIterator iterator = null;\n    try {\n      // look up start times for the specified entities\n      // skip entities with no start time\n      for (String entityId : entityIds) {\n        byte[] startTime = getStartTime(entityId, entityType);\n        if (startTime != null) {\n          List<EntityIdentifier> entities = startTimeMap.get(startTime);\n          if (entities == null) {\n            entities = new ArrayList<EntityIdentifier>();\n            startTimeMap.put(startTime, entities);\n          }\n          entities.add(new EntityIdentifier(entityId, entityType));\n        }\n      }\n      for (Entry<byte[], List<EntityIdentifier>> entry :\n          startTimeMap.entrySet()) {\n        // look up the events matching the given parameters (limit,\n        // start time, end time, event types) for entities whose start times\n        // were found and add the entities to the return list\n        byte[] revStartTime = entry.getKey();\n        for (EntityIdentifier entityIdentifier : entry.getValue()) {\n          EventsOfOneEntity entity = new EventsOfOneEntity();\n          entity.setEntityId(entityIdentifier.getId());\n          entity.setEntityType(entityType);\n          events.addEvent(entity);\n          KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n              .add(entityType).add(revStartTime).add(entityIdentifier.getId())\n              .add(EVENTS_COLUMN);\n          byte[] prefix = kb.getBytesForLookup();\n          if (windowEnd == null) {\n            windowEnd = Long.MAX_VALUE;\n          }\n          byte[] revts = writeReverseOrderedLong(windowEnd);\n          kb.add(revts);\n          byte[] first = kb.getBytesForLookup();\n          byte[] last = null;\n          if (windowStart != null) {\n            last = KeyBuilder.newInstance().add(prefix)\n                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n          }\n          if (limit == null) {\n            limit = DEFAULT_LIMIT;\n          }\n          iterator = db.iterator();\n          for (iterator.seek(first); entity.getEvents().size() < limit &&\n              iterator.hasNext(); iterator.next()) {\n            byte[] key = iterator.peekNext().getKey();\n            if (!prefixMatches(prefix, prefix.length, key) || (last != null &&\n                WritableComparator.compareBytes(key, 0, key.length, last, 0,\n                    last.length) > 0)) {\n              break;\n            }\n            TimelineEvent event = getEntityEvent(eventType, key, prefix.length,\n                iterator.peekNext().getValue());\n            if (event != null) {\n              entity.addEvent(event);\n            }\n          }\n        }\n      }\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n    return events;\n  }","id":9375,"modified_method":"@Override\n  public TimelineEvents getEntityTimelines(String entityType,\n      SortedSet<String> entityIds, Long limit, Long windowStart,\n      Long windowEnd, Set<String> eventType) throws IOException {\n    TimelineEvents events = new TimelineEvents();\n    if (entityIds == null || entityIds.isEmpty()) {\n      return events;\n    }\n    // create a lexicographically-ordered map from start time to entities\n    Map<byte[], List<EntityIdentifier>> startTimeMap = new TreeMap<byte[],\n        List<EntityIdentifier>>(new Comparator<byte[]>() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                o2.length);\n          }\n        });\n    LeveldbIterator iterator = null;\n    try {\n      // look up start times for the specified entities\n      // skip entities with no start time\n      for (String entityId : entityIds) {\n        byte[] startTime = getStartTime(entityId, entityType);\n        if (startTime != null) {\n          List<EntityIdentifier> entities = startTimeMap.get(startTime);\n          if (entities == null) {\n            entities = new ArrayList<EntityIdentifier>();\n            startTimeMap.put(startTime, entities);\n          }\n          entities.add(new EntityIdentifier(entityId, entityType));\n        }\n      }\n      for (Entry<byte[], List<EntityIdentifier>> entry :\n          startTimeMap.entrySet()) {\n        // look up the events matching the given parameters (limit,\n        // start time, end time, event types) for entities whose start times\n        // were found and add the entities to the return list\n        byte[] revStartTime = entry.getKey();\n        for (EntityIdentifier entityIdentifier : entry.getValue()) {\n          EventsOfOneEntity entity = new EventsOfOneEntity();\n          entity.setEntityId(entityIdentifier.getId());\n          entity.setEntityType(entityType);\n          events.addEvent(entity);\n          KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n              .add(entityType).add(revStartTime).add(entityIdentifier.getId())\n              .add(EVENTS_COLUMN);\n          byte[] prefix = kb.getBytesForLookup();\n          if (windowEnd == null) {\n            windowEnd = Long.MAX_VALUE;\n          }\n          byte[] revts = writeReverseOrderedLong(windowEnd);\n          kb.add(revts);\n          byte[] first = kb.getBytesForLookup();\n          byte[] last = null;\n          if (windowStart != null) {\n            last = KeyBuilder.newInstance().add(prefix)\n                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n          }\n          if (limit == null) {\n            limit = DEFAULT_LIMIT;\n          }\n          iterator = new LeveldbIterator(db);\n          for (iterator.seek(first); entity.getEvents().size() < limit &&\n              iterator.hasNext(); iterator.next()) {\n            byte[] key = iterator.peekNext().getKey();\n            if (!prefixMatches(prefix, prefix.length, key) || (last != null &&\n                WritableComparator.compareBytes(key, 0, key.length, last, 0,\n                    last.length) > 0)) {\n              break;\n            }\n            TimelineEvent event = getEntityEvent(eventType, key, prefix.length,\n                iterator.peekNext().getValue());\n            if (event != null) {\n              entity.addEvent(event);\n            }\n          }\n        }\n      }\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n    return events;\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Discards entities with start timestamp less than or equal to the given\n   * timestamp.\n   */\n  @VisibleForTesting\n  void discardOldEntities(long timestamp)\n      throws IOException, InterruptedException {\n    byte[] reverseTimestamp = writeReverseOrderedLong(timestamp);\n    long totalCount = 0;\n    long t1 = System.currentTimeMillis();\n    try {\n      List<String> entityTypes = getEntityTypes();\n      for (String entityType : entityTypes) {\n        DBIterator iterator = null;\n        DBIterator pfIterator = null;\n        long typeCount = 0;\n        try {\n          deleteLock.writeLock().lock();\n          iterator = getDbIterator(false);\n          pfIterator = getDbIterator(false);\n\n          if (deletionThread != null && deletionThread.isInterrupted()) {\n            throw new InterruptedException();\n          }\n          boolean seeked = false;\n          while (deleteNextEntity(entityType, reverseTimestamp, iterator,\n              pfIterator, seeked)) {\n            typeCount++;\n            totalCount++;\n            seeked = true;\n            if (deletionThread != null && deletionThread.isInterrupted()) {\n              throw new InterruptedException();\n            }\n          }\n        } catch (IOException e) {\n          LOG.error(\"Got IOException while deleting entities for type \" +\n              entityType + \", continuing to next type\", e);\n        } finally {\n          IOUtils.cleanup(LOG, iterator, pfIterator);\n          deleteLock.writeLock().unlock();\n          if (typeCount > 0) {\n            LOG.info(\"Deleted \" + typeCount + \" entities of type \" +\n                entityType);\n          }\n        }\n      }\n    } finally {\n      long t2 = System.currentTimeMillis();\n      LOG.info(\"Discarded \" + totalCount + \" entities for timestamp \" +\n          timestamp + \" and earlier in \" + (t2 - t1) / 1000.0 + \" seconds\");\n    }\n  }","id":9376,"modified_method":"/**\n   * Discards entities with start timestamp less than or equal to the given\n   * timestamp.\n   */\n  @VisibleForTesting\n  void discardOldEntities(long timestamp)\n      throws IOException, InterruptedException {\n    byte[] reverseTimestamp = writeReverseOrderedLong(timestamp);\n    long totalCount = 0;\n    long t1 = System.currentTimeMillis();\n    try {\n      List<String> entityTypes = getEntityTypes();\n      for (String entityType : entityTypes) {\n        LeveldbIterator iterator = null;\n        LeveldbIterator pfIterator = null;\n        long typeCount = 0;\n        try {\n          deleteLock.writeLock().lock();\n          iterator = getDbIterator(false);\n          pfIterator = getDbIterator(false);\n\n          if (deletionThread != null && deletionThread.isInterrupted()) {\n            throw new InterruptedException();\n          }\n          boolean seeked = false;\n          while (deleteNextEntity(entityType, reverseTimestamp, iterator,\n              pfIterator, seeked)) {\n            typeCount++;\n            totalCount++;\n            seeked = true;\n            if (deletionThread != null && deletionThread.isInterrupted()) {\n              throw new InterruptedException();\n            }\n          }\n        } catch (IOException e) {\n          LOG.error(\"Got IOException while deleting entities for type \" +\n              entityType + \", continuing to next type\", e);\n        } finally {\n          IOUtils.cleanup(LOG, iterator, pfIterator);\n          deleteLock.writeLock().unlock();\n          if (typeCount > 0) {\n            LOG.info(\"Deleted \" + typeCount + \" entities of type \" +\n                entityType);\n          }\n        }\n      }\n    } finally {\n      long t2 = System.currentTimeMillis();\n      LOG.info(\"Discarded \" + totalCount + \" entities for timestamp \" +\n          timestamp + \" and earlier in \" + (t2 - t1) / 1000.0 + \" seconds\");\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Put a single entity.  If there is an error, add a TimelinePutError to the\n   * given response.\n   */\n  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock<EntityIdentifier> lock =\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch = null;\n    List<EntityIdentifier> relatedEntitiesWithoutStartTimes =\n        new ArrayList<EntityIdentifier>();\n    byte[] revStartTime = null;\n    Map<String, Set<Object>> primaryFilters = null;\n    try {\n      writeBatch = db.createWriteBatch();\n      List<TimelineEvent> events = entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime = getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime == null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error = new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      revStartTime = writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters = entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey = createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue = writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events != null && !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts = writeReverseOrderedLong(event.getTimestamp());\n          byte[] key = createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value = GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map<String, Set<String>> relatedEntities =\n          entity.getRelatedEntities();\n      if (relatedEntities != null && !relatedEntities.isEmpty()) {\n        for (Entry<String, Set<String>> relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType = relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -> related entity)\n            byte[] key = createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime = getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime == null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes = db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won't have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId = null;\n              if (domainIdBytes == null) {\n                domainId = TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId = new String(domainIdBytes);\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                TimelinePutError error = new TimelinePutError();\n                error.setEntityId(entity.getEntityId());\n                error.setEntityType(entity.getEntityType());\n                error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n                response.addError(error);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -> entity)\n            key = createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters != null && !primaryFilters.isEmpty()) {\n        for (Entry<String, Set<Object>> primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key = createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map<String, Object> otherInfo = entity.getOtherInfo();\n      if (otherInfo != null && !otherInfo.isEmpty()) {\n        for (Entry<String, Object> i : otherInfo.entrySet()) {\n          byte[] key = createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value = GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key = createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() == null ||\n          entity.getDomainId().length() == 0) {\n        if (!allowEmptyDomainId) {\n          TimelinePutError error = new TimelinePutError();\n          error.setEntityId(entity.getEntityId());\n          error.setEntityType(entity.getEntityType());\n          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n          response.addError(error);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes());\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes());\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error = new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock = writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime =\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime == null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime = writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key = createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes());\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error = new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }","id":9377,"modified_method":"/**\n   * Put a single entity.  If there is an error, add a TimelinePutError to the\n   * given response.\n   */\n  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock<EntityIdentifier> lock =\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch = null;\n    List<EntityIdentifier> relatedEntitiesWithoutStartTimes =\n        new ArrayList<EntityIdentifier>();\n    byte[] revStartTime = null;\n    Map<String, Set<Object>> primaryFilters = null;\n    try {\n      writeBatch = db.createWriteBatch();\n      List<TimelineEvent> events = entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime = getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime == null) {\n        // if no start time is found, add an error and return\n        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n        return;\n      }\n      revStartTime = writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters = entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey = createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue = writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events != null && !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts = writeReverseOrderedLong(event.getTimestamp());\n          byte[] key = createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value = GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map<String, Set<String>> relatedEntities =\n          entity.getRelatedEntities();\n      if (relatedEntities != null && !relatedEntities.isEmpty()) {\n        for (Entry<String, Set<String>> relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType = relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -> related entity)\n            byte[] key = createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime = getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime == null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes = db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won't have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId = null;\n              if (domainIdBytes == null) {\n                domainId = TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId = new String(domainIdBytes);\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -> entity)\n            key = createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters != null && !primaryFilters.isEmpty()) {\n        for (Entry<String, Set<Object>> primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key = createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map<String, Object> otherInfo = entity.getOtherInfo();\n      if (otherInfo != null && !otherInfo.isEmpty()) {\n        for (Entry<String, Object> i : otherInfo.entrySet()) {\n          byte[] key = createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value = GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key = createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() == null ||\n          entity.getDomainId().length() == 0) {\n        if (!allowEmptyDomainId) {\n          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes());\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes());\n      }\n      db.write(writeBatch);\n    } catch (DBException de) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                \" of type \" + entity.getEntityType(), de);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock = writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime =\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime == null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime = writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key = createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes());\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (DBException de) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public void put(TimelineDomain domain) throws IOException {\n    WriteBatch writeBatch = null;\n    try {\n      writeBatch = db.createWriteBatch();\n      if (domain.getId() == null || domain.getId().length() == 0) {\n        throw new IllegalArgumentException(\"Domain doesn't have an ID\");\n      }\n      if (domain.getOwner() == null || domain.getOwner().length() == 0) {\n        throw new IllegalArgumentException(\"Domain doesn't have an owner.\");\n      }\n\n      // Write description\n      byte[] domainEntryKey = createDomainEntryKey(\n          domain.getId(), DESCRIPTION_COLUMN);\n      byte[] ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), DESCRIPTION_COLUMN);\n      if (domain.getDescription() != null) {\n        writeBatch.put(domainEntryKey, domain.getDescription().getBytes());\n        writeBatch.put(ownerLookupEntryKey, domain.getDescription().getBytes());\n      } else {\n        writeBatch.put(domainEntryKey, EMPTY_BYTES);\n        writeBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write owner\n      domainEntryKey = createDomainEntryKey(domain.getId(), OWNER_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), OWNER_COLUMN);\n      // Null check for owner is done before\n      writeBatch.put(domainEntryKey, domain.getOwner().getBytes());\n      writeBatch.put(ownerLookupEntryKey, domain.getOwner().getBytes());\n\n      // Write readers\n      domainEntryKey = createDomainEntryKey(domain.getId(), READER_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), READER_COLUMN);\n      if (domain.getReaders() != null && domain.getReaders().length() > 0) {\n        writeBatch.put(domainEntryKey, domain.getReaders().getBytes());\n        writeBatch.put(ownerLookupEntryKey, domain.getReaders().getBytes());\n      } else {\n        writeBatch.put(domainEntryKey, EMPTY_BYTES);\n        writeBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write writers\n      domainEntryKey = createDomainEntryKey(domain.getId(), WRITER_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), WRITER_COLUMN);\n      if (domain.getWriters() != null && domain.getWriters().length() > 0) {\n        writeBatch.put(domainEntryKey, domain.getWriters().getBytes());\n        writeBatch.put(ownerLookupEntryKey, domain.getWriters().getBytes());\n      } else {\n        writeBatch.put(domainEntryKey, EMPTY_BYTES);\n        writeBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write creation time and modification time\n      // We put both timestamps together because they are always retrieved\n      // together, and store them in the same way as we did for the entity's\n      // start time and insert time.\n      domainEntryKey = createDomainEntryKey(domain.getId(), TIMESTAMP_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), TIMESTAMP_COLUMN);\n      long currentTimestamp = System.currentTimeMillis();\n      byte[] timestamps = db.get(domainEntryKey);\n      if (timestamps == null) {\n        timestamps = new byte[16];\n        writeReverseOrderedLong(currentTimestamp, timestamps, 0);\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      } else {\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      }\n      writeBatch.put(domainEntryKey, timestamps);\n      writeBatch.put(ownerLookupEntryKey, timestamps);\n      db.write(writeBatch);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }","id":9378,"modified_method":"@Override\n  public void put(TimelineDomain domain) throws IOException {\n    WriteBatch writeBatch = null;\n    try {\n      writeBatch = db.createWriteBatch();\n      if (domain.getId() == null || domain.getId().length() == 0) {\n        throw new IllegalArgumentException(\"Domain doesn't have an ID\");\n      }\n      if (domain.getOwner() == null || domain.getOwner().length() == 0) {\n        throw new IllegalArgumentException(\"Domain doesn't have an owner.\");\n      }\n\n      // Write description\n      byte[] domainEntryKey = createDomainEntryKey(\n          domain.getId(), DESCRIPTION_COLUMN);\n      byte[] ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), DESCRIPTION_COLUMN);\n      if (domain.getDescription() != null) {\n        writeBatch.put(domainEntryKey, domain.getDescription().getBytes());\n        writeBatch.put(ownerLookupEntryKey, domain.getDescription().getBytes());\n      } else {\n        writeBatch.put(domainEntryKey, EMPTY_BYTES);\n        writeBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write owner\n      domainEntryKey = createDomainEntryKey(domain.getId(), OWNER_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), OWNER_COLUMN);\n      // Null check for owner is done before\n      writeBatch.put(domainEntryKey, domain.getOwner().getBytes());\n      writeBatch.put(ownerLookupEntryKey, domain.getOwner().getBytes());\n\n      // Write readers\n      domainEntryKey = createDomainEntryKey(domain.getId(), READER_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), READER_COLUMN);\n      if (domain.getReaders() != null && domain.getReaders().length() > 0) {\n        writeBatch.put(domainEntryKey, domain.getReaders().getBytes());\n        writeBatch.put(ownerLookupEntryKey, domain.getReaders().getBytes());\n      } else {\n        writeBatch.put(domainEntryKey, EMPTY_BYTES);\n        writeBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write writers\n      domainEntryKey = createDomainEntryKey(domain.getId(), WRITER_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), WRITER_COLUMN);\n      if (domain.getWriters() != null && domain.getWriters().length() > 0) {\n        writeBatch.put(domainEntryKey, domain.getWriters().getBytes());\n        writeBatch.put(ownerLookupEntryKey, domain.getWriters().getBytes());\n      } else {\n        writeBatch.put(domainEntryKey, EMPTY_BYTES);\n        writeBatch.put(ownerLookupEntryKey, EMPTY_BYTES);\n      }\n\n      // Write creation time and modification time\n      // We put both timestamps together because they are always retrieved\n      // together, and store them in the same way as we did for the entity's\n      // start time and insert time.\n      domainEntryKey = createDomainEntryKey(domain.getId(), TIMESTAMP_COLUMN);\n      ownerLookupEntryKey = createOwnerLookupKey(\n          domain.getOwner(), domain.getId(), TIMESTAMP_COLUMN);\n      long currentTimestamp = System.currentTimeMillis();\n      byte[] timestamps = db.get(domainEntryKey);\n      if (timestamps == null) {\n        timestamps = new byte[16];\n        writeReverseOrderedLong(currentTimestamp, timestamps, 0);\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      } else {\n        writeReverseOrderedLong(currentTimestamp, timestamps, 8);\n      }\n      writeBatch.put(domainEntryKey, timestamps);\n      writeBatch.put(ownerLookupEntryKey, timestamps);\n      db.write(writeBatch);\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  boolean deleteNextEntity(String entityType, byte[] reverseTimestamp,\n      DBIterator iterator, DBIterator pfIterator, boolean seeked)\n      throws IOException {\n    WriteBatch writeBatch = null;\n    try {\n      KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n          .add(entityType);\n      byte[] typePrefix = kb.getBytesForLookup();\n      kb.add(reverseTimestamp);\n      if (!seeked) {\n        iterator.seek(kb.getBytesForLookup());\n      }\n      if (!iterator.hasNext()) {\n        return false;\n      }\n      byte[] entityKey = iterator.peekNext().getKey();\n      if (!prefixMatches(typePrefix, typePrefix.length, entityKey)) {\n        return false;\n      }\n\n      // read the start time and entity id from the current key\n      KeyParser kp = new KeyParser(entityKey, typePrefix.length + 8);\n      String entityId = kp.getNextString();\n      int prefixlen = kp.getOffset();\n      byte[] deletePrefix = new byte[prefixlen];\n      System.arraycopy(entityKey, 0, deletePrefix, 0, prefixlen);\n\n      writeBatch = db.createWriteBatch();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" + entityId);\n      }\n      // remove start time from cache and db\n      writeBatch.delete(createStartTimeLookupKey(entityId, entityType));\n      EntityIdentifier entityIdentifier =\n          new EntityIdentifier(entityId, entityType);\n      startTimeReadCache.remove(entityIdentifier);\n      startTimeWriteCache.remove(entityIdentifier);\n\n      // delete current entity\n      for (; iterator.hasNext(); iterator.next()) {\n        byte[] key = iterator.peekNext().getKey();\n        if (!prefixMatches(entityKey, prefixlen, key)) {\n          break;\n        }\n        writeBatch.delete(key);\n\n        if (key.length == prefixlen) {\n          continue;\n        }\n        if (key[prefixlen] == PRIMARY_FILTERS_COLUMN[0]) {\n          kp = new KeyParser(key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n          String name = kp.getNextString();\n          Object value = GenericObjectMapper.read(key, kp.getOffset());\n          deleteKeysWithPrefix(writeBatch, addPrimaryFilterToKey(name, value,\n              deletePrefix), pfIterator);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" +\n                entityId + \" primary filter entry \" + name + \" \" +\n                value);\n          }\n        } else if (key[prefixlen] == RELATED_ENTITIES_COLUMN[0]) {\n          kp = new KeyParser(key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n          String type = kp.getNextString();\n          String id = kp.getNextString();\n          byte[] relatedEntityStartTime = getStartTime(id, type);\n          if (relatedEntityStartTime == null) {\n            LOG.warn(\"Found no start time for \" +\n                \"related entity \" + id + \" of type \" + type + \" while \" +\n                \"deleting \" + entityId + \" of type \" + entityType);\n            continue;\n          }\n          writeBatch.delete(createReverseRelatedEntityKey(id, type,\n              relatedEntityStartTime, entityId, entityType));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" +\n                entityId + \" from invisible reverse related entity \" +\n                \"entry of type:\" + type + \" id:\" + id);\n          }\n        } else if (key[prefixlen] ==\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          kp = new KeyParser(key, prefixlen +\n              INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN.length);\n          String type = kp.getNextString();\n          String id = kp.getNextString();\n          byte[] relatedEntityStartTime = getStartTime(id, type);\n          if (relatedEntityStartTime == null) {\n            LOG.warn(\"Found no start time for reverse \" +\n                \"related entity \" + id + \" of type \" + type + \" while \" +\n                \"deleting \" + entityId + \" of type \" + entityType);\n            continue;\n          }\n          writeBatch.delete(createRelatedEntityKey(id, type,\n              relatedEntityStartTime, entityId, entityType));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" +\n                entityId + \" from related entity entry of type:\" +\n                type + \" id:\" + id);\n          }\n        }\n      }\n      WriteOptions writeOptions = new WriteOptions();\n      writeOptions.sync(true);\n      db.write(writeBatch, writeOptions);\n      return true;\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }","id":9379,"modified_method":"@VisibleForTesting\n  boolean deleteNextEntity(String entityType, byte[] reverseTimestamp,\n      LeveldbIterator iterator, LeveldbIterator pfIterator, boolean seeked)\n      throws IOException {\n    WriteBatch writeBatch = null;\n    try {\n      KeyBuilder kb = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n          .add(entityType);\n      byte[] typePrefix = kb.getBytesForLookup();\n      kb.add(reverseTimestamp);\n      if (!seeked) {\n        iterator.seek(kb.getBytesForLookup());\n      }\n      if (!iterator.hasNext()) {\n        return false;\n      }\n      byte[] entityKey = iterator.peekNext().getKey();\n      if (!prefixMatches(typePrefix, typePrefix.length, entityKey)) {\n        return false;\n      }\n\n      // read the start time and entity id from the current key\n      KeyParser kp = new KeyParser(entityKey, typePrefix.length + 8);\n      String entityId = kp.getNextString();\n      int prefixlen = kp.getOffset();\n      byte[] deletePrefix = new byte[prefixlen];\n      System.arraycopy(entityKey, 0, deletePrefix, 0, prefixlen);\n\n      writeBatch = db.createWriteBatch();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" + entityId);\n      }\n      // remove start time from cache and db\n      writeBatch.delete(createStartTimeLookupKey(entityId, entityType));\n      EntityIdentifier entityIdentifier =\n          new EntityIdentifier(entityId, entityType);\n      startTimeReadCache.remove(entityIdentifier);\n      startTimeWriteCache.remove(entityIdentifier);\n\n      // delete current entity\n      for (; iterator.hasNext(); iterator.next()) {\n        byte[] key = iterator.peekNext().getKey();\n        if (!prefixMatches(entityKey, prefixlen, key)) {\n          break;\n        }\n        writeBatch.delete(key);\n\n        if (key.length == prefixlen) {\n          continue;\n        }\n        if (key[prefixlen] == PRIMARY_FILTERS_COLUMN[0]) {\n          kp = new KeyParser(key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n          String name = kp.getNextString();\n          Object value = GenericObjectMapper.read(key, kp.getOffset());\n          deleteKeysWithPrefix(writeBatch, addPrimaryFilterToKey(name, value,\n              deletePrefix), pfIterator);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" +\n                entityId + \" primary filter entry \" + name + \" \" +\n                value);\n          }\n        } else if (key[prefixlen] == RELATED_ENTITIES_COLUMN[0]) {\n          kp = new KeyParser(key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n          String type = kp.getNextString();\n          String id = kp.getNextString();\n          byte[] relatedEntityStartTime = getStartTime(id, type);\n          if (relatedEntityStartTime == null) {\n            LOG.warn(\"Found no start time for \" +\n                \"related entity \" + id + \" of type \" + type + \" while \" +\n                \"deleting \" + entityId + \" of type \" + entityType);\n            continue;\n          }\n          writeBatch.delete(createReverseRelatedEntityKey(id, type,\n              relatedEntityStartTime, entityId, entityType));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" +\n                entityId + \" from invisible reverse related entity \" +\n                \"entry of type:\" + type + \" id:\" + id);\n          }\n        } else if (key[prefixlen] ==\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          kp = new KeyParser(key, prefixlen +\n              INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN.length);\n          String type = kp.getNextString();\n          String id = kp.getNextString();\n          byte[] relatedEntityStartTime = getStartTime(id, type);\n          if (relatedEntityStartTime == null) {\n            LOG.warn(\"Found no start time for reverse \" +\n                \"related entity \" + id + \" of type \" + type + \" while \" +\n                \"deleting \" + entityId + \" of type \" + entityType);\n            continue;\n          }\n          writeBatch.delete(createRelatedEntityKey(id, type,\n              relatedEntityStartTime, entityId, entityType));\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Deleting entity type:\" + entityType + \" id:\" +\n                entityId + \" from related entity entry of type:\" +\n                type + \" id:\" + id);\n          }\n        }\n      }\n      WriteOptions writeOptions = new WriteOptions();\n      writeOptions.sync(true);\n      db.write(writeBatch, writeOptions);\n      return true;\n    } catch(DBException e) {\n      throw new IOException(e);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Retrieves a list of entities satisfying given parameters.\n   *\n   * @param base A byte array prefix for the lookup\n   * @param entityType The type of the entity\n   * @param limit A limit on the number of entities to return\n   * @param starttime The earliest entity start time to retrieve (exclusive)\n   * @param endtime The latest entity start time to retrieve (inclusive)\n   * @param fromId Retrieve entities starting with this entity\n   * @param fromTs Ignore entities with insert timestamp later than this ts\n   * @param secondaryFilters Filter pairs that the entities should match\n   * @param fields The set of fields to retrieve\n   * @return A list of entities\n   * @throws IOException\n   */\n  private TimelineEntities getEntityByTime(byte[] base,\n      String entityType, Long limit, Long starttime, Long endtime,\n      String fromId, Long fromTs, Collection<NameValuePair> secondaryFilters,\n      EnumSet<Field> fields) throws IOException {\n    DBIterator iterator = null;\n    try {\n      KeyBuilder kb = KeyBuilder.newInstance().add(base).add(entityType);\n      // only db keys matching the prefix (base + entity type) will be parsed\n      byte[] prefix = kb.getBytesForLookup();\n      if (endtime == null) {\n        // if end time is null, place no restriction on end time\n        endtime = Long.MAX_VALUE;\n      }\n      // construct a first key that will be seeked to using end time or fromId\n      byte[] first = null;\n      if (fromId != null) {\n        Long fromIdStartTime = getStartTimeLong(fromId, entityType);\n        if (fromIdStartTime == null) {\n          // no start time for provided id, so return empty entities\n          return new TimelineEntities();\n        }\n        if (fromIdStartTime <= endtime) {\n          // if provided id's start time falls before the end of the window,\n          // use it to construct the seek key\n          first = kb.add(writeReverseOrderedLong(fromIdStartTime))\n              .add(fromId).getBytesForLookup();\n        }\n      }\n      // if seek key wasn't constructed using fromId, construct it using end ts\n      if (first == null) {\n        first = kb.add(writeReverseOrderedLong(endtime)).getBytesForLookup();\n      }\n      byte[] last = null;\n      if (starttime != null) {\n        // if start time is not null, set a last key that will not be\n        // iterated past\n        last = KeyBuilder.newInstance().add(base).add(entityType)\n            .add(writeReverseOrderedLong(starttime)).getBytesForLookup();\n      }\n      if (limit == null) {\n        // if limit is not specified, use the default\n        limit = DEFAULT_LIMIT;\n      }\n\n      TimelineEntities entities = new TimelineEntities();\n      iterator = db.iterator();\n      iterator.seek(first);\n      // iterate until one of the following conditions is met: limit is\n      // reached, there are no more keys, the key prefix no longer matches,\n      // or a start time has been specified and reached/exceeded\n      while (entities.getEntities().size() < limit && iterator.hasNext()) {\n        byte[] key = iterator.peekNext().getKey();\n        if (!prefixMatches(prefix, prefix.length, key) || (last != null &&\n            WritableComparator.compareBytes(key, 0, key.length, last, 0,\n                last.length) > 0)) {\n          break;\n        }\n        // read the start time and entity id from the current key\n        KeyParser kp = new KeyParser(key, prefix.length);\n        Long startTime = kp.getNextLong();\n        String entityId = kp.getNextString();\n\n        if (fromTs != null) {\n          long insertTime = readReverseOrderedLong(iterator.peekNext()\n              .getValue(), 0);\n          if (insertTime > fromTs) {\n            byte[] firstKey = key;\n            while (iterator.hasNext() && prefixMatches(firstKey,\n                kp.getOffset(), key)) {\n              iterator.next();\n              key = iterator.peekNext().getKey();\n            }\n            continue;\n          }\n        }\n\n        // parse the entity that owns this key, iterating over all keys for\n        // the entity\n        TimelineEntity entity = getEntity(entityId, entityType, startTime,\n            fields, iterator, key, kp.getOffset());\n        // determine if the retrieved entity matches the provided secondary\n        // filters, and if so add it to the list of entities to return\n        boolean filterPassed = true;\n        if (secondaryFilters != null) {\n          for (NameValuePair filter : secondaryFilters) {\n            Object v = entity.getOtherInfo().get(filter.getName());\n            if (v == null) {\n              Set<Object> vs = entity.getPrimaryFilters()\n                  .get(filter.getName());\n              if (vs != null && !vs.contains(filter.getValue())) {\n                filterPassed = false;\n                break;\n              }\n            } else if (!v.equals(filter.getValue())) {\n              filterPassed = false;\n              break;\n            }\n          }\n        }\n        if (filterPassed) {\n          entities.addEntity(entity);\n        }\n      }\n      return entities;\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","id":9380,"modified_method":"/**\n   * Retrieves a list of entities satisfying given parameters.\n   *\n   * @param base A byte array prefix for the lookup\n   * @param entityType The type of the entity\n   * @param limit A limit on the number of entities to return\n   * @param starttime The earliest entity start time to retrieve (exclusive)\n   * @param endtime The latest entity start time to retrieve (inclusive)\n   * @param fromId Retrieve entities starting with this entity\n   * @param fromTs Ignore entities with insert timestamp later than this ts\n   * @param secondaryFilters Filter pairs that the entities should match\n   * @param fields The set of fields to retrieve\n   * @return A list of entities\n   * @throws IOException\n   */\n  private TimelineEntities getEntityByTime(byte[] base,\n      String entityType, Long limit, Long starttime, Long endtime,\n      String fromId, Long fromTs, Collection<NameValuePair> secondaryFilters,\n      EnumSet<Field> fields) throws IOException {\n    LeveldbIterator iterator = null;\n    try {\n      KeyBuilder kb = KeyBuilder.newInstance().add(base).add(entityType);\n      // only db keys matching the prefix (base + entity type) will be parsed\n      byte[] prefix = kb.getBytesForLookup();\n      if (endtime == null) {\n        // if end time is null, place no restriction on end time\n        endtime = Long.MAX_VALUE;\n      }\n      // construct a first key that will be seeked to using end time or fromId\n      byte[] first = null;\n      if (fromId != null) {\n        Long fromIdStartTime = getStartTimeLong(fromId, entityType);\n        if (fromIdStartTime == null) {\n          // no start time for provided id, so return empty entities\n          return new TimelineEntities();\n        }\n        if (fromIdStartTime <= endtime) {\n          // if provided id's start time falls before the end of the window,\n          // use it to construct the seek key\n          first = kb.add(writeReverseOrderedLong(fromIdStartTime))\n              .add(fromId).getBytesForLookup();\n        }\n      }\n      // if seek key wasn't constructed using fromId, construct it using end ts\n      if (first == null) {\n        first = kb.add(writeReverseOrderedLong(endtime)).getBytesForLookup();\n      }\n      byte[] last = null;\n      if (starttime != null) {\n        // if start time is not null, set a last key that will not be\n        // iterated past\n        last = KeyBuilder.newInstance().add(base).add(entityType)\n            .add(writeReverseOrderedLong(starttime)).getBytesForLookup();\n      }\n      if (limit == null) {\n        // if limit is not specified, use the default\n        limit = DEFAULT_LIMIT;\n      }\n\n      TimelineEntities entities = new TimelineEntities();\n      iterator = new LeveldbIterator(db);\n      iterator.seek(first);\n      // iterate until one of the following conditions is met: limit is\n      // reached, there are no more keys, the key prefix no longer matches,\n      // or a start time has been specified and reached/exceeded\n      while (entities.getEntities().size() < limit && iterator.hasNext()) {\n        byte[] key = iterator.peekNext().getKey();\n        if (!prefixMatches(prefix, prefix.length, key) || (last != null &&\n            WritableComparator.compareBytes(key, 0, key.length, last, 0,\n                last.length) > 0)) {\n          break;\n        }\n        // read the start time and entity id from the current key\n        KeyParser kp = new KeyParser(key, prefix.length);\n        Long startTime = kp.getNextLong();\n        String entityId = kp.getNextString();\n\n        if (fromTs != null) {\n          long insertTime = readReverseOrderedLong(iterator.peekNext()\n              .getValue(), 0);\n          if (insertTime > fromTs) {\n            byte[] firstKey = key;\n            while (iterator.hasNext() && prefixMatches(firstKey,\n                kp.getOffset(), key)) {\n              iterator.next();\n              key = iterator.peekNext().getKey();\n            }\n            continue;\n          }\n        }\n\n        // parse the entity that owns this key, iterating over all keys for\n        // the entity\n        TimelineEntity entity = getEntity(entityId, entityType, startTime,\n            fields, iterator, key, kp.getOffset());\n        // determine if the retrieved entity matches the provided secondary\n        // filters, and if so add it to the list of entities to return\n        boolean filterPassed = true;\n        if (secondaryFilters != null) {\n          for (NameValuePair filter : secondaryFilters) {\n            Object v = entity.getOtherInfo().get(filter.getName());\n            if (v == null) {\n              Set<Object> vs = entity.getPrimaryFilters()\n                  .get(filter.getName());\n              if (vs != null && !vs.contains(filter.getValue())) {\n                filterPassed = false;\n                break;\n              }\n            } else if (!v.equals(filter.getValue())) {\n              filterPassed = false;\n              break;\n            }\n          }\n        }\n        if (filterPassed) {\n          entities.addEntity(entity);\n        }\n      }\n      return entities;\n    } catch(DBException e) {\n      throw new IOException(e);   \t\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  List<String> getEntityTypes() throws IOException {\n    DBIterator iterator = null;\n    try {\n      iterator = getDbIterator(false);\n      List<String> entityTypes = new ArrayList<String>();\n      iterator.seek(ENTITY_ENTRY_PREFIX);\n      while (iterator.hasNext()) {\n        byte[] key = iterator.peekNext().getKey();\n        if (key[0] != ENTITY_ENTRY_PREFIX[0]) {\n          break;\n        }\n        KeyParser kp = new KeyParser(key,\n            ENTITY_ENTRY_PREFIX.length);\n        String entityType = kp.getNextString();\n        entityTypes.add(entityType);\n        byte[] lookupKey = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n            .add(entityType).getBytesForLookup();\n        if (lookupKey[lookupKey.length - 1] != 0x0) {\n          throw new IOException(\"Found unexpected end byte in lookup key\");\n        }\n        lookupKey[lookupKey.length - 1] = 0x1;\n        iterator.seek(lookupKey);\n      }\n      return entityTypes;\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","id":9381,"modified_method":"@VisibleForTesting\n  List<String> getEntityTypes() throws IOException {\n    LeveldbIterator iterator = null;\n    try {\n      iterator = getDbIterator(false);\n      List<String> entityTypes = new ArrayList<String>();\n      iterator.seek(ENTITY_ENTRY_PREFIX);\n      while (iterator.hasNext()) {\n        byte[] key = iterator.peekNext().getKey();\n        if (key[0] != ENTITY_ENTRY_PREFIX[0]) {\n          break;\n        }\n        KeyParser kp = new KeyParser(key,\n            ENTITY_ENTRY_PREFIX.length);\n        String entityType = kp.getNextString();\n        entityTypes.add(entityType);\n        byte[] lookupKey = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n            .add(entityType).getBytesForLookup();\n        if (lookupKey[lookupKey.length - 1] != 0x0) {\n          throw new IOException(\"Found unexpected end byte in lookup key\");\n        }\n        lookupKey[lookupKey.length - 1] = 0x1;\n        iterator.seek(lookupKey);\n      }\n      return entityTypes;\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Finds all keys in the db that have a given prefix and deletes them on\n   * the given write batch.\n   */\n  private void deleteKeysWithPrefix(WriteBatch writeBatch, byte[] prefix,\n      DBIterator iterator) {\n    for (iterator.seek(prefix); iterator.hasNext(); iterator.next()) {\n      byte[] key = iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefix.length, key)) {\n        break;\n      }\n      writeBatch.delete(key);\n    }\n  }","id":9382,"modified_method":"/**\n   * Finds all keys in the db that have a given prefix and deletes them on\n   * the given write batch.\n   */\n  private void deleteKeysWithPrefix(WriteBatch writeBatch, byte[] prefix,\n      LeveldbIterator iterator) {\n    for (iterator.seek(prefix); iterator.hasNext(); iterator.next()) {\n      byte[] key = iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefix.length, key)) {\n        break;\n      }\n      writeBatch.delete(key);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Get the unique start time for a given entity as a Long.\n   *\n   * @param entityId The id of the entity\n   * @param entityType The type of the entity\n   * @return A Long, null if not found\n   * @throws IOException\n   */\n  private Long getStartTimeLong(String entityId, String entityType)\n      throws IOException {\n    EntityIdentifier entity = new EntityIdentifier(entityId, entityType);\n    // start time is not provided, so try to look it up\n    if (startTimeReadCache.containsKey(entity)) {\n      // found the start time in the cache\n      return startTimeReadCache.get(entity);\n    } else {\n      // try to look up the start time in the db\n      byte[] b = createStartTimeLookupKey(entity.getId(), entity.getType());\n      byte[] v = db.get(b);\n      if (v == null) {\n        // did not find the start time in the db\n        return null;\n      } else {\n        // found the start time in the db\n        Long l = readReverseOrderedLong(v, 0);\n        startTimeReadCache.put(entity, l);\n        return l;\n      }\n    }\n  }","id":9383,"modified_method":"/**\n   * Get the unique start time for a given entity as a Long.\n   *\n   * @param entityId The id of the entity\n   * @param entityType The type of the entity\n   * @return A Long, null if not found\n   * @throws IOException\n   */\n  private Long getStartTimeLong(String entityId, String entityType)\n      throws IOException {\n    EntityIdentifier entity = new EntityIdentifier(entityId, entityType);\n    try {\n      // start time is not provided, so try to look it up\n      if (startTimeReadCache.containsKey(entity)) {\n        // found the start time in the cache\n        return startTimeReadCache.get(entity);\n      } else {\n        // try to look up the start time in the db\n        byte[] b = createStartTimeLookupKey(entity.getId(), entity.getType());\n        byte[] v = db.get(b);\n        if (v == null) {\n          // did not find the start time in the db\n          return null;\n        } else {\n          // found the start time in the db\n          Long l = readReverseOrderedLong(v, 0);\n          startTimeReadCache.put(entity, l);\n          return l;\n        }\n      }\n    } catch(DBException e) {\n      throw new IOException(e);   \n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"private static TimelineDomain getTimelineDomain(\n      DBIterator iterator, String domainId, byte[] prefix) throws IOException {\n    // Iterate over all the rows whose key starts with prefix to retrieve the\n    // domain information.\n    TimelineDomain domain = new TimelineDomain();\n    domain.setId(domainId);\n    boolean noRows = true;\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key = iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefix.length, key)) {\n        break;\n      }\n      if (noRows) {\n        noRows = false;\n      }\n      byte[] value = iterator.peekNext().getValue();\n      if (value != null && value.length > 0) {\n        if (key[prefix.length] == DESCRIPTION_COLUMN[0]) {\n          domain.setDescription(new String(value));\n        } else if (key[prefix.length] == OWNER_COLUMN[0]) {\n          domain.setOwner(new String(value));\n        } else if (key[prefix.length] == READER_COLUMN[0]) {\n          domain.setReaders(new String(value));\n        } else if (key[prefix.length] == WRITER_COLUMN[0]) {\n          domain.setWriters(new String(value));\n        } else if (key[prefix.length] == TIMESTAMP_COLUMN[0]) {\n          domain.setCreatedTime(readReverseOrderedLong(value, 0));\n          domain.setModifiedTime(readReverseOrderedLong(value, 8));\n        } else {\n          LOG.error(\"Unrecognized domain column: \" + key[prefix.length]);\n        }\n      }\n    }\n    if (noRows) {\n      return null;\n    } else {\n      return domain;\n    }\n  }","id":9384,"modified_method":"private static TimelineDomain getTimelineDomain(\n      LeveldbIterator iterator, String domainId, byte[] prefix) throws IOException {\n    // Iterate over all the rows whose key starts with prefix to retrieve the\n    // domain information.\n    TimelineDomain domain = new TimelineDomain();\n    domain.setId(domainId);\n    boolean noRows = true;\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key = iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefix.length, key)) {\n        break;\n      }\n      if (noRows) {\n        noRows = false;\n      }\n      byte[] value = iterator.peekNext().getValue();\n      if (value != null && value.length > 0) {\n        if (key[prefix.length] == DESCRIPTION_COLUMN[0]) {\n          domain.setDescription(new String(value));\n        } else if (key[prefix.length] == OWNER_COLUMN[0]) {\n          domain.setOwner(new String(value));\n        } else if (key[prefix.length] == READER_COLUMN[0]) {\n          domain.setReaders(new String(value));\n        } else if (key[prefix.length] == WRITER_COLUMN[0]) {\n          domain.setWriters(new String(value));\n        } else if (key[prefix.length] == TIMESTAMP_COLUMN[0]) {\n          domain.setCreatedTime(readReverseOrderedLong(value, 0));\n          domain.setModifiedTime(readReverseOrderedLong(value, 8));\n        } else {\n          LOG.error(\"Unrecognized domain column: \" + key[prefix.length]);\n        }\n      }\n    }\n    if (noRows) {\n      return null;\n    } else {\n      return domain;\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public TimelineDomain getDomain(String domainId)\n      throws IOException {\n    DBIterator iterator = null;\n    try {\n      byte[] prefix = KeyBuilder.newInstance()\n          .add(DOMAIN_ENTRY_PREFIX).add(domainId).getBytesForLookup();\n      iterator = db.iterator();\n      iterator.seek(prefix);\n      return getTimelineDomain(iterator, domainId, prefix);\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","id":9385,"modified_method":"@Override\n  public TimelineDomain getDomain(String domainId)\n      throws IOException {\n    LeveldbIterator iterator = null;\n    try {\n      byte[] prefix = KeyBuilder.newInstance()\n          .add(DOMAIN_ENTRY_PREFIX).add(domainId).getBytesForLookup();\n      iterator = new LeveldbIterator(db);\n      iterator.seek(prefix);\n      return getTimelineDomain(iterator, domainId, prefix);\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public TimelineDomains getDomains(String owner)\n      throws IOException {\n    DBIterator iterator = null;\n    try {\n      byte[] prefix = KeyBuilder.newInstance()\n          .add(OWNER_LOOKUP_PREFIX).add(owner).getBytesForLookup();\n      List<TimelineDomain> domains = new ArrayList<TimelineDomain>();\n      for (iterator = db.iterator(), iterator.seek(prefix);\n          iterator.hasNext();) {\n        byte[] key = iterator.peekNext().getKey();\n        if (!prefixMatches(prefix, prefix.length, key)) {\n          break;\n        }\n        // Iterator to parse the rows of an individual domain\n        KeyParser kp = new KeyParser(key, prefix.length);\n        String domainId = kp.getNextString();\n        byte[] prefixExt = KeyBuilder.newInstance().add(OWNER_LOOKUP_PREFIX)\n            .add(owner).add(domainId).getBytesForLookup();\n        TimelineDomain domainToReturn =\n            getTimelineDomain(iterator, domainId, prefixExt);\n        if (domainToReturn != null) {\n          domains.add(domainToReturn);\n        }\n      }\n      // Sort the domains to return\n      Collections.sort(domains, new Comparator<TimelineDomain>() {\n        @Override\n        public int compare(\n            TimelineDomain domain1, TimelineDomain domain2) {\n           int result = domain2.getCreatedTime().compareTo(\n               domain1.getCreatedTime());\n           if (result == 0) {\n             return domain2.getModifiedTime().compareTo(\n                 domain1.getModifiedTime());\n           } else {\n             return result;\n           }\n        }\n      });\n      TimelineDomains domainsToReturn = new TimelineDomains();\n      domainsToReturn.addDomains(domains);\n      return domainsToReturn;\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","id":9386,"modified_method":"@Override\n  public TimelineDomains getDomains(String owner)\n      throws IOException {\n    LeveldbIterator iterator = null;\n    try {\n      byte[] prefix = KeyBuilder.newInstance()\n          .add(OWNER_LOOKUP_PREFIX).add(owner).getBytesForLookup();\n      List<TimelineDomain> domains = new ArrayList<TimelineDomain>();\n      for (iterator = new LeveldbIterator(db), iterator.seek(prefix);\n          iterator.hasNext();) {\n        byte[] key = iterator.peekNext().getKey();\n        if (!prefixMatches(prefix, prefix.length, key)) {\n          break;\n        }\n        // Iterator to parse the rows of an individual domain\n        KeyParser kp = new KeyParser(key, prefix.length);\n        String domainId = kp.getNextString();\n        byte[] prefixExt = KeyBuilder.newInstance().add(OWNER_LOOKUP_PREFIX)\n            .add(owner).add(domainId).getBytesForLookup();\n        TimelineDomain domainToReturn =\n            getTimelineDomain(iterator, domainId, prefixExt);\n        if (domainToReturn != null) {\n          domains.add(domainToReturn);\n        }\n      }\n      // Sort the domains to return\n      Collections.sort(domains, new Comparator<TimelineDomain>() {\n        @Override\n        public int compare(\n            TimelineDomain domain1, TimelineDomain domain2) {\n           int result = domain2.getCreatedTime().compareTo(\n               domain1.getCreatedTime());\n           if (result == 0) {\n             return domain2.getModifiedTime().compareTo(\n                 domain1.getModifiedTime());\n           } else {\n             return result;\n           }\n        }\n      });\n      TimelineDomains domainsToReturn = new TimelineDomains();\n      domainsToReturn.addDomains(domains);\n      return domainsToReturn;\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@VisibleForTesting\n  DBIterator getDbIterator(boolean fillCache) {\n    ReadOptions readOptions = new ReadOptions();\n    readOptions.fillCache(fillCache);\n    return db.iterator(readOptions);\n  }","id":9387,"modified_method":"@VisibleForTesting\n  LeveldbIterator getDbIterator(boolean fillCache) {\n    ReadOptions readOptions = new ReadOptions();\n    readOptions.fillCache(fillCache);\n    return new LeveldbIterator(db, readOptions);\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"Version loadVersion() throws IOException {\n    byte[] data = db.get(bytes(TIMELINE_STORE_VERSION_KEY));\n    // if version is not stored previously, treat it as 1.0.\n    if (data == null || data.length == 0) {\n      return Version.newInstance(1, 0);\n    }\n    Version version =\n        new VersionPBImpl(VersionProto.parseFrom(data));\n    return version;\n  }","id":9388,"modified_method":"Version loadVersion() throws IOException {\n    try {\n      byte[] data = db.get(bytes(TIMELINE_STORE_VERSION_KEY));\n      // if version is not stored previously, treat it as 1.0.\n      if (data == null || data.length == 0) {\n        return Version.newInstance(1, 0);\n      }\n      Version version =\n          new VersionPBImpl(VersionProto.parseFrom(data));\n      return version;\n    } catch(DBException e) {\n      throw new IOException(e);    \t\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Read entity from a db iterator.  If no information is found in the\n   * specified fields for this entity, return null.\n   */\n  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet<Field> fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields == null) {\n      fields = EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity = new TimelineEntity();\n    boolean events = false;\n    boolean lastEvent = false;\n    if (fields.contains(Field.EVENTS)) {\n      events = true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent = true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities = false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities = true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters = false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters = true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo = false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo = true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity's entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key = iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length == prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] == PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] == OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] == RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] == EVENTS_COLUMN[0]) {\n        if (events || (lastEvent &&\n            entity.getEvents().size() == 0)) {\n          TimelineEvent event = getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event != null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] == DOMAIN_ID_COLUMN[0]) {\n        byte[] v = iterator.peekNext().getValue();\n        String domainId = new String(v);\n        entity.setDomainId(domainId);\n      } else {\n        if (key[prefixlen] !=\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }","id":9389,"modified_method":"/**\n   * Read entity from a db iterator.  If no information is found in the\n   * specified fields for this entity, return null.\n   */\n  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet<Field> fields, LeveldbIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields == null) {\n      fields = EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity = new TimelineEntity();\n    boolean events = false;\n    boolean lastEvent = false;\n    if (fields.contains(Field.EVENTS)) {\n      events = true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent = true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities = false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities = true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters = false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters = true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo = false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo = true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity's entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key = iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length == prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] == PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key,\n              prefixlen + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] == OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length),\n              GenericObjectMapper.read(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] == RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key,\n              prefixlen + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] == EVENTS_COLUMN[0]) {\n        if (events || (lastEvent &&\n            entity.getEvents().size() == 0)) {\n          TimelineEvent event = getEntityEvent(null, key, prefixlen +\n              EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event != null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] == DOMAIN_ID_COLUMN[0]) {\n        byte[] v = iterator.peekNext().getValue();\n        String domainId = new String(v);\n        entity.setDomainId(domainId);\n      } else {\n        if (key[prefixlen] !=\n            INVISIBLE_REVERSE_RELATED_ENTITIES_COLUMN[0]) {\n          LOG.warn(String.format(\"Found unexpected column for entity %s of \" +\n              \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n        }\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public TimelineEntity getEntity(String entityId, String entityType,\n      EnumSet<Field> fields) throws IOException {\n    Long revStartTime = getStartTimeLong(entityId, entityType);\n    if (revStartTime == null) {\n      return null;\n    }\n    byte[] prefix = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n        .add(entityType).add(writeReverseOrderedLong(revStartTime))\n        .add(entityId).getBytesForLookup();\n\n    DBIterator iterator = null;\n    try {\n      iterator = db.iterator();\n      iterator.seek(prefix);\n\n      return getEntity(entityId, entityType, revStartTime, fields, iterator,\n          prefix, prefix.length);\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","id":9390,"modified_method":"@Override\n  public TimelineEntity getEntity(String entityId, String entityType,\n      EnumSet<Field> fields) throws IOException {\n    Long revStartTime = getStartTimeLong(entityId, entityType);\n    if (revStartTime == null) {\n      return null;\n    }\n    byte[] prefix = KeyBuilder.newInstance().add(ENTITY_ENTRY_PREFIX)\n        .add(entityType).add(writeReverseOrderedLong(revStartTime))\n        .add(entityId).getBytesForLookup();\n\n    LeveldbIterator iterator = null;\n    try {\n      iterator = new LeveldbIterator(db);\n      iterator.seek(prefix);\n\n      return getEntity(entityId, entityType, revStartTime, fields, iterator,\n          prefix, prefix.length);\n    } catch(DBException e) {\n      throw new IOException(e);            \t\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"private boolean deleteNextEntity(String entityType, byte[] ts)\n      throws IOException, InterruptedException {\n    DBIterator iterator = null;\n    DBIterator pfIterator = null;\n    try {\n      iterator = ((LeveldbTimelineStore)store).getDbIterator(false);\n      pfIterator = ((LeveldbTimelineStore)store).getDbIterator(false);\n      return ((LeveldbTimelineStore)store).deleteNextEntity(entityType, ts,\n          iterator, pfIterator, false);\n    } finally {\n      IOUtils.cleanup(null, iterator, pfIterator);\n    }\n  }","id":9391,"modified_method":"private boolean deleteNextEntity(String entityType, byte[] ts)\n      throws IOException, InterruptedException {\n    LeveldbIterator iterator = null;\n    LeveldbIterator pfIterator = null;\n    try {\n      iterator = ((LeveldbTimelineStore)store).getDbIterator(false);\n      pfIterator = ((LeveldbTimelineStore)store).getDbIterator(false);\n      return ((LeveldbTimelineStore)store).deleteNextEntity(entityType, ts,\n          iterator, pfIterator, false);\n    } catch(DBException e) {\n      throw new IOException(e);   \t\n    } finally {\n      IOUtils.cleanup(null, iterator, pfIterator);\n    }\n  }","commit_id":"1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1","url":"https://github.com/apache/hadoop"},{"original_method":"public CustomJspBagImpl(\n\t\tServletContext servletContext, String customJspDir,\n\t\tboolean customJspGlobal, String pluginPackageName) {\n\n\t\t_servletContext = servletContext;\n\t\t_customJspDir = customJspDir;\n\t\t_customJspGlobal = customJspGlobal;\n\t\t_pluginPackageName = pluginPackageName;\n\n\t\t_customJsps = new ArrayList<>();\n\t}","id":9392,"modified_method":"public CustomJspBagImpl(\n\t\tURLContainer urlContainer, String customJspDir,\n\t\tboolean customJspGlobal) {\n\n\t\t_urlContainer = urlContainer;\n\t\t_customJspDir = customJspDir;\n\t\t_customJspGlobal = customJspGlobal;\n\n\t\t_customJsps = new ArrayList<>();\n\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void getCustomJsps(\n\t\tServletContext servletContext, String resourcePath,\n\t\tList<String> customJsps) {\n\n\t\tSet<String> resourcePaths = servletContext.getResourcePaths(\n\t\t\tresourcePath);\n\n\t\tif ((resourcePaths == null) || resourcePaths.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String curResourcePath : resourcePaths) {\n\t\t\tif (curResourcePath.endsWith(StringPool.SLASH)) {\n\t\t\t\tgetCustomJsps(servletContext, curResourcePath, customJsps);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString customJsp = curResourcePath;\n\n\t\t\t\tcustomJsp = StringUtil.replace(\n\t\t\t\t\tcustomJsp, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\t\t\tcustomJsps.add(customJsp);\n\t\t\t}\n\t\t}\n\t}","id":9393,"modified_method":"protected void getCustomJsps(\n\t\tURLContainer urlContainer, String resourcePath,\n\t\tList<String> customJsps) {\n\n\t\tSet<String> resourcePaths = urlContainer.getResources(resourcePath);\n\n\t\tif ((resourcePaths == null) || resourcePaths.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String curResourcePath : resourcePaths) {\n\t\t\tif (curResourcePath.endsWith(StringPool.SLASH)) {\n\t\t\t\tgetCustomJsps(urlContainer, curResourcePath, customJsps);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString customJsp = curResourcePath;\n\n\t\t\t\tcustomJsp = StringUtil.replace(\n\t\t\t\t\tcustomJsp, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\t\t\tcustomJsps.add(customJsp);\n\t\t\t}\n\t\t}\n\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void verifyCustomJsps(\n\t\t\tString servletContextName, CustomJspBag customJspBag)\n\t\tthrows DuplicateCustomJspException {\n\n\t\tSet<String> customJsps = new HashSet<>();\n\n\t\tfor (String customJsp : customJspBag.getCustomJsps()) {\n\t\t\tString portalJsp = getPortalJsp(\n\t\t\t\tcustomJsp, customJspBag.getCustomJspDir());\n\n\t\t\tcustomJsps.add(portalJsp);\n\t\t}\n\n\t\tMap<String, String> conflictingCustomJsps = new HashMap<>();\n\n\t\tfor (Map.Entry<String, CustomJspBag> entry :\n\t\t\t\t_customJspBagsMap.entrySet()) {\n\n\t\t\tCustomJspBag currentCustomJspBag = entry.getValue();\n\n\t\t\tif (!currentCustomJspBag.isCustomJspGlobal()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString currentServletContextName = entry.getKey();\n\n\t\t\tList<String> currentCustomJsps =\n\t\t\t\tcurrentCustomJspBag.getCustomJsps();\n\n\t\t\tfor (String currentCustomJsp : currentCustomJsps) {\n\t\t\t\tString currentPortalJsp = getPortalJsp(\n\t\t\t\t\tcurrentCustomJsp, currentCustomJspBag.getCustomJspDir());\n\n\t\t\t\tif (customJsps.contains(currentPortalJsp)) {\n\t\t\t\t\tconflictingCustomJsps.put(\n\t\t\t\t\t\tcurrentPortalJsp, currentServletContextName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conflictingCustomJsps.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_log.error(servletContextName + \" conflicts with the installed hooks\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tLog log = SanitizerLogWrapper.allowCRLF(_log);\n\n\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\tconflictingCustomJsps.size() * 4 + 2);\n\n\t\t\tsb.append(\"Colliding JSP files in \");\n\t\t\tsb.append(servletContextName);\n\t\t\tsb.append(StringPool.NEW_LINE);\n\n\t\t\tint i = 0;\n\n\t\t\tfor (Map.Entry<String, String> entry :\n\t\t\t\t\tconflictingCustomJsps.entrySet()) {\n\n\t\t\t\tsb.append(entry.getKey());\n\t\t\t\tsb.append(\" with \");\n\t\t\t\tsb.append(entry.getValue());\n\n\t\t\t\tif ((i + 1) < conflictingCustomJsps.size()) {\n\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tlog.debug(sb.toString());\n\t\t}\n\n\t\tthrow new DuplicateCustomJspException();\n\t}","id":9394,"modified_method":"protected void verifyCustomJsps(String contextId, CustomJspBag customJspBag)\n\t\tthrows DuplicateCustomJspException {\n\n\t\tSet<String> customJsps = new HashSet<>();\n\n\t\tfor (String customJsp : customJspBag.getCustomJsps()) {\n\t\t\tString portalJsp = getPortalJsp(\n\t\t\t\tcustomJsp, customJspBag.getCustomJspDir());\n\n\t\t\tcustomJsps.add(portalJsp);\n\t\t}\n\n\t\tMap<String, String> conflictingCustomJsps = new HashMap<>();\n\n\t\tfor (Map.Entry<ServiceReference<CustomJspBag>, CustomJspBag> entry :\n\t\t\t\t_customJspBagsMap.entrySet()) {\n\n\t\t\tCustomJspBag currentCustomJspBag = entry.getValue();\n\n\t\t\tif (!currentCustomJspBag.isCustomJspGlobal()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tServiceReference<CustomJspBag> serviceReference = entry.getKey();\n\n\t\t\tString contextName = GetterUtil.getString(\n\t\t\t\tserviceReference.getProperty(\"context.name\"));\n\n\t\t\tList<String> currentCustomJsps =\n\t\t\t\tcurrentCustomJspBag.getCustomJsps();\n\n\t\t\tfor (String currentCustomJsp : currentCustomJsps) {\n\t\t\t\tString currentPortalJsp = getPortalJsp(\n\t\t\t\t\tcurrentCustomJsp, currentCustomJspBag.getCustomJspDir());\n\n\t\t\t\tif (customJsps.contains(currentPortalJsp)) {\n\t\t\t\t\tconflictingCustomJsps.put(currentPortalJsp, contextName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (conflictingCustomJsps.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t_log.error(contextId + \" conflicts with the installed hooks\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tLog log = SanitizerLogWrapper.allowCRLF(_log);\n\n\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\tconflictingCustomJsps.size() * 4 + 2);\n\n\t\t\tsb.append(\"Colliding JSP files in \");\n\t\t\tsb.append(contextId);\n\t\t\tsb.append(StringPool.NEW_LINE);\n\n\t\t\tint i = 0;\n\n\t\t\tfor (Map.Entry<String, String> entry :\n\t\t\t\t\tconflictingCustomJsps.entrySet()) {\n\n\t\t\t\tsb.append(entry.getKey());\n\t\t\t\tsb.append(\" with \");\n\t\t\t\tsb.append(entry.getValue());\n\n\t\t\t\tif ((i + 1) < conflictingCustomJsps.size()) {\n\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tlog.debug(sb.toString());\n\t\t}\n\n\t\tthrow new DuplicateCustomJspException();\n\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private CustomJspBagRegistryUtil() {\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\t_serviceTracker = registry.trackServices(\n\t\t\t\tCustomJspBag.class,\n\t\t\t\tnew CustomJspBagRegistryUtilServiceTrackerCustomizer());\n\n\t\t\t_serviceTracker.open();\n\t\t}","id":9395,"modified_method":"private CustomJspBagRegistryUtil() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tFilter filter = registry.getFilter(\n\t\t\t\"(&(context.id=*)(context.name=*)(objectClass=\" +\n\t\t\t\tCustomJspBag.class.getName() + \"))\");\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tfilter, new CustomJspBagRegistryUtilServiceTrackerCustomizer());\n\n\t\t_serviceTracker.open();\n\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic CustomJspBag addingService(\n\t\t\tServiceReference<CustomJspBag> serviceReference) {\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tCustomJspBag customJspBag = registry.getService(serviceReference);\n\n\t\t\tList<String> customJsps = customJspBag.getCustomJsps();\n\n\t\t\tif (customJsps.isEmpty()) {\n\t\t\t\tgetCustomJsps(\n\t\t\t\t\tcustomJspBag.getServletContext(),\n\t\t\t\t\tcustomJspBag.getCustomJspDir(),\n\t\t\t\t\tcustomJspBag.getCustomJsps());\n\n\t\t\t\tcustomJsps = customJspBag.getCustomJsps();\n\n\t\t\t\tif (customJsps.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(customJsps.size() * 2);\n\n\t\t\t\tsb.append(\"Custom JSP files:\\n\");\n\n\t\t\t\tfor (int i = 0; i < customJsps.size(); i++) {\n\t\t\t\t\tString customJsp = customJsps.get(0);\n\n\t\t\t\t\tsb.append(customJsp);\n\n\t\t\t\t\tif ((i + 1) < customJsps.size()) {\n\t\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tLog log = SanitizerLogWrapper.allowCRLF(_log);\n\n\t\t\t\tlog.debug(sb.toString());\n\t\t\t}\n\n\t\t\tString servletContextName = customJspBag.getServletContextName();\n\n\t\t\tif (\n\t\t\t\t\tcustomJspBag.isCustomJspGlobal() &&\n\t\t\t\t!_customJspBagsMap.isEmpty() &&\n\t\t\t\t!_customJspBagsMap.containsKey(servletContextName)) {\n\n\t\t\t\ttry {\n\t\t\t\t\tverifyCustomJsps(servletContextName, customJspBag);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateCustomJspException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_customJspBagsMap.put(servletContextName, customJspBag);\n\n\t\t\ttry {\n\t\t\t\tinitCustomJspBag(\n\t\t\t\t\tservletContextName, customJspBag.getPluginPackageName(),\n\t\t\t\t\tcustomJspBag);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn customJspBag;\n\t\t}","id":9396,"modified_method":"@Override\n\t\tpublic CustomJspBag addingService(\n\t\t\tServiceReference<CustomJspBag> serviceReference) {\n\n\t\t\tString contextId = GetterUtil.getString(\n\t\t\t\tserviceReference.getProperty(\"context.id\"));\n\t\t\tString contextName = GetterUtil.getString(\n\t\t\t\tserviceReference.getProperty(\"context.name\"));\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tCustomJspBag customJspBag = registry.getService(serviceReference);\n\n\t\t\tList<String> customJsps = customJspBag.getCustomJsps();\n\n\t\t\tif (customJsps.isEmpty()) {\n\t\t\t\tgetCustomJsps(\n\t\t\t\t\tcustomJspBag.getURLContainer(),\n\t\t\t\t\tcustomJspBag.getCustomJspDir(),\n\t\t\t\t\tcustomJspBag.getCustomJsps());\n\n\t\t\t\tcustomJsps = customJspBag.getCustomJsps();\n\n\t\t\t\tif (customJsps.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tStringBundler sb = new StringBundler(customJsps.size() * 2);\n\n\t\t\t\tsb.append(\"Custom JSP files:\\n\");\n\n\t\t\t\tfor (int i = 0; i < customJsps.size(); i++) {\n\t\t\t\t\tString customJsp = customJsps.get(0);\n\n\t\t\t\t\tsb.append(customJsp);\n\n\t\t\t\t\tif ((i + 1) < customJsps.size()) {\n\t\t\t\t\t\tsb.append(StringPool.NEW_LINE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tLog log = SanitizerLogWrapper.allowCRLF(_log);\n\n\t\t\t\tlog.debug(sb.toString());\n\t\t\t}\n\n\t\t\tif (customJspBag.isCustomJspGlobal() &&\n\t\t\t\t!_customJspBagsMap.isEmpty()) {\n\n\t\t\t\ttry {\n\t\t\t\t\tverifyCustomJsps(contextId, customJspBag);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateCustomJspException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_customJspBagsMap.put(serviceReference, customJspBag);\n\n\t\t\ttry {\n\t\t\t\tinitCustomJspBag(contextId, contextName, customJspBag);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn customJspBag;\n\t\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initCustomJspBag(\n\t\t\tString servletContextName, String displayName,\n\t\t\tCustomJspBag customJspBag)\n\t\tthrows Exception {\n\n\t\tString customJspDir = customJspBag.getCustomJspDir();\n\t\tboolean customJspGlobal = customJspBag.isCustomJspGlobal();\n\t\tList<String> customJsps = customJspBag.getCustomJsps();\n\n\t\tString portalWebDir = PortalUtil.getPortalWebDir();\n\n\t\tfor (String customJsp : customJsps) {\n\t\t\tString portalJsp = getPortalJsp(customJsp, customJspDir);\n\n\t\t\tif (customJspGlobal) {\n\t\t\t\tFile portalJspFile = new File(portalWebDir + portalJsp);\n\t\t\t\tFile portalJspBackupFile = getPortalJspBackupFile(\n\t\t\t\t\tportalJspFile);\n\n\t\t\t\tif (portalJspFile.exists() && !portalJspBackupFile.exists()) {\n\t\t\t\t\tFileUtil.copyFile(portalJspFile, portalJspBackupFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportalJsp = CustomJspRegistryUtil.getCustomJspFileName(\n\t\t\t\t\tservletContextName, portalJsp);\n\t\t\t}\n\n\t\t\tFileUtil.write(\n\t\t\t\tportalWebDir + portalJsp,\n\t\t\t\tgetCustomJspInputStream(\n\t\t\t\t\tcustomJspBag.getServletContext(), customJsp));\n\t\t}\n\n\t\tif (!customJspGlobal) {\n\t\t\tCustomJspRegistryUtil.registerServletContextName(\n\t\t\t\tservletContextName, displayName);\n\t\t}\n\t}","id":9397,"modified_method":"protected void initCustomJspBag(\n\t\t\tString contextId, String contextName, CustomJspBag customJspBag)\n\t\tthrows Exception {\n\n\t\tString customJspDir = customJspBag.getCustomJspDir();\n\t\tboolean customJspGlobal = customJspBag.isCustomJspGlobal();\n\t\tList<String> customJsps = customJspBag.getCustomJsps();\n\n\t\tString portalWebDir = PortalUtil.getPortalWebDir();\n\n\t\tfor (String customJsp : customJsps) {\n\t\t\tString portalJsp = getPortalJsp(customJsp, customJspDir);\n\n\t\t\tif (customJspGlobal) {\n\t\t\t\tFile portalJspFile = new File(portalWebDir + portalJsp);\n\t\t\t\tFile portalJspBackupFile = getPortalJspBackupFile(\n\t\t\t\t\tportalJspFile);\n\n\t\t\t\tif (portalJspFile.exists() && !portalJspBackupFile.exists()) {\n\t\t\t\t\tFileUtil.copyFile(portalJspFile, portalJspBackupFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportalJsp = CustomJspRegistryUtil.getCustomJspFileName(\n\t\t\t\t\tcontextId, portalJsp);\n\t\t\t}\n\n\t\t\tFileUtil.write(\n\t\t\t\tportalWebDir + portalJsp,\n\t\t\t\tgetCustomJspInputStream(\n\t\t\t\t\tcustomJspBag.getURLContainer(), customJsp));\n\t\t}\n\n\t\tif (!customJspGlobal) {\n\t\t\tCustomJspRegistryUtil.registerServletContextName(\n\t\t\t\tcontextId, contextName);\n\t\t}\n\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic void modifiedService(\n\t\t\tServiceReference<CustomJspBag> serviceReference,\n\t\t\tCustomJspBag customJspBag) {\n\t\t}","id":9398,"modified_method":"@Override\n\t\tpublic void modifiedService(\n\t\t\tServiceReference<CustomJspBag> serviceReference,\n\t\t\tCustomJspBag customJspBag) {\n\n\t\t\tremovedService(serviceReference, customJspBag);\n\t\t\taddingService(serviceReference);\n\t\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic void removedService(\n\t\t\tServiceReference<CustomJspBag> serviceReference,\n\t\t\tCustomJspBag customJspBag) {\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tregistry.ungetService(serviceReference);\n\n\t\t\tString customJspDir = customJspBag.getCustomJspDir();\n\t\t\tboolean customJspGlobal = customJspBag.isCustomJspGlobal();\n\t\t\tList<String> customJsps = customJspBag.getCustomJsps();\n\n\t\t\tString portalWebDir = PortalUtil.getPortalWebDir();\n\n\t\t\tfor (String customJsp : customJsps) {\n\t\t\t\tint pos = customJsp.indexOf(customJspDir);\n\n\t\t\t\tString portalJsp = customJsp.substring(\n\t\t\t\t\tpos + customJspDir.length());\n\n\t\t\t\tif (customJspGlobal) {\n\t\t\t\t\tFile portalJspFile = new File(portalWebDir + portalJsp);\n\t\t\t\t\tFile portalJspBackupFile = getPortalJspBackupFile(\n\t\t\t\t\t\tportalJspFile);\n\n\t\t\t\t\tif (portalJspBackupFile.exists()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFileUtil.copyFile(\n\t\t\t\t\t\t\t\tportalJspBackupFile, portalJspFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tportalJspBackupFile.delete();\n\t\t\t\t\t}\n\t\t\t\t\telse if (portalJspFile.exists()) {\n\t\t\t\t\t\tportalJspFile.delete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tportalJsp = CustomJspRegistryUtil.getCustomJspFileName(\n\t\t\t\t\t\tcustomJspBag.getServletContextName(), portalJsp);\n\n\t\t\t\t\t\tFile portalJspFile = new File(portalWebDir + portalJsp);\n\n\t\t\t\t\t\tif (portalJspFile.exists()) {\n\t\t\t\t\t\t\tportalJspFile.delete();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!customJspGlobal) {\n\t\t\t\t\tCustomJspRegistryUtil.unregisterServletContextName(\n\t\t\t\t\t\tcustomJspBag.getServletContextName());\n\t\t\t\t}\n\n\t\t\t\t_customJspBagsMap.remove(customJspBag.getServletContextName());\n\t\t\t}","id":9399,"modified_method":"@Override\n\t\tpublic void removedService(\n\t\t\tServiceReference<CustomJspBag> serviceReference,\n\t\t\tCustomJspBag customJspBag) {\n\n\t\t\tString contextId = GetterUtil.getString(\n\t\t\t\tserviceReference.getProperty(\"context.id\"));\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tregistry.ungetService(serviceReference);\n\n\t\t\tString customJspDir = customJspBag.getCustomJspDir();\n\t\t\tboolean customJspGlobal = customJspBag.isCustomJspGlobal();\n\t\t\tList<String> customJsps = customJspBag.getCustomJsps();\n\n\t\t\tString portalWebDir = PortalUtil.getPortalWebDir();\n\n\t\t\tfor (String customJsp : customJsps) {\n\t\t\t\tint pos = customJsp.indexOf(customJspDir);\n\n\t\t\t\tString portalJsp = customJsp.substring(\n\t\t\t\t\tpos + customJspDir.length());\n\n\t\t\t\tif (customJspGlobal) {\n\t\t\t\t\tFile portalJspFile = new File(portalWebDir + portalJsp);\n\t\t\t\t\tFile portalJspBackupFile = getPortalJspBackupFile(\n\t\t\t\t\t\tportalJspFile);\n\n\t\t\t\t\tif (portalJspBackupFile.exists()) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tFileUtil.copyFile(\n\t\t\t\t\t\t\t\tportalJspBackupFile, portalJspFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IOException e) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tportalJspBackupFile.delete();\n\t\t\t\t\t}\n\t\t\t\t\telse if (portalJspFile.exists()) {\n\t\t\t\t\t\tportalJspFile.delete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tportalJsp = CustomJspRegistryUtil.getCustomJspFileName(\n\t\t\t\t\t\tcontextId, portalJsp);\n\n\t\t\t\t\tFile portalJspFile = new File(portalWebDir + portalJsp);\n\n\t\t\t\t\tif (portalJspFile.exists()) {\n\t\t\t\t\t\tportalJspFile.delete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!customJspGlobal) {\n\t\t\t\tCustomJspRegistryUtil.unregisterServletContextName(contextId);\n\t\t\t}\n\n\t\t\t_customJspBagsMap.remove(serviceReference);\n\t\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected InputStream getCustomJspInputStream(\n\t\tServletContext servletContext, String customJsp) {\n\n\t\treturn servletContext.getResourceAsStream(customJsp);\n\t}","id":9400,"modified_method":"protected InputStream getCustomJspInputStream(\n\t\t\tURLContainer urlContainer, String customJsp)\n\t\tthrows IOException {\n\n\t\tURL url = urlContainer.getResource(customJsp);\n\n\t\treturn url.openStream();\n\t}","commit_id":"2b7a836621eece880d93a14847c8dab60bce3542","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic AuthVerifierConfiguration addingService(\n\t\t\tServiceReference<AuthVerifier> serviceReference) {\n\n\t\t\tif (Validator.isNull(\n\t\t\t\t\tserviceReference.getProperty(\"urls.includes\"))) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tAuthVerifier authVerifier = registry.getService(serviceReference);\n\n\t\t\tClass<?> authVerifierClass = authVerifier.getClass();\n\n\t\t\tAuthVerifierConfiguration authVerifierConfiguration =\n\t\t\t\tnew AuthVerifierConfiguration();\n\n\t\t\tauthVerifierConfiguration.setAuthVerifier(authVerifier);\n\t\t\tauthVerifierConfiguration.setAuthVerifierClassName(\n\t\t\t\tauthVerifierClass.getName());\n\t\t\tauthVerifierConfiguration.setProperties(\n\t\t\t\tPropertiesUtil.fromMap(serviceReference.getProperties()));\n\n\t\t\t_authVerifierConfigurations.add(0, authVerifierConfiguration);\n\n\t\t\treturn authVerifierConfiguration;\n\t\t}","id":9401,"modified_method":"@Override\n\t\tpublic AuthVerifierConfiguration addingService(\n\t\t\tServiceReference<AuthVerifier> serviceReference) {\n\n\t\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t\tAuthVerifier authVerifier = registry.getService(serviceReference);\n\n\t\t\tClass<?> authVerifierClass = authVerifier.getClass();\n\n\t\t\tAuthVerifierConfiguration authVerifierConfiguration =\n\t\t\t\tnew AuthVerifierConfiguration();\n\n\t\t\tauthVerifierConfiguration.setAuthVerifier(authVerifier);\n\t\t\tauthVerifierConfiguration.setAuthVerifierClassName(\n\t\t\t\tauthVerifierClass.getName());\n\t\t\tauthVerifierConfiguration.setProperties(\n\t\t\t\tPropertiesUtil.fromMap(serviceReference.getProperties()));\n\n\t\t\t_authVerifierConfigurations.add(0, authVerifierConfiguration);\n\n\t\t\treturn authVerifierConfiguration;\n\t\t}","commit_id":"f854837435ca6dbc2cd766a2960e6340d2b06322","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private AuthVerifierPipeline() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tAuthVerifier.class, new AuthVerifierTrackerCustomizer());\n\n\t\t_serviceTracker.open();\n\t}","id":9402,"modified_method":"private AuthVerifierPipeline() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tFilter authVerifierPipelineFilter = registry.getFilter(\n\t\t\t\"(&(objectClass=\" + AuthVerifier.class.getName() +\n\t\t\t\t\")(urls.includes=*))\");\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tauthVerifierPipelineFilter, new AuthVerifierTrackerCustomizer());\n\n\t\t_serviceTracker.open();\n\t}","commit_id":"f854837435ca6dbc2cd766a2960e6340d2b06322","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private TemplateManagerUtil() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tTemplateManager.class,\n\t\t\tnew TemplateManagerServiceTrackerCustomizer());\n\n\t\t_serviceTracker.open();\n\t}","id":9403,"modified_method":"private TemplateManagerUtil() {\n\t\tRegistry registry = RegistryUtil.getRegistry();\n\n\t\tcom.liferay.registry.Filter filter = registry.getFilter(\n\t\t\t\"(&(language.type=*)(objectClass=\" +\n\t\t\t\tTemplateManager.class.getName() + \"))\");\n\n\t\t_serviceTracker = registry.trackServices(\n\t\t\tfilter, new TemplateManagerServiceTrackerCustomizer());\n\n\t\t_serviceTracker.open();\n\t}","commit_id":"a1382fa514991735a97cab007ecd3fae22d3746b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<JCAnnotation> makeAtType(String name) {\n        if (disableModelAnnotations)\n            return List.nil();\n        return List.<JCAnnotation> of(make().Annotation(makeIdent(syms.ceylonAtTypeInfoType), List.<JCExpression> of(make().Literal(name))));\n    }","id":9404,"modified_method":"public List<JCAnnotation> makeAtType(String name) {\n        return makeModelAnnotation(syms.ceylonAtTypeInfoType, List.<JCExpression>of(make().Literal(name)));\n    }","commit_id":"46092911ca5262d6d13ad6f8247c5856854c0536","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCAnnotation> makeAtAttribute() {\n        if (disableModelAnnotations)\n            return List.nil();\n        return List.<JCAnnotation> of(make().Annotation(makeIdent(syms.ceylonAtAttributeType), List.<JCExpression> nil()));\n    }","id":9405,"modified_method":"public List<JCAnnotation> makeAtAttribute() {\n        return makeModelAnnotation(syms.ceylonAtAttributeType);\n    }","commit_id":"46092911ca5262d6d13ad6f8247c5856854c0536","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCAnnotation> makeAtCeylon() {\n        if (disableModelAnnotations)\n            return List.nil();\n        return List.<JCAnnotation> of(make().Annotation(makeIdent(syms.ceylonAtCeylonType), List.<JCExpression> nil()));\n    }","id":9406,"modified_method":"public List<JCAnnotation> makeAtCeylon() {\n        return makeModelAnnotation(syms.ceylonAtCeylonType);\n    }","commit_id":"46092911ca5262d6d13ad6f8247c5856854c0536","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCAnnotation> makeAtName(String name) {\n        if (disableModelAnnotations)\n            return List.nil();\n        return List.<JCAnnotation> of(make().Annotation(makeIdent(syms.ceylonAtNameType), List.<JCExpression> of(make().Literal(name))));\n    }","id":9407,"modified_method":"public List<JCAnnotation> makeAtName(String name) {\n        return makeModelAnnotation(syms.ceylonAtNameType, List.<JCExpression>of(make().Literal(name)));\n    }","commit_id":"46092911ca5262d6d13ad6f8247c5856854c0536","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public List<JCAnnotation> makeAtMethod() {\n        if (disableModelAnnotations)\n            return List.nil();\n        return List.<JCAnnotation> of(make().Annotation(makeIdent(syms.ceylonAtMethodType), List.<JCExpression> nil()));\n    }","id":9408,"modified_method":"public List<JCAnnotation> makeAtMethod() {\n        return makeModelAnnotation(syms.ceylonAtMethodType);\n    }","commit_id":"46092911ca5262d6d13ad6f8247c5856854c0536","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n   * List of all objects to be injected in the picocontainer dedicated to computation stack.\n   * Does not contain the steps declared in {@link org.sonar.server.computation.step.ComputationSteps#orderedStepClasses()}.\n   */\n  private static List componentClasses() {\n    return Arrays.asList(\n      ActivityManager.class,\n      ReportExtractor.class,\n      BatchReportReaderImpl.class,\n\n      // repositories\n      PlatformLanguageRepository.class,\n      MeasureRepositoryImpl.class,\n      ProjectSettingsRepository.class,\n\n      // component caches\n      DbComponentsRefCache.class,\n\n      // issues\n      ScmAccountCacheLoader.class,\n      ScmAccountCache.class,\n      SourceLinesCache.class,\n      IssueComputation.class,\n      RuleCache.class,\n      RuleCacheLoader.class,\n      IssueCache.class,\n      MetricCache.class,\n      UpdateConflictResolver.class,\n\n      // views\n      ViewIndex.class,\n\n      // ComputationService\n      ComputationService.class\n      );\n  }","id":9409,"modified_method":"/**\n   * List of all objects to be injected in the picocontainer dedicated to computation stack.\n   * Does not contain the steps declared in {@link org.sonar.server.computation.step.ComputationSteps#orderedStepClasses()}.\n   */\n  private static List componentClasses() {\n    return Arrays.asList(\n      ActivityManager.class,\n      ReportExtractor.class,\n      BatchReportReaderImpl.class,\n\n      // repositories\n      PlatformLanguageRepository.class,\n      MeasureRepositoryImpl.class,\n      EventRepositoryImpl.class,\n      ProjectSettingsRepository.class,\n\n      // component caches\n      DbComponentsRefCache.class,\n\n      // issues\n      ScmAccountCacheLoader.class,\n      ScmAccountCache.class,\n      SourceLinesCache.class,\n      IssueComputation.class,\n      RuleCache.class,\n      RuleCacheLoader.class,\n      IssueCache.class,\n      MetricCache.class,\n      UpdateConflictResolver.class,\n\n      // views\n      ViewIndex.class,\n\n      // ComputationService\n      ComputationService.class\n      );\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void markAsAdded(Component component, QualityProfile profile) {\n    component.getEventRepository().add(createQProfileEvent(component, profile, \"Use %s\"));\n  }","id":9410,"modified_method":"private void markAsAdded(Component component, QualityProfile profile) {\n    eventRepository.add(component, createQProfileEvent(component, profile, \"Use %s\"));\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void markAsRemoved(Component component, QualityProfile profile) {\n    component.getEventRepository().add(createQProfileEvent(component, profile, \"Stop using %s\"));\n  }","id":9411,"modified_method":"private void markAsRemoved(Component component, QualityProfile profile) {\n    eventRepository.add(component, createQProfileEvent(component, profile, \"Stop using %s\"));\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QualityProfileEventsStep(MeasureRepository measureRepository) {\n    this.measureRepository = measureRepository;\n  }","id":9412,"modified_method":"public QualityProfileEventsStep(MeasureRepository measureRepository, EventRepository eventRepository) {\n    this.measureRepository = measureRepository;\n    this.eventRepository = eventRepository;\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void markAsChanged(Component component, QualityProfile previousProfile, QualityProfile profile) {\n    Date from = previousProfile.getRulesUpdatedAt();\n\n    String data = KeyValueFormat.format(ImmutableSortedMap.of(\n        \"key\", profile.getQpKey(),\n        \"from\", UtcDateUtils.formatDateTime(fixDate(from)),\n        \"to\", UtcDateUtils.formatDateTime(fixDate(profile.getRulesUpdatedAt()))));\n    component.getEventRepository().add(createQProfileEvent(component, profile, \"Changes in %s\", data));\n  }","id":9413,"modified_method":"private void markAsChanged(Component component, QualityProfile previousProfile, QualityProfile profile) {\n    Date from = previousProfile.getRulesUpdatedAt();\n\n    String data = KeyValueFormat.format(ImmutableSortedMap.of(\n        \"key\", profile.getQpKey(),\n        \"from\", UtcDateUtils.formatDateTime(fixDate(from)),\n        \"to\", UtcDateUtils.formatDateTime(fixDate(profile.getRulesUpdatedAt()))));\n    eventRepository.add(component, createQProfileEvent(component, profile, \"Changes in %s\", data));\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void added_event_uses_language_key_in_message_if_language_not_found() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockLanguageNotInRepository(LANGUAGE_KEY_1);\n    mockMeasures(context.getRoot(), null, arrayOf(qp));\n\n    underTest.execute(context);\n\n    List<Event> events = Lists.newArrayList(context.getRoot().getEventRepository().getEvents());\n    assertThat(events).hasSize(1);\n    verifyEvent(events.get(0), \"Use '\" + qp.getQpName() + \"' (\" + qp.getLanguageKey() + \")\", null);\n  }","id":9414,"modified_method":"@Test\n  public void added_event_uses_language_key_in_message_if_language_not_found() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockLanguageNotInRepository(LANGUAGE_KEY_1);\n    mockMeasures(context.getRoot(), null, arrayOf(qp));\n\n    underTest.execute(context);\n\n    verify(eventRepository).add(eq(context.getRoot()), eventArgumentCaptor.capture());\n    verifyNoMoreInteractions(eventRepository);\n    verifyEvent(eventArgumentCaptor.getValue(), \"Use '\" + qp.getQpName() + \"' (\" + qp.getLanguageKey() + \")\", null);\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void no_more_used_event_uses_language_key_in_message_if_language_not_found() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp), null);\n    mockLanguageNotInRepository(LANGUAGE_KEY_1);\n\n    underTest.execute(context);\n\n    List<Event> events = Lists.newArrayList(context.getRoot().getEventRepository().getEvents());\n    assertThat(events).hasSize(1);\n    verifyEvent(events.get(0), \"Stop using '\" + qp.getQpName() + \"' (\" + qp.getLanguageKey() + \")\", null);\n  }","id":9415,"modified_method":"@Test\n  public void no_more_used_event_uses_language_key_in_message_if_language_not_found() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp), null);\n    mockLanguageNotInRepository(LANGUAGE_KEY_1);\n\n    underTest.execute(context);\n\n    verify(eventRepository).add(eq(context.getRoot()), eventArgumentCaptor.capture());\n    verifyNoMoreInteractions(eventRepository);\n    verifyEvent(eventArgumentCaptor.getValue(), \"Stop using '\" + qp.getQpName() + \"' (\" + qp.getLanguageKey() + \")\", null);\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void changed_event_if_same_qp_but_no_same_date() {\n    QualityProfile qp1 = qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:13+0100\"));\n    QualityProfile qp2 = qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:17+0100\"));\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp1), arrayOf(qp2));\n    Language language = mockLanguageInRepository(LANGUAGE_KEY_1);\n\n    underTest.execute(context);\n\n    List<Event> events = Lists.newArrayList(context.getRoot().getEventRepository().getEvents());\n    assertThat(events).hasSize(1);\n    verifyEvent(\n      events.get(0),\n      \"Changes in '\" + qp2.getQpName() + \"' (\" + language.getName() + \")\",\n      \"from=\" + UtcDateUtils.formatDateTime(parseDateTime(\"2011-04-25T01:05:14+0100\")) + \";key=\" + qp1.getQpKey() + \";to=\"\n        + UtcDateUtils.formatDateTime(parseDateTime(\"2011-04-25T01:05:18+0100\")));\n  }","id":9416,"modified_method":"@Test\n  public void changed_event_if_same_qp_but_no_same_date() {\n    QualityProfile qp1 = qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:13+0100\"));\n    QualityProfile qp2 = qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:17+0100\"));\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp1), arrayOf(qp2));\n    Language language = mockLanguageInRepository(LANGUAGE_KEY_1);\n\n    underTest.execute(context);\n\n    verify(eventRepository).add(eq(context.getRoot()), eventArgumentCaptor.capture());\n    verifyNoMoreInteractions(eventRepository);\n    verifyEvent(eventArgumentCaptor.getValue(),\n      \"Changes in '\" + qp2.getQpName() + \"' (\" + language.getName() + \")\",\n      \"from=\" + UtcDateUtils.formatDateTime(parseDateTime(\"2011-04-25T01:05:14+0100\")) + \";key=\" + qp1.getQpKey() + \";to=\"\n        + UtcDateUtils.formatDateTime(parseDateTime(\"2011-04-25T01:05:18+0100\")));\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void added_event_if_one_new_qp() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    Language language = mockLanguageInRepository(LANGUAGE_KEY_1);\n    mockMeasures(context.getRoot(), null, arrayOf(qp));\n\n    underTest.execute(context);\n\n    List<Event> events = Lists.newArrayList(context.getRoot().getEventRepository().getEvents());\n    assertThat(events).hasSize(1);\n    verifyEvent(events.get(0), \"Use '\" + qp.getQpName() + \"' (\" + language.getName() + \")\", null);\n  }","id":9417,"modified_method":"@Test\n  public void added_event_if_one_new_qp() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    Language language = mockLanguageInRepository(LANGUAGE_KEY_1);\n    mockMeasures(context.getRoot(), null, arrayOf(qp));\n\n    underTest.execute(context);\n\n    verify(eventRepository).add(eq(context.getRoot()), eventArgumentCaptor.capture());\n    verifyNoMoreInteractions(eventRepository);\n    verifyEvent(eventArgumentCaptor.getValue(), \"Use '\" + qp.getQpName() + \"' (\" + language.getName() + \")\", null);\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void no_more_used_event_if_qp_no_more_listed() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp), null);\n    Language language = mockLanguageInRepository(LANGUAGE_KEY_1);\n\n    underTest.execute(context);\n\n    List<Event> events = Lists.newArrayList(context.getRoot().getEventRepository().getEvents());\n    assertThat(events).hasSize(1);\n    verifyEvent(events.get(0), \"Stop using '\" + qp.getQpName() + \"' (\" + language.getName() + \")\", null);\n  }","id":9418,"modified_method":"@Test\n  public void no_more_used_event_if_qp_no_more_listed() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp), null);\n    Language language = mockLanguageInRepository(LANGUAGE_KEY_1);\n\n    underTest.execute(context);\n\n    verify(eventRepository).add(eq(context.getRoot()), eventArgumentCaptor.capture());\n    verifyNoMoreInteractions(eventRepository);\n    verifyEvent(eventArgumentCaptor.getValue(), \"Stop using '\" + qp.getQpName() + \"' (\" + language.getName() + \")\", null);\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_detection_with_complex_mix_of_qps() {\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(\n      context.getRoot(), arrayOf(\n        qp(QP_NAME_2, LANGUAGE_KEY_1),\n        qp(QP_NAME_2, LANGUAGE_KEY_2),\n        qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:13+0100\"))\n      ),\n      arrayOf(\n        qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:17+0100\")),\n        qp(QP_NAME_2, LANGUAGE_KEY_2),\n        qp(QP_NAME_2, LANGUAGE_KEY_3)\n      ));\n    mockNoLanguageInRepository();\n\n    underTest.execute(context);\n\n    assertThat(context.getRoot().getEventRepository().getEvents()).extracting(\"name\").containsOnly(\n      \"Stop using '\" + QP_NAME_2 + \"' (\" + LANGUAGE_KEY_1 + \")\",\n      \"Use '\" + QP_NAME_2 + \"' (\" + LANGUAGE_KEY_3 + \")\",\n      \"Changes in '\" + QP_NAME_1 + \"' (\" + LANGUAGE_KEY_1 + \")\"\n      );\n\n  }","id":9419,"modified_method":"@Test\n  public void verify_detection_with_complex_mix_of_qps() {\n    ComputationContext context = newNoChildRootContext();\n    final Set<Event> events = new HashSet<>();\n    doAnswer(new Answer() {\n      @Override\n      public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n        events.add((Event) invocationOnMock.getArguments()[1]);\n        return null;\n      }\n    }).when(eventRepository).add(eq(context.getRoot()), any(Event.class));\n\n    mockMeasures(\n      context.getRoot(), arrayOf(\n        qp(QP_NAME_2, LANGUAGE_KEY_1),\n        qp(QP_NAME_2, LANGUAGE_KEY_2),\n        qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:13+0100\"))\n      ),\n      arrayOf(\n        qp(QP_NAME_1, LANGUAGE_KEY_1, parseDateTime(\"2011-04-25T01:05:17+0100\")),\n        qp(QP_NAME_2, LANGUAGE_KEY_2),\n        qp(QP_NAME_2, LANGUAGE_KEY_3)\n      ));\n    mockNoLanguageInRepository();\n\n    underTest.execute(context);\n\n    assertThat(events).extracting(\"name\").containsOnly(\n      \"Stop using '\" + QP_NAME_2 + \"' (\" + LANGUAGE_KEY_1 + \")\",\n      \"Use '\" + QP_NAME_2 + \"' (\" + LANGUAGE_KEY_3 + \")\",\n      \"Changes in '\" + QP_NAME_1 + \"' (\" + LANGUAGE_KEY_1 + \")\"\n      );\n\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void no_event_if_no_qp_now_nor_before() {\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), null, null);\n\n    underTest.execute(context);\n\n    assertThat(context.getRoot().getEventRepository().getEvents()).isEmpty();\n  }","id":9420,"modified_method":"@Test\n  public void no_event_if_no_qp_now_nor_before() {\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), null, null);\n\n    underTest.execute(context);\n\n    verifyNoMoreInteractions(eventRepository);\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void no_effect_if_no_previous_measure() {\n    ComputationContext context = newNoChildRootContext();\n\n    when(measureRepository.findPrevious(context.getRoot(), CoreMetrics.QUALITY_PROFILES)).thenReturn(Optional.<MeasureDto>absent());\n\n    underTest.execute(context);\n\n    assertThat(context.getRoot().getEventRepository().getEvents()).isEmpty();\n  }","id":9421,"modified_method":"@Test\n  public void no_effect_if_no_previous_measure() {\n    ComputationContext context = newNoChildRootContext();\n\n    when(measureRepository.findPrevious(context.getRoot(), CoreMetrics.QUALITY_PROFILES)).thenReturn(Optional.<MeasureDto>absent());\n\n    underTest.execute(context);\n\n    verifyNoMoreInteractions(eventRepository);\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void no_event_if_same_qp_with_same_date() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp), arrayOf(qp));\n\n    underTest.execute(context);\n\n    assertThat(context.getRoot().getEventRepository().getEvents()).isEmpty();\n  }","id":9422,"modified_method":"@Test\n  public void no_event_if_same_qp_with_same_date() {\n    QualityProfile qp = qp(QP_NAME_1, LANGUAGE_KEY_1);\n    ComputationContext context = newNoChildRootContext();\n\n    mockMeasures(context.getRoot(), arrayOf(qp), arrayOf(qp));\n\n    underTest.execute(context);\n\n    verify(eventRepository, never()).add(any(Component.class), any(Event.class));\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private ComputationContext newNoChildRootContext() {\n    return newContext(new ComponentTreeBuilder() {\n      @Override\n      public Component build(ComputationContext context) {\n        return new EvenRepoComponent(context, Component.Type.PROJECT, 1);\n      }\n    });\n  }","id":9423,"modified_method":"private ComputationContext newNoChildRootContext() {\n    return newContext(new ComponentTreeBuilder() {\n      @Override\n      public Component build(ComputationContext context) {\n        return new DumbComponent(context, Component.Type.PROJECT, 1, \"uuid\", \"key\");\n      }\n    });\n  }","commit_id":"c295398811dff0db54e3a6c140ab41d275780f73","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        OpennmsServerConfigFactory.init();\n        OpennmsServerConfigFactory onmsSvrConfig = OpennmsServerConfigFactory.getInstance();\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.POLLER_CONFIG_FILE_NAME);\n\n        logStatic().debug(\"init: config file path: \" + cfgFile.getPath());\n\n        FileReader reader = new FileReader(cfgFile);\n        PollerConfigFactory config = new PollerConfigFactory(cfgFile.lastModified(), reader, onmsSvrConfig.getServerName(), onmsSvrConfig.verifyServer());\n        reader.close();\n\n        setInstance(config);\n    }","id":9424,"modified_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        OpennmsServerConfigFactory.init();\n        OpennmsServerConfigFactory onmsSvrConfig = OpennmsServerConfigFactory.getInstance();\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.POLLER_CONFIG_FILE_NAME);\n\n        logStatic().debug(\"init: config file path: \" + cfgFile.getPath());\n\n        FileReader reader = new FileReader(cfgFile);\n        PollerConfigFactory config = new PollerConfigFactory(cfgFile.lastModified(), reader, onmsSvrConfig.getServerName(), onmsSvrConfig.verifyServer());\n        reader.close();\n\n        for (org.opennms.netmgt.config.poller.Package pollerPackage : config.getConfiguration().getPackageCollection()) {\n            for (org.opennms.netmgt.config.poller.Service service : pollerPackage.getServiceCollection()) {\n                for (org.opennms.netmgt.config.poller.Parameter parm : service.getParameterCollection()) {\n                    if (parm.getKey().equals(\"ds-name\")) {\n                        if (parm.getValue().length() > ConfigFileConstants.RRD_DS_MAX_SIZE) {\n                            throw new ValidationException(\n                                String.format(\"ds-name '%s' in service '%s' (poller package '%s') is greater than %d characters\",\n                                parm.getValue(), service.getName(), pollerPackage.getName(), ConfigFileConstants.RRD_DS_MAX_SIZE)\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        setInstance(config);\n    }","commit_id":"0e6cd2c6e58b88ae4af27674efe7b65c3770e1dc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.THRESHOLDING_CONF_FILE_NAME);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"init: config file path: \" + cfgFile.getPath());\n        }\n\n        m_singleton = new ThresholdingConfigFactory(cfgFile.getPath());\n\n        m_loaded = true;\n    }","id":9425,"modified_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.THRESHOLDING_CONF_FILE_NAME);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"init: config file path: \" + cfgFile.getPath());\n        }\n\n        ThresholdingConfigFactory tcf = new ThresholdingConfigFactory(cfgFile.getPath());\n\n        for (String groupName : tcf.getGroupNames()) {\n            Group g = tcf.getGroup(groupName);\n            for (org.opennms.netmgt.config.threshd.Threshold threshold :  g.getThresholdCollection()) {\n                if (threshold.getDsName().length() > ConfigFileConstants.RRD_DS_MAX_SIZE) {\n                    throw new ValidationException(\n                        String.format(\"ds-name '%s' in group '%s' is greater than %d characters\",\n                            threshold.getDsName(), groupName, ConfigFileConstants.RRD_DS_MAX_SIZE)\n                    );\n                }\n            }\n        }\n        m_singleton = tcf;\n        m_loaded = true;\n    }","commit_id":"0e6cd2c6e58b88ae4af27674efe7b65c3770e1dc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Build map of org.opennms.netmgt.config.threshd.Group objects\n     * indexed by group name.\n     *\n     * This is parsed and built at initialization for\n     * faster processing at run-timne.\n     */ \n    private void initGroupMap() {\n        Map<String, Group> groupMap = new HashMap<String, Group>();\n        \n        Iterator iter = m_config.getGroupCollection().iterator();\n        while (iter.hasNext()) {\n            Group group = (Group) iter.next();\n            groupMap.put(group.getName(), group);\n        }\n        \n        m_groupMap = groupMap;\n    }","id":9426,"modified_method":"/**\n     * Build map of org.opennms.netmgt.config.threshd.Group objects\n     * indexed by group name.\n     *\n     * This is parsed and built at initialization for\n     * faster processing at run-timne.\n     */ \n    private void initGroupMap() {\n        Map<String, Group> groupMap = new HashMap<String, Group>();\n\n        for (Group g : m_config.getGroupCollection()) {\n            groupMap.put(g.getName(), g);\n        }\n        \n        m_groupMap = groupMap;\n    }","commit_id":"0e6cd2c6e58b88ae4af27674efe7b65c3770e1dc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        OpennmsServerConfigFactory.init();\n        OpennmsServerConfigFactory onmsSvrConfig = OpennmsServerConfigFactory.getInstance();\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.POLLER_CONFIG_FILE_NAME);\n\n        logStatic().debug(\"init: config file path: \" + cfgFile.getPath());\n\n        FileReader reader = new FileReader(cfgFile);\n        PollerConfigFactory config = new PollerConfigFactory(cfgFile.lastModified(), reader, onmsSvrConfig.getServerName(), onmsSvrConfig.verifyServer());\n        reader.close();\n\n        setInstance(config);\n    }","id":9427,"modified_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        OpennmsServerConfigFactory.init();\n        OpennmsServerConfigFactory onmsSvrConfig = OpennmsServerConfigFactory.getInstance();\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.POLLER_CONFIG_FILE_NAME);\n\n        logStatic().debug(\"init: config file path: \" + cfgFile.getPath());\n\n        FileReader reader = new FileReader(cfgFile);\n        PollerConfigFactory config = new PollerConfigFactory(cfgFile.lastModified(), reader, onmsSvrConfig.getServerName(), onmsSvrConfig.verifyServer());\n        reader.close();\n\n        for (org.opennms.netmgt.config.poller.Package pollerPackage : config.getConfiguration().getPackageCollection()) {\n            for (org.opennms.netmgt.config.poller.Service service : pollerPackage.getServiceCollection()) {\n                for (org.opennms.netmgt.config.poller.Parameter parm : service.getParameterCollection()) {\n                    if (parm.getKey().equals(\"ds-name\")) {\n                        if (parm.getValue().length() > ConfigFileConstants.RRD_DS_MAX_SIZE) {\n                            throw new ValidationException(\n                                String.format(\"ds-name '%s' in service '%s' (poller package '%s') is greater than %d characters\",\n                                parm.getValue(), service.getName(), pollerPackage.getName(), ConfigFileConstants.RRD_DS_MAX_SIZE)\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        setInstance(config);\n    }","commit_id":"5a8177ab37a37f9db008a8f858ed78a4ae909561","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Build map of org.opennms.netmgt.config.threshd.Group objects\n     * indexed by group name.\n     *\n     * This is parsed and built at initialization for\n     * faster processing at run-timne.\n     */ \n    private void initGroupMap() {\n        Map<String, Group> groupMap = new HashMap<String, Group>();\n        \n        Iterator iter = m_config.getGroupCollection().iterator();\n        while (iter.hasNext()) {\n            Group group = (Group) iter.next();\n            groupMap.put(group.getName(), group);\n        }\n        \n        m_groupMap = groupMap;\n    }","id":9428,"modified_method":"/**\n     * Build map of org.opennms.netmgt.config.threshd.Group objects\n     * indexed by group name.\n     *\n     * This is parsed and built at initialization for\n     * faster processing at run-timne.\n     */ \n    private void initGroupMap() {\n        Map<String, Group> groupMap = new HashMap<String, Group>();\n\n        for (Group g : m_config.getGroupCollection()) {\n            groupMap.put(g.getName(), g);\n        }\n        \n        m_groupMap = groupMap;\n    }","commit_id":"5a8177ab37a37f9db008a8f858ed78a4ae909561","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.THRESHOLDING_CONF_FILE_NAME);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"init: config file path: \" + cfgFile.getPath());\n        }\n\n        m_singleton = new ThresholdingConfigFactory(cfgFile.getPath());\n\n        m_loaded = true;\n    }","id":9429,"modified_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.THRESHOLDING_CONF_FILE_NAME);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"init: config file path: \" + cfgFile.getPath());\n        }\n\n        ThresholdingConfigFactory tcf = new ThresholdingConfigFactory(cfgFile.getPath());\n\n        for (String groupName : tcf.getGroupNames()) {\n            Group g = tcf.getGroup(groupName);\n            for (org.opennms.netmgt.config.threshd.Threshold threshold :  g.getThresholdCollection()) {\n                if (threshold.getDsName().length() > ConfigFileConstants.RRD_DS_MAX_SIZE) {\n                    throw new ValidationException(\n                        String.format(\"ds-name '%s' in group '%s' is greater than %d characters\",\n                            threshold.getDsName(), groupName, ConfigFileConstants.RRD_DS_MAX_SIZE)\n                    );\n                }\n            }\n        }\n        m_singleton = tcf;\n        m_loaded = true;\n    }","commit_id":"5a8177ab37a37f9db008a8f858ed78a4ae909561","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        OpennmsServerConfigFactory.init();\n        OpennmsServerConfigFactory onmsSvrConfig = OpennmsServerConfigFactory.getInstance();\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.POLLER_CONFIG_FILE_NAME);\n\n        logStatic().debug(\"init: config file path: \" + cfgFile.getPath());\n\n        FileReader reader = new FileReader(cfgFile);\n        PollerConfigFactory config = new PollerConfigFactory(cfgFile.lastModified(), reader, onmsSvrConfig.getServerName(), onmsSvrConfig.verifyServer());\n        reader.close();\n\n        setInstance(config);\n    }","id":9430,"modified_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        OpennmsServerConfigFactory.init();\n        OpennmsServerConfigFactory onmsSvrConfig = OpennmsServerConfigFactory.getInstance();\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.POLLER_CONFIG_FILE_NAME);\n\n        logStatic().debug(\"init: config file path: \" + cfgFile.getPath());\n\n        FileReader reader = new FileReader(cfgFile);\n        PollerConfigFactory config = new PollerConfigFactory(cfgFile.lastModified(), reader, onmsSvrConfig.getServerName(), onmsSvrConfig.verifyServer());\n        reader.close();\n\n        for (org.opennms.netmgt.config.poller.Package pollerPackage : config.getConfiguration().getPackageCollection()) {\n            for (org.opennms.netmgt.config.poller.Service service : pollerPackage.getServiceCollection()) {\n                for (org.opennms.netmgt.config.poller.Parameter parm : service.getParameterCollection()) {\n                    if (parm.getKey().equals(\"ds-name\")) {\n                        if (parm.getValue().length() > ConfigFileConstants.RRD_DS_MAX_SIZE) {\n                            throw new ValidationException(\n                                String.format(\"ds-name '%s' in service '%s' (poller package '%s') is greater than %d characters\",\n                                parm.getValue(), service.getName(), pollerPackage.getName(), ConfigFileConstants.RRD_DS_MAX_SIZE)\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        setInstance(config);\n    }","commit_id":"a6f999ae8962a654e114c821c3f1bdceab59d99f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.THRESHOLDING_CONF_FILE_NAME);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"init: config file path: \" + cfgFile.getPath());\n        }\n\n        m_singleton = new ThresholdingConfigFactory(cfgFile.getPath());\n\n        m_loaded = true;\n    }","id":9431,"modified_method":"/**\n     * Load the config from the default config file and create the singleton\n     * instance of this factory.\n     * \n     * @exception java.io.IOException\n     *                Thrown if the specified config file cannot be read\n     * @exception org.exolab.castor.xml.MarshalException\n     *                Thrown if the file does not conform to the schema.\n     * @exception org.exolab.castor.xml.ValidationException\n     *                Thrown if the contents do not match the required schema.\n     */\n    public static synchronized void init() throws IOException, MarshalException, ValidationException {\n        if (m_loaded) {\n            // init already called - return\n            // to reload, reload() will need to be called\n            return;\n        }\n\n        File cfgFile = ConfigFileConstants.getFile(ConfigFileConstants.THRESHOLDING_CONF_FILE_NAME);\n\n        if (log().isDebugEnabled()) {\n            log().debug(\"init: config file path: \" + cfgFile.getPath());\n        }\n\n        ThresholdingConfigFactory tcf = new ThresholdingConfigFactory(cfgFile.getPath());\n\n        for (String groupName : tcf.getGroupNames()) {\n            Group g = tcf.getGroup(groupName);\n            for (org.opennms.netmgt.config.threshd.Threshold threshold :  g.getThresholdCollection()) {\n                if (threshold.getDsName().length() > ConfigFileConstants.RRD_DS_MAX_SIZE) {\n                    throw new ValidationException(\n                        String.format(\"ds-name '%s' in group '%s' is greater than %d characters\",\n                            threshold.getDsName(), groupName, ConfigFileConstants.RRD_DS_MAX_SIZE)\n                    );\n                }\n            }\n        }\n        m_singleton = tcf;\n        m_loaded = true;\n    }","commit_id":"a6f999ae8962a654e114c821c3f1bdceab59d99f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Build map of org.opennms.netmgt.config.threshd.Group objects\n     * indexed by group name.\n     *\n     * This is parsed and built at initialization for\n     * faster processing at run-timne.\n     */ \n    private void initGroupMap() {\n        Map<String, Group> groupMap = new HashMap<String, Group>();\n        \n        Iterator iter = m_config.getGroupCollection().iterator();\n        while (iter.hasNext()) {\n            Group group = (Group) iter.next();\n            groupMap.put(group.getName(), group);\n        }\n        \n        m_groupMap = groupMap;\n    }","id":9432,"modified_method":"/**\n     * Build map of org.opennms.netmgt.config.threshd.Group objects\n     * indexed by group name.\n     *\n     * This is parsed and built at initialization for\n     * faster processing at run-timne.\n     */ \n    private void initGroupMap() {\n        Map<String, Group> groupMap = new HashMap<String, Group>();\n\n        for (Group g : m_config.getGroupCollection()) {\n            groupMap.put(g.getName(), g);\n        }\n        \n        m_groupMap = groupMap;\n    }","commit_id":"a6f999ae8962a654e114c821c3f1bdceab59d99f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportStarted() {\n\t\tEvent e = createEvent(EventConstants.IMPORT_STARTED_UEI);\n\t\tm_eventManager.sendNow(e);\n\t}","id":9433,"modified_method":"private void sendImportStarted(Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_STARTED_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"eef69d760182b9c4c7ce7acc90c671964f50de5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportSuccessful(ImporterStats stats) {\n    \tEvent e = createEvent(EventConstants.IMPORT_SUCCESSFUL_UEI, EventConstants.PARM_IMPORT_STATS, stats.toString());\n\t\tm_eventManager.sendNow(e);\n\t}","id":9434,"modified_method":"private void sendImportSuccessful(ImporterStats stats, Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_SUCCESSFUL_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n        builder.addParam(EventConstants.PARM_IMPORT_STATS, stats.toString());\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"eef69d760182b9c4c7ce7acc90c671964f50de5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportFailed(String msg) {\n\t\tEvent e = createEvent(EventConstants.IMPORT_FAILED_UEI, EventConstants.PARM_FAILURE_MESSAGE, msg);\n\t\tm_eventManager.sendNow(e);\n\t}","id":9435,"modified_method":"private void sendImportFailed(String msg, Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_FAILED_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n        builder.addParam(EventConstants.PARM_FAILURE_MESSAGE, msg);\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"eef69d760182b9c4c7ce7acc90c671964f50de5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Begins importing from resource specified in model-importer.properties file or\n     * in event parameter: url.  Import Resources are managed with a \"key\" called \n     * \"foreignSource\" specified in the XML retreived by the resource and can be overridden \n     * as a parameter of an event.\n     * @param event\n     */\n    private void doImport(Event event) {\n        Resource resource = null;\n        try {\n        \tsendImportStarted();\n            m_stats = new ImporterStats();\n            resource = ((event != null && getEventUrl(event) != null) ? new UrlResource(getEventUrl(event)) : m_importResource); \n\t\t\timportModelFromResource(resource, m_stats, event);\n            log().info(\"Finished Importing: \"+m_stats);\n            sendImportSuccessful(m_stats);\n        } catch (IOException e) {\n            String msg = \"IOException importing \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage());\n        } catch (ModelImportException e) {\n            String msg = \"Error parsing import data from \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage());\n        }\n    }","id":9436,"modified_method":"/**\n     * Begins importing from resource specified in model-importer.properties file or\n     * in event parameter: url.  Import Resources are managed with a \"key\" called \n     * \"foreignSource\" specified in the XML retreived by the resource and can be overridden \n     * as a parameter of an event.\n     * @param event\n     */\n    private void doImport(Event event) {\n        Resource resource = null;\n        try {\n            m_stats = new ImporterStats();\n            resource = ((event != null && getEventUrl(event) != null) ? new UrlResource(getEventUrl(event)) : m_importResource); \n            sendImportStarted(resource);\n\t\t\timportModelFromResource(resource, m_stats, event);\n            log().info(\"Finished Importing: \"+m_stats);\n            sendImportSuccessful(m_stats, resource);\n        } catch (IOException e) {\n            String msg = \"IOException importing \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage(), resource);\n        } catch (ModelImportException e) {\n            String msg = \"Error parsing import data from \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage(), resource);\n        }\n    }","commit_id":"eef69d760182b9c4c7ce7acc90c671964f50de5a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportStarted() {\n\t\tEvent e = createEvent(EventConstants.IMPORT_STARTED_UEI);\n\t\tm_eventManager.sendNow(e);\n\t}","id":9437,"modified_method":"private void sendImportStarted(Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_STARTED_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"1b7f38a8cc885bf46e9cd6be00fddd288c96de84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Begins importing from resource specified in model-importer.properties file or\n     * in event parameter: url.  Import Resources are managed with a \"key\" called \n     * \"foreignSource\" specified in the XML retreived by the resource and can be overridden \n     * as a parameter of an event.\n     * @param event\n     */\n    private void doImport(Event event) {\n        Resource resource = null;\n        try {\n        \tsendImportStarted();\n            m_stats = new ImporterStats();\n            resource = ((event != null && getEventUrl(event) != null) ? new UrlResource(getEventUrl(event)) : m_importResource); \n\t\t\timportModelFromResource(resource, m_stats, event);\n            log().info(\"Finished Importing: \"+m_stats);\n            sendImportSuccessful(m_stats);\n        } catch (IOException e) {\n            String msg = \"IOException importing \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage());\n        } catch (ModelImportException e) {\n            String msg = \"Error parsing import data from \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage());\n        }\n    }","id":9438,"modified_method":"/**\n     * Begins importing from resource specified in model-importer.properties file or\n     * in event parameter: url.  Import Resources are managed with a \"key\" called \n     * \"foreignSource\" specified in the XML retreived by the resource and can be overridden \n     * as a parameter of an event.\n     * @param event\n     */\n    private void doImport(Event event) {\n        Resource resource = null;\n        try {\n            m_stats = new ImporterStats();\n            resource = ((event != null && getEventUrl(event) != null) ? new UrlResource(getEventUrl(event)) : m_importResource); \n            sendImportStarted(resource);\n\t\t\timportModelFromResource(resource, m_stats, event);\n            log().info(\"Finished Importing: \"+m_stats);\n            sendImportSuccessful(m_stats, resource);\n        } catch (IOException e) {\n            String msg = \"IOException importing \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage(), resource);\n        } catch (ModelImportException e) {\n            String msg = \"Error parsing import data from \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage(), resource);\n        }\n    }","commit_id":"1b7f38a8cc885bf46e9cd6be00fddd288c96de84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportSuccessful(ImporterStats stats) {\n    \tEvent e = createEvent(EventConstants.IMPORT_SUCCESSFUL_UEI, EventConstants.PARM_IMPORT_STATS, stats.toString());\n\t\tm_eventManager.sendNow(e);\n\t}","id":9439,"modified_method":"private void sendImportSuccessful(ImporterStats stats, Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_SUCCESSFUL_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n        builder.addParam(EventConstants.PARM_IMPORT_STATS, stats.toString());\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"1b7f38a8cc885bf46e9cd6be00fddd288c96de84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportFailed(String msg) {\n\t\tEvent e = createEvent(EventConstants.IMPORT_FAILED_UEI, EventConstants.PARM_FAILURE_MESSAGE, msg);\n\t\tm_eventManager.sendNow(e);\n\t}","id":9440,"modified_method":"private void sendImportFailed(String msg, Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_FAILED_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n        builder.addParam(EventConstants.PARM_FAILURE_MESSAGE, msg);\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"1b7f38a8cc885bf46e9cd6be00fddd288c96de84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportSuccessful(ImporterStats stats) {\n    \tEvent e = createEvent(EventConstants.IMPORT_SUCCESSFUL_UEI, EventConstants.PARM_IMPORT_STATS, stats.toString());\n\t\tm_eventManager.sendNow(e);\n\t}","id":9441,"modified_method":"private void sendImportSuccessful(ImporterStats stats, Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_SUCCESSFUL_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n        builder.addParam(EventConstants.PARM_IMPORT_STATS, stats.toString());\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"0d0c1eb0012bdc05fd959e05c91c611fcb451137","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportStarted() {\n\t\tEvent e = createEvent(EventConstants.IMPORT_STARTED_UEI);\n\t\tm_eventManager.sendNow(e);\n\t}","id":9442,"modified_method":"private void sendImportStarted(Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_STARTED_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"0d0c1eb0012bdc05fd959e05c91c611fcb451137","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void sendImportFailed(String msg) {\n\t\tEvent e = createEvent(EventConstants.IMPORT_FAILED_UEI, EventConstants.PARM_FAILURE_MESSAGE, msg);\n\t\tm_eventManager.sendNow(e);\n\t}","id":9443,"modified_method":"private void sendImportFailed(String msg, Resource resource) {\n        EventBuilder builder = new EventBuilder(EventConstants.IMPORT_FAILED_UEI, NAME);\n        builder.addParam(EventConstants.PARM_IMPORT_RESOURCE, resource.toString());\n        builder.addParam(EventConstants.PARM_FAILURE_MESSAGE, msg);\n\t\tm_eventManager.sendNow(builder.getEvent());\n\t}","commit_id":"0d0c1eb0012bdc05fd959e05c91c611fcb451137","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Begins importing from resource specified in model-importer.properties file or\n     * in event parameter: url.  Import Resources are managed with a \"key\" called \n     * \"foreignSource\" specified in the XML retreived by the resource and can be overridden \n     * as a parameter of an event.\n     * @param event\n     */\n    private void doImport(Event event) {\n        Resource resource = null;\n        try {\n        \tsendImportStarted();\n            m_stats = new ImporterStats();\n            resource = ((event != null && getEventUrl(event) != null) ? new UrlResource(getEventUrl(event)) : m_importResource); \n\t\t\timportModelFromResource(resource, m_stats, event);\n            log().info(\"Finished Importing: \"+m_stats);\n            sendImportSuccessful(m_stats);\n        } catch (IOException e) {\n            String msg = \"IOException importing \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage());\n        } catch (ModelImportException e) {\n            String msg = \"Error parsing import data from \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage());\n        }\n    }","id":9444,"modified_method":"/**\n     * Begins importing from resource specified in model-importer.properties file or\n     * in event parameter: url.  Import Resources are managed with a \"key\" called \n     * \"foreignSource\" specified in the XML retreived by the resource and can be overridden \n     * as a parameter of an event.\n     * @param event\n     */\n    private void doImport(Event event) {\n        Resource resource = null;\n        try {\n            m_stats = new ImporterStats();\n            resource = ((event != null && getEventUrl(event) != null) ? new UrlResource(getEventUrl(event)) : m_importResource); \n            sendImportStarted(resource);\n\t\t\timportModelFromResource(resource, m_stats, event);\n            log().info(\"Finished Importing: \"+m_stats);\n            sendImportSuccessful(m_stats, resource);\n        } catch (IOException e) {\n            String msg = \"IOException importing \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage(), resource);\n        } catch (ModelImportException e) {\n            String msg = \"Error parsing import data from \"+resource;\n\t\t\tlog().error(msg, e);\n            sendImportFailed(msg+\": \"+e.getMessage(), resource);\n        }\n    }","commit_id":"0d0c1eb0012bdc05fd959e05c91c611fcb451137","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t *\n\t * @return a {@link java.lang.String} object.\n\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t */\n\tpublic String getIpNetToMediaPhysAddress(){\n\t    try {\n\t        // Try to fetch the physical address value as a hex string.\n                String hexString = getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n                if (hexString != null && hexString.length() == 12) {\n                    // If the hex string is 12 characters long, than the agent is kinda weird and\n                    // is returning the value as a raw binary value that is 6 bytes in length.\n                    // But that's OK, as long as we can convert it into a string, that's fine. \n                    return hexString;\n                } else {\n                    // This is the normal case that most agents conform to: the value is an ASCII \n                    // string representing the colon-separated MAC address. We just need to reformat \n                    // it to remove the colons and convert it into a 12-character string.\n                    return normalizeMacAddress(getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR));\n                }\n\t    } catch (IllegalArgumentException e) {\n\t        LOG.warn(\"IllegalArgumentException\", e);\n\t    }\n            return getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n\t}","id":9445,"modified_method":"/**\n\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t *\n\t * @return a {@link java.lang.String} object.\n\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t */\n\tpublic String getIpNetToMediaPhysAddress(){\n\t    try {\n\t        // Try to fetch the physical address value as a hex string.\n                String hexString = getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n                if (hexString != null && hexString.length() == 12) {\n                    // If the hex string is 12 characters long, than the agent is kinda weird and\n                    // is returning the value as a raw binary value that is 6 bytes in length.\n                    // But that's OK, as long as we can convert it into a string, that's fine. \n                    return hexString;\n                } else {\n                    // This is the normal case that most agents conform to: the value is an ASCII \n                    // string representing the colon-separated MAC address. We just need to reformat \n                    // it to remove the colons and convert it into a 12-character string.\n                    String mac = getValue(IpNetToMediaTableEntry.INTM_PHYSADDR).toDisplayString();\n                    return mac == null || mac.trim().isEmpty() ? null : normalizeMacAddress(mac);\n                }\n\t    } catch (IllegalArgumentException e) {\n\t        LOG.warn(\"IllegalArgumentException\", e);\n\t    }\n            return getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n\t}","commit_id":"a68b3c29c0a9592fef7bbcf0a86ec50bdbfd40ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t\t */\n\t\tpublic String getIpNetToMediaPhysAddress(){\n\t\t    SnmpValue mac = getValue(IPNETTOMEDIA_TABLE_PHYSADDR);\n\t\t        // Try to fetch the physical address value as a hex string.\n\t            String hexString = mac.toHexString();\n\t            if (hexString != null && isValidBridgeAddress(hexString))\n\t                // If the hex string is 12 characters long, than the agent is kinda weird and\n\t                // is returning the value as a raw binary value that is 6 bytes in length.\n\t                // But that's OK, as long as we can convert it into a string, that's fine. \n\t                return hexString;\n\t            try{ \n\t                if (mac.isDisplayable())\n\t                // This is the normal case that most agents conform to: the value is an ASCII \n\t                // string representing the colon-separated MAC address. We just need to reformat \n\t                // it to remove the colons and convert it into a 12-character string.\n\t                    return normalizeMacAddress(mac.toDisplayString());\n\t\t    } catch (IllegalArgumentException e) {\n\t\t        LOG.warn(\"IllegalArgument mac on ipnettomediatable:  return null\", e);\n\t\t        return null;\n\t\t    }\n\t            hexString=mac.toDisplayString();\n\t            if (isValidBridgeAddress(hexString))\n\t                return hexString;\n                    LOG.warn(\"IllegalArgument mac {} on ipnettomediatable {} return null\", hexString);\n\t            return null;\n\t\t}","id":9446,"modified_method":"/**\n\t\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t\t */\n\t\tpublic String getIpNetToMediaPhysAddress(){\n\t\t    SnmpValue mac = getValue(IPNETTOMEDIA_TABLE_PHYSADDR);\n\t\t        // Try to fetch the physical address value as a hex string.\n\t            String hexString = mac.toHexString();\n\t            if (hexString != null && isValidBridgeAddress(hexString))\n\t                // If the hex string is 12 characters long, than the agent is kinda weird and\n\t                // is returning the value as a raw binary value that is 6 bytes in length.\n\t                // But that's OK, as long as we can convert it into a string, that's fine. \n\t                return hexString;\n\t            try{ \n\t                if (mac.isDisplayable()) {\n\t                // This is the normal case that most agents conform to: the value is an ASCII \n\t                // string representing the colon-separated MAC address. We just need to reformat \n\t                // it to remove the colons and convert it into a 12-character string.\n\t                    String displayString = mac.toDisplayString();\n\t                    return displayString == null || displayString.trim().isEmpty() ? null : normalizeMacAddress(displayString);\n\t                }\n\t\t    } catch (IllegalArgumentException e) {\n\t\t        LOG.warn(\"IllegalArgument mac on ipnettomediatable:  return null\", e);\n\t\t        return null;\n\t\t    }\n\t            hexString=mac.toDisplayString();\n\t            if (isValidBridgeAddress(hexString))\n\t                return hexString;\n                    LOG.warn(\"IllegalArgument mac {} on ipnettomediatable {} return null\", hexString);\n\t            return null;\n\t\t}","commit_id":"a68b3c29c0a9592fef7bbcf0a86ec50bdbfd40ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t *\n\t * @return a {@link java.lang.String} object.\n\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t */\n\tpublic String getIpNetToMediaPhysAddress(){\n\t    try {\n\t        // Try to fetch the physical address value as a hex string.\n                String hexString = getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n                if (hexString != null && hexString.length() == 12) {\n                    // If the hex string is 12 characters long, than the agent is kinda weird and\n                    // is returning the value as a raw binary value that is 6 bytes in length.\n                    // But that's OK, as long as we can convert it into a string, that's fine. \n                    return hexString;\n                } else {\n                    // This is the normal case that most agents conform to: the value is an ASCII \n                    // string representing the colon-separated MAC address. We just need to reformat \n                    // it to remove the colons and convert it into a 12-character string.\n                    return normalizeMacAddress(getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR));\n                }\n\t    } catch (IllegalArgumentException e) {\n\t        LOG.warn(\"IllegalArgumentException\", e);\n\t    }\n            return getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n\t}","id":9447,"modified_method":"/**\n\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t *\n\t * @return a {@link java.lang.String} object.\n\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t */\n\tpublic String getIpNetToMediaPhysAddress(){\n\t    try {\n\t        // Try to fetch the physical address value as a hex string.\n                String hexString = getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n                if (hexString != null && hexString.length() == 12) {\n                    // If the hex string is 12 characters long, than the agent is kinda weird and\n                    // is returning the value as a raw binary value that is 6 bytes in length.\n                    // But that's OK, as long as we can convert it into a string, that's fine. \n                    return hexString;\n                } else {\n                    // This is the normal case that most agents conform to: the value is an ASCII \n                    // string representing the colon-separated MAC address. We just need to reformat \n                    // it to remove the colons and convert it into a 12-character string.\n                    String mac = getValue(IpNetToMediaTableEntry.INTM_PHYSADDR).toDisplayString();\n                    return mac == null || mac.trim().isEmpty() ? null : normalizeMacAddress(mac);\n                }\n\t    } catch (IllegalArgumentException e) {\n\t        LOG.warn(\"IllegalArgumentException\", e);\n\t    }\n            return getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n\t}","commit_id":"f797241aac868805a6dc74edc9563e6e47cfccd8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t\t */\n\t\tpublic String getIpNetToMediaPhysAddress(){\n\t\t    try {\n\t\t        // Try to fetch the physical address value as a hex string.\n\t            String hexString = getValue(IPNETTOMEDIA_TABLE_PHYSADDR).toHexString();\n\t            if (hexString != null && hexString.length() == 12) {\n\t                // If the hex string is 12 characters long, than the agent is kinda weird and\n\t                // is returning the value as a raw binary value that is 6 bytes in length.\n\t                // But that's OK, as long as we can convert it into a string, that's fine. \n\t                return hexString;\n\t            } else {\n\t                // This is the normal case that most agents conform to: the value is an ASCII \n\t                // string representing the colon-separated MAC address. We just need to reformat \n\t                // it to remove the colons and convert it into a 12-character string.\n\t                return normalizeMacAddress(getValue(IPNETTOMEDIA_TABLE_PHYSADDR).toDisplayString());\n\t            }\n\t\t    } catch (IllegalArgumentException e) {\n\t\t        LOG.warn(\"IllegalArgument on ipnettomediatable\", e);\n\t\t        return getValue(IPNETTOMEDIA_TABLE_PHYSADDR).toDisplayString();\n\t\t    }\n\t\t}","id":9448,"modified_method":"/**\n\t\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t\t */\n\t\tpublic String getIpNetToMediaPhysAddress(){\n\t\t    try {\n\t\t        // Try to fetch the physical address value as a hex string.\n\t            String hexString = getValue(IPNETTOMEDIA_TABLE_PHYSADDR).toHexString();\n\t            if (hexString != null && hexString.length() == 12) {\n\t                // If the hex string is 12 characters long, than the agent is kinda weird and\n\t                // is returning the value as a raw binary value that is 6 bytes in length.\n\t                // But that's OK, as long as we can convert it into a string, that's fine. \n\t                return hexString;\n\t            } else {\n\t                // This is the normal case that most agents conform to: the value is an ASCII \n\t                // string representing the colon-separated MAC address. We just need to reformat \n\t                // it to remove the colons and convert it into a 12-character string.\n\t                String mac = getValue(IPNETTOMEDIA_TABLE_PHYSADDR).toDisplayString();\n\t                return mac == null || mac.trim().isEmpty() ? null : normalizeMacAddress(mac);\n\t            }\n\t\t    } catch (IllegalArgumentException e) {\n\t\t        LOG.warn(\"IllegalArgument on ipnettomediatable\", e);\n\t\t        return getValue(IPNETTOMEDIA_TABLE_PHYSADDR).toDisplayString();\n\t\t    }\n\t\t}","commit_id":"f797241aac868805a6dc74edc9563e6e47cfccd8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t *\n\t * @return a {@link java.lang.String} object.\n\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t */\n\tpublic String getIpNetToMediaPhysAddress(){\n\t    try {\n\t        // Try to fetch the physical address value as a hex string.\n                String hexString = getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n                if (hexString != null && hexString.length() == 12) {\n                    // If the hex string is 12 characters long, than the agent is kinda weird and\n                    // is returning the value as a raw binary value that is 6 bytes in length.\n                    // But that's OK, as long as we can convert it into a string, that's fine. \n                    return hexString;\n                } else {\n                    // This is the normal case that most agents conform to: the value is an ASCII \n                    // string representing the colon-separated MAC address. We just need to reformat \n                    // it to remove the colons and convert it into a 12-character string.\n                    return normalizeMacAddress(getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR));\n                }\n\t    } catch (IllegalArgumentException e) {\n\t        LOG.warn(\"IllegalArgumentException\", e);\n\t    }\n            return getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n\t}","id":9449,"modified_method":"/**\n\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t *\n\t * @return a {@link java.lang.String} object.\n\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t */\n\tpublic String getIpNetToMediaPhysAddress(){\n\t    try {\n\t        // Try to fetch the physical address value as a hex string.\n                String hexString = getHexString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n                if (hexString != null && hexString.length() == 12) {\n                    // If the hex string is 12 characters long, than the agent is kinda weird and\n                    // is returning the value as a raw binary value that is 6 bytes in length.\n                    // But that's OK, as long as we can convert it into a string, that's fine. \n                    return hexString;\n                } else {\n                    // This is the normal case that most agents conform to: the value is an ASCII \n                    // string representing the colon-separated MAC address. We just need to reformat \n                    // it to remove the colons and convert it into a 12-character string.\n                    String mac = getValue(IpNetToMediaTableEntry.INTM_PHYSADDR).toDisplayString();\n                    return mac == null || mac.trim().isEmpty() ? null : normalizeMacAddress(mac);\n                }\n\t    } catch (IllegalArgumentException e) {\n\t        LOG.warn(\"IllegalArgumentException\", e);\n\t    }\n            return getDisplayString(IpNetToMediaTableEntry.INTM_PHYSADDR);\n\t}","commit_id":"3f5f153ca477c2fd5b1aef7c46238a28657c8b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t\t */\n\t\tpublic String getIpNetToMediaPhysAddress(){\n\t\t    SnmpValue mac = getValue(IPNETTOMEDIA_TABLE_PHYSADDR);\n\t\t        // Try to fetch the physical address value as a hex string.\n\t            String hexString = mac.toHexString();\n\t            if (hexString != null && isValidBridgeAddress(hexString))\n\t                // If the hex string is 12 characters long, than the agent is kinda weird and\n\t                // is returning the value as a raw binary value that is 6 bytes in length.\n\t                // But that's OK, as long as we can convert it into a string, that's fine. \n\t                return hexString;\n\t            try{ \n\t                if (mac.isDisplayable())\n\t                // This is the normal case that most agents conform to: the value is an ASCII \n\t                // string representing the colon-separated MAC address. We just need to reformat \n\t                // it to remove the colons and convert it into a 12-character string.\n\t                    return normalizeMacAddress(mac.toDisplayString());\n\t\t    } catch (IllegalArgumentException e) {\n\t\t        LOG.warn(\"IllegalArgument mac on ipnettomediatable:  return null\", e);\n\t\t        return null;\n\t\t    }\n\t            hexString=mac.toDisplayString();\n\t            if (isValidBridgeAddress(hexString))\n\t                return hexString;\n                    LOG.warn(\"IllegalArgument mac {} on ipnettomediatable {} return null\", hexString);\n\t            return null;\n\t\t}","id":9450,"modified_method":"/**\n\t\t * <p>getIpNetToMediaPhysAddress<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t * @see {@link org.opennms.netmgt.provision.service.snmp.IfTableEntry#getPhysAddr()}\n\t\t */\n\t\tpublic String getIpNetToMediaPhysAddress(){\n\t\t    SnmpValue mac = getValue(IPNETTOMEDIA_TABLE_PHYSADDR);\n\t\t        // Try to fetch the physical address value as a hex string.\n\t            String hexString = mac.toHexString();\n\t            if (hexString != null && isValidBridgeAddress(hexString))\n\t                // If the hex string is 12 characters long, than the agent is kinda weird and\n\t                // is returning the value as a raw binary value that is 6 bytes in length.\n\t                // But that's OK, as long as we can convert it into a string, that's fine. \n\t                return hexString;\n\t            try{ \n\t                if (mac.isDisplayable()) {\n\t                // This is the normal case that most agents conform to: the value is an ASCII \n\t                // string representing the colon-separated MAC address. We just need to reformat \n\t                // it to remove the colons and convert it into a 12-character string.\n\t                    String displayString = mac.toDisplayString();\n\t                    return displayString == null || displayString.trim().isEmpty() ? null : normalizeMacAddress(displayString);\n\t                }\n\t\t    } catch (IllegalArgumentException e) {\n\t\t        LOG.warn(\"IllegalArgument mac on ipnettomediatable:  return null\", e);\n\t\t        return null;\n\t\t    }\n\t            hexString=mac.toDisplayString();\n\t            if (isValidBridgeAddress(hexString))\n\t                return hexString;\n                    LOG.warn(\"IllegalArgument mac {} on ipnettomediatable {} return null\", hexString);\n\t            return null;\n\t\t}","commit_id":"3f5f153ca477c2fd5b1aef7c46238a28657c8b84","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testDontFlapWhenOnlyTwoOutages() throws Exception {\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(100);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        Thread.sleep(100);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(100);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        m_anticipatedMemorySize = 6;\n        \n        Thread.sleep(100);\n        \n        verify();\n\n    }","id":9451,"modified_method":"public void testDontFlapWhenOnlyTwoOutages() throws Exception {\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        m_anticipatedMemorySize = 6;\n        \n        Thread.sleep(100);\n        \n        verify();\n        \n        Thread.sleep(1000);\n        \n        m_anticipatedMemorySize = 0;\n        \n        verify();\n\n    }","commit_id":"6574f214219e46e4943ef18ecd1ba708d054f8a5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testDontFlapWhenOnlyTwoOutages() throws Exception {\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(100);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        Thread.sleep(100);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(100);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        m_anticipatedMemorySize = 6;\n        \n        Thread.sleep(100);\n        \n        verify();\n\n    }","id":9452,"modified_method":"public void testDontFlapWhenOnlyTwoOutages() throws Exception {\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeLostServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n\n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"AVAIL\", 7));\n        \n        Thread.sleep(50);\n        \n        m_engine.correlate(createRemoteNodeRegainedServiceEvent(1, \"192.168.1.1\", \"HTTP\", 7));\n        \n        m_anticipatedMemorySize = 6;\n        \n        Thread.sleep(100);\n        \n        verify();\n        \n        Thread.sleep(1000);\n        \n        m_anticipatedMemorySize = 0;\n        \n        verify();\n\n    }","commit_id":"bffb14764ac3746f3221751129edd246e2210f25","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * Performs an asynchronous increment of the specified counter in the\n   * specified counter set by the specified amount.\n   * <p>\n   * Value of counter after increment is not available.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   * @throws OperationException\n   */\n  public void incrementCounterSet(byte [] counterSet, byte [] counter,\n      long amount) throws OperationException {\n    this.collector.add(\n        generateCounterSetIncrement(counterSet, counter, amount));\n  }","id":9453,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counter in the\n   * specified counter set by the specified amount.\n   * <p>\n   * Value of counter after increment is not available.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   */\n  public void incrementCounterSet(byte [] counterSet, byte [] counter,\n      long amount) {\n    this.collector.add(\n        generateCounterSetIncrement(counterSet, counter, amount));\n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure(FlowSpecifier specifier) {\n\n    // Set metadata fields\n    specifier.name(\"ProductFeedProcessor\");\n    specifier.email(\"dev@continuuity.com\");\n    specifier.application(\"Cluster Activity Feeds\");\n    specifier.company(\"Continuuity+Payvment\");\n\n    // Declare all of the flowlets within the flow\n    specifier.flowlet(\"product_parser\", ProductFeedParserFlowlet.class, 1);\n    specifier.flowlet(\"product_processor\", ProductProcessorFlowlet.class, 1);\n    specifier.flowlet(\"activity_feed_updater\",\n        ProductActivityFeedUpdaterFlowlet.class, 1);\n\n    // Define user_follow_events stream and connect to json_source_parser\n    specifier.stream(inputStream);\n    specifier.input(inputStream, \"product_parser\");\n\n    // Wire up the remaining flowlet connections\n    specifier.connection(\"product_parser\", \"product_processor\");\n    specifier.connection(\"product_processor\", \"activity_feed_updater\");\n  }","id":9454,"modified_method":"@Override\n  public void configure(FlowSpecifier specifier) {\n\n    // Set metadata fields\n    specifier.name(flowName);\n    specifier.email(\"dev@continuuity.com\");\n    specifier.application(\"Cluster Activity Feeds\");\n    specifier.company(\"Continuuity+Payvment\");\n\n    // Declare all of the flowlets within the flow\n    specifier.flowlet(\"product_parser\", ProductFeedParserFlowlet.class, 1);\n    specifier.flowlet(\"product_processor\", ProductProcessorFlowlet.class, 1);\n    specifier.flowlet(\"activity_feed_updater\",\n        ProductActivityFeedUpdaterFlowlet.class, 1);\n\n    // Define user_follow_events stream and connect to json_source_parser\n    specifier.stream(inputStream);\n    specifier.input(inputStream, \"product_parser\");\n\n    // Wire up the remaining flowlet connections\n    specifier.connection(\"product_parser\", \"product_processor\");\n    specifier.connection(\"product_processor\", \"activity_feed_updater\");\n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure(FlowSpecifier specifier) {\n\n    // Set metadata fields\n    specifier.name(\"SocialActionProcessor\");\n    specifier.email(\"dev@continuuity.com\");\n    specifier.application(\"Cluster Activity Feeds\");\n    specifier.company(\"Continuuity+Payvment\");\n\n    // Declare all of the flowlets within the flow\n    specifier.flowlet(\"action_parser\", SocialActionParserFlowlet.class,\n        1);\n    specifier.flowlet(\"action_processor\", SocialActionProcessorFlowlet.class,\n        1);\n    specifier.flowlet(\"activity_feed_updater\", ActivityFeedUpdaterFlowlet.class,\n        1);\n    specifier.flowlet(\"popular_feed_updater\", PopularFeedUpdaterFlowlet.class,\n        1);\n\n    // Define user_follow_events stream and connect to json_source_parser\n    specifier.stream(inputStream);\n    specifier.input(inputStream, \"action_parser\");\n\n    // Wire up the remaining flowlet connections\n    specifier.connection(\"action_parser\", \"action_processor\");\n    specifier.connection(\"action_processor\", \"activity_feed_updater\");\n    specifier.connection(\"action_processor\", \"popular_feed_updater\");\n  }","id":9455,"modified_method":"@Override\n  public void configure(FlowSpecifier specifier) {\n\n    // Set metadata fields\n    specifier.name(flowName);\n    specifier.email(\"dev@continuuity.com\");\n    specifier.application(\"Cluster Activity Feeds\");\n    specifier.company(\"Continuuity+Payvment\");\n\n    // Declare all of the flowlets within the flow\n    specifier.flowlet(\"action_parser\", SocialActionParserFlowlet.class,\n        1);\n    specifier.flowlet(\"action_processor\", SocialActionProcessorFlowlet.class,\n        1);\n    specifier.flowlet(\"activity_feed_updater\", ActivityFeedUpdaterFlowlet.class,\n        1);\n    specifier.flowlet(\"popular_feed_updater\", PopularFeedUpdaterFlowlet.class,\n        1);\n\n    // Define user_follow_events stream and connect to json_source_parser\n    specifier.stream(inputStream);\n    specifier.input(inputStream, \"action_parser\");\n\n    // Wire up the remaining flowlet connections\n    specifier.connection(\"action_parser\", \"action_processor\");\n    specifier.connection(\"action_processor\", \"activity_feed_updater\");\n    specifier.connection(\"action_processor\", \"popular_feed_updater\");\n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void process(Tuple tuple, TupleContext context,\n        OutputCollector collector) {\n      SocialAction action = tuple.get(\"action\");\n      TupleBuilder tupleBuilder = new TupleBuilder();\n      tupleBuilder.set(\"action\", action);\n      \n      // Read the category from product table\n      ProductMeta productMeta;\n      try {\n        productMeta = productTable.readObject(\n            Bytes.toBytes(action.product_id));\n      } catch (OperationException e) {\n        e.printStackTrace();\n        throw new RuntimeException(\"Error reading product metadata\");\n      }\n      if (productMeta == null) {\n        // Received social action for unknown item, don't know what to do yet\n        String msg = \"Received social action for unknown product (\" +\n            action.product_id + \")\";\n        System.out.println(msg);\n        throw new RuntimeException(msg);\n      }\n      tupleBuilder.set(\"product-meta\", productMeta);\n      \n      // Update product action count table\n      try {\n        this.productActionCountTable.incrementCounterSet(\n            Bytes.toBytes(action.product_id), Bytes.toBytes(action.type), 1L);\n      } catch (OperationException e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n      }\n      \n      // Determine score increase\n      Long scoreIncrease = action.getSocialActionType().getScore();\n      tupleBuilder.set(\"score-increase\", scoreIncrease);\n      \n      // Update all-time score, but put increment into tuple for pass-thru\n      Increment allTimeScore = allTimeScoreTable.generateSingleKeyIncrement(\n          Bytes.add(Constants.PRODUCT_ALL_TIME_PREFIX,\n              Bytes.toBytes(action.product_id)), scoreIncrease);\n      tupleBuilder.set(\"all-time-score\", allTimeScore);\n      \n      // Update time bucketed top-score table, also put increment into tuple\n      Increment topScoreHourly = topScoreTable.generatePrimaryCounterIncrement(\n          Bytes.add(Bytes.toBytes(Helpers.hour(action.date)),\n              Bytes.toBytes(productMeta.category)),\n          Bytes.toBytes(action.product_id), scoreIncrease);\n      tupleBuilder.set(\"hourly-score\", topScoreHourly);\n      \n      collector.add(tupleBuilder.create());\n    }","id":9456,"modified_method":"@Override\n    public void process(Tuple tuple, TupleContext context,\n        OutputCollector collector) {\n      SocialAction action = tuple.get(\"action\");\n      TupleBuilder tupleBuilder = new TupleBuilder();\n      tupleBuilder.set(\"action\", action);\n      \n      // Read the category from product table\n      ProductMeta productMeta;\n      try {\n        productMeta = productTable.readObject(\n            Bytes.toBytes(action.product_id));\n      } catch (OperationException e) {\n        e.printStackTrace();\n        throw new RuntimeException(\"Error reading product metadata\");\n      }\n      if (productMeta == null) {\n        // Received social action for unknown item, don't know what to do yet\n        String msg = \"Received social action for unknown product (\" +\n            action.product_id + \")\";\n        System.out.println(msg);\n        numErrors++;\n        throw new RuntimeException(msg);\n      }\n      tupleBuilder.set(\"product-meta\", productMeta);\n      \n      // Update product action count table async\n      this.productActionCountTable.incrementCounterSet(\n          Bytes.toBytes(action.product_id), Bytes.toBytes(action.type), 1L);\n      \n      // Determine score increase\n      Long scoreIncrease = action.getSocialActionType().getScore();\n      tupleBuilder.set(\"score-increase\", scoreIncrease);\n      \n      // Update all-time score, but put increment into tuple for pass-thru\n      Increment allTimeScore = allTimeScoreTable.generateSingleKeyIncrement(\n          Bytes.add(Constants.PRODUCT_ALL_TIME_PREFIX,\n              Bytes.toBytes(action.product_id)), scoreIncrease);\n      tupleBuilder.set(\"all-time-score\", allTimeScore);\n      \n      // Update time bucketed top-score table, also put increment into tuple\n      Increment topScoreHourly = topScoreTable.generatePrimaryCounterIncrement(\n          Bytes.add(Bytes.toBytes(Helpers.hour(action.date)),\n              Bytes.toBytes(productMeta.category)),\n          Bytes.toBytes(action.product_id), scoreIncrease);\n      tupleBuilder.set(\"hourly-score\", topScoreHourly);\n      \n      collector.add(tupleBuilder.create());\n    }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 10000000)\n  public void testProductFeedFlow_Basic() throws Exception {\n    \n    // Instantiate product feed flow\n    ProductFeedFlow productFeedFlow = new ProductFeedFlow();\n    \n    // Start the flow\n    TestFlowHandle flowHandle =\n        FlowTestHelper.startFlow(productFeedFlow, conf, executor);\n    assertTrue(flowHandle.isSuccess());\n    \n    // Generate a single product event\n    long now = System.currentTimeMillis();\n    ProductMeta productMeta =\n        new ProductMeta(1L, 2L, now, \"category\", \"name\", 3.5);\n    String productMetaJson = productMeta.toJson();\n    \n    // Write json to input stream\n    writeToStream(ProductFeedFlow.inputStream, Bytes.toBytes(productMetaJson));\n    \n    // Wait for parsing flowlet to process the tuple\n    while (ProductFeedParserFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for parsing flowlet to process tuple\");\n      Thread.sleep(1000);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (ProductFeedFlow.ProductProcessorFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for processor flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (ProductFeedFlow.ProductActivityFeedUpdaterFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for updater flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    System.out.println(\"Tuple processed to the end!\");\n\n    // If we are here, flow ran successfully!\n    assertTrue(FlowTestHelper.stopFlow(flowHandle));\n    \n    // Verify the product is stored\n    \n    // Verify activity feed entry has been generated\n    \n  }","id":9457,"modified_method":"@Test(timeout = 10000000)\n  public void testProductFeedFlow_Basic() throws Exception {\n    \n    // Instantiate product feed flow\n    ProductFeedFlow productFeedFlow = new ProductFeedFlow();\n    \n    // Start the flow\n    TestFlowHandle flowHandle =\n        FlowTestHelper.startFlow(productFeedFlow, conf, executor);\n    assertTrue(flowHandle.isSuccess());\n    \n    // Generate a single product event\n    long now = System.currentTimeMillis();\n    ProductMeta productMeta =\n        new ProductMeta(1L, 2L, now, \"category\", \"name\", 3.5);\n    String productMetaJson = productMeta.toJson();\n    \n    // Write json to input stream\n    writeToStream(ProductFeedFlow.flowName, ProductFeedFlow.inputStream,\n        Bytes.toBytes(productMetaJson));\n    \n    // Wait for parsing flowlet to process the tuple\n    while (ProductFeedParserFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for parsing flowlet to process tuple\");\n      Thread.sleep(1000);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (ProductFeedFlow.ProductProcessorFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for processor flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (ProductFeedFlow.ProductActivityFeedUpdaterFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for updater flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    System.out.println(\"Tuple processed to the end!\");\n\n    // If we are here, flow ran successfully!\n    assertTrue(FlowTestHelper.stopFlow(flowHandle));\n    \n    // Verify the product is stored\n    \n    // Verify activity feed entry has been generated\n    \n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"private void writeToStream(String streamName, byte[] bytes)\n      throws OperationException {\n    Map<String,String> headers = new HashMap<String,String>();\n    TupleSerializer serializer = new TupleSerializer(false);\n    Tuple tuple = new TupleBuilder()\n        .set(\"headers\", headers)\n        .set(\"body\", bytes)\n        .create();\n    executor.execute(OperationContext.DEFAULT,\n        new QueueEnqueue(\n            Bytes.toBytes(FlowStream.defaultInputURI(streamName).toString()),\n            serializer.serialize(tuple)));\n  }","id":9458,"modified_method":"private void writeToStream(String flowName, String streamName, byte[] bytes)\n      throws OperationException {\n    Map<String,String> headers = new HashMap<String,String>();\n    TupleSerializer serializer = new TupleSerializer(false);\n    Tuple tuple = new TupleBuilder()\n        .set(\"headers\", headers)\n        .set(\"body\", bytes)\n        .create();\n    System.out.println(\"Writing event to stream: \" +\n        FlowStream.defaultURI(flowName, streamName).toString());\n    executor.execute(OperationContext.DEFAULT,\n        new QueueEnqueue(\n            Bytes.toBytes(\n                FlowStream.defaultURI(flowName, streamName).toString()),\n            serializer.serialize(tuple)));\n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 10000)\n  public void testSocialActionFlow_Basic() throws Exception {\n    \n    // Instantiate product feed flow\n    SocialActionFlow socialActionFlow = new SocialActionFlow();\n    \n    // Start the flow\n    TestFlowHandle flowHandle =\n        FlowTestHelper.startFlow(socialActionFlow, conf, executor);\n    assertTrue(flowHandle.isSuccess());\n    \n    // Generate a single social action event\n    long now = System.currentTimeMillis();\n    Long event_id = 1L;\n    Long product_id = 2L;\n    Long user_id = 3l;\n    SocialAction socialAction =\n        new SocialAction(event_id, now, \"yay-exp-action\", product_id, user_id);\n    String socialActionJson = socialAction.toJson();\n    \n    // Write json to input stream\n    writeToStream(SocialActionFlow.inputStream,\n        Bytes.toBytes(socialActionJson));\n    \n    // Wait for parsing flowlet to process the tuple\n    while (SocialActionParserFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for parsing flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (SocialActionFlow.SocialActionProcessorFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for processor flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (SocialActionFlow.ActivityFeedUpdaterFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for updater flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (SocialActionFlow.PopularFeedUpdaterFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for updater flowlet to process tuple\");\n      Thread.sleep(10);\n    }\n    \n    System.out.println(\"Tuple processed to the end!\");\n\n    // If we are here, flow ran successfully!\n    assertTrue(FlowTestHelper.stopFlow(flowHandle));\n    \n    // Verify the product action count has been incremented\n    \n    // Verify the product total score has incremented\n    \n    // Verify the hourly score has been incremented\n    \n    // Verify a new entry has been made in activity feed\n    \n    \n  }","id":9459,"modified_method":"@Test(timeout = 10000000)\n  public void testSocialActionFlow_Basic() throws Exception {\n    \n    // Instantiate product feed flow\n    SocialActionFlow socialActionFlow = new SocialActionFlow();\n    \n    // Start the flow\n    TestFlowHandle flowHandle =\n        FlowTestHelper.startFlow(socialActionFlow, conf, executor);\n    assertTrue(flowHandle.isSuccess());\n    \n    // Generate a single social action event\n    long now = System.currentTimeMillis();\n    Long event_id = 1L;\n    Long product_id = 2L;\n    Long user_id = 3L;\n    SocialAction socialAction =\n        new SocialAction(event_id, now, \"yay-exp-action\", product_id, user_id);\n    String socialActionJson = socialAction.toJson();\n    \n    // Write json to input stream\n    writeToStream(SocialActionFlow.flowName, SocialActionFlow.inputStream,\n        Bytes.toBytes(socialActionJson));\n    \n    // Wait for parsing flowlet to process the tuple\n    while (SocialActionParserFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for parsing flowlet to process tuple\");\n      Thread.sleep(100);\n    }\n    \n    // This tuple should error out because it's an unknown product\n    while (SocialActionFlow.SocialActionProcessorFlowlet.numErrors < 1) {\n      System.out.println(\"Waiting for processor flowlet to error on tuple\");\n      Thread.sleep(100);\n    }\n    \n    // Store the product -> category mapping\n    Long store_id = 15L;\n    String category = \"Sports\";\n    String name = \"Tennis Shoes\";\n    ProductMeta productMeta = new ProductMeta(product_id, store_id, now,\n        category, name, 1.0);\n    ProductTable productTable = new ProductTable(flowletContext);\n    productTable.writeObject(Bytes.toBytes(productMeta.product_id),\n        productMeta);\n    \n    // Write same json to input stream\n    writeToStream(SocialActionFlow.flowName, SocialActionFlow.inputStream,\n        Bytes.toBytes(socialActionJson));\n    \n    // Wait for parsing flowlet to process the second tuple\n    while (SocialActionParserFlowlet.numProcessed < 2) {\n      System.out.println(\"Waiting for parsing flowlet to process 2nd tuple\");\n      Thread.sleep(100);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (SocialActionFlow.SocialActionProcessorFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for processor flowlet to process tuple\");\n      Thread.sleep(100);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (SocialActionFlow.ActivityFeedUpdaterFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for updater flowlet to process tuple\");\n      Thread.sleep(100);\n    }\n    \n    // Wait for processor flowlet to process the tuple\n    while (SocialActionFlow.PopularFeedUpdaterFlowlet.numProcessed < 1) {\n      System.out.println(\"Waiting for updater flowlet to process tuple\");\n      Thread.sleep(100);\n    }\n    \n    System.out.println(\"Tuple processed to the end!\");\n\n    // If we are here, flow ran successfully!\n    assertTrue(FlowTestHelper.stopFlow(flowHandle));\n    \n    // Verify the product action count has been incremented\n    \n    // Verify the product total score has incremented\n    \n    // Verify the hourly score has been incremented\n    \n    // Verify a new entry has been made in activity feed\n    \n    \n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"private void writeToStream(String streamName, byte[] bytes)\n      throws OperationException {\n    Map<String,String> headers = new HashMap<String,String>();\n    TupleSerializer serializer = new TupleSerializer(false);\n    Tuple tuple = new TupleBuilder()\n        .set(\"headers\", headers)\n        .set(\"body\", bytes)\n        .create();\n    executor.execute(OperationContext.DEFAULT,\n        new QueueEnqueue(\n            Bytes.toBytes(FlowStream.defaultInputURI(streamName).toString()),\n            serializer.serialize(tuple)));\n  }","id":9460,"modified_method":"private void writeToStream(String flowName, String streamName, byte[] bytes)\n      throws OperationException {\n    Map<String,String> headers = new HashMap<String,String>();\n    TupleSerializer serializer = new TupleSerializer(false);\n    Tuple tuple = new TupleBuilder()\n        .set(\"headers\", headers)\n        .set(\"body\", bytes)\n        .create();\n    System.out.println(\"Writing event to stream: \" +\n        FlowStream.defaultURI(flowName, streamName).toString());\n    executor.execute(OperationContext.DEFAULT,\n        new QueueEnqueue(\n            Bytes.toBytes(\n                FlowStream.defaultURI(flowName, streamName).toString()),\n            serializer.serialize(tuple)));\n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void setUpBeforeClass() throws Exception {\n    conf = CConfiguration.create();\n  }","id":9461,"modified_method":"@BeforeClass\n  public static void setUpBeforeClass() throws Exception {\n    conf = CConfiguration.create();\n    flowletContext = new FlowletContext() {\n\n      @Override\n      public void register(BatchCollectionClient client) {}\n\n      @Override\n      public DataFabric getDataFabric() {\n        return new DataFabricImpl(executor, OperationContext.DEFAULT);\n      }\n\n      @Override\n      public int getInstanceId() {\n        return 0;\n      }\n      \n    };\n  }","commit_id":"966eb52a1f25fed3db104f63eeb32e09ef546959","url":"https://github.com/caskdata/cdap"},{"original_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression){\n            super.visitMethodCallExpression(expression);\n            if(!isJNDIFactoryMethod(expression)){\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(!(parent instanceof PsiAssignmentExpression)){\n                registerError(expression, expression);\n                return;\n            }\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) parent;\n            final PsiExpression lhs = assignment.getLExpression();\n            if(!(lhs instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiElement referent =\n                    ((PsiReference) lhs).resolve();\n            if(referent == null || !(referent instanceof PsiVariable)){\n                return;\n            }\n            final PsiVariable boundVariable = (PsiVariable) referent;\n\n            PsiElement currentContext = expression;\n            while(true){\n                final PsiTryStatement tryStatement =\n                        PsiTreeUtil.getParentOfType(currentContext,\n                                PsiTryStatement.class);\n                if(tryStatement == null){\n                    registerError(expression, expression);\n                    return;\n                }\n                if(resourceIsOpenedInTryAndClosedInFinally(tryStatement,\n                        expression,\n                        boundVariable)){\n                    return;\n                }\n                currentContext = tryStatement;\n            }\n        }","id":9462,"modified_method":"public void visitMethodCallExpression(\n                @NotNull PsiMethodCallExpression expression){\n            super.visitMethodCallExpression(expression);\n            if(!isJNDIFactoryMethod(expression)){\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(!(parent instanceof PsiAssignmentExpression)){\n                final PsiType type = expression.getType();\n                if (type == null) {\n                    return;\n                }\n                final String text = type.getPresentableText();\n                registerError(expression, text);\n                return;\n            }\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) parent;\n            final PsiExpression lhs = assignment.getLExpression();\n            if(!(lhs instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiElement referent =\n                    ((PsiReference) lhs).resolve();\n            if(referent == null || !(referent instanceof PsiVariable)){\n                return;\n            }\n            final PsiVariable boundVariable = (PsiVariable) referent;\n\n            PsiElement currentContext = expression;\n            while(true){\n                final PsiTryStatement tryStatement =\n                        PsiTreeUtil.getParentOfType(currentContext,\n                                PsiTryStatement.class);\n                if(tryStatement == null){\n                    final PsiType type = expression.getType();\n                    if (type == null) {\n                        return;\n                    }\n                    final String text = type.getPresentableText();\n                    registerError(expression, text);\n                    return;\n                }\n                if(resourceIsOpenedInTryAndClosedInFinally(tryStatement,\n                        expression,\n                        boundVariable)){\n                    return;\n                }\n                currentContext = tryStatement;\n            }\n        }","commit_id":"2ad0ba788c1c4db3b8a9b22d7172c630aec063a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitNewExpression(@NotNull PsiNewExpression expression){\n            super.visitNewExpression(expression);\n            if(!isJNDIResource(expression)){\n                return;\n            }\n            if(expression.getType() == null){\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(!(parent instanceof PsiAssignmentExpression)){\n                registerError(expression, expression);\n                return;\n            }\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) parent;\n            final PsiExpression lhs = assignment.getLExpression();\n            if(!(lhs instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiElement referent =\n                    ((PsiReference) lhs).resolve();\n            if(referent == null || !(referent instanceof PsiVariable)){\n                return;\n            }\n            final PsiVariable boundVariable = (PsiVariable) referent;\n\n            PsiElement currentContext = expression;\n            while(true){\n                final PsiTryStatement tryStatement =\n                        PsiTreeUtil.getParentOfType(currentContext,\n                                PsiTryStatement.class);\n                if(tryStatement == null){\n                    registerError(expression, expression);\n                    return;\n                }\n                if(resourceIsOpenedInTryAndClosedInFinally(tryStatement,\n                        expression,\n                        boundVariable)){\n                    return;\n                }\n                currentContext = tryStatement;\n            }\n        }","id":9463,"modified_method":"public void visitNewExpression(@NotNull PsiNewExpression expression){\n            super.visitNewExpression(expression);\n            if(!isJNDIResource(expression)){\n                return;\n            }\n            if(expression.getType() == null){\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(!(parent instanceof PsiAssignmentExpression)){\n                final PsiType type = expression.getType();\n                if (type == null) {\n                    return;\n                }\n                final String text = type.getPresentableText();\n                registerError(expression, text);\n                return;\n            }\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) parent;\n            final PsiExpression lhs = assignment.getLExpression();\n            if(!(lhs instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiElement referent =\n                    ((PsiReference) lhs).resolve();\n            if(referent == null || !(referent instanceof PsiVariable)){\n                return;\n            }\n            final PsiVariable boundVariable = (PsiVariable) referent;\n\n            PsiElement currentContext = expression;\n            while(true){\n                final PsiTryStatement tryStatement =\n                        PsiTreeUtil.getParentOfType(currentContext,\n                                PsiTryStatement.class);\n                if(tryStatement == null){\n                    final PsiType type = expression.getType();\n                    if (type == null) {\n                        return;\n                    }\n                    final String text = type.getPresentableText();\n                    registerError(expression, text);\n                    return;\n                }\n                if(resourceIsOpenedInTryAndClosedInFinally(tryStatement,\n                        expression,\n                        boundVariable)){\n                    return;\n                }\n                currentContext = tryStatement;\n            }\n        }","commit_id":"2ad0ba788c1c4db3b8a9b22d7172c630aec063a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String buildErrorString(Object... infos){\n        final PsiExpression expression = (PsiExpression) infos[0];\n        final PsiType type = expression.getType();\n        assert type != null;\n        final String text = type.getPresentableText();\n        return InspectionGadgetsBundle.message(\n                \"resource.opened.not.closed.problem.descriptor\", text);\n    }","id":9464,"modified_method":"@NotNull\n    public String buildErrorString(Object... infos){\n        return InspectionGadgetsBundle.message(\n                \"resource.opened.not.closed.problem.descriptor\", infos[0]);\n    }","commit_id":"2ad0ba788c1c4db3b8a9b22d7172c630aec063a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                while(received_msgs.size() > 0) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"received msgs=\" + received_msgs.size() + \", max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                    key=(Long)received_msgs.firstKey();\n                    retval=(Message)received_msgs.get(key);\n                    if(retval != null) { // message exists and is ready for delivery\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        if(discard_delivered_msgs == false) {\n                            delivered_msgs.put(key, retval); // delivered_msgs\n                        }\n                        head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                        return retval;\n                    }\n                    else { // message has not yet been received (gap in the message sequence stream)\n                        if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                            received_msgs.remove(key);       // move from received_msgs to ...\n                            head++;\n                            retransmitter.remove(key.longValue());\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                return retval;\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n            return null;\n        }\n    }","id":9465,"modified_method":"public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                while(received_msgs.size() > 0) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"received msgs=\");\n                        sb.append(received_msgs.size()).append(\", max_xmit_buf_size=\").append(max_xmit_buf_size);\n                        log.trace(sb.toString());\n                    }\n\n                    key=(Long)received_msgs.firstKey();\n                    retval=(Message)received_msgs.get(key);\n                    if(retval != null) { // message exists and is ready for delivery\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        if(discard_delivered_msgs == false) {\n                            delivered_msgs.put(key, retval); // delivered_msgs\n                        }\n                        head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                        return retval;\n                    }\n                    else { // message has not yet been received (gap in the message sequence stream)\n                        if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                            received_msgs.remove(key);       // move from received_msgs to ...\n                            head++;\n                            retransmitter.remove(key.longValue());\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                return retval;\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n            return null;\n        }\n    }","commit_id":"3868a10b23f7fe6cb594f278998109b57088325d","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                old_tail=tail;\n                if(seqno < head) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"seqno \" + seqno + \" is smaller than \" + head + \"); discarding message\");\n                    return;\n                }\n\n                // add at end (regular expected msg)\n                if(seqno == tail) {\n                    received_msgs.put(new Long(seqno), msg);\n                    tail++;\n                    highest_seen=seqno;\n                }\n                // gap detected\n                // i. add placeholders, creating gaps\n                // ii. add real msg\n                // iii. tell retransmitter to retrieve missing msgs\n                else if(seqno > tail) {\n                    for(long i=tail; i < seqno; i++) {\n                        received_msgs.put(new Long(i), null);\n                        // XmitEntry xmit_entry=new XmitEntry();\n                        //xmits.put(new Long(i), xmit_entry);\n                        tail++;\n                    }\n                    received_msgs.put(new Long(seqno), msg);\n                    tail=seqno + 1;\n                    if(retransmitter != null) {\n                        retransmitter.add(old_tail, seqno - 1);\n                    }\n                    // finally received missing message\n                }\n                else if(seqno < tail) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"added missing msg \" + msg.getSrc() + '#' + seqno);\n\n                    Object val=received_msgs.get(new Long(seqno));\n                    if(val == null) {\n                        // only set message if not yet received (bela July 23 2003)\n                        received_msgs.put(new Long(seqno), msg);\n\n                        if(highest_seen +1 == seqno || seqno == head)\n                            updateHighestSeen();\n\n                        //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                        //if(xmit_entry != null)\n                        //  xmit_entry.received=System.currentTimeMillis();\n                        //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                        //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                        if(retransmitter != null) retransmitter.remove(seqno);\n                    }\n                }\n                updateLowestSeen();\n                // updateHighestSeen();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","id":9466,"modified_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                old_tail=tail;\n                if(seqno < head) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"seqno \");\n                        sb.append(seqno).append(\" is smaller than \").append(head).append(\"); discarding message\");\n                        log.trace(sb.toString());\n                    }\n                    return;\n                }\n\n                // add at end (regular expected msg)\n                if(seqno == tail) {\n                    received_msgs.put(new Long(seqno), msg);\n                    tail++;\n                    highest_seen=seqno;\n                }\n                // gap detected\n                // i. add placeholders, creating gaps\n                // ii. add real msg\n                // iii. tell retransmitter to retrieve missing msgs\n                else if(seqno > tail) {\n                    for(long i=tail; i < seqno; i++) {\n                        received_msgs.put(new Long(i), null);\n                        // XmitEntry xmit_entry=new XmitEntry();\n                        //xmits.put(new Long(i), xmit_entry);\n                        tail++;\n                    }\n                    received_msgs.put(new Long(seqno), msg);\n                    tail=seqno + 1;\n                    if(retransmitter != null) {\n                        retransmitter.add(old_tail, seqno - 1);\n                    }\n                    // finally received missing message\n                }\n                else if(seqno < tail) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"added missing msg \");\n                        sb.append(msg.getSrc()).append('#').append(seqno);\n                        log.trace(sb.toString());\n                    }\n\n                    Object val=received_msgs.get(new Long(seqno));\n                    if(val == null) {\n                        // only set message if not yet received (bela July 23 2003)\n                        received_msgs.put(new Long(seqno), msg);\n\n                        if(highest_seen +1 == seqno || seqno == head)\n                            updateHighestSeen();\n\n                        //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                        //if(xmit_entry != null)\n                        //  xmit_entry.received=System.currentTimeMillis();\n                        //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                        //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                        if(retransmitter != null) retransmitter.remove(seqno);\n                    }\n                }\n                updateLowestSeen();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"3868a10b23f7fe6cb594f278998109b57088325d","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setUp() {\n\tnum_msgs_received=0;\n\tnum_msgs_sent=0;\n    }","id":9467,"modified_method":"public void setUp() throws Exception {\n        super.setUp();\n        num_msgs_received=0;\n        num_msgs_sent=0;\n    }","commit_id":"3868a10b23f7fe6cb594f278998109b57088325d","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                old_tail=tail;\n                if(seqno < head) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"seqno \" + seqno + \" is smaller than \" + head + \"); discarding message\");\n                    return;\n                }\n\n                // add at end (regular expected msg)\n                if(seqno == tail) {\n                    received_msgs.put(new Long(seqno), msg);\n                    tail++;\n                    highest_seen=seqno;\n                }\n                // gap detected\n                // i. add placeholders, creating gaps\n                // ii. add real msg\n                // iii. tell retransmitter to retrieve missing msgs\n                else if(seqno > tail) {\n                    for(long i=tail; i < seqno; i++) {\n                        received_msgs.put(new Long(i), null);\n                        // XmitEntry xmit_entry=new XmitEntry();\n                        //xmits.put(new Long(i), xmit_entry);\n                        tail++;\n                    }\n                    received_msgs.put(new Long(seqno), msg);\n                    tail=seqno + 1;\n                    if(retransmitter != null) {\n                        retransmitter.add(old_tail, seqno - 1);\n                    }\n                    // finally received missing message\n                }\n                else if(seqno < tail) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"added missing msg \" + msg.getSrc() + '#' + seqno);\n\n                    Object val=received_msgs.get(new Long(seqno));\n                    if(val == null) {\n                        // only set message if not yet received (bela July 23 2003)\n                        received_msgs.put(new Long(seqno), msg);\n\n                        if(highest_seen +1 == seqno || seqno == head)\n                            updateHighestSeen();\n\n                        //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                        //if(xmit_entry != null)\n                        //  xmit_entry.received=System.currentTimeMillis();\n                        //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                        //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                        if(retransmitter != null) retransmitter.remove(seqno);\n                    }\n                }\n                updateLowestSeen();\n                // updateHighestSeen();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","id":9468,"modified_method":"/**\n     * Adds a message according to its sequence number (ordered).\n     * <p>\n     * Variables <code>head<\/code> and <code>tail<\/code> mark the start and\n     * end of the messages received, but not delivered yet. When a message is\n     * received, if its seqno is smaller than <code>head<\/code>, it is\n     * discarded (already received). If it is bigger than <code>tail<\/code>,\n     * we advance <code>tail<\/code> and add empty elements. If it is between\n     * <code>head<\/code> and <code>tail<\/code>, we set the corresponding\n     * missing (or already present) element. If it is equal to\n     * <code>tail<\/code>, we advance the latter by 1 and add the message\n     * (default case).\n     */\n    public void add(long seqno, Message msg) {\n        long old_tail;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                old_tail=tail;\n                if(seqno < head) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"seqno \");\n                        sb.append(seqno).append(\" is smaller than \").append(head).append(\"); discarding message\");\n                        log.trace(sb.toString());\n                    }\n                    return;\n                }\n\n                // add at end (regular expected msg)\n                if(seqno == tail) {\n                    received_msgs.put(new Long(seqno), msg);\n                    tail++;\n                    highest_seen=seqno;\n                }\n                // gap detected\n                // i. add placeholders, creating gaps\n                // ii. add real msg\n                // iii. tell retransmitter to retrieve missing msgs\n                else if(seqno > tail) {\n                    for(long i=tail; i < seqno; i++) {\n                        received_msgs.put(new Long(i), null);\n                        // XmitEntry xmit_entry=new XmitEntry();\n                        //xmits.put(new Long(i), xmit_entry);\n                        tail++;\n                    }\n                    received_msgs.put(new Long(seqno), msg);\n                    tail=seqno + 1;\n                    if(retransmitter != null) {\n                        retransmitter.add(old_tail, seqno - 1);\n                    }\n                    // finally received missing message\n                }\n                else if(seqno < tail) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"added missing msg \");\n                        sb.append(msg.getSrc()).append('#').append(seqno);\n                        log.trace(sb.toString());\n                    }\n\n                    Object val=received_msgs.get(new Long(seqno));\n                    if(val == null) {\n                        // only set message if not yet received (bela July 23 2003)\n                        received_msgs.put(new Long(seqno), msg);\n\n                        if(highest_seen +1 == seqno || seqno == head)\n                            updateHighestSeen();\n\n                        //XmitEntry xmit_entry=(XmitEntry)xmits.get(new Long(seqno));\n                        //if(xmit_entry != null)\n                        //  xmit_entry.received=System.currentTimeMillis();\n                        //long xmit_diff=xmit_entry == null? -1 : xmit_entry.received - xmit_entry.created;\n                        //NAKACK.addXmitResponse(msg.getSrc(), seqno);\n                        if(retransmitter != null) retransmitter.remove(seqno);\n                    }\n                }\n                updateLowestSeen();\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n        }\n    }","commit_id":"6b9a455670674c6e28c1fa0fe04d184dc64569bc","url":"https://github.com/belaban/JGroups"},{"original_method":"public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                while(received_msgs.size() > 0) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"received msgs=\" + received_msgs.size() + \", max_xmit_buf_size=\" + max_xmit_buf_size);\n\n                    key=(Long)received_msgs.firstKey();\n                    retval=(Message)received_msgs.get(key);\n                    if(retval != null) { // message exists and is ready for delivery\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        if(discard_delivered_msgs == false) {\n                            delivered_msgs.put(key, retval); // delivered_msgs\n                        }\n                        head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                        return retval;\n                    }\n                    else { // message has not yet been received (gap in the message sequence stream)\n                        if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                            received_msgs.remove(key);       // move from received_msgs to ...\n                            head++;\n                            retransmitter.remove(key.longValue());\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                return retval;\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n            return null;\n        }\n    }","id":9469,"modified_method":"public Message remove() {\n        Message retval=null;\n        Long    key;\n        boolean bounded_buffer_enabled=max_xmit_buf_size > 0;\n\n        try {\n            lock.writeLock().acquire();\n            try {\n                while(received_msgs.size() > 0) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"received msgs=\");\n                        sb.append(received_msgs.size()).append(\", max_xmit_buf_size=\").append(max_xmit_buf_size);\n                        log.trace(sb.toString());\n                    }\n\n                    key=(Long)received_msgs.firstKey();\n                    retval=(Message)received_msgs.get(key);\n                    if(retval != null) { // message exists and is ready for delivery\n                        received_msgs.remove(key);       // move from received_msgs to ...\n                        if(discard_delivered_msgs == false) {\n                            delivered_msgs.put(key, retval); // delivered_msgs\n                        }\n                        head++;  // is removed from retransmitter somewhere else (when missing message is received)\n                        return retval;\n                    }\n                    else { // message has not yet been received (gap in the message sequence stream)\n                        if(bounded_buffer_enabled && received_msgs.size() > max_xmit_buf_size) {\n                            received_msgs.remove(key);       // move from received_msgs to ...\n                            head++;\n                            retransmitter.remove(key.longValue());\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n                return retval;\n            }\n            finally {\n                lock.writeLock().release();\n            }\n        }\n        catch(InterruptedException e) {\n            log.error(\"failed acquiring write lock\", e);\n            return null;\n        }\n    }","commit_id":"6b9a455670674c6e28c1fa0fe04d184dc64569bc","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setUp() {\n\tnum_msgs_received=0;\n\tnum_msgs_sent=0;\n    }","id":9470,"modified_method":"public void setUp() throws Exception {\n        super.setUp();\n        num_msgs_received=0;\n        num_msgs_sent=0;\n    }","commit_id":"6b9a455670674c6e28c1fa0fe04d184dc64569bc","url":"https://github.com/belaban/JGroups"},{"original_method":"public void doReceive(Message message) throws Exception {\n\t\tSearchRequest searchRequest = (SearchRequest)message.getPayload();\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tif (command.equals(SearchRequest.COMMAND_INDEX_ONLY)) {\n\t\t\tdoCommandIndexOnly(message);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_SEARCH)) {\n\t\t\tdoCommandSearch(message, searchRequest);\n\t\t}\n\t}","id":9471,"modified_method":"public void doReceive(Message message) throws Exception {\n\t\tObject payload = message.getPayload();\n\n\t\tif (!LuceneSearchEngineUtil.isRegistered() ||\n\t\t\t!(payload instanceof SearchRequest)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSearchRequest searchRequest = (SearchRequest)payload;\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tif (command.equals(SearchRequest.COMMAND_INDEX_ONLY)) {\n\t\t\tdoCommandIndexOnly(message);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_SEARCH)) {\n\t\t\tdoCommandSearch(message, searchRequest);\n\t\t}\n\t}","commit_id":"440349458d30f45751b998d4f24b3f343073b059","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void unregister(String name) {\n\t\tif (!_name.equals(name)) {\n\t\t\tMessageBusUtil.unregisterMessageListener(\n\t\t\t\tDestinationNames.SEARCH_READER, _searchReaderMessageListener);\n\n\t\t\tMessageBusUtil.unregisterMessageListener(\n\t\t\t\tDestinationNames.SEARCH_WRITER, _searchWriterMessageListener);\n\t\t}\n\t}","id":9472,"modified_method":"public void unregister(String name) {\n\t\tif (!_name.equals(name)) {\n\t\t\t_registered = false;\n\t\t}\n\t}","commit_id":"440349458d30f45751b998d4f24b3f343073b059","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doReceive(Message message) throws Exception {\n\t\tSearchRequest searchRequest = (SearchRequest)message.getPayload();\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tlong companyId = searchRequest.getCompanyId();\n\t\tString id = searchRequest.getId();\n\t\tDocument doc = searchRequest.getDocument();\n\n\t\tif (command.equals(SearchRequest.COMMAND_ADD)) {\n\t\t\tLuceneSearchEngineUtil.addDocument(companyId, doc);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE)) {\n\t\t\tLuceneSearchEngineUtil.deleteDocument(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE_PORTLET_DOCS)) {\n\t\t\tLuceneSearchEngineUtil.deletePortletDocuments(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UNREGISTER)) {\n\t\t\tLuceneSearchEngineUtil.unregister(id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UPDATE)) {\n\t\t\tLuceneSearchEngineUtil.updateDocument(companyId, id, doc);\n\t\t}\n\t}","id":9473,"modified_method":"public void doReceive(Message message) throws Exception {\n\t\tObject payload = message.getPayload();\n\n\t\tif (!LuceneSearchEngineUtil.isRegistered() ||\n\t\t\t!(payload instanceof SearchRequest)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSearchRequest searchRequest = (SearchRequest)payload;\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tlong companyId = searchRequest.getCompanyId();\n\t\tString id = searchRequest.getId();\n\t\tDocument doc = searchRequest.getDocument();\n\n\t\tif (command.equals(SearchRequest.COMMAND_ADD)) {\n\t\t\tLuceneSearchEngineUtil.addDocument(companyId, doc);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE)) {\n\t\t\tLuceneSearchEngineUtil.deleteDocument(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE_PORTLET_DOCS)) {\n\t\t\tLuceneSearchEngineUtil.deletePortletDocuments(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UNREGISTER)) {\n\t\t\tLuceneSearchEngineUtil.unregister(id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UPDATE)) {\n\t\t\tLuceneSearchEngineUtil.updateDocument(companyId, id, doc);\n\t\t}\n\t}","commit_id":"440349458d30f45751b998d4f24b3f343073b059","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doReceive(Message message) throws Exception {\n\t\tSearchRequest searchRequest = (SearchRequest)message.getPayload();\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tif (command.equals(SearchRequest.COMMAND_INDEX_ONLY)) {\n\t\t\tdoCommandIndexOnly(message);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_SEARCH)) {\n\t\t\tdoCommandSearch(message, searchRequest);\n\t\t}\n\t}","id":9474,"modified_method":"public void doReceive(Message message) throws Exception {\n\t\tObject payload = message.getPayload();\n\n\t\tif (!SolrSearchEngineUtil.isRegistered() ||\n\t\t\t!(payload instanceof SearchRequest)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSearchRequest searchRequest = (SearchRequest)payload;\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tif (command.equals(SearchRequest.COMMAND_INDEX_ONLY)) {\n\t\t\tdoCommandIndexOnly(message);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_SEARCH)) {\n\t\t\tdoCommandSearch(message, searchRequest);\n\t\t}\n\t}","commit_id":"97df704cad5a66d4eec1957abc6904d173a3d6d5","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void unregister(String id) {\n\t\tif (!_name.equals(id)) {\n\t\t\tMessageBusUtil.unregisterMessageListener(\n\t\t\t\tDestinationNames.SEARCH_READER, _searchReaderMessageListener);\n\n\t\t\tMessageBusUtil.unregisterMessageListener(\n\t\t\t\tDestinationNames.SEARCH_WRITER, _searchWriterMessageListener);\n\t\t}\n\t}","id":9475,"modified_method":"public void unregister(String id) {\n\t\tif (!_name.equals(id)) {\n\t\t\t_registered = false;\n\t\t}\n\t}","commit_id":"97df704cad5a66d4eec1957abc6904d173a3d6d5","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void doReceive(Message message) throws Exception {\n\t\tSearchRequest searchRequest = (SearchRequest)message.getPayload();\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tlong companyId = searchRequest.getCompanyId();\n\t\tString id = searchRequest.getId();\n\t\tDocument doc = searchRequest.getDocument();\n\n\t\tif (command.equals(SearchRequest.COMMAND_ADD)) {\n\t\t\tSolrSearchEngineUtil.addDocument(companyId, doc);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE)) {\n\t\t\tSolrSearchEngineUtil.deleteDocument(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE_PORTLET_DOCS)) {\n\t\t\tSolrSearchEngineUtil.deletePortletDocuments(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UNREGISTER)) {\n\t\t\tSolrSearchEngineUtil.unregister(id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UPDATE)) {\n\t\t\tSolrSearchEngineUtil.updateDocument(companyId, id, doc);\n\t\t}\n\t}","id":9476,"modified_method":"public void doReceive(Message message) throws Exception {\n\t\tObject payload = message.getPayload();\n\n\t\tif (!SolrSearchEngineUtil.isRegistered() ||\n\t\t\t!(payload instanceof SearchRequest)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tSearchRequest searchRequest = (SearchRequest)payload;\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tlong companyId = searchRequest.getCompanyId();\n\t\tString id = searchRequest.getId();\n\t\tDocument doc = searchRequest.getDocument();\n\n\t\tif (command.equals(SearchRequest.COMMAND_ADD)) {\n\t\t\tSolrSearchEngineUtil.addDocument(companyId, doc);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE)) {\n\t\t\tSolrSearchEngineUtil.deleteDocument(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_DELETE_PORTLET_DOCS)) {\n\t\t\tSolrSearchEngineUtil.deletePortletDocuments(companyId, id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UNREGISTER)) {\n\t\t\tSolrSearchEngineUtil.unregister(id);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_UPDATE)) {\n\t\t\tSolrSearchEngineUtil.updateDocument(companyId, id, doc);\n\t\t}\n\t}","commit_id":"97df704cad5a66d4eec1957abc6904d173a3d6d5","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + state);\n\n\t\tif (stack.getStackDepth() < stackDepth) {\n\t\t\tstate = FormatState.NONE;\n\t\t\tstackDepth = 0;\n\t\t\targuments = null;\n\t\t}\n\t\tif (seen == ANEWARRAY && stack.getStackDepth() >= 2) {\n\t\t\tObject size = stack.getStackItem(0).getConstant();\n\t\t\tObject formatStr = stack.getStackItem(1).getConstant();\n\t\t\tif (size instanceof Integer && formatStr instanceof String) {\n\t\t\t\targuments = new OpcodeStack.Item[(Integer) size];\n\t\t\t\tthis.formatString = (String) formatStr;\n\t\t\t\tstate = FormatState.READY_FOR_FORMAT;\n\t\t\t\tstackDepth = stack.getStackDepth();\n\t\t\t}\n\t\t} else if (state == FormatState.READY_FOR_FORMAT && seen == DUP) {\n\t        state = FormatState.EXPECTING_ASSIGNMENT;\n        } else if (state == FormatState.EXPECTING_ASSIGNMENT && stack.getStackDepth() == stackDepth + 3 && seen == AASTORE) {\n\t\t\tObject pos = stack.getStackItem(1).getConstant();\n\t\t\tOpcodeStack.Item value = stack.getStackItem(0);\n\t\t\tif (pos instanceof Integer) {\n\t\t\t\tint index = (Integer) pos;\n\t\t\t\tif (index >= 0 && index < arguments.length) {\n\t\t\t\t\targuments[index] = value;\n\t\t\t\t\tstate = FormatState.READY_FOR_FORMAT;\n\t\t\t\t} else {\n\t                state = FormatState.NONE;\n                }\n\t\t\t} else {\n\t            state = FormatState.NONE;\n            }\n\t\t}  else if (state == FormatState.READY_FOR_FORMAT\n\t\t        && (seen == INVOKESPECIAL || seen == INVOKEVIRTUAL || seen == INVOKESTATIC || seen == INVOKEINTERFACE)\n\t\t        && stack.getStackDepth() == stackDepth) {\n\n\t\t\tString cl = getClassConstantOperand();\n\t\t\tString nm = getNameConstantOperand();\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tXMethod m = getXMethodOperand();\n\t\t\tif ((m == null || m.isVarArgs()) && sig.indexOf(\"Ljava/lang/String;[Ljava/lang/Object;)\") >= 0\n\t\t\t\t\t&& (\"java/util/Formatter\".equals(cl) && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| \"java/lang/String\".equals(cl) && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| \"java/io/PrintStream\".equals(cl) && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| \"java/io/PrintStream\".equals(cl)  && \"printf\".equals(nm)\n\t\t\t\t\t\t\t|| cl.endsWith(\"Writer\") && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| cl.endsWith(\"Writer\") && \"printf\".equals(nm))\n\t\t\t\t\t\t\t|| cl.endsWith(\"Logger\") && nm.endsWith(\"fmt\")) {\n\n\t\t\t\ttry {\n\t\t\t\t\tString[] signatures = new String[arguments.length];\n\t\t\t\t\tfor(int i = 0; i < signatures.length; i++)\n\t\t\t\t\t\tsignatures[i] = arguments[i].getSignature();\n\t\t\t\t\tFormatter.check(formatString, signatures);\n\t\t\t\t\t\n\t\t\t\t} catch (IllegalDateFormatConversionException e) {\n\t\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addType(e.getArgumentSignature())\n\t\t\t\t\t\t\t.addString(\"t\"+e.getConversion())\n\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t} catch (IllegalFormatConversionException e) {\n\t\t\t\t\n\t\t\t\t\tif (e.getConversion() == 'b')\n\t\t\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t\t.addType(e.getArgumentSignature())\n\t\t\t\t\t\t\t\t.addString(e.getConversion())\n\t\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t\t);\n\t\t\t\t\telse if (e.getArgumentSignature().charAt(0) == '[' && e.getConversion() == 's')\n                \tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addType(e.getArgumentSignature())\n\t\t\t\t\t\t\t.addString(Character.toString(e.getConversion()))\n\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t\telse bugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addType(e.getArgumentSignature())\n\t\t\t\t\t\t\t.addString(e.getConversion())\n\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                } catch (IllegalArgumentException e) {\n                \tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_ILLEGAL\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                } catch (MissingFormatArgumentException e) {\n\n                \tif (e.pos < 0) {\n\t                    bugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t.addString(e.formatSpecifier)\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                    } else {\n\t                    bugReporter.reportBug(\n\t                    \t\tnew BugInstance(this, \"VA_FORMAT_STRING_MISSING_ARGUMENT\", HIGH_PRIORITY)\n\t                    \t\t.addClassAndMethod(this)\n\t                    \t\t.addCalledMethod(this)\n\t                    \t\t.addString(formatString)\n\t                    \t\t.addString(e.formatSpecifier)\n\t                    \t\t.addInt(e.pos+1)\n\t                    \t\t.addInt(arguments.length).describe(IntAnnotation.INT_ACTUAL_ARGUMENTS)\n\t                    \t\t.addSourceLine(this)\n\t                    \t);\n                    }\n\n                } catch (ExtraFormatArgumentsException e) {\n                \tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addString(formatString)\n\t\t\t\t\t\t\t.addInt(e.used).describe(IntAnnotation.INT_EXPECTED_ARGUMENTS)\n\t\t\t\t\t\t\t.addInt(e.provided).describe(IntAnnotation.INT_ACTUAL_ARGUMENTS)\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                }\n\t\t\t}\n\n\t\t}\n\t}","id":9477,"modified_method":"@Override\n\tpublic void sawOpcode(int seen) {\n\t\t// System.out.println(getPC() + \" \" + OPCODE_NAMES[seen] + \" \" + state);\n\n\t\tif (stack.getStackDepth() < stackDepth) {\n\t\t\tstate = FormatState.NONE;\n\t\t\tstackDepth = 0;\n\t\t\targuments = null;\n\t\t}\n\t\tif (seen == ANEWARRAY && stack.getStackDepth() >= 2) {\n\t\t\tObject size = stack.getStackItem(0).getConstant();\n\t\t\tObject formatStr = stack.getStackItem(1).getConstant();\n\t\t\tif (size instanceof Integer && formatStr instanceof String) {\n\t\t\t\targuments = new OpcodeStack.Item[(Integer) size];\n\t\t\t\tthis.formatString = (String) formatStr;\n\t\t\t\tstate = FormatState.READY_FOR_FORMAT;\n\t\t\t\tstackDepth = stack.getStackDepth();\n\t\t\t}\n\t\t} else if (state == FormatState.READY_FOR_FORMAT && seen == DUP) {\n\t        state = FormatState.EXPECTING_ASSIGNMENT;\n        } else if (state == FormatState.EXPECTING_ASSIGNMENT && stack.getStackDepth() == stackDepth + 3 && seen == AASTORE) {\n\t\t\tObject pos = stack.getStackItem(1).getConstant();\n\t\t\tOpcodeStack.Item value = stack.getStackItem(0);\n\t\t\tif (pos instanceof Integer) {\n\t\t\t\tint index = (Integer) pos;\n\t\t\t\tif (index >= 0 && index < arguments.length) {\n\t\t\t\t\targuments[index] = value;\n\t\t\t\t\tstate = FormatState.READY_FOR_FORMAT;\n\t\t\t\t} else {\n\t                state = FormatState.NONE;\n                }\n\t\t\t} else {\n\t            state = FormatState.NONE;\n            }\n\t\t}  else if (state == FormatState.READY_FOR_FORMAT\n\t\t        && (seen == INVOKESPECIAL || seen == INVOKEVIRTUAL || seen == INVOKESTATIC || seen == INVOKEINTERFACE)\n\t\t        && stack.getStackDepth() == stackDepth) {\n\n\t\t\tString cl = getClassConstantOperand();\n\t\t\tString nm = getNameConstantOperand();\n\t\t\tString sig = getSigConstantOperand();\n\t\t\tXMethod m = getXMethodOperand();\n\t\t\tif ((m == null || m.isVarArgs()) && sig.indexOf(\"Ljava/lang/String;[Ljava/lang/Object;)\") >= 0\n\t\t\t\t\t&& (\"java/util/Formatter\".equals(cl) && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| \"java/lang/String\".equals(cl) && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| \"java/io/PrintStream\".equals(cl) && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| \"java/io/PrintStream\".equals(cl)  && \"printf\".equals(nm)\n\t\t\t\t\t\t\t|| cl.endsWith(\"Writer\") && \"format\".equals(nm)\n\t\t\t\t\t\t\t|| cl.endsWith(\"Writer\") && \"printf\".equals(nm))\n\t\t\t\t\t\t\t|| cl.endsWith(\"Logger\") && nm.endsWith(\"fmt\")) {\n\n\t\t\t\ttry {\n\t\t\t\t\tString[] signatures = new String[arguments.length];\n\t\t\t\t\tfor(int i = 0; i < signatures.length; i++)\n\t\t\t\t\t\tsignatures[i] = arguments[i].getSignature();\n\t\t\t\t\tFormatter.check(formatString, signatures);\n\t\t\t\t\t\n\t\t\t\t} catch (IllegalFormatConversionException e) {\n\t\t\t\t\n\t\t\t\t\tif (e.getConversion() == 'b')\n\t\t\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t\t.addType(e.getArgumentSignature()).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t\t\t\t\t\t\t\t.addString(e.getFormatSpecifier()).describe(StringAnnotation.FORMAT_SPECIFIER_ROLE)\n\t\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t\t);\n\t\t\t\t\telse if (e.getArgumentSignature().charAt(0) == '[' && e.getConversion() == 's')\n                \tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addType(e.getArgumentSignature()).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t\t\t\t\t\t\t.addString(e.getFormatSpecifier()).describe(StringAnnotation.FORMAT_SPECIFIER_ROLE)\n\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t\telse bugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_BAD_CONVERSION\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addType(e.getArgumentSignature()).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t\t\t\t\t\t\t.addString(e.getFormatSpecifier()).describe(StringAnnotation.FORMAT_SPECIFIER_ROLE)\n\t\t\t\t\t\t\t.addValueSource(arguments[e.getArgIndex()], getMethod(), getPC())\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                } catch (IllegalArgumentException e) {\n                \tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_ILLEGAL\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                } catch (MissingFormatArgumentException e) {\n\n                \tif (e.pos < 0) {\n\t                    bugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT\", HIGH_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t\t\t\t\t\t\t.addString(e.formatSpecifier).describe(StringAnnotation.FORMAT_SPECIFIER_ROLE)\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                    } else {\n\t                    bugReporter.reportBug(\n\t                    \t\tnew BugInstance(this, \"VA_FORMAT_STRING_MISSING_ARGUMENT\", HIGH_PRIORITY)\n\t                    \t\t.addClassAndMethod(this)\n\t                    \t\t.addCalledMethod(this)\n\t                    \t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t                    \t\t.addString(e.formatSpecifier).describe(StringAnnotation.FORMAT_SPECIFIER_ROLE)\n\t                    \t\t.addInt(e.pos+1).describe(IntAnnotation.INT_EXPECTED_ARGUMENTS)\n\t                    \t\t.addInt(arguments.length).describe(IntAnnotation.INT_ACTUAL_ARGUMENTS)\n\t                    \t\t.addSourceLine(this)\n\t                    \t);\n                    }\n\n                } catch (ExtraFormatArgumentsException e) {\n                \tbugReporter.reportBug(\n\t\t\t\t\t\t\tnew BugInstance(this, \"VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addString(formatString).describe(StringAnnotation.FORMAT_STRING_ROLE)\n\t\t\t\t\t\t\t.addInt(e.used).describe(IntAnnotation.INT_EXPECTED_ARGUMENTS)\n\t\t\t\t\t\t\t.addInt(e.provided).describe(IntAnnotation.INT_ACTUAL_ARGUMENTS)\n\t\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n                }\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"88d0e47f4d15e314b9f99ad62e09df613de4a8eb","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tif (isSynthetic(method) || !prescreen(classContext, method))\n\t\t\treturn;\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\t\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t\tSet<ValueNumber> paramValueNumberSet = null;\n\t\t\n\t\tValueNumberDataflow vnaDataflow = null;\n\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t+ methodGen.getName();\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tSet<SourceLineAnnotation> haveInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveCast = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleCast = new HashSet<SourceLineAnnotation>();\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\tif (ins instanceof CHECKCAST) {\n\t\t\t\tif (!haveCast.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleCast.add(sourceLineAnnotation);\n\t\t\t} else {\n\t\t\t\tif (!haveInstanceOf.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleInstanceOf.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n        BitSet linesMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n        LineNumberTable lineNumberTable = methodGen.getLineNumberTable(methodGen.getConstantPool());\n        \n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tint pc = handle.getPosition();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\t\t\tif (handle.getNext() == null) continue;\n\t\t\tInstruction nextIns = handle.getNext().getInstruction();\n\n\t\t\tboolean isCast = ins instanceof CHECKCAST;\n\t\t\tString kind = isCast ? \"checkedCast\" : \"instanceof\";\n\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\tpc).size();\n\t\t\tboolean split = occurrences > 1;\n            if (lineNumberTable != null) {\n                int line = lineNumberTable.getSourceLine(handle.getPosition());\n                if (linesMentionedMultipleTimes.get(line)) split=true;\n            }\n\n\t\t\tIsNullValueFrame nullFrame = isNullDataflow.getFactAtLocation(location);\n            if (!nullFrame.isValid()) continue;\n\t\t\tIsNullValue operandNullness = nullFrame.getTopValue();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(kind + \" at pc: \" + pc + \" in \" + methodName);\n\t\t\t\tSystem.out.println(\" occurrences: \" + occurrences);\n\t\t\t\tSystem.out.println(\"XXX: \" + operandNullness);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (split && !isCast) {\n\t\t\t\t// don't report this case; it might be infeasible due to inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tType operandType = frame.getTopValue();\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean operandTypeIsExact = frame.isExact(frame.getStackLocation(0));\n\t\t\tType castType = ((TypedInstruction) ins).getType(cpg);\n\n\t\t\tif (!(castType instanceof ReferenceType)) {\n\t\t\t\t// This shouldn't happen either\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castSig = castType.getSignature();\n\t\t\t\n\t\t\tif (operandType.equals(NullType.instance()) || operandNullness.isDefinitelyNull()) {\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tString castName = castSig.substring(1, castSig.length() - 1)\n\t\t\t\t.replace('/', '.');\n\t\t\t\tif (!isCast) accumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_NULL_INSTANCEOF\", split ? LOW_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addClass(castName), sourceLineAnnotation);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\n\t\t\tif (refType.equals(castType)) {\n\t\t\t\t// System.out.println(\"self-cast to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString refSig = refType.getSignature();\n\t\t\tString castSig2 = castSig;\n\t\t\tString refSig2 = refSig;\n\t\t\twhile (castSig2.charAt(0) == '[' && refSig2.charAt(0) == '[') {\n\t\t\t\tcastSig2 = castSig2.substring(1);\n\t\t\t\trefSig2 = refSig2.substring(1);\n\t\t\t}\n\n\t\t\t\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\n\t\t\tif (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {\n\t\t\t\tif ( castSig2.charAt(0) == '[' && (refSig2.equals(\"Ljava/io/Serializable;\") \n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Object;\")\n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Cloneable;\"))) continue;\n\t\t\t\tif ( refSig2.charAt(0) == '[' && (castSig2.equals(\"Ljava/io/Serializable;\") \n\t\t\t\t\t\t|| castSig2.equals(\"Ljava/lang/Object;\")\n\t\t\t\t\t\t|| castSig2.equals(\"Ljava/lang/Cloneable;\"))) continue;\n                int priority = HIGH_PRIORITY;\n                if (split && (castSig2.endsWith(\"Error;\") || castSig2.endsWith(\"Exception;\")))\n                    priority = LOW_PRIORITY;\n\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\tnew BugInstance(this,\n\t\t\t\t\t\t\"BC_IMPOSSIBLE_CAST\",  priority)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t.addType(castSig)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (refSig2.equals(\"Ljava/lang/Object;\")  &!operandTypeIsExact) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (false && isCast && haveMultipleCast.contains(sourceLineAnnotation)\n\t\t\t\t\t|| !isCast\n\t\t\t\t\t&& haveMultipleInstanceOf.contains(sourceLineAnnotation)) {\n\t\t\t\t// skip; might be due to JSR inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castName = castSig2.substring(1, castSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\t\t\tString refName = refSig2.substring(1, refSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\n\t\t\tif (vnaDataflow == null)\n\t\t\t\tvnaDataflow = classContext\n\t\t\t\t.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame vFrame = vnaDataflow.getFactAtLocation(location);\n\t\t\tif (paramValueNumberSet == null) \n\t\t\t\tparamValueNumberSet = getParameterValueNumbers(classContext, method, cfg);\n\t\t\tboolean isParameter = paramValueNumberSet.contains(vFrame\n\t\t\t\t\t.getTopValue());\n\t\t\ttry {\n\t\t\t\tJavaClass castJavaClass = Repository.lookupClass(castName);\n\t\t\t\tJavaClass refJavaClass = Repository.lookupClass(refName);\n\t\t\t\tboolean upcast = Repository.instanceOf(refJavaClass,\n\t\t\t\t\t\tcastJavaClass);\n\t\t\t\tif (upcast) {\n\t\t\t\t\tif (!isCast)\n\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"BC_VACUOUS_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t\t\t.addType(castSig)\n\t\t\t\t\t\t\t\t,sourceLineAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tboolean downcast = Repository.instanceOf(castJavaClass,\n\t\t\t\t\t\t\trefJavaClass);\n\t\t\t\t\t\n\t\t\t\t\tif (refName.equals(\"java.lang.Object\")  &!operandTypeIsExact) continue;\n\t\t\t\t\tdouble rank = 0.0;\n\t\t\t\t\tboolean castToConcreteCollection = concreteCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& abstractCollectionClasses.contains(refName);\n\t\t\t\t\tboolean castToAbstractCollection = \n\t\t\t\t\t\t\tabstractCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName);\n\t\n\t\t\t\t\tif (!operandTypeIsExact) {\n\t\t\t\t\t\trank = DeepSubtypeAnalysis.deepInstanceOf(refJavaClass,\n\t\t\t\t\t\t\t\tcastJavaClass);\n\t\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& rank > 0.6)\n\t\t\t\t\t\t  rank = (rank + 0.6) /2;\n\t\t\t\t\t\telse if (castToAbstractCollection\n\t\t\t\t\t\t\t&& rank > 0.3)\n\t\t\t\t\t\t  rank = (rank + 0.3) /2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif (false)\n\t\t\t\t\t\tSystem.out.println(\"Rank:\\t\" + rank + \"\\t\" + refName\n\t\t\t\t\t\t\t\t+ \"\\t\" + castName);\n\t\t\t\t\tboolean completeInformation =  (!castJavaClass.isInterface() && !refJavaClass\n\t\t\t\t\t\t\t.isInterface())\n\t\t\t\t\t\t\t|| refJavaClass.isFinal()\n\t\t\t\t\t\t\t|| castJavaClass.isFinal();\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"cast from \" + refName + \" to \"\n\t\t\t\t\t\t\t\t+ castName);\n\t\t\t\t\t\tSystem.out.println(\"  is downcast: \" + downcast);\n\t\t\t\t\t\tSystem.out.println(\"  operand type is exact: \" + operandTypeIsExact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"  complete information: \"\n\t\t\t\t\t\t\t\t+ completeInformation);\n\t\t\t\t\t\tSystem.out.println(\"  isParameter: \"\n\t\t\t\t\t\t\t\t+ vFrame.getTopValue());\n\t\t\t\t\t\tSystem.out.println(\"  score: \" + rank);\n\t\t\t\t\t}\n\t\t\t\t\tif (!downcast && completeInformation || operandTypeIsExact)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\tisCast ? \"BC_IMPOSSIBLE_CAST\"\n\t\t\t\t\t\t\t\t\t\t: \"BC_IMPOSSIBLE_INSTANCEOF\",\n\t\t\t\t\t\t\t\tisCast ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t\t\t.addType(castSig)\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\t\telse if (isCast && rank < 0.9) {\n\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tif (rank > 0.75)\n\t\t\t\t\t\t\tpriority += 2;\n\t\t\t\t\t\telse if (rank > 0.5)\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\telse if (rank > 0.25)\n\t\t\t\t\t\t\tpriority += 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpriority--;\n\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority a: \" + priority);\n\t\t\t\t\t\tif (methodGen.getClassName().startsWith(refName)\n\t\t\t\t\t\t\t\t|| methodGen.getClassName().startsWith(castName))\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority b: \" + priority);\n\t\t\t\t\t\tif (castJavaClass.isInterface() && !castToAbstractCollection)\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority c: \" + priority);\n\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName))\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority d: \" + priority);\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY \n\t\t\t\t\t\t\t\t&& !castToAbstractCollection\n\t\t\t\t\t\t\t\t&& !castToConcreteCollection\n\t\t\t\t\t\t\t\t&& (refJavaClass.isInterface() || refJavaClass\n\t\t\t\t\t\t\t\t\t\t.isAbstract()))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority e: \" + priority);\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" ref name: \" + refName);\n\t\t\t\t\t\tif (methodGen.getName().equals(\"compareTo\"))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\telse if (methodGen.isPublic() && isParameter)\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority h: \" + priority);\n\t\t\t\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY) {\n\t\t\t\t\t\t\tString bug = \"BC_UNCONFIRMED_CAST\";\n\t\t\t\t\t\t\tif (castToConcreteCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_CONCRETE_COLLECTION\";\n\t\t\t\t\t\t\telse if (castToAbstractCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_ABSTRACT_COLLECTION\";\n\n\t\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addType(refSig)\n\t\t\t\t\t\t\t\t\t.addType(castSig),\n\t\t\t\t\t\t\t\t\tsourceLineAnnotation\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","id":9478,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tif (isSynthetic(method) || !prescreen(classContext, method))\n\t\t\treturn;\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\t\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tIsNullValueDataflow isNullDataflow = classContext.getIsNullValueDataflow(method);\n\t\tSet<ValueNumber> paramValueNumberSet = null;\n\t\t\n\t\tValueNumberDataflow vnaDataflow = null;\n\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) return;\n\t\tString methodName = methodGen.getClassName() + \".\"\n\t\t\t\t+ methodGen.getName();\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"Checking \" + methodName);\n\t\t}\n\n\t\tSet<SourceLineAnnotation> haveInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveCast = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleInstanceOf = new HashSet<SourceLineAnnotation>();\n\t\tSet<SourceLineAnnotation> haveMultipleCast = new HashSet<SourceLineAnnotation>();\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\tif (ins instanceof CHECKCAST) {\n\t\t\t\tif (!haveCast.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleCast.add(sourceLineAnnotation);\n\t\t\t} else {\n\t\t\t\tif (!haveInstanceOf.add(sourceLineAnnotation))\n\t\t\t\t\thaveMultipleInstanceOf.add(sourceLineAnnotation);\n\t\t\t}\n\t\t}\n        BitSet linesMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n        LineNumberTable lineNumberTable = methodGen.getLineNumberTable(methodGen.getConstantPool());\n        \n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tint pc = handle.getPosition();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\n\t\t\tif (!(ins instanceof CHECKCAST) && !(ins instanceof INSTANCEOF))\n\t\t\t\tcontinue;\n\t\t\tif (handle.getNext() == null) continue;\n\t\t\tInstruction nextIns = handle.getNext().getInstruction();\n\n\t\t\tboolean isCast = ins instanceof CHECKCAST;\n\t\t\tString kind = isCast ? \"checkedCast\" : \"instanceof\";\n\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\tpc).size();\n\t\t\tboolean split = occurrences > 1;\n            if (lineNumberTable != null) {\n                int line = lineNumberTable.getSourceLine(handle.getPosition());\n                if (linesMentionedMultipleTimes.get(line)) split=true;\n            }\n\n\t\t\tIsNullValueFrame nullFrame = isNullDataflow.getFactAtLocation(location);\n            if (!nullFrame.isValid()) continue;\n\t\t\tIsNullValue operandNullness = nullFrame.getTopValue();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(kind + \" at pc: \" + pc + \" in \" + methodName);\n\t\t\t\tSystem.out.println(\" occurrences: \" + occurrences);\n\t\t\t\tSystem.out.println(\"XXX: \" + operandNullness);\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (split && !isCast) {\n\t\t\t\t// don't report this case; it might be infeasible due to inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tType operandType = frame.getTopValue();\n\t\t\tif (operandType.equals(TopType.instance())) {\n\t\t\t\t// unreachable\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean operandTypeIsExact = frame.isExact(frame.getStackLocation(0));\n\t\t\tType castType = ((TypedInstruction) ins).getType(cpg);\n\n\t\t\tif (!(castType instanceof ReferenceType)) {\n\t\t\t\t// This shouldn't happen either\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castSig = castType.getSignature();\n\t\t\t\n\t\t\tif (operandType.equals(NullType.instance()) || operandNullness.isDefinitelyNull()) {\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tString castName = castSig.substring(1, castSig.length() - 1)\n\t\t\t\t.replace('/', '.');\n\t\t\t\tif (!isCast) accumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_NULL_INSTANCEOF\", split ? LOW_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addClass(castName), sourceLineAnnotation);\n\t\t\t\tcontinue;\n\n\t\t\t}\n\t\t\tif (!(operandType instanceof ReferenceType)) {\n\t\t\t\t// Shouldn't happen - illegal bytecode\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tReferenceType refType = (ReferenceType) operandType;\n\n\t\t\n\t\t\tif (refType.equals(castType)) {\n\t\t\t\t// System.out.println(\"self-cast to \" + castType.getSignature());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tString refSig = refType.getSignature();\n\t\t\tString castSig2 = castSig;\n\t\t\tString refSig2 = refSig;\n\t\t\twhile (castSig2.charAt(0) == '[' && refSig2.charAt(0) == '[') {\n\t\t\t\tcastSig2 = castSig2.substring(1);\n\t\t\t\trefSig2 = refSig2.substring(1);\n\t\t\t}\n\n\t\t\t\n\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\n\t\t\tif (refSig2.charAt(0) != 'L' || castSig2.charAt(0) != 'L') {\n\t\t\t\tif ( castSig2.charAt(0) == '[' && (refSig2.equals(\"Ljava/io/Serializable;\") \n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Object;\")\n\t\t\t\t\t\t|| refSig2.equals(\"Ljava/lang/Cloneable;\"))) continue;\n\t\t\t\tif ( refSig2.charAt(0) == '[' && (castSig2.equals(\"Ljava/io/Serializable;\") \n\t\t\t\t\t\t|| castSig2.equals(\"Ljava/lang/Object;\")\n\t\t\t\t\t\t|| castSig2.equals(\"Ljava/lang/Cloneable;\"))) continue;\n                int priority = HIGH_PRIORITY;\n                if (split && (castSig2.endsWith(\"Error;\") || castSig2.endsWith(\"Exception;\")))\n                    priority = LOW_PRIORITY;\n\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\tnew BugInstance(this,\n\t\t\t\t\t\t\"BC_IMPOSSIBLE_CAST\",  priority)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addType(refSig).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t.addType(castSig).describe(TypeAnnotation.EXPECTED_ROLE)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (refSig2.equals(\"Ljava/lang/Object;\")  &!operandTypeIsExact) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (false && isCast && haveMultipleCast.contains(sourceLineAnnotation)\n\t\t\t\t\t|| !isCast\n\t\t\t\t\t&& haveMultipleInstanceOf.contains(sourceLineAnnotation)) {\n\t\t\t\t// skip; might be due to JSR inlining\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString castName = castSig2.substring(1, castSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\t\t\tString refName = refSig2.substring(1, refSig2.length() - 1)\n\t\t\t\t\t.replace('/', '.');\n\n\t\t\tif (vnaDataflow == null)\n\t\t\t\tvnaDataflow = classContext\n\t\t\t\t.getValueNumberDataflow(method);\n\t\t\tValueNumberFrame vFrame = vnaDataflow.getFactAtLocation(location);\n\t\t\tif (paramValueNumberSet == null) \n\t\t\t\tparamValueNumberSet = getParameterValueNumbers(classContext, method, cfg);\n\t\t\tboolean isParameter = paramValueNumberSet.contains(vFrame\n\t\t\t\t\t.getTopValue());\n\t\t\ttry {\n\t\t\t\tJavaClass castJavaClass = Repository.lookupClass(castName);\n\t\t\t\tJavaClass refJavaClass = Repository.lookupClass(refName);\n\t\t\t\tboolean upcast = Repository.instanceOf(refJavaClass,\n\t\t\t\t\t\tcastJavaClass);\n\t\t\t\tif (upcast) {\n\t\t\t\t\tif (!isCast)\n\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"BC_VACUOUS_INSTANCEOF\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addType(refSig).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t\t.addType(castSig).describe(TypeAnnotation.EXPECTED_ROLE)\n\t\t\t\t\t\t\t\t,sourceLineAnnotation);\n\t\t\t\t} else {\n\t\t\t\t\tboolean downcast = Repository.instanceOf(castJavaClass,\n\t\t\t\t\t\t\trefJavaClass);\n\t\t\t\t\t\n\t\t\t\t\tif (refName.equals(\"java.lang.Object\")  &!operandTypeIsExact) continue;\n\t\t\t\t\tdouble rank = 0.0;\n\t\t\t\t\tboolean castToConcreteCollection = concreteCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& abstractCollectionClasses.contains(refName);\n\t\t\t\t\tboolean castToAbstractCollection = \n\t\t\t\t\t\t\tabstractCollectionClasses.contains(castName)\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName);\n\t\n\t\t\t\t\tif (!operandTypeIsExact) {\n\t\t\t\t\t\trank = DeepSubtypeAnalysis.deepInstanceOf(refJavaClass,\n\t\t\t\t\t\t\t\tcastJavaClass);\n\t\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& rank > 0.6)\n\t\t\t\t\t\t  rank = (rank + 0.6) /2;\n\t\t\t\t\t\telse if (castToAbstractCollection\n\t\t\t\t\t\t\t&& rank > 0.3)\n\t\t\t\t\t\t  rank = (rank + 0.3) /2;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tif (false)\n\t\t\t\t\t\tSystem.out.println(\"Rank:\\t\" + rank + \"\\t\" + refName\n\t\t\t\t\t\t\t\t+ \"\\t\" + castName);\n\t\t\t\t\tboolean completeInformation =  (!castJavaClass.isInterface() && !refJavaClass\n\t\t\t\t\t\t\t.isInterface())\n\t\t\t\t\t\t\t|| refJavaClass.isFinal()\n\t\t\t\t\t\t\t|| castJavaClass.isFinal();\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(\"cast from \" + refName + \" to \"\n\t\t\t\t\t\t\t\t+ castName);\n\t\t\t\t\t\tSystem.out.println(\"  is downcast: \" + downcast);\n\t\t\t\t\t\tSystem.out.println(\"  operand type is exact: \" + operandTypeIsExact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"  complete information: \"\n\t\t\t\t\t\t\t\t+ completeInformation);\n\t\t\t\t\t\tSystem.out.println(\"  isParameter: \"\n\t\t\t\t\t\t\t\t+ vFrame.getTopValue());\n\t\t\t\t\t\tSystem.out.println(\"  score: \" + rank);\n\t\t\t\t\t}\n\t\t\t\t\tif (!downcast && completeInformation || operandTypeIsExact)\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\t\tisCast ? \"BC_IMPOSSIBLE_CAST\"\n\t\t\t\t\t\t\t\t\t\t: \"BC_IMPOSSIBLE_INSTANCEOF\",\n\t\t\t\t\t\t\t\tisCast ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t.addType(refSig).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t\t.addType(castSig).describe(TypeAnnotation.EXPECTED_ROLE)\n\t\t\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t\t\telse if (isCast && rank < 0.9) {\n\n\t\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tif (rank > 0.75)\n\t\t\t\t\t\t\tpriority += 2;\n\t\t\t\t\t\telse if (rank > 0.5)\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\telse if (rank > 0.25)\n\t\t\t\t\t\t\tpriority += 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpriority--;\n\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority a: \" + priority);\n\t\t\t\t\t\tif (methodGen.getClassName().startsWith(refName)\n\t\t\t\t\t\t\t\t|| methodGen.getClassName().startsWith(castName))\n\t\t\t\t\t\t\tpriority += 1;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority b: \" + priority);\n\t\t\t\t\t\tif (castJavaClass.isInterface() && !castToAbstractCollection)\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority c: \" + priority);\n\t\t\t\t\t\tif (castToConcreteCollection\n\t\t\t\t\t\t\t&& veryAbstractCollectionClasses.contains(refName))\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority d: \" + priority);\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY \n\t\t\t\t\t\t\t\t&& !castToAbstractCollection\n\t\t\t\t\t\t\t\t&& !castToConcreteCollection\n\t\t\t\t\t\t\t\t&& (refJavaClass.isInterface() || refJavaClass\n\t\t\t\t\t\t\t\t\t\t.isAbstract()))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority e: \" + priority);\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" ref name: \" + refName);\n\t\t\t\t\t\tif (methodGen.getName().equals(\"compareTo\"))\n\t\t\t\t\t\t\tpriority++;\n\t\t\t\t\t\telse if (methodGen.isPublic() && isParameter)\n\t\t\t\t\t\t\tpriority--;\n\t\t\t\t\t\tif (DEBUG)\n\t\t\t\t\t\t\tSystem.out.println(\" priority h: \" + priority);\n\t\t\t\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\t\tif (priority <= LOW_PRIORITY) {\n\t\t\t\t\t\t\tString bug = \"BC_UNCONFIRMED_CAST\";\n\t\t\t\t\t\t\tif (castToConcreteCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_CONCRETE_COLLECTION\";\n\t\t\t\t\t\t\telse if (castToAbstractCollection)\n\t\t\t\t\t\t\t\tbug = \"BC_BAD_CAST_TO_ABSTRACT_COLLECTION\";\n\n\t\t\t\t\t\t\taccumulator.accumulateBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t\t\t\t.addType(refSig).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t\t\t.addType(castSig).describe(TypeAnnotation.EXPECTED_ROLE),\n\t\t\t\t\t\t\t\t\tsourceLineAnnotation\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t}\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"421858fe0feb6eca40c376cf5b5a0a0df95cc059","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n         public void sawOpcode( int seen) {\n\t\t// System.out.println(\"State:\" + state);\n\t\tif (seen == GOTO && getBranchOffset() == 4) {\n\t\t\tstate = SEEN_GOTO;\n\t\t} else\n\t\t\tswitch (state) {\n\t\t\tcase SEEN_NOTHING:\n\t\t\t\tif ((seen == ICONST_1))\n\t\t\t\t\tstate = SEEN_ICONST_1;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ICONST_1:\n\t\t\t\tif (seen == ANEWARRAY && primitiveArray.matcher(getClassConstantOperand()).matches()) {\n\t\t\t\t\t// System.out.println(\"Allocation of array of type \" + getClassConstantOperand());\n\t\t\t\t\tprimitiveArraySig = getClassConstantOperand();\n\t\t\t\t\tstate = SEEN_ANEWARRAY; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ANEWARRAY:\n\t\t\t\tif (seen == DUP)\n\t\t\t\t\tstate = SEEN_DUP;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_DUP:\n\t\t\t\tif (seen == ICONST_0)\n\t\t\t\t\tstate = SEEN_ICONST_0;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_ICONST_0:\n\t\t\t\tif (((seen >= ALOAD_0) && (seen < ALOAD_3)) || (seen == ALOAD))\n\t\t\t\t\tstate = SEEN_ALOAD;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ALOAD:\n\t\t\t\tif (seen == AASTORE)\n\t\t\t\t\tstate = SEEN_AASTORE;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_AASTORE:\n\t\t\t\tif (seen == INVOKESTATIC || seen == INVOKEINTERFACE\n\t\t\t\t\t\t|| seen == INVOKESPECIAL || seen == INVOKEVIRTUAL) {\n//\t\t\t\t\tSystem.out.println(getClassConstantOperand());\n//\t\t\t\t\tSystem.out.println(getNameConstantOperand());\n//\t\t\t\t\tSystem.out.println(getSigConstantOperand());\n\t\t\t\t\tif (getSigConstantOperand().indexOf(\"Ljava/lang/Object;)\") == -1) break;\n\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\tif (getNameConstantOperand().equals(\"asList\") \n\t\t\t\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Arrays\"))\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\tbugReporter.reportBug( new BugInstance( this, \"VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG\", priority)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addType(primitiveArraySig)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addSourceLine(this));\n\t\t\t\t}\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_GOTO:\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"State \" + state\n\t\t\t\t\t\t+ \" not expected\");\n\n\t\t\t}\n\t}","id":9479,"modified_method":"@Override\n         public void sawOpcode( int seen) {\n\t\t// System.out.println(\"State:\" + state);\n\t\tif (seen == GOTO && getBranchOffset() == 4) {\n\t\t\tstate = SEEN_GOTO;\n\t\t} else\n\t\t\tswitch (state) {\n\t\t\tcase SEEN_NOTHING:\n\t\t\t\tif ((seen == ICONST_1))\n\t\t\t\t\tstate = SEEN_ICONST_1;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ICONST_1:\n\t\t\t\tif (seen == ANEWARRAY && primitiveArray.matcher(getClassConstantOperand()).matches()) {\n\t\t\t\t\t// System.out.println(\"Allocation of array of type \" + getClassConstantOperand());\n\t\t\t\t\tprimitiveArraySig = getClassConstantOperand();\n\t\t\t\t\tstate = SEEN_ANEWARRAY; \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ANEWARRAY:\n\t\t\t\tif (seen == DUP)\n\t\t\t\t\tstate = SEEN_DUP;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_DUP:\n\t\t\t\tif (seen == ICONST_0)\n\t\t\t\t\tstate = SEEN_ICONST_0;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tcase SEEN_ICONST_0:\n\t\t\t\tif (((seen >= ALOAD_0) && (seen < ALOAD_3)) || (seen == ALOAD))\n\t\t\t\t\tstate = SEEN_ALOAD;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_ALOAD:\n\t\t\t\tif (seen == AASTORE)\n\t\t\t\t\tstate = SEEN_AASTORE;\n\t\t\t\telse\n\t\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_AASTORE:\n\t\t\t\tif (seen == INVOKESTATIC || seen == INVOKEINTERFACE\n\t\t\t\t\t\t|| seen == INVOKESPECIAL || seen == INVOKEVIRTUAL) {\n//\t\t\t\t\tSystem.out.println(getClassConstantOperand());\n//\t\t\t\t\tSystem.out.println(getNameConstantOperand());\n//\t\t\t\t\tSystem.out.println(getSigConstantOperand());\n\t\t\t\t\tif (getSigConstantOperand().indexOf(\"Ljava/lang/Object;)\") == -1) break;\n\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\tif (getNameConstantOperand().equals(\"asList\") \n\t\t\t\t\t\t\t&& getClassConstantOperand().equals(\"java/util/Arrays\"))\n\t\t\t\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t\t\tbugReporter.reportBug( new BugInstance( this, \"VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG\", priority)\n\t\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t\t.addType(primitiveArraySig).describe(TypeAnnotation.FOUND_ROLE)\n\t\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t\t.addSourceLine(this));\n\t\t\t\t}\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\n\t\t\tcase SEEN_GOTO:\n\t\t\t\tstate = SEEN_NOTHING;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"State \" + state\n\t\t\t\t\t\t+ \" not expected\");\n\n\t\t\t}\n\t}","commit_id":"421858fe0feb6eca40c376cf5b5a0a0df95cc059","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void setCachedValue(Object cachedValue) {\n\n    }","id":9480,"modified_method":"@Override\n    public boolean casCachedValue(Object expectedValue, Object newValue) {\n        return true;\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Object getCachedValue() {\n        return Record.NOT_CACHED;\n    }","id":9481,"modified_method":"@Override\n    public Object getCachedValueUnsafe() {\n        return Record.NOT_CACHED;\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setValue(Data o) {\n        cachedValue = null;\n        super.setValue(o);\n    }","id":9482,"modified_method":"@Override\n    public void setValue(Data o) {\n        super.setValue(o);\n        cachedValue = null;\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setCachedValue(Object cachedValue) {\n        this.cachedValue = cachedValue;\n    }","id":9483,"modified_method":"@Override\n    public boolean casCachedValue(Object expectedValue, Object newValue) {\n        return CACHED_VALUE.compareAndSet(this, expectedValue, newValue);\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Object getCachedValue() {\n        return cachedValue;\n    }","id":9484,"modified_method":"@Override\n    public Object getCachedValueUnsafe() {\n        return cachedValue;\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Object getCachedValue() {\n        return cachedValue;\n    }","id":9485,"modified_method":"@Override\n    public Object getCachedValueUnsafe() {\n        return cachedValue;\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setCachedValue(Object cachedValue) {\n        this.cachedValue = cachedValue;\n    }","id":9486,"modified_method":"@Override\n    public boolean casCachedValue(Object expectedValue, Object newValue) {\n        return CACHED_VALUE.compareAndSet(this, expectedValue, newValue);\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void setValue(Data o) {\n        cachedValue = null;\n        super.setValue(o);\n    }","id":9487,"modified_method":"@Override\n    public void setValue(Data o) {\n        super.setValue(o);\n        cachedValue = null;\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static Object getValueOrCachedValue(Record record, SerializationService serializationService) {\n        Object value = record.getCachedValue();\n        if (value == NOT_CACHED) {\n            value = record.getValue();\n        } else if (value == null) {\n            value = record.getValue();\n            if (shouldCache(record, value)) {\n                value = serializationService.toObject(value);\n                record.setCachedValue(value);\n            }\n        }\n        return value;\n    }","id":9488,"modified_method":"/**\n     * Return cached value where appropriate, otherwise return the actual value.\n     * Value caching makes sense when:\n     * <ul>\n     *     <li>Portable serialization is not used<\/li>\n     *     <li>OBJECT InMemoryFormat is not used<\/li>\n     * <\/ul>\n     *\n     * If Record does not contain cached value and is found appropriate (see above) then new cache value is created\n     * by de-serializing the {@link Record#getValue()}\n     *\n     * The newly de-deserialized value may not be stored into the Record cache when the record has been modified\n     * while the method was running.\n     *\n     * WARNING: This method may temporarily set an arbitrary object into the Record cache - this object acts as mutex.\n     * The mutex should never be returned to the outside world. Use {@link #getCachedValue(Record)} instead of raw\n     * {@link Record#getCachedValueUnsafe()} to protect from accidental mutex exposure to the user-code.\n     *\n     * @param record\n     * @param serializationService\n     * @return\n     */\n    public static Object getValueOrCachedValue(Record record, SerializationService serializationService) {\n        Object cachedValue = record.getCachedValueUnsafe();\n        if (cachedValue == NOT_CACHED) {\n            //record does not support caching at all\n            return record.getValue();\n        }\n        for (;;) {\n            if (cachedValue == null) {\n                Object valueBeforeCas = record.getValue();\n                if (!shouldCache(valueBeforeCas)) {\n                    //it's either a null or value which we do not want to cache. let's just return it.\n                    return valueBeforeCas;\n                }\n                Object fromCache = tryStoreIntoCache(record, valueBeforeCas, serializationService);\n                if (fromCache != null) {\n                    return fromCache;\n                }\n            } else if (cachedValue instanceof Thread) {\n                //the cachedValue is either locked by another thread or it contains a wrapped thread\n                cachedValue = ThreadWrapper.unwrapOrNull(cachedValue);\n                if (cachedValue != null) {\n                    //exceptional case: the cachedValue is not locked, it just contains an instance of Thread.\n                    //this can happen when user put an instance of Thread into a map\n                    //(=it should never happen, but never say never...)\n                    return cachedValue;\n                }\n                //it looks like some other thread actually locked the cachedValue. let's give it another try (iteration)\n            } else {\n                //it's not the 'in-progress' marker/lock && it's not a null -> it has to be the actual cachedValue\n                return cachedValue;\n            }\n            Thread.yield();\n            cachedValue = record.getCachedValueUnsafe();\n        }\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private static boolean shouldCache(Record record, Object value) {\n        boolean isCachableRecordType = record instanceof CachedDataRecordWithStats || record instanceof CachedDataRecord;\n        if (!isCachableRecordType) {\n            return false;\n        }\n        return value instanceof Data && !((Data) value).isPortable();\n    }","id":9489,"modified_method":"static boolean shouldCache(Object value) {\n        return value instanceof Data && !((Data) value).isPortable();\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void getValueOrCachedValue_whenRecordIsNotCachable_thenDoNotCache() {\n        String objectPayload = \"foo\";\n        Data dataPayload = serializationService.toData(objectPayload);\n        Record record = mock(Record.class);\n        when(record.getValue()).thenReturn(dataPayload);\n\n        Records.getValueOrCachedValue(record, serializationService);\n        verify(record, never()).setCachedValue(objectPayload);\n    }","id":9490,"modified_method":"@Test\n    public void getValueOrCachedValue_whenRecordIsNotCachable_thenDoNotCache() {\n        String objectPayload = \"foo\";\n        Data dataPayload = serializationService.toData(objectPayload);\n        Record record = new DataRecord(dataPayload);\n        Object value = Records.getValueOrCachedValue(record, null);\n        assertSame(dataPayload, value);\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void getValueOrCachedValue_whenRecordIsCachedDataRecordWithStats_thenCache() {\n        String objectPayload = \"foo\";\n        Data dataPayload = serializationService.toData(objectPayload);\n        Record record = mock(CachedDataRecordWithStats.class);\n        when(record.getValue()).thenReturn(dataPayload);\n\n        Records.getValueOrCachedValue(record, serializationService);\n        verify(record, times(1)).setCachedValue(objectPayload);\n    }","id":9491,"modified_method":"@Test\n    public void getValueOrCachedValue_whenRecordIsCachedDataRecordWithStats_thenCache() {\n        String objectPayload = \"foo\";\n        Data dataPayload = serializationService.toData(objectPayload);\n        Record record = new CachedDataRecordWithStats(dataPayload);\n        Object firstDeserilizedValue = Records.getValueOrCachedValue(record, serializationService);\n        assertEquals(objectPayload, firstDeserilizedValue);\n\n        //we don't need serialization service for the 2nd call\n        Object secondDeserilizedValue = Records.getValueOrCachedValue(record, null);\n        assertSame(firstDeserilizedValue, secondDeserilizedValue);\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void getValueOrCachedValue_whenRecordIsCachedDataRecord_thenCache() {\n        String objectPayload = \"foo\";\n        Data dataPayload = serializationService.toData(objectPayload);\n        Record record = mock(CachedDataRecord.class);\n        when(record.getValue()).thenReturn(dataPayload);\n\n        Records.getValueOrCachedValue(record, serializationService);\n        verify(record, times(1)).setCachedValue(objectPayload);\n    }","id":9492,"modified_method":"@Test\n    public void getValueOrCachedValue_whenRecordIsCachedDataRecord_thenCache() {\n        String objectPayload = \"foo\";\n        Data dataPayload = serializationService.toData(objectPayload);\n        Record record = new CachedDataRecord(dataPayload);\n        Object firstDeserilizedValue = Records.getValueOrCachedValue(record, serializationService);\n        assertEquals(objectPayload, firstDeserilizedValue);\n\n        //we don't need serialization service for the 2nd call\n        Object secondDeserilizedValue = Records.getValueOrCachedValue(record, null);\n        assertSame(firstDeserilizedValue, secondDeserilizedValue);\n    }","commit_id":"b61f06761db36560596136536b9cd78cdd0bde14","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString newFileName)\n\t\tthrows PortalException {\n\n\t\tsuper.updateFile(companyId, repositoryId, fileName, newFileName);\n\n\t\tFile newFileNameDir = getFileNameDir(\n\t\t\tcompanyId, repositoryId, newFileName);\n\n\t\tString[] fileNameVersions = FileUtil.listFiles(newFileNameDir);\n\n\t\tfor (String fileNameVersion : fileNameVersions) {\n\t\t\tString ext = FileUtil.getExtension(fileNameVersion);\n\n\t\t\tif (ext.equals(_HOOK_EXTENSION)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFile fileNameVersionFile = new File(\n\t\t\t\tnewFileNameDir + StringPool.SLASH + fileNameVersion);\n\t\t\tFile newFileNameVersionFile = new File(\n\t\t\t\tnewFileNameDir + StringPool.SLASH +\n\t\t\t\t\tFileUtil.stripExtension(fileNameVersion) +\n\t\t\t\t\t\tStringPool.PERIOD + _HOOK_EXTENSION);\n\n\t\t\tfileNameVersionFile.renameTo(newFileNameVersionFile);\n\t\t}\n\t}","id":9493,"modified_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString newFileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tsuper.updateFile(companyId, repositoryId, fileName, newFileName);\n\n\t\tFile newFileNameDir = getFileNameDir(\n\t\t\tcompanyId, repositoryId, newFileName);\n\n\t\tString[] fileNameVersions = FileUtil.listFiles(newFileNameDir);\n\n\t\tfor (String fileNameVersion : fileNameVersions) {\n\t\t\tString ext = FileUtil.getExtension(fileNameVersion);\n\n\t\t\tif (ext.equals(_HOOK_EXTENSION)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFile fileNameVersionFile = new File(\n\t\t\t\tnewFileNameDir + StringPool.SLASH + fileNameVersion);\n\t\t\tFile newFileNameVersionFile = new File(\n\t\t\t\tnewFileNameDir + StringPool.SLASH +\n\t\t\t\t\tFileUtil.stripExtension(fileNameVersion) +\n\t\t\t\t\t\tStringPool.PERIOD + _HOOK_EXTENSION);\n\n\t\t\tboolean renamed = fileNameVersionFile.renameTo(\n\t\t\t\tnewFileNameVersionFile);\n\n\t\t\tif (!renamed) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"File name version file was not renamed from \" +\n\t\t\t\t\t\tfileNameVersionFile.getPath() + \" to \" +\n\t\t\t\t\t\t\tnewFileNameVersionFile.getPath());\n\t\t\t}\n\t\t}\n\t}","commit_id":"ef78f01f62487497956974bb8824ce9dedf83296","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected File getFileNameDir(\n\t\tlong companyId, long repositoryId, String fileName) {\n\n\t\tif (fileName.indexOf(CharPool.SLASH) != -1) {\n\t\t\treturn getDirNameDir(companyId, repositoryId, fileName);\n\t\t}\n\n\t\tString ext = StringPool.PERIOD + FileUtil.getExtension(fileName);\n\n\t\tif (ext.equals(StringPool.PERIOD)) {\n\t\t\text += _HOOK_EXTENSION;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tString fileNameFragment = FileUtil.stripExtension(fileName);\n\n\t\tif (fileNameFragment.startsWith(\"DLFE-\")) {\n\t\t\tfileNameFragment = fileNameFragment.substring(5);\n\n\t\t\tsb.append(\"DLFE\" + StringPool.SLASH);\n\t\t}\n\n\t\tbuildPath(sb, fileNameFragment);\n\n\t\tFile repositoryDir = getRepositoryDir(companyId, repositoryId);\n\n\t\tFile fileNameDir = new File(\n\t\t\trepositoryDir + StringPool.SLASH + sb.toString() +\n\t\t\t\tStringPool.SLASH + fileNameFragment + ext);\n\n\t\tFile parentDir = fileNameDir.getParentFile();\n\n\t\tif (!parentDir.exists()) {\n\t\t\tparentDir.mkdirs();\n\t\t}\n\n\t\treturn fileNameDir;\n\t}","id":9494,"modified_method":"@Override\n\tprotected File getFileNameDir(\n\t\tlong companyId, long repositoryId, String fileName) {\n\n\t\tif (fileName.indexOf(CharPool.SLASH) != -1) {\n\t\t\treturn getDirNameDir(companyId, repositoryId, fileName);\n\t\t}\n\n\t\tString ext = StringPool.PERIOD + FileUtil.getExtension(fileName);\n\n\t\tif (ext.equals(StringPool.PERIOD)) {\n\t\t\text += _HOOK_EXTENSION;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tString fileNameFragment = FileUtil.stripExtension(fileName);\n\n\t\tif (fileNameFragment.startsWith(\"DLFE-\")) {\n\t\t\tfileNameFragment = fileNameFragment.substring(5);\n\n\t\t\tsb.append(\"DLFE\" + StringPool.SLASH);\n\t\t}\n\n\t\tbuildPath(sb, fileNameFragment);\n\n\t\tFile repositoryDir = getRepositoryDir(companyId, repositoryId);\n\n\t\tFile fileNameDir = new File(\n\t\t\trepositoryDir + StringPool.SLASH + sb.toString() +\n\t\t\t\tStringPool.SLASH + fileNameFragment + ext);\n\n\t\tFile parentFile = fileNameDir.getParentFile();\n\n\t\tif (!parentFile.exists()) {\n\t\t\tparentFile.mkdirs();\n\t\t}\n\n\t\treturn fileNameDir;\n\t}","commit_id":"ef78f01f62487497956974bb8824ce9dedf83296","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString newFileName)\n\t\tthrows PortalException {\n\n\t\tFile fileNameDir = getFileNameDir(companyId, repositoryId, fileName);\n\t\tFile newFileNameDir = getFileNameDir(\n\t\t\tcompanyId, repositoryId, newFileName);\n\n\t\tif (newFileNameDir.exists()) {\n\t\t\tthrow new DuplicateFileException(newFileName);\n\t\t}\n\n\t\tFile parentFile = fileNameDir.getParentFile();\n\n\t\tfileNameDir.renameTo(newFileNameDir);\n\n\t\tdeleteEmptyAncestors(companyId, repositoryId, parentFile);\n\t}","id":9495,"modified_method":"public void updateFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString newFileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tFile fileNameDir = getFileNameDir(companyId, repositoryId, fileName);\n\t\tFile newFileNameDir = getFileNameDir(\n\t\t\tcompanyId, repositoryId, newFileName);\n\n\t\tif (newFileNameDir.exists()) {\n\t\t\tthrow new DuplicateFileException(newFileName);\n\t\t}\n\n\t\tFile parentFile = fileNameDir.getParentFile();\n\n\t\tboolean renamed = fileNameDir.renameTo(newFileNameDir);\n\n\t\tif (!renamed) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"File name directory was not renamed from \" +\n\t\t\t\t\tfileNameDir.getPath() + \" to \" + newFileNameDir.getPath());\n\t\t}\n\n\t\tdeleteEmptyAncestors(companyId, repositoryId, parentFile);\n\t}","commit_id":"ef78f01f62487497956974bb8824ce9dedf83296","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, long newRepositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException {\n\n\t\tFile fileNameDir = getFileNameDir(companyId, repositoryId, fileName);\n\t\tFile newFileNameDir = getFileNameDir(\n\t\t\tcompanyId, newRepositoryId, fileName);\n\n\t\tif (newFileNameDir.exists()) {\n\t\t\tthrow new DuplicateFileException(fileName);\n\t\t}\n\n\t\tFile parentFile = fileNameDir.getParentFile();\n\n\t\tfileNameDir.renameTo(newFileNameDir);\n\n\t\tdeleteEmptyAncestors(companyId, repositoryId, parentFile);\n\t}","id":9496,"modified_method":"@Override\n\tpublic void updateFile(\n\t\t\tlong companyId, long repositoryId, long newRepositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException, SystemException {\n\n\t\tFile fileNameDir = getFileNameDir(companyId, repositoryId, fileName);\n\t\tFile newFileNameDir = getFileNameDir(\n\t\t\tcompanyId, newRepositoryId, fileName);\n\n\t\tif (newFileNameDir.exists()) {\n\t\t\tthrow new DuplicateFileException(fileName);\n\t\t}\n\n\t\tFile parentFile = fileNameDir.getParentFile();\n\n\t\tboolean renamed = fileNameDir.renameTo(newFileNameDir);\n\n\t\tif (!renamed) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"File name directory was not renamed from \" +\n\t\t\t\t\tfileNameDir.getPath() + \" to \" + newFileNameDir.getPath());\n\t\t}\n\n\t\tdeleteEmptyAncestors(companyId, repositoryId, parentFile);\n\t}","commit_id":"ef78f01f62487497956974bb8824ce9dedf83296","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void updateFileVersion(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString fromVersionLabel, String toVersionLabel)\n\t\tthrows PortalException {\n\n\t\tFile fromFileNameVersionFile = getFileNameVersionFile(\n\t\t\tcompanyId, repositoryId, fileName, fromVersionLabel);\n\n\t\tFile toFileNameVersionFile = getFileNameVersionFile(\n\t\t\tcompanyId, repositoryId, fileName, toVersionLabel);\n\n\t\tif (toFileNameVersionFile.exists()) {\n\t\t\tthrow new DuplicateFileException(toFileNameVersionFile.getPath());\n\t\t}\n\n\t\tfromFileNameVersionFile.renameTo(toFileNameVersionFile);\n\t}","id":9497,"modified_method":"@Override\n\tpublic void updateFileVersion(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString fromVersionLabel, String toVersionLabel)\n\t\tthrows PortalException, SystemException {\n\n\t\tFile fromFileNameVersionFile = getFileNameVersionFile(\n\t\t\tcompanyId, repositoryId, fileName, fromVersionLabel);\n\n\t\tFile toFileNameVersionFile = getFileNameVersionFile(\n\t\t\tcompanyId, repositoryId, fileName, toVersionLabel);\n\n\t\tif (toFileNameVersionFile.exists()) {\n\t\t\tthrow new DuplicateFileException(toFileNameVersionFile.getPath());\n\t\t}\n\n\t\tboolean renamed = fromFileNameVersionFile.renameTo(\n\t\t\ttoFileNameVersionFile);\n\n\t\tif (!renamed) {\n\t\t\tthrow new SystemException(\n\t\t\t\t\"File name version file was not renamed from \" +\n\t\t\t\t\tfromFileNameVersionFile.getPath() + \" to \" +\n\t\t\t\t\t\ttoFileNameVersionFile.getPath());\n\t\t}\n\t}","commit_id":"ef78f01f62487497956974bb8824ce9dedf83296","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getIfLabel(int nodeId, String ipAddr) throws SQLException {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        String label = null;\n        final DBUtils d = new DBUtils(IfLabel.class);\n\n        try {\n            Connection conn = Vault.getDbConnection();\n            d.watch(conn);\n            label = getIfLabel(conn, nodeId, ipAddr);\n        } finally {\n            d.cleanUp();\n        }\n\n        return label;\n    }","id":9498,"modified_method":"public static String getIfLabel(final int nodeId, final String ipAddr) {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        \n        class LabelHolder {\n            private String m_label;\n\n            public void setLabel(String label) {\n                m_label = label;\n            }\n\n            public String getLabel() {\n                return m_label;\n            }\n        }\n        \n        final LabelHolder holder = new LabelHolder();\n\n        String query = \"\" +\n        \t\t\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr \" +\n        \t\t\"  FROM snmpinterface, ipinterface \" +\n        \t\t\" WHERE (ipinterface.ismanaged!='D') \" +\n        \t\t\"   AND ipinterface.nodeid=snmpinterface.nodeid \" +\n        \t\t\"   AND ifindex=snmpifindex \" +\n        \t\t\"   AND ipinterface.nodeid = \"+nodeId+\n        \t\t\"   AND ipinterface.ipaddr = '\"+ipAddr+\"'\";\n        \n        Querier q = new Querier(Vault.getDataSource(), query, new RowProcessor() {\n            public void processRow(ResultSet rs) throws SQLException {\n                if (rs.next()) {\n                    String name = rs.getString(\"snmpifname\");\n                    String descr = rs.getString(\"snmpifdescr\");\n                    String physAddr = rs.getString(\"snmpphysaddr\");\n\n                    if (name != null || descr != null) {\n                        holder.setLabel(getIfLabel(name, descr, physAddr));\n                    } else {\n                        log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                        holder.setLabel(\"no_ifLabel\");\n                    }\n                }\n            }\n        });\n        q.execute();\n        \n        return holder.getLabel();\n    }","commit_id":"44339f3a1fb72c04a92e700d07fc5a6bab5acf2d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static String getIfLabelfromIfIndex(int nodeId, String ipAddr, int ifIndex) throws SQLException, NumberFormatException {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (ifIndex == -1) {\n        \treturn getIfLabel(nodeId, ipAddr);\n        }\n        \n        String label = null;\n        Connection conn = Vault.getDbConnection();\n\n        final DBUtils d = new DBUtils(IfLabel.class);\n        try {\n        \tInteger intIfIndex = Integer.valueOf(ifIndex);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr from snmpinterface, ipinterface where (ipinterface.ismanaged!='D') AND ipinterface.nodeid=snmpinterface.nodeid AND ifindex=snmpifindex AND ipinterface.nodeid=? AND ipinterface.ipaddr=? AND ipinterface.ifindex=?\");\n            d.watch(stmt);\n            stmt.setInt(1, nodeId);\n            stmt.setString(2, ipAddr);\n            stmt.setInt(3, intIfIndex);\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n\n            if (rs.next()) {\n                String name = rs.getString(\"snmpifname\");\n                String descr = rs.getString(\"snmpifdescr\");\n                String physAddr = rs.getString(\"snmpphysaddr\");\n\n                if (name != null || descr != null) {\n                    label = getIfLabel(name, descr, physAddr);\n                } else {\n                    log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                    label = \"no_ifLabel\";\n                }\n            }\n\n            if (rs.next()) {\n                log.warn(\"Found more than one interface for node=\" + nodeId + \" ip=\" + ipAddr);\n            }\n        } finally {\n            d.cleanUp();\n            Vault.releaseDbConnection(conn);\n        }\n\n        return label;\n    }","id":9499,"modified_method":"public static String getIfLabelfromIfIndex(final int nodeId, final String ipAddr, final int ifIndex) {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (ifIndex == -1) {\n        \treturn getIfLabel(nodeId, ipAddr);\n        }\n        \n        class LabelHolder {\n            private String m_label;\n\n            public void setLabel(String label) {\n                m_label = label;\n            }\n\n            public String getLabel() {\n                return m_label;\n            }\n        }\n        \n        final LabelHolder holder = new LabelHolder();\n        \n        String query = \"\" +\n        \t\t\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr \" +\n        \t\t\"  FROM snmpinterface, ipinterface \" +\n        \t\t\" WHERE (ipinterface.ismanaged!='D') \" +\n        \t\t\"   AND ipinterface.nodeid=snmpinterface.nodeid \" +\n        \t\t\"   AND ifindex=snmpifindex \" +\n        \t\t\"   AND ipinterface.nodeid=? \" +\n        \t\t\"   AND ipinterface.ipaddr=? \" +\n        \t\t\"   AND ipinterface.ifindex=?\";\n        \n        \n        Querier q = new Querier(Vault.getDataSource(), query, new RowProcessor() {\n\n            public void processRow(ResultSet rs) throws SQLException {\n                if (rs.next()) {\n                    String name = rs.getString(\"snmpifname\");\n                    String descr = rs.getString(\"snmpifdescr\");\n                    String physAddr = rs.getString(\"snmpphysaddr\");\n\n                    if (name != null || descr != null) {\n                        holder.setLabel(getIfLabel(name, descr, physAddr));\n                    } else {\n                        log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                        holder.setLabel(\"no_ifLabel\");\n                    }\n                }\n\n                if (rs.next()) {\n                    log.warn(\"Found more than one interface for node=\" + nodeId + \" ip=\" + ipAddr);\n                }\n            }\n            \n        });\n        q.execute();\n        \n        return holder.getLabel();\n    }","commit_id":"44339f3a1fb72c04a92e700d07fc5a6bab5acf2d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getIfLabel(int nodeId, String ipAddress) {\n        // Get database connection\n        java.sql.Connection dbConn = null;\n        try {\n            dbConn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException e) {\n            //log().error(\"checkIfDir: Failed getting connection to the database: \" + e, e);\n            throw new UndeclaredThrowableException(e);\n        }\n    \n        // Make certain we close the connection\n        String label = null;\n        try {\n            label = IfLabel.getIfLabel(dbConn, nodeId, ipAddress);\n        } catch (SQLException e) {\n        } finally {\n            // Done with the database so close the connection\n            try {\n                if (dbConn != null) {\n                    dbConn.close();\n                }\n            } catch (SQLException e) {\n            }\n        }\n        return label;\n    }","id":9500,"modified_method":"public String getIfLabel(int nodeId, String ipAddress) {\n        return IfLabel.getIfLabel(nodeId, ipAddress);\n    }","commit_id":"44339f3a1fb72c04a92e700d07fc5a6bab5acf2d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static String getIfLabelfromIfIndex(int nodeId, String ipAddr, int ifIndex) throws SQLException, NumberFormatException {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (ifIndex == -1) {\n        \treturn getIfLabel(nodeId, ipAddr);\n        }\n        \n        String label = null;\n        Connection conn = Vault.getDbConnection();\n\n        final DBUtils d = new DBUtils(IfLabel.class);\n        try {\n        \tInteger intIfIndex = Integer.valueOf(ifIndex);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr from snmpinterface, ipinterface where (ipinterface.ismanaged!='D') AND ipinterface.nodeid=snmpinterface.nodeid AND ifindex=snmpifindex AND ipinterface.nodeid=? AND ipinterface.ipaddr=? AND ipinterface.ifindex=?\");\n            d.watch(stmt);\n            stmt.setInt(1, nodeId);\n            stmt.setString(2, ipAddr);\n            stmt.setInt(3, intIfIndex);\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n\n            if (rs.next()) {\n                String name = rs.getString(\"snmpifname\");\n                String descr = rs.getString(\"snmpifdescr\");\n                String physAddr = rs.getString(\"snmpphysaddr\");\n\n                if (name != null || descr != null) {\n                    label = getIfLabel(name, descr, physAddr);\n                } else {\n                    log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                    label = \"no_ifLabel\";\n                }\n            }\n\n            if (rs.next()) {\n                log.warn(\"Found more than one interface for node=\" + nodeId + \" ip=\" + ipAddr);\n            }\n        } finally {\n            d.cleanUp();\n            Vault.releaseDbConnection(conn);\n        }\n\n        return label;\n    }","id":9501,"modified_method":"public static String getIfLabelfromIfIndex(final int nodeId, final String ipAddr, final int ifIndex) {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (ifIndex == -1) {\n        \treturn getIfLabel(nodeId, ipAddr);\n        }\n        \n        class LabelHolder {\n            private String m_label;\n\n            public void setLabel(String label) {\n                m_label = label;\n            }\n\n            public String getLabel() {\n                return m_label;\n            }\n        }\n        \n        final LabelHolder holder = new LabelHolder();\n        \n        String query = \"\" +\n        \t\t\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr \" +\n        \t\t\"  FROM snmpinterface, ipinterface \" +\n        \t\t\" WHERE (ipinterface.ismanaged!='D') \" +\n        \t\t\"   AND ipinterface.nodeid=snmpinterface.nodeid \" +\n        \t\t\"   AND ifindex=snmpifindex \" +\n        \t\t\"   AND ipinterface.nodeid=? \" +\n        \t\t\"   AND ipinterface.ipaddr=? \" +\n        \t\t\"   AND ipinterface.ifindex=?\";\n        \n        \n        Querier q = new Querier(Vault.getDataSource(), query, new RowProcessor() {\n\n            public void processRow(ResultSet rs) throws SQLException {\n                if (rs.next()) {\n                    String name = rs.getString(\"snmpifname\");\n                    String descr = rs.getString(\"snmpifdescr\");\n                    String physAddr = rs.getString(\"snmpphysaddr\");\n\n                    if (name != null || descr != null) {\n                        holder.setLabel(getIfLabel(name, descr, physAddr));\n                    } else {\n                        log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                        holder.setLabel(\"no_ifLabel\");\n                    }\n                }\n\n                if (rs.next()) {\n                    log.warn(\"Found more than one interface for node=\" + nodeId + \" ip=\" + ipAddr);\n                }\n            }\n            \n        });\n        q.execute();\n        \n        return holder.getLabel();\n    }","commit_id":"546ce8fb72d31cb8c1297c6c563281a4316559ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static String getIfLabel(int nodeId, String ipAddr) throws SQLException {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        String label = null;\n        final DBUtils d = new DBUtils(IfLabel.class);\n\n        try {\n            Connection conn = Vault.getDbConnection();\n            d.watch(conn);\n            label = getIfLabel(conn, nodeId, ipAddr);\n        } finally {\n            d.cleanUp();\n        }\n\n        return label;\n    }","id":9502,"modified_method":"public static String getIfLabel(final int nodeId, final String ipAddr) {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        \n        class LabelHolder {\n            private String m_label;\n\n            public void setLabel(String label) {\n                m_label = label;\n            }\n\n            public String getLabel() {\n                return m_label;\n            }\n        }\n        \n        final LabelHolder holder = new LabelHolder();\n\n        String query = \"\" +\n        \t\t\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr \" +\n        \t\t\"  FROM snmpinterface, ipinterface \" +\n        \t\t\" WHERE (ipinterface.ismanaged!='D') \" +\n        \t\t\"   AND ipinterface.nodeid=snmpinterface.nodeid \" +\n        \t\t\"   AND ifindex=snmpifindex \" +\n        \t\t\"   AND ipinterface.nodeid = \"+nodeId+\n        \t\t\"   AND ipinterface.ipaddr = '\"+ipAddr+\"'\";\n        \n        Querier q = new Querier(Vault.getDataSource(), query, new RowProcessor() {\n            public void processRow(ResultSet rs) throws SQLException {\n                if (rs.next()) {\n                    String name = rs.getString(\"snmpifname\");\n                    String descr = rs.getString(\"snmpifdescr\");\n                    String physAddr = rs.getString(\"snmpphysaddr\");\n\n                    if (name != null || descr != null) {\n                        holder.setLabel(getIfLabel(name, descr, physAddr));\n                    } else {\n                        log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                        holder.setLabel(\"no_ifLabel\");\n                    }\n                }\n            }\n        });\n        q.execute();\n        \n        return holder.getLabel();\n    }","commit_id":"546ce8fb72d31cb8c1297c6c563281a4316559ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getIfLabel(int nodeId, String ipAddress) {\n        // Get database connection\n        java.sql.Connection dbConn = null;\n        try {\n            dbConn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException e) {\n            //log().error(\"checkIfDir: Failed getting connection to the database: \" + e, e);\n            throw new UndeclaredThrowableException(e);\n        }\n    \n        // Make certain we close the connection\n        String label = null;\n        try {\n            label = IfLabel.getIfLabel(dbConn, nodeId, ipAddress);\n        } catch (SQLException e) {\n        } finally {\n            // Done with the database so close the connection\n            try {\n                if (dbConn != null) {\n                    dbConn.close();\n                }\n            } catch (SQLException e) {\n            }\n        }\n        return label;\n    }","id":9503,"modified_method":"public String getIfLabel(int nodeId, String ipAddress) {\n        return IfLabel.getIfLabel(nodeId, ipAddress);\n    }","commit_id":"546ce8fb72d31cb8c1297c6c563281a4316559ba","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static String getIfLabelfromIfIndex(int nodeId, String ipAddr, int ifIndex) throws SQLException, NumberFormatException {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (ifIndex == -1) {\n        \treturn getIfLabel(nodeId, ipAddr);\n        }\n        \n        String label = null;\n        Connection conn = Vault.getDbConnection();\n\n        final DBUtils d = new DBUtils(IfLabel.class);\n        try {\n        \tInteger intIfIndex = Integer.valueOf(ifIndex);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr from snmpinterface, ipinterface where (ipinterface.ismanaged!='D') AND ipinterface.nodeid=snmpinterface.nodeid AND ifindex=snmpifindex AND ipinterface.nodeid=? AND ipinterface.ipaddr=? AND ipinterface.ifindex=?\");\n            d.watch(stmt);\n            stmt.setInt(1, nodeId);\n            stmt.setString(2, ipAddr);\n            stmt.setInt(3, intIfIndex);\n\n            ResultSet rs = stmt.executeQuery();\n            d.watch(rs);\n\n            if (rs.next()) {\n                String name = rs.getString(\"snmpifname\");\n                String descr = rs.getString(\"snmpifdescr\");\n                String physAddr = rs.getString(\"snmpphysaddr\");\n\n                if (name != null || descr != null) {\n                    label = getIfLabel(name, descr, physAddr);\n                } else {\n                    log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                    label = \"no_ifLabel\";\n                }\n            }\n\n            if (rs.next()) {\n                log.warn(\"Found more than one interface for node=\" + nodeId + \" ip=\" + ipAddr);\n            }\n        } finally {\n            d.cleanUp();\n            Vault.releaseDbConnection(conn);\n        }\n\n        return label;\n    }","id":9504,"modified_method":"public static String getIfLabelfromIfIndex(final int nodeId, final String ipAddr, final int ifIndex) {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        if (ifIndex == -1) {\n        \treturn getIfLabel(nodeId, ipAddr);\n        }\n        \n        class LabelHolder {\n            private String m_label;\n\n            public void setLabel(String label) {\n                m_label = label;\n            }\n\n            public String getLabel() {\n                return m_label;\n            }\n        }\n        \n        final LabelHolder holder = new LabelHolder();\n        \n        String query = \"\" +\n        \t\t\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr \" +\n        \t\t\"  FROM snmpinterface, ipinterface \" +\n        \t\t\" WHERE (ipinterface.ismanaged!='D') \" +\n        \t\t\"   AND ipinterface.nodeid=snmpinterface.nodeid \" +\n        \t\t\"   AND ifindex=snmpifindex \" +\n        \t\t\"   AND ipinterface.nodeid=? \" +\n        \t\t\"   AND ipinterface.ipaddr=? \" +\n        \t\t\"   AND ipinterface.ifindex=?\";\n        \n        \n        Querier q = new Querier(Vault.getDataSource(), query, new RowProcessor() {\n\n            public void processRow(ResultSet rs) throws SQLException {\n                if (rs.next()) {\n                    String name = rs.getString(\"snmpifname\");\n                    String descr = rs.getString(\"snmpifdescr\");\n                    String physAddr = rs.getString(\"snmpphysaddr\");\n\n                    if (name != null || descr != null) {\n                        holder.setLabel(getIfLabel(name, descr, physAddr));\n                    } else {\n                        log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                        holder.setLabel(\"no_ifLabel\");\n                    }\n                }\n\n                if (rs.next()) {\n                    log.warn(\"Found more than one interface for node=\" + nodeId + \" ip=\" + ipAddr);\n                }\n            }\n            \n        });\n        q.execute();\n        \n        return holder.getLabel();\n    }","commit_id":"286fa2e12378e937a93f116ff9cc1ff8dc15d251","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static String getIfLabel(int nodeId, String ipAddr) throws SQLException {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        String label = null;\n        final DBUtils d = new DBUtils(IfLabel.class);\n\n        try {\n            Connection conn = Vault.getDbConnection();\n            d.watch(conn);\n            label = getIfLabel(conn, nodeId, ipAddr);\n        } finally {\n            d.cleanUp();\n        }\n\n        return label;\n    }","id":9505,"modified_method":"public static String getIfLabel(final int nodeId, final String ipAddr) {\n        if (ipAddr == null) {\n            throw new IllegalArgumentException(\"Cannot take null parameters.\");\n        }\n\n        \n        class LabelHolder {\n            private String m_label;\n\n            public void setLabel(String label) {\n                m_label = label;\n            }\n\n            public String getLabel() {\n                return m_label;\n            }\n        }\n        \n        final LabelHolder holder = new LabelHolder();\n\n        String query = \"\" +\n        \t\t\"SELECT DISTINCT snmpifname, snmpifdescr,snmpphysaddr \" +\n        \t\t\"  FROM snmpinterface, ipinterface \" +\n        \t\t\" WHERE (ipinterface.ismanaged!='D') \" +\n        \t\t\"   AND ipinterface.nodeid=snmpinterface.nodeid \" +\n        \t\t\"   AND ifindex=snmpifindex \" +\n        \t\t\"   AND ipinterface.nodeid = \"+nodeId+\n        \t\t\"   AND ipinterface.ipaddr = '\"+ipAddr+\"'\";\n        \n        Querier q = new Querier(Vault.getDataSource(), query, new RowProcessor() {\n            public void processRow(ResultSet rs) throws SQLException {\n                if (rs.next()) {\n                    String name = rs.getString(\"snmpifname\");\n                    String descr = rs.getString(\"snmpifdescr\");\n                    String physAddr = rs.getString(\"snmpphysaddr\");\n\n                    if (name != null || descr != null) {\n                        holder.setLabel(getIfLabel(name, descr, physAddr));\n                    } else {\n                        log.warn(\"Interface (nodeId/ipAddr=\" + nodeId + \"/\" + ipAddr + \") has no ifName and no ifDescr...setting to label to 'no_ifLabel'.\");\n                        holder.setLabel(\"no_ifLabel\");\n                    }\n                }\n            }\n        });\n        q.execute();\n        \n        return holder.getLabel();\n    }","commit_id":"286fa2e12378e937a93f116ff9cc1ff8dc15d251","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String getIfLabel(int nodeId, String ipAddress) {\n        // Get database connection\n        java.sql.Connection dbConn = null;\n        try {\n            dbConn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException e) {\n            //log().error(\"checkIfDir: Failed getting connection to the database: \" + e, e);\n            throw new UndeclaredThrowableException(e);\n        }\n    \n        // Make certain we close the connection\n        String label = null;\n        try {\n            label = IfLabel.getIfLabel(dbConn, nodeId, ipAddress);\n        } catch (SQLException e) {\n        } finally {\n            // Done with the database so close the connection\n            try {\n                if (dbConn != null) {\n                    dbConn.close();\n                }\n            } catch (SQLException e) {\n            }\n        }\n        return label;\n    }","id":9506,"modified_method":"public String getIfLabel(int nodeId, String ipAddress) {\n        return IfLabel.getIfLabel(nodeId, ipAddress);\n    }","commit_id":"286fa2e12378e937a93f116ff9cc1ff8dc15d251","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Returns a Metainformation of a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param meta The Metadefinition-name of which the Metainformation has to be read.\n\t * \n\t * @return metainfo The metainfo as string or null if the metainfo not exists.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic String readMetainformation(A_CmsResource resource, String meta)\n\t\tthrows CmsException {\n\t\t try {\n\t\t\t ResultSet result;\n\t\t\t \n\t\t\t synchronized(m_statementReadMetainfo) {\n\t\t\t\tm_statementReadMetainfo.setString(1, resource.getPath());\n\t\t\t\tm_statementReadMetainfo.setInt(2, resource.getProjectId());\n\t\t\t\tm_statementReadMetainfo.setString(3, meta);\n\t\t\t\tm_statementReadMetainfo.setInt(4, resource.getType());\n\n\t\t\t\tresult = m_statementReadMetainfo.executeQuery();\n\t\t\t }\n\t\t\t \n\t\t\t // if resultset exists - return it\n\t\t\t if(result.next()) {\n\t\t\t\t return(result.getString(C_METAINFO_VALUE));\n\t\t\t } else {\n\t\t\t\t return(null);\n\t\t\t }\n\t\t } catch( SQLException exc ) {\n\t\t\t throw new CmsException(exc.getMessage(), CmsException.C_SQL_ERROR, exc);\n\t\t }\n\t}","id":9507,"modified_method":"/**\n\t * Returns a Metainformation of a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param meta The Metadefinition-name of which the Metainformation has to be read.\n\t * \n\t * @return metainfo The metainfo as string or null if the metainfo not exists.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic String readMetainformation(A_CmsResource resource, String meta)\n\t\tthrows CmsException {\n\t\treturn( readMetainformation(meta, resource.getProjectId(), \n\t\t\t\t\t\t\t\t\tresource.getPath(), resource.getType()) );\n\t}","commit_id":"afee069d29b5807eb511069ae05cb08ffc7d740f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Deletes all Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void deleteAllMetainformations(A_CmsResource resource)\n\t\tthrows CmsException {\n\t\t\n\t\ttry {\n\t\t\tsynchronized(m_statementDeleteAllMetainfo) {\n\t\t\t\tm_statementDeleteAllMetainfo.setString(1, resource.getAbsolutePath());\n\t\t\t\tm_statementDeleteAllMetainfo.setInt(2, resource.getProjectId());\n\n\t\t\t\tm_statementDeleteAllMetainfo.executeQuery();\n\t\t\t}\t\t\t\n\t\t} catch( SQLException exc ) {\n\t\t\tthrow new CmsException(exc.getMessage(), CmsException.C_SQL_ERROR, exc);\n\t\t}\n\t}","id":9508,"modified_method":"/**\n\t * Deletes all Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void deleteAllMetainformations(A_CmsResource resource)\n\t\tthrows CmsException {\n\t\tdeleteAllMetainformations(resource.getProjectId(), resource.getAbsolutePath());\n\t}","commit_id":"afee069d29b5807eb511069ae05cb08ffc7d740f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Writes a Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param meta The Metadefinition-name of which the Metainformation has to be set.\n\t * @param value The value for the metainfo to be set.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void writeMetainformation(A_CmsResource resource, String meta,\n\t\t\t\t\t\t\t  String value)\n\t\tthrows CmsException {\n\t\tA_CmsMetadefinition metadef = readMetadefinition(meta, resource.getType());\n\t\t\n\t\tif( metadef == null) {\n\t\t\t// there is no metadefinition for with the overgiven name for the resource\n\t\t\tthrow new CmsException(meta, CmsException.C_NOT_FOUND);\n\t\t} else {\n\t\t\t// write the metainfo into the db\n\t\t\ttry {\n\t\t\t\tif( readMetainformation(resource, metadef.getName()) != null) {\n\t\t\t\t\t// metainfo exists already - use update.\n\t\t\t\t\tsynchronized(m_statementUpdateMetainfo) {\n\t\t\t\t\t\tm_statementUpdateMetainfo.setString(1, value);\n\t\t\t\t\t\tm_statementUpdateMetainfo.setString(2, resource.getAbsolutePath());\n\t\t\t\t\t\tm_statementUpdateMetainfo.setInt(3, resource.getProjectId());\n\t\t\t\t\t\tm_statementUpdateMetainfo.setInt(4, metadef.getId());\n\t\t\t\t\t\tm_statementUpdateMetainfo.executeUpdate();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// metainfo dosen't exist - use create.\n\t\t\t\t\tsynchronized(m_statementCreateMetainfo) {\n\t\t\t\t\t\tm_statementCreateMetainfo.setInt(1, metadef.getId());\n\t\t\t\t\t\tm_statementCreateMetainfo.setString(2, resource.getAbsolutePath());\n\t\t\t\t\t\tm_statementCreateMetainfo.setInt(3, resource.getProjectId());\n\t\t\t\t\t\tm_statementCreateMetainfo.setString(4, value);\n\t\t\t\t\t\tm_statementCreateMetainfo.executeUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch(SQLException exc) {\n\t\t\t\tthrow new CmsException(exc.getMessage(), CmsException.C_SQL_ERROR, exc);\n\t\t\t}\n\t\t}\n\t}","id":9509,"modified_method":"/**\n\t * Writes a Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param meta The Metadefinition-name of which the Metainformation has to be set.\n\t * @param value The value for the metainfo to be set.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void writeMetainformation(A_CmsResource resource, String meta,\n\t\t\t\t\t\t\t  String value)\n\t\tthrows CmsException {\n\t\twriteMetainformation(meta, value, resource.getProjectId(), \n\t\t\t\t\t\t\t resource.getAbsolutePath(), resource.getType());\n\t}","commit_id":"afee069d29b5807eb511069ae05cb08ffc7d740f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Returns a list of all Metainformations of a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * \n\t * @return Vector of Metainformation as Strings.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic Hashtable readAllMetainformations(A_CmsResource resource)\n\t\tthrows CmsException {\n\t\t\n\t\tHashtable returnValue = new Hashtable();\n\t\t\n\t\ttry {\n\t\t\tResultSet result;\n\t\t\tsynchronized(m_statementReadAllMetainfo) {\n\t\t\t\tm_statementReadAllMetainfo.setString(1, resource.getAbsolutePath());\n\t\t\t\tm_statementReadAllMetainfo.setInt(2, resource.getProjectId());\n\t\t\t\tm_statementReadAllMetainfo.setInt(3, resource.getType());\n\n\t\t\t\tresult = m_statementReadAllMetainfo.executeQuery();\n\t\t\t}\n\t\t\t\n\t\t\t while(result.next()) {\n\t\t\t\t returnValue.put(result.getString(C_METADEF_NAME),\n\t\t\t\t\t\t\t\t result.getString(C_METAINFO_VALUE));\n\t\t\t }\n\t\t\t return(returnValue);\t\t\n\t\t\t\n\t\t} catch( SQLException exc ) {\n\t\t\tthrow new CmsException(exc.getMessage(), CmsException.C_SQL_ERROR, exc);\n\t\t}\n\t\t\n\t}","id":9510,"modified_method":"/**\n\t * Returns a list of all Metainformations of a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * \n\t * @return Vector of Metainformation as Strings.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic Hashtable readAllMetainformations(A_CmsResource resource)\n\t\tthrows CmsException {\n\t\treturn( readAllMetainformations( resource.getProjectId(), \n\t\t\t\t\t\t\t\t\t\t resource.getAbsolutePath(),\n\t\t\t\t\t\t\t\t\t\t resource.getType() ) );\n\t}","commit_id":"afee069d29b5807eb511069ae05cb08ffc7d740f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Deletes a Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param meta The Metadefinition-name of which the Metainformation has to be set.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void deleteMetainformation(A_CmsResource resource, String meta)\n\t\tthrows CmsException {\n\t\tA_CmsMetadefinition metadef = readMetadefinition(meta, resource.getType());\n\t\t\n\t\tif( metadef == null) {\n\t\t\t// there is no metadefinition with the overgiven name for the resource\n\t\t\tthrow new CmsException(meta, CmsException.C_NOT_FOUND);\n\t\t} else {\n\t\t\t// delete the metainfo into the db\n\t\t\ttry {\n\t\t\t\tsynchronized(m_statementDeleteMetainfo) {\n\t\t\t\t\tm_statementDeleteMetainfo.setInt(1, metadef.getId());\n\t\t\t\t\tm_statementDeleteMetainfo.setString(2, resource.getAbsolutePath());\n\t\t\t\t\tm_statementDeleteMetainfo.setInt(3, resource.getProjectId());\n\t\t\t\t\tm_statementDeleteMetainfo.executeUpdate();\n\t\t\t\t}\n\t\t\t} catch(SQLException exc) {\n\t\t\t\tthrow new CmsException(exc.getMessage(), CmsException.C_SQL_ERROR, exc);\n\t\t\t}\n\t\t}\n\t}","id":9511,"modified_method":"/**\n\t * Deletes a Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param meta The Metadefinition-name of which the Metainformation has to be set.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void deleteMetainformation(A_CmsResource resource, String meta)\n\t\tthrows CmsException {\n\t\tdeleteMetainformation(meta, resource.getProjectId(), resource.getAbsolutePath(), \n\t\t\t\t\t\t\t  resource.getType());\n\t}","commit_id":"afee069d29b5807eb511069ae05cb08ffc7d740f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Writes a couple of Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param metainfos A Hashtable with Metadefinition- metainfo-pairs as strings.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void writeMetainformations(A_CmsResource resource, Hashtable metainfos)\n\t\tthrows CmsException {\n\t\t\n\t\t// get all metadefs\n\t\tEnumeration keys = metainfos.keys();\n\t\t\n\t\t// one metainfo-name:\n\t\tString key;\n\t\t\n\t\twhile(keys.hasMoreElements()) {\n\t\t\tkey = (String) keys.nextElement();\n\t\t\tthis.writeMetainformation(resource, key, (String) metainfos.get(key));\n\t\t}\t\t\n\t}","id":9512,"modified_method":"/**\n\t * Writes a couple of Metainformation for a file or folder.\n\t * \n\t * @param resource The resource of which the Metainformation has to be read.\n\t * @param metainfos A Hashtable with Metadefinition- metainfo-pairs as strings.\n\t * \n\t * @exception CmsException Throws CmsException if operation was not succesful\n\t */\n\tpublic void writeMetainformations(A_CmsResource resource, Hashtable metainfos)\n\t\tthrows CmsException {\n\t\twriteMetainformations(metainfos, resource.getProjectId(), \n\t\t\t\t\t\t\t  resource.getAbsolutePath(), resource.getType());\n\t}","commit_id":"afee069d29b5807eb511069ae05cb08ffc7d740f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n    public boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"chooseTarget: \" + outcome.toString() + \":\" + target.toString());\n        }\n        // sometimes a target selection can be made from a player that does not control the ability\n        UUID abilityControllerId = playerId;\n        if (target.getTargetController() != null && target.getAbilityController() != null) {\n            abilityControllerId = target.getAbilityController();\n        }\n        UUID opponentId = game.getOpponents(abilityControllerId).iterator().next();\n        if (target instanceof TargetPlayer) {\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n                if (target.isRequired(sourceId, game)) {\n                    if (target.canTarget(opponentId, game)) {\n                        target.add(opponentId, game);\n                        return true;\n                    }\n                }\n            } else {\n                if (target.canTarget(opponentId, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n                if (target.isRequired(sourceId, game)) {\n                    if (target.canTarget(abilityControllerId, game)) {\n                        target.add(abilityControllerId, game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetDiscard) {\n            findPlayables(game);\n            if (unplayable.size() > 0) {\n                for (int i = unplayable.size() - 1; i >= 0; i--) {\n                    if (target.canTarget(unplayable.values().toArray(new Card[0])[i].getId(), game)) {\n                        target.add(unplayable.values().toArray(new Card[0])[i].getId(), game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (hand.size() > 0) {\n                for (int i = 0; i < hand.size(); i++) {\n                    if (target.canTarget(hand.toArray(new UUID[0])[i], game)) {\n                        target.add(hand.toArray(new UUID[0])[i], game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetControlledPermanent) {\n            List<Permanent> targets;\n            targets = threats(abilityControllerId, sourceId, ((TargetControlledPermanent) target).getFilter(), game, target.getTargets());\n            if (!outcome.isGood()) {\n                Collections.reverse(targets);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetControlledPermanent) target).canTarget(abilityControllerId, permanent.getId(), sourceId, game, false) && !target.getTargets().contains(permanent.getId())) {\n                    target.add(permanent.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetPermanent) {\n            List<Permanent> targets;\n            if (outcome.isCanTargetAll()) {\n                targets = threats(null, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            } else {\n                if (outcome.isGood()) {\n                    targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                } else {\n                    targets = threats(opponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                }\n                if (targets.isEmpty() && target.isRequired()) {\n                    if (!outcome.isGood()) {\n                        targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    } else {\n                        targets = threats(opponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    }\n                }\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetPermanent) target).canTarget(abilityControllerId, permanent.getId(), null, game) && !target.getTargets().contains(permanent.getId())) {\n                    // stop to add targets if not needed and outcome is no advantage for AI player\n                    if (target.getNumberOfTargets() == target.getTargets().size()) {\n                        if (outcome.isGood() && hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                        if (!outcome.isGood() && !hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                    }\n                    // add the target\n                    target.add(permanent.getId(), game);\n                    if (target.doneChosing()) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInHand\n                || (target.getZone().equals(Zone.HAND) && (target instanceof TargetCard))) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID cardId : target.possibleTargets(sourceId, this.getId(), game)) {\n                Card card = game.getCard(cardId);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            while ((outcome.isGood() ? target.getTargets().size() < target.getMaxNumberOfTargets() : !target.isChosen())\n                    && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, null, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), null, game);\n                    cards.remove(pick);\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetCreatureOrPlayer) {\n            List<Permanent> targets;\n            TargetCreatureOrPlayer t = ((TargetCreatureOrPlayer) target);\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            } else {\n                targets = threats(opponentId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(abilityControllerId, permanent.getId(), null, game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(opponentId, null, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n        }\n\n        if (target instanceof TargetPermanentOrPlayer) {\n            List<Permanent> targets;\n            TargetPermanentOrPlayer t = ((TargetPermanentOrPlayer) target);\n            List<Permanent> ownedTargets = threats(abilityControllerId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());;\n            List<Permanent> opponentTargets = threats(opponentId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());\n            if (outcome.isGood()) {\n                targets = ownedTargets;\n            } else {\n                targets = opponentTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(opponentId, null, game)) {\n                    target.add(opponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game) || target.getNumberOfTargets() == 0) {\n                return false;\n            }\n            if (target.canTarget(opponentId, null, game)) {\n                target.add(opponentId, game);\n                return true;\n            }\n            if (target.canTarget(abilityControllerId, null, game)) {\n                target.add(abilityControllerId, game);\n                return true;\n            }\n            if (outcome.isGood()) { // no other valid targets so use a permanent\n                targets = opponentTargets;\n            } else {\n                targets = ownedTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                for (Card card : player.getGraveyard().getCards(game)) {\n                    if (target.canTarget(card.getId(), game)) {\n                        cards.add(card);\n                    }\n                }\n            }\n            for (Card card : cards) {\n                target.add(card.getId(), game);\n                if (target.isChosen()) {\n                    return true;\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInYourGraveyard) {\n            List<UUID> alreadyTargetted = target.getTargets();\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getGraveyard().getCards(game));\n            while (!cards.isEmpty()) {\n                Card card = pickTarget(cards, outcome, target, null, game);\n                if (card != null && alreadyTargetted != null && !alreadyTargetted.contains(card.getId())) {\n                    target.add(card.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetSource) {\n            Set<UUID> targets;\n            TargetSource t = ((TargetSource) target);\n            targets = t.possibleTargets(sourceId, abilityControllerId, game);\n            for (UUID targetId : targets) {\n                MageObject targetObject = game.getObject(targetId);\n                if (targetObject != null) {\n                    List<UUID> alreadyTargetted = target.getTargets();\n                    if (t.canTarget(targetObject.getId(), game)) {\n                        if (alreadyTargetted != null && !alreadyTargetted.contains(targetObject.getId())) {\n                            target.add(targetObject.getId(), game);\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n            throw new IllegalStateException(\"TargetSource wasn't handled. class:\" + target.getClass().toString());\n        }\n\n        throw new IllegalStateException(\"Target wasn't handled. class:\" + target.getClass().toString());\n    }","id":9513,"modified_method":"@Override\n    public boolean choose(Outcome outcome, Target target, UUID sourceId, Game game, Map<String, Serializable> options) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"chooseTarget: \" + outcome.toString() + \":\" + target.toString());\n        }\n        // sometimes a target selection can be made from a player that does not control the ability\n        UUID abilityControllerId = playerId;\n        if (target.getTargetController() != null && target.getAbilityController() != null) {\n            abilityControllerId = target.getAbilityController();\n        }\n        UUID randomOpponentId = getRandomOpponent(abilityControllerId, game);\n        if (target instanceof TargetPlayer) {\n            return setTargetPlayer(outcome, target, null, sourceId, abilityControllerId, randomOpponentId, game);\n        }\n\n        if (target instanceof TargetDiscard) {\n            findPlayables(game);\n            if (unplayable.size() > 0) {\n                for (int i = unplayable.size() - 1; i >= 0; i--) {\n                    if (target.canTarget(unplayable.values().toArray(new Card[0])[i].getId(), game)) {\n                        target.add(unplayable.values().toArray(new Card[0])[i].getId(), game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (hand.size() > 0) {\n                for (int i = 0; i < hand.size(); i++) {\n                    if (target.canTarget(hand.toArray(new UUID[0])[i], game)) {\n                        target.add(hand.toArray(new UUID[0])[i], game);\n                        if (target.isChosen()) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetControlledPermanent) {\n            List<Permanent> targets;\n            targets = threats(abilityControllerId, sourceId, ((TargetControlledPermanent) target).getFilter(), game, target.getTargets());\n            if (!outcome.isGood()) {\n                Collections.reverse(targets);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetControlledPermanent) target).canTarget(abilityControllerId, permanent.getId(), sourceId, game, false) && !target.getTargets().contains(permanent.getId())) {\n                    target.add(permanent.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetPermanent) {\n            List<Permanent> targets;\n            if (outcome.isCanTargetAll()) {\n                targets = threats(null, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            } else {\n                if (outcome.isGood()) {\n                    targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                } else {\n                    targets = threats(randomOpponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                }\n                if (targets.isEmpty() && target.isRequired()) {\n                    if (!outcome.isGood()) {\n                        targets = threats(abilityControllerId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    } else {\n                        targets = threats(randomOpponentId, sourceId, ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                    }\n                }\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetPermanent) target).canTarget(abilityControllerId, permanent.getId(), null, game) && !target.getTargets().contains(permanent.getId())) {\n                    // stop to add targets if not needed and outcome is no advantage for AI player\n                    if (target.getNumberOfTargets() == target.getTargets().size()) {\n                        if (outcome.isGood() && hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                        if (!outcome.isGood() && !hasOpponent(permanent.getControllerId(), game)) {\n                            return true;\n                        }\n                    }\n                    // add the target\n                    target.add(permanent.getId(), game);\n                    if (target.doneChosing()) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInHand\n                || (target.getZone().equals(Zone.HAND) && (target instanceof TargetCard))) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID cardId : target.possibleTargets(sourceId, this.getId(), game)) {\n                Card card = game.getCard(cardId);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            while ((outcome.isGood() ? target.getTargets().size() < target.getMaxNumberOfTargets() : !target.isChosen())\n                    && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, null, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), null, game);\n                    cards.remove(pick);\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetCreatureOrPlayer) {\n            List<Permanent> targets;\n            TargetCreatureOrPlayer t = ((TargetCreatureOrPlayer) target);\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            } else {\n                targets = threats(randomOpponentId, sourceId, ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(abilityControllerId, permanent.getId(), null, game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(randomOpponentId, null, game)) {\n                    target.add(randomOpponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n        }\n\n        if (target instanceof TargetPermanentOrPlayer) {\n            List<Permanent> targets;\n            TargetPermanentOrPlayer t = ((TargetPermanentOrPlayer) target);\n            List<Permanent> ownedTargets = threats(abilityControllerId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());\n            List<Permanent> opponentTargets = threats(randomOpponentId, sourceId, ((FilterPermanentOrPlayer) t.getFilter()).getPermanentFilter(), game, target.getTargets());\n            if (outcome.isGood()) {\n                targets = ownedTargets;\n            } else {\n                targets = opponentTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, null, game)) {\n                    target.add(abilityControllerId, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(randomOpponentId, null, game)) {\n                    target.add(randomOpponentId, game);\n                    return true;\n                }\n            }\n            if (!target.isRequired(sourceId, game) || target.getNumberOfTargets() == 0) {\n                return false;\n            }\n            if (target.canTarget(randomOpponentId, null, game)) {\n                target.add(randomOpponentId, game);\n                return true;\n            }\n            if (target.canTarget(abilityControllerId, null, game)) {\n                target.add(abilityControllerId, game);\n                return true;\n            }\n            if (outcome.isGood()) { // no other valid targets so use a permanent\n                targets = opponentTargets;\n            } else {\n                targets = ownedTargets;\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(permanent.getId(), game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.add(permanent.getId(), game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                for (Card card : player.getGraveyard().getCards(game)) {\n                    if (target.canTarget(card.getId(), game)) {\n                        cards.add(card);\n                    }\n                }\n            }\n            for (Card card : cards) {\n                target.add(card.getId(), game);\n                if (target.isChosen()) {\n                    return true;\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInYourGraveyard) {\n            List<UUID> alreadyTargetted = target.getTargets();\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getGraveyard().getCards(game));\n            while (!cards.isEmpty()) {\n                Card card = pickTarget(cards, outcome, target, null, game);\n                if (card != null && alreadyTargetted != null && !alreadyTargetted.contains(card.getId())) {\n                    target.add(card.getId(), game);\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetSource) {\n            Set<UUID> targets;\n            TargetSource t = ((TargetSource) target);\n            targets = t.possibleTargets(sourceId, abilityControllerId, game);\n            for (UUID targetId : targets) {\n                MageObject targetObject = game.getObject(targetId);\n                if (targetObject != null) {\n                    List<UUID> alreadyTargetted = target.getTargets();\n                    if (t.canTarget(targetObject.getId(), game)) {\n                        if (alreadyTargetted != null && !alreadyTargetted.contains(targetObject.getId())) {\n                            target.add(targetObject.getId(), game);\n                            return true;\n                        }\n                    }\n                }\n            }\n            if (!target.isRequired(sourceId, game)) {\n                return false;\n            }\n            throw new IllegalStateException(\"TargetSource wasn't handled. class:\" + target.getClass().toString());\n        }\n\n        throw new IllegalStateException(\"Target wasn't handled. class:\" + target.getClass().toString());\n    }","commit_id":"c008b04965691b3115b458740e8af806e2c48414","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"chooseTarget: \" + outcome.toString() + \":\" + target.toString());\n        }\n        // sometimes a target selection can be made from a player that does not control the ability\n        UUID abilityControllerId = playerId;\n        if (target.getAbilityController() != null) {\n            abilityControllerId = target.getAbilityController();\n        }\n        UUID opponentId = game.getOpponents(abilityControllerId).iterator().next();\n        if (target instanceof TargetPlayer) {\n            if (outcome.isGood()) {\n                if (target.canTarget(abilityControllerId, abilityControllerId, source, game)) {\n                    target.addTarget(playerId, source, game);\n                    return true;\n                }\n                if (target.isRequired(source)) {\n                    if (target.canTarget(abilityControllerId, opponentId, source, game)) {\n                        target.addTarget(opponentId, source, game);\n                        return true;\n                    }\n                }\n            } else {\n                if (target.canTarget(abilityControllerId, opponentId, source, game)) {\n                    target.addTarget(opponentId, source, game);\n                    return true;\n                }\n                if (target.isRequired(source)) {\n                    if (target.canTarget(abilityControllerId, abilityControllerId, source, game)) {\n                        target.addTarget(abilityControllerId, source, game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetDiscard || target instanceof TargetCardInHand) {\n            if (outcome.isGood()) {\n                Cards cards = new CardsImpl(target.possibleTargets(source.getSourceId(), getId(), game));\n                ArrayList<Card> cardsInHand = new ArrayList<>(cards.getCards(game));\n                while (!target.isChosen()\n                        && target.possibleTargets(source.getSourceId(), getId(), game).size() > 0\n                        && target.getMaxNumberOfTargets() > target.getTargets().size()) {\n                    Card card = pickBestCard(cardsInHand, null, target, source, game);\n                    if (card != null) {\n                        if (target.canTarget(getId(), card.getId(), source, game)) {\n                            target.addTarget(card.getId(), source, game);\n                            cardsInHand.remove(card);\n                            if (target.isChosen()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            } else {\n                findPlayables(game);\n                if (unplayable.size() > 0) {\n                    for (int i = unplayable.size() - 1; i >= 0; i--) {\n                        if (target.canTarget(getId(), unplayable.values().toArray(new Card[0])[i].getId(), source, game)) {\n                            target.addTarget(unplayable.values().toArray(new Card[0])[i].getId(), source, game);\n                            if (target.isChosen()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                if (hand.size() > 0) {\n                    for (int i = 0; i < hand.size(); i++) {\n                        if (target.canTarget(getId(), hand.toArray(new UUID[0])[i], source, game)) {\n                            target.addTarget(hand.toArray(new UUID[0])[i], source, game);\n                            if (target.isChosen()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetControlledPermanent) {\n            List<Permanent> targets;\n            targets = threats(abilityControllerId, source.getSourceId(), ((TargetControlledPermanent) target).getFilter(), game, target.getTargets());\n            if (!outcome.isGood()) {\n                Collections.reverse(targets);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetControlledPermanent) target).canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    target.addTarget(permanent.getId(), source, game);\n                    if (target.getNumberOfTargets() <= target.getTargets().size() && (!outcome.isGood() || target.getMaxNumberOfTargets() <= target.getTargets().size())) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n\n        }\n        if (target instanceof TargetPermanent) {\n            List<Permanent> targets;\n            boolean outcomeTargets = true;\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, source == null ? null : source.getSourceId(), ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            } else {\n                targets = threats(opponentId, source == null ? null : source.getSourceId(), ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            }\n            if (targets.isEmpty() && target.isRequired(source)) {\n                targets = threats(null, source == null ? null : source.getSourceId(), ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                Collections.reverse(targets);\n                outcomeTargets = false;\n                //targets = game.getBattlefield().getActivePermanents(((TargetPermanent)target).getFilter(), playerId, game);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetPermanent) target).canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    target.addTarget(permanent.getId(), source, game);\n                    if (!outcomeTargets || target.getMaxNumberOfTargets() <= target.getTargets().size()) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetCreatureOrPlayer) {\n            List<Permanent> targets;\n            TargetCreatureOrPlayer t = ((TargetCreatureOrPlayer) target);\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, source.getSourceId(), ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            } else {\n                targets = threats(opponentId, source.getSourceId(), ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            }\n\n            if (targets.isEmpty()) {\n                if (outcome.isGood()) {\n                    if (target.canTarget(getId(), abilityControllerId, source, game)) {\n                        target.addTarget(abilityControllerId, source, game);\n                        return true;\n                    }\n                } else {\n                    if (target.canTarget(getId(), opponentId, source, game)) {\n                        target.addTarget(opponentId, source, game);\n                        return true;\n                    }\n                }\n            }\n\n            if (targets.isEmpty() && target.isRequired(source)) {\n                targets = game.getBattlefield().getActivePermanents(((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), playerId, game);\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.addTarget(permanent.getId(), source, game);\n                        return true;\n                    }\n                }\n            }\n\n            if (outcome.isGood()) {\n                if (target.canTarget(getId(), abilityControllerId, source, game)) {\n                    target.addTarget(abilityControllerId, source, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(getId(), opponentId, source, game)) {\n                    target.addTarget(opponentId, source, game);\n                    return true;\n                }\n            }\n\n            //if (!target.isRequired())\n            return false;\n        }\n        if (target instanceof TargetCardInGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                cards.addAll(player.getGraveyard().getCards(game));\n            }\n            Card card = pickTarget(cards, outcome, target, source, game);\n            if (card != null) {\n                target.addTarget(card.getId(), source, game);\n                return true;\n            }\n            //if (!target.isRequired())\n            return false;\n        }\n        if (target instanceof TargetCardInLibrary) {\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getLibrary().getCards(game));\n            Card card = pickTarget(cards, outcome, target, source, game);\n            if (card != null) {\n                target.addTarget(card.getId(), source, game);\n                return true;\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInYourGraveyard) {\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getGraveyard().getCards(game));\n            while (!target.isChosen() && !cards.isEmpty()) {\n                Card card = pickTarget(cards, outcome, target, source, game);\n                if (card != null) {\n                    target.addTarget(card.getId(), source, game);\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetSpell) {\n            if (game.getStack().size() > 0) {\n                Iterator<StackObject> it = game.getStack().iterator();\n                while (it.hasNext()) {\n                    StackObject o = it.next();\n                    if (o instanceof Spell && !source.getId().equals(o.getStackAbility().getId())) {\n                        target.addTarget(o.getId(), source, game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetSpellOrPermanent) {\n            // TODO: Also check if a spell should be selected\n            List<Permanent> targets;\n            boolean outcomeTargets = true;\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, source == null ? null : source.getSourceId(), ((TargetSpellOrPermanent) target).getPermanentFilter(), game, target.getTargets());\n            } else {\n                targets = threats(opponentId, source == null ? null : source.getSourceId(), ((TargetSpellOrPermanent) target).getPermanentFilter(), game, target.getTargets());\n            }\n            if (targets.isEmpty() && target.isRequired(source)) {\n                targets = threats(null, source == null ? null : source.getSourceId(), ((TargetSpellOrPermanent) target).getPermanentFilter(), game, target.getTargets());\n                Collections.reverse(targets);\n                outcomeTargets = false;\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetSpellOrPermanent) target).canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    target.addTarget(permanent.getId(), source, game);\n                    if (!outcomeTargets || target.getMaxNumberOfTargets() <= target.getTargets().size()) {\n                        return true;\n                    }\n                }\n            }\n            if (game.getStack().size() > 0) {\n                Iterator<StackObject> it = game.getStack().iterator();\n                while (it.hasNext()) {\n                    StackObject stackObject = it.next();\n                    if (stackObject instanceof Spell && source != null && !source.getId().equals(stackObject.getStackAbility().getId())) {\n                        if (((TargetSpellOrPermanent) target).getFilter().match(stackObject, game)) {\n                            target.addTarget(stackObject.getId(), source, game);\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInOpponentsGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID uuid : game.getOpponents(abilityControllerId)) {\n                Player player = game.getPlayer(uuid);\n                if (player != null) {\n                    cards.addAll(player.getGraveyard().getCards(game));\n                }\n            }\n            Card card = pickTarget(cards, outcome, target, source, game);\n            if (card != null) {\n                target.addTarget(card.getId(), source, game);\n                return true;\n            }\n            //if (!target.isRequired())\n            return false;\n        }\n        if (target instanceof TargetDefender) {\n            // TODO: Improve, now planeswalker is always chosen if it exits\n            List<Permanent> targets;\n            targets = game.getBattlefield().getActivePermanents(new FilterPlaneswalkerPermanent(), opponentId, game);\n            if (targets != null && !targets.isEmpty()) {\n                for (Permanent planeswalker : targets) {\n                    if (target.canTarget(getId(), planeswalker.getId(), source, game)) {\n                        target.addTarget(planeswalker.getId(), source, game);\n                    }\n                    if (target.isChosen()) {\n                        return true;\n                    }\n                }\n            }\n            if (!target.isChosen()) {\n                if (target.canTarget(getId(), opponentId, source, game)) {\n                    target.addTarget(opponentId, source, game);\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInASingleGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                cards.addAll(player.getGraveyard().getCards(game));\n            }\n            while (!target.isChosen() && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, source, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), source, game);\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInExile) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID uuid : ((TargetCardInExile) target).possibleTargets(source.getSourceId(), source.getControllerId(), game)) {\n                Card card = game.getCard(uuid);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            while (!target.isChosen() && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, source, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), source, game);\n                }\n            }\n            return target.isChosen();\n        }\n\n        throw new IllegalStateException(\"Target wasn't handled. class:\" + target.getClass().toString());\n    }","id":9514,"modified_method":"@Override\n    public boolean chooseTarget(Outcome outcome, Target target, Ability source, Game game) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"chooseTarget: \" + outcome.toString() + \":\" + target.toString());\n        }\n        // sometimes a target selection can be made from a player that does not control the ability\n        UUID abilityControllerId = playerId;\n        if (target.getAbilityController() != null) {\n            abilityControllerId = target.getAbilityController();\n        }\n        UUID randomOpponentId = getRandomOpponent(abilityControllerId, game);\n        if (target instanceof TargetPlayer) {\n            return setTargetPlayer(outcome, target, source, source.getSourceId(), abilityControllerId, randomOpponentId, game);\n        }\n\n        if (target instanceof TargetDiscard || target instanceof TargetCardInHand) {\n            if (outcome.isGood()) {\n                Cards cards = new CardsImpl(target.possibleTargets(source.getSourceId(), getId(), game));\n                ArrayList<Card> cardsInHand = new ArrayList<>(cards.getCards(game));\n                while (!target.isChosen()\n                        && target.possibleTargets(source.getSourceId(), getId(), game).size() > 0\n                        && target.getMaxNumberOfTargets() > target.getTargets().size()) {\n                    Card card = pickBestCard(cardsInHand, null, target, source, game);\n                    if (card != null) {\n                        if (target.canTarget(getId(), card.getId(), source, game)) {\n                            target.addTarget(card.getId(), source, game);\n                            cardsInHand.remove(card);\n                            if (target.isChosen()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            } else {\n                findPlayables(game);\n                if (unplayable.size() > 0) {\n                    for (int i = unplayable.size() - 1; i >= 0; i--) {\n                        if (target.canTarget(getId(), unplayable.values().toArray(new Card[0])[i].getId(), source, game)) {\n                            target.addTarget(unplayable.values().toArray(new Card[0])[i].getId(), source, game);\n                            if (target.isChosen()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                if (hand.size() > 0) {\n                    for (int i = 0; i < hand.size(); i++) {\n                        if (target.canTarget(getId(), hand.toArray(new UUID[0])[i], source, game)) {\n                            target.addTarget(hand.toArray(new UUID[0])[i], source, game);\n                            if (target.isChosen()) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetControlledPermanent) {\n            List<Permanent> targets;\n            targets = threats(abilityControllerId, source.getSourceId(), ((TargetControlledPermanent) target).getFilter(), game, target.getTargets());\n            if (!outcome.isGood()) {\n                Collections.reverse(targets);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetControlledPermanent) target).canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    target.addTarget(permanent.getId(), source, game);\n                    if (target.getNumberOfTargets() <= target.getTargets().size() && (!outcome.isGood() || target.getMaxNumberOfTargets() <= target.getTargets().size())) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n\n        }\n        if (target instanceof TargetPermanent) {\n            List<Permanent> targets;\n            boolean outcomeTargets = true;\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, source == null ? null : source.getSourceId(), ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            } else {\n                targets = threats(randomOpponentId, source == null ? null : source.getSourceId(), ((TargetPermanent) target).getFilter(), game, target.getTargets());\n            }\n            if (targets.isEmpty() && target.isRequired(source)) {\n                targets = threats(null, source == null ? null : source.getSourceId(), ((TargetPermanent) target).getFilter(), game, target.getTargets());\n                Collections.reverse(targets);\n                outcomeTargets = false;\n                //targets = game.getBattlefield().getActivePermanents(((TargetPermanent)target).getFilter(), playerId, game);\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetPermanent) target).canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    target.addTarget(permanent.getId(), source, game);\n                    if (!outcomeTargets || target.getMaxNumberOfTargets() <= target.getTargets().size()) {\n                        return true;\n                    }\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetCreatureOrPlayer) {\n            List<Permanent> targets;\n            TargetCreatureOrPlayer t = ((TargetCreatureOrPlayer) target);\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, source.getSourceId(), ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            } else {\n                targets = threats(randomOpponentId, source.getSourceId(), ((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), game, target.getTargets());\n            }\n\n            if (targets.isEmpty()) {\n                if (outcome.isGood()) {\n                    if (target.canTarget(getId(), abilityControllerId, source, game)) {\n                        target.addTarget(abilityControllerId, source, game);\n                        return true;\n                    }\n                } else {\n                    if (target.canTarget(getId(), randomOpponentId, source, game)) {\n                        target.addTarget(randomOpponentId, source, game);\n                        return true;\n                    }\n                }\n            }\n\n            if (targets.isEmpty() && target.isRequired(source)) {\n                targets = game.getBattlefield().getActivePermanents(((FilterCreatureOrPlayer) t.getFilter()).getCreatureFilter(), playerId, game);\n            }\n            for (Permanent permanent : targets) {\n                List<UUID> alreadyTargetted = target.getTargets();\n                if (t.canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    if (alreadyTargetted != null && !alreadyTargetted.contains(permanent.getId())) {\n                        target.addTarget(permanent.getId(), source, game);\n                        return true;\n                    }\n                }\n            }\n\n            if (outcome.isGood()) {\n                if (target.canTarget(getId(), abilityControllerId, source, game)) {\n                    target.addTarget(abilityControllerId, source, game);\n                    return true;\n                }\n            } else {\n                if (target.canTarget(getId(), randomOpponentId, source, game)) {\n                    target.addTarget(randomOpponentId, source, game);\n                    return true;\n                }\n            }\n\n            //if (!target.isRequired())\n            return false;\n        }\n        if (target instanceof TargetCardInGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                cards.addAll(player.getGraveyard().getCards(game));\n            }\n            Card card = pickTarget(cards, outcome, target, source, game);\n            if (card != null) {\n                target.addTarget(card.getId(), source, game);\n                return true;\n            }\n            //if (!target.isRequired())\n            return false;\n        }\n        if (target instanceof TargetCardInLibrary) {\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getLibrary().getCards(game));\n            Card card = pickTarget(cards, outcome, target, source, game);\n            if (card != null) {\n                target.addTarget(card.getId(), source, game);\n                return true;\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInYourGraveyard) {\n            List<Card> cards = new ArrayList<>(game.getPlayer(abilityControllerId).getGraveyard().getCards(game));\n            while (!target.isChosen() && !cards.isEmpty()) {\n                Card card = pickTarget(cards, outcome, target, source, game);\n                if (card != null) {\n                    target.addTarget(card.getId(), source, game);\n                }\n            }\n            return target.isChosen();\n        }\n        if (target instanceof TargetSpell) {\n            if (game.getStack().size() > 0) {\n                Iterator<StackObject> it = game.getStack().iterator();\n                while (it.hasNext()) {\n                    StackObject o = it.next();\n                    if (o instanceof Spell && !source.getId().equals(o.getStackAbility().getId())) {\n                        target.addTarget(o.getId(), source, game);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetSpellOrPermanent) {\n            // TODO: Also check if a spell should be selected\n            List<Permanent> targets;\n            boolean outcomeTargets = true;\n            if (outcome.isGood()) {\n                targets = threats(abilityControllerId, source == null ? null : source.getSourceId(), ((TargetSpellOrPermanent) target).getPermanentFilter(), game, target.getTargets());\n            } else {\n                targets = threats(randomOpponentId, source == null ? null : source.getSourceId(), ((TargetSpellOrPermanent) target).getPermanentFilter(), game, target.getTargets());\n            }\n            if (targets.isEmpty() && target.isRequired(source)) {\n                targets = threats(null, source == null ? null : source.getSourceId(), ((TargetSpellOrPermanent) target).getPermanentFilter(), game, target.getTargets());\n                Collections.reverse(targets);\n                outcomeTargets = false;\n            }\n            for (Permanent permanent : targets) {\n                if (((TargetSpellOrPermanent) target).canTarget(abilityControllerId, permanent.getId(), source, game)) {\n                    target.addTarget(permanent.getId(), source, game);\n                    if (!outcomeTargets || target.getMaxNumberOfTargets() <= target.getTargets().size()) {\n                        return true;\n                    }\n                }\n            }\n            if (game.getStack().size() > 0) {\n                Iterator<StackObject> it = game.getStack().iterator();\n                while (it.hasNext()) {\n                    StackObject stackObject = it.next();\n                    if (stackObject instanceof Spell && source != null && !source.getId().equals(stackObject.getStackAbility().getId())) {\n                        if (((TargetSpellOrPermanent) target).getFilter().match(stackObject, game)) {\n                            target.addTarget(stackObject.getId(), source, game);\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        if (target instanceof TargetCardInOpponentsGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID uuid : game.getOpponents(abilityControllerId)) {\n                Player player = game.getPlayer(uuid);\n                if (player != null) {\n                    cards.addAll(player.getGraveyard().getCards(game));\n                }\n            }\n            Card card = pickTarget(cards, outcome, target, source, game);\n            if (card != null) {\n                target.addTarget(card.getId(), source, game);\n                return true;\n            }\n            //if (!target.isRequired())\n            return false;\n        }\n        if (target instanceof TargetDefender) {\n            // TODO: Improve, now planeswalker is always chosen if it exits\n            List<Permanent> targets;\n            targets = game.getBattlefield().getActivePermanents(new FilterPlaneswalkerPermanent(), randomOpponentId, game);\n            if (targets != null && !targets.isEmpty()) {\n                for (Permanent planeswalker : targets) {\n                    if (target.canTarget(getId(), planeswalker.getId(), source, game)) {\n                        target.addTarget(planeswalker.getId(), source, game);\n                    }\n                    if (target.isChosen()) {\n                        return true;\n                    }\n                }\n            }\n            if (!target.isChosen()) {\n                if (target.canTarget(getId(), randomOpponentId, source, game)) {\n                    target.addTarget(randomOpponentId, source, game);\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInASingleGraveyard) {\n            List<Card> cards = new ArrayList<>();\n            for (Player player : game.getPlayers().values()) {\n                cards.addAll(player.getGraveyard().getCards(game));\n            }\n            while (!target.isChosen() && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, source, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), source, game);\n                }\n            }\n            return target.isChosen();\n        }\n\n        if (target instanceof TargetCardInExile) {\n            List<Card> cards = new ArrayList<>();\n            for (UUID uuid : ((TargetCardInExile) target).possibleTargets(source.getSourceId(), source.getControllerId(), game)) {\n                Card card = game.getCard(uuid);\n                if (card != null) {\n                    cards.add(card);\n                }\n            }\n            while (!target.isChosen() && !cards.isEmpty()) {\n                Card pick = pickTarget(cards, outcome, target, source, game);\n                if (pick != null) {\n                    target.addTarget(pick.getId(), source, game);\n                }\n            }\n            return target.isChosen();\n        }\n\n        throw new IllegalStateException(\"Target wasn't handled. class:\" + target.getClass().toString());\n    }","commit_id":"c008b04965691b3115b458740e8af806e2c48414","url":"https://github.com/magefree/mage"},{"original_method":"@Nullable\n  private List<AnalyzedToken> doGuessCompoundTag(String word) {\n    int dashIdx = word.lastIndexOf('-');\n    if( dashIdx == 0 || dashIdx == word.length() - 1 )\n      return null;\n\n    int firstDashIdx = word.indexOf('-');\n    if( dashIdx != firstDashIdx )\n      return null;\n\n    String leftWord = word.substring(0, dashIdx);\n    String rightWord = word.substring(dashIdx + 1);\n\n    List<TaggedWord> leftWdList = tagAsIsAndWithLowerCase(leftWord);\n\n\n    // стривай-бо, чекай-но, прийшов-таки, такий-от, такий-то\n\n    if( rightPartsWithLeftTagMap.containsKey(rightWord) ) {\n      if( leftWdList.isEmpty() )\n        return null;\n\n      Pattern leftTagRegex = rightPartsWithLeftTagMap.get(rightWord);\n      \n      List<AnalyzedToken> leftAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(leftWord, leftWdList);\n      List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>(leftAnalyzedTokens.size());\n      for (AnalyzedToken analyzedToken : leftAnalyzedTokens) {\n        String posTag = analyzedToken.getPOSTag();\n        if( posTag != null && leftTagRegex.matcher(posTag).matches() ) {\n          newAnalyzedTokens.add(new AnalyzedToken(word, posTag, analyzedToken.getLemma()));\n        }\n      }\n      \n      return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n    }\n\n\n    // 101-й, 100-річному\n\n    if( UkrainianTagger.NUMBER.matcher(leftWord).matches() ) {\n      List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>();\n      // e.g. 101-го\n      if( NUMR_ENDING_MAP.containsKey(rightWord) ) {\n        List<String> tags = NUMR_ENDING_MAP.get(rightWord);\n        for (String tag: tags) {\n          // TODO: shall it be numr or adj?\n          newAnalyzedTokens.add(new AnalyzedToken(word, IPOSTag.adj.getText()+tag, leftWord + \"-\" + \"й\"));\n        }\n      }\n      else {\n        List<TaggedWord> rightWdList = wordTagger.tag(rightWord);\n        if( rightWdList.isEmpty() )\n          return null;\n\n        List<AnalyzedToken> rightAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(rightWord, rightWdList);\n\n        // e.g. 100-річному\n        for (AnalyzedToken analyzedToken : rightAnalyzedTokens) {\n          if( analyzedToken.getPOSTag().startsWith(IPOSTag.adj.getText()) ) {\n            newAnalyzedTokens.add(new AnalyzedToken(word, analyzedToken.getPOSTag(), leftWord + \"-\" + analyzedToken.getLemma()));\n          }\n        }\n      }\n      return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n    }\n\n\n    // по-болгарськи, по-болгарському\n\n    if( leftWord.equalsIgnoreCase(\"по\") && rightWord.endsWith(\"ськи\") ) {\n      rightWord += \"й\";\n    }\n\n    List<TaggedWord> rightWdList = wordTagger.tag(rightWord);\n    if( rightWdList.isEmpty() )\n      return null;\n\n    List<AnalyzedToken> rightAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(rightWord, rightWdList);\n\n    if( leftWord.equalsIgnoreCase(\"по\") ) {\n      if( rightWord.endsWith(\"ому\") ) {\n        return poAdvMatch(word, rightAnalyzedTokens, ADJ_TAG_FOR_PO_ADV_MIS);\n      }\n      else if( rightWord.endsWith(\"ський\") ) {\n        return poAdvMatch(word, rightAnalyzedTokens, ADJ_TAG_FOR_PO_ADV_NAZ);\n      }\n      return null;\n    }\n\n\n    // майстер-класу\n    \n    if( dashPrefixes.contains( leftWord ) || dashPrefixes.contains( leftWord.toLowerCase() ) || DASH_PREFIX_LAT_PATTERN.matcher(leftWord).matches() ) {\n      return getNvPrefixNounMatch(word, rightAnalyzedTokens, leftWord);\n    }\n\n    \n    // пів-України\n\n    if( word.startsWith(\"пів-\") && Character.isUpperCase(word.charAt(4)) ) {\n      List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>(rightAnalyzedTokens.size());\n      \n      for (AnalyzedToken rightAnalyzedToken : rightAnalyzedTokens) {\n        String rightPosTag = rightAnalyzedToken.getPOSTag();\n\n        if( rightPosTag == null )\n          continue;\n\n        if( NOUN_SING_V_ROD_REGEX.matcher(rightPosTag).matches() ) {\n          for(String vid: PosTagHelper.VIDMINKY_MAP.keySet()) {\n            if( vid.equals(\"v_kly\") )\n              continue;\n            String posTag = rightPosTag.replace(\"v_rod\", vid);\n            newAnalyzedTokens.add(new AnalyzedToken(word, posTag, word));\n          }\n        }\n      }\n\n      return newAnalyzedTokens;\n    }\n\n\n    // Пенсильванія-авеню\n\n    if( Character.isUpperCase(leftWord.charAt(0)) && cityAvenue.contains(rightWord) ) {\n      if( leftWdList.isEmpty() )\n        return null;\n      \n      List<AnalyzedToken> leftAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(leftWord, leftWdList);\n      return cityAvenueMatch(word, leftAnalyzedTokens);\n    }\n\n\n    // вгору-вниз, лікар-гомеопат, жило-було\n\n    if( ! leftWdList.isEmpty() ) {\n      List<AnalyzedToken> leftAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(leftWord, leftWdList);\n\n      List<AnalyzedToken> tagMatch = tagMatch(word, leftAnalyzedTokens, rightAnalyzedTokens);\n      if( tagMatch != null ) {\n        return tagMatch;\n      }\n    }\n\n\n    // яскраво-барвистий...\n\n    if( O_ADJ_PATTERN.matcher(leftWord).matches() ) {\n      return oAdjMatch(word, rightAnalyzedTokens, leftWord);\n    }\n\n    debug_compound_unknown_write(word);\n    \n    return null;\n  }","id":9515,"modified_method":"@Nullable\n  private List<AnalyzedToken> doGuessCompoundTag(String word) {\n    int dashIdx = word.lastIndexOf('-');\n    if( dashIdx == 0 || dashIdx == word.length() - 1 )\n      return null;\n\n    int firstDashIdx = word.indexOf('-');\n    if( dashIdx != firstDashIdx )\n      return null;\n\n    String leftWord = word.substring(0, dashIdx);\n    String rightWord = word.substring(dashIdx + 1);\n\n\n    if( LEFT_INVALID.contains(leftWord.toLowerCase()) )\n      return null;\n\n\n    List<TaggedWord> leftWdList = tagAsIsAndWithLowerCase(leftWord);\n\n\n    // стривай-бо, чекай-но, прийшов-таки, такий-от, такий-то\n\n    if( rightPartsWithLeftTagMap.containsKey(rightWord) ) {\n      if( leftWdList.isEmpty() )\n        return null;\n\n      Pattern leftTagRegex = rightPartsWithLeftTagMap.get(rightWord);\n      \n      List<AnalyzedToken> leftAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(leftWord, leftWdList);\n      List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>(leftAnalyzedTokens.size());\n      for (AnalyzedToken analyzedToken : leftAnalyzedTokens) {\n        String posTag = analyzedToken.getPOSTag();\n        if( posTag != null && leftTagRegex.matcher(posTag).matches() ) {\n          newAnalyzedTokens.add(new AnalyzedToken(word, posTag, analyzedToken.getLemma()));\n        }\n      }\n      \n      return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n    }\n\n\n    // 101-й, 100-річному\n\n    if( UkrainianTagger.NUMBER.matcher(leftWord).matches() ) {\n      List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>();\n      // e.g. 101-го\n      if( NUMR_ENDING_MAP.containsKey(rightWord) ) {\n        List<String> tags = NUMR_ENDING_MAP.get(rightWord);\n        for (String tag: tags) {\n          // TODO: shall it be numr or adj?\n          newAnalyzedTokens.add(new AnalyzedToken(word, IPOSTag.adj.getText() + tag + \":&numr\", leftWord + \"-\" + \"й\"));\n        }\n      }\n      else {\n        List<TaggedWord> rightWdList = wordTagger.tag(rightWord);\n        if( rightWdList.isEmpty() )\n          return null;\n\n        List<AnalyzedToken> rightAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(rightWord, rightWdList);\n\n        // e.g. 100-річному\n        for (AnalyzedToken analyzedToken : rightAnalyzedTokens) {\n          if( analyzedToken.getPOSTag().startsWith(IPOSTag.adj.getText()) ) {\n            newAnalyzedTokens.add(new AnalyzedToken(word, analyzedToken.getPOSTag(), leftWord + \"-\" + analyzedToken.getLemma()));\n          }\n        }\n      }\n      return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n    }\n\n\n    // по-болгарськи, по-болгарському\n\n    if( leftWord.equalsIgnoreCase(\"по\") && rightWord.endsWith(\"ськи\") ) {\n      rightWord += \"й\";\n    }\n\n    List<TaggedWord> rightWdList = wordTagger.tag(rightWord);\n    if( rightWdList.isEmpty() )\n      return null;\n\n    List<AnalyzedToken> rightAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(rightWord, rightWdList);\n\n    if( leftWord.equalsIgnoreCase(\"по\") ) {\n      if( rightWord.endsWith(\"ому\") ) {\n        return poAdvMatch(word, rightAnalyzedTokens, ADJ_TAG_FOR_PO_ADV_MIS);\n      }\n      else if( rightWord.endsWith(\"ський\") ) {\n        return poAdvMatch(word, rightAnalyzedTokens, ADJ_TAG_FOR_PO_ADV_NAZ);\n      }\n      return null;\n    }\n\n\n    // exclude: Малишко-це, відносини-коли\n\n    if( ! leftWord.equalsIgnoreCase(rightWord) && PosTagHelper.hasPosTag(rightAnalyzedTokens, \"(part|conj).*|.*:&pron.*\") )\n      return null;\n\n\n\n    // майстер-класу\n    \n    if( dashPrefixes.contains( leftWord ) || dashPrefixes.contains( leftWord.toLowerCase() ) || DASH_PREFIX_LAT_PATTERN.matcher(leftWord).matches() ) {\n      return getNvPrefixNounMatch(word, rightAnalyzedTokens, leftWord);\n    }\n\n    \n    // пів-України\n\n    if( word.startsWith(\"пів-\") && Character.isUpperCase(word.charAt(4)) ) {\n      List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>(rightAnalyzedTokens.size());\n      \n      for (AnalyzedToken rightAnalyzedToken : rightAnalyzedTokens) {\n        String rightPosTag = rightAnalyzedToken.getPOSTag();\n\n        if( rightPosTag == null )\n          continue;\n\n        if( NOUN_SING_V_ROD_REGEX.matcher(rightPosTag).matches() ) {\n          for(String vid: PosTagHelper.VIDMINKY_MAP.keySet()) {\n            if( vid.equals(\"v_kly\") )\n              continue;\n            String posTag = rightPosTag.replace(\"v_rod\", vid);\n            newAnalyzedTokens.add(new AnalyzedToken(word, posTag, word));\n          }\n        }\n      }\n\n      return newAnalyzedTokens;\n    }\n\n\n    // Пенсильванія-авеню\n\n    if( Character.isUpperCase(leftWord.charAt(0)) && cityAvenue.contains(rightWord) ) {\n      if( leftWdList.isEmpty() )\n        return null;\n      \n      List<AnalyzedToken> leftAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(leftWord, leftWdList);\n      return cityAvenueMatch(word, leftAnalyzedTokens);\n    }\n\n\n\n    // don't allow: Донець-кий, зовнішньо-економічний, мас-штаби\n\n    List<AnalyzedToken> leftAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(leftWord, leftWdList);\n    \n    // allow га-га!\n\n    if( ! PosTagHelper.hasPosTag(leftAnalyzedTokens, \"intj.*\") ) {\n      String noDashWord = word.replace(\"-\", \"\");\n      List<TaggedWord> noDashWordList = tagAsIsAndWithLowerCase(noDashWord);\n      List<AnalyzedToken> noDashAnalyzedTokens = ukrainianTagger.asAnalyzedTokenListForTaggedWordsInternal(noDashWord, noDashWordList);\n\n      if( ! noDashAnalyzedTokens.isEmpty() )\n        return null;\n    }\n\n\n    // вгору-вниз, лікар-гомеопат, жило-було\n\n    if( ! leftWdList.isEmpty() ) {\n\n      List<AnalyzedToken> tagMatch = tagMatch(word, leftAnalyzedTokens, rightAnalyzedTokens);\n      if( tagMatch != null ) {\n        return tagMatch;\n      }\n    }\n\n\n    if( LEFT_O_ADJ_INVALID.contains(leftWord.toLowerCase()) )\n      return null;\n\n\n    // яскраво-барвистий...\n\n    if( O_ADJ_PATTERN.matcher(leftWord).matches() ) {\n      return oAdjMatch(word, rightAnalyzedTokens, leftWord);\n    }\n\n    debug_compound_unknown_write(word);\n    \n    return null;\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Nullable\n  private List<AnalyzedToken> oAdjMatch(String word, List<AnalyzedToken> analyzedTokens, String leftWord) {\n    List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>(analyzedTokens.size());\n\n    String leftBase = leftWord.substring(0, leftWord.length()-1);\n    if( ! LEFT_O_ADJ.contains(leftWord.toLowerCase(conversionLocale))\n        && tagBothCases(leftWord).isEmpty()            // яскраво для яскраво-барвистий\n        && tagBothCases(oToYj(leftWord)).isEmpty()  // кричущий для кричуще-яскравий\n        && tagBothCases(leftBase).isEmpty()         // паталог для паталого-анатомічний\n        && tagBothCases(leftBase + \"а\").isEmpty() ) // два для дво-триметровий\n      return null;\n    \n    for (AnalyzedToken analyzedToken : analyzedTokens) {\n      String posTag = analyzedToken.getPOSTag();\n      if( posTag.startsWith( IPOSTag.adj.getText() ) ) {\n        newAnalyzedTokens.add(new AnalyzedToken(word, posTag, leftWord + \"-\" + analyzedToken.getLemma()));\n      }\n    }\n    \n    return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n  }","id":9516,"modified_method":"@Nullable\n  private List<AnalyzedToken> oAdjMatch(String word, List<AnalyzedToken> analyzedTokens, String leftWord) {\n    List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>(analyzedTokens.size());\n\n    String leftBase = leftWord.substring(0, leftWord.length()-1);\n    \n    String extraTag = \"\";\n    if( ! LEFT_O_ADJ.contains(leftWord.toLowerCase(conversionLocale)) ) {\n\n    List<TaggedWord> taggedWords = tagBothCases(leftWord);            // яскраво для яскраво-барвистий\n    if( taggedWords.isEmpty() ) {\n      taggedWords = tagBothCases(oToYj(leftWord));  // кричущий для кричуще-яскравий\n    }\n    if( taggedWords.isEmpty() ) {\n      taggedWords = tagBothCases(leftBase);         // паталог для паталого-анатомічний\n    }\n    if( taggedWords.isEmpty() ) {\n      taggedWords = tagBothCases(leftBase + \"а\");   // два для дво-триметровий\n    }\n    if( taggedWords.isEmpty() )\n      return null;\n      \n      \n    for(TaggedWord taggedWord: taggedWords) {\n      if( taggedWord.getPosTag().contains(\":bad\") ) {\n        extraTag = \":bad\";\n        break;\n      }\n    }\n    }\n    \n    for (AnalyzedToken analyzedToken : analyzedTokens) {\n      String posTag = analyzedToken.getPOSTag();\n      if( posTag.startsWith( IPOSTag.adj.getText() ) ) {\n        newAnalyzedTokens.add(new AnalyzedToken(word, posTag + extraTag, leftWord.toLowerCase() + \"-\" + analyzedToken.getLemma()));\n      }\n    }\n    \n    return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Nullable\n  private List<AnalyzedToken> tagMatch(String word, List<AnalyzedToken> leftAnalyzedTokens, List<AnalyzedToken> rightAnalyzedTokens) {\n    List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>();\n    List<AnalyzedToken> newAnalyzedTokensAnimInanim = new ArrayList<>();\n    \n    String animInanimNotTagged = null;\n    \n    for (AnalyzedToken leftAnalyzedToken : leftAnalyzedTokens) {\n      String leftPosTag = leftAnalyzedToken.getPOSTag();\n      \n      if( leftPosTag == null || IPOSTag.contains(leftPosTag, IPOSTag.abbr.getText()) )\n        continue;\n\n      String leftPosTagExtra = \"\";\n      boolean leftNv = false;\n\n      if( leftPosTag.contains(NV_TAG) ) {\n        leftNv = true;\n        leftPosTag = leftPosTag.replace(NV_TAG, \"\");\n      }\n\n      Matcher matcher = EXTRA_TAGS.matcher(leftPosTag);\n      if( matcher.find() ) {\n        leftPosTagExtra += matcher.group();\n        leftPosTag = matcher.replaceAll(\"\");\n      }\n      if( leftPosTag.contains(COMPB_TAG) ) {\n        leftPosTag = leftPosTag.replace(COMPB_TAG, \"\");\n      }\n\n      for (AnalyzedToken rightAnalyzedToken : rightAnalyzedTokens) {\n        String rightPosTag = rightAnalyzedToken.getPOSTag();\n        \n        if( rightPosTag == null || IPOSTag.contains(rightPosTag, IPOSTag.abbr.getText()) )\n          continue;\n\n        String extraNvTag = \"\";\n        boolean rightNv = false;\n        if( rightPosTag.contains(NV_TAG) ) {\n          rightNv = true;\n          \n          if( leftNv ) {\n            extraNvTag += NV_TAG;\n          }\n        }\n\n        Matcher matcherR = EXTRA_TAGS.matcher(rightPosTag);\n        if( matcherR.find() ) {\n          rightPosTag = matcherR.replaceAll(\"\");\n        }\n        if( rightPosTag.contains(COMPB_TAG) ) {\n          rightPosTag = rightPosTag.replace(COMPB_TAG, \"\");\n        }\n        \n        if (leftPosTag.equals(rightPosTag) \n            && (IPOSTag.startsWith(leftPosTag, IPOSTag.numr, IPOSTag.adv, IPOSTag.adj, IPOSTag.verb)\n            || (IPOSTag.startsWith(leftPosTag, IPOSTag.excl) && leftAnalyzedToken.getLemma().equalsIgnoreCase(rightAnalyzedToken.getLemma())) ) ) {\n          newAnalyzedTokens.add(new AnalyzedToken(word, leftPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n        }\n        // noun-noun\n        else if ( leftPosTag.startsWith(IPOSTag.noun.getText()) && rightPosTag.startsWith(IPOSTag.noun.getText()) ) {\n          String agreedPosTag = getAgreedPosTag(leftPosTag, rightPosTag, leftNv);\n\n          if( agreedPosTag == null \n              && rightPosTag.startsWith(\"noun:inanim:m:v_naz\")\n              && isMinMax(rightAnalyzedToken.getToken()) ) {\n            agreedPosTag = leftPosTag;\n          }\n\n          if( agreedPosTag == null && ! isSameAnimStatus(leftPosTag, rightPosTag) ) {\n\n            agreedPosTag = tryAnimInanim(leftPosTag, rightPosTag, leftAnalyzedToken.getLemma(), rightAnalyzedToken.getLemma(), leftNv, rightNv);\n            \n            if( agreedPosTag == null ) {\n              animInanimNotTagged = leftPosTag.contains(\":anim\") ? \"anim-inanim\" : \"inanim-anim\";\n            }\n            else {\n              newAnalyzedTokensAnimInanim.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n              continue;\n            }\n          }\n          \n          if( agreedPosTag != null ) {\n            newAnalyzedTokens.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n          }\n        }\n        // numr-numr: один-два\n        else if ( leftPosTag.startsWith(IPOSTag.numr.getText()) && rightPosTag.startsWith(IPOSTag.numr.getText()) ) {\n            String agreedPosTag = getNumAgreedPosTag(leftPosTag, rightPosTag, leftNv);\n            if( agreedPosTag != null ) {\n              newAnalyzedTokens.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n            }\n        }\n        // noun-numr match\n        else if ( IPOSTag.startsWith(leftPosTag, IPOSTag.noun) && IPOSTag.startsWith(rightPosTag, IPOSTag.numr) ) {\n          // gender tags match\n          String leftGenderConj = PosTagHelper.getGenderConj(leftPosTag);\n          if( leftGenderConj != null && leftGenderConj.equals(PosTagHelper.getGenderConj(rightPosTag)) ) {\n            newAnalyzedTokens.add(new AnalyzedToken(word, leftPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n          }\n          else {\n            // (with different gender tags): сотні (:p:) - дві (:f:)\n            String agreedPosTag = getNumAgreedPosTag(leftPosTag, rightPosTag, leftNv);\n            if( agreedPosTag != null ) {\n              newAnalyzedTokens.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n            }\n          }\n        }\n        // noun-adj match: Буш-молодший, братів-православних, рік-два\n        else if( leftPosTag.startsWith(IPOSTag.noun.getText()) \n            && IPOSTag.startsWith(rightPosTag, IPOSTag.adj, IPOSTag.numr) ) {\n          \n          if( ! leftPosTag.contains(\":prop\")\n              || isJuniorSenior(leftAnalyzedToken, rightAnalyzedToken) ) { \n            String leftGenderConj = PosTagHelper.getGenderConj(leftPosTag);\n            if( leftGenderConj != null && leftGenderConj.equals(PosTagHelper.getGenderConj(rightPosTag)) ) {\n              newAnalyzedTokens.add(new AnalyzedToken(word, leftPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n            }\n          }\n        }\n      }\n    }\n    \n    if( newAnalyzedTokens.isEmpty() ) {\n      newAnalyzedTokens = newAnalyzedTokensAnimInanim;\n    }\n\n    if( animInanimNotTagged != null && newAnalyzedTokens.isEmpty() ) {\n      debug_compound_unknown_write(word + \" \" + animInanimNotTagged);\n    }\n    \n    return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n  }","id":9517,"modified_method":"@Nullable\n  private List<AnalyzedToken> tagMatch(String word, List<AnalyzedToken> leftAnalyzedTokens, List<AnalyzedToken> rightAnalyzedTokens) {\n    List<AnalyzedToken> newAnalyzedTokens = new ArrayList<>();\n    List<AnalyzedToken> newAnalyzedTokensAnimInanim = new ArrayList<>();\n    \n    String animInanimNotTagged = null;\n    \n    for (AnalyzedToken leftAnalyzedToken : leftAnalyzedTokens) {\n      String leftPosTag = leftAnalyzedToken.getPOSTag();\n      \n      if( leftPosTag == null || IPOSTag.contains(leftPosTag, IPOSTag.abbr.getText()) )\n        continue;\n\n      String leftPosTagExtra = \"\";\n      boolean leftNv = false;\n\n      if( leftPosTag.contains(NV_TAG) ) {\n        leftNv = true;\n        leftPosTag = leftPosTag.replace(NV_TAG, \"\");\n      }\n\n      Matcher matcher = EXTRA_TAGS.matcher(leftPosTag);\n      if( matcher.find() ) {\n        leftPosTagExtra += matcher.group();\n        leftPosTag = matcher.replaceAll(\"\");\n      }\n      if( leftPosTag.contains(COMPB_TAG) ) {\n        leftPosTag = leftPosTag.replace(COMPB_TAG, \"\");\n      }\n\n      for (AnalyzedToken rightAnalyzedToken : rightAnalyzedTokens) {\n        String rightPosTag = rightAnalyzedToken.getPOSTag();\n        \n        if( rightPosTag == null || IPOSTag.contains(rightPosTag, IPOSTag.abbr.getText()) )\n          continue;\n\n        String extraNvTag = \"\";\n        boolean rightNv = false;\n        if( rightPosTag.contains(NV_TAG) ) {\n          rightNv = true;\n          \n          if( leftNv ) {\n            extraNvTag += NV_TAG;\n          }\n        }\n\n        Matcher matcherR = EXTRA_TAGS.matcher(rightPosTag);\n        if( matcherR.find() ) {\n          rightPosTag = matcherR.replaceAll(\"\");\n        }\n        if( rightPosTag.contains(COMPB_TAG) ) {\n          rightPosTag = rightPosTag.replace(COMPB_TAG, \"\");\n        }\n        \n        if (leftPosTag.equals(rightPosTag) \n            && (IPOSTag.startsWith(leftPosTag, IPOSTag.numr, IPOSTag.adv, IPOSTag.adj, IPOSTag.verb)\n            || (IPOSTag.startsWith(leftPosTag, IPOSTag.intj) && leftAnalyzedToken.getLemma().equalsIgnoreCase(rightAnalyzedToken.getLemma())) ) ) {\n          newAnalyzedTokens.add(new AnalyzedToken(word, leftPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n        }\n        // noun-noun\n        else if ( leftPosTag.startsWith(IPOSTag.noun.getText()) && rightPosTag.startsWith(IPOSTag.noun.getText()) ) {\n\n        \t// discard чорний-чорний as noun:anim\n        \tif( leftAnalyzedToken.getToken().equalsIgnoreCase(rightAnalyzedToken.getToken())\n        \t\t\t&& leftPosTag.contains(TAG_ANIM) && rightPosTag.contains(TAG_ANIM) )\n        \t\tcontinue;\n        \t\n          String agreedPosTag = getAgreedPosTag(leftPosTag, rightPosTag, leftNv);\n\n          if( agreedPosTag == null \n              && rightPosTag.startsWith(\"noun:inanim:m:v_naz\")\n              && isMinMax(rightAnalyzedToken.getToken()) ) {\n            agreedPosTag = leftPosTag;\n          }\n\n          if( agreedPosTag == null && ! isSameAnimStatus(leftPosTag, rightPosTag) ) {\n\n            agreedPosTag = tryAnimInanim(leftPosTag, rightPosTag, leftAnalyzedToken.getLemma(), rightAnalyzedToken.getLemma(), leftNv, rightNv);\n            \n            if( agreedPosTag == null ) {\n              animInanimNotTagged = leftPosTag.contains(\":anim\") ? \"anim-inanim\" : \"inanim-anim\";\n            }\n            else {\n              newAnalyzedTokensAnimInanim.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n              continue;\n            }\n          }\n          \n          if( agreedPosTag != null ) {\n            newAnalyzedTokens.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n          }\n        }\n        // numr-numr: один-два\n        else if ( leftPosTag.startsWith(IPOSTag.numr.getText()) && rightPosTag.startsWith(IPOSTag.numr.getText()) ) {\n            String agreedPosTag = getNumAgreedPosTag(leftPosTag, rightPosTag, leftNv);\n            if( agreedPosTag != null ) {\n              newAnalyzedTokens.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n            }\n        }\n        // noun-numr match\n        else if ( IPOSTag.startsWith(leftPosTag, IPOSTag.noun) && IPOSTag.startsWith(rightPosTag, IPOSTag.numr) ) {\n          // gender tags match\n          String leftGenderConj = PosTagHelper.getGenderConj(leftPosTag);\n          if( leftGenderConj != null && leftGenderConj.equals(PosTagHelper.getGenderConj(rightPosTag)) ) {\n            newAnalyzedTokens.add(new AnalyzedToken(word, leftPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n          }\n          else {\n            // (with different gender tags): сотні (:p:) - дві (:f:)\n            String agreedPosTag = getNumAgreedPosTag(leftPosTag, rightPosTag, leftNv);\n            if( agreedPosTag != null ) {\n              newAnalyzedTokens.add(new AnalyzedToken(word, agreedPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n            }\n          }\n        }\n        // noun-adj match: Буш-молодший, рік-два\n        // не робимо братів-православних \u2014 загальний noun-adj дає забагато фальшивих спрацьовувань\n        else if( leftPosTag.startsWith(IPOSTag.noun.getText()) \n            && IPOSTag.startsWith(rightPosTag, IPOSTag.numr) \n                || (IPOSTag.startsWith(rightPosTag, IPOSTag.adj) && isJuniorSenior(leftAnalyzedToken, rightAnalyzedToken)) ) {\n          \n//          if( ! leftPosTag.contains(\":prop\")\n//              || isJuniorSenior(leftAnalyzedToken, rightAnalyzedToken) ) { \n          \t\n          \t// discard чорний-чорний as noun:anim\n//          \tif( leftAnalyzedToken.getToken().equalsIgnoreCase(rightAnalyzedToken.getToken()) )\n//          \t\tcontinue;\n\n            String leftGenderConj = PosTagHelper.getGenderConj(leftPosTag);\n            if( leftGenderConj != null && leftGenderConj.equals(PosTagHelper.getGenderConj(rightPosTag)) ) {\n              newAnalyzedTokens.add(new AnalyzedToken(word, leftPosTag + extraNvTag + leftPosTagExtra, leftAnalyzedToken.getLemma() + \"-\" + rightAnalyzedToken.getLemma()));\n            }\n  //        }\n        }\n      }\n    }\n\n    // remove duplicates\n    newAnalyzedTokens = new ArrayList<>(new LinkedHashSet<>(newAnalyzedTokens));\n    \n    if( newAnalyzedTokens.isEmpty() ) {\n      newAnalyzedTokens = newAnalyzedTokensAnimInanim;\n    }\n\n    if( animInanimNotTagged != null && newAnalyzedTokens.isEmpty() ) {\n      debug_compound_unknown_write(word + \" \" + animInanimNotTagged);\n    }\n    \n    return newAnalyzedTokens.isEmpty() ? null : newAnalyzedTokens;\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testMorfologikSpeller() throws IOException {\n    MorfologikUkrainianSpellerRule rule = new MorfologikUkrainianSpellerRule (TestTools.getMessages(\"uk\"), new Ukrainian());\n\n    JLanguageTool langTool = new JLanguageTool(new Ukrainian());\n\n    // correct sentences:\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"До вас прийде заввідділу!\")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\",\")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"123454\")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"До нас приїде The Beatles!\")).length);\n\n    // soft hyphen\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"піс\\u00ADні\")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"піс\\u00ADні піс\\u00ADні\")).length);\n\n    // non-breaking hyphen\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"ось\\u2011ось\")).length);\n\n    \n    //incorrect sentences:\n\n    RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\"атакуючий\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"шкляний\"));\n\n    assertEquals(1, matches.length);\n    assertEquals(\"скляний\", matches[0].getSuggestedReplacements().get(0));\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"а\")).length);\n\n    // mix alphabets\n    matches = rule.match(langTool.getAnalyzedSentence(\"прийдешнiй\"));   // latin 'i'\n\n    assertEquals(1, matches.length);\n    assertEquals(\"прийдешній\", matches[0].getSuggestedReplacements().get(0));\n\n    // кличний для неістот\n    matches = rule.match(langTool.getAnalyzedSentence(\"душе\"));\n\n    assertEquals(1, matches.length);\n\n    // розмовний інфінітив\n    matches = rule.match(langTool.getAnalyzedSentence(\"писать\"));\n\n    assertEquals(1, matches.length);\n    \n    // compounding\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"Жакет був синьо-жовтого кольору\")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"Він багато сидів на інтернет-форумах\")).length);\n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"Він багато сидів на інтермет-форумах\")).length);\n\n    \n    // dynamic tagging\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"екс-креветка\")).length);\n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"банд-формування.\")).length);\n\n\n    // abbreviations\n\n    RuleMatch[] match = rule.match(langTool.getAnalyzedSentence(\"Читання віршів Т.Г.Шевченко і Г.Тютюнника\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"Читання віршів Т. Г. Шевченко і Г. Тютюнника\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"Англі́йська мова (англ. English language, English) належить до германської групи\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"Англі́йська мова (англ English language, English) належить до германської групи\"));\n    assertEquals(1, match.length);\n\n  \n    match = rule.match(langTool.getAnalyzedSentence(\"100 тис. гривень\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"100 кв. м\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"100 км²\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"100 кв м\"));\n    assertEquals(1, Arrays.asList(match).size());\n  }","id":9518,"modified_method":"@Test\n  public void testMorfologikSpeller() throws IOException {\n    MorfologikUkrainianSpellerRule rule = new MorfologikUkrainianSpellerRule (TestTools.getMessages(\"uk\"), new Ukrainian());\n\n    JLanguageTool langTool = new JLanguageTool(new Ukrainian());\n\n    // correct sentences:\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"До вас прийде заввідділу!\")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\",\")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"123454\")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"До нас приїде The Beatles!\")).length);\n\n    // soft hyphen\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"піс\\u00ADні\")).length);\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"піс\\u00ADні піс\\u00ADні\")).length);\n\n    // non-breaking hyphen\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"ось\\u2011ось\")).length);\n\n    \n    //incorrect sentences:\n\n    RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\"атакуючий\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"шкляний\"));\n\n    assertEquals(1, matches.length);\n    assertEquals(\"скляний\", matches[0].getSuggestedReplacements().get(0));\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"а\")).length);\n\n    // mix alphabets\n    matches = rule.match(langTool.getAnalyzedSentence(\"прийдешнiй\"));   // latin 'i'\n\n    assertEquals(1, matches.length);\n    assertEquals(\"прийдешній\", matches[0].getSuggestedReplacements().get(0));\n\n    // кличний для неістот\n    matches = rule.match(langTool.getAnalyzedSentence(\"душе\"));\n\n    assertEquals(1, matches.length);\n\n    // розмовний інфінітив\n    matches = rule.match(langTool.getAnalyzedSentence(\"писать\"));\n\n    assertEquals(1, matches.length);\n    \n    // compounding\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"Жакет був синьо-жовтого кольору\")).length);\n\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"Він багато сидів на інтернет-форумах\")).length);\n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"Він багато сидів на інтермет-форумах\")).length);\n\n    \n    // dynamic tagging\n    assertEquals(0, rule.match(langTool.getAnalyzedSentence(\"екс-креветка\")).length);\n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"банд-формування.\")).length);\n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"учбово-виховного\")).length);\n\n    // abbreviations\n\n    RuleMatch[] match = rule.match(langTool.getAnalyzedSentence(\"Читання віршів Т.Г.Шевченко і Г.Тютюнника\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"Читання віршів Т. Г. Шевченко і Г. Тютюнника\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"Англі́йська мова (англ. English language, English) належить до германської групи\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"Англі́йська мова (англ English language, English) належить до германської групи\"));\n    assertEquals(1, match.length);\n\n  \n    match = rule.match(langTool.getAnalyzedSentence(\"100 тис. гривень\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"100 кв. м\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"100 км²\"));\n    assertEquals(new ArrayList<RuleMatch>(), Arrays.asList(match));\n\n    match = rule.match(langTool.getAnalyzedSentence(\"100 кв м\"));\n    assertEquals(1, Arrays.asList(match).size());\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public static boolean hasPosTag(AnalyzedTokenReadings analyzedTokenReadings, String posTagRegex) {\n    for(AnalyzedToken analyzedToken: analyzedTokenReadings) {\n      if( hasPosTag(analyzedToken, posTagRegex) )\n        return true;\n    }\n    return false;\n  }","id":9519,"modified_method":"public static boolean hasPosTag(AnalyzedTokenReadings analyzedTokenReadings, String posTagRegex) {\n    return hasPosTag(analyzedTokenReadings.getReadings(), posTagRegex);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public final RuleMatch[] match(AnalyzedSentence text) {\n    List<RuleMatch> ruleMatches = new ArrayList<>();\n    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();    \n    boolean insideMultiword = false;\n\n    AnalyzedTokenReadings reqTokenReadings = null;\n    for (int i = 0; i < tokens.length; i++) {\n      AnalyzedTokenReadings tokenReadings = tokens[i];\n\n      String posTag = tokenReadings.getAnalyzedToken(0).getPOSTag();\n\n      //TODO: skip conj напр. «бодай»\n\n      if (posTag == null\n          || posTag.contains(IPOSTag.unknown.getText())\n          || posTag.equals(JLanguageTool.SENTENCE_START_TAGNAME) ){\n        reqTokenReadings = null;\n        continue;\n      }\n\n      // first token is always SENT_START\n      String thisToken = tokenReadings.getToken();\n      if( i > 1 && thisToken.length() == 1 && Character.isUpperCase(thisToken.charAt(0)) \n          && tokenReadings.isWhitespaceBefore() && ! tokens[i-1].getToken().matches(\"[:\u2014\u2013-]\")) {  // часто вживають укр. В замість лат.: гепатит В\n        reqTokenReadings = null;\n        continue;\n      }\n\n      AnalyzedToken multiwordReqToken = getMultiwordToken(tokenReadings);\n      if( multiwordReqToken != null ) {\n        String mwPosTag = multiwordReqToken.getPOSTag();\n        if( mwPosTag.startsWith(\"<\/\") ) {\n          insideMultiword = false;\n        }\n        else {\n          insideMultiword = true;\n        }\n        \n        if (mwPosTag.startsWith(\"<\/\") && mwPosTag.contains(REQUIRE_VIDMINOK_SUBSTR)) { // напр. \"згідно з\"\n          posTag = multiwordReqToken.getPOSTag();\n          reqTokenReadings = tokenReadings;\n          continue;\n        }\n        else {\n          if( ! mwPosTag.contains(\"adv\") && ! mwPosTag.contains(\"insert\") ) {\n            reqTokenReadings = null;\n          }\n          continue;\n        }\n      }\n      \n      if( insideMultiword ) {\n        continue;\n      }\n\n      String token = tokenReadings.getAnalyzedToken(0).getToken();\n      if( posTag.contains(REQUIRE_VIDMINOK_SUBSTR) && tokenReadings.getReadingsLength() == 1 ) {\n        String prep = token;\n\n        if( prep.equals(\"за\") && reverseSearch(tokens, i, \"що\") ) // TODO: move to disambiguator\n          continue;\n\n        if( prep.equalsIgnoreCase(\"понад\") )\n          continue;\n\n        if( (prep.equalsIgnoreCase(\"окрім\") || prep.equalsIgnoreCase(\"крім\"))\n            && tokens.length > i+1 && tokens[i+1].getAnalyzedToken(0).getToken().equalsIgnoreCase(\"як\") ) {\n          reqTokenReadings = null;\n          continue;\n        }\n\n        reqTokenReadings = tokenReadings;\n        continue;\n      }\n\n      if( reqTokenReadings == null )\n        continue;\n\n\n      // Do actual check\n\n      List<String> posTagsToFind = new ArrayList<>();\n      String reqPosTag = reqTokenReadings.getAnalyzedToken(0).getPOSTag();\n      String prep = reqTokenReadings.getAnalyzedToken(0).getLemma();\n      \n//      AnalyzedToken multiwordToken = getMultiwordToken(tokenReadings);\n//      if( multiwordToken != null ) {\n//        reqTokenReadings = null;\n//        continue;\n//      }\n\n      //TODO: for numerics only v_naz\n      if( prep.equalsIgnoreCase(\"понад\") ) { //&& tokenReadings.getAnalyzedToken(0).getPOSTag().equals(IPOSTag.numr) ) { \n        posTagsToFind.add(\"v_naz\");\n      }\n      else if( prep.equalsIgnoreCase(\"замість\") ) {\n        posTagsToFind.add(\"v_naz\");\n      }\n\n      Matcher matcher = REQUIRE_VIDMINOK_REGEX.matcher(reqPosTag);\n      while( matcher.find() ) {\n        posTagsToFind.add(matcher.group(1));\n      }\n\n      for(AnalyzedToken readingToken: tokenReadings) {\n        if( IPOSTag.numr.match(readingToken.getPOSTag()) ) {\n          posTagsToFind.add(\"v_naz\");  // TODO: only if noun is following?\n          break;\n        }\n      }\n\n      //      System.out.println(\"For \" + tokenReadings + \" to match \" + posTagsToFind + \" of \" + reqTokenReadings.getToken());\n      if( ! getReadingWithVidmPosTag(posTagsToFind, tokenReadings) ) {\n        if( isTokenToSkip(tokenReadings) )\n          continue;\n\n//        if( isTokenToIgnore(tokenReadings) ) {\n//          reqTokenReadings = null;\n//          continue;\n//        }\n\n\n        //TODO: only for subset: президенти/депутати/мери/гості... or by verb піти/йти/балотуватися/записатися...\n        if( prep.equalsIgnoreCase(\"в\") || prep.equalsIgnoreCase(\"у\") || prep.equals(\"межи\") || prep.equals(\"між\") || prep.equals(\"на\") ) {\n          if( PosTagHelper.hasPosTag(tokenReadings, \"noun:anim.*:p:v_naz[^&]*\") ) { // but not &pron:\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        if (prep.equalsIgnoreCase(\"на\")) {\n          // 1) на (свято) Купала, на (вулиці) Мазепи, на (вулиці) Тюльпанів\n          if ((Character.isUpperCase(token.charAt(0)) && posTag.matches(\"noun.*?:.:v_rod.*\"))\n                // 2) поміняти ім'я на Захар; поміняв Іван на Петро\n                || (posTag.matches(\".*[fl]name.*\")\n                    && ((i > 1 && NAMES.contains(tokens[i-2].getAnalyzedToken(0).getToken()))\n                        || (i > 2 && NAMES.contains(tokens[i-3].getAnalyzedToken(0).getLemma()))))) {\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        if( prep.equalsIgnoreCase(\"з\") ) {\n          if( token.equals(\"рана\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n        \n        if( prep.equalsIgnoreCase(\"від\") ) {\n          if( token.equalsIgnoreCase(\"а\") || token.equals(\"рана\") || token.equals(\"корки\") || token.equals(\"мала\") ) {  // корки/мала ловиться іншим правилом\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n        else if( prep.equalsIgnoreCase(\"до\") ) {\n          if( token.equalsIgnoreCase(\"я\") || token.equals(\"корки\") || token.equals(\"велика\") ) {  // корки/велика ловиться іншим правилом\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        // exceptions\n        if( tokens.length > i+1 ) {\n          //      if( tokens.length > i+1 && Character.isUpperCase(tokenReadings.getAnalyzedToken(0).getToken().charAt(0))\n          //        && hasRequiredPosTag(Arrays.asList(\"v_naz\"), tokenReadings)\n          //        && Character.isUpperCase(tokens[i+1].getAnalyzedToken(0).getToken().charAt(0)) )\n          //          continue; // \"у Конан Дойла\", \"у Робін Гуда\"\n\n          if( isCapitalized( token ) \n              && STREETS.contains( tokens[i+1].getAnalyzedToken(0).getToken()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( PosTagHelper.hasPosTag(tokens[i+1], \"num.*\")\n              && (token.equals(\"мінус\") || token.equals(\"плюс\")\n                  || token.equals(\"мінімум\") || token.equals(\"максимум\") ) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          // на мохом стеленому дні - пропускаємо «мохом»\n          if( PosTagHelper.hasPosTag(tokenReadings, \"noun.*?:.:v_oru.*\")\n              && tokens[i+1].hasPartialPosTag(\"adjp\") ) {\n            continue;\n          }\n          \n          if( (prep.equalsIgnoreCase(\"через\") || prep.equalsIgnoreCase(\"на\"))  // років 10, відсотки 3-4\n              && (posTag.startsWith(\"noun:inanim:p:v_naz\") || posTag.startsWith(\"noun:inanim:p:v_rod\")) // token.equals(\"років\") \n              && IPOSTag.isNum(tokens[i+1].getAnalyzedToken(0).getPOSTag()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( (token.equals(\"вами\") || token.equals(\"тобою\") || token.equals(\"їми\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"ж\") ) {\n            continue;\n          }\n          if( (token.equals(\"собі\") || token.equals(\"йому\") || token.equals(\"їм\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"подібн\") ) {\n            continue;\n          }\n          if( (token.equals(\"усім\") || token.equals(\"всім\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"відом\") ) {\n            continue;\n          }\n\n          if( prep.equalsIgnoreCase(\"до\") && token.equals(\"схід\") \n                && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"сонця\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n          \n          if( tokens[i+1].getAnalyzedToken(0).getToken().equals(\"«\") \n              && tokens[i].getAnalyzedToken(0).getPOSTag().contains(\":abbr\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( tokens.length > i+2 ) {\n            // спиралося на місячної давнини рішення\n            if (/*prep.equalsIgnoreCase(\"на\") &&*/ posTag.matches(\"adj.*:[mfn]:v_rod.*\")) {\n              String gender = PosTagHelper.getGender(posTag);\n              if( gender == null ) {\n//                System.err.println(\"unknown gender for \" + token);\n              }\n              \n              if ( PosTagHelper.hasPosTag(tokens[i+1], \"noun.*:\"+gender+\":v_rod.*\")) {\n                i += 1;\n                continue;\n              }\n            }\n\n            if ((token.equals(\"нікому\") || token.equals(\"ніким\") || token.equals(\"нічим\") || token.equals(\"нічому\")) \n                && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"не\")) {\n              //          reqTokenReadings = null;\n              continue;\n            }\n//            // спиралося на місячної давнини рішення\n//            if (prep.equalsIgnoreCase(\"на\") && posTag.matches(\"adj.*:[mfn]:v_rod.*\")) {\n//              String gender = PosTagHelper.getGender(posTag);\n//              if ( hasPosTag(tokens[i+1], \"noun.*:\"+gender+\":v_rod.*\")) {\n//                i+=1;\n//                continue;\n//              }\n//            }\n          }\n        }\n\n        RuleMatch potentialRuleMatch = createRuleMatch(tokenReadings, reqTokenReadings, posTagsToFind);\n        ruleMatches.add(potentialRuleMatch);\n      }\n\n      reqTokenReadings = null;\n    }\n\n    return toRuleMatchArray(ruleMatches);\n  }","id":9520,"modified_method":"@Override\n  public final RuleMatch[] match(AnalyzedSentence text) {\n    List<RuleMatch> ruleMatches = new ArrayList<>();\n    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();    \n    boolean insideMultiword = false;\n\n    AnalyzedTokenReadings reqTokenReadings = null;\n    for (int i = 0; i < tokens.length; i++) {\n      AnalyzedTokenReadings tokenReadings = tokens[i];\n\n      String posTag = tokenReadings.getAnalyzedToken(0).getPOSTag();\n\n      //TODO: skip conj напр. «бодай»\n\n      if (posTag == null\n          || posTag.contains(IPOSTag.unknown.getText())\n          || posTag.equals(JLanguageTool.SENTENCE_START_TAGNAME) ){\n        reqTokenReadings = null;\n        continue;\n      }\n\n      // first token is always SENT_START\n      String thisToken = tokenReadings.getToken();\n      if( i > 1 && thisToken.length() == 1 && Character.isUpperCase(thisToken.charAt(0)) \n          && tokenReadings.isWhitespaceBefore() && ! tokens[i-1].getToken().matches(\"[:\u2014\u2013-]\")) {  // часто вживають укр. В замість лат.: гепатит В\n        reqTokenReadings = null;\n        continue;\n      }\n\n      AnalyzedToken multiwordReqToken = getMultiwordToken(tokenReadings);\n      if( multiwordReqToken != null ) {\n        String mwPosTag = multiwordReqToken.getPOSTag();\n        if( mwPosTag.startsWith(\"<\/\") ) {\n          insideMultiword = false;\n        }\n        else {\n          insideMultiword = true;\n        }\n        \n        if (mwPosTag.startsWith(\"<\/\") && mwPosTag.contains(REQUIRE_VIDMINOK_SUBSTR)) { // напр. \"згідно з\"\n          posTag = multiwordReqToken.getPOSTag();\n          reqTokenReadings = tokenReadings;\n          continue;\n        }\n        else {\n          if( ! mwPosTag.contains(\"adv\") && ! mwPosTag.contains(\"insert\") ) {\n            reqTokenReadings = null;\n          }\n          continue;\n        }\n      }\n      \n      if( insideMultiword ) {\n        continue;\n      }\n\n      String token = tokenReadings.getAnalyzedToken(0).getToken();\n      if( posTag.contains(REQUIRE_VIDMINOK_SUBSTR) && tokenReadings.getReadingsLength() == 1 ) {\n        String prep = token;\n\n        if( prep.equals(\"за\") && reverseSearch(tokens, i, \"що\") ) // TODO: move to disambiguator\n          continue;\n\n        if( prep.equalsIgnoreCase(\"понад\") )\n          continue;\n\n        if( (prep.equalsIgnoreCase(\"окрім\") || prep.equalsIgnoreCase(\"крім\"))\n            && tokens.length > i+1 && tokens[i+1].getAnalyzedToken(0).getToken().equalsIgnoreCase(\"як\") ) {\n          reqTokenReadings = null;\n          continue;\n        }\n\n        reqTokenReadings = tokenReadings;\n        continue;\n      }\n\n      if( reqTokenReadings == null )\n        continue;\n\n\n      // Do actual check\n\n      List<String> posTagsToFind = new ArrayList<>();\n      String reqPosTag = reqTokenReadings.getAnalyzedToken(0).getPOSTag();\n      String prep = reqTokenReadings.getAnalyzedToken(0).getLemma();\n      \n//      AnalyzedToken multiwordToken = getMultiwordToken(tokenReadings);\n//      if( multiwordToken != null ) {\n//        reqTokenReadings = null;\n//        continue;\n//      }\n\n      //TODO: for numerics only v_naz\n//      if( prep.equalsIgnoreCase(\"понад\") ) { //&& tokenReadings.getAnalyzedToken(0).getPOSTag().equals(IPOSTag.numr) ) { \n//        posTagsToFind.add(\"v_naz\");\n//      }\n//      else \n      if( prep.equalsIgnoreCase(\"замість\") ) {\n        posTagsToFind.add(\"v_naz\");\n      }\n\n      Matcher matcher = REQUIRE_VIDMINOK_REGEX.matcher(reqPosTag);\n      while( matcher.find() ) {\n        posTagsToFind.add(matcher.group(1));\n      }\n\n      for(AnalyzedToken readingToken: tokenReadings) {\n        if( IPOSTag.numr.match(readingToken.getPOSTag()) ) {\n          posTagsToFind.add(\"v_naz\");  // TODO: only if noun is following?\n          break;\n        }\n      }\n\n      //      System.out.println(\"For \" + tokenReadings + \" to match \" + posTagsToFind + \" of \" + reqTokenReadings.getToken());\n      if( ! getReadingWithVidmPosTag(posTagsToFind, tokenReadings) ) {\n        if( isTokenToSkip(tokenReadings) )\n          continue;\n\n//        if( isTokenToIgnore(tokenReadings) ) {\n//          reqTokenReadings = null;\n//          continue;\n//        }\n\n\n        //TODO: only for subset: президенти/депутати/мери/гості... or by verb піти/йти/балотуватися/записатися...\n        if( prep.equalsIgnoreCase(\"в\") || prep.equalsIgnoreCase(\"у\") || prep.equals(\"межи\") || prep.equals(\"між\") || prep.equals(\"на\") ) {\n          if( PosTagHelper.hasPosTag(tokenReadings, \"noun:anim.*:p:v_naz[^&]*\") ) { // but not &pron:\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        if (prep.equalsIgnoreCase(\"на\")) {\n          // 1) на (свято) Купала, на (вулиці) Мазепи, на (вулиці) Тюльпанів\n          if ((Character.isUpperCase(token.charAt(0)) && posTag.matches(\"noun.*?:.:v_rod.*\"))\n                // 2) поміняти ім'я на Захар; поміняв Іван на Петро\n                || (posTag.matches(\".*[fl]name.*\")\n                    && ((i > 1 && NAMES.contains(tokens[i-2].getAnalyzedToken(0).getToken()))\n                        || (i > 2 && NAMES.contains(tokens[i-3].getAnalyzedToken(0).getLemma()))))) {\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        if( prep.equalsIgnoreCase(\"з\") ) {\n          if( token.equals(\"рана\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n        \n        if( prep.equalsIgnoreCase(\"від\") ) {\n          if( token.equalsIgnoreCase(\"а\") || token.equals(\"рана\") || token.equals(\"корки\") || token.equals(\"мала\") ) {  // корки/мала ловиться іншим правилом\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n        else if( prep.equalsIgnoreCase(\"до\") ) {\n          if( token.equalsIgnoreCase(\"я\") || token.equals(\"корки\") || token.equals(\"велика\") ) {  // корки/велика ловиться іншим правилом\n            reqTokenReadings = null;\n            continue;\n          }\n        }\n\n        // exceptions\n        if( tokens.length > i+1 ) {\n          //      if( tokens.length > i+1 && Character.isUpperCase(tokenReadings.getAnalyzedToken(0).getToken().charAt(0))\n          //        && hasRequiredPosTag(Arrays.asList(\"v_naz\"), tokenReadings)\n          //        && Character.isUpperCase(tokens[i+1].getAnalyzedToken(0).getToken().charAt(0)) )\n          //          continue; // \"у Конан Дойла\", \"у Робін Гуда\"\n\n          if( isCapitalized( token ) \n              && STREETS.contains( tokens[i+1].getAnalyzedToken(0).getToken()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( PosTagHelper.hasPosTag(tokens[i+1], \"num.*\")\n              && (token.equals(\"мінус\") || token.equals(\"плюс\")\n                  || token.equals(\"мінімум\") || token.equals(\"максимум\") ) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          // на мохом стеленому дні - пропускаємо «мохом»\n          if( PosTagHelper.hasPosTag(tokenReadings, \"noun.*?:.:v_oru.*\")\n              && tokens[i+1].hasPartialPosTag(\"adjp\") ) {\n            continue;\n          }\n          \n          if( (prep.equalsIgnoreCase(\"через\") || prep.equalsIgnoreCase(\"на\"))  // років 10, відсотки 3-4\n              && (posTag.startsWith(\"noun:inanim:p:v_naz\") || posTag.startsWith(\"noun:inanim:p:v_rod\")) // token.equals(\"років\") \n              && IPOSTag.isNum(tokens[i+1].getAnalyzedToken(0).getPOSTag()) ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( (token.equals(\"вами\") || token.equals(\"тобою\") || token.equals(\"їми\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"ж\") ) {\n            continue;\n          }\n          if( (token.equals(\"собі\") || token.equals(\"йому\") || token.equals(\"їм\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"подібн\") ) {\n            continue;\n          }\n          if( (token.equals(\"усім\") || token.equals(\"всім\"))\n              && tokens[i+1].getAnalyzedToken(0).getToken().startsWith(\"відом\") ) {\n            continue;\n          }\n\n          if( prep.equalsIgnoreCase(\"до\") && token.equals(\"схід\") \n                && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"сонця\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n          \n          if( tokens[i+1].getAnalyzedToken(0).getToken().equals(\"«\") \n              && tokens[i].getAnalyzedToken(0).getPOSTag().contains(\":abbr\") ) {\n            reqTokenReadings = null;\n            continue;\n          }\n\n          if( tokens.length > i+2 ) {\n            // спиралося на місячної давнини рішення\n            if (/*prep.equalsIgnoreCase(\"на\") &&*/ PosTagHelper.hasPosTag(tokenReadings, \"adj.*:[mfn]:v_rod.*\")) {\n              String genders = PosTagHelper.getGenders(tokenReadings, \"adj.*:[mfn]:v_rod.*\");\n              \n              if ( PosTagHelper.hasPosTag(tokens[i+1], \"noun.*:[\"+genders+\"]:v_rod.*\")) {\n                i += 1;\n                continue;\n              }\n            }\n\n            if ((token.equals(\"нікому\") || token.equals(\"ніким\") || token.equals(\"нічим\") || token.equals(\"нічому\")) \n                && tokens[i+1].getAnalyzedToken(0).getToken().equals(\"не\")) {\n              //          reqTokenReadings = null;\n              continue;\n            }\n//            // спиралося на місячної давнини рішення\n//            if (prep.equalsIgnoreCase(\"на\") && posTag.matches(\"adj.*:[mfn]:v_rod.*\")) {\n//              String gender = PosTagHelper.getGender(posTag);\n//              if ( hasPosTag(tokens[i+1], \"noun.*:\"+gender+\":v_rod.*\")) {\n//                i+=1;\n//                continue;\n//              }\n//            }\n          }\n        }\n\n        RuleMatch potentialRuleMatch = createRuleMatch(tokenReadings, reqTokenReadings, posTagsToFind);\n        ruleMatches.add(potentialRuleMatch);\n      }\n\n      reqTokenReadings = null;\n    }\n\n    return toRuleMatchArray(ruleMatches);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testRule() throws IOException {\n\n    // correct sentences:\n    assertEmptyMatch(\"без повного\");\n    assertEmptyMatch(\"без неба\");\n\n    assertEmptyMatch(\"по авеню\");\n\n    assertEmptyMatch(\"що за ганебна непослідовність?\");\n\n    assertEmptyMatch(\"щодо власне людини\");\n    assertEmptyMatch(\"у загалом симпатичній повістині\");\n\n    assertEmptyMatch(\"понад половина людей\");\n    assertEmptyMatch(\"з понад ста людей\");\n\n    assertEmptyMatch(\"по нервах\");\n    assertEmptyMatch(\"з особливою увагою\");\n\n    assertEmptyMatch(\"щодо бодай гіпотетичної здатності\");\n    assertEmptyMatch(\"хто їде на заробітки за кордон\");\n\n    assertEmptyMatch(\"піти в президенти\");\n    assertEmptyMatch(\"піти межі люди\");\n\n    assertEmptyMatch(\"що то була за людина\");\n    assertEmptyMatch(\"що за людина\");\n    assertEmptyMatch(\"що балотувався за цім округом\");\n\n    assertEmptyMatch(\"на дому\");\n\n    assertEmptyMatch(\"окрім як українці\");\n    assertEmptyMatch(\"за двісті метрів\");\n    assertEmptyMatch(\"переходить у Фрідріх Штрассе\");\n    assertEmptyMatch(\"від мінус 1 до плюс 1\");\n    assertEmptyMatch(\"до мінус сорока град\");\n    assertEmptyMatch(\"до мінус шістдесяти\");\n    assertEmptyMatch(\"через років 10\");\n    assertEmptyMatch(\"на хвилин 9-10\");\n    assertEmptyMatch(\"співпрацювати із собі подібними\");\n    assertEmptyMatch(\"через усім відомі причини\");\n    assertEmptyMatch(\"через нікому не відомі причини\");\n    assertEmptyMatch(\"прийшли до ВАТ «Кривий Ріг цемент»\");\n    assertEmptyMatch(\"від А до Я\");\n    assertEmptyMatch(\"до та після\");\n    assertEmptyMatch(\"до схід сонця\");\n    assertEmptyMatch(\"з рана до вечора, від рана до ночі\");\n    assertEmptyMatch(\"до НАК «Надра України»\");\n    assertEmptyMatch(\"призвів до значною мірою демократичного середнього класу\");\n    assertEmptyMatch(\"Вони замість Андрій вибрали Юрій\");\n    assertEmptyMatch(\"на мохом стеленому дні\");\n    assertEmptyMatch(\"час від часу нам доводилось\");\n    assertEmptyMatch(\"який до речі вони присягалися\");\n    assertEmptyMatch(\"ні до чого доброго силові дії не призведуть\");\n//    assertEmptyMatch(\"Імена від Андрій до Юрій\");  // називний між від і до рідко зустрічається але такий виняток ховає багато помилок \n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"призвів до значною мірою демократичному середньому класу\")).length);\n\n//    assertEmptyMatch(\"як у Конана Дойла\")).length); //TODO\n//    assertEmptyMatch(\"як у Конану Дойла\")).length);\n//    assertEmptyMatch(\"як у Конан Дойла\")).length);\n    \n    //incorrect sentences:\n\n    RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\"без небу\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(Arrays.asList(\"неба\"), matches[0].getSuggestedReplacements());\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"не в останню чергу через    корупцією, міжрелігійну ворожнечу\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"по нервам\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(3, matches[0].getFromPos());\n    assertEquals(9, matches[0].getToPos());\n    assertEquals(Arrays.asList(\"нервах\", \"нерви\"), matches[0].getSuggestedReplacements());\n    \n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"в п'ятьом людям\")).length);\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"в понад п'ятьом людям\")).length);\n\n    AnalyzedSentence analyzedSentence = langTool.getAnalyzedSentence(\"завдяки їх вдалим трюкам\");\n    RuleMatch[] match = rule.match(analyzedSentence);\n    assertEquals(1, match.length);\n    List<String> suggestedReplacements = match[0].getSuggestedReplacements();\n    assertTrue(\"Did not find «їхній»: \" + suggestedReplacements, suggestedReplacements.contains(\"їхнім\"));\n\n    analyzedSentence = langTool.getAnalyzedSentence(\"О дівчина!\");\n    match = rule.match(analyzedSentence);\n    assertEquals(1, match.length);\n    suggestedReplacements = match[0].getSuggestedReplacements();\n    assertTrue(\"Did not find кличний «дівчино»: \" + suggestedReplacements, suggestedReplacements.contains(\"дівчино\"));\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"по церковним канонам\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    List<String> replacements = matches[0].getSuggestedReplacements();\n    assertTrue(\"Not found церковних among: \" + replacements, replacements.contains(\"церковних\"));\n    \n    // свята\n    assertEmptyMatch(\"на Купала\");\n    assertEmptyMatch(\"на Явдохи\");\n    // вулиці\n    assertEmptyMatch(\"на Мазепи\");\n    assertEmptyMatch(\"на Кульчицької\");\n    assertEmptyMatch(\"на Правди\");\n    assertEmptyMatch(\"на Ломоносова\");\n    // invert\n    assertEmptyMatch(\"як на Кучми іменини\");\n    // ім'я, прізвище\n    assertEmptyMatch(\"змінив ім'я на Фріц Ланг\");\n    assertEmptyMatch(\"Бо заміна прізвища Горбатий на Щербань передбачає i зміну ситуації.\");\n//    assertEmptyMatch(\"поміняв Юрій Володимирович на Георгій Вурдалакович.\");\n\n    assertEmptyMatch(\"З одного боку на щастя сім\u2019я Ющенків нарешті з\u2019їжджає з державної дачі.\");\n\n\n    assertEmptyMatch(\"спиралося на місячної давнини рішення\");\n    assertEmptyMatch(\"На середньої довжини шубу\");\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"спиралося на місячної давнини рішенням\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"Від стягу Ататюрка до піратського прапору\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"згідно з документа\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"зацікавлених у ви користанні\"));\n    assertEquals(1, matches.length);\n\n//    matches = rule.match(langTool.getAnalyzedSentence(\"колега з Мінську\"));\n//    System.out.println(langTool.getAnalyzedSentence(\"колега з Мінську\"));\n//    // check match positions:\n//    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"В йому заграла кров.\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"  В йому заграла кров.\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"І от «В йому заграла кров».\"));\n    assertEquals(1, matches.length);\n\n    assertEmptyMatch(\"гепатитів В та С\");\n    \n    matches = rule.match(langTool.getAnalyzedSentence(\"\u2014 О пан Єзус, захисти їх!\"));\n    assertEquals(1, matches.length);\n    \n    matches = rule.match(langTool.getAnalyzedSentence(\"На фото: З Голлівуду Яринка Шуст привезла дві золоті медалі\"));\n    assertEquals(1, matches.length);\n  }","id":9521,"modified_method":"@Test\n  public void testRule() throws IOException {\n\n    // correct sentences:\n    assertEmptyMatch(\"без повного\");\n    assertEmptyMatch(\"без неба\");\n\n    assertEmptyMatch(\"по авеню\");\n\n    assertEmptyMatch(\"що за ганебна непослідовність?\");\n\n    assertEmptyMatch(\"щодо власне людини\");\n    assertEmptyMatch(\"у загалом симпатичній повістині\");\n\n    assertEmptyMatch(\"понад половина людей\");\n    assertEmptyMatch(\"з понад ста людей\");\n\n    assertEmptyMatch(\"по нервах\");\n    assertEmptyMatch(\"з особливою увагою\");\n\n    assertEmptyMatch(\"щодо бодай гіпотетичної здатності\");\n    assertEmptyMatch(\"хто їде на заробітки за кордон\");\n\n    assertEmptyMatch(\"піти в президенти\");\n    assertEmptyMatch(\"піти межі люди\");\n\n    assertEmptyMatch(\"що то була за людина\");\n    assertEmptyMatch(\"що за людина\");\n    assertEmptyMatch(\"що балотувався за цім округом\");\n\n    assertEmptyMatch(\"на дому\");\n\n    assertEmptyMatch(\"окрім як українці\");\n    assertEmptyMatch(\"за двісті метрів\");\n    assertEmptyMatch(\"переходить у Фрідріх Штрассе\");\n    assertEmptyMatch(\"від мінус 1 до плюс 1\");\n    assertEmptyMatch(\"до мінус сорока град\");\n    assertEmptyMatch(\"до мінус шістдесяти\");\n    assertEmptyMatch(\"через років 10\");\n    assertEmptyMatch(\"на хвилин 9-10\");\n    assertEmptyMatch(\"співпрацювати із собі подібними\");\n    assertEmptyMatch(\"через усім відомі причини\");\n    assertEmptyMatch(\"через нікому не відомі причини\");\n    assertEmptyMatch(\"прийшли до ВАТ «Кривий Ріг цемент»\");\n    assertEmptyMatch(\"від А до Я\");\n    assertEmptyMatch(\"до та після\");\n    assertEmptyMatch(\"до схід сонця\");\n    assertEmptyMatch(\"з рана до вечора, від рана до ночі\");\n    assertEmptyMatch(\"до НАК «Надра України»\");\n    assertEmptyMatch(\"призвів до значною мірою демократичного середнього класу\");\n    assertEmptyMatch(\"Вони замість Андрій вибрали Юрій\");\n    assertEmptyMatch(\"на мохом стеленому дні\");\n    assertEmptyMatch(\"час від часу нам доводилось\");\n    assertEmptyMatch(\"який до речі вони присягалися\");\n    assertEmptyMatch(\"ні до чого доброго силові дії не призведуть\");\n//    assertEmptyMatch(\"Імена від Андрій до Юрій\");  // називний між від і до рідко зустрічається але такий виняток ховає багато помилок \n\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"призвів до значною мірою демократичному середньому класу\")).length);\n\n//    assertEmptyMatch(\"як у Конана Дойла\")).length); //TODO\n//    assertEmptyMatch(\"як у Конану Дойла\")).length);\n//    assertEmptyMatch(\"як у Конан Дойла\")).length);\n    \n    //incorrect sentences:\n\n    RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence(\"без небу\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(Arrays.asList(\"неба\"), matches[0].getSuggestedReplacements());\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"не в останню чергу через    корупцією, міжрелігійну ворожнечу\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"по нервам\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    assertEquals(3, matches[0].getFromPos());\n    assertEquals(9, matches[0].getToPos());\n    assertEquals(Arrays.asList(\"нервах\", \"нерви\"), matches[0].getSuggestedReplacements());\n    \n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"в п'ятьом людям\")).length);\n    assertEquals(1, rule.match(langTool.getAnalyzedSentence(\"в понад п'ятьом людям\")).length);\n\n    AnalyzedSentence analyzedSentence = langTool.getAnalyzedSentence(\"завдяки їх вдалим трюкам\");\n    RuleMatch[] match = rule.match(analyzedSentence);\n    assertEquals(1, match.length);\n    List<String> suggestedReplacements = match[0].getSuggestedReplacements();\n    assertTrue(\"Did not find «їхній»: \" + suggestedReplacements, suggestedReplacements.contains(\"їхнім\"));\n\n    analyzedSentence = langTool.getAnalyzedSentence(\"О дівчина!\");\n    match = rule.match(analyzedSentence);\n    assertEquals(1, match.length);\n    suggestedReplacements = match[0].getSuggestedReplacements();\n    assertTrue(\"Did not find кличний «дівчино»: \" + suggestedReplacements, suggestedReplacements.contains(\"дівчино\"));\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"по церковним канонам\"));\n    // check match positions:\n    assertEquals(1, matches.length);\n    List<String> replacements = matches[0].getSuggestedReplacements();\n    assertTrue(\"Not found церковних among: \" + replacements, replacements.contains(\"церковних\"));\n    \n    // свята\n    assertEmptyMatch(\"на Купала\");\n    assertEmptyMatch(\"на Явдохи\");\n    // вулиці\n    assertEmptyMatch(\"на Мазепи\");\n    assertEmptyMatch(\"на Кульчицької\");\n    assertEmptyMatch(\"на Правди\");\n    assertEmptyMatch(\"на Ломоносова\");\n    // invert\n    assertEmptyMatch(\"як на Кучми іменини\");\n    // ім'я, прізвище\n    assertEmptyMatch(\"змінив ім'я на Фріц Ланг\");\n    assertEmptyMatch(\"Бо заміна прізвища Горбатий на Щербань передбачає i зміну ситуації.\");\n//    assertEmptyMatch(\"поміняв Юрій Володимирович на Георгій Вурдалакович.\");\n\n    assertEmptyMatch(\"З одного боку на щастя сім\u2019я Ющенків нарешті з\u2019їжджає з державної дачі.\");\n\n\n    assertEmptyMatch(\"спиралося на місячної давнини рішення\");\n    assertEmptyMatch(\"На середньої довжини шубу\");\n\n    assertEmptyMatch(\"При різного роду процесах\");\n  \n    //TODO:\n//    assertEmptyMatch(\"Так висловлюються про екс-першого віце-спікера.\");\n\n    \n    matches = rule.match(langTool.getAnalyzedSentence(\"спиралося на місячної давнини рішенням\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"Від стягу Ататюрка до піратського прапору\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"згідно з документа\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"зацікавлених у ви користанні\"));\n    assertEquals(1, matches.length);\n\n//    matches = rule.match(langTool.getAnalyzedSentence(\"колега з Мінську\"));\n//    System.out.println(langTool.getAnalyzedSentence(\"колега з Мінську\"));\n//    // check match positions:\n//    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"В йому заграла кров.\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"  В йому заграла кров.\"));\n    assertEquals(1, matches.length);\n\n    matches = rule.match(langTool.getAnalyzedSentence(\"І от «В йому заграла кров».\"));\n    assertEquals(1, matches.length);\n\n    assertEmptyMatch(\"гепатитів В та С\");\n    \n    matches = rule.match(langTool.getAnalyzedSentence(\"\u2014 О пан Єзус, захисти їх!\"));\n    assertEquals(1, matches.length);\n    \n    matches = rule.match(langTool.getAnalyzedSentence(\"На фото: З Голлівуду Яринка Шуст привезла дві золоті медалі\"));\n    assertEquals(1, matches.length);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {\n    return Arrays.asList(\n        new CommaWhitespaceRule(messages),\n        // TODO: does not handle !.. and ?..\n        //            new DoublePunctuationRule(messages),\n        new MorfologikUkrainianSpellerRule(messages, this),\n        new MixedAlphabetsRule(messages),\n        // TODO: does not handle dot in abbreviations in the middle of the sentence, and also !.., ?..          \n        //            new UppercaseSentenceStartRule(messages),\n        new MultipleWhitespaceRule(messages, this),\n        new UkrainianWordRepeatRule(messages, this),\n        // specific to Ukrainian:\n        new SimpleReplaceRule(messages),\n        new SimpleReplaceSoftRule(messages),\n        new TokenAgreementRule(messages),\n        new HiddenCharacterRule(messages)\n    );\n  }","id":9522,"modified_method":"@Override\n  public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {\n    return Arrays.asList(\n        new CommaWhitespaceRule(messages,\n            Example.wrong(\"Ми обідали борщем<marker> ,<\/marker> пловом і салатом.\"),\n            Example.fixed(\"Ми обідали борщем<marker>,<\/marker> пловом і салатом\")),\n        // TODO: does not handle !.. and ?..\n        //            new DoublePunctuationRule(messages),\n        new MorfologikUkrainianSpellerRule(messages, this),\n        new MixedAlphabetsRule(messages),\n        // TODO: does not handle dot in abbreviations in the middle of the sentence, and also !.., ?..          \n        //            new UppercaseSentenceStartRule(messages),\n        new MultipleWhitespaceRule(messages, this),\n        new UkrainianWordRepeatRule(messages, this),\n        // specific to Ukrainian:\n        new SimpleReplaceRule(messages),\n        new SimpleReplaceSoftRule(messages),\n        new TokenAgreementRule(messages),\n        new TokenInflectionAgreementRule(messages),\n        new HiddenCharacterRule(messages)\n    );\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testDisambiguatorForInitials() throws IOException {\n    TestTools.myAssert(\"Є.Бакуліна\",\n      \"/[null]SENT_START\"\n        + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n        + \" ./[null]null\"\n        + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n      tokenizer, sentenceTokenizer, tagger, disambiguator);\n  \n    TestTools.myAssert(\" Є. Бакуліна\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    TestTools.myAssert(\" Є.\\u00A0Бакуліна\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \" \\u00A0/[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    TestTools.myAssert(\"Є.Л.Бакуліна\",\n      \"/[null]SENT_START\"\n        + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n        + \" ./[null]null\"\n        + \" Л/[Л]noun:anim:f:v_naz:prop:patr:abbr|Л/[Л]noun:anim:m:v_rod:prop:patr:abbr|Л/[Л]noun:anim:m:v_zna:prop:patr:abbr\"\n        + \" ./[null]null\"\n        + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n      tokenizer, sentenceTokenizer, tagger, disambiguator);\n    \n    TestTools.myAssert(\" Є. Л. Бакуліна\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Л/[Л]noun:anim:f:v_naz:prop:patr:abbr|Л/[Л]noun:anim:m:v_rod:prop:patr:abbr|Л/[Л]noun:anim:m:v_zna:prop:patr:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    \n    TestTools.myAssert(\" Є. Л. Бакуліна і Г. К. Бакулін\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Л/[Л]noun:anim:f:v_naz:prop:patr:abbr|Л/[Л]noun:anim:m:v_rod:prop:patr:abbr|Л/[Л]noun:anim:m:v_zna:prop:patr:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\"\n          + \"  /[null]null\"\n          + \" і/[і]conj:coord|і/[і]part\"\n          + \"  /[null]null\"\n          + \" Г/[Г]noun:anim:m:v_naz:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" К/[К]noun:anim:m:v_naz:prop:patr:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакулін/[Бакулін]noun:anim:m:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    // make sure we don't choke on complex test\n    TestTools.myAssert(\"Комендант, преподобний С. С. Мокітімі, був чудовою людиною.\",\n      \"/[null]SENT_START Комендант/[комендант]noun:anim:m:v_naz ,/[null]null\"\n      +\"  /[null]null преподобний/[преподобний]adj:m:v_kly|преподобний/[преподобний]adj:m:v_naz|преподобний/[преподобний]adj:m:v_zna:rinanim\"\n      +\"  /[null]null С/[null]null ./[null]null  /[null]null С/[null]null ./[null]null  /[null]null\"\n      +\" Мокітімі/[null]null ,/[null]null  /[null]null\"\n      +\" був/[бути]verb:imperf:past:m  /[null]null чудовою/[чудовий]adj:f:v_oru:compb  /[null]null людиною/[людина]noun:anim:f:v_oru ./[null]null\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n  }","id":9523,"modified_method":"@Test\n  public void testDisambiguatorForInitials() throws IOException {\n    TestTools.myAssert(\"Є.Бакуліна\",\n      \"/[null]SENT_START\"\n        + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n        + \" ./[null]null\"\n        + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n      tokenizer, sentenceTokenizer, tagger, disambiguator);\n  \n    TestTools.myAssert(\" Є. Бакуліна\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    TestTools.myAssert(\" Є.\\u00A0Бакуліна\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \" \\u00A0/[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    TestTools.myAssert(\"Є.Л.Бакуліна\",\n      \"/[null]SENT_START\"\n        + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n        + \" ./[null]null\"\n        + \" Л/[Л]noun:anim:f:v_naz:prop:patr:abbr|Л/[Л]noun:anim:m:v_rod:prop:patr:abbr|Л/[Л]noun:anim:m:v_zna:prop:patr:abbr\"\n        + \" ./[null]null\"\n        + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n      tokenizer, sentenceTokenizer, tagger, disambiguator);\n    \n    TestTools.myAssert(\" Є. Л. Бакуліна\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Л/[Л]noun:anim:f:v_naz:prop:patr:abbr|Л/[Л]noun:anim:m:v_rod:prop:patr:abbr|Л/[Л]noun:anim:m:v_zna:prop:patr:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    \n    TestTools.myAssert(\" Є. Л. Бакуліна і Г. К. Бакулін\",\n        \"/[null]SENT_START\"\n          + \"  /[null]null\"\n          + \" Є/[Є]noun:anim:f:v_naz:prop:fname:abbr|Є/[Є]noun:anim:m:v_rod:prop:fname:abbr|Є/[Є]noun:anim:m:v_zna:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Л/[Л]noun:anim:f:v_naz:prop:patr:abbr|Л/[Л]noun:anim:m:v_rod:prop:patr:abbr|Л/[Л]noun:anim:m:v_zna:prop:patr:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакуліна/[Бакулін]noun:anim:m:v_rod:prop:lname|Бакуліна/[Бакулін]noun:anim:m:v_zna:prop:lname|Бакуліна/[Бакуліна]noun:anim:f:v_naz:prop:lname\"\n          + \"  /[null]null\"\n          + \" і/[і]conj:coord|і/[і]part\"\n          + \"  /[null]null\"\n          + \" Г/[Г]noun:anim:m:v_naz:prop:fname:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" К/[К]noun:anim:m:v_naz:prop:patr:abbr\"\n          + \" ./[null]null\"\n          + \"  /[null]null\"\n          + \" Бакулін/[Бакулін]noun:anim:m:v_naz:prop:lname\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n\n    // make sure we don't choke on complex test\n    TestTools.myAssert(\"Комендант, преподобний С. С. Мокітімі, був чудовою людиною.\",\n      \"/[null]SENT_START Комендант/[Комендант]noun:anim:m:v_naz:prop:lname|Комендант/[комендант]noun:anim:m:v_naz ,/[null]null\"\n      +\"  /[null]null преподобний/[преподобний]adj:m:v_kly|преподобний/[преподобний]adj:m:v_naz|преподобний/[преподобний]adj:m:v_zna:rinanim\"\n      +\"|преподобний/[преподобний]noun:anim:m:v_kly|преподобний/[преподобний]noun:anim:m:v_naz\"\n      +\"  /[null]null С/[null]null ./[null]null  /[null]null С/[null]null ./[null]null  /[null]null\"\n      +\" Мокітімі/[null]null ,/[null]null  /[null]null\"\n      +\" був/[бути]verb:imperf:past:m  /[null]null чудовою/[чудовий]adj:f:v_oru:compb  /[null]null людиною/[людина]noun:anim:f:v_oru ./[null]null\",\n        tokenizer, sentenceTokenizer, tagger, disambiguator);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testNumberTagging() throws IOException {\n    TestTools.myAssert(\"101,234\", \"101,234/[101,234]number\", tokenizer, tagger);\n    TestTools.myAssert(\"3,5-5,6% 7° 7,4°С\", \"3,5-5,6%/[3,5-5,6%]number -- 7°/[7°]number -- 7,4°С/[7,4°С]number\", tokenizer, tagger);\n    TestTools.myAssert(\"XIX\", \"XIX/[XIX]number\", tokenizer, tagger);\n\n    TestTools.myAssert(\"14.07.2001\", \"14.07.2001/[14.07.2001]date\", tokenizer, tagger);\n\n    TestTools.myAssert(\"о 15.33\", \"о/[о]excl|о/[о]prep:rv_zna:rv_mis -- 15.33/[15.33]time\", tokenizer, tagger);\n    TestTools.myAssert(\"О 1:05\", \"О/[о]excl|О/[о]prep:rv_zna:rv_mis -- 1:05/[1:05]time\", tokenizer, tagger);\n  }","id":9524,"modified_method":"@Test\n  public void testNumberTagging() throws IOException {\n    TestTools.myAssert(\"101,234\", \"101,234/[101,234]number\", tokenizer, tagger);\n    TestTools.myAssert(\"3,5-5,6% 7° 7,4°С\", \"3,5-5,6%/[3,5-5,6%]number -- 7°/[7°]number -- 7,4°С/[7,4°С]number\", tokenizer, tagger);\n    TestTools.myAssert(\"XIX\", \"XIX/[XIX]number\", tokenizer, tagger);\n\n    TestTools.myAssert(\"14.07.2001\", \"14.07.2001/[14.07.2001]date\", tokenizer, tagger);\n\n    TestTools.myAssert(\"о 15.33\", \"о/[о]intj|о/[о]prep:rv_zna:rv_mis -- 15.33/[15.33]time\", tokenizer, tagger);\n    TestTools.myAssert(\"О 1:05\", \"О/[о]intj|О/[о]prep:rv_zna:rv_mis -- 1:05/[1:05]time\", tokenizer, tagger);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testDynamicTagging() throws IOException {\n    TestTools.myAssert(\"г-г-г\", \"г-г-г/[null]null\", tokenizer, tagger);\n    \n    TestTools.myAssert(\"100-річному\", \"100-річному/[100-річний]adj:m:v_dav|100-річному/[100-річний]adj:m:v_mis|100-річному/[100-річний]adj:n:v_dav|100-річному/[100-річний]adj:n:v_mis\", tokenizer, tagger);\n    TestTools.myAssert(\"100-й\", \"100-й/[100-й]adj:f:v_dav|100-й/[100-й]adj:f:v_mis|100-й/[100-й]adj:m:v_naz|100-й/[100-й]adj:m:v_zna:rinanim\", tokenizer, tagger);\n    TestTools.myAssert(\"50-х\", \"50-х/[50-й]adj:p:v_mis|50-х/[50-й]adj:p:v_rod|50-х/[50-й]adj:p:v_zna\", tokenizer, tagger);\n\n    TestTools.myAssert(\"по-свинячому\", \"по-свинячому/[по-свинячому]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"по-сибірськи\", \"по-сибірськи/[по-сибірськи]adv\", tokenizer, tagger);\n\n    TestTools.myAssert(\"давай-но\", \"давай-но/[давати]verb:imperf:impr:s:2\", tokenizer, tagger);\n    TestTools.myAssert(\"дивіться-но\", \"дивіться-но/[дивитися]verb:rev:imperf:impr:p:2\", tokenizer, tagger);\n    TestTools.myAssert(\"той-таки\", \"той-таки/[той-таки]adj:m:v_naz:&pron:dem|той-таки/[той-таки]adj:m:v_zna:rinanim:&pron:dem\", tokenizer, tagger);\n    TestTools.myAssert(\"буде-таки\", \"буде-таки/[бути]verb:imperf:futr:s:3\", tokenizer, tagger);\n    TestTools.myAssert(\"оцей-от\", \"оцей-от/[оцей]adj:m:v_naz:&pron:dem|оцей-от/[оцей]adj:m:v_zna:rinanim:&pron:dem\", tokenizer, tagger);\n    TestTools.myAssert(\"оттакий-то\", \"оттакий-то/[оттакий]adj:m:v_naz:&pron:dem:rare|оттакий-то/[оттакий]adj:m:v_zna:rinanim:&pron:dem:rare\", tokenizer, tagger);\n    TestTools.myAssert(\"геть-то\", \"геть-то/[геть]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"ану-бо\", \"ану-бо/[ану]excl|ану-бо/[ану]part\", tokenizer, tagger);\n    TestTools.myAssert(\"годі-бо\", \"годі-бо/[годі]predic\", tokenizer, tagger);\n    TestTools.myAssert(\"гей-но\", \"гей-но/[гей]excl\", tokenizer, tagger);\n    TestTools.myAssert(\"цить-но\", \"цить-но/[цить]excl\", tokenizer, tagger);\n\n    TestTools.myAssert(\"дер-жав\", \"дер-жав/[дерти-жати]verb:imperf:past:m|дер-жав/[дерти-жати]verb:imperf:past:m\", tokenizer, tagger);\n\n    TestTools.myAssert(\"екс-партнер\", \"екс-партнер/[екс-партнер]noun:anim:m:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Алієва-старшого\", \"Алієва-старшого/[Алієв-старший]noun:anim:m:v_rod:prop:lname|Алієва-старшого/[Алієв-старший]noun:anim:m:v_zna:prop:lname\", tokenizer, tagger);\n    // test ranim/rinanim\n//    TestTools.myAssert(\"Алієва-старший\", \"Алієва-старший/[Алієва-старший]\", tokenizer, tagger);\n//    TestTools.myAssert(\"Алієв-старшого\", \"Алієва-старшого/[Алієва-старшого]\", tokenizer, tagger);\n\n//    TestTools.myAssert(\"греко-уніятський\", \"\", tokenizer, tagger);\n    \n    TestTools.myAssert(\"жило-було\", \"жило-було/[жити-бути]verb:imperf:past:n\", tokenizer, tagger);\n    TestTools.myAssert(\"учиш-учиш\", \"учиш-учиш/[учити-учити]verb:imperf:pres:s:2:v-u\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Га-га\", \"Га-га/[га-га]excl\", tokenizer, tagger);\n    TestTools.myAssert(\"вгору-вниз\", \"вгору-вниз/[вгору-вниз]adv:v-u\", tokenizer, tagger);\n\n    TestTools.myAssert(\"низенько-низенько\", \"низенько-низенько/[низенько-низенько]adv\", tokenizer, tagger);\n//    TestTools.myAssert(\"такого-сякого\", \"такого-сякого/[такий-сякий]adj:m:v_rod:&pron:def|такого-сякого/[такий-сякий]adj:m:v_zna:&pron:def|такого-сякого/[такий-сякий]adj:n:v_rod:&pron:def\", tokenizer, tagger);\n    TestTools.myAssert(\"великий-превеликий\", \"великий-превеликий/[великий-превеликий]adj:m:v_kly|великий-превеликий/[великий-превеликий]adj:m:v_naz|великий-превеликий/[великий-превеликий]adj:m:v_zna:rinanim\", tokenizer, tagger);\n    TestTools.myAssert(\"чорній-чорній\", \"чорній-чорній/[чорний-чорний]adj:f:v_dav|чорній-чорній/[чорний-чорний]adj:f:v_mis|чорній-чорній/[чорніти-чорніти]verb:imperf:impr:s:2\", tokenizer, tagger);\n\n    TestTools.myAssert(\"лікар-гомеопат\", \"лікар-гомеопат/[лікар-гомеопат]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"лікаря-гомеопата\", \"лікаря-гомеопата/[лікар-гомеопат]noun:anim:m:v_rod|лікаря-гомеопата/[лікар-гомеопат]noun:anim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"шмкр-гомеопат\", \"шмкр-гомеопат/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"шмкр-ткр\", \"шмкр-ткр/[null]null\", tokenizer, tagger);\n\n    TestTools.myAssert(\"вчинок-приклад\", \"вчинок-приклад/[вчинок-приклад]noun:inanim:m:v_naz:v-u|вчинок-приклад/[вчинок-приклад]noun:inanim:m:v_naz:v-u|вчинок-приклад/[вчинок-приклад]noun:inanim:m:v_zna:v-u\"\n        +\"|вчинок-приклад/[вчинок-приклад]noun:inanim:m:v_zna:v-u\", tokenizer, tagger);\n    TestTools.myAssert(\"міста-фортеці\", \"міста-фортеці/[місто-фортеця]noun:inanim:n:v_rod|міста-фортеці/[місто-фортеця]noun:inanim:p:v_kly|міста-фортеці/[місто-фортеця]noun:inanim:p:v_naz|міста-фортеці/[місто-фортеця]noun:inanim:p:v_zna\", tokenizer, tagger);\n\n    // inanim-anim\n    TestTools.myAssert(\"вчених-новаторів\", \"вчених-новаторів/[вчений-новатор]noun:anim:p:v_rod:v-u|вчених-новаторів/[вчений-новатор]noun:anim:p:v_zna:v-u\", tokenizer, tagger);\n    TestTools.myAssert(\"країна-виробник\", \"країна-виробник/[країна-виробник]noun:inanim:f:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"банк-виробник\", \"банк-виробник/[банк-виробник]noun:inanim:m:v_naz|банк-виробник/[банк-виробник]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"банки-агенти\", \"банки-агенти/[банк-агент]noun:inanim:p:v_kly|банки-агенти/[банк-агент]noun:inanim:p:v_naz|банки-агенти/[банк-агент]noun:inanim:p:v_zna|банки-агенти/[банка-агент]noun:inanim:p:v_kly|банки-агенти/[банка-агент]noun:inanim:p:v_naz|банки-агенти/[банка-агент]noun:inanim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"місто-гігант\", \"місто-гігант/[місто-гігант]noun:inanim:n:v_naz|місто-гігант/[місто-гігант]noun:inanim:n:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"країни-агресори\", \"країни-агресори/[країна-агресор]noun:inanim:p:v_kly|країни-агресори/[країна-агресор]noun:inanim:p:v_naz|країни-агресори/[країна-агресор]noun:inanim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"поселення-гігант\", \"поселення-гігант/[поселення-гігант]noun:inanim:n:v_naz|поселення-гігант/[поселення-гігант]noun:inanim:n:v_zna\", tokenizer, tagger);\n    \n    TestTools.myAssert(\"сонях-красень\", \"сонях-красень/[сонях-красень]noun:inanim:m:v_naz|сонях-красень/[сонях-красень]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"красень-сонях\", \"красень-сонях/[красень-сонях]noun:inanim:m:v_naz|красень-сонях/[красень-сонях]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"депутатів-привидів\", \"депутатів-привидів/[депутат-привид]noun:anim:p:v_rod|депутатів-привидів/[депутат-привид]noun:anim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"дівчата-зірочки\", \"дівчата-зірочки/[дівча-зірочка]noun:anim:p:v_kly|дівчата-зірочки/[дівча-зірочка]noun:anim:p:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"етно-диско\", \"етно-диско/[null]null\", tokenizer, tagger);\n\n    // unanim\n    TestTools.myAssert(\"ворог-стафілокок\", \"ворог-стафілокок/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"стафілокок-реагент\", \"стафілокок-реагент/[null]null\", tokenizer, tagger);\n\n    // noun-numr\n    TestTools.myAssert(\"абзац-два\", \"абзац-два/[абзац-два]noun:inanim:m:v_naz|абзац-два/[абзац-два]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"сотні-дві\", \"сотні-дві/[сотня-два]noun:inanim:p:v_naz|сотні-дві/[сотня-два]noun:inanim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"тисячею-трьома\", \"тисячею-трьома/[тисяча-три]noun:inanim:f:v_oru|тисячею-трьома/[тисяча-троє]noun:inanim:f:v_oru\", tokenizer, tagger);\n\n    TestTools.myAssert(\"одним-двома\", \"одним-двома/[один-два]numr:m:v_oru|одним-двома/[один-два]numr:n:v_oru|одним-двома/[один-двоє]numr:m:v_oru|одним-двома/[один-двоє]numr:n:v_oru\", tokenizer, tagger);\n    //TODO: бере іменник п\u2019ята\n//    TestTools.myAssert(\"п'яти-шести\", \"п'яти-шести/[п'ять-шість]numr:v_dav|п'яти-шести/[п'ять-шість]numr:v_mis|п'яти-шести/[п'ять-шість]numr:v_rod\", tokenizer, tagger);\n    TestTools.myAssert(\"п'яти-шести\", \"п'яти-шести/[п'ята-шість]noun:inanim:f:v_rod|п'яти-шести/[п'ять-шість]numr:p:v_dav|п'яти-шести/[п'ять-шість]numr:p:v_mis|п'яти-шести/[п'ять-шість]numr:p:v_rod\", tokenizer, tagger);\n    TestTools.myAssert(\"півтори-дві\", \"півтори-дві/[півтори-два]numr:f:v_naz|півтори-дві/[півтори-два]numr:f:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"три-чотири\", \"три-чотири/[три-чотири]numr:p:v_naz|три-чотири/[три-чотири]numr:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"два-чотири\", \"два-чотири/[два-чотири]numr:m:v_naz|два-чотири/[два-чотири]numr:m:v_zna:rinanim|два-чотири/[два-чотири]numr:n:v_naz|два-чотири/[два-чотири]numr:n:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"одному-двох\", \"одному-двох/[один-два]numr:m:v_mis|одному-двох/[один-два]numr:n:v_mis|одному-двох/[один-двоє]numr:m:v_mis|одному-двох/[один-двоє]numr:n:v_mis\", tokenizer, tagger);\n    // u2013\n    TestTools.myAssert(\"три\u2013чотири\", \"три\u2013чотири/[три\u2013чотири]numr:p:v_naz|три\u2013чотири/[три\u2013чотири]numr:p:v_zna\", tokenizer, tagger);\n    \n//    \"однією-єдиною\"\n//    TestTools.myAssert(\"капуджі-ага\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n//    TestTools.myAssert(\"Каладжі-бей\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n//    TestTools.myAssert(\"капудан-паша\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n//    TestTools.myAssert(\"кальфа-ефенді\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"а-а\", \"а-а/[а-а]excl\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Москви-ріки\", \"Москви-ріки/[Москва-ріка]noun:inanim:f:v_rod:prop\", tokenizer, tagger);\n    \n    TestTools.myAssert(\"пів-України\", \"пів-України/[пів-України]noun:inanim:f:v_dav:prop|пів-України/[пів-України]noun:inanim:f:v_mis:prop|пів-України/[пів-України]noun:inanim:f:v_naz:prop\"\n        +\"|пів-України/[пів-України]noun:inanim:f:v_oru:prop|пів-України/[пів-України]noun:inanim:f:v_rod:prop|пів-України/[пів-України]noun:inanim:f:v_zna:prop\", tokenizer, tagger);\n\n    TestTools.myAssert(\"кава-еспресо\", \"кава-еспресо/[кава-еспресо]noun:inanim:f:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"кави-еспресо\", \"кави-еспресо/[кава-еспресо]noun:inanim:f:v_rod\", tokenizer, tagger);\n    TestTools.myAssert(\"еспресо-машина\", \"еспресо-машина/[еспресо-машина]noun:inanim:f:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"програмою-максимум\", \"програмою-максимум/[програма-максимум]noun:inanim:f:v_oru\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Пенсильванія-авеню\", \"Пенсильванія-авеню/[Пенсильванія-авеню]noun:inanim:f:nv:prop\", tokenizer, tagger);\n\n    TestTools.myAssert(\"патолого-анатомічний\", \"патолого-анатомічний/[патолого-анатомічний]adj:m:v_kly|патолого-анатомічний/[патолого-анатомічний]adj:m:v_naz|патолого-анатомічний/[патолого-анатомічний]adj:m:v_zna:rinanim\", tokenizer, tagger);\n    TestTools.myAssert(\"паталого-анатомічний\", \"паталого-анатомічний/[null]null\", tokenizer, tagger);\n    //TODO: fix this case (now works like братів-православних)\n//    TestTools.myAssert(\"патолога-анатомічний\", \"патолога-анатомічний/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"патолого-гмкнх\", \"патолого-гмкнх/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"патолого-голова\", \"патолого-голова/[null]null\", tokenizer, tagger);\n    //TODO: remove :compb ?\n    TestTools.myAssert(\"освітньо-культурний\", \"освітньо-культурний/[освітньо-культурний]adj:m:v_kly:compb|освітньо-культурний/[освітньо-культурний]adj:m:v_naz:compb|освітньо-культурний/[освітньо-культурний]adj:m:v_zna:rinanim:compb\", tokenizer, tagger);\n    TestTools.myAssert(\"бірмюково-блакитний\", \"бірмюково-блакитний/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"сліпуче-яскравого\", \"сліпуче-яскравого/[сліпуче-яскравий]adj:m:v_rod:compb|сліпуче-яскравого/[сліпуче-яскравий]adj:m:v_zna:ranim:compb|сліпуче-яскравого/[сліпуче-яскравий]adj:n:v_rod:compb\", tokenizer, tagger);\n    TestTools.myAssert(\"дво-триметровий\", \"дво-триметровий/[дво-триметровий]adj:m:v_kly|дво-триметровий/[дво-триметровий]adj:m:v_naz|дво-триметровий/[дво-триметровий]adj:m:v_zna:rinanim\", tokenizer, tagger);\n    TestTools.myAssert(\"україно-болгарський\", \"україно-болгарський/[україно-болгарський]adj:m:v_kly|україно-болгарський/[україно-болгарський]adj:m:v_naz|україно-болгарський/[україно-болгарський]adj:m:v_zna:rinanim\", tokenizer, tagger);\n\n//    TestTools.myAssert(\"американо-блакитний\", \"бірмюково-блакитний/[бірмюково-блакитний]adj:m:v_naz|бірмюково-блакитний/[бірмюково-блакитний]adj:m:v_zna\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Дівчинка-першокласниця\", \"Дівчинка-першокласниця/[дівчинка-першокласниця]noun:anim:f:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"RPM-пакунок\", \"RPM-пакунок/[RPM-пакунок]noun:inanim:m:v_naz|RPM-пакунок/[RPM-пакунок]noun:inanim:m:v_zna\", tokenizer, tagger);\n\n    TestTools.myAssert(\"ось\\u2011ось\", \"ось\\u2011ось/[ось\\u2011ось]adv\", tokenizer, tagger);\n\n    // істота-неістота\n    //TODO:\n    // про місяця-місяченька\n    // бабці-Австрії\n    // змагання зі слалому-гіганту\n    // голосувати за Тимошенко-прем\u2019єра\n  }","id":9525,"modified_method":"@Test\n  public void testDynamicTaggingFullTagMatch() throws IOException {\n    TestTools.myAssert(\"пів-України\", \"пів-України/[пів-України]noun:inanim:f:v_dav:prop|пів-України/[пів-України]noun:inanim:f:v_mis:prop|пів-України/[пів-України]noun:inanim:f:v_naz:prop\"\n        +\"|пів-України/[пів-України]noun:inanim:f:v_oru:prop|пів-України/[пів-України]noun:inanim:f:v_rod:prop|пів-України/[пів-України]noun:inanim:f:v_zna:prop\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Пенсильванія-авеню\", \"Пенсильванія-авеню/[Пенсильванія-авеню]noun:inanim:f:nv:prop\", tokenizer, tagger);\n\n\n    // full tag match\n    \n\n    TestTools.myAssert(\"жило-було\", \"жило-було/[жити-бути]verb:imperf:past:n\", tokenizer, tagger);\n    TestTools.myAssert(\"учиш-учиш\", \"учиш-учиш/[учити-учити]verb:imperf:pres:s:2:v-u\", tokenizer, tagger);\n\n    TestTools.myAssert(\"а-а\", \"а-а/[а-а]intj\", tokenizer, tagger);\n    TestTools.myAssert(\"Га-га\", \"Га-га/[га-га]intj\", tokenizer, tagger);\n    TestTools.myAssert(\"ось\\u2011ось\", \"ось\\u2011ось/[ось\\u2011ось]adv\", tokenizer, tagger);\n\n    TestTools.myAssert(\"вгору-вниз\", \"вгору-вниз/[вгору-вниз]adv:v-u\", tokenizer, tagger);\n\n    // numr-numr\n    TestTools.myAssert(\"одним-двома\", \"одним-двома/[один-два]numr:m:v_oru|одним-двома/[один-два]numr:n:v_oru|одним-двома/[один-двоє]numr:m:v_oru|одним-двома/[один-двоє]numr:n:v_oru\", tokenizer, tagger);\n    //TODO: бере іменник п\u2019ята\n//    TestTools.myAssert(\"п'яти-шести\", \"п'яти-шести/[п'ять-шість]numr:v_dav|п'яти-шести/[п'ять-шість]numr:v_mis|п'яти-шести/[п'ять-шість]numr:v_rod\", tokenizer, tagger);\n    TestTools.myAssert(\"п'яти-шести\", \"п'яти-шести/[п'ята-шість]noun:inanim:f:v_rod|п'яти-шести/[п'ять-шість]numr:p:v_dav|п'яти-шести/[п'ять-шість]numr:p:v_mis|п'яти-шести/[п'ять-шість]numr:p:v_rod\", tokenizer, tagger);\n    TestTools.myAssert(\"півтори-дві\", \"півтори-дві/[півтори-два]numr:f:v_naz|півтори-дві/[півтори-два]numr:f:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"три-чотири\", \"три-чотири/[три-чотири]numr:p:v_naz|три-чотири/[три-чотири]numr:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"два-чотири\", \"два-чотири/[два-чотири]numr:m:v_naz|два-чотири/[два-чотири]numr:m:v_zna|два-чотири/[два-чотири]numr:n:v_naz|два-чотири/[два-чотири]numr:n:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"одному-двох\", \"одному-двох/[один-два]numr:m:v_mis|одному-двох/[один-два]numr:n:v_mis|одному-двох/[один-двоє]numr:m:v_mis|одному-двох/[один-двоє]numr:n:v_mis\", tokenizer, tagger);\n    TestTools.myAssert(\"три\u2013чотири\", \"три\u2013чотири/[три\u2013чотири]numr:p:v_naz|три\u2013чотири/[три\u2013чотири]numr:p:v_zna\", tokenizer, tagger);\n\n    // noun-numr\n    TestTools.myAssert(\"абзац-два\", \"абзац-два/[абзац-два]noun:inanim:m:v_naz|абзац-два/[абзац-два]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"сотні-дві\", \"сотні-дві/[сотня-два]noun:inanim:p:v_naz|сотні-дві/[сотня-два]noun:inanim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"тисячею-трьома\", \"тисячею-трьома/[тисяча-три]noun:inanim:f:v_oru|тисячею-трьома/[тисяча-троє]noun:inanim:f:v_oru\", tokenizer, tagger);\n\n    \n    // others\n\n    TestTools.myAssert(\"низенько-низенько\", \"низенько-низенько/[низенько-низенько]adv\", tokenizer, tagger);\n//    TestTools.myAssert(\"такого-сякого\", \"такого-сякого/[такий-сякий]adj:m:v_rod:&pron:def|такого-сякого/[такий-сякий]adj:m:v_zna:&pron:def|такого-сякого/[такий-сякий]adj:n:v_rod:&pron:def\", tokenizer, tagger);\n    TestTools.myAssert(\"великий-превеликий\", \"великий-превеликий/[великий-превеликий]adj:m:v_kly|великий-превеликий/[великий-превеликий]adj:m:v_naz|великий-превеликий/[великий-превеликий]adj:m:v_zna:rinanim\", tokenizer, tagger);\n    TestTools.myAssert(\"чорній-чорній\", \"чорній-чорній/[чорний-чорний]adj:f:v_dav|чорній-чорній/[чорний-чорний]adj:f:v_mis|чорній-чорній/[чорніти-чорніти]verb:imperf:impr:s:2\", tokenizer, tagger);\n\n\n    TestTools.myAssert(\"етно-диско\", \"етно-диско/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"екс-партнер\", \"екс-партнер/[екс-партнер]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"еспресо-машина\", \"еспресо-машина/[еспресо-машина]noun:inanim:f:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"кава-еспресо\", \"кава-еспресо/[кава-еспресо]noun:inanim:f:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"кави-еспресо\", \"кави-еспресо/[кава-еспресо]noun:inanim:f:v_rod\", tokenizer, tagger);\n    TestTools.myAssert(\"програмою-максимум\", \"програмою-максимум/[програма-максимум]noun:inanim:f:v_oru\", tokenizer, tagger);\n\n    // jr/sr\n\n    TestTools.myAssert(\"Алієва-старшого\", \"Алієва-старшого/[Алієв-старший]noun:anim:m:v_rod:prop:lname|Алієва-старшого/[Алієв-старший]noun:anim:m:v_zna:prop:lname\", tokenizer, tagger);\n    // test ranim/rinanim\n//    TestTools.myAssert(\"Алієва-старший\", \"Алієва-старший/[Алієва-старший]\", tokenizer, tagger);\n//    TestTools.myAssert(\"Алієв-старшого\", \"Алієва-старшого/[Алієва-старшого]\", tokenizer, tagger);\n    \n    // noun-noun\n\n    TestTools.myAssert(\"лікар-гомеопат\", \"лікар-гомеопат/[лікар-гомеопат]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"лікаря-гомеопата\", \"лікаря-гомеопата/[лікар-гомеопат]noun:anim:m:v_rod|лікаря-гомеопата/[лікар-гомеопат]noun:anim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"шмкр-гомеопат\", \"шмкр-гомеопат/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"лікар-ткр\", \"лікар-ткр/[null]null\", tokenizer, tagger);\n\n    TestTools.myAssert(\"вчинок-приклад\", \"вчинок-приклад/[вчинок-приклад]noun:inanim:m:v_naz:v-u|вчинок-приклад/[вчинок-приклад]noun:inanim:m:v_zna:v-u\", tokenizer, tagger);\n    TestTools.myAssert(\"міста-фортеці\", \"міста-фортеці/[місто-фортеця]noun:inanim:n:v_rod|міста-фортеці/[місто-фортеця]noun:inanim:p:v_kly|міста-фортеці/[місто-фортеця]noun:inanim:p:v_naz|міста-фортеці/[місто-фортеця]noun:inanim:p:v_zna\", tokenizer, tagger);\n\n    // inanim-anim\n    TestTools.myAssert(\"вчених-новаторів\", \"вчених-новаторів/[вчений-новатор]noun:anim:p:v_rod:v-u|вчених-новаторів/[вчений-новатор]noun:anim:p:v_zna:v-u\", tokenizer, tagger);\n    TestTools.myAssert(\"країна-виробник\", \"країна-виробник/[країна-виробник]noun:inanim:f:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"банк-виробник\", \"банк-виробник/[банк-виробник]noun:inanim:m:v_naz|банк-виробник/[банк-виробник]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"банки-агенти\", \"банки-агенти/[банк-агент]noun:inanim:p:v_kly|банки-агенти/[банк-агент]noun:inanim:p:v_naz|банки-агенти/[банк-агент]noun:inanim:p:v_zna|банки-агенти/[банка-агент]noun:inanim:p:v_kly|банки-агенти/[банка-агент]noun:inanim:p:v_naz|банки-агенти/[банка-агент]noun:inanim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"місто-гігант\", \"місто-гігант/[місто-гігант]noun:inanim:n:v_naz|місто-гігант/[місто-гігант]noun:inanim:n:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"країни-агресори\", \"країни-агресори/[країна-агресор]noun:inanim:p:v_kly|країни-агресори/[країна-агресор]noun:inanim:p:v_naz|країни-агресори/[країна-агресор]noun:inanim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"поселення-гігант\", \"поселення-гігант/[поселення-гігант]noun:inanim:n:v_naz|поселення-гігант/[поселення-гігант]noun:inanim:n:v_zna\", tokenizer, tagger);\n    \n    TestTools.myAssert(\"сонях-красень\", \"сонях-красень/[сонях-красень]noun:inanim:m:v_naz|сонях-красень/[сонях-красень]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"красень-сонях\", \"красень-сонях/[красень-сонях]noun:inanim:m:v_naz|красень-сонях/[красень-сонях]noun:inanim:m:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"депутатів-привидів\", \"депутатів-привидів/[депутат-привид]noun:anim:p:v_rod|депутатів-привидів/[депутат-привид]noun:anim:p:v_zna\", tokenizer, tagger);\n    TestTools.myAssert(\"дівчата-зірочки\", \"дівчата-зірочки/[дівча-зірочка]noun:anim:p:v_kly|дівчата-зірочки/[дівча-зірочка]noun:anim:p:v_naz\", tokenizer, tagger);\n    \n    // TODO: істота-неістота\n    // про місяця-місяченька\n    // бабці-Австрії\n    // змагання зі слалому-гіганту\n    // голосувати за Тимошенко-прем\u2019єра\n\n\n    // TODO: unanim\n    TestTools.myAssert(\"ворог-стафілокок\", \"ворог-стафілокок/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"стафілокок-реагент\", \"стафілокок-реагент/[null]null\", tokenizer, tagger);\n    \n//    TestTools.myAssert(\"капуджі-ага\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n//    TestTools.myAssert(\"Каладжі-бей\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n//    TestTools.myAssert(\"капудан-паша\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n//    TestTools.myAssert(\"кальфа-ефенді\", \"два-чотири/[два-чотири]numr:v_naz|два-чотири/[два-чотири]numr:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Москви-ріки\", \"Москви-ріки/[Москва-ріка]noun:inanim:f:v_rod:prop\", tokenizer, tagger);\n\n\n    // adv-adj\n\n    TestTools.myAssert(\"патолого-анатомічний\", \"патолого-анатомічний/[патолого-анатомічний]adj:m:v_kly|патолого-анатомічний/[патолого-анатомічний]adj:m:v_naz|патолого-анатомічний/[патолого-анатомічний]adj:m:v_zna:rinanim\", tokenizer, tagger);\n\n    TestTools.myAssert(\"паталого-анатомічний\", \"паталого-анатомічний/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"патолога-анатомічний\", \"патолога-анатомічний/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"патолого-гмкнх\", \"патолого-гмкнх/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"патолого-голова\", \"патолого-голова/[null]null\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Освітньо-культурний\", \"Освітньо-культурний/[освітньо-культурний]adj:m:v_kly:compb|Освітньо-культурний/[освітньо-культурний]adj:m:v_naz:compb|Освітньо-культурний/[освітньо-культурний]adj:m:v_zna:rinanim:compb\", tokenizer, tagger);\n    TestTools.myAssert(\"сліпуче-яскравого\", \"сліпуче-яскравого/[сліпуче-яскравий]adj:m:v_rod:compb|сліпуче-яскравого/[сліпуче-яскравий]adj:m:v_zna:ranim:compb|сліпуче-яскравого/[сліпуче-яскравий]adj:n:v_rod:compb\", tokenizer, tagger);\n    TestTools.myAssert(\"дво-триметровий\", \"дво-триметровий/[дво-триметровий]adj:m:v_kly|дво-триметровий/[дво-триметровий]adj:m:v_naz|дво-триметровий/[дво-триметровий]adj:m:v_zna:rinanim\", tokenizer, tagger);\n    TestTools.myAssert(\"україно-болгарський\", \"україно-болгарський/[україно-болгарський]adj:m:v_kly|україно-болгарський/[україно-болгарський]adj:m:v_naz|україно-болгарський/[україно-болгарський]adj:m:v_zna:rinanim\", tokenizer, tagger);\n\n    TestTools.myAssert(\"бірмюково-блакитний\", \"бірмюково-блакитний/[null]null\", tokenizer, tagger);\n\n//    TestTools.myAssert(\"американо-блакитний\", \"американо-блакитний/[null]null\", tokenizer, tagger);\n\n    TestTools.myAssert(\"Дівчинка-першокласниця\", \"Дівчинка-першокласниця/[дівчинка-першокласниця]noun:anim:f:v_naz\", tokenizer, tagger);\n\n    TestTools.myAssert(\"RPM-пакунок\", \"RPM-пакунок/[RPM-пакунок]noun:inanim:m:v_naz|RPM-пакунок/[RPM-пакунок]noun:inanim:m:v_zna\", tokenizer, tagger);\n\n    TestTools.myAssert(\"учбово-спортивної\", \"учбово-спортивної/[учбово-спортивний]adj:f:v_rod:bad\", tokenizer, tagger);\n\n\n    assertNotTagged(\"авто-салон\");\n    assertNotTagged(\"квазі-держави\");\n    assertNotTagged(\"мульти-візу\");\n    assertNotTagged(\"напів-люкс\");\n    assertNotTagged(\"контр-міри\");\n    assertNotTagged(\"кіно-критика\");\n\n    assertNotTagged(\"Малишко-це\");\n    assertNotTagged(\"відносини-коли\");\n    assertNotTagged(\"лісо-та\");\n\n    assertNotTagged(\"древньо-римський\");\n    assertNotTagged(\"давньо-римський\");\n\n    assertNotTagged(\"Ліс-наш\");\n\n    assertNotTagged(\"кохання-найщиріше\"); // - мало би бути тире\n\n    // don't allow dash when the words spelled together\n    \n    assertNotTagged(\"дер-жав\");\n    assertNotTagged(\"зовнішньо-економічний\");\n    assertNotTagged(\"високо-релевантною\");\n    assertNotTagged(\"всесвітньо-відомі\");\n\n    assertNotTagged(\"Донець-кий\");\n    assertNotTagged(\"мас-штаби\");\n\n    assertNotTagged(\"максимально-можливу\"); // має бути \"максимально можливу\"\n\n//  assertNotTagged(\"льотно-посадкова\"); - загубилося початкове \"з\". Але це не спинило тегувальника - чому?\n\n\n//    TestTools.myAssert(\"дітей-сиріт\", \"дітей-сиріт/[діти-сироти]noun:anim:p:v_rod\", tokenizer, tagger);\n//    TestTools.myAssert(\"курей-бройлерів\", \"кури-бройлери\", tokenizer, tagger);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testTagger() throws IOException {\n\n    // one-way case sensitivity\n    TestTools.myAssert(\"києві\", \"києві/[кий]noun:inanim:m:v_dav|києві/[кий]noun:inanim:m:v_mis\", tokenizer, tagger);\n    TestTools.myAssert(\"Києві\", \"Києві/[Кий]noun:anim:m:v_dav:prop:fname|Києві/[Кий]noun:anim:m:v_mis:prop:fname|Києві/[Київ]noun:inanim:m:v_mis:prop|Києві/[кий]noun:inanim:m:v_dav|Києві/[кий]noun:inanim:m:v_mis\", tokenizer, tagger);\n    TestTools.myAssert(\"віл\", \"віл/[віл]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"Віл\", \"Віл/[віл]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"ВІЛ\", \"ВІЛ/[ВІЛ]noun:inanim:m:v_dav:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_kly:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_mis:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_naz:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_oru:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_rod:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_zna:nv:np:abbr|ВІЛ/[віл]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"далі\", \"далі/[даль]noun:inanim:f:v_dav|далі/[даль]noun:inanim:f:v_mis|далі/[даль]noun:inanim:f:v_rod|далі/[даль]noun:inanim:p:v_kly|далі/[даль]noun:inanim:p:v_naz|далі/[даль]noun:inanim:p:v_zna|далі/[далі]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"Далі\", \"Далі/[Даль]noun:anim:m:v_mis:prop:lname|Далі/[Далі]noun:anim:m:v_dav:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_kly:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_mis:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_naz:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_oru:nv:np:prop:lname\"\n        +\"|Далі/[Далі]noun:anim:m:v_rod:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_zna:nv:np:prop:lname|Далі/[даль]noun:inanim:f:v_dav|Далі/[даль]noun:inanim:f:v_mis|Далі/[даль]noun:inanim:f:v_rod|Далі/[даль]noun:inanim:p:v_kly|Далі/[даль]noun:inanim:p:v_naz|Далі/[даль]noun:inanim:p:v_zna|Далі/[далі]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"Бен\", \"Бен/[Бен]noun:anim:m:v_naz:prop:fname|Бен/[бен]part:pers\", tokenizer, tagger);\n    TestTools.myAssert(\"бен\", \"бен/[бен]part:pers\", tokenizer, tagger);\n\n\n    TestTools.myAssert(\"Справу порушено судом\", \n      \"Справу/[справа]noun:inanim:f:v_zna -- порушено/[порушити]verb:perf:impers -- судом/[суд]noun:inanim:m:v_oru|судом/[судома]noun:inanim:p:v_rod\",\n       tokenizer, tagger);\n       \n    String expected = \n      \"Майже/[майже]adv -- два/[два]numr:m:v_naz|два/[два]numr:m:v_zna:rinanim|два/[два]numr:n:v_naz|два/[два]numr:n:v_zna -- роки/[рік]noun:inanim:p:v_kly|роки/[рік]noun:inanim:p:v_naz|роки/[рік]noun:inanim:p:v_zna\"\n    + \" -- тому/[той]adj:m:v_dav:&pron:dem|тому/[той]adj:m:v_mis:&pron:dem|тому/[той]adj:n:v_dav:&pron:dem|тому/[той]adj:n:v_mis:&pron:dem|тому/[том]noun:inanim:m:v_dav|тому/[том]noun:inanim:m:v_mis|тому/[том]noun:inanim:m:v_rod|тому/[тому]adv|тому/[тому]conj:subord\"\n    + \" -- Люба/[Люба]noun:anim:f:v_naz:prop:fname|Люба/[любий]adj:f:v_kly|Люба/[любий]adj:f:v_naz -- разом/[раз]noun:inanim:m:v_oru|разом/[разом]adv -- із/[із]prep:rv_rod:rv_zna:rv_oru\"\n    + \" -- чоловіком/[чоловік]noun:anim:m:v_oru -- Степаном/[Степан]noun:anim:m:v_oru:prop:fname -- виїхали/[виїхати]verb:perf:past:p -- туди/[туди]adv:&pron:dem\"\n    + \" -- на/[на]excl|на/[на]part|на/[на]prep:rv_zna:rv_mis -- \"\n    + \"проживання/[проживання]noun:inanim:n:v_kly|проживання/[проживання]noun:inanim:n:v_naz|проживання/[проживання]noun:inanim:n:v_rod|проживання/[проживання]noun:inanim:n:v_zna\"\n    + \"|проживання/[проживання]noun:inanim:p:v_kly|проживання/[проживання]noun:inanim:p:v_naz|проживання/[проживання]noun:inanim:p:v_zna\";\n  \n    TestTools.myAssert(\"Майже два роки тому Люба разом із чоловіком Степаном виїхали туди на проживання.\",\n        expected, tokenizer, tagger);\n  }","id":9526,"modified_method":"@Test\n  public void testTagger() throws IOException {\n\n    // one-way case sensitivity\n    TestTools.myAssert(\"києві\", \"києві/[кий]noun:inanim:m:v_dav|києві/[кий]noun:inanim:m:v_mis\", tokenizer, tagger);\n    TestTools.myAssert(\"Києві\", \"Києві/[Кий]noun:anim:m:v_dav:prop:fname|Києві/[Кий]noun:anim:m:v_mis:prop:fname|Києві/[Київ]noun:inanim:m:v_mis:prop|Києві/[кий]noun:inanim:m:v_dav|Києві/[кий]noun:inanim:m:v_mis\", tokenizer, tagger);\n    TestTools.myAssert(\"віл\", \"віл/[віл]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"Віл\", \"Віл/[віл]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"ВІЛ\", \"ВІЛ/[ВІЛ]noun:inanim:m:v_dav:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_kly:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_mis:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_naz:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_oru:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_rod:nv:np:abbr|ВІЛ/[ВІЛ]noun:inanim:m:v_zna:nv:np:abbr|ВІЛ/[віл]noun:anim:m:v_naz\", tokenizer, tagger);\n    TestTools.myAssert(\"далі\", \"далі/[даль]noun:inanim:f:v_dav|далі/[даль]noun:inanim:f:v_mis|далі/[даль]noun:inanim:f:v_rod|далі/[даль]noun:inanim:p:v_kly|далі/[даль]noun:inanim:p:v_naz|далі/[даль]noun:inanim:p:v_zna|далі/[далі]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"Далі\", \"Далі/[Даль]noun:anim:m:v_mis:prop:lname|Далі/[Далі]noun:anim:m:v_dav:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_kly:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_mis:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_naz:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_oru:nv:np:prop:lname\"\n        +\"|Далі/[Далі]noun:anim:m:v_rod:nv:np:prop:lname|Далі/[Далі]noun:anim:m:v_zna:nv:np:prop:lname|Далі/[даль]noun:inanim:f:v_dav|Далі/[даль]noun:inanim:f:v_mis|Далі/[даль]noun:inanim:f:v_rod|Далі/[даль]noun:inanim:p:v_kly|Далі/[даль]noun:inanim:p:v_naz|Далі/[даль]noun:inanim:p:v_zna|Далі/[далі]adv\", tokenizer, tagger);\n    TestTools.myAssert(\"Бен\", \"Бен/[Бен]noun:anim:m:v_naz:prop:fname|Бен/[бен]part:pers\", tokenizer, tagger);\n    TestTools.myAssert(\"бен\", \"бен/[бен]part:pers\", tokenizer, tagger);\n\n\n    TestTools.myAssert(\"Справу порушено судом\", \n      \"Справу/[справа]noun:inanim:f:v_zna -- порушено/[порушити]verb:perf:impers -- судом/[суд]noun:inanim:m:v_oru|судом/[судома]noun:inanim:p:v_rod\",\n       tokenizer, tagger);\n       \n    String expected = \n      \"Майже/[майже]adv -- два/[два]numr:m:v_naz|два/[два]numr:m:v_zna|два/[два]numr:n:v_naz|два/[два]numr:n:v_zna -- роки/[рік]noun:inanim:p:v_kly|роки/[рік]noun:inanim:p:v_naz|роки/[рік]noun:inanim:p:v_zna\"\n    + \" -- тому/[те]noun:inanim:n:v_dav:&pron:dem|тому/[те]noun:inanim:n:v_mis:&pron:dem|тому/[той]adj:m:v_dav:&pron:dem|тому/[той]adj:m:v_mis:&pron:dem|тому/[той]adj:n:v_dav:&pron:dem|тому/[той]adj:n:v_mis:&pron:dem|тому/[том]noun:inanim:m:v_dav|тому/[том]noun:inanim:m:v_mis|тому/[том]noun:inanim:m:v_rod|тому/[тому]adv|тому/[тому]conj:subord\"\n    + \" -- Люба/[Люба]noun:anim:f:v_naz:prop:fname|Люба/[любий]adj:f:v_kly|Люба/[любий]adj:f:v_naz -- разом/[раз]noun:inanim:m:v_oru|разом/[разом]adv -- із/[із]prep:rv_rod:rv_zna:rv_oru\"\n    + \" -- чоловіком/[чоловік]noun:anim:m:v_oru -- Степаном/[Степан]noun:anim:m:v_oru:prop:fname -- виїхали/[виїхати]verb:perf:past:p -- туди/[туди]adv:&pron:dem\"\n    + \" -- на/[на]intj|на/[на]part|на/[на]prep:rv_zna:rv_mis -- \"\n    + \"проживання/[проживання]noun:inanim:n:v_kly|проживання/[проживання]noun:inanim:n:v_naz|проживання/[проживання]noun:inanim:n:v_rod|проживання/[проживання]noun:inanim:n:v_zna\"\n    + \"|проживання/[проживання]noun:inanim:p:v_kly|проживання/[проживання]noun:inanim:p:v_naz|проживання/[проживання]noun:inanim:p:v_zna\";\n  \n    TestTools.myAssert(\"Майже два роки тому Люба разом із чоловіком Степаном виїхали туди на проживання.\",\n        expected, tokenizer, tagger);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testDynamicTaggingSkip() throws IOException {\n    TestTools.myAssert(\"йо-га\", \"йо-га/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"с-г\", \"с-г/[null]null\", tokenizer, tagger);\n//    TestTools.myAssert(\"де-куди\", \"де-куди/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"чи-то\", \"чи-то/[null]null\", tokenizer, tagger);\n//    TestTools.myAssert(\"як-то\", \"як-то/[null]null\", tokenizer, tagger);\n  }","id":9527,"modified_method":"@Test\n  public void testDynamicTaggingSkip() throws IOException {\n    TestTools.myAssert(\"йо-га\", \"йо-га/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"с-г\", \"с-г/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"де-куди\", \"де-куди/[null]null\", tokenizer, tagger);\n    TestTools.myAssert(\"чи-то\", \"чи-то/[null]null\", tokenizer, tagger);\n//    TestTools.myAssert(\"як-то\", \"як-то/[як-то]conj:subord:bad\", tokenizer, tagger);\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Test\n  public void testUkrainian() throws IOException {\n    final Ukrainian ukrainian = new Ukrainian();\n    final UppercaseSentenceStartRule rule = new UppercaseSentenceStartRule(TestTools.getEnglishMessages(), ukrainian);\n    final JLanguageTool lt = new JLanguageTool(ukrainian);\n\n    assertEquals(0, rule.match(lt.getAnalyzedSentence(\"Автор написав це речення з великої літери.\")).length);\n\n    final RuleMatch[] matches = rule.match(lt.getAnalyzedSentence(\"автор написав це речення з маленької літери.\"));\n    assertEquals(1, matches.length);\n    assertEquals(1, matches[0].getSuggestedReplacements().size());\n    assertEquals(\"Автор\", matches[0].getSuggestedReplacements().get(0));\n    \n    assertEquals(new ArrayList<RuleMatch>(), lt.check(\"Це список з декількох рядків:\\n\\nрядок 1,\\n\\nрядок 2,\\n\\nрядок 3.\"));\n    assertEquals(0, lt.check(\"Це список з декількох рядків:\\n\\nрядок 1;\\n\\nрядок 2;\\n\\nрядок 3.\").size());\n    assertEquals(0, lt.check(\"Це список з декількох рядків:\\n\\n 1) рядок 1;\\n\\n2) рядок 2;\\n\\n3)рядок 3.\").size());\n  }","id":9528,"modified_method":"@Test\n  public void testUkrainian() throws IOException {\n    final Ukrainian ukrainian = new Ukrainian();\n    final UppercaseSentenceStartRule rule = new UppercaseSentenceStartRule(TestTools.getEnglishMessages(), ukrainian);\n    final JLanguageTool lt = new JLanguageTool(ukrainian);\n\n    assertEquals(0, rule.match(lt.getAnalyzedSentence(\"Автор написав це речення з великої літери.\")).length);\n\n    final RuleMatch[] matches = rule.match(lt.getAnalyzedSentence(\"автор написав це речення з маленької літери.\"));\n    assertEquals(1, matches.length);\n    assertEquals(1, matches[0].getSuggestedReplacements().size());\n    assertEquals(\"Автор\", matches[0].getSuggestedReplacements().get(0));\n    \n    assertEquals(new ArrayList<RuleMatch>(), lt.check(\"Цей список з декількох рядків:\\n\\nрядок 1,\\n\\nрядок 2,\\n\\nрядок 3.\"));\n    assertEquals(0, lt.check(\"Цей список з декількох рядків:\\n\\nрядок 1;\\n\\nрядок 2;\\n\\nрядок 3.\").size());\n    assertEquals(0, lt.check(\"Цей список з декількох рядків:\\n\\n 1) рядок 1;\\n\\n2) рядок 2;\\n\\n3)рядок 3.\").size());\n  }","commit_id":"92d76df015db99119124d4ab272bac78979c20eb","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public MergeModelsDialog(SModel baseModel, SModel mineModel, SModel repositoryModel, DiffRequest request) {\n    super(request.getProject(), true);\n    setTitle(\"Merging \" + baseModel.getModelDescriptor().getModelName());\n    myProject = request.getProject();\n    myContentTitles = request.getContentTitles();\n    assert myContentTitles.length == 3;\n    jetbrains.mps.project.Project p = ProjectHelper.toMPSProject(myProject);\n    // temporary: create \"normal\" models \n    final org.jetbrains.mps.openapi.model.SModel baseMD = new MergeTemporaryModel(baseModel, true);\n    final org.jetbrains.mps.openapi.model.SModel mineMD = new MergeTemporaryModel(mineModel, true);\n    final org.jetbrains.mps.openapi.model.SModel repoMD = new MergeTemporaryModel(repositoryModel, true);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myMergeSession = MergeSession.createMergeSession(baseMD, mineMD, repoMD);\n        myInitialState = myMergeSession.getCurrentState();\n      }\n    });\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getBaseModel(), \"base\");\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getMyModel(), \"mine\");\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getRepositoryModel(), \"repo\");\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getResultModel(), \"result\");\n      }\n    });\n    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          org.jetbrains.mps.openapi.model.SModel baseMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getBaseModel(), \"metadata_base\", false);\n          org.jetbrains.mps.openapi.model.SModel mineMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getMyModel(), \"metadata_mine\", false);\n          org.jetbrains.mps.openapi.model.SModel repoMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getRepositoryModel(), \"metadata_repo\", false);\n          myMetadataMergeSession = MergeSession.createMergeSession(baseMetaModel, mineMetaModel, repoMetaModel);\n          myMetadataInitialState = myMetadataMergeSession.getCurrentState();\n          DiffModelUtil.renameModelAndRegister(myMetadataMergeSession.getResultModel(), \"result\");\n        }\n      });\n    }\n\n    myMergeSession.installResultModelListener();\n\n    myActionGroup = ActionUtils.groupFromActions(new InvokeTextDiffAction(\"Merge as Text (Use Carefully!)\", \"Merge models using text merge for XML contents\", this, request, new MergeTool()), Separator.getInstance(), new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this));\n\n    init();\n  }","id":9529,"modified_method":"public MergeModelsDialog(final SModel baseModel, final SModel mineModel, final SModel repoModel, DiffRequest request) {\n    super(request.getProject(), true);\n    setTitle(\"Merging \" + SModelOperations.getModelName(baseModel));\n    myProject = request.getProject();\n    myContentTitles = request.getContentTitles();\n    assert myContentTitles.length == 3;\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myMergeSession = MergeSession.createMergeSession(baseModel, mineModel, repoModel);\n        myInitialState = myMergeSession.getCurrentState();\n      }\n    });\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getBaseModel(), \"base\");\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getMyModel(), \"mine\");\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getRepositoryModel(), \"repo\");\n        DiffModelUtil.renameModelAndRegister(myMergeSession.getResultModel(), \"result\");\n      }\n    });\n    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          SModel baseMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getBaseModel(), \"metadata_base\", false);\n          SModel mineMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getMyModel(), \"metadata_mine\", false);\n          SModel repoMetaModel = MetadataUtil.createMetadataModel(myMergeSession.getRepositoryModel(), \"metadata_repo\", false);\n          myMetadataMergeSession = MergeSession.createMergeSession(baseMetaModel, mineMetaModel, repoMetaModel);\n          myMetadataInitialState = myMetadataMergeSession.getCurrentState();\n          DiffModelUtil.renameModelAndRegister(myMetadataMergeSession.getResultModel(), \"result\");\n        }\n      });\n    }\n\n    myMergeSession.installResultModelListener();\n\n    myActionGroup = ActionUtils.groupFromActions(new InvokeTextDiffAction(\"Merge as Text (Use Carefully!)\", \"Merge models using text merge for XML contents\", this, request, new MergeTool()), Separator.getInstance(), new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this));\n\n    init();\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void unregisterModels() {\n    jetbrains.mps.project.Project p = ProjectHelper.toMPSProject(myProject);\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        if (myMetadataMergeSession != null) {\n          DiffModelUtil.unregisterModel(myMetadataMergeSession.getResultModel());\n          MetadataUtil.dispose(myMetadataMergeSession.getRepositoryModel());\n          MetadataUtil.dispose(myMetadataMergeSession.getMyModel());\n          MetadataUtil.dispose(myMetadataMergeSession.getBaseModel());\n        }\n        DiffModelUtil.unregisterModel(myMergeSession.getResultModel());\n        DiffModelUtil.unregisterModel(myMergeSession.getRepositoryModel());\n        DiffModelUtil.unregisterModel(myMergeSession.getMyModel());\n        DiffModelUtil.unregisterModel(myMergeSession.getBaseModel());\n\n      }\n    });\n  }","id":9530,"modified_method":"public void unregisterModels() {\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        if (myMetadataMergeSession != null) {\n          DiffModelUtil.unregisterModel(myMetadataMergeSession.getResultModel());\n          MetadataUtil.dispose(myMetadataMergeSession.getRepositoryModel());\n          MetadataUtil.dispose(myMetadataMergeSession.getMyModel());\n          MetadataUtil.dispose(myMetadataMergeSession.getBaseModel());\n        }\n        DiffModelUtil.unregisterModel(myMergeSession.getResultModel());\n        DiffModelUtil.unregisterModel(myMergeSession.getRepositoryModel());\n        DiffModelUtil.unregisterModel(myMergeSession.getMyModel());\n        DiffModelUtil.unregisterModel(myMergeSession.getBaseModel());\n      }\n    });\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected Iterable<org.jetbrains.mps.openapi.model.SModel> getModels() {\n      return Arrays.asList(myMergeSession.getBaseModel(), myMergeSession.getMyModel(), myMergeSession.getRepositoryModel());\n    }","id":9531,"modified_method":"@Override\n    protected Iterable<SModel> getModels() {\n      return Arrays.asList(myMergeSession.getBaseModel(), myMergeSession.getMyModel(), myMergeSession.getRepositoryModel());\n    }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SModel getResultModelWithFixedId() {\n    if (!(myApplyChanges)) {\n      return null;\n    }\n    final org.jetbrains.mps.openapi.model.SModel resultModel = myMergeSession.getResultModel();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffModelUtil.restoreModelName(resultModel);\n        // fix??? \n        for (org.jetbrains.mps.openapi.model.SModel m : new org.jetbrains.mps.openapi.model.SModel[]{myMergeSession.getMyModel(), myMergeSession.getRepositoryModel()}) {\n          DiffModelUtil.fixModelReferences(resultModel, m.getReference());\n        }\n      }\n    });\n    return as_3qqb0l_a0a3a53(resultModel, SModelBase.class).getSModelInternal();\n  }","id":9532,"modified_method":"public SModel getResultModelWithFixedId() {\n    if (!(myApplyChanges)) {\n      return null;\n    }\n    final SModel resultModel = myMergeSession.getResultModel();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffModelUtil.restoreModelName(resultModel);\n        // fix??? \n        for (SModel m : new SModel[]{myMergeSession.getMyModel(), myMergeSession.getRepositoryModel()}) {\n          DiffModelUtil.fixModelReferences(resultModel, m.getReference());\n        }\n      }\n    });\n    return resultModel;\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SModel getResultModel() {\n    return (myApplyChanges ?\n      as_3qqb0l_a0a0a0ib(myMergeSession.getResultModel(), SModelBase.class).getSModelInternal() :\n      null\n    );\n  }","id":9533,"modified_method":"public SModel getResultModel() {\n    return (myApplyChanges ?\n      myMergeSession.getResultModel() :\n      null\n    );\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void show(final DiffRequest request) {\n    MergeRequestImpl mrequest = (MergeRequestImpl) request;\n    try {\n      VirtualFile file = getFileFromMergeRequest(mrequest);\n      if (file == null) {\n        if (LOG_705910402.isEnabledFor(Priority.ERROR)) {\n          LOG_705910402.error(\"No file\");\n        }\n        file = LocalFileSystem.getInstance().findFileByPath(\"/\");\n      }\n      File backupFile = MergeBackupUtil.zipModel(request.getContents(), file);\n      DiffContent[] contents = mrequest.getContents();\n      final SModel baseModel;\n      final SModel mineModel;\n      final SModel newModel;\n      try {\n        baseModel = ModelPersistence.readModel(contents[MergeConstants.ORIGINAL].getDocument().getText(), false);\n        mineModel = ModelPersistence.readModel(new String(contents[MergeConstants.CURRENT].getBytes(), FileUtil.DEFAULT_CHARSET), false);\n        newModel = ModelPersistence.readModel(new String(contents[MergeConstants.LAST_REVISION].getBytes(), FileUtil.DEFAULT_CHARSET), false);\n      } catch (ModelReadException e) {\n        if (LOG_705910402.isEnabledFor(Priority.WARN)) {\n          LOG_705910402.warn(\"Couldn't read model, invoking text merge\", e);\n        }\n        super.show(request);\n        return;\n      }\n\n      final MergeModelsDialog dialog = new MergeModelsDialog(baseModel, mineModel, newModel, mrequest);\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          dialog.toFront();\n        }\n      });\n      dialog.show();\n      SModel resultModel = dialog.getResultModelWithFixedId();\n      if (resultModel != null) {\n        String asString = ModelPersistence.modelToString(resultModel);\n        resolved(mrequest, asString);\n        MergeBackupUtil.packMergeResult(backupFile, file.getName(), asString);\n      }\n      dialog.unregisterModels();\n    } catch (IOException e) {\n      LOG.error(null, e);\n    }\n  }","id":9534,"modified_method":"@Override\n  public void show(final DiffRequest request) {\n    MergeRequestImpl mrequest = (MergeRequestImpl) request;\n    try {\n      VirtualFile file = getFileFromMergeRequest(mrequest);\n      if (file == null) {\n        if (LOG_705910402.isEnabledFor(Priority.ERROR)) {\n          LOG_705910402.error(\"No file\");\n        }\n        file = LocalFileSystem.getInstance().findFileByPath(\"/\");\n      }\n      File backupFile = MergeBackupUtil.zipModel(request.getContents(), file);\n      DiffContent[] contents = mrequest.getContents();\n      String ext = file.getExtension();\n      SModel baseModel = PersistenceUtil.loadModel(contents[MergeConstants.ORIGINAL].getDocument().getText(), ext);\n      SModel mineModel = PersistenceUtil.loadModel(contents[MergeConstants.CURRENT].getBytes(), ext);\n      SModel newModel = PersistenceUtil.loadModel(contents[MergeConstants.LAST_REVISION].getBytes(), ext);\n      if (baseModel == null || mineModel == null || newModel == null) {\n        if (LOG_705910402.isEnabledFor(Priority.WARN)) {\n          LOG_705910402.warn(\"Couldn't read model, invoking text merge\");\n        }\n        super.show(request);\n        return;\n      }\n\n      final MergeModelsDialog dialog = new MergeModelsDialog(baseModel, mineModel, newModel, mrequest);\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          dialog.toFront();\n        }\n      });\n      dialog.show();\n      SModel resultModel = dialog.getResultModelWithFixedId();\n      if (resultModel != null) {\n        String asString = ModelPersistence.modelToString(as_7qvsj_a0a0a0a41a1a2(resultModel, SModelBase.class).getSModelInternal());\n        resolved(mrequest, asString);\n        MergeBackupUtil.packMergeResult(backupFile, file.getName(), asString);\n      }\n      dialog.unregisterModels();\n    } catch (IOException e) {\n      LOG.error(null, e);\n    }\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, true, true, false, false) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          return !((file.isDirectory())) && file.getName().toLowerCase().endsWith(\".zip\");\n        }\n      };\n\n      descriptor.setTitle(\"select archive with merge files\");\n      descriptor.setDescription(\"Zip files (*.zip) \");\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          VirtualFile vFile = FileChooser.chooseFile(((Project) MapSequence.fromMap(_params).get(\"project\")), descriptor);\n\n          String resString;\n          SModel[] zipped;\n          try {\n            zipped = MergeBackupUtil.loadZippedModels(new File(vFile.getCanonicalPath()), new MergeVersion[]{MergeVersion.BASE, MergeVersion.MINE, MergeVersion.REPOSITORY});\n            resString = File.createTempFile(\"mpstmp\", \".result\").getAbsolutePath();\n          } catch (Exception e) {\n            e.printStackTrace();\n            return;\n          }\n\n          final String resFile = resString;\n          final SModel[] models = zipped;\n\n          MergeModelsDialog dialog = new MergeModelsDialog(models[0], models[1], models[2], new SimpleDiffRequest(((Project) MapSequence.fromMap(_params).get(\"project\")), models, new String[]{\"Local Version\", \"Merge Result\", \"Remote Version\"}));\n          dialog.show();\n          final SModel result = dialog.getResultModelWithFixedId();\n          if (result != null) {\n            ModelAccess.instance().runWriteAction(new Runnable() {\n              @Override\n              public void run() {\n                IFile iFile = FileSystem.getInstance().getFileByPath(resFile);\n                if (!(iFile.exists())) {\n                  iFile.createNewFile();\n                }\n                try {\n                  ModelPersistence.saveModel(result, new FileDataSource(iFile));\n                } catch (IOException e) {\n                  if (LOG.isEnabledFor(Priority.ERROR)) {\n                    LOG.error(\"Cannot save model.\", e);\n                  }\n                }\n              }\n            });\n          }\n          dialog.unregisterModels();\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"TestMergeAction\", t);\n      }\n    }\n  }","id":9535,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, true, true, false, false) {\n        @Override\n        public boolean isFileSelectable(VirtualFile file) {\n          return !((file.isDirectory())) && file.getName().toLowerCase().endsWith(\".zip\");\n        }\n      };\n\n      descriptor.setTitle(\"select archive with merge files\");\n      descriptor.setDescription(\"Zip files (*.zip) \");\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          VirtualFile vFile = FileChooser.chooseFile(((Project) MapSequence.fromMap(_params).get(\"project\")), descriptor);\n\n          final String resFile;\n          SModel[] zipped;\n          try {\n            zipped = MergeBackupUtil.loadZippedModels(new File(vFile.getCanonicalPath()), new MergeVersion[]{MergeVersion.BASE, MergeVersion.MINE, MergeVersion.REPOSITORY});\n            resFile = File.createTempFile(\"mpstmp\", \".result\").getAbsolutePath();\n          } catch (Exception e) {\n            e.printStackTrace();\n            return;\n          }\n\n          MergeModelsDialog dialog = new MergeModelsDialog(new MergeTemporaryModel(zipped[0], true), new MergeTemporaryModel(zipped[1], true), new MergeTemporaryModel(zipped[2], true), new SimpleDiffRequest(((Project) MapSequence.fromMap(_params).get(\"project\")), zipped, new String[]{\"Local Version\", \"Merge Result\", \"Remote Version\"}));\n          dialog.show();\n          final org.jetbrains.mps.openapi.model.SModel result = dialog.getResultModelWithFixedId();\n          if (result != null) {\n            ModelAccess.instance().runWriteAction(new Runnable() {\n              @Override\n              public void run() {\n                IFile iFile = FileSystem.getInstance().getFileByPath(resFile);\n                if (!(iFile.exists())) {\n                  iFile.createNewFile();\n                }\n                try {\n                  ModelPersistence.saveModel(as_81bq2k_a0a0a0c0a0a0a0a0j0a0a0a4a0a5(result, SModelBase.class).getSModelInternal(), new FileDataSource(iFile));\n                } catch (IOException e) {\n                  if (LOG.isEnabledFor(Priority.ERROR)) {\n                    LOG.error(\"Cannot save model.\", e);\n                  }\n                }\n              }\n            });\n          }\n          dialog.unregisterModels();\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"TestMergeAction\", t);\n      }\n    }\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void main(String[] args) throws JDOMException, IOException, ModelReadException {\n    if (args.length == 0) {\n      System.out.print(\"Input path to model zip: \");\n      String line = new Scanner(System.in).nextLine();\n      args = new String[]{((line == null ?\n        null :\n        line.trim()\n      ))};\n    }\n    ENV = new IdeaEnvironment(EnvironmentConfig.defaultEnvironment());\n    IdeMain.setTestMode(IdeMain.TestMode.NO_TEST);\n    IconLoader.activate();\n    final SModel[] models = new SModel[3];\n    String resultFile;\n    if (args.length == 2 || args.length == 1) {\n      final SModel[] zipped = MergeBackupUtil.loadZippedModels(new File(args[0]), new MergeVersion[]{MergeVersion.BASE, MergeVersion.MINE, MergeVersion.REPOSITORY});\n      models[0] = zipped[0];\n      models[1] = zipped[1];\n      models[2] = zipped[2];\n      if (args.length == 1) {\n        resultFile = File.createTempFile(\"mpstmd\", \"\").getAbsolutePath();\n      } else {\n        resultFile = args[1];\n      }\n    } else\n    if (args.length == 4 || args.length == 3) {\n      models[0] = ModelPersistence.readModel(new FileDataSource(FileSystem.getInstance().getFileByPath(args[0])), false);\n      models[1] = ModelPersistence.readModel(new FileDataSource(FileSystem.getInstance().getFileByPath(args[1])), false);\n      models[2] = ModelPersistence.readModel(new FileDataSource(FileSystem.getInstance().getFileByPath(args[2])), false);\n      if (args.length == 3) {\n        resultFile = File.createTempFile(\"\", \"\").getAbsolutePath();\n      } else {\n        resultFile = args[3];\n      }\n    } else {\n      System.err.println(\"There must be 1-4 parameters\");\n      return;\n    }\n    final String finalResultFile = resultFile;\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        MergeModelsDialog dialog = ModelAccess.instance().runReadAction(new Computable<MergeModelsDialog>() {\n          public MergeModelsDialog compute() {\n            return new MergeModelsDialog(models[0], models[1], models[2], new SimpleDiffRequest(TestMergeDialog.ourProject, (SModel[]) null, new String[]{\"Local Version\", \"Merge Result\", \"Remote Version\"}));\n          }\n        });\n        try {\n          Field field = dialog.getClass().getDeclaredField(\"myMergeTree\");\n          field.setAccessible(true);\n          IdeaTestApplication.getInstance(null).setDataProvider((DiffModelTree) field.get(dialog));\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        dialog.show();\n        final SModel result = dialog.getResultModelWithFixedId();\n        if (result == null) {\n          dialog.close(0);\n          System.exit(0);\n        }\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            IFile iFile = FileSystem.getInstance().getFileByPath(finalResultFile);\n            if (!(iFile.exists())) {\n              iFile.createNewFile();\n            }\n            try {\n              ModelPersistence.saveModel(result, new FileDataSource(iFile));\n            } catch (IOException ex) {\n              if (LOG.isEnabledFor(Priority.ERROR)) {\n                LOG.error(\"Cannot save model.\", ex);\n              }\n            }\n          }\n        });\n        dialog.unregisterModels();\n        dialog.close(0);\n        Disposer.dispose(TestMergeDialog.myParentDisposable);\n        System.exit(0);\n      }\n    });\n  }","id":9536,"modified_method":"public static void main(String[] args) throws JDOMException, IOException, ModelReadException {\n    if (args.length == 0) {\n      System.out.print(\"Input path to model zip: \");\n      String line = new Scanner(System.in).nextLine();\n      args = new String[]{((line == null ?\n        null :\n        line.trim()\n      ))};\n    }\n    ENV = new IdeaEnvironment(EnvironmentConfig.defaultEnvironment());\n    IdeMain.setTestMode(IdeMain.TestMode.NO_TEST);\n    IconLoader.activate();\n    final SModel[] models = new SModel[3];\n    String resultFile;\n    if (args.length == 2 || args.length == 1) {\n      final SModel[] zipped = MergeBackupUtil.loadZippedModels(new File(args[0]), new MergeVersion[]{MergeVersion.BASE, MergeVersion.MINE, MergeVersion.REPOSITORY});\n      models[0] = zipped[0];\n      models[1] = zipped[1];\n      models[2] = zipped[2];\n      if (args.length == 1) {\n        resultFile = File.createTempFile(\"mpstmd\", \"\").getAbsolutePath();\n      } else {\n        resultFile = args[1];\n      }\n    } else\n    if (args.length == 4 || args.length == 3) {\n      models[0] = ModelPersistence.readModel(new FileDataSource(FileSystem.getInstance().getFileByPath(args[0])), false);\n      models[1] = ModelPersistence.readModel(new FileDataSource(FileSystem.getInstance().getFileByPath(args[1])), false);\n      models[2] = ModelPersistence.readModel(new FileDataSource(FileSystem.getInstance().getFileByPath(args[2])), false);\n      if (args.length == 3) {\n        resultFile = File.createTempFile(\"\", \"\").getAbsolutePath();\n      } else {\n        resultFile = args[3];\n      }\n    } else {\n      System.err.println(\"There must be 1-4 parameters\");\n      return;\n    }\n    final String finalResultFile = resultFile;\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        MergeModelsDialog dialog = ModelAccess.instance().runReadAction(new Computable<MergeModelsDialog>() {\n          public MergeModelsDialog compute() {\n            return new MergeModelsDialog(new MergeTemporaryModel(models[0], true), new MergeTemporaryModel(models[1], true), new MergeTemporaryModel(models[2], true), new SimpleDiffRequest(TestMergeDialog.ourProject, (SModel[]) null, new String[]{\"Local Version\", \"Merge Result\", \"Remote Version\"}));\n          }\n        });\n        try {\n          Field field = dialog.getClass().getDeclaredField(\"myMergeTree\");\n          field.setAccessible(true);\n          IdeaTestApplication.getInstance(null).setDataProvider((DiffModelTree) field.get(dialog));\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n        dialog.show();\n        final org.jetbrains.mps.openapi.model.SModel result = dialog.getResultModelWithFixedId();\n        if (result == null) {\n          dialog.close(0);\n          System.exit(0);\n        }\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            IFile iFile = FileSystem.getInstance().getFileByPath(finalResultFile);\n            if (!(iFile.exists())) {\n              iFile.createNewFile();\n            }\n            try {\n              ModelPersistence.saveModel(as_jrs6o7_a0a0a0c0a0a0a0f0a0a0a8a7(result, SModelBase.class).getSModelInternal(), new FileDataSource(iFile));\n            } catch (IOException ex) {\n              if (LOG.isEnabledFor(Priority.ERROR)) {\n                LOG.error(\"Cannot save model.\", ex);\n              }\n            }\n          }\n        });\n        dialog.unregisterModels();\n        dialog.close(0);\n        Disposer.dispose(TestMergeDialog.myParentDisposable);\n        System.exit(0);\n      }\n    });\n  }","commit_id":"22ef374b0b6e77296876c4a6dd352da987ddb61b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(Messages.getString(\"XBaseInput.Log.StartingToRun\"));\t\t //$NON-NLS-1$\n\t\t\twhile (!isStopped() && processRow(meta, data) );\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"XBaseInput.Log.Error.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\n            logError(Const.getStackTracker(e));\n            setErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t    dispose(meta, data);\n\t\t\tmarkStop();\n\t\t    logSummary();\n\t\t}\n\t}","id":9537,"modified_method":"public void run()\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"System.Log.StartingToRun\")); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Throwable t)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"System.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Const.getStackTracker(t));\r\n            setErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","commit_id":"aaed9023594bb85643a885b26a1f3a9118319a90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\r\n\t{\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"XsdValidator.Log.StartingToRun\")); //$NON-NLS-1$\r\n\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"XsdValidator.Log.UnexpectedeError\")+\" : \"+e.toString()); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Messages.getString(\"XsdValidator.Log.ErrorStackTrace\")+Const.CR+Const.getStackTracker(e)); //$NON-NLS-1$\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","id":9538,"modified_method":"public void run()\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"System.Log.StartingToRun\")); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Throwable t)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"System.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Const.getStackTracker(t));\r\n            setErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","commit_id":"aaed9023594bb85643a885b26a1f3a9118319a90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\n\t{\n\t\tlogBasic(Messages.getString(\"DatabaseJoin.Log.StartingToRun\")); //$NON-NLS-1$\n\t\t\n\t\ttry\n\t\t{\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"DatabaseJoin.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\n            logError(Const.getStackTracker(e));\n            setErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t\t\n\t}","id":9539,"modified_method":"public void run()\r\n    {\r\n        try\r\n        {\r\n        \tlogBasic(Messages.getString(\"System.Log.StartingToRun\")); //$NON-NLS-1$\r\n\r\n        \twhile (processRow(meta, data) && !isStopped());\r\n        }\r\n        catch(Throwable t)\r\n        {\r\n            logError(Messages.getString(\"System.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Const.getStackTracker(t));\r\n            setErrors(1);\r\n            stopAll();\r\n        }\r\n        finally\r\n        {\r\n        \tdispose(meta, data);\r\n            logSummary();\r\n            markStop();\r\n        }\r\n    }","commit_id":"aa869ccdec49758f7218998285fb899c719b85c7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\r\n\t{\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"RegexEval.Log.StartingToRun\")); //$NON-NLS-1$\r\n\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\t\r\n\r\n\t\t\t\r\n\t\t\tlogError(Messages.getString(\"RegexEval.Log.UnexpectedeError\")+\" : \"+e.toString()); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Messages.getString(\"RegexEval.Log.ErrorStackTrace\")+Const.CR+Const.getStackTracker(e)); //$NON-NLS-1$\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","id":9540,"modified_method":"public void run()\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"System.Log.StartingToRun\")); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Throwable t)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"System.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Const.getStackTracker(t));\r\n            setErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","commit_id":"aa869ccdec49758f7218998285fb899c719b85c7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\n    {\n\n        nbRowProcess = 0;\n        logBasic(\"Starting to run...\");\n        try\n        {\n            requestTime = 0;\n            while (processRow(meta, data) && !isStopped())\n                ;\n        }\n        catch (Exception e)\n        {\n            logError(\"Unexpected error: \", e);\n            setErrors(1);\n            stopAll();\n        }\n        finally\n        {\n            dispose(meta, data);\n            logBasic(\"Finished, processing \" + linesRead + \" rows\");\n            markStop();\n        }\n    }","id":9541,"modified_method":"public void run()\n\t{\n\t\ttry\n\t\t{\n\t\t\tlogBasic(Messages.getString(\"System.Log.StartingToRun\")); //$NON-NLS-1$\n\t\t\t\n\t\t\twhile (processRow(meta, data) && !isStopped());\n\t\t}\n\t\tcatch(Throwable t)\n\t\t{\n\t\t\tlogError(Messages.getString(\"System.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\n            logError(Const.getStackTracker(t));\n            setErrors(1);\n\t\t\tstopAll();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tdispose(meta, data);\n\t\t\tlogSummary();\n\t\t\tmarkStop();\n\t\t}\n\t}","commit_id":"f6f9dfd0f55fe89eaeea4c7e69e9a3f980d60b2e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void run()\r\n\t{\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"Xslt.Log.StartingToRun\")); //$NON-NLS-1$\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Exception e)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"Xslt.Log.UnexpectedeError\")+\" : \"+e.toString()); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Messages.getString(\"Xslt.Log.ErrorStackTrace\")+Const.CR+Const.getStackTracker(e)); //$NON-NLS-1$\r\n\t\t\tsetErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","id":9542,"modified_method":"public void run()\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tlogBasic(Messages.getString(\"System.Log.StartingToRun\")); //$NON-NLS-1$\r\n\t\t\t\r\n\t\t\twhile (processRow(meta, data) && !isStopped());\r\n\t\t}\r\n\t\tcatch(Throwable t)\r\n\t\t{\r\n\t\t\tlogError(Messages.getString(\"System.Log.UnexpectedError\")+\" : \"); //$NON-NLS-1$ //$NON-NLS-2$\r\n            logError(Const.getStackTracker(t));\r\n            setErrors(1);\r\n\t\t\tstopAll();\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tdispose(meta, data);\r\n\t\t\tlogSummary();\r\n\t\t\tmarkStop();\r\n\t\t}\r\n\t}","commit_id":"f6f9dfd0f55fe89eaeea4c7e69e9a3f980d60b2e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    protected final void doRun(SlingHttpServletRequest request,\n            HtmlResponse response) throws RepositoryException {\n\n        Resource resource = request.getResource();\n        String source = resource.getPath();\n\n        // ensure dest is not empty/null and is absolute\n        String dest = request.getParameter(SlingPostConstants.RP_DEST);\n        if (dest == null || dest.length() == 0) {\n            throw new IllegalArgumentException(\"Unable to process \"\n                + getOperationName() + \". Missing destination\");\n        }\n\n        // register whether the path ends with a trailing slash\n        boolean trailingSlash = dest.endsWith(\"/\");\n\n        // ensure destination is an absolute and normalized path\n        if (!dest.startsWith(\"/\")) {\n            dest = ResourceUtil.getParent(source) + \"/\" + dest;\n        }\n        dest = ResourceUtil.normalize(dest);\n\n        // destination parent and name\n        String dstParent = trailingSlash ? dest : ResourceUtil.getParent(dest);\n\n        // delete destination if already exists\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n        if (!trailingSlash && session.itemExists(dest)) {\n\n            final String replaceString = request.getParameter(SlingPostConstants.RP_REPLACE);\n            final boolean isReplace = \"true\".equalsIgnoreCase(replaceString);\n            if (!isReplace) {\n                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED,\n                    \"Cannot \" + getOperationName() + \" \" + resource + \" to \"\n                        + dest + \": destination exists\");\n                return;\n            }\n\n        } else {\n\n            // check if path to destination exists and create it, but only\n            // if it's a descendant of the current node\n            if (!dstParent.equals(\"\") && !session.itemExists(dstParent)) {\n                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED,\n                    \"Cannot \" + getOperationName() + \" \" + resource + \" to \"\n                        + dest + \": parent of destination does not exist\");\n                return;\n            }\n\n            // the destination is newly created, hence a create request\n            response.setCreateRequest(true);\n        }\n\n        Iterator<Resource> resources = getApplyToResources(request);\n        if (resources == null) {\n\n            // ensure we have an item underlying the request's resource\n            Item item = resource.adaptTo(Item.class);\n            if (item == null) {\n                throw new ResourceNotFoundException(\"Missing source \"\n                    + resource + \" for \" + getOperationName());\n            }\n\n            String dstName = trailingSlash ? null : ResourceUtil.getName(dest);\n            execute(response, item, dstParent, dstName);\n\n        } else {\n\n            // multiple applyTo requires trailing slash on destination\n            if (!trailingSlash) {\n                throw new IllegalArgumentException(\n                    \"Applying \"\n                        + getOperationName()\n                        + \" to multiple resources requires a trailing slash on the destination\");\n            }\n\n            // multiple copy will never return 201/CREATED\n            response.setCreateRequest(false);\n\n            while (resources.hasNext()) {\n                Resource applyTo = resources.next();\n                Item item = applyTo.adaptTo(Item.class);\n                if (item != null) {\n                    execute(response, item, dstParent, null);\n                }\n            }\n\n        }\n\n        // finally apply the ordering parameter\n        orderNode(request, session.getItem(dest));\n    }","id":9543,"modified_method":"@Override\n    protected final void doRun(SlingHttpServletRequest request,\n            HtmlResponse response,\n            List<Modification> changes)\n    throws RepositoryException {\n\n        Resource resource = request.getResource();\n        String source = resource.getPath();\n\n        // ensure dest is not empty/null and is absolute\n        String dest = request.getParameter(SlingPostConstants.RP_DEST);\n        if (dest == null || dest.length() == 0) {\n            throw new IllegalArgumentException(\"Unable to process \"\n                + getOperationName() + \". Missing destination\");\n        }\n\n        // register whether the path ends with a trailing slash\n        boolean trailingSlash = dest.endsWith(\"/\");\n\n        // ensure destination is an absolute and normalized path\n        if (!dest.startsWith(\"/\")) {\n            dest = ResourceUtil.getParent(source) + \"/\" + dest;\n        }\n        dest = ResourceUtil.normalize(dest);\n\n        // destination parent and name\n        String dstParent = trailingSlash ? dest : ResourceUtil.getParent(dest);\n\n        // delete destination if already exists\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n        if (!trailingSlash && session.itemExists(dest)) {\n\n            final String replaceString = request.getParameter(SlingPostConstants.RP_REPLACE);\n            final boolean isReplace = \"true\".equalsIgnoreCase(replaceString);\n            if (!isReplace) {\n                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED,\n                    \"Cannot \" + getOperationName() + \" \" + resource + \" to \"\n                        + dest + \": destination exists\");\n                return;\n            }\n\n        } else {\n\n            // check if path to destination exists and create it, but only\n            // if it's a descendant of the current node\n            if (!dstParent.equals(\"\") && !session.itemExists(dstParent)) {\n                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED,\n                    \"Cannot \" + getOperationName() + \" \" + resource + \" to \"\n                        + dest + \": parent of destination does not exist\");\n                return;\n            }\n\n            // the destination is newly created, hence a create request\n            response.setCreateRequest(true);\n        }\n\n        Iterator<Resource> resources = getApplyToResources(request);\n        if (resources == null) {\n\n            // ensure we have an item underlying the request's resource\n            Item item = resource.adaptTo(Item.class);\n            if (item == null) {\n                throw new ResourceNotFoundException(\"Missing source \"\n                    + resource + \" for \" + getOperationName());\n            }\n\n            String dstName = trailingSlash ? null : ResourceUtil.getName(dest);\n            execute(changes, item, dstParent, dstName);\n\n        } else {\n\n            // multiple applyTo requires trailing slash on destination\n            if (!trailingSlash) {\n                throw new IllegalArgumentException(\n                    \"Applying \"\n                        + getOperationName()\n                        + \" to multiple resources requires a trailing slash on the destination\");\n            }\n\n            // multiple copy will never return 201/CREATED\n            response.setCreateRequest(false);\n\n            while (resources.hasNext()) {\n                Resource applyTo = resources.next();\n                Item item = applyTo.adaptTo(Item.class);\n                if (item != null) {\n                    execute(changes, item, dstParent, null);\n                }\n            }\n\n        }\n\n        // finally apply the ordering parameter\n        orderNode(request, session.getItem(dest));\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"protected abstract void doRun(SlingHttpServletRequest request,\n            HtmlResponse response) throws RepositoryException;","id":9544,"modified_method":"protected abstract void doRun(SlingHttpServletRequest request,\n            HtmlResponse response,\n            List<Modification> changes) throws RepositoryException;","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Prepares and finalizes the actual operation. Preparation encompasses\n     * getting the absolute path of the item to operate on by calling the\n     * {@link #getItemPath(SlingHttpServletRequest)} method and setting the\n     * location and parent location on the response. After the operation has\n     * been done in the {@link #doRun(SlingHttpServletRequest, HtmlResponse)}\n     * method the session is saved if there are unsaved modifications. In case\n     * of errorrs, the unsaved changes in the session are rolled back.\n     *\n     * @param request the request to operate on\n     * @param response The <code>HtmlResponse<\/code> to record execution\n     *            progress.\n     */\n    public final void run(SlingHttpServletRequest request, HtmlResponse response) {\n\n        // calculate the paths\n        String path = getItemPath(request);\n        response.setPath(path);\n\n        // location\n        response.setLocation(externalizePath(request, path));\n\n        // parent location\n        path = ResourceUtil.getParent(path);\n        response.setParentLocation(externalizePath(request, path));\n\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n\n        try {\n\n            doRun(request, response);\n\n            if (session.hasPendingChanges()) {\n                session.save();\n            }\n\n        } catch (Exception e) {\n\n            log.error(\"Exception during response processing.\", e);\n            response.setError(e);\n\n        } finally {\n            try {\n                if (session.hasPendingChanges()) {\n                    session.refresh(false);\n                }\n            } catch (RepositoryException e) {\n                log.warn(\"RepositoryException in finally block: {}\",\n                    e.getMessage(), e);\n            }\n        }\n\n    }","id":9545,"modified_method":"/**\n     * Prepares and finalizes the actual operation. Preparation encompasses\n     * getting the absolute path of the item to operate on by calling the\n     * {@link #getItemPath(SlingHttpServletRequest)} method and setting the\n     * location and parent location on the response. After the operation has\n     * been done in the {@link #doRun(SlingHttpServletRequest, HtmlResponse, List)}\n     * method the session is saved if there are unsaved modifications. In case\n     * of errorrs, the unsaved changes in the session are rolled back.\n     *\n     * @param request the request to operate on\n     * @param response The <code>HtmlResponse<\/code> to record execution\n     *            progress.\n     */\n    public void run(SlingHttpServletRequest request,\n            HtmlResponse response) {\n\n        // calculate the paths\n        String path = getItemPath(request);\n        response.setPath(path);\n\n        // location\n        response.setLocation(externalizePath(request, path));\n\n        // parent location\n        path = ResourceUtil.getParent(path);\n        response.setParentLocation(externalizePath(request, path));\n\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n\n        final List<Modification> changes = new ArrayList<Modification>();\n\n        try {\n\n            doRun(request, response, changes);\n\n            // set changes on html response\n            for(Modification change : changes) {\n                switch ( change.getType() ) {\n                    case MODIFY : response.onModified(change.getSource()); break;\n                    case DELETE : response.onDeleted(change.getSource()); break;\n                    case MOVE :   response.onMoved(change.getSource(), change.getDestination()); break;\n                    case COPY :   response.onCopied(change.getSource(), change.getDestination()); break;\n                    case CREATE : response.onCreated(change.getSource()); break;\n                }\n            }\n            if (session.hasPendingChanges()) {\n                session.save();\n            }\n\n        } catch (Exception e) {\n\n            log.error(\"Exception during response processing.\", e);\n            response.setError(e);\n\n        } finally {\n            try {\n                if (session.hasPendingChanges()) {\n                    session.refresh(false);\n                }\n            } catch (RepositoryException e) {\n                log.warn(\"RepositoryException in finally block: {}\",\n                    e.getMessage(), e);\n            }\n        }\n\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doRun(SlingHttpServletRequest request, HtmlResponse response)\n            throws RepositoryException {\n\n        Iterator<Resource> res = getApplyToResources(request);\n        if (res == null) {\n            \n            Resource resource = request.getResource();\n            Item item = resource.adaptTo(Item.class);\n            if (item == null) {\n                throw new ResourceNotFoundException(\"Missing source \"\n                    + resource + \" for delete\");\n            }\n\n            item.remove();\n            response.onDeleted(resource.getPath());\n            \n        } else {\n            \n            while (res.hasNext()) {\n                Resource resource = res.next();\n                Item item = resource.adaptTo(Item.class);\n                if (item != null) {\n                    item.remove();\n                    response.onDeleted(resource.getPath());\n                }\n            }\n            \n        }\n\n    }","id":9546,"modified_method":"@Override\n    protected void doRun(SlingHttpServletRequest request, HtmlResponse response, List<Modification> changes)\n    throws RepositoryException {\n\n        Iterator<Resource> res = getApplyToResources(request);\n        if (res == null) {\n\n            Resource resource = request.getResource();\n            Item item = resource.adaptTo(Item.class);\n            if (item == null) {\n                throw new ResourceNotFoundException(\"Missing source \"\n                    + resource + \" for delete\");\n            }\n\n            item.remove();\n            changes.add(Modification.onDeleted(resource.getPath()));\n\n        } else {\n\n            while (res.hasNext()) {\n                Resource resource = res.next();\n                Item item = resource.adaptTo(Item.class);\n                if (item != null) {\n                    item.remove();\n                    changes.add(Modification.onDeleted(resource.getPath()));\n                }\n            }\n\n        }\n\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create node(s) according to current request\n     *\n     * @throws RepositoryException if a repository error occurs\n     */\n    private void processCreate(Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n\n        String path = response.getPath();\n        if (!session.itemExists(path)) {\n            deepGetOrCreateNode(session, path, reqProperties, response);\n            response.setCreateRequest(true);\n        }\n\n    }","id":9547,"modified_method":"/**\n     * Create node(s) according to current request\n     *\n     * @throws RepositoryException if a repository error occurs\n     */\n    private void processCreate(Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response, List<Modification> changes)\n            throws RepositoryException {\n\n        String path = response.getPath();\n        if (!session.itemExists(path)) {\n            deepGetOrCreateNode(session, path, reqProperties, changes);\n            response.setCreateRequest(true);\n        }\n\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deep gets or creates a node, parent-padding with default nodes nodes. If\n     * the path is empty, the given parent node is returned.\n     *\n     * @param path path to node that needs to be deep-created\n     * @return node at path\n     * @throws RepositoryException if an error occurs\n     * @throws IllegalArgumentException if the path is relative and parent is\n     *             <code>null<\/code>\n     */\n    private Node deepGetOrCreateNode(Session session, String path,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Deep-creating Node '{}'\", path);\n        }\n        if (path == null || !path.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\"path must be an absolute path.\");\n        }\n        // get the starting node\n        String startingNodePath = path;\n        Node startingNode = null;\n        while (startingNode == null) {\n            if (startingNodePath.equals(\"/\")) {\n                startingNode = session.getRootNode();\n            } else if (session.itemExists(startingNodePath)) {\n                startingNode = (Node) session.getItem(startingNodePath);\n            } else {\n                int pos = startingNodePath.lastIndexOf('/');\n                if (pos > 0) {\n                    startingNodePath = startingNodePath.substring(0, pos);\n                } else {\n                    startingNodePath = \"/\";\n                }\n            }\n        }\n        // is the searched node already existing?\n        if (startingNodePath.length() == path.length()) {\n            return startingNode;\n        }\n        // create nodes\n        int from = (startingNodePath.length() == 1\n                ? 1\n                : startingNodePath.length() + 1);\n        Node node = startingNode;\n        while (from > 0) {\n            final int to = path.indexOf('/', from);\n            final String name = to < 0 ? path.substring(from) : path.substring(\n                from, to);\n            // although the node should not exist (according to the first test\n            // above)\n            // we do a sanety check.\n            if (node.hasNode(name)) {\n                node = node.getNode(name);\n            } else {\n                final String tmpPath = to < 0 ? path : path.substring(0, to);\n                // check for node type\n                final String nodeType = getPrimaryType(reqProperties, tmpPath);\n                if (nodeType != null) {\n                    node = node.addNode(name, nodeType);\n                } else {\n                    node = node.addNode(name);\n                }\n                // check for mixin types\n                final String[] mixinTypes = getMixinTypes(reqProperties,\n                    tmpPath);\n                if (mixinTypes != null) {\n                    for (String mix : mixinTypes) {\n                        node.addMixin(mix);\n                    }\n                }\n                response.onCreated(node.getPath());\n            }\n            from = to + 1;\n        }\n        return node;\n    }","id":9548,"modified_method":"/**\n     * Deep gets or creates a node, parent-padding with default nodes nodes. If\n     * the path is empty, the given parent node is returned.\n     *\n     * @param path path to node that needs to be deep-created\n     * @return node at path\n     * @throws RepositoryException if an error occurs\n     * @throws IllegalArgumentException if the path is relative and parent is\n     *             <code>null<\/code>\n     */\n    private Node deepGetOrCreateNode(Session session, String path,\n            Map<String, RequestProperty> reqProperties, List<Modification> changes)\n            throws RepositoryException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Deep-creating Node '{}'\", path);\n        }\n        if (path == null || !path.startsWith(\"/\")) {\n            throw new IllegalArgumentException(\"path must be an absolute path.\");\n        }\n        // get the starting node\n        String startingNodePath = path;\n        Node startingNode = null;\n        while (startingNode == null) {\n            if (startingNodePath.equals(\"/\")) {\n                startingNode = session.getRootNode();\n            } else if (session.itemExists(startingNodePath)) {\n                startingNode = (Node) session.getItem(startingNodePath);\n            } else {\n                int pos = startingNodePath.lastIndexOf('/');\n                if (pos > 0) {\n                    startingNodePath = startingNodePath.substring(0, pos);\n                } else {\n                    startingNodePath = \"/\";\n                }\n            }\n        }\n        // is the searched node already existing?\n        if (startingNodePath.length() == path.length()) {\n            return startingNode;\n        }\n        // create nodes\n        int from = (startingNodePath.length() == 1\n                ? 1\n                : startingNodePath.length() + 1);\n        Node node = startingNode;\n        while (from > 0) {\n            final int to = path.indexOf('/', from);\n            final String name = to < 0 ? path.substring(from) : path.substring(\n                from, to);\n            // although the node should not exist (according to the first test\n            // above)\n            // we do a sanety check.\n            if (node.hasNode(name)) {\n                node = node.getNode(name);\n            } else {\n                final String tmpPath = to < 0 ? path : path.substring(0, to);\n                // check for node type\n                final String nodeType = getPrimaryType(reqProperties, tmpPath);\n                if (nodeType != null) {\n                    node = node.addNode(name, nodeType);\n                } else {\n                    node = node.addNode(name);\n                }\n                // check for mixin types\n                final String[] mixinTypes = getMixinTypes(reqProperties,\n                    tmpPath);\n                if (mixinTypes != null) {\n                    for (String mix : mixinTypes) {\n                        node.addMixin(mix);\n                    }\n                }\n                changes.add(Modification.onCreated(node.getPath()));\n            }\n            from = to + 1;\n        }\n        return node;\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Moves all repository content listed as repository move source in the\n     * request properties to the locations indicated by the resource properties.\n     */\n    private void processMoves(Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n\n        for (RequestProperty property : reqProperties.values()) {\n            if (property.hasRepositoryMoveSource()) {\n                processMovesCopiesInternal(property, true, session,\n                    reqProperties, response);\n            }\n        }\n    }","id":9549,"modified_method":"/**\n     * Moves all repository content listed as repository move source in the\n     * request properties to the locations indicated by the resource properties.\n     */\n    private void processMoves(Session session,\n            Map<String, RequestProperty> reqProperties, List<Modification> changes)\n            throws RepositoryException {\n\n        for (RequestProperty property : reqProperties.values()) {\n            if (property.hasRepositoryMoveSource()) {\n                processMovesCopiesInternal(property, true, session,\n                    reqProperties, changes);\n            }\n        }\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Copies all repository content listed as repository copy source in the\n     * request properties to the locations indicated by the resource properties.\n     */\n    private void processCopies(Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n\n        for (RequestProperty property : reqProperties.values()) {\n            if (property.hasRepositoryCopySource()) {\n                processMovesCopiesInternal(property, false, session,\n                    reqProperties, response);\n            }\n        }\n    }","id":9550,"modified_method":"/**\n     * Copies all repository content listed as repository copy source in the\n     * request properties to the locations indicated by the resource properties.\n     */\n    private void processCopies(Session session,\n            Map<String, RequestProperty> reqProperties, List<Modification> changes)\n            throws RepositoryException {\n\n        for (RequestProperty property : reqProperties.values()) {\n            if (property.hasRepositoryCopySource()) {\n                processMovesCopiesInternal(property, false, session,\n                    reqProperties, changes);\n            }\n        }\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Writes back the content\n     *\n     * @throws RepositoryException if a repository error occurs\n     * @throws ServletException if an internal error occurs\n     */\n    private void writeContent(Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n\n        SlingPropertyValueHandler propHandler = new SlingPropertyValueHandler(\n            dateParser, response);\n\n        for (RequestProperty prop : reqProperties.values()) {\n            if (prop.hasValues()) {\n                Node parent = deepGetOrCreateNode(session,\n                    prop.getParentPath(), reqProperties, response);\n                // skip jcr special properties\n                if (prop.getName().equals(\"jcr:primaryType\")\n                    || prop.getName().equals(\"jcr:mixinTypes\")) {\n                    continue;\n                }\n                if (prop.isFileUpload()) {\n                    uploadHandler.setFile(parent, prop, response);\n                } else {\n                    propHandler.setProperty(parent, prop);\n                }\n            }\n        }\n    }","id":9551,"modified_method":"/**\n     * Writes back the content\n     *\n     * @throws RepositoryException if a repository error occurs\n     * @throws ServletException if an internal error occurs\n     */\n    private void writeContent(Session session,\n            Map<String, RequestProperty> reqProperties, List<Modification> changes)\n            throws RepositoryException {\n\n        SlingPropertyValueHandler propHandler = new SlingPropertyValueHandler(\n            dateParser, changes);\n\n        for (RequestProperty prop : reqProperties.values()) {\n            if (prop.hasValues()) {\n                Node parent = deepGetOrCreateNode(session,\n                    prop.getParentPath(), reqProperties, changes);\n                // skip jcr special properties\n                if (prop.getName().equals(\"jcr:primaryType\")\n                    || prop.getName().equals(\"jcr:mixinTypes\")) {\n                    continue;\n                }\n                if (prop.isFileUpload()) {\n                    uploadHandler.setFile(parent, prop, changes);\n                } else {\n                    propHandler.setProperty(parent, prop);\n                }\n            }\n        }\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Internal implementation of the\n     * {@link #processCopies(Session, Map, HtmlResponse)} and\n     * {@link #processMoves(Session, Map, HtmlResponse)} methods taking into\n     * account whether the source is actually a property or a node.\n     * <p>\n     * Any intermediary nodes to the destination as indicated by the\n     * <code>property<\/code> path are created using the\n     * <code>reqProperties<\/code> as indications for required node types.\n     *\n     * @param property The {@link RequestProperty} identifying the source\n     *            content of the operation.\n     * @param isMove <code>true<\/code> if the source item is to be moved.\n     *            Otherwise the source item is just copied.\n     * @param session The repository session to use to access the content\n     * @param reqProperties All accepted request properties. This is used to\n     *            create intermediary nodes along the property path.\n     * @param response The <code>HtmlResponse<\/code> into which successfull\n     *            copies and moves as well as intermediary node creations are\n     *            recorded.\n     * @throws RepositoryException May be thrown if an error occurrs.\n     */\n    private void processMovesCopiesInternal(RequestProperty property,\n            boolean isMove, Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n\n        String propPath = property.getPath();\n        String source = property.getRepositorySource();\n\n        // only continue here, if the source really exists\n        if (session.itemExists(source)) {\n\n            // if the destination item already exists, remove it\n            // first, otherwise ensure the parent location\n            if (session.itemExists(propPath)) {\n                session.getItem(propPath).remove();\n                response.onDeleted(propPath);\n            } else {\n                deepGetOrCreateNode(session, property.getParentPath(),\n                    reqProperties, response);\n            }\n\n            // move through the session and record operation\n            Item sourceItem = session.getItem(source);\n            if (sourceItem.isNode()) {\n\n                // node move/copy through session\n                if (isMove) {\n                    session.move(source, propPath);\n                } else {\n                    Node sourceNode = (Node) sourceItem;\n                    Node destParent = (Node) session.getItem(property.getParentPath());\n                    CopyOperation.copy(sourceNode, destParent,\n                        property.getName());\n                }\n\n            } else {\n\n                // property move manually\n                Property sourceProperty = (Property) sourceItem;\n\n                // create destination property\n                Node destParent = (Node) session.getItem(property.getParentPath());\n                CopyOperation.copy(sourceProperty, destParent, null);\n\n                // remove source property (if not just copying)\n                if (isMove) {\n                    sourceProperty.remove();\n                }\n            }\n\n            // make sure the property is not deleted even in case for a given\n            // property both @MoveFrom and @Delete is set\n            property.setDelete(false);\n\n            // record successful move\n            if (isMove) {\n                response.onMoved(source, propPath);\n            } else {\n                response.onCopied(source, propPath);\n            }\n        }\n    }","id":9552,"modified_method":"/**\n     * Internal implementation of the\n     * {@link #processCopies(Session, Map, HtmlResponse)} and\n     * {@link #processMoves(Session, Map, HtmlResponse)} methods taking into\n     * account whether the source is actually a property or a node.\n     * <p>\n     * Any intermediary nodes to the destination as indicated by the\n     * <code>property<\/code> path are created using the\n     * <code>reqProperties<\/code> as indications for required node types.\n     *\n     * @param property The {@link RequestProperty} identifying the source\n     *            content of the operation.\n     * @param isMove <code>true<\/code> if the source item is to be moved.\n     *            Otherwise the source item is just copied.\n     * @param session The repository session to use to access the content\n     * @param reqProperties All accepted request properties. This is used to\n     *            create intermediary nodes along the property path.\n     * @param response The <code>HtmlResponse<\/code> into which successfull\n     *            copies and moves as well as intermediary node creations are\n     *            recorded.\n     * @throws RepositoryException May be thrown if an error occurrs.\n     */\n    private void processMovesCopiesInternal(RequestProperty property,\n            boolean isMove, Session session,\n            Map<String, RequestProperty> reqProperties, List<Modification> changes)\n            throws RepositoryException {\n\n        String propPath = property.getPath();\n        String source = property.getRepositorySource();\n\n        // only continue here, if the source really exists\n        if (session.itemExists(source)) {\n\n            // if the destination item already exists, remove it\n            // first, otherwise ensure the parent location\n            if (session.itemExists(propPath)) {\n                session.getItem(propPath).remove();\n                changes.add(Modification.onDeleted(propPath));\n            } else {\n                deepGetOrCreateNode(session, property.getParentPath(),\n                    reqProperties, changes);\n            }\n\n            // move through the session and record operation\n            Item sourceItem = session.getItem(source);\n            if (sourceItem.isNode()) {\n\n                // node move/copy through session\n                if (isMove) {\n                    session.move(source, propPath);\n                } else {\n                    Node sourceNode = (Node) sourceItem;\n                    Node destParent = (Node) session.getItem(property.getParentPath());\n                    CopyOperation.copy(sourceNode, destParent,\n                        property.getName());\n                }\n\n            } else {\n\n                // property move manually\n                Property sourceProperty = (Property) sourceItem;\n\n                // create destination property\n                Node destParent = (Node) session.getItem(property.getParentPath());\n                CopyOperation.copy(sourceProperty, destParent, null);\n\n                // remove source property (if not just copying)\n                if (isMove) {\n                    sourceProperty.remove();\n                }\n            }\n\n            // make sure the property is not deleted even in case for a given\n            // property both @MoveFrom and @Delete is set\n            property.setDelete(false);\n\n            // record successful move\n            if (isMove) {\n                changes.add(Modification.onMoved(source, propPath));\n            } else {\n                changes.add(Modification.onCopied(source, propPath));\n            }\n        }\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Removes all properties listed as {@link RequestProperty#isDelete()} from\n     * the repository.\n     *\n     * @param session The <code>javax.jcr.Session<\/code> used to access the\n     *            repository to delete the properties.\n     * @param reqProperties The map of request properties to check for\n     *            properties to be removed.\n     * @param response The <code>HtmlResponse<\/code> to be updated with\n     *            information on deleted properties.\n     * @throws RepositoryException Is thrown if an error occurrs checking or\n     *             removing properties.\n     */\n    private void processDeletes(Session session,\n            Map<String, RequestProperty> reqProperties, HtmlResponse response)\n            throws RepositoryException {\n\n        for (RequestProperty property : reqProperties.values()) {\n            if (property.isDelete()) {\n                String propPath = property.getPath();\n                if (session.itemExists(propPath)) {\n                    session.getItem(propPath).remove();\n                    response.onDeleted(propPath);\n                }\n            }\n        }\n\n    }","id":9553,"modified_method":"/**\n     * Removes all properties listed as {@link RequestProperty#isDelete()} from\n     * the repository.\n     *\n     * @param session The <code>javax.jcr.Session<\/code> used to access the\n     *            repository to delete the properties.\n     * @param reqProperties The map of request properties to check for\n     *            properties to be removed.\n     * @param response The <code>HtmlResponse<\/code> to be updated with\n     *            information on deleted properties.\n     * @throws RepositoryException Is thrown if an error occurrs checking or\n     *             removing properties.\n     */\n    private void processDeletes(Session session,\n            Map<String, RequestProperty> reqProperties, List<Modification> changes)\n            throws RepositoryException {\n\n        for (RequestProperty property : reqProperties.values()) {\n            if (property.isDelete()) {\n                String propPath = property.getPath();\n                if (session.itemExists(propPath)) {\n                    session.getItem(propPath).remove();\n                    changes.add(Modification.onDeleted(propPath));\n                }\n            }\n        }\n\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doRun(SlingHttpServletRequest request, HtmlResponse response)\n            throws RepositoryException {\n\n        Map<String, RequestProperty> reqProperties = collectContent(request,\n            response);\n\n        // do not change order unless you have a very good reason.\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n\n        // ensure root of new content\n        processCreate(session, reqProperties, response);\n\n        // write content from existing content (@Move/CopyFrom parameters)\n        processMoves(session, reqProperties, response);\n        processCopies(session, reqProperties, response);\n\n        // cleanup any old content (@Delete parameters)\n        processDeletes(session, reqProperties, response);\n\n        // write content from form\n        writeContent(session, reqProperties, response);\n\n        // order content\n        String path = response.getPath();\n        orderNode(request, session.getItem(path));\n    }","id":9554,"modified_method":"@Override\n    protected void doRun(SlingHttpServletRequest request, HtmlResponse response, List<Modification> changes)\n            throws RepositoryException {\n\n        Map<String, RequestProperty> reqProperties = collectContent(request,\n                response);\n\n        // do not change order unless you have a very good reason.\n        Session session = request.getResourceResolver().adaptTo(Session.class);\n\n        // ensure root of new content\n        processCreate(session, reqProperties, response, changes);\n\n        // write content from existing content (@Move/CopyFrom parameters)\n        processMoves(session, reqProperties, changes);\n        processCopies(session, reqProperties, changes);\n\n        // cleanup any old content (@Delete parameters)\n        processDeletes(session, reqProperties, changes);\n\n        // write content from form\n        writeContent(session, reqProperties, changes);\n\n        // order content\n        String path = response.getPath();\n        orderNode(request, session.getItem(path));\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Uses the file(s) in the request parameter for creation of new nodes.\n     * if the parent node is a nt:folder a new nt:file is created. otherwise\n     * just a nt:resource. if the <code>name<\/code> is '*', the filename of\n     * the uploaded file is used.\n     *\n     * @param parent the parent node\n     * @param prop the assembled property info\n     * @throws RepositoryException if an error occurs\n     */\n    public void setFile(Node parent, RequestProperty prop, HtmlResponse response)\n            throws RepositoryException {\n        RequestParameter value = prop.getValues()[0];\n        assert !value.isFormField();\n\n        // ignore if empty\n        if (value.getSize() <= 0) {\n            return;\n        }\n\n        // get node name\n        String name = prop.getName();\n        if (name.equals(\"*\")) {\n            name = value.getFileName();\n            // strip of possible path (some browsers include the entire path)\n            name = name.substring(name.lastIndexOf('/') + 1);\n            name = name.substring(name.lastIndexOf('\\\\') + 1);\n        }\n        name = Text.escapeIllegalJcrChars(name);\n\n        // check type hint. if the type is ok and extends from nt:file,\n        // create an nt:file with that type. if it's invalid, drop it and let\n        // the parent node type decide.\n        boolean createNtFile = parent.isNodeType(NT_FOLDER);\n        String typeHint = prop.getTypeHint();\n        if (typeHint != null) {\n            try {\n                NodeTypeManager ntMgr = parent.getSession().getWorkspace().getNodeTypeManager();\n                NodeType nt = ntMgr.getNodeType(typeHint);\n                createNtFile = nt.isNodeType(NT_FILE);\n            } catch (RepositoryException e) {\n                // assuming type not valid.\n                typeHint = null;\n            }\n        }\n\n        // also create an nt:file if the name contains an extension\n        // the rationale is that if the file name is \"important\" we want\n        // an nt:file, and an image name with an extension is probably \"important\"\n        if(!createNtFile && name.indexOf('.') > 0) {\n            createNtFile = true;\n        }\n\n        // set empty type\n        if (typeHint == null) {\n            typeHint = createNtFile ? NT_FILE : NT_RESOURCE;\n        }\n\n        // remove node\n        if (parent.hasNode(name)) {\n            parent.getNode(name).remove();\n        }\n\n        // create nt:file node if needed\n        if (createNtFile) {\n            // create nt:file\n            parent = parent.addNode(name, typeHint);\n            response.onCreated(parent.getPath());\n            name = JCR_CONTENT;\n            typeHint = NT_RESOURCE;\n        }\n\n        // create resource node\n        Node res = parent.addNode(name, typeHint);\n        response.onCreated(res.getPath());\n\n        // get content type\n        String contentType = value.getContentType();\n        if (contentType != null) {\n            int idx = contentType.indexOf(';');\n            if (idx > 0) {\n                contentType = contentType.substring(0, idx);\n            }\n        }\n        if (contentType == null || contentType.equals(\"application/octet-stream\")) {\n            // try to find a better content type\n            contentType = this.servletContext.getMimeType(value.getFileName());\n            if (contentType == null || contentType.equals(\"application/octet-stream\")) {\n                contentType = \"application/octet-stream\";\n            }\n        }\n\n        // set properties\n        response.onModified(\n            res.setProperty(JCR_LASTMODIFIED, Calendar.getInstance()).getPath()\n        );\n        response.onModified(\n            res.setProperty(JCR_MIMETYPE, contentType).getPath()\n        );\n        try {\n            response.onModified(\n                res.setProperty(JCR_DATA, value.getInputStream()).getPath()\n            );\n        } catch (IOException e) {\n            throw new RepositoryException(\"Error while retrieving inputstream from parameter value.\", e);\n        }\n    }","id":9555,"modified_method":"/**\n     * Uses the file(s) in the request parameter for creation of new nodes.\n     * if the parent node is a nt:folder a new nt:file is created. otherwise\n     * just a nt:resource. if the <code>name<\/code> is '*', the filename of\n     * the uploaded file is used.\n     *\n     * @param parent the parent node\n     * @param prop the assembled property info\n     * @throws RepositoryException if an error occurs\n     */\n    public void setFile(Node parent, RequestProperty prop, List<Modification> changes)\n            throws RepositoryException {\n        RequestParameter value = prop.getValues()[0];\n        assert !value.isFormField();\n\n        // ignore if empty\n        if (value.getSize() <= 0) {\n            return;\n        }\n\n        // get node name\n        String name = prop.getName();\n        if (name.equals(\"*\")) {\n            name = value.getFileName();\n            // strip of possible path (some browsers include the entire path)\n            name = name.substring(name.lastIndexOf('/') + 1);\n            name = name.substring(name.lastIndexOf('\\\\') + 1);\n        }\n        name = Text.escapeIllegalJcrChars(name);\n\n        // check type hint. if the type is ok and extends from nt:file,\n        // create an nt:file with that type. if it's invalid, drop it and let\n        // the parent node type decide.\n        boolean createNtFile = parent.isNodeType(NT_FOLDER);\n        String typeHint = prop.getTypeHint();\n        if (typeHint != null) {\n            try {\n                NodeTypeManager ntMgr = parent.getSession().getWorkspace().getNodeTypeManager();\n                NodeType nt = ntMgr.getNodeType(typeHint);\n                createNtFile = nt.isNodeType(NT_FILE);\n            } catch (RepositoryException e) {\n                // assuming type not valid.\n                typeHint = null;\n            }\n        }\n\n        // also create an nt:file if the name contains an extension\n        // the rationale is that if the file name is \"important\" we want\n        // an nt:file, and an image name with an extension is probably \"important\"\n        if(!createNtFile && name.indexOf('.') > 0) {\n            createNtFile = true;\n        }\n\n        // set empty type\n        if (typeHint == null) {\n            typeHint = createNtFile ? NT_FILE : NT_RESOURCE;\n        }\n\n        // remove node\n        if (parent.hasNode(name)) {\n            parent.getNode(name).remove();\n        }\n\n        // create nt:file node if needed\n        if (createNtFile) {\n            // create nt:file\n            parent = parent.addNode(name, typeHint);\n            changes.add(Modification.onCreated(parent.getPath()));\n            name = JCR_CONTENT;\n            typeHint = NT_RESOURCE;\n        }\n\n        // create resource node\n        Node res = parent.addNode(name, typeHint);\n        changes.add(Modification.onCreated(res.getPath()));\n\n        // get content type\n        String contentType = value.getContentType();\n        if (contentType != null) {\n            int idx = contentType.indexOf(';');\n            if (idx > 0) {\n                contentType = contentType.substring(0, idx);\n            }\n        }\n        if (contentType == null || contentType.equals(\"application/octet-stream\")) {\n            // try to find a better content type\n            contentType = this.servletContext.getMimeType(value.getFileName());\n            if (contentType == null || contentType.equals(\"application/octet-stream\")) {\n                contentType = \"application/octet-stream\";\n            }\n        }\n\n        // set properties\n        changes.add(Modification.onModified(\n            res.setProperty(JCR_LASTMODIFIED, Calendar.getInstance()).getPath()\n        ));\n        changes.add(Modification.onModified(\n            res.setProperty(JCR_MIMETYPE, contentType).getPath()\n        ));\n        try {\n            changes.add(Modification.onModified(\n                res.setProperty(JCR_DATA, value.getInputStream()).getPath()\n            ));\n        } catch (IOException e) {\n            throw new RepositoryException(\"Error while retrieving inputstream from parameter value.\", e);\n        }\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * set property without processing, except for type hints\n     *\n     * @param parent the parent node\n     * @param prop the request property\n     * @throws RepositoryException if a repository error occurs.\n     */\n    private void setPropertyAsIs(Node parent, RequestProperty prop)\n            throws RepositoryException {\n\n        // no explicit typehint\n        int type = PropertyType.UNDEFINED;\n        if (prop.getTypeHint() != null) {\n            try {\n                type = PropertyType.valueFromName(prop.getTypeHint());\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        String[] values = prop.getStringValues();\n        if (values == null) {\n            // remove property\n            response.onDeleted(\n                removePropertyIfExists(parent, prop.getName())\n            );\n        } else if (values.length == 0) {\n            // do not create new prop here, but clear existing\n            if (parent.hasProperty(prop.getName())) {\n                response.onModified(\n                    parent.setProperty(prop.getName(), \"\").getPath()\n                );\n            }\n        } else if (values.length == 1) {\n            final String removePath = removePropertyIfExists(parent, prop.getName());\n            // if the provided value is the empty string, we don't have to do anything.\n            if ( values[0].length() == 0 ) {\n                if ( removePath != null ) {\n                    response.onDeleted(removePath);\n                }\n            } else {\n                // modify property\n                if (type == PropertyType.DATE) {\n                    // try conversion\n                    Calendar c = dateParser.parse(values[0]);\n                    if (c != null) {\n                        if ( prop.hasMultiValueTypeHint() ) {\n                            final Value[] array = new Value[1];\n                            array[0] = parent.getSession().getValueFactory().createValue(c);\n                            response.onModified(\n                                parent.setProperty(prop.getName(), array).getPath()\n                            );\n                        } else {\n                            response.onModified(\n                                    parent.setProperty(prop.getName(), c).getPath()\n                                );\n                        }\n                        return;\n                    }\n                    // fall back to default behaviour\n                }\n                final Property p;\n                if ( type == PropertyType.UNDEFINED ) {\n                    p = parent.setProperty(prop.getName(), values[0]);\n                } else {\n                    if ( prop.hasMultiValueTypeHint() ) {\n                        final Value[] array = new Value[1];\n                        array[0] = parent.getSession().getValueFactory().createValue(values[0], type);\n                        p = parent.setProperty(prop.getName(), array);\n                    } else {\n                        p = parent.setProperty(prop.getName(), values[0], type);\n                    }\n                }\n                response.onModified(p.getPath());\n            }\n        } else {\n            removePropertyIfExists(parent, prop.getName());\n            if (type == PropertyType.DATE) {\n                // try conversion\n                ValueFactory valFac = parent.getSession().getValueFactory();\n                Value[] c = dateParser.parse(values, valFac);\n                if (c != null) {\n                    response.onModified(\n                        parent.setProperty(prop.getName(), c).getPath()\n                    );\n                    return;\n                }\n                // fall back to default behaviour\n            }\n            final Property p;\n            if ( type == PropertyType.UNDEFINED ) {\n                p = parent.setProperty(prop.getName(), values);\n            } else {\n                p = parent.setProperty(prop.getName(), values, type);\n            }\n            response.onModified(p.getPath());\n        }\n    }","id":9556,"modified_method":"/**\n     * set property without processing, except for type hints\n     *\n     * @param parent the parent node\n     * @param prop the request property\n     * @throws RepositoryException if a repository error occurs.\n     */\n    private void setPropertyAsIs(Node parent, RequestProperty prop)\n            throws RepositoryException {\n\n        // no explicit typehint\n        int type = PropertyType.UNDEFINED;\n        if (prop.getTypeHint() != null) {\n            try {\n                type = PropertyType.valueFromName(prop.getTypeHint());\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n\n        String[] values = prop.getStringValues();\n        if (values == null) {\n            // remove property\n            changes.add(Modification.onDeleted(\n                removePropertyIfExists(parent, prop.getName())\n            ));\n        } else if (values.length == 0) {\n            // do not create new prop here, but clear existing\n            if (parent.hasProperty(prop.getName())) {\n                changes.add(Modification.onModified(\n                    parent.setProperty(prop.getName(), \"\").getPath()\n                ));\n            }\n        } else if (values.length == 1) {\n            final String removePath = removePropertyIfExists(parent, prop.getName());\n            // if the provided value is the empty string, we don't have to do anything.\n            if ( values[0].length() == 0 ) {\n                if ( removePath != null ) {\n                    changes.add(Modification.onDeleted(removePath));\n                }\n            } else {\n                // modify property\n                if (type == PropertyType.DATE) {\n                    // try conversion\n                    Calendar c = dateParser.parse(values[0]);\n                    if (c != null) {\n                        if ( prop.hasMultiValueTypeHint() ) {\n                            final Value[] array = new Value[1];\n                            array[0] = parent.getSession().getValueFactory().createValue(c);\n                            changes.add(Modification.onModified(\n                                parent.setProperty(prop.getName(), array).getPath()\n                            ));\n                        } else {\n                            changes.add(Modification.onModified(\n                                    parent.setProperty(prop.getName(), c).getPath()\n                                ));\n                        }\n                        return;\n                    }\n                    // fall back to default behaviour\n                }\n                final Property p;\n                if ( type == PropertyType.UNDEFINED ) {\n                    p = parent.setProperty(prop.getName(), values[0]);\n                } else {\n                    if ( prop.hasMultiValueTypeHint() ) {\n                        final Value[] array = new Value[1];\n                        array[0] = parent.getSession().getValueFactory().createValue(values[0], type);\n                        p = parent.setProperty(prop.getName(), array);\n                    } else {\n                        p = parent.setProperty(prop.getName(), values[0], type);\n                    }\n                }\n                changes.add(Modification.onModified(p.getPath()));\n            }\n        } else {\n            removePropertyIfExists(parent, prop.getName());\n            if (type == PropertyType.DATE) {\n                // try conversion\n                ValueFactory valFac = parent.getSession().getValueFactory();\n                Value[] c = dateParser.parse(values, valFac);\n                if (c != null) {\n                    changes.add(Modification.onModified(\n                        parent.setProperty(prop.getName(), c).getPath()\n                    ));\n                    return;\n                }\n                // fall back to default behaviour\n            }\n            final Property p;\n            if ( type == PropertyType.UNDEFINED ) {\n                p = parent.setProperty(prop.getName(), values);\n            } else {\n                p = parent.setProperty(prop.getName(), values, type);\n            }\n            changes.add(Modification.onModified(p.getPath()));\n        }\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Sets the property to the given date\n     * @param parent parent node\n     * @param name name of the property\n     * @throws RepositoryException if a repository error occurs\n     */\n    private void setCurrentDate(Node parent, String name)\n            throws RepositoryException {\n        removePropertyIfExists(parent, name);\n        response.onModified(\n            parent.setProperty(name, now).getPath()\n        );\n    }","id":9557,"modified_method":"/**\n     * Sets the property to the given date\n     * @param parent parent node\n     * @param name name of the property\n     * @throws RepositoryException if a repository error occurs\n     */\n    private void setCurrentDate(Node parent, String name)\n            throws RepositoryException {\n        removePropertyIfExists(parent, name);\n        changes.add(Modification.onModified(\n            parent.setProperty(name, now).getPath()\n        ));\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * set property to the current User id\n     * @param parent parent node\n     * @param name name of the property\n     * @throws RepositoryException if a repository error occurs\n     */\n    private void setCurrentUser(Node parent, String name)\n            throws RepositoryException {\n        removePropertyIfExists(parent, name);\n        response.onModified(\n            parent.setProperty(name, parent.getSession().getUserID()).getPath()\n        );\n    }","id":9558,"modified_method":"/**\n     * set property to the current User id\n     * @param parent parent node\n     * @param name name of the property\n     * @throws RepositoryException if a repository error occurs\n     */\n    private void setCurrentUser(Node parent, String name)\n            throws RepositoryException {\n        removePropertyIfExists(parent, name);\n        changes.add(Modification.onModified(\n            parent.setProperty(name, parent.getSession().getUserID()).getPath()\n        ));\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Constructs a propert value handler\n     */\n    public SlingPropertyValueHandler(DateParser dateParser, HtmlResponse response) {\n        this.dateParser = dateParser;\n        this.response = response;\n    }","id":9559,"modified_method":"/**\n     * Constructs a propert value handler\n     */\n    public SlingPropertyValueHandler(DateParser dateParser, List<Modification> changes) {\n        this.dateParser = dateParser;\n        this.changes = changes;\n    }","commit_id":"3bc56cddb15a29fc8512a139cdc62c0168e14665","url":"https://github.com/apache/sling"},{"original_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t}","id":9560,"modified_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t\tprimitivesChartTab.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t}","commit_id":"c276a36555be86938b42477eb01ce2b1116616d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getValueOfCssProperty(\"display\") != \"none\") {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9561,"modified_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getValueOfCssProperty(\"display\").equals(\"none\")) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"c276a36555be86938b42477eb01ce2b1116616d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) == expectedValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9562,"modified_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName).equals(expectedValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"c276a36555be86938b42477eb01ce2b1116616d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) != currentValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9563,"modified_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getAttribute(attributeName).equals(currentValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"c276a36555be86938b42477eb01ce2b1116616d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t}","id":9564,"modified_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t\tprimitivesChartTab.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t}","commit_id":"d9f579fe42b97fdcdefb471bf24ff6f188739c9b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) == expectedValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9565,"modified_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName).equals(expectedValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"d9f579fe42b97fdcdefb471bf24ff6f188739c9b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) != currentValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9566,"modified_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getAttribute(attributeName).equals(currentValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"d9f579fe42b97fdcdefb471bf24ff6f188739c9b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getValueOfCssProperty(\"display\") != \"none\") {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9567,"modified_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getValueOfCssProperty(\"display\").equals(\"none\")) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"d9f579fe42b97fdcdefb471bf24ff6f188739c9b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t}","id":9568,"modified_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t\tprimitivesChartTab.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t}","commit_id":"1363c3f877ffb7ae1629bc4b83d6cc61cece6e74","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getValueOfCssProperty(\"display\") != \"none\") {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9569,"modified_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getValueOfCssProperty(\"display\").equals(\"none\")) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"1363c3f877ffb7ae1629bc4b83d6cc61cece6e74","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) != currentValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9570,"modified_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getAttribute(attributeName).equals(currentValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"1363c3f877ffb7ae1629bc4b83d6cc61cece6e74","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) == expectedValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9571,"modified_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName).equals(expectedValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"1363c3f877ffb7ae1629bc4b83d6cc61cece6e74","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t}","id":9572,"modified_method":"@Test\n\tpublic void shouldBeAbleToSwitchBetweenCharts() {\n\t\t\n\t\tdashboardMenu.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t\tmemoryChartTab.click();\n\t\t\n\t\tassertThat(memoryChart.getElement(), isVisible());\n\t\tassertThat(primitivesChart.getElement(), not(isVisible()));\n\t\t\n\t\tprimitivesChartTab.click();\n\t\t\n\t\tassertThat(primitivesChart.getElement(), isVisible());\n\t\tassertThat(memoryChart.getElement(), not(isVisible()));\n\t\t\n\t}","commit_id":"c038e5248076bf3082d64ad6235012602515846d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) == expectedValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9573,"modified_method":"public void waitForAttributeToBe(String attributeName, String expectedValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName).equals(expectedValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"c038e5248076bf3082d64ad6235012602515846d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getValueOfCssProperty(\"display\") != \"none\") {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9574,"modified_method":"public void waitUntilVisible() {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getValueOfCssProperty(\"display\").equals(\"none\")) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element did not become visible within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"c038e5248076bf3082d64ad6235012602515846d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if (this.getAttribute(attributeName) != currentValue) {\n                return;\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","id":9575,"modified_method":"public void waitForAttributeToChangeFrom(String attributeName, String currentValue) {\n        long end = System.currentTimeMillis() + 10000;\n        while (System.currentTimeMillis() < end) {\n            if ( ! this.getAttribute(attributeName).equals(currentValue)) {\n                return;\n            }\n            try{\n            \tThread.sleep(13);\n            } catch(Exception e) {\n            \tthrow new RuntimeException(e);\n            }\n        }\n\n        throw new RuntimeException(\"Element attribute did not change within a reasonable time. Element was: \" + this.getElement().toString());\n    }","commit_id":"c038e5248076bf3082d64ad6235012602515846d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void processPendingOperationForNode(AdapterOperation op) throws ProvisioningAdapterException {\n        if (op.getType() == AdapterOperationType.ADD) {\n            doAdd(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.UPDATE) {\n            doUpdate(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.DELETE) {\n            doDelete(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            doNodeConfigChanged(op.getNodeId());\n        }\n    }","id":9576,"modified_method":"@Override\n    public void processPendingOperationForNode(AdapterOperation op) throws ProvisioningAdapterException {\n        if (op.getType() == AdapterOperationType.ADD) {\n            doAdd(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.UPDATE) {\n            doUpdate(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.DELETE) {\n            doDelete(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            doNodeConfigChanged(op.getNodeId(),m_cp,true);\n        }\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\n        RWSClientApi.init();\n        Assert.notNull(m_rwsConfig, \"Rancid Provisioning Adapter requires RWSConfig property to be set.\");\n        \n        m_cp = getRWSConnection();\n        \n        Assert.notNull(m_nodeDao, \"Rancid Provisioning Adapter requires nodeDao property to be set.\");\n        \n        createMessageSelectorAndSubscribe();\n        buildRancidNodeMap();\n    }","id":9577,"modified_method":"public void afterPropertiesSet() throws Exception {\n\n        RWSClientApi.init();\n        Assert.notNull(m_rwsConfig, \"Rancid Provisioning Adapter requires RWSConfig property to be set.\");\n        \n        m_cp = getRWSConnection();\n        \n        Assert.notNull(m_nodeDao, \"Rancid Provisioning Adapter requires nodeDao property to be set.\");\n        \n        createMessageSelectorAndSubscribe();\n        getRancidCategories();\n        buildRancidNodeMap();\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void doNodeConfigChanged(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();\n                RWSClientApi.updateRWSRancidNode(m_cp, rNode);\n            } else {\n                throw new Exception(\"No node found for nodeid: \" + nodeId);\n            }\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","id":9578,"modified_method":"public void doNodeConfigChanged(int nodeId,ConnectionProperties cp, boolean retry) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();\n                RWSClientApi.updateRWSRancidNode(cp, rNode);\n            } else {\n                log().warn(\"No node found in nodeRancid Map for nodeid: \" + nodeId);\n            }\n        } catch (Exception e) {\n            cp = getStandByRWSConnection();\n            if (retry && cp != null) {\n                doNodeConfigChanged(nodeId, cp, false);\n            } else {\n                sendAndThrow(nodeId, e);            \n            }\n        }\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_FAILURE_UEI)\n    public void handleRancidDownLoadFailure(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid()) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, true);\n                doNodeConfigChanged(nodeId);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","id":9579,"modified_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_FAILURE_UEI)\n    public void handleRancidDownLoadFailure(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid()) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, true);\n                doNodeConfigChanged(nodeId,m_cp,true);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private ConnectionProperties getRWSConnection() {\n        log().debug(\"Connections used : \" +m_rwsConfig.getBaseUrl().getServer_url()+m_rwsConfig.getBaseUrl().getDirectory());\n        log().debug(\"RWS timeout(sec): \"+m_rwsConfig.getBaseUrl().getTimeout());        \n        return new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n    }","id":9580,"modified_method":"private ConnectionProperties getRWSConnection() {\n        log().debug(\"Connections used : \" +m_rwsConfig.getBaseUrl().getServer_url()+m_rwsConfig.getBaseUrl().getDirectory());\n        log().debug(\"RWS timeout(sec): \"+m_rwsConfig.getBaseUrl().getTimeout());\n        if (m_rwsConfig.getBaseUrl().getUsername() == null)\n            return new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n        String password = \"\";\n        if (m_rwsConfig.getBaseUrl().getPassword() != null)\n            password = m_rwsConfig.getBaseUrl().getPassword();\n        return new ConnectionProperties(m_rwsConfig.getBaseUrl().getUsername(),password,m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //The group should be the foreign source of the node\n\n        String group = node.getForeignSource();\n\n        if (group == null) return null;\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Check the node categories if useNodecategories is true\n        r_node.setDeviceType(m_rancidAdapterConfig.getType(node.getSysObjectId()));\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","id":9581,"modified_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //The group should be the foreign source of the node\n\n        String group = node.getForeignSource();\n\n        if (group == null) return null;\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        String ipaddress = getSuitableIpForRancid(node.getId().intValue());\n        if (m_rancidAdapterConfig.useCategories(ipaddress)) {\n           r_node.setDeviceType(getTypeFromCategories(node)); \n        } else {\n            r_node.setDeviceType(getTypeFromSysObjectId(node.getSysObjectId()));\n        }\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getSuitableIpForRancid(int nodeid){\n        OnmsNode node = m_nodeDao.get(nodeid);\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","id":9582,"modified_method":"@Transactional\n    public String getSuitableIpForRancid(int nodeid){\n        OnmsNode node = m_nodeDao.get(nodeid);\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_SUCCESS_UEI)\n    public void handleRancidDownLoadSuccess(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid() ) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, false);\n                doNodeConfigChanged(nodeId);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","id":9583,"modified_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_SUCCESS_UEI)\n    public void handleRancidDownLoadSuccess(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid() ) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, false);\n                doNodeConfigChanged(nodeId,m_cp,true);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","commit_id":"3c404e11277a79aa924876ff8cb47baefd5bc8b5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_FAILURE_UEI)\n    public void handleRancidDownLoadFailure(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid()) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, true);\n                doNodeConfigChanged(nodeId);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","id":9584,"modified_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_FAILURE_UEI)\n    public void handleRancidDownLoadFailure(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid()) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, true);\n                doNodeConfigChanged(nodeId,m_cp,true);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_SUCCESS_UEI)\n    public void handleRancidDownLoadSuccess(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid() ) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, false);\n                doNodeConfigChanged(nodeId);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","id":9585,"modified_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_SUCCESS_UEI)\n    public void handleRancidDownLoadSuccess(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid() ) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, false);\n                doNodeConfigChanged(nodeId,m_cp,true);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private ConnectionProperties getRWSConnection() {\n        log().debug(\"Connections used : \" +m_rwsConfig.getBaseUrl().getServer_url()+m_rwsConfig.getBaseUrl().getDirectory());\n        log().debug(\"RWS timeout(sec): \"+m_rwsConfig.getBaseUrl().getTimeout());        \n        return new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n    }","id":9586,"modified_method":"private ConnectionProperties getRWSConnection() {\n        log().debug(\"Connections used : \" +m_rwsConfig.getBaseUrl().getServer_url()+m_rwsConfig.getBaseUrl().getDirectory());\n        log().debug(\"RWS timeout(sec): \"+m_rwsConfig.getBaseUrl().getTimeout());\n        if (m_rwsConfig.getBaseUrl().getUsername() == null)\n            return new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n        String password = \"\";\n        if (m_rwsConfig.getBaseUrl().getPassword() != null)\n            password = m_rwsConfig.getBaseUrl().getPassword();\n        return new ConnectionProperties(m_rwsConfig.getBaseUrl().getUsername(),password,m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void processPendingOperationForNode(AdapterOperation op) throws ProvisioningAdapterException {\n        if (op.getType() == AdapterOperationType.ADD) {\n            doAdd(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.UPDATE) {\n            doUpdate(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.DELETE) {\n            doDelete(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            doNodeConfigChanged(op.getNodeId());\n        }\n    }","id":9587,"modified_method":"@Override\n    public void processPendingOperationForNode(AdapterOperation op) throws ProvisioningAdapterException {\n        if (op.getType() == AdapterOperationType.ADD) {\n            doAdd(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.UPDATE) {\n            doUpdate(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.DELETE) {\n            doDelete(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            doNodeConfigChanged(op.getNodeId(),m_cp,true);\n        }\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\n        RWSClientApi.init();\n        Assert.notNull(m_rwsConfig, \"Rancid Provisioning Adapter requires RWSConfig property to be set.\");\n        \n        m_cp = getRWSConnection();\n        \n        Assert.notNull(m_nodeDao, \"Rancid Provisioning Adapter requires nodeDao property to be set.\");\n        \n        createMessageSelectorAndSubscribe();\n        buildRancidNodeMap();\n    }","id":9588,"modified_method":"public void afterPropertiesSet() throws Exception {\n\n        RWSClientApi.init();\n        Assert.notNull(m_rwsConfig, \"Rancid Provisioning Adapter requires RWSConfig property to be set.\");\n        \n        m_cp = getRWSConnection();\n        \n        Assert.notNull(m_nodeDao, \"Rancid Provisioning Adapter requires nodeDao property to be set.\");\n        \n        createMessageSelectorAndSubscribe();\n        getRancidCategories();\n        buildRancidNodeMap();\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //The group should be the foreign source of the node\n\n        String group = node.getForeignSource();\n\n        if (group == null) return null;\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Check the node categories if useNodecategories is true\n        r_node.setDeviceType(m_rancidAdapterConfig.getType(node.getSysObjectId()));\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","id":9589,"modified_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //The group should be the foreign source of the node\n\n        String group = node.getForeignSource();\n\n        if (group == null) return null;\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        String ipaddress = getSuitableIpForRancid(node.getId().intValue());\n        if (m_rancidAdapterConfig.useCategories(ipaddress)) {\n           r_node.setDeviceType(getTypeFromCategories(node)); \n        } else {\n            r_node.setDeviceType(getTypeFromSysObjectId(node.getSysObjectId()));\n        }\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getSuitableIpForRancid(int nodeid){\n        OnmsNode node = m_nodeDao.get(nodeid);\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","id":9590,"modified_method":"@Transactional\n    public String getSuitableIpForRancid(int nodeid){\n        OnmsNode node = m_nodeDao.get(nodeid);\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void doNodeConfigChanged(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();\n                RWSClientApi.updateRWSRancidNode(m_cp, rNode);\n            } else {\n                throw new Exception(\"No node found for nodeid: \" + nodeId);\n            }\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","id":9591,"modified_method":"public void doNodeConfigChanged(int nodeId,ConnectionProperties cp, boolean retry) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();\n                RWSClientApi.updateRWSRancidNode(cp, rNode);\n            } else {\n                log().warn(\"No node found in nodeRancid Map for nodeid: \" + nodeId);\n            }\n        } catch (Exception e) {\n            cp = getStandByRWSConnection();\n            if (retry && cp != null) {\n                doNodeConfigChanged(nodeId, cp, false);\n            } else {\n                sendAndThrow(nodeId, e);            \n            }\n        }\n    }","commit_id":"c6ec57b52d4f0561cc9c7ea611a54899981d8ede","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void doNodeConfigChanged(int nodeId) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();\n                RWSClientApi.updateRWSRancidNode(m_cp, rNode);\n            } else {\n                throw new Exception(\"No node found for nodeid: \" + nodeId);\n            }\n        } catch (Exception e) {\n            sendAndThrow(nodeId, e);\n        }\n    }","id":9592,"modified_method":"public void doNodeConfigChanged(int nodeId,ConnectionProperties cp, boolean retry) throws ProvisioningAdapterException {\n        log().debug(\"RANCID PROVISIONING ADAPTER CALLED updateNode\");\n        try {\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                RancidNode rNode = m_onmsNodeRancidNodeMap.get(Integer.valueOf(nodeId)).getNode();\n                RWSClientApi.updateRWSRancidNode(cp, rNode);\n            } else {\n                log().warn(\"No node found in nodeRancid Map for nodeid: \" + nodeId);\n            }\n        } catch (Exception e) {\n            cp = getStandByRWSConnection();\n            if (retry && cp != null) {\n                doNodeConfigChanged(nodeId, cp, false);\n            } else {\n                sendAndThrow(nodeId, e);            \n            }\n        }\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_FAILURE_UEI)\n    public void handleRancidDownLoadFailure(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid()) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, true);\n                doNodeConfigChanged(nodeId);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","id":9593,"modified_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_FAILURE_UEI)\n    public void handleRancidDownLoadFailure(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid()) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, true);\n                doNodeConfigChanged(nodeId,m_cp,true);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private ConnectionProperties getRWSConnection() {\n        log().debug(\"Connections used : \" +m_rwsConfig.getBaseUrl().getServer_url()+m_rwsConfig.getBaseUrl().getDirectory());\n        log().debug(\"RWS timeout(sec): \"+m_rwsConfig.getBaseUrl().getTimeout());        \n        return new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n    }","id":9594,"modified_method":"private ConnectionProperties getRWSConnection() {\n        log().debug(\"Connections used : \" +m_rwsConfig.getBaseUrl().getServer_url()+m_rwsConfig.getBaseUrl().getDirectory());\n        log().debug(\"RWS timeout(sec): \"+m_rwsConfig.getBaseUrl().getTimeout());\n        if (m_rwsConfig.getBaseUrl().getUsername() == null)\n            return new ConnectionProperties(m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n        String password = \"\";\n        if (m_rwsConfig.getBaseUrl().getPassword() != null)\n            password = m_rwsConfig.getBaseUrl().getPassword();\n        return new ConnectionProperties(m_rwsConfig.getBaseUrl().getUsername(),password,m_rwsConfig.getBaseUrl().getServer_url(),m_rwsConfig.getBaseUrl().getDirectory(),m_rwsConfig.getBaseUrl().getTimeout());\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_SUCCESS_UEI)\n    public void handleRancidDownLoadSuccess(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid() ) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, false);\n                doNodeConfigChanged(nodeId);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","id":9595,"modified_method":"@EventHandler(uei = EventConstants.RANCID_DOWNLOAD_SUCCESS_UEI)\n    public void handleRancidDownLoadSuccess(Event e) {\n        log().debug(\"get Event uei/id: \" + e.getUei() + \"/\" + e.getDbid());\n        if (e.hasNodeid() ) {\n            int nodeId = Long.valueOf(e.getNodeid()).intValue();\n            if (m_onmsNodeRancidNodeMap.containsKey(Integer.valueOf(nodeId))) {\n                updateRancidNodeState(nodeId, false);\n                doNodeConfigChanged(nodeId,m_cp,true);\n            } else {\n                log().warn(\"node does not exist with nodeid: \" + e.getNodeid());\n            }\n        }\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //The group should be the foreign source of the node\n\n        String group = node.getForeignSource();\n\n        if (group == null) return null;\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        //FIXME: Check the node categories if useNodecategories is true\n        r_node.setDeviceType(m_rancidAdapterConfig.getType(node.getSysObjectId()));\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","id":9596,"modified_method":"private RancidNode getSuitableRancidNode(OnmsNode node) {\n        \n\n        //The group should be the foreign source of the node\n\n        String group = node.getForeignSource();\n\n        if (group == null) return null;\n        RancidNode r_node = new RancidNode(group, node.getLabel());\n\n        String ipaddress = getSuitableIpForRancid(node.getId().intValue());\n        if (m_rancidAdapterConfig.useCategories(ipaddress)) {\n           r_node.setDeviceType(getTypeFromCategories(node)); \n        } else {\n            r_node.setDeviceType(getTypeFromSysObjectId(node.getSysObjectId()));\n        }\n        r_node.setStateUp(false);\n        r_node.setComment(RANCID_COMMENT);\n        return r_node;\n\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void afterPropertiesSet() throws Exception {\n\n        RWSClientApi.init();\n        Assert.notNull(m_rwsConfig, \"Rancid Provisioning Adapter requires RWSConfig property to be set.\");\n        \n        m_cp = getRWSConnection();\n        \n        Assert.notNull(m_nodeDao, \"Rancid Provisioning Adapter requires nodeDao property to be set.\");\n        \n        createMessageSelectorAndSubscribe();\n        buildRancidNodeMap();\n    }","id":9597,"modified_method":"public void afterPropertiesSet() throws Exception {\n\n        RWSClientApi.init();\n        Assert.notNull(m_rwsConfig, \"Rancid Provisioning Adapter requires RWSConfig property to be set.\");\n        \n        m_cp = getRWSConnection();\n        \n        Assert.notNull(m_nodeDao, \"Rancid Provisioning Adapter requires nodeDao property to be set.\");\n        \n        createMessageSelectorAndSubscribe();\n        getRancidCategories();\n        buildRancidNodeMap();\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getSuitableIpForRancid(int nodeid){\n        OnmsNode node = m_nodeDao.get(nodeid);\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","id":9598,"modified_method":"@Transactional\n    public String getSuitableIpForRancid(int nodeid){\n        OnmsNode node = m_nodeDao.get(nodeid);\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void processPendingOperationForNode(AdapterOperation op) throws ProvisioningAdapterException {\n        if (op.getType() == AdapterOperationType.ADD) {\n            doAdd(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.UPDATE) {\n            doUpdate(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.DELETE) {\n            doDelete(op.getNodeId());\n        } else if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            doNodeConfigChanged(op.getNodeId());\n        }\n    }","id":9599,"modified_method":"@Override\n    public void processPendingOperationForNode(AdapterOperation op) throws ProvisioningAdapterException {\n        if (op.getType() == AdapterOperationType.ADD) {\n            doAdd(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.UPDATE) {\n            doUpdate(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.DELETE) {\n            doDelete(op.getNodeId(),m_cp,true);\n        } else if (op.getType() == AdapterOperationType.CONFIG_CHANGE) {\n            doNodeConfigChanged(op.getNodeId(),m_cp,true);\n        }\n    }","commit_id":"d3c4a373079d099aa0d55f0cebfaaa417e4cb992","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public Map<String,String> getBuildVariables() {\n        Map<String,String> r = super.getBuildVariables();\n        // pick up user axes\n        r.putAll(getParent().getCombination());\n        return r;\n    }","id":9600,"modified_method":"@Override\n    public Map<String,String> getBuildVariables() {\n        Map<String,String> r = super.getBuildVariables();\n        // pick up user axes\n        AxisList axes = getParent().getParent().getAxes();\n        for (Map.Entry<String,String> e : getParent().getCombination().entrySet()) {\n            Axis a = axes.find(e.getKey());\n            if (a!=null)\n                a.addBuildVariable(e.getValue(),r);\n            else\n                r.put(e.getKey(), e.getValue());\n        }\n        return r;\n    }","commit_id":"ba1588168136ef86f204a01b9acadd050eccc091","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\r\n     * stacks a crawl item. The position can also be remote\r\n     * @param entry\r\n     * @return null if successful, a reason string if not successful\r\n     */\r\n    public String stackCrawl(final Request entry) {\r\n        //this.log.logFinest(\"stackCrawl: nexturlString='\" + nexturlString + \"'\");\r\n\r\n        byte[] handle = UTF8.getBytes(entry.profileHandle());\r\n        final CrawlProfile profile = this.crawler.get(handle);\r\n        String error;\r\n        if (profile == null) {\r\n            error = \"LOST STACKER PROFILE HANDLE '\" + entry.profileHandle() + \"' for URL \" + entry.url();\r\n            this.log.warn(error);\r\n            return error;\r\n        }\r\n\r\n        error = checkAcceptanceChangeable(entry.url(), profile, entry.depth());\r\n        if (error != null) return error;\r\n        error = checkAcceptanceInitially(entry.url(), profile);\r\n        if (error != null) return error;\r\n\r\n        // store information\r\n        final boolean local = Base64Order.enhancedCoder.equal(entry.initiator(), UTF8.getBytes(this.peers.mySeed().hash));\r\n        final boolean proxy = (entry.initiator() == null || entry.initiator().length == 0 || ASCII.String(entry.initiator()).equals(\"------------\")) && profile.handle().equals(this.crawler.defaultProxyProfile.handle());\r\n        final boolean remote = profile.handle().equals(this.crawler.defaultRemoteProfile.handle());\r\n        final boolean global =\r\n            (profile.remoteIndexing()) /* granted */ &&\r\n            (entry.depth() == profile.depth()) /* leaf node */ &&\r\n            //(initiatorHash.equals(yacyCore.seedDB.mySeed.hash)) /* not proxy */ &&\r\n            (\r\n                    (this.peers.mySeed().isSenior()) ||\r\n                    (this.peers.mySeed().isPrincipal())\r\n            ) /* qualified */;\r\n\r\n        if (!local && !global && !remote && !proxy) {\r\n            error = \"URL '\" + entry.url().toString() + \"' cannot be crawled. initiator = \" + ((entry.initiator() == null) ? \"\" : ASCII.String(entry.initiator())) + \", profile.handle = \" + profile.handle();\r\n            this.log.severe(error);\r\n            return error;\r\n        }\r\n\r\n        long maxFileSize = Long.MAX_VALUE;\r\n        if (!entry.isEmpty()) {\r\n            final String protocol = entry.url().getProtocol();\r\n            if (protocol.equals(\"http\") || protocol.equals(\"https\")) maxFileSize = Switchboard.getSwitchboard().getConfigLong(\"crawler.http.maxFileSize\", HTTPLoader.DEFAULT_MAXFILESIZE);\r\n            if (protocol.equals(\"ftp\")) maxFileSize = Switchboard.getSwitchboard().getConfigLong(\"crawler.ftp.maxFileSize\", FTPLoader.DEFAULT_MAXFILESIZE);\r\n            if (protocol.equals(\"smb\")) maxFileSize = Switchboard.getSwitchboard().getConfigLong(\"crawler.smb.maxFileSize\", SMBLoader.DEFAULT_MAXFILESIZE);\r\n        }\r\n\r\n        // check availability of parser and maxfilesize\r\n        String warning = null;\r\n        boolean loadImages = Switchboard.getSwitchboard().getConfigBool(SwitchboardConstants.CRAWLER_LOAD_IMAGE, true);\r\n        if (!loadImages && Switchboard.getSwitchboard().getConfig(SwitchboardConstants.CRAWLER_LOAD_IMAGE, \"\").equals(\"true;\")) {\r\n            // dammit semicolon\r\n            // TODO: remove this shit later\r\n            Switchboard.getSwitchboard().setConfig(SwitchboardConstants.CRAWLER_LOAD_IMAGE, true);\r\n            loadImages = true;\r\n        }\r\n        ContentDomain contentDomain = entry.url().getContentDomainFromExt();\r\n        if ((maxFileSize >= 0 && entry.size() > maxFileSize) ||\r\n            contentDomain == ContentDomain.APP  ||\r\n            (!loadImages && contentDomain == ContentDomain.IMAGE) ||\r\n            contentDomain == ContentDomain.AUDIO  ||\r\n            contentDomain == ContentDomain.VIDEO ||\r\n            contentDomain == ContentDomain.CTRL) {\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.NOLOAD, entry, profile, this.robots);\r\n            //if (warning != null && this.log.isFine()) this.log.logFine(\"CrawlStacker.stackCrawl of URL \" + entry.url().toNormalform(true, false) + \" - not pushed: \" + warning);\r\n            return null;\r\n        }\r\n\r\n        if (global) {\r\n            // it may be possible that global == true and local == true, so do not check an error case against it\r\n            if (proxy) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: global = true, proxy = true, initiator = proxy\" + \", profile.handle = \" + profile.handle());\r\n            if (remote) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: global = true, remote = true, initiator = \" + ASCII.String(entry.initiator()) + \", profile.handle = \" + profile.handle());\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.GLOBAL, entry, profile, this.robots);\r\n        } else if (local) {\r\n            if (proxy) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: local = true, proxy = true, initiator = proxy\" + \", profile.handle = \" + profile.handle());\r\n            if (remote) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: local = true, remote = true, initiator = \" + ASCII.String(entry.initiator()) + \", profile.handle = \" + profile.handle());\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.LOCAL, entry, profile, this.robots);\r\n        } else if (proxy) {\r\n            if (remote) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: proxy = true, remote = true, initiator = \" + ASCII.String(entry.initiator()) + \", profile.handle = \" + profile.handle());\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.LOCAL, entry, profile, this.robots);\r\n        } else if (remote) {\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.REMOTE, entry, profile, this.robots);\r\n        }\r\n        if (warning != null && this.log.isFine()) this.log.fine(\"CrawlStacker.stackCrawl of URL \" + entry.url().toNormalform(true) + \" - not pushed: \" + warning);\r\n\r\n        return null;\r\n    }","id":9601,"modified_method":"/**\r\n     * stacks a crawl item. The position can also be remote\r\n     * @param entry\r\n     * @return null if successful, a reason string if not successful\r\n     */\r\n    public String stackCrawl(final Request entry) {\r\n        //this.log.logFinest(\"stackCrawl: nexturlString='\" + nexturlString + \"'\");\r\n\r\n        byte[] handle = UTF8.getBytes(entry.profileHandle());\r\n        final CrawlProfile profile = this.crawler.get(handle);\r\n        String error;\r\n        if (profile == null) {\r\n            error = \"LOST STACKER PROFILE HANDLE '\" + entry.profileHandle() + \"' for URL \" + entry.url();\r\n            this.log.warn(error);\r\n            return error;\r\n        }\r\n\r\n        error = checkAcceptanceChangeable(entry.url(), profile, entry.depth());\r\n        if (error != null) return error;\r\n        error = checkAcceptanceInitially(entry.url(), profile);\r\n        if (error != null) return error;\r\n\r\n        // store information\r\n        final boolean local = Base64Order.enhancedCoder.equal(entry.initiator(), UTF8.getBytes(this.peers.mySeed().hash));\r\n        final boolean proxy = (entry.initiator() == null || entry.initiator().length == 0 || ASCII.String(entry.initiator()).equals(\"------------\")) && profile.handle().equals(this.crawler.defaultProxyProfile.handle());\r\n        final boolean remote = profile.handle().equals(this.crawler.defaultRemoteProfile.handle());\r\n        final boolean global =\r\n            (profile.remoteIndexing()) /* granted */ &&\r\n            (entry.depth() == profile.depth()) /* leaf node */ &&\r\n            //(initiatorHash.equals(yacyCore.seedDB.mySeed.hash)) /* not proxy */ &&\r\n            (\r\n                    (this.peers.mySeed().isSenior()) ||\r\n                    (this.peers.mySeed().isPrincipal())\r\n            ) /* qualified */;\r\n\r\n        if (!local && !global && !remote && !proxy) {\r\n            error = \"URL '\" + entry.url().toString() + \"' cannot be crawled. initiator = \" + ((entry.initiator() == null) ? \"\" : ASCII.String(entry.initiator())) + \", profile.handle = \" + profile.handle();\r\n            this.log.severe(error);\r\n            return error;\r\n        }\r\n\r\n        long maxFileSize = Long.MAX_VALUE;\r\n        if (!entry.isEmpty()) {\r\n            final String protocol = entry.url().getProtocol();\r\n            if (protocol.equals(\"http\") || protocol.equals(\"https\")) maxFileSize = Switchboard.getSwitchboard().getConfigLong(\"crawler.http.maxFileSize\", HTTPLoader.DEFAULT_MAXFILESIZE);\r\n            if (protocol.equals(\"ftp\")) maxFileSize = Switchboard.getSwitchboard().getConfigLong(\"crawler.ftp.maxFileSize\", FTPLoader.DEFAULT_MAXFILESIZE);\r\n            if (protocol.equals(\"smb\")) maxFileSize = Switchboard.getSwitchboard().getConfigLong(\"crawler.smb.maxFileSize\", SMBLoader.DEFAULT_MAXFILESIZE);\r\n        }\r\n\r\n        // check availability of parser and maxfilesize\r\n        String warning = null;\r\n        ContentDomain contentDomain = entry.url().getContentDomainFromExt();\r\n        if ((maxFileSize >= 0 && entry.size() > maxFileSize) ||\r\n            contentDomain == ContentDomain.APP  ||\r\n            (contentDomain == ContentDomain.IMAGE && TextParser.supportsExtension(entry.url()) != null) ||\r\n            contentDomain == ContentDomain.AUDIO  ||\r\n            contentDomain == ContentDomain.VIDEO ||\r\n            contentDomain == ContentDomain.CTRL) {\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.NOLOAD, entry, profile, this.robots);\r\n            //if (warning != null && this.log.isFine()) this.log.logFine(\"CrawlStacker.stackCrawl of URL \" + entry.url().toNormalform(true, false) + \" - not pushed: \" + warning);\r\n            return null;\r\n        }\r\n\r\n        if (global) {\r\n            // it may be possible that global == true and local == true, so do not check an error case against it\r\n            if (proxy) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: global = true, proxy = true, initiator = proxy\" + \", profile.handle = \" + profile.handle());\r\n            if (remote) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: global = true, remote = true, initiator = \" + ASCII.String(entry.initiator()) + \", profile.handle = \" + profile.handle());\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.GLOBAL, entry, profile, this.robots);\r\n        } else if (local) {\r\n            if (proxy) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: local = true, proxy = true, initiator = proxy\" + \", profile.handle = \" + profile.handle());\r\n            if (remote) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: local = true, remote = true, initiator = \" + ASCII.String(entry.initiator()) + \", profile.handle = \" + profile.handle());\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.LOCAL, entry, profile, this.robots);\r\n        } else if (proxy) {\r\n            if (remote) this.log.warn(\"URL '\" + entry.url().toString() + \"' has conflicting initiator properties: proxy = true, remote = true, initiator = \" + ASCII.String(entry.initiator()) + \", profile.handle = \" + profile.handle());\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.LOCAL, entry, profile, this.robots);\r\n        } else if (remote) {\r\n            warning = this.nextQueue.noticeURL.push(NoticedURL.StackType.REMOTE, entry, profile, this.robots);\r\n        }\r\n        if (warning != null && this.log.isFine()) this.log.fine(\"CrawlStacker.stackCrawl of URL \" + entry.url().toNormalform(true) + \" - not pushed: \" + warning);\r\n\r\n        return null;\r\n    }","commit_id":"234a974955c0ab4f7de63157738e4b00a8ffcae8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Document[] parseDocument(final Response response) throws InterruptedException {\n        Document[] documents = null;\n        final EventOrigin processCase = response.processCase(this.peers.mySeed().hash);\n\n        if ( this.log.isFine() ) {\n            this.log.fine(\n                \"processResourceStack processCase=\" + processCase\n                + \", depth=\" + response.depth()\n                + \", maxDepth=\" + ((response.profile() == null) ? \"null\" : Integer.toString(response.profile().depth()))\n                + \", must-match=\" + ((response.profile() == null) ? \"null\" : response.profile().urlMustMatchPattern().toString())\n                + \", must-not-match=\" + ((response.profile() == null) ? \"null\" : response.profile().urlMustNotMatchPattern().toString())\n                + \", initiatorHash=\" + ((response.initiator() == null) ? \"null\" : ASCII.String(response.initiator()))\n                + \", url=\" + response.url()); // DEBUG\n        }\n\n        // PARSE CONTENT\n        final long parsingStartTime = System.currentTimeMillis();\n        if ( response.getContent() == null ) {\n            // fetch the document from cache\n            response.setContent(Cache.getContent(response.url().hash()));\n            if ( response.getContent() == null ) {\n                this.log.warn(\"the resource '\" + response.url() + \"' is missing in the cache.\");\n                // create a new errorURL DB entry\n                this.crawlQueues.errorURL.push(response.url(), response.profile(), FailCategory.FINAL_LOAD_CONTEXT, \"missing in cache\", -1);\n                return null;\n            }\n        }\n        assert response.getContent() != null;\n        try {\n            // parse the document\n            documents =\n                TextParser.parseSource(\n                    new AnchorURL(response.url()),\n                    response.getMimeType(),\n                    response.getCharacterEncoding(),\n                    response.getContent());\n            if ( documents == null ) {\n                throw new Parser.Failure(\"Parser returned null.\", response.url());\n            }\n        } catch (final Parser.Failure e ) {\n            this.log.warn(\"Unable to parse the resource '\" + response.url() + \"'. \" + e.getMessage());\n            // create a new errorURL DB entry\n            this.crawlQueues.errorURL.push(response.url(), response.profile(), FailCategory.FINAL_PROCESS_CONTEXT, e.getMessage(), -1);\n            return null;\n        }\n        final long parsingEndTime = System.currentTimeMillis();\n        \n        \n        // put anchors on crawl stack\n        final long stackStartTime = System.currentTimeMillis();\n        // check if the documents have valid urls; this is not a bug patch; it is possible that\n        // i.e. the result of a feed parsing results in documents from domains which shall be filtered by the crawl profile\n        if (response.profile() != null) {\n            ArrayList<Document> newDocs = new ArrayList<Document>();\n            for (Document doc: documents) {\n                String rejectReason = this.crawlStacker.checkAcceptanceChangeable(doc.dc_source(), response.profile(), 1 /*depth is irrelevant here, we just make clear its not the start url*/);\n                if (rejectReason == null) {\n                    newDocs.add(doc);\n                } else {\n                    // we consider this as fail urls to have a tracking of the problem\n                    if (rejectReason != null && !rejectReason.startsWith(\"double in\")) {\n                        final CrawlProfile profile = this.crawler.get(UTF8.getBytes(response.profile().handle()));\n                        this.crawlStacker.nextQueue.errorURL.push(response.url(), profile, FailCategory.FINAL_LOAD_CONTEXT, rejectReason, -1);\n                    }\n                }\n            }\n            if (newDocs.size() != documents.length) {\n                documents = (Document[]) newDocs.toArray();\n            }\n        }\n        \n        // collect anchors within remaining documents\n        if ((processCase == EventOrigin.PROXY_LOAD || processCase == EventOrigin.LOCAL_CRAWLING) &&\n            (\n                response.profile() == null ||\n                response.depth() < response.profile().depth() ||\n                response.profile().crawlerNoDepthLimitMatchPattern().matcher(response.url().toNormalform(true)).matches()\n            )\n           ) {\n            // get the hyperlinks\n            final Map<DigestURL, String> hl = Document.getHyperlinks(documents);\n            boolean loadImages = getConfigBool(SwitchboardConstants.CRAWLER_LOAD_IMAGE, true);\n            if (loadImages) hl.putAll(Document.getImagelinks(documents));\n            \n            // add all media links also to the crawl stack. They will be re-sorted to the NOLOAD queue and indexed afterwards as pure links\n            if (response.profile().directDocByURL()) {\n                if (!loadImages) hl.putAll(Document.getImagelinks(documents));\n                hl.putAll(Document.getApplinks(documents));\n                hl.putAll(Document.getVideolinks(documents));\n                hl.putAll(Document.getAudiolinks(documents));\n            }\n\n            // insert those hyperlinks to the crawler\n            MultiProtocolURL nextUrl;\n            for ( final Map.Entry<DigestURL, String> nextEntry : hl.entrySet() ) {\n                // check for interruption\n                checkInterruption();\n\n                // process the next hyperlink\n                nextUrl = nextEntry.getKey();\n                String u = nextUrl.toNormalform(true, true);\n                if ( !(u.startsWith(\"http://\")\n                    || u.startsWith(\"https://\")\n                    || u.startsWith(\"ftp://\")\n                    || u.startsWith(\"smb://\") || u.startsWith(\"file://\")) ) {\n                    continue;\n                }\n                \n                // rewrite the url\n                String u0 = LibraryProvider.urlRewriter.apply(u);\n                if (!u.equals(u0)) {\n                    log.info(\"REWRITE of url = \\\"\" + u + \"\\\" to \\\"\" + u0 + \"\\\"\");\n                    u = u0;\n                }\n                \n                // enqueue the hyperlink into the pre-notice-url db\n                try {\n                    this.crawlStacker.enqueueEntry(new Request(\n                        response.initiator(),\n                        new DigestURL(u),\n                        response.url().hash(),\n                        nextEntry.getValue(),\n                        new Date(),\n                        response.profile().handle(),\n                        response.depth() + 1,\n                        0,\n                        0,\n                        response.size() < 0 ? 0 : response.size()));\n                } catch (final MalformedURLException e ) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n            final long stackEndTime = System.currentTimeMillis();\n            if ( this.log.isInfo() ) {\n                this.log.info(\"CRAWL: ADDED \"\n                    + hl.size()\n                    + \" LINKS FROM \"\n                    + response.url().toNormalform(true)\n                    + \", STACKING TIME = \"\n                    + (stackEndTime - stackStartTime)\n                    + \", PARSING TIME = \"\n                    + (parsingEndTime - parsingStartTime));\n            }\n        }\n        return documents;\n    }","id":9602,"modified_method":"private Document[] parseDocument(final Response response) throws InterruptedException {\n        Document[] documents = null;\n        final EventOrigin processCase = response.processCase(this.peers.mySeed().hash);\n\n        if ( this.log.isFine() ) {\n            this.log.fine(\n                \"processResourceStack processCase=\" + processCase\n                + \", depth=\" + response.depth()\n                + \", maxDepth=\" + ((response.profile() == null) ? \"null\" : Integer.toString(response.profile().depth()))\n                + \", must-match=\" + ((response.profile() == null) ? \"null\" : response.profile().urlMustMatchPattern().toString())\n                + \", must-not-match=\" + ((response.profile() == null) ? \"null\" : response.profile().urlMustNotMatchPattern().toString())\n                + \", initiatorHash=\" + ((response.initiator() == null) ? \"null\" : ASCII.String(response.initiator()))\n                + \", url=\" + response.url()); // DEBUG\n        }\n\n        // PARSE CONTENT\n        final long parsingStartTime = System.currentTimeMillis();\n        if ( response.getContent() == null ) {\n            // fetch the document from cache\n            response.setContent(Cache.getContent(response.url().hash()));\n            if ( response.getContent() == null ) {\n                this.log.warn(\"the resource '\" + response.url() + \"' is missing in the cache.\");\n                // create a new errorURL DB entry\n                this.crawlQueues.errorURL.push(response.url(), response.profile(), FailCategory.FINAL_LOAD_CONTEXT, \"missing in cache\", -1);\n                return null;\n            }\n        }\n        assert response.getContent() != null;\n        try {\n            // parse the document\n            documents =\n                TextParser.parseSource(\n                    new AnchorURL(response.url()),\n                    response.getMimeType(),\n                    response.getCharacterEncoding(),\n                    response.getContent());\n            if ( documents == null ) {\n                throw new Parser.Failure(\"Parser returned null.\", response.url());\n            }\n        } catch (final Parser.Failure e ) {\n            this.log.warn(\"Unable to parse the resource '\" + response.url() + \"'. \" + e.getMessage());\n            // create a new errorURL DB entry\n            this.crawlQueues.errorURL.push(response.url(), response.profile(), FailCategory.FINAL_PROCESS_CONTEXT, e.getMessage(), -1);\n            return null;\n        }\n        final long parsingEndTime = System.currentTimeMillis();\n        \n        \n        // put anchors on crawl stack\n        final long stackStartTime = System.currentTimeMillis();\n        // check if the documents have valid urls; this is not a bug patch; it is possible that\n        // i.e. the result of a feed parsing results in documents from domains which shall be filtered by the crawl profile\n        if (response.profile() != null) {\n            ArrayList<Document> newDocs = new ArrayList<Document>();\n            for (Document doc: documents) {\n                String rejectReason = this.crawlStacker.checkAcceptanceChangeable(doc.dc_source(), response.profile(), 1 /*depth is irrelevant here, we just make clear its not the start url*/);\n                if (rejectReason == null) {\n                    newDocs.add(doc);\n                } else {\n                    // we consider this as fail urls to have a tracking of the problem\n                    if (rejectReason != null && !rejectReason.startsWith(\"double in\")) {\n                        final CrawlProfile profile = this.crawler.get(UTF8.getBytes(response.profile().handle()));\n                        this.crawlStacker.nextQueue.errorURL.push(response.url(), profile, FailCategory.FINAL_LOAD_CONTEXT, rejectReason, -1);\n                    }\n                }\n            }\n            if (newDocs.size() != documents.length) {\n                documents = (Document[]) newDocs.toArray();\n            }\n        }\n        \n        // collect anchors within remaining documents\n        if ((processCase == EventOrigin.PROXY_LOAD || processCase == EventOrigin.LOCAL_CRAWLING) &&\n            (\n                response.profile() == null ||\n                response.depth() < response.profile().depth() ||\n                response.profile().crawlerNoDepthLimitMatchPattern().matcher(response.url().toNormalform(true)).matches()\n            )\n           ) {\n            // get the hyperlinks\n            final Map<DigestURL, String> hl = Document.getHyperlinks(documents);\n            for (Map.Entry<DigestURL, String> entry: Document.getImagelinks(documents).entrySet()) {\n                if (TextParser.supportsExtension(entry.getKey()) == null) hl.put(entry.getKey(), entry.getValue());\n            }\n            \n            \n            // add all media links also to the crawl stack. They will be re-sorted to the NOLOAD queue and indexed afterwards as pure links\n            if (response.profile().directDocByURL()) {\n                for (Map.Entry<DigestURL, String> entry: Document.getImagelinks(documents).entrySet()) {\n                    if (TextParser.supportsExtension(entry.getKey()) != null) hl.put(entry.getKey(), entry.getValue());\n                }\n                hl.putAll(Document.getApplinks(documents));\n                hl.putAll(Document.getVideolinks(documents));\n                hl.putAll(Document.getAudiolinks(documents));\n            }\n\n            // insert those hyperlinks to the crawler\n            MultiProtocolURL nextUrl;\n            for ( final Map.Entry<DigestURL, String> nextEntry : hl.entrySet() ) {\n                // check for interruption\n                checkInterruption();\n\n                // process the next hyperlink\n                nextUrl = nextEntry.getKey();\n                String u = nextUrl.toNormalform(true, true);\n                if ( !(u.startsWith(\"http://\")\n                    || u.startsWith(\"https://\")\n                    || u.startsWith(\"ftp://\")\n                    || u.startsWith(\"smb://\") || u.startsWith(\"file://\")) ) {\n                    continue;\n                }\n                \n                // rewrite the url\n                String u0 = LibraryProvider.urlRewriter.apply(u);\n                if (!u.equals(u0)) {\n                    log.info(\"REWRITE of url = \\\"\" + u + \"\\\" to \\\"\" + u0 + \"\\\"\");\n                    u = u0;\n                }\n                \n                // enqueue the hyperlink into the pre-notice-url db\n                try {\n                    this.crawlStacker.enqueueEntry(new Request(\n                        response.initiator(),\n                        new DigestURL(u),\n                        response.url().hash(),\n                        nextEntry.getValue(),\n                        new Date(),\n                        response.profile().handle(),\n                        response.depth() + 1,\n                        0,\n                        0,\n                        response.size() < 0 ? 0 : response.size()));\n                } catch (final MalformedURLException e ) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n            final long stackEndTime = System.currentTimeMillis();\n            if ( this.log.isInfo() ) {\n                this.log.info(\"CRAWL: ADDED \"\n                    + hl.size()\n                    + \" LINKS FROM \"\n                    + response.url().toNormalform(true)\n                    + \", STACKING TIME = \"\n                    + (stackEndTime - stackStartTime)\n                    + \", PARSING TIME = \"\n                    + (parsingEndTime - parsingStartTime));\n            }\n        }\n        return documents;\n    }","commit_id":"234a974955c0ab4f7de63157738e4b00a8ffcae8","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Gets the content of a given template file.\n     *\n     * @param cms CmsObject Object for accessing system resources\n     * @param templateFile Filename of the template file\n     * @param elementName <em>not used here<\/em>.\n     * @param parameters <em>not used here<\/em>.\n     * @return Unprocessed content of the given template file.\n     * @throws CmsException\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters) throws CmsException {\n        if(I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && A_OpenCms.isLogging() && C_DEBUG) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsDumpTemplate] Now dumping contents of file \" + templateFile);\n        }\n        byte[] s = null;\n        try {\n            // Encoding project:\n            CmsFile file = cms.readFile(templateFile);\n            if (cms.getResourceType(\"plain\").getResourceType() == file.getType()) {            \n                // We have a plain text file - so we need to deliver it in correct encoding.\n                // Here we suppose that in Cms non-xml files are stored in default content encoding\n                // (that's why we need to force this encoding for all workplace\n                // files - they need to operate with Cms files in this encoding)\n                s = new String(file.getContents(), A_OpenCms.getDefaultEncoding()).getBytes(cms.getRequestContext().getEncoding());\n            } else {\n                // we got a binary file - so just push it into result as it is\n                s = file.getContents();\n        \t}\n        }\n        catch(Exception e) {\n            String errorMessage = \"Error while reading file \" + templateFile + \": \" + e;\n            if(I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && A_OpenCms.isLogging() ) {\n                A_OpenCms.log(C_OPENCMS_CRITICAL, \"[CmsDumpTemplate] \" + errorMessage);\n            }\n            if(e instanceof CmsException) {\n                throw (CmsException)e;\n            }\n            else {\n                throw new CmsException(errorMessage, CmsException.C_UNKNOWN_EXCEPTION);\n            }\n        }\n        return s;\n    }","id":9603,"modified_method":"/**\n     * Gets the content of a given template file.\n     *\n     * @param cms CmsObject Object for accessing system resources\n     * @param templateFile Filename of the template file\n     * @param elementName <em>not used here<\/em>.\n     * @param parameters <em>not used here<\/em>.\n     * @return Unprocessed content of the given template file.\n     * @throws CmsException\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters) throws CmsException {\n        if(I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && A_OpenCms.isLogging() && C_DEBUG) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsDumpTemplate] Now dumping contents of file \" + templateFile);\n        }\n        byte[] s = null;\n        try {\n            // Encoding project:\n            CmsFile file = cms.readFile(templateFile);\n            if (cms.getResourceType(\"plain\").getResourceType() == file.getType()) {            \n                // We have a plain text file - so we need to deliver it in correct encoding.\n                // Here we suppose that in Cms non-xml files are stored in default content encoding\n                // (that's why we need to force this encoding for all workplace\n                // files - they need to operate with Cms files in this encoding)\n                s = Encoder.changeEncoding(file.getContents(), A_OpenCms.getDefaultEncoding(), cms.getRequestContext().getEncoding());\n            } else {\n                // we got a binary file - so just push it into result as it is\n                s = file.getContents();\n        \t}\n        }\n        catch(Exception e) {\n            String errorMessage = \"Error while reading file \" + templateFile + \": \" + e;\n            if(I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && A_OpenCms.isLogging() ) {\n                A_OpenCms.log(C_OPENCMS_CRITICAL, \"[CmsDumpTemplate] \" + errorMessage);\n            }\n            if(e instanceof CmsException) {\n                throw (CmsException)e;\n            }\n            else {\n                throw new CmsException(errorMessage, CmsException.C_UNKNOWN_EXCEPTION);\n            }\n        }\n        return s;\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Displays the editor described by the template file <code>templateFile<\/code>.\n     * This can be either the HTML editor or the text editor.\n     * <p>\n     * The given template file will be scanned for special section \"ie\" and \"ns\"\n     * that can be used to generate browser specific versions of the editors\n     * (MS IE or Netscape Navigator). If no such section exists, the default\n     * section will be displayed.\n     *\n     * @see #getContent(CmsObject, String, String, Hashtable, String)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        String saveerror = \"\";\n        // Get all editor parameters\n        String file = (String)parameters.get(C_PARA_FILE);\n        // try to get the value from the session because we might come from the error page\n        if((file == null) || (\"\".equals(file))){\n            file = (String)session.getValue(C_PARA_FILE);\n            session.removeValue(C_PARA_FILE);\n        }        \n        if((file != null) && (! \"\".equals(file))) {\n            session.putValue(\"te_file\", file);\n        }\n        String content = (String)parameters.get(C_PARA_CONTENT);\n        // try to get the value from the session because we might come from the error page\n        if((content == null) || (\"\".equals(content))){\n            content = (String)session.getValue(C_PARA_CONTENT);\n            if(content != null){\n                parameters.put(C_PARA_CONTENT, content);\n            }\n            session.removeValue(C_PARA_CONTENT);\n        }\n        String action = (String)parameters.get(C_PARA_ACTION);\n        String jsfile = (String)parameters.get(C_ROOT_TEMPLATE_NAME + \".\" + C_PARA_JSFILE);\n        // try to get the value from the session because we might come from the error page\n        if((jsfile == null) || (\"\".equals(jsfile))){\n            jsfile = (String)session.getValue(C_PARA_JSFILE);\n            session.removeValue(C_PARA_JSFILE);\n        }\n        String editorframe = (String)parameters.get(\"root.editorframe\");\n        if((editorframe == null) || (\"\".equals(editorframe))){\n            editorframe = (String)session.getValue(\"editorframe\");\n            session.removeValue(\"editorframe\");\n        }\n\n        boolean checkit = false;\n        boolean existsFileParam = ((file != null) && (!\"\".equals(file)));\n        boolean saveRequested = ((action != null) && (C_EDIT_ACTION_SAVE.equals(action)\n                || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n        boolean exitRequested = ((action != null) && (C_EDIT_ACTION_EXIT.equals(action)\n                || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n\n        // CmsFile object of the file to be edited\n        CmsFile editFile = null;\n\n        // If there is a file parameter and no content, try to read the file.\n        // If the user requested a \"save file\", also load the file.\n        if(existsFileParam && (content == null || saveRequested)) {\n            editFile = readFile(cms, file);\n            checkit = true;\n\n            // If there is no content set, this is the first request of the editor.\n            // So load the file content and set the \"content\" parameter.\n            if(content == null) {\n                //Gridnine AB Aug 8, 2002\n                try {\n                    content = new String(editFile.getContents(),\n                        cms.getRequestContext().getEncoding());\n                } catch (UnsupportedEncodingException e) {\n                    content = new String(editFile.getContents());\n                }\n                content = Encoder.escapeWBlanks(content,\n                    cms.getRequestContext().getEncoding());\n                parameters.put(C_PARA_CONTENT, content);\n            }\n\n            // If the user requested a file save, write the file content\n            // back to the database.\n            if(saveRequested) {\n                try{\n                    //Gridnine AB Aug 8, 2002\n                    String decodedContent = Encoder.unescape(content,\n                        cms.getRequestContext().getEncoding());\n                    try {\n                        editFile.setContents(decodedContent.getBytes(\n                            cms.getRequestContext().getEncoding()));\n                    } catch (UnsupportedEncodingException e) {\n                        editFile.setContents(decodedContent.getBytes());\n                    }\n                    cms.writeFile(editFile);\n                } catch (CmsException e){\n                    saveerror = e.getShortException();\n                }\n            }\n        }\n\n        // Check if we should leave th editor instead of start processing\n        if(exitRequested && ((saveerror == null) || (\"\".equals(saveerror)))) {\n            try {\n                cms.getRequestContext().getResponse().sendCmsRedirect(\"/system/workplace/action/index.html\");\n            }\n            catch(IOException e) {\n                throwException(\"Could not send redirect to workplace main screen.\", e);\n            }\n\n            //return \"\".getBytes();\n            return null;\n        }\n\n        // Load the template file and get the browser specific section name\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n        String sectionName = getBrowserSpecificSection(cms, xmlTemplateDocument, parameters);\n        \n        // Put the \"file\" datablock for processing in the template file.\n        // It will be inserted in a hidden input field and given back when submitting.\n        xmlTemplateDocument.setData(C_PARA_FILE, file);\n        xmlTemplateDocument.setData(C_PARA_JSFILE, jsfile);\n        xmlTemplateDocument.setData(\"editorframe\", editorframe);\n        // Announcement of path and file name in the header of the browser.\n        if(checkit==true){\n            xmlTemplateDocument.setData(\"fileName\", (String) editFile.getName());\n            xmlTemplateDocument.setData(\"pathName\", (String) editFile.getPath());\n        }\n        String lasturlname = null;\n        if(!\"\".equals(saveerror)){\n            if(file != null){\n                session.putValue(C_PARA_FILE, file);\n            }\n            if(content != null){\n                session.putValue(C_PARA_CONTENT, content);\n            }\n            if(jsfile != null){\n                session.putValue(C_PARA_JSFILE, jsfile);\n            }\n            if(editorframe != null){\n                session.putValue(\"editorframe\", editorframe);\n            }\n            sectionName = \"errorsave\";\n            xmlTemplateDocument.setData(\"errordetail\", saveerror);\n            lasturlname=(String)parameters.get(\"editor._TEMPLATE_\");\n            if (lasturlname != null){\n                lasturlname=lasturlname.substring(lasturlname.lastIndexOf(\"/\")+1, lasturlname.length());\n            }\n            xmlTemplateDocument.setData(\"errorlasturl\", lasturlname+\".html\");\n        }\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, sectionName);\n    }","id":9604,"modified_method":"/**\n     * Displays the editor described by the template file <code>templateFile<\/code>.\n     * This can be either the HTML editor or the text editor.\n     * <p>\n     * The given template file will be scanned for special section \"ie\" and \"ns\"\n     * that can be used to generate browser specific versions of the editors\n     * (MS IE or Netscape Navigator). If no such section exists, the default\n     * section will be displayed.\n     *\n     * @see #getContent(CmsObject, String, String, Hashtable, String)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        String saveerror = \"\";\n        // Get all editor parameters\n        String file = (String)parameters.get(C_PARA_FILE);\n        // try to get the value from the session because we might come from the error page\n        if((file == null) || (\"\".equals(file))){\n            file = (String)session.getValue(C_PARA_FILE);\n            session.removeValue(C_PARA_FILE);\n        }        \n        if((file != null) && (! \"\".equals(file))) {\n            session.putValue(\"te_file\", file);\n        }\n        String content = (String)parameters.get(C_PARA_CONTENT);\n        // try to get the value from the session because we might come from the error page\n        if((content == null) || (\"\".equals(content))){\n            content = (String)session.getValue(C_PARA_CONTENT);\n            if(content != null){\n                parameters.put(C_PARA_CONTENT, content);\n            }\n            session.removeValue(C_PARA_CONTENT);\n        }\n        String action = (String)parameters.get(C_PARA_ACTION);\n        String jsfile = (String)parameters.get(C_ROOT_TEMPLATE_NAME + \".\" + C_PARA_JSFILE);\n        // try to get the value from the session because we might come from the error page\n        if((jsfile == null) || (\"\".equals(jsfile))){\n            jsfile = (String)session.getValue(C_PARA_JSFILE);\n            session.removeValue(C_PARA_JSFILE);\n        }\n        String editorframe = (String)parameters.get(\"root.editorframe\");\n        if((editorframe == null) || (\"\".equals(editorframe))){\n            editorframe = (String)session.getValue(\"editorframe\");\n            session.removeValue(\"editorframe\");\n        }\n\n        boolean checkit = false;\n        boolean existsFileParam = ((file != null) && (!\"\".equals(file)));\n        boolean saveRequested = ((action != null) && (C_EDIT_ACTION_SAVE.equals(action)\n                || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n        boolean exitRequested = ((action != null) && (C_EDIT_ACTION_EXIT.equals(action)\n                || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n\n        // CmsFile object of the file to be edited\n        CmsFile editFile = null;\n\n        // If there is a file parameter and no content, try to read the file.\n        // If the user requested a \"save file\", also load the file.\n        if(existsFileParam && (content == null || saveRequested)) {\n            editFile = readFile(cms, file);\n            checkit = true;\n\n            // Read file encoding from the property of the file \n            String encoding = cms.getRequestContext().getEncoding();\n            encoding = cms.readProperty(file, C_PROPERTY_CONTENT_ENCODING, true, encoding);\n\n            // If there is no content set, this is the first request of the editor.\n            // So load the file content and set the \"content\" parameter.\n            if(content == null) {\n                //Gridnine AB Aug 8, 2002\n                try {\n                    content = new String(editFile.getContents(), encoding);\n                } catch (UnsupportedEncodingException e) {\n                    content = new String(editFile.getContents());\n                }\n                content = Encoder.escapeWBlanks(content, Encoder.C_URI_ENCODING);\n                parameters.put(C_PARA_CONTENT, content);\n            }\n\n            // If the user requested a file save, write the file content\n            // back to the database.\n            if(saveRequested) {\n                try{\n                    //Gridnine AB Aug 8, 2002\n                    String decodedContent = Encoder.unescape(content, Encoder.C_URI_ENCODING);\n                    try {\n                        editFile.setContents(decodedContent.getBytes(encoding));\n                    } catch (UnsupportedEncodingException e) {\n                        editFile.setContents(decodedContent.getBytes());\n                    }\n                    cms.writeFile(editFile);\n                } catch (CmsException e){\n                    saveerror = e.getShortException();\n                }\n            }\n        }\n\n        // Check if we should leave th editor instead of start processing\n        if(exitRequested && ((saveerror == null) || (\"\".equals(saveerror)))) {\n            try {\n                cms.getRequestContext().getResponse().sendCmsRedirect(\"/system/workplace/action/index.html\");\n            }\n            catch(IOException e) {\n                throwException(\"Could not send redirect to workplace main screen.\", e);\n            }\n\n            //return \"\".getBytes();\n            return null;\n        }\n\n        // Load the template file and get the browser specific section name\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n        String sectionName = getBrowserSpecificSection(cms, xmlTemplateDocument, parameters);\n        \n        // Put the \"file\" datablock for processing in the template file.\n        // It will be inserted in a hidden input field and given back when submitting.\n        xmlTemplateDocument.setData(C_PARA_FILE, file);\n        xmlTemplateDocument.setData(C_PARA_JSFILE, jsfile);\n        xmlTemplateDocument.setData(\"editorframe\", editorframe);\n        // Announcement of path and file name in the header of the browser.\n        if(checkit==true){\n            xmlTemplateDocument.setData(\"fileName\", (String) editFile.getName());\n            xmlTemplateDocument.setData(\"pathName\", (String) editFile.getPath());\n        }\n        String lasturlname = null;\n        if(!\"\".equals(saveerror)){\n            if(file != null){\n                session.putValue(C_PARA_FILE, file);\n            }\n            if(content != null){\n                session.putValue(C_PARA_CONTENT, content);\n            }\n            if(jsfile != null){\n                session.putValue(C_PARA_JSFILE, jsfile);\n            }\n            if(editorframe != null){\n                session.putValue(\"editorframe\", editorframe);\n            }\n            sectionName = \"errorsave\";\n            xmlTemplateDocument.setData(\"errordetail\", saveerror);\n            lasturlname=(String)parameters.get(\"editor._TEMPLATE_\");\n            if (lasturlname != null){\n                lasturlname=lasturlname.substring(lasturlname.lastIndexOf(\"/\")+1, lasturlname.length());\n            }\n            xmlTemplateDocument.setData(\"errorlasturl\", lasturlname+\".html\");\n        }\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, sectionName);\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Updates a JSP page in the \"real\" file system in case the VFS resource has changed.<p>\n     * \n     * Also processes the <code>&lt;%@ cms %&gt;<\/code> tags before the JSP is written to the real FS.\n     * Also recursivly updates all files that are referenced by a <code>&lt;%@ cms %&gt;<\/code> tag \n     * on this page to make sure the file actually exists in the real FS. \n     * All <code>&lt;%@ include %&gt;<\/code> tags are parsed and the name in the tag is translated\n     * from the OpenCms VFS path to the path in the real FS. \n     * The same is done for filenames in <code>&lt;%@ page errorPage=... %&gt;<\/code> tags.\n     * \n     * @param cms Used to access the OpenCms VFS\n     * @param file The reqested JSP file resource in the VFS\n     * @param req The current request\n     * @param res The current response\n     * @param updates A Set containing all JSP pages that have been already updated\n     * \n     * @return The file name of the updated JSP in the \"real\" FS\n     * \n     * @throws ServletException might be thrown in the process of including the JSP \n     * @throws IOException might be thrown in the process of including the JSP \n     */\n    private synchronized String updateJsp(CmsObject cms, CmsResource file, CmsFlexRequest req, Set updates) \n    throws IOException, ServletException {\n        \n        String jspTargetName = getJspName(file.getAbsolutePath());\n        String jspPath = getJspPath(jspTargetName, req.isOnline());\n        \n        File d = new File(jspPath).getParentFile();\n        if (! (d != null) && (d.exists() && d.isDirectory() && d.canRead())) {\n            if (I_CmsLogChannels.C_LOGGING && A_OpenCms.isLogging(I_CmsLogChannels.C_OPENCMS_CRITICAL)) \n                A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_CRITICAL, \"Could not access directory for \" + jspPath);\n            throw new ServletException(\"JspLoader: Could not access directory for \" + jspPath);\n        }    \n        \n        if (updates.contains(jspTargetName)) return null;\n        updates.add(jspTargetName);\n        \n        boolean mustUpdate = false;\n        \n        File f = new File(jspPath);        \n        if (!f.exists()) {\n            // File does not exist in FS\n            mustUpdate = true;\n        } else if (f.lastModified() <= file.getDateLastModified()) {\n            // File in FS is older then file in VFS\n            mustUpdate = true;\n        } else if (req.isDoRecompile()) {\n            // Recompile is forced with parameter\n            mustUpdate = true;\n        }\n\n        String jspfilename = getJspUri(file.getAbsolutePath(), req.isOnline());               \n        \n        if (mustUpdate) {\n            if (DEBUG > 2) System.err.println(\"JspLoader writing new file: \" + jspfilename);         \n            byte[] contents = null;\n            String jspEncoding = null;\n            try {\n                contents = req.getCmsObject().readFile(file.getAbsolutePath()).getContents();\n                // Encoding project:\n                // Check the JSP \"content-encoding\" property\n                jspEncoding = cms.readProperty(file.getAbsolutePath(), I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, true);\n                if (jspEncoding == null) jspEncoding = C_DEFAULT_JSP_ENCODING;\n                jspEncoding = jspEncoding.trim().toLowerCase();\n            } catch (CmsException e) {\n                throw new ServletException(\"JspLoader: Could not read contents for file '\" + file.getAbsolutePath() + \"'\", e);\n            }\n            \n            try {\n                FileOutputStream fs = new FileOutputStream(f);                \n                // Encoding project:\n                // We need to use some encoding to convert bytes to String\n                // corectly. Internally a JSP will always be stored in the \n                // system default encoding since they are just a variation of\n                // the \"plain\" resource type.\n                String page = new String(contents, A_OpenCms.getDefaultEncoding());\n                StringBuffer buf = new StringBuffer(contents.length);\n\n                int p0 = 0, i2 = 0, slen = C_DIRECTIVE_START.length(), elen = C_DIRECTIVE_END.length();\n                // Check if any jsp name references occur in the file\n                int i1 = page.indexOf(C_DIRECTIVE_START);\n                while (i1 >= 0) {\n                    // Parse the file and replace jsp name references \n                    i2 = page.indexOf(C_DIRECTIVE_END, i1 + slen);\n                    if (i2 > i1) {\n                        String directive = page.substring(i1 + slen, i2);\n                        if (DEBUG > 2) System.err.println(\"JspLoader: Detected \" + C_DIRECTIVE_START + directive + C_DIRECTIVE_END);\n\n                        int t1=0, t2=0, t3=0, t4=0, t5=0, t6=slen, t7=0;\n                        while (directive.charAt(t1) == ' ') t1++;\n                        String filename = null;                        \n                        if (directive.startsWith(\"include\", t1)) {            \n                            if (DEBUG > 2) System.err.println(\"JspLoader: Detected 'include' directive!\");                            \n                            t2 = directive.indexOf(\"file\", t1 + 7);\n                            t5 = 6;\n                        } else if (directive.startsWith(\"page\", t1)) {\n                            if (DEBUG > 2) System.err.println(\"JspLoader: Detected 'page' directive!\");                            \n                            t2 = directive.indexOf(\"errorPage\", t1 + 4);\n                            t5 = 11;\n                        } else if (directive.startsWith(\"cms\", t1)) {\n                            if (DEBUG > 2) System.err.println(\"JspLoader: Detected 'cms' directive!\");                            \n                            t2 = directive.indexOf(\"file\", t1 + 3);\n                            t5 = 4; t6 = 0; t7 = elen; \n                        }\n                        \n                        if (t2 > 0) {\n                            String sub = directive.substring(t2 + t5); \n                            char c1 = sub.charAt(t3);\n                            while ((c1 == ' ') || (c1 == '=') || (c1 == '\"')) c1 = sub.charAt(++t3);\n                            t4 = t3;\n                            while (c1 != '\"') c1 = sub.charAt(++t4);\n                            if (t4 > t3) filename=sub.substring(t3,t4);\n                            if (DEBUG > 2) System.err.println(\"JspLoader: File given in directive is: \" + filename);                            \n                        }\n                        \n                        if (filename != null) {\n                            // a file was found, changes have to be made\n                            String pre = ((t7 == 0)?directive.substring(0,t2+t3+t5):\"\");                            ;\n                            String suf = ((t7 == 0)?directive.substring(t2+t3+t5+filename.length()):\"\");\n                            // Now try to update the referenced file \n                            String absolute = req.toAbsolute(filename);\n                            if (DEBUG > 2) System.err.println(\"JspLoader: Absolute location=\" + absolute);\n                            String jspname = null;\n                            try {\n                                // Make sure the jsp referenced file is generated\n                                CmsResource jsp = cms.readFileHeader(absolute);\n                                updateJsp(cms, jsp, req, updates);\n                                jspname = getJspUri(jsp.getAbsolutePath(), req.isOnline());\n                            } catch (Exception e) {\n                                jspname = null;\n                                if (DEBUG > 2) System.err.println(\"JspLoader: Error while creating jsp file \" + absolute + \"\\n\" + e);\n                            }\n                            if (jspname != null) {\n                                // Only change something in case no error had occured\n                                if (DEBUG > 2) System.err.println(\"JspLoader: Name of jsp file is \" + jspname);\n                                directive = pre + jspname + suf;\n                                if (DEBUG > 2) System.err.println(\"JspLoader: Changed directive to \" + C_DIRECTIVE_START + directive + C_DIRECTIVE_END);                                                     \n                            }\n                        }\n                        \n                        buf.append(page.substring(p0, i1 + t6));\n                        buf.append(directive);\n                        p0 = i2 + t7;\n                        i1 = page.indexOf(C_DIRECTIVE_START, p0);\n                    }\n                }\n                if (i2 > 0) {\n                    buf.append(page.substring(p0, page.length()));\n                    // Encoding project:\n                    // Now we are ready to store String data in file system.\n                    // To convert String to bytes we also need to provide\n                    // some encoding. The default (by the JSP standard) encoding \n                    // for JSP is ISO-8859-1.\n                    contents = buf.toString().getBytes(jspEncoding);\n                } else {\n                    // Encoding project:\n                    // Contents of original file where not modified,\n                    // just translate to the required JSP encoding (if necessary)\n                    String defaultEncoding = A_OpenCms.getDefaultEncoding().trim().toLowerCase();  \n                    if (! jspEncoding.equals(defaultEncoding)) {\n                        contents = (new String(contents, defaultEncoding)).getBytes(jspEncoding); \n                    }                    \n                }                                         \n                fs.write(contents);                \n                fs.close();\n                \n                if (I_CmsLogChannels.C_LOGGING && A_OpenCms.isLogging(I_CmsLogChannels.C_OPENCMS_INFO)) \n                    A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"Updated JSP file \\\"\" + jspfilename + \"\\\" for resource \\\"\" + file.getAbsolutePath() + \"\\\"\") ;\n            } catch (FileNotFoundException e) {\n                throw new ServletException(\"JspLauncher: Could not write to file '\" + f.getName() + \"'\\n\" + e, e);\n            }\n        }                      \n        return jspfilename;\n    }","id":9605,"modified_method":"/**\n     * Updates a JSP page in the \"real\" file system in case the VFS resource has changed.<p>\n     * \n     * Also processes the <code>&lt;%@ cms %&gt;<\/code> tags before the JSP is written to the real FS.\n     * Also recursivly updates all files that are referenced by a <code>&lt;%@ cms %&gt;<\/code> tag \n     * on this page to make sure the file actually exists in the real FS. \n     * All <code>&lt;%@ include %&gt;<\/code> tags are parsed and the name in the tag is translated\n     * from the OpenCms VFS path to the path in the real FS. \n     * The same is done for filenames in <code>&lt;%@ page errorPage=... %&gt;<\/code> tags.\n     * \n     * @param cms Used to access the OpenCms VFS\n     * @param file The reqested JSP file resource in the VFS\n     * @param req The current request\n     * @param res The current response\n     * @param updates A Set containing all JSP pages that have been already updated\n     * \n     * @return The file name of the updated JSP in the \"real\" FS\n     * \n     * @throws ServletException might be thrown in the process of including the JSP \n     * @throws IOException might be thrown in the process of including the JSP \n     */\n    private synchronized String updateJsp(CmsObject cms, CmsResource file, CmsFlexRequest req, Set updates) \n    throws IOException, ServletException {\n        \n        String jspTargetName = getJspName(file.getAbsolutePath());\n        String jspPath = getJspPath(jspTargetName, req.isOnline());\n        \n        File d = new File(jspPath).getParentFile();\n        if (! (d != null) && (d.exists() && d.isDirectory() && d.canRead())) {\n            if (I_CmsLogChannels.C_LOGGING && A_OpenCms.isLogging(I_CmsLogChannels.C_OPENCMS_CRITICAL)) \n                A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_CRITICAL, \"Could not access directory for \" + jspPath);\n            throw new ServletException(\"JspLoader: Could not access directory for \" + jspPath);\n        }    \n        \n        if (updates.contains(jspTargetName)) return null;\n        updates.add(jspTargetName);\n        \n        boolean mustUpdate = false;\n        \n        File f = new File(jspPath);        \n        if (!f.exists()) {\n            // File does not exist in FS\n            mustUpdate = true;\n        } else if (f.lastModified() <= file.getDateLastModified()) {\n            // File in FS is older then file in VFS\n            mustUpdate = true;\n        } else if (req.isDoRecompile()) {\n            // Recompile is forced with parameter\n            mustUpdate = true;\n        }\n\n        String jspfilename = getJspUri(file.getAbsolutePath(), req.isOnline());               \n        \n        if (mustUpdate) {\n            if (DEBUG > 2) System.err.println(\"JspLoader writing new file: \" + jspfilename);         \n            byte[] contents = null;\n            String jspEncoding = null;\n            try {\n                contents = req.getCmsObject().readFile(file.getAbsolutePath()).getContents();\n                // Encoding project:\n                // Check the JSP \"content-encoding\" property\n                jspEncoding = cms.readProperty(file.getAbsolutePath(), I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, true);\n                if (jspEncoding == null) jspEncoding = C_DEFAULT_JSP_ENCODING;\n                jspEncoding = jspEncoding.trim().toLowerCase();\n            } catch (CmsException e) {\n                throw new ServletException(\"JspLoader: Could not read contents for file '\" + file.getAbsolutePath() + \"'\", e);\n            }\n            \n            try {\n                FileOutputStream fs = new FileOutputStream(f);                \n                // Encoding project:\n                // We need to use some encoding to convert bytes to String\n                // corectly. Internally a JSP will always be stored in the \n                // system default encoding since they are just a variation of\n                // the \"plain\" resource type.\n                String page = new String(contents, A_OpenCms.getDefaultEncoding());\n                StringBuffer buf = new StringBuffer(contents.length);\n\n                int p0 = 0, i2 = 0, slen = C_DIRECTIVE_START.length(), elen = C_DIRECTIVE_END.length();\n                // Check if any jsp name references occur in the file\n                int i1 = page.indexOf(C_DIRECTIVE_START);\n                while (i1 >= 0) {\n                    // Parse the file and replace jsp name references \n                    i2 = page.indexOf(C_DIRECTIVE_END, i1 + slen);\n                    if (i2 > i1) {\n                        String directive = page.substring(i1 + slen, i2);\n                        if (DEBUG > 2) System.err.println(\"JspLoader: Detected \" + C_DIRECTIVE_START + directive + C_DIRECTIVE_END);\n\n                        int t1=0, t2=0, t3=0, t4=0, t5=0, t6=slen, t7=0;\n                        while (directive.charAt(t1) == ' ') t1++;\n                        String filename = null;                        \n                        if (directive.startsWith(\"include\", t1)) {            \n                            if (DEBUG > 2) System.err.println(\"JspLoader: Detected 'include' directive!\");                            \n                            t2 = directive.indexOf(\"file\", t1 + 7);\n                            t5 = 6;\n                        } else if (directive.startsWith(\"page\", t1)) {\n                            if (DEBUG > 2) System.err.println(\"JspLoader: Detected 'page' directive!\");                            \n                            t2 = directive.indexOf(\"errorPage\", t1 + 4);\n                            t5 = 11;\n                        } else if (directive.startsWith(\"cms\", t1)) {\n                            if (DEBUG > 2) System.err.println(\"JspLoader: Detected 'cms' directive!\");                            \n                            t2 = directive.indexOf(\"file\", t1 + 3);\n                            t5 = 4; t6 = 0; t7 = elen; \n                        }\n                        \n                        if (t2 > 0) {\n                            String sub = directive.substring(t2 + t5); \n                            char c1 = sub.charAt(t3);\n                            while ((c1 == ' ') || (c1 == '=') || (c1 == '\"')) c1 = sub.charAt(++t3);\n                            t4 = t3;\n                            while (c1 != '\"') c1 = sub.charAt(++t4);\n                            if (t4 > t3) filename=sub.substring(t3,t4);\n                            if (DEBUG > 2) System.err.println(\"JspLoader: File given in directive is: \" + filename);                            \n                        }\n                        \n                        if (filename != null) {\n                            // a file was found, changes have to be made\n                            String pre = ((t7 == 0)?directive.substring(0,t2+t3+t5):\"\");                            ;\n                            String suf = ((t7 == 0)?directive.substring(t2+t3+t5+filename.length()):\"\");\n                            // Now try to update the referenced file \n                            String absolute = req.toAbsolute(filename);\n                            if (DEBUG > 2) System.err.println(\"JspLoader: Absolute location=\" + absolute);\n                            String jspname = null;\n                            try {\n                                // Make sure the jsp referenced file is generated\n                                CmsResource jsp = cms.readFileHeader(absolute);\n                                updateJsp(cms, jsp, req, updates);\n                                jspname = getJspUri(jsp.getAbsolutePath(), req.isOnline());\n                            } catch (Exception e) {\n                                jspname = null;\n                                if (DEBUG > 2) System.err.println(\"JspLoader: Error while creating jsp file \" + absolute + \"\\n\" + e);\n                            }\n                            if (jspname != null) {\n                                // Only change something in case no error had occured\n                                if (DEBUG > 2) System.err.println(\"JspLoader: Name of jsp file is \" + jspname);\n                                directive = pre + jspname + suf;\n                                if (DEBUG > 2) System.err.println(\"JspLoader: Changed directive to \" + C_DIRECTIVE_START + directive + C_DIRECTIVE_END);                                                     \n                            }\n                        }\n                        \n                        buf.append(page.substring(p0, i1 + t6));\n                        buf.append(directive);\n                        p0 = i2 + t7;\n                        i1 = page.indexOf(C_DIRECTIVE_START, p0);\n                    }\n                }\n                if (i2 > 0) {\n                    buf.append(page.substring(p0, page.length()));\n                    // Encoding project:\n                    // Now we are ready to store String data in file system.\n                    // To convert String to bytes we also need to provide\n                    // some encoding. The default (by the JSP standard) encoding \n                    // for JSP is ISO-8859-1.\n                    contents = buf.toString().getBytes(jspEncoding);\n                } else {\n                    // Encoding project:\n                    // Contents of original file where not modified,\n                    // just translate to the required JSP encoding (if necessary)\n                    contents = Encoder.changeEncoding(contents, A_OpenCms.getDefaultEncoding(), jspEncoding);                    \n                }                                         \n                fs.write(contents);                \n                fs.close();\n                \n                if (I_CmsLogChannels.C_LOGGING && A_OpenCms.isLogging(I_CmsLogChannels.C_OPENCMS_INFO)) \n                    A_OpenCms.log(I_CmsLogChannels.C_OPENCMS_INFO, \"Updated JSP file \\\"\" + jspfilename + \"\\\" for resource \\\"\" + file.getAbsolutePath() + \"\\\"\") ;\n            } catch (FileNotFoundException e) {\n                throw new ServletException(\"JspLauncher: Could not write to file '\" + f.getName() + \"'\\n\" + e, e);\n            }\n        }                      \n        return jspfilename;\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Method to enable JSPs to be used as sub-elements in XMLTemplates.\n     *\n     * @param cms The initialized CmsObject which provides user permissions\n     * @param file The requested OpenCms VFS resource\n     * \n     * @throws CmsException In case the Loader can not process the requested resource\n     * \n     * @see CmsJspTemplate\n     */\n    public byte[] loadTemplate(CmsObject cms, CmsFile file) \n    throws CmsException {\n\n        byte[] result = null;\n        \n        long timer1 = 0;\n        if (DEBUG > 0) {\n            timer1 = System.currentTimeMillis();        \n            System.err.println(\"========== JspLoader (Template) loading: \" + file.getAbsolutePath());\n        }       \n\n        if (cms.getRequestContext().getRequest() instanceof com.opencms.core.CmsExportRequest) {\n            if (DEBUG > 1) System.err.println(\"FlexJspLoader.loadTemplate(): Export requested for \" + file.getAbsolutePath());\n            // export the JSP\n            result = exportJsp(cms, file);\n        } else {\n            HttpServletRequest req = (HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest();\n            HttpServletResponse res = (HttpServletResponse)cms.getRequestContext().getResponse().getOriginalResponse();             \n            \n            CmsFlexRequest w_req; \n            CmsFlexResponse w_res;\n            if (req instanceof CmsFlexRequest) {\n                w_req = (CmsFlexRequest)req; \n            } else {\n                w_req = new CmsFlexRequest(req, file, m_cache, cms); \n            }        \n            if (res instanceof CmsFlexResponse) {\n                w_res = (CmsFlexResponse)res;              \n            } else {\n                w_res = new CmsFlexResponse(res, false, false, cms.getRequestContext().getEncoding());\n            }\n            \n            try {\n                w_req.getCmsRequestDispatcher(file.getAbsolutePath()).include(w_req, w_res);\n            } catch (java.net.SocketException e) {        \n                // Uncritical, might happen if client (browser) does not wait until end of page delivery\n                if (DEBUG > 1) System.err.println(\"JspLoader.loadTemplate() ignoring SocketException \" + e);\n            } catch (Exception e) {            \n                System.err.println(\"Error in CmsJspLoader.loadTemplate() while loading: \" + e.toString());\n                if (DEBUG > 0) System.err.println(com.opencms.util.Utils.getStackTrace(e));\n                throw new CmsException(\"Error in CmsJspLoader.loadTemplate() while loading \" + file.getAbsolutePath() + \"\\n\" + e, CmsException.C_LAUNCH_ERROR, e);\n            } \n    \n            if (! w_res.isSuspended()) {\n                try {      \n                    if ((res == null) || (! res.isCommitted())) {\n                        // If a JSP errorpage was triggered the response will be already committed here\n                        result = w_res.getWriterBytes();                                                \n                        // Encoding project:\n                        // The byte array will internally be encoded in the OpenCms\n                        // default encoding. In case another encoding is set\n                        // in the 'content-encoding' property of the file,\n                        // we need to re-encode the output here.\n                        String dnc = A_OpenCms.getDefaultEncoding().trim().toLowerCase();\n                        String enc = cms.getRequestContext().getEncoding().trim().toLowerCase();\n                        if (! dnc.equals(enc)) {\n                            if (DEBUG > 1) System.err.println(\"CmsJspLoader.loadTemplate(): Encoding result from \" + dnc + \" to \" + enc);\n                            result = (new String(result, dnc)).getBytes(enc);\n                        }                                                \n                    }\n                } catch (IllegalStateException e) {\n                    // Uncritical, might happen if JSP error page was used\n                    if (DEBUG > 1) System.err.println(\"JspLoader.loadTemplate() ignoring IllegalStateException \" + e);\n                } catch (Exception e) {\n                    System.err.println(\"Error in CmsJspLoader.loadTemplate() while writing buffer to final stream: \" + e.toString());\n                    if (DEBUG > 0) System.err.println(com.opencms.util.Utils.getStackTrace(e));\n                    throw new CmsException(\"Error in CmsJspLoader.loadTemplate() while writing buffer to final stream for \" + file.getAbsolutePath() + \"\\n\" + e, CmsException.C_LAUNCH_ERROR, e);\n                }        \n            }\n        }\n        \n        if (DEBUG > 0) {\n            long timer2 = System.currentTimeMillis() - timer1;\n            System.err.println(\"========== JspLoader (Template) time delivering JSP for \" + file.getAbsolutePath() + \": \" + timer2 + \"ms\");\n        }        \n        \n        return result;\n    }","id":9606,"modified_method":"/**\n     * Method to enable JSPs to be used as sub-elements in XMLTemplates.\n     *\n     * @param cms The initialized CmsObject which provides user permissions\n     * @param file The requested OpenCms VFS resource\n     * \n     * @throws CmsException In case the Loader can not process the requested resource\n     * \n     * @see CmsJspTemplate\n     */\n    public byte[] loadTemplate(CmsObject cms, CmsFile file) \n    throws CmsException {\n\n        byte[] result = null;\n        \n        long timer1 = 0;\n        if (DEBUG > 0) {\n            timer1 = System.currentTimeMillis();        \n            System.err.println(\"========== JspLoader (Template) loading: \" + file.getAbsolutePath());\n        }       \n\n        if (cms.getRequestContext().getRequest() instanceof com.opencms.core.CmsExportRequest) {\n            if (DEBUG > 1) System.err.println(\"FlexJspLoader.loadTemplate(): Export requested for \" + file.getAbsolutePath());\n            // export the JSP\n            result = exportJsp(cms, file);\n        } else {\n            HttpServletRequest req = (HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest();\n            HttpServletResponse res = (HttpServletResponse)cms.getRequestContext().getResponse().getOriginalResponse();             \n            \n            CmsFlexRequest w_req; \n            CmsFlexResponse w_res;\n            if (req instanceof CmsFlexRequest) {\n                w_req = (CmsFlexRequest)req; \n            } else {\n                w_req = new CmsFlexRequest(req, file, m_cache, cms); \n            }        \n            if (res instanceof CmsFlexResponse) {\n                w_res = (CmsFlexResponse)res;              \n            } else {\n                w_res = new CmsFlexResponse(res, false, false, cms.getRequestContext().getEncoding());\n            }\n            \n            try {\n                w_req.getCmsRequestDispatcher(file.getAbsolutePath()).include(w_req, w_res);\n            } catch (java.net.SocketException e) {        \n                // Uncritical, might happen if client (browser) does not wait until end of page delivery\n                if (DEBUG > 1) System.err.println(\"JspLoader.loadTemplate() ignoring SocketException \" + e);\n            } catch (Exception e) {            \n                System.err.println(\"Error in CmsJspLoader.loadTemplate() while loading: \" + e.toString());\n                if (DEBUG > 0) System.err.println(com.opencms.util.Utils.getStackTrace(e));\n                throw new CmsException(\"Error in CmsJspLoader.loadTemplate() while loading \" + file.getAbsolutePath() + \"\\n\" + e, CmsException.C_LAUNCH_ERROR, e);\n            } \n    \n            if (! w_res.isSuspended()) {\n                try {      \n                    if ((res == null) || (! res.isCommitted())) {\n                        // If a JSP errorpage was triggered the response will be already committed here\n                        result = w_res.getWriterBytes();                                                \n                        // Encoding project:\n                        // The byte array will internally be encoded in the OpenCms\n                        // default encoding. In case another encoding is set\n                        // in the 'content-encoding' property of the file,\n                        // we need to re-encode the output here\n                        result = Encoder.changeEncoding(result, A_OpenCms.getDefaultEncoding(), cms.getRequestContext().getEncoding());                                              \n                    }\n                } catch (IllegalStateException e) {\n                    // Uncritical, might happen if JSP error page was used\n                    if (DEBUG > 1) System.err.println(\"JspLoader.loadTemplate() ignoring IllegalStateException \" + e);\n                } catch (Exception e) {\n                    System.err.println(\"Error in CmsJspLoader.loadTemplate() while writing buffer to final stream: \" + e.toString());\n                    if (DEBUG > 0) System.err.println(com.opencms.util.Utils.getStackTrace(e));\n                    throw new CmsException(\"Error in CmsJspLoader.loadTemplate() while writing buffer to final stream for \" + file.getAbsolutePath() + \"\\n\" + e, CmsException.C_LAUNCH_ERROR, e);\n                }        \n            }\n        }\n        \n        if (DEBUG > 0) {\n            long timer2 = System.currentTimeMillis() - timer1;\n            System.err.println(\"========== JspLoader (Template) time delivering JSP for \" + file.getAbsolutePath() + \": \" + timer2 + \"ms\");\n        }        \n        \n        return result;\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Basic top-page processing method for this I_CmsResourceLoader,\n     * this method is called by <code>initlaunch()<\/code> if a JSP is requested and\n     * the original request was from the launcher manager.\n     *\n     * @param cms The initialized CmsObject which provides user permissions\n     * @param file The requested OpenCms VFS resource\n     * @param req The original servlet request\n     * @param res The original servlet response\n     * \n     * @throws ServletException might be thrown in the process of including the JSP \n     * @throws IOException might be thrown in the process of including the JSP \n     * \n     * @see I_CmsResourceLoader\n     * @see #initlaunch(CmsObject cms, CmsFile file, String startTemplateClass, A_OpenCms openCms)\n     */\n    public void load(CmsObject cms, CmsFile file, HttpServletRequest req, HttpServletResponse res) \n    throws ServletException, IOException {       \n\n        long timer1 = 0;\n        if (DEBUG > 0) {\n            timer1 = System.currentTimeMillis();        \n            System.err.println(\"========== JspLoader loading: \" + file.getAbsolutePath());\n        }\n\n        boolean streaming = false;            \n        boolean bypass = false;\n        \n        // check if export mode is active, if so \"streaming\" must be deactivated\n        boolean exportmode = (cms.getMode() == CmsObject.C_MODUS_EXPORT);\n        \n        try {\n            // Read caching property from requested VFS resource                                     \n            String stream = cms.readProperty(file.getAbsolutePath(), I_CmsResourceLoader.C_LOADER_STREAMPROPERTY);                    \n            if (stream != null) {\n                if (\"yes\".equalsIgnoreCase(stream) || \"true\".equalsIgnoreCase(stream)) {\n                    // streaming not allowed in export mode\n                    streaming = !exportmode;                \n                } else if (\"bypass\".equalsIgnoreCase(stream) || \"bypasscache\".equalsIgnoreCase(stream)) {\n                    // bypass not allowed in export mode\n                    bypass = !exportmode;\n                }\n            }\n        } catch (CmsException e) {\n            throw new ServletException(\"FlexJspLoader: Error while loading stream properties for \" + file.getAbsolutePath() + \"\\n\" + e, e);\n        } \n        \n        if (DEBUG > 1) System.err.println(\"========== JspLoader stream=\" + streaming + \" bypass=\" + bypass);\n        \n        CmsFlexRequest w_req; \n        CmsFlexResponse w_res;\n        if (req instanceof CmsFlexRequest) {\n            w_req = (CmsFlexRequest)req; \n        } else {\n            w_req = new CmsFlexRequest(req, file, m_cache, cms); \n        }        \n        if (res instanceof CmsFlexResponse) {\n            w_res = (CmsFlexResponse)res;              \n        } else {\n            w_res = new CmsFlexResponse(res, streaming, true, cms.getRequestContext().getEncoding());\n        }\n        \n        if (bypass) {\n            // Bypass Flex cache for this page (this solves some compatibility issues in BEA Weblogic)        \n            if (DEBUG > 1) System.err.println(\"JspLoader.load() bypassing cache for file \" + file.getAbsolutePath());\n            // Update the JSP first if neccessary            \n            String target = updateJsp(cms, file, w_req, new HashSet(11));\n            // Dispatch to external JSP\n            req.getRequestDispatcher(target).forward(w_req, res);              \n            if (DEBUG > 1) System.err.println(\"JspLoader.load() cache was bypassed!\");\n        } else {\n            // Flex cache not bypassed            \n            try {\n                w_req.getCmsRequestDispatcher(file.getAbsolutePath()).include(w_req, w_res);\n            } catch (java.net.SocketException e) {        \n                // Uncritical, might happen if client (browser) does not wait until end of page delivery\n                if (DEBUG > 1) System.err.println(\"JspLoader.load() ignoring SocketException \" + e);\n            }            \n            if (! streaming && ! w_res.isSuspended()) {\n                try {      \n                    if (! res.isCommitted() || m_errorPagesAreNotCommited) {\n                        // If a JSP errorpage was triggered the response will be already committed here\n                        byte[] result = w_res.getWriterBytes();\n                        \n                        // Encoding project:  \n                        // The byte array will internally be encoded in the OpenCms \n                        // default encoding. In case another encoding is set \n                        // in the 'content-encoding' property of the file, \n                        // we need to re-encode the output here. \n                        String dnc = A_OpenCms.getDefaultEncoding().trim().toLowerCase();  \n                        String enc = cms.getRequestContext().getEncoding().trim().toLowerCase();\n                        if (! dnc.equals(enc)) {\n                            if (DEBUG > 1) System.err.println(\"CmsJspLoader.load(): Encoding result from \" + dnc + \" to \" + enc);\n                            result = (new String(result, dnc)).getBytes(enc);                            \n                        }\n                                                                                                                              \n                        // Check for export request links \n                        if (exportmode) {\n                            exportSetLinkHeader(cms, w_res);\n                        }\n                              \n                        // Process headers and write output                                          \n                        res.setContentLength(result.length);\n                        CmsFlexResponse.processHeaders(w_res.getHeaders(), res);                        \n                        res.getOutputStream().write(result);\n                        res.getOutputStream().flush();\n                    } else if (DEBUG > 1) {\n                        System.err.println(\"JspLoader.load() resource is already commited!\");\n                    }\n                } catch (IllegalStateException e) {\n                    // Uncritical, might happen if JSP error page was used\n                    if (DEBUG > 1) System.err.println(\"JspLoader.load() ignoring IllegalStateException \" + e);\n                } catch (java.net.SocketException e) {        \n                    // Uncritical, might happen if client (browser) does not wait until end of page delivery\n                    if (DEBUG > 1) System.err.println(\"JspLoader.load() ignoring SocketException \" + e);\n                }       \n            }\n        }\n        \n        if (DEBUG > 0) {\n            long timer2 = System.currentTimeMillis() - timer1;\n            System.err.println(\"========== JspLoader time delivering JSP for \" + file.getAbsolutePath() + \": \" + timer2 + \"ms\");\n        }        \n    }","id":9607,"modified_method":"/**\n     * Basic top-page processing method for this I_CmsResourceLoader,\n     * this method is called by <code>initlaunch()<\/code> if a JSP is requested and\n     * the original request was from the launcher manager.\n     *\n     * @param cms The initialized CmsObject which provides user permissions\n     * @param file The requested OpenCms VFS resource\n     * @param req The original servlet request\n     * @param res The original servlet response\n     * \n     * @throws ServletException might be thrown in the process of including the JSP \n     * @throws IOException might be thrown in the process of including the JSP \n     * \n     * @see I_CmsResourceLoader\n     * @see #initlaunch(CmsObject cms, CmsFile file, String startTemplateClass, A_OpenCms openCms)\n     */\n    public void load(CmsObject cms, CmsFile file, HttpServletRequest req, HttpServletResponse res) \n    throws ServletException, IOException {       \n\n        long timer1 = 0;\n        if (DEBUG > 0) {\n            timer1 = System.currentTimeMillis();        \n            System.err.println(\"========== JspLoader loading: \" + file.getAbsolutePath());\n        }\n\n        boolean streaming = false;            \n        boolean bypass = false;\n        \n        // check if export mode is active, if so \"streaming\" must be deactivated\n        boolean exportmode = (cms.getMode() == CmsObject.C_MODUS_EXPORT);\n        \n        try {\n            // Read caching property from requested VFS resource                                     \n            String stream = cms.readProperty(file.getAbsolutePath(), I_CmsResourceLoader.C_LOADER_STREAMPROPERTY);                    \n            if (stream != null) {\n                if (\"yes\".equalsIgnoreCase(stream) || \"true\".equalsIgnoreCase(stream)) {\n                    // streaming not allowed in export mode\n                    streaming = !exportmode;                \n                } else if (\"bypass\".equalsIgnoreCase(stream) || \"bypasscache\".equalsIgnoreCase(stream)) {\n                    // bypass not allowed in export mode\n                    bypass = !exportmode;\n                }\n            }\n        } catch (CmsException e) {\n            throw new ServletException(\"FlexJspLoader: Error while loading stream properties for \" + file.getAbsolutePath() + \"\\n\" + e, e);\n        } \n        \n        if (DEBUG > 1) System.err.println(\"========== JspLoader stream=\" + streaming + \" bypass=\" + bypass);\n        \n        CmsFlexRequest w_req; \n        CmsFlexResponse w_res;\n        if (req instanceof CmsFlexRequest) {\n            w_req = (CmsFlexRequest)req; \n        } else {\n            w_req = new CmsFlexRequest(req, file, m_cache, cms); \n        }        \n        if (res instanceof CmsFlexResponse) {\n            w_res = (CmsFlexResponse)res;              \n        } else {\n            w_res = new CmsFlexResponse(res, streaming, true, cms.getRequestContext().getEncoding());\n        }\n        \n        if (bypass) {\n            // Bypass Flex cache for this page (this solves some compatibility issues in BEA Weblogic)        \n            if (DEBUG > 1) System.err.println(\"JspLoader.load() bypassing cache for file \" + file.getAbsolutePath());\n            // Update the JSP first if neccessary            \n            String target = updateJsp(cms, file, w_req, new HashSet(11));\n            // Dispatch to external JSP\n            req.getRequestDispatcher(target).forward(w_req, res);              \n            if (DEBUG > 1) System.err.println(\"JspLoader.load() cache was bypassed!\");\n        } else {\n            // Flex cache not bypassed            \n            try {\n                w_req.getCmsRequestDispatcher(file.getAbsolutePath()).include(w_req, w_res);\n            } catch (java.net.SocketException e) {        \n                // Uncritical, might happen if client (browser) does not wait until end of page delivery\n                if (DEBUG > 1) System.err.println(\"JspLoader.load() ignoring SocketException \" + e);\n            }            \n            if (! streaming && ! w_res.isSuspended()) {\n                try {      \n                    if (! res.isCommitted() || m_errorPagesAreNotCommited) {\n                        // If a JSP errorpage was triggered the response will be already committed here\n                        byte[] result = w_res.getWriterBytes();\n                        \n                        // Encoding project:  \n                        // The byte array will internally be encoded in the OpenCms \n                        // default encoding. In case another encoding is set \n                        // in the 'content-encoding' property of the file, \n                        // we need to re-encode the output here. \n                        result = Encoder.changeEncoding(result, A_OpenCms.getDefaultEncoding(), cms.getRequestContext().getEncoding());   \n                                                                                                                              \n                        // Check for export request links \n                        if (exportmode) {\n                            exportSetLinkHeader(cms, w_res);\n                        }\n                              \n                        // Process headers and write output                                          \n                        res.setContentLength(result.length);\n                        CmsFlexResponse.processHeaders(w_res.getHeaders(), res);                        \n                        res.getOutputStream().write(result);\n                        res.getOutputStream().flush();\n                    } else if (DEBUG > 1) {\n                        System.err.println(\"JspLoader.load() resource is already commited!\");\n                    }\n                } catch (IllegalStateException e) {\n                    // Uncritical, might happen if JSP error page was used\n                    if (DEBUG > 1) System.err.println(\"JspLoader.load() ignoring IllegalStateException \" + e);\n                } catch (java.net.SocketException e) {        \n                    // Uncritical, might happen if client (browser) does not wait until end of page delivery\n                    if (DEBUG > 1) System.err.println(\"JspLoader.load() ignoring SocketException \" + e);\n                }       \n            }\n        }\n        \n        if (DEBUG > 0) {\n            long timer2 = System.currentTimeMillis() - timer1;\n            System.err.println(\"========== JspLoader time delivering JSP for \" + file.getAbsolutePath() + \": \" + timer2 + \"ms\");\n        }        \n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Perform an export of the requested JSP page.<p>\n     * \n     * The export of a JSP is done in the following way:\n     * <ul>\n     * <li>A HttpURLConnection is openend to the address configured in the runtime property with\n     * the name {@link #C_LOADER_JSPEXPORTURL}, which usually should be the current OpenCms server.\n     * <li>The URI of the <code>file<\/code> is appended to the connection as path information, so\n     * this will be the page requested and exported.\n     * <li>All current request parameters are encoded and also added to the request as parameters.\n     * <li>The currently requested URI is also appended as value of the special parameter {@link\n     * #C_EXPORT_PARAM}.\n     * <li>When processing this special request, the mode of the <code>CmsObject<\/code> will be\n     * set to <code>C_MODUS_EXPORT<\/code>, which is the required mode if you want to generate\n     * the result for an export.\n     * <li>All links found while processing the exported JSP will be written in a special header\n     * of the response, called {@link #C_EXPORT_HEADER}.\n     * <li>The response result will be checked for the headers and all links found will be added to\n     * the link vector of the currently processed page.\n     * <li>The content of the resonse will be read into a byte array and returned as result of this\n     * call.\n     * <\/ul>\n     *  \n     * @param cms provides the current cms context\n     * @param file the JSP file requested\n     * @return the contents of the JSP page for the export\n     */\n    private byte[] exportJsp(CmsObject cms, CmsFile file) throws CmsException {\n        \n        // check if we are properly initialized\n        if (m_jspExportUrl == null) {\n            throw new CmsException(\"JSP export URL not set, can not export JSP\", CmsException.C_FLEX_LOADER);\n        }\n        \n        ByteArrayOutputStream bytes = null;        \n        CmsRequestContext context = cms.getRequestContext();\n        \n        // generate export URL\n        StringBuffer exportUrl = new StringBuffer(m_jspExportUrl); \n        exportUrl.append(file.getAbsolutePath());\n        exportUrl.append(\"?\");\n        \n        // add parameters to export call\n        Enumeration params = context.getRequest().getParameterNames();\n        while (params.hasMoreElements()) {\n            String key = (String)params.nextElement();\n            String values[] = (String[])context.getRequest().getParameterValues(key);\n            for (int i=0; i<values.length; i++) {\n                exportUrl.append(key);\n                exportUrl.append(\"=\");\n                exportUrl.append(Encoder.encode(values[i], \"UTF-8\", true));\n                exportUrl.append(\"&\");\n            }\n        }\n        // add the export parameter to the request\n        exportUrl.append(C_EXPORT_PARAM);\n        exportUrl.append(\"=\");\n        exportUrl.append(cms.getRequestContext().getUri());\n        // add the original requested body file to the request\n        String body = (String)cms.getRequestContext().getAttribute(I_CmsConstants.C_XML_BODY_ELEMENT);\n        if (body != null) {\n            exportUrl.append(\"&\");\n            exportUrl.append(C_EXPORT_BODY);\n            exportUrl.append(\"=\");\n            exportUrl.append(Encoder.encode(body, \"UTF-8\", true));            \n        }\n        // add the encoding used for the output page to the request\n        String encoding = cms.getRequestContext().getEncoding();\n        exportUrl.append(\"&\");\n        exportUrl.append(C_EXPORT_ENCODING);\n        exportUrl.append(\"=\");\n        exportUrl.append(Encoder.encode(encoding, \"UTF-8\", true));        \n        \n        if (DEBUG > 2) System.err.println(\"CmsJspLoader.exportJsp(): JSP export URL is \" + exportUrl);\n\n        // perform the export with an URLConnection\n        URL export;\n        HttpURLConnection urlcon;\n        DataInputStream input;\n                \n        try {\n            export = new URL(new String(exportUrl));\n            urlcon = (HttpURLConnection) export.openConnection();\n            // set request type to POST\n            urlcon.setRequestMethod(\"POST\");\n            HttpURLConnection.setFollowRedirects(false);\n            // input and output stream\n            input = new DataInputStream(urlcon.getInputStream());\n            bytes = new ByteArrayOutputStream(urlcon.getContentLength()>0?urlcon.getContentLength():1024);\n        } catch (Exception e) {\n            // all exceptions here will be IO related\n            throw new CmsException(\"IO related error while exporting JSP for URI \" + cms.getRequestContext().getUri(), \n                CmsException.C_FLEX_LOADER, e);\n        }\n        \n        // check if links are present in the exported page \n        String cmslinks = urlcon.getHeaderField(C_EXPORT_HEADER);\n        if (cmslinks != null) {\n            // add all the links to the current cms context\n            StringTokenizer tok = new StringTokenizer(cmslinks, C_EXPORT_HEADER_SEP);\n            while (tok.hasMoreTokens()) {\n                String link = Encoder.decode(tok.nextToken(), \"UFT-8\", true);\n                cms.getRequestContext().addLink(link);\n                if (DEBUG > 3) System.err.println(\"CmsJspLoader.exportJsp(): Extracted link \" + link);\n            }\n        }\n        // now read the page content and write it to the byte array\n        try {\n            int b;\n            while ((b = input.read()) > 0) {\n                bytes.write(b);\n            }\n        } catch (IOException e) {\n            throw new CmsException(\"IO error writing bytes to buffer exporting JSP for URI \" + cms.getRequestContext().getUri(),\n                CmsException.C_FLEX_LOADER, e);            \n        }\n\n        return bytes.toByteArray();\n    }","id":9608,"modified_method":"/**\n     * Perform an export of the requested JSP page.<p>\n     * \n     * The export of a JSP is done in the following way:\n     * <ul>\n     * <li>A HttpURLConnection is openend to the address configured in the runtime property with\n     * the name {@link #C_LOADER_JSPEXPORTURL}, which usually should be the current OpenCms server.\n     * <li>The URI of the <code>file<\/code> is appended to the connection as path information, so\n     * this will be the page requested and exported.\n     * <li>All current request parameters are encoded and also added to the request as parameters.\n     * <li>The currently requested URI is also appended as value of the special parameter {@link\n     * #C_EXPORT_PARAM}.\n     * <li>When processing this special request, the mode of the <code>CmsObject<\/code> will be\n     * set to <code>C_MODUS_EXPORT<\/code>, which is the required mode if you want to generate\n     * the result for an export.\n     * <li>All links found while processing the exported JSP will be written in a special header\n     * of the response, called {@link #C_EXPORT_HEADER}.\n     * <li>The response result will be checked for the headers and all links found will be added to\n     * the link vector of the currently processed page.\n     * <li>The content of the resonse will be read into a byte array and returned as result of this\n     * call.\n     * <\/ul>\n     *  \n     * @param cms provides the current cms context\n     * @param file the JSP file requested\n     * @return the contents of the JSP page for the export\n     */\n    private byte[] exportJsp(CmsObject cms, CmsFile file) throws CmsException {\n        \n        // check if we are properly initialized\n        if (m_jspExportUrl == null) {\n            throw new CmsException(\"JSP export URL not set, can not export JSP\", CmsException.C_FLEX_LOADER);\n        }\n        \n        ByteArrayOutputStream bytes = null;        \n        CmsRequestContext context = cms.getRequestContext();\n        \n        // generate export URL\n        StringBuffer exportUrl = new StringBuffer(m_jspExportUrl); \n        exportUrl.append(file.getAbsolutePath());\n        exportUrl.append(\"?\");\n        \n        // add parameters to export call\n        Enumeration params = context.getRequest().getParameterNames();\n        while (params.hasMoreElements()) {\n            String key = (String)params.nextElement();\n            String values[] = (String[])context.getRequest().getParameterValues(key);\n            for (int i=0; i<values.length; i++) {\n                exportUrl.append(key);\n                exportUrl.append(\"=\");\n                exportUrl.append(Encoder.encode(values[i]));\n                exportUrl.append(\"&\");\n            }\n        }\n        // add the export parameter to the request\n        exportUrl.append(C_EXPORT_PARAM);\n        exportUrl.append(\"=\");\n        exportUrl.append(cms.getRequestContext().getUri());\n        // add the original requested body file to the request\n        String body = (String)cms.getRequestContext().getAttribute(I_CmsConstants.C_XML_BODY_ELEMENT);\n        if (body != null) {\n            exportUrl.append(\"&\");\n            exportUrl.append(C_EXPORT_BODY);\n            exportUrl.append(\"=\");\n            exportUrl.append(Encoder.encode(body));            \n        }\n        // add the encoding used for the output page to the request\n        String encoding = cms.getRequestContext().getEncoding();\n        exportUrl.append(\"&\");\n        exportUrl.append(C_EXPORT_ENCODING);\n        exportUrl.append(\"=\");\n        exportUrl.append(Encoder.encode(encoding));        \n        \n        if (DEBUG > 2) System.err.println(\"CmsJspLoader.exportJsp(): JSP export URL is \" + exportUrl);\n\n        // perform the export with an URLConnection\n        URL export;\n        HttpURLConnection urlcon;\n        DataInputStream input;\n                \n        try {\n            export = new URL(new String(exportUrl));\n            urlcon = (HttpURLConnection) export.openConnection();\n            // set request type to POST\n            urlcon.setRequestMethod(\"POST\");\n            HttpURLConnection.setFollowRedirects(false);\n            // input and output stream\n            input = new DataInputStream(urlcon.getInputStream());\n            bytes = new ByteArrayOutputStream(urlcon.getContentLength()>0?urlcon.getContentLength():1024);\n        } catch (Exception e) {\n            // all exceptions here will be IO related\n            throw new CmsException(\"IO related error while exporting JSP for URI \" + cms.getRequestContext().getUri(), \n                CmsException.C_FLEX_LOADER, e);\n        }\n        \n        // check if links are present in the exported page \n        String cmslinks = urlcon.getHeaderField(C_EXPORT_HEADER);\n        if (cmslinks != null) {\n            // add all the links to the current cms context\n            StringTokenizer tok = new StringTokenizer(cmslinks, C_EXPORT_HEADER_SEP);\n            while (tok.hasMoreTokens()) {\n                String link = Encoder.decode(tok.nextToken(), \"UFT-8\", true);\n                cms.getRequestContext().addLink(link);\n                if (DEBUG > 3) System.err.println(\"CmsJspLoader.exportJsp(): Extracted link \" + link);\n            }\n        }\n        // now read the page content and write it to the byte array\n        try {\n            int b;\n            while ((b = input.read()) > 0) {\n                bytes.write(b);\n            }\n        } catch (IOException e) {\n            throw new CmsException(\"IO error writing bytes to buffer exporting JSP for URI \" + cms.getRequestContext().getUri(),\n                CmsException.C_FLEX_LOADER, e);            \n        }\n\n        return bytes.toByteArray();\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the links found in the currently processed page as response headers,\n     * so that the static export can pick them up later.\n     *\n     * @param cms provides the current cms context\n     * @param res the response to set the headers in\n     */\n    private void exportSetLinkHeader(CmsObject cms, HttpServletResponse res) {\n        // get the links found on the page from the current request context\n        Vector v = cms.getRequestContext().getLinkVector();\n        // making the vector a set removes the duplicate entries\n        Set s = new HashSet(v);\n        StringBuffer links = new StringBuffer(s.size() * 64);\n        Iterator i = s.iterator();\n        // build a string out of the found links\n        while (i.hasNext()) {\n            links.append(Encoder.encode((String)i.next(), \"UTF-8\", true));\n            if (i.hasNext()) links.append(C_EXPORT_HEADER_SEP);\n        }\n        // set the export header and we are finished\n        res.setHeader(C_EXPORT_HEADER, new String(links));\n    }","id":9609,"modified_method":"/**\n     * Returns the links found in the currently processed page as response headers,\n     * so that the static export can pick them up later.\n     *\n     * @param cms provides the current cms context\n     * @param res the response to set the headers in\n     */\n    private void exportSetLinkHeader(CmsObject cms, HttpServletResponse res) {\n        // get the links found on the page from the current request context\n        Vector v = cms.getRequestContext().getLinkVector();\n        // making the vector a set removes the duplicate entries\n        Set s = new HashSet(v);\n        StringBuffer links = new StringBuffer(s.size() * 64);\n        Iterator i = s.iterator();\n        // build a string out of the found links\n        while (i.hasNext()) {\n            links.append(Encoder.encode((String)i.next()));\n            if (i.hasNext()) links.append(C_EXPORT_HEADER_SEP);\n        }\n        // set the export header and we are finished\n        res.setHeader(C_EXPORT_HEADER, new String(links));\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see #getContent(CmsObject, String, String, Hashtable, String)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        CmsRequestContext reqCont = cms.getRequestContext();\n        HttpServletRequest orgReq = (HttpServletRequest)reqCont.getRequest().getOriginalRequest();\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n\n        // get the temporary file projectid\n        int tempProject = 0;\n        try{\n            tempProject = Integer.parseInt((String)cms.getRegistry().getSystemValue(\"tempfileproject\"));\n        }catch(Exception e){\n            throw new CmsException(\"Can not read projectId of tempfileproject for creating temporary file for editing! \"+e.toString());\n        }\n        if(tempProject == 0){\n            throw new CmsException(\"Can not create temporary file for editing!\");\n        }\n        int curProject = cms.getRequestContext().currentProject().getId();\n\n        // Get the user's browser\n        String browser = orgReq.getHeader(\"user-agent\");\n        // TESTFIX (AJS) Old code: String hostName = orgReq.getScheme() + \"://\" + orgReq.getHeader(\"HOST\");\n        String hostName = orgReq.getScheme() + \"://\" + orgReq.getServerName() + \":\" + orgReq.getServerPort();\n\n        // Get all URL parameters\n        String content = (String)parameters.get(C_PARA_CONTENT);\n        if(content == null){\n            // try to get the value from the session because we might come from errorpage\n            content = (String)session.getValue(C_PARA_CONTENT);\n            session.removeValue(C_PARA_CONTENT);\n        }\n        String body = (String)parameters.get(\"body\");\n        if(body == null){\n            // try to get the value from the session because we might come from errorpage\n            body = (String)session.getValue(\"body\");\n            session.removeValue(\"body\");\n        }\n        String file = (String)parameters.get(C_PARA_FILE);\n        if(file == null){\n            // try to get the value from the session because we might come from errorpage\n            file = (String)session.getValue(C_PARA_FILE);\n            session.removeValue(C_PARA_FILE);\n        }\n        String editor = (String)parameters.get(\"editor\");\n        if((editor == null) || \"\".equals(editor)){\n            // try to get the value from the session because we might come from errorpage\n            editor = (String)session.getValue(\"editor\");\n            if(editor != null){\n                parameters.put(\"editor\", editor);\n            }\n            session.removeValue(\"editor\");\n        }\n        String title = (String)parameters.get(C_PARA_TITLE);\n        if(title == null){\n            // try to get the value from the session because we might come from errorpage\n            title = (String)session.getValue(C_PARA_TITLE);\n            session.removeValue(C_PARA_TITLE);\n        }\n        String bodytitle = (String)parameters.get(\"bodytitle\");\n        if(bodytitle == null){\n            // try to get the value from the session because we might come from errorpage\n            bodytitle = (String)session.getValue(\"bodytitle\");\n            session.removeValue(\"bodytitle\");\n        }\n        String layoutTemplateFilename = (String)parameters.get(\"template\");\n        if(layoutTemplateFilename == null){\n            // try to get the value from the session because we might come from errorpage\n            layoutTemplateFilename = (String)session.getValue(\"template\");\n            session.removeValue(\"template\");\n        }\n        String layoutTemplatFilenameRelative = layoutTemplateFilename;\n        layoutTemplateFilename = Utils.mergeAbsolutePath(file, layoutTemplateFilename);\n        String bodyElementClassName = (String)parameters.get(\"bodyclass\");\n        if(bodyElementClassName == null){\n            // try to get the value from the session because we might come from errorpage\n            bodyElementClassName = (String)session.getValue(\"bodyclass\");\n            session.removeValue(\"bodyclass\");\n        }\n        String bodyElementFilename = (String)parameters.get(\"bodyfile\");\n        if(bodyElementFilename == null){\n            // try to get the value from the session because we might come from errorpage\n            bodyElementFilename = (String)session.getValue(\"bodyfile\");\n            session.removeValue(\"bodyfile\");\n        }\n        String action = (String)parameters.get(C_PARA_ACTION);\n\n        String startView = (String)parameters.get(\"startview\");\n        if((startView == null) || (\"\".equals(startView))){\n            // try to get the value from the session because we might come from errorpage\n            startView = (String)session.getValue(\"startview\");\n            session.removeValue(\"startview\");\n        }\n\n        // Get all session parameters\n        String oldEdit = (String)session.getValue(\"te_oldedit\");\n        String oldLayoutFilename = (String)session.getValue(\"te_oldlayout\");\n        String oldTitle = (String)session.getValue(\"te_title\");\n        String oldBody = (String)session.getValue(\"te_oldbody\");\n        String oldBodytitle = (String)session.getValue(\"te_oldbodytitle\");\n        String layoutTemplateClassName = (String)session.getValue(\"te_templateclass\");\n        String tempPageFilename = (String)session.getValue(\"te_temppagefile\");\n        String tempBodyFilename = (String)session.getValue(\"te_tempbodyfile\");\n        String style = (String)session.getValue(\"te_stylesheet\");\n\n        boolean existsContentParam = content != null;\n        boolean existsFileParam = (file != null && (!\"\".equals(file)));\n        boolean saveRequested = ((action != null) && (C_EDIT_ACTION_SAVE.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n        boolean exitRequested = ((action != null) && (C_EDIT_ACTION_EXIT.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n        boolean bodychangeRequested = ((oldBody != null) && (body != null) && (!(oldBody.equals(body))));\n        boolean templatechangeRequested = (oldLayoutFilename != null && layoutTemplateFilename != null\n               && (!(oldLayoutFilename.equals(layoutTemplateFilename))));\n        boolean titlechangeRequested = (oldTitle != null && title != null && (!(oldTitle.equals(title))));\n        boolean newbodyRequested = ((action != null) && \"newbody\".equals(action));\n        boolean previewRequested = ((action != null) && \"preview\".equals(action));\n        boolean bodytitlechangeRequested = (oldBodytitle != null && bodytitle != null && (!(oldBodytitle.equals(bodytitle))));\n\n        String saveerror = \"\";\n\n        // Check if there is a file parameter in the request\n        if(!existsFileParam) {\n            throwException(\"No \\\"file\\\" parameter given. Don't know which file should be edited.\");\n        }\n\n        // If there is no content parameter this seems to be\n        // a new request of the page editor.\n        // So we have to read all files and set some initial values.\n        parameters.put(\"root.pagetype\", cms.getResourceType(cms.readFileHeader(file).getType()).getResourceTypeName());\n        parameters.put(\"filename_for_relative_template\", file);\n        if(!existsContentParam) {\n            CmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n            if(originalControlFile.isElementClassDefined(C_BODY_ELEMENT)) {\n                bodyElementClassName = originalControlFile.getElementClass(C_BODY_ELEMENT);\n            }\n            if(originalControlFile.isElementTemplateDefined(C_BODY_ELEMENT)) {\n                bodyElementFilename = originalControlFile.getElementTemplate(C_BODY_ELEMENT);\n            }\n            if((bodyElementClassName == null) || (bodyElementFilename == null)) {\n                // Either the template class or the template file\n                // for the body element could not be determined.\n                // BUG: Send error here\n            }\n            // Check, if the selected page file is locked\n            CmsResource pageFileResource = cms.readFileHeader(file);\n            if(!pageFileResource.isLocked()) {\n                // BUG: Check only, dont't lock here!\n                cms.lockResource(file);\n            }\n            // The content file must be locked before editing\n            CmsResource contentFileResource = cms.readFileHeader(bodyElementFilename);\n            if(!contentFileResource.isLocked()) {\n                cms.lockResource(bodyElementFilename);\n            }\n            // Now get the currently selected master template file\n            layoutTemplateFilename = originalControlFile.getMasterTemplate();\n            layoutTemplatFilenameRelative = layoutTemplateFilename;\n            layoutTemplateFilename = Utils.mergeAbsolutePath(originalControlFile.getAbsoluteFilename()\n                                                            , layoutTemplateFilename);\n            layoutTemplateClassName = originalControlFile.getTemplateClass();\n            int browserId;\n            if(browser.indexOf(\"MSIE\") > -1) {\n                browserId = 0;\n            }else {\n                browserId = 1;\n            }\n\n            if(editor == null || \"\".equals(editor)) {\n                if(startView == null || \"\".equals(startView)){\n                    editor = C_SELECTBOX_EDITORVIEWS[C_SELECTBOX_EDITORVIEWS_DEFAULT[browserId]];\n                } else {\n                    editor = startView;\n                }\n                session.putValue(\"te_pageeditor\", editor);\n                parameters.put(\"editor\", editor);\n            }\n\n            // And finally the document title\n            title = cms.readProperty(file, C_PROPERTY_TITLE);\n            if(title == null) {\n                title = \"\";\n            }\n\n            // We don't want the user to go on and create any temporary\n            // files, if he has insufficient rights. Check this now.\n            if(!cms.accessWrite(file)) {\n                throw new CmsException(getClassName() + \"Insufficient rights for editing the file \" + file, CmsException.C_NO_ACCESS);\n            }\n            if(!cms.accessWrite(bodyElementFilename)) {\n                throw new CmsException(getClassName() + \"Insufficient rights for editing the file \" + bodyElementFilename, CmsException.C_NO_ACCESS);\n            }\n\n            // Okay. All values are initialized. Now we can create\n            // the temporary files.\n            // if the parameter noactivex is set the temp file was already created,\n            // so read the filename from the session\n            String noactivex = (String)parameters.get(\"noactivex\");\n            if(noactivex == null || \"\".equals(noactivex.trim())){\n                tempPageFilename = createTemporaryFile(cms, pageFileResource, tempProject, curProject);\n            } else {\n                tempPageFilename = (String)session.getValue(\"te_temppagefile\");\n            }\n            cms.getRequestContext().setCurrentProject(curProject);\n            tempBodyFilename = C_VFS_PATH_BODIES.substring(0, C_VFS_PATH_BODIES.length()-1) + tempPageFilename;\n\n            session.putValue(\"te_temppagefile\", tempPageFilename);\n            session.putValue(\"te_tempbodyfile\", tempBodyFilename);\n        }\n        // Get the XML parsed content of the layout file.\n        // This can be done by calling the getOwnTemplateFile() method of the\n        // layout's template class.\n        // The content is needed to determine the HTML style of the body element.\n        Object tempObj = CmsTemplateClassManager.getClassInstance(cms, layoutTemplateClassName);\n        CmsXmlTemplate layoutTemplateClassObject = (CmsXmlTemplate)tempObj;\n        CmsXmlTemplateFile layoutTemplateFile = layoutTemplateClassObject.getOwnTemplateFile(cms,\n                layoutTemplateFilename, null, parameters, null);\n\n        // Get the XML parsed content of the body file.\n        // This can be done by calling the getOwnTemplateFile() method of the\n        // body's template class.\n        tempObj = CmsTemplateClassManager.getClassInstance(cms, bodyElementClassName);\n        CmsXmlTemplate bodyElementClassObject = (CmsXmlTemplate)tempObj;\n        CmsXmlTemplateFile bodyTemplateFile = bodyElementClassObject.getOwnTemplateFile(cms,\n                tempBodyFilename, C_BODY_ELEMENT, parameters, null);\n\n        // Get the temporary page file object\n        CmsXmlControlFile temporaryControlFile = new CmsXmlControlFile(cms, tempPageFilename);\n        if(!existsContentParam) {\n            Vector allBodys = bodyTemplateFile.getAllSections();\n            if(allBodys == null || allBodys.size() == 0) {\n                body = \"\";\n            }else {\n                body = (String)allBodys.elementAt(0);\n            }\n            bodytitle = body.equals(\"(default)\") ? \"\" : body;\n            temporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n            temporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n            // change the current project to temp file project\n            cms.getRequestContext().setCurrentProject(tempProject);\n            temporaryControlFile.write();\n            cms.getRequestContext().setCurrentProject(curProject);\n            try {\n                style = getStylesheet(cms, null, layoutTemplateFile, null);\n                if(style != null && !\"\".equals(style)) {\n                    style = hostName + style;\n                }\n            }catch(Exception e) {\n                style = \"\";\n            }\n            session.putValue(\"te_stylesheet\", style);\n        }else {\n            // There exists a content parameter.\n            // We have to check all possible changes requested by the user.\n            if(titlechangeRequested) {\n                // The user entered a new document title\n                try {\n                    cms.getRequestContext().setCurrentProject(tempProject);\n                    cms.writeProperty(tempPageFilename, C_PROPERTY_TITLE, title);\n                    cms.getRequestContext().setCurrentProject(curProject);\n                }catch(CmsException e) {\n                    cms.getRequestContext().setCurrentProject(curProject);\n                    if(I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && A_OpenCms.isLogging() ) {\n                        A_OpenCms.log(C_OPENCMS_INFO, getClassName()\n                                + \"Could not write property \" + C_PROPERTY_TITLE + \" for file \" + file + \".\");\n                        A_OpenCms.log(C_OPENCMS_INFO, getClassName() + e);\n                    }\n                }\n            }\n            if(templatechangeRequested) {\n                // The user requested a change of the layout template\n                temporaryControlFile.setMasterTemplate(layoutTemplatFilenameRelative );\n                try {\n                    style = getStylesheet(cms, null, layoutTemplateFile, null);\n                    if(style != null && !\"\".equals(style)) {\n                        style = hostName + style;\n                    }\n                }catch(Exception e) {\n                    style = \"\";\n                }\n                session.putValue(\"te_stylesheet\", style);\n            }\n            if(bodytitlechangeRequested) {\n                // The user entered a new title for the current body\n                if((!oldBody.equals(\"(default)\")) && (!oldBody.equals(\"script\"))) {\n                    if(bodytitle.toLowerCase().equals(\"script\")) {\n                        bodytitle = \"script\";\n                    }\n                    try {\n                        bodyTemplateFile.renameSection(oldBody, bodytitle);\n                        oldBody = bodytitle;\n                        if(!bodychangeRequested) {\n                            body = bodytitle;\n                        }\n                    }catch(Exception e) {\n                        bodytitle = oldBodytitle;\n                    }\n                    if(bodytitle.equals(\"script\")) {\n                        session.putValue(\"te_pageeditor\", editor);\n                        editor = C_SELECTBOX_EDITORVIEWS[1];\n                        parameters.put(\"editor\", editor);\n                    }\n                }else {\n                    bodytitle = oldBodytitle;\n                }\n            }\n            if(bodychangeRequested) {\n                temporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n                bodytitle = body.equals(\"(default)\") ? \"\" : body;\n                if(body.equals(\"script\")) {\n                    // User wants to edit javascript code\n                    // Select text editor\n                    session.putValue(\"te_pageeditor\", editor);\n                    editor = C_SELECTBOX_EDITORVIEWS[1];\n                    parameters.put(\"editor\", editor);\n                }else {\n                    if(oldBody.equals(\"script\")) {\n                        // User wants to switch back from javascript mode\n                        // Select old editor\n                        editor = (String)session.getValue(\"te_pageeditor\");\n                        parameters.put(\"editor\", editor);\n                    }\n                }\n            }\n            if(newbodyRequested) {\n                body = C_BODY_ELEMENT + bodyTemplateFile.createNewSection(C_BODY_ELEMENT);\n                bodytitle = body;\n                temporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n                temporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n            }\n            \n            // check for C_PROPERTY_RELATIVEROOT property (with directory search)\n            String relativeRoot = cms.readProperty(file, C_PROPERTY_RELATIVEROOT, true);\n            \n            // save file contents to our temporary file.\n            //Gridnine AB Aug 8, 2002\n            content = Encoder.unescape(content,\n                cms.getRequestContext().getEncoding());\n            // TODO: Set correct error page here\n            if((!exitRequested) || saveRequested) {\n                bodyTemplateFile.setEditedTemplateContent(cms, content, oldBody, oldEdit.equals(C_SELECTBOX_EDITORVIEWS[0]), file, relativeRoot);\n            }\n            cms.getRequestContext().setCurrentProject(tempProject);\n            bodyTemplateFile.write();\n            temporaryControlFile.write();\n            cms.getRequestContext().setCurrentProject(curProject);\n        }\n\n        // If the user requested a preview then send a redirect\n        // to the temporary page file.\n        if(previewRequested) {\n            preview(tempPageFilename, reqCont);\n            return \"\".getBytes();\n        }\n\n        // If the user requested a \"save\" expilitly by pressing one of\n        // the \"save\" buttons, copy all informations of the temporary\n        // files to the original files.\n        if(saveRequested) {\n            try{\n                commitTemporaryFile(cms, bodyElementFilename, tempBodyFilename, tempProject, curProject);\n                cms.getRequestContext().setCurrentProject(tempProject);\n                title = cms.readProperty(tempPageFilename, C_PROPERTY_TITLE);\n                cms.getRequestContext().setCurrentProject(curProject);\n                if(title != null && !\"\".equals(title)) {\n                    cms.writeProperty(file, C_PROPERTY_TITLE, title);\n                }\n                CmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n                originalControlFile.setMasterTemplate(temporaryControlFile.getMasterTemplate());\n                originalControlFile.write();\n                // here we care about the linkmanagement\n                CmsPageLinks linkObject = cms.getPageLinks(file);\n                cms.createLinkEntrys(linkObject.getResourceId(), linkObject.getLinkTargets());\n            } catch (CmsException e){\n                // there was an exception while the file should be saved\n                // return to the editor and show the exception so the user can save the changes\n                saveerror = e.getShortException();\n                if(content != null){\n                    session.putValue(C_PARA_CONTENT, content);\n                }\n                if(body != null){\n                    session.putValue(\"body\", body);\n                }\n                if(file != null){\n                    session.putValue(C_PARA_FILE, file);\n                }\n                if(editor != null){\n                    session.putValue(\"editor\", editor);\n                }\n                if(title != null){\n                    session.putValue(C_PARA_TITLE, title);\n                }\n                if(bodytitle != null){\n                    session.putValue(\"bodytitle\", bodytitle);\n                }\n                if(layoutTemplatFilenameRelative != null){\n                    session.putValue(\"template\", layoutTemplatFilenameRelative);\n                }\n                if(bodyElementClassName != null){\n                    session.putValue(\"bodyclass\", bodyElementClassName);\n                }\n                if(bodyElementFilename != null){\n                    session.putValue(\"bodyfile\", bodyElementFilename);\n                }\n                if(startView != null){\n                    session.putValue(\"startview\", startView);\n                }\n            }\n        }\n\n        // Check if we should leave th editor instead of start processing\n        if(exitRequested && ((saveerror == null) || \"\".equals(saveerror))) {\n\n            // First delete temporary files\n            temporaryControlFile.removeFromFileCache();\n            bodyTemplateFile.removeFromFileCache();\n            // deleting the pagefile will delete the bodyfile too\n            cms.getRequestContext().setCurrentProject(tempProject);\n            cms.deleteResource(tempPageFilename);\n            cms.getRequestContext().setCurrentProject(curProject);\n            try {\n                cms.getRequestContext().getResponse().sendCmsRedirect(\"/system/workplace/action/index.html\");\n            }catch(IOException e) {\n                throwException(\"Could not send redirect to workplace main screen.\", e);\n            }\n            return null;\n        }\n\n        // Include the datablocks of the layout file into the body file.\n        // So the \"bodytag\" and \"style\" data can be accessed by the body file.\n        Element bodyTag = layoutTemplateFile.getBodyTag();\n        bodyTemplateFile.setBodyTag(bodyTag);\n\n        // Load the body!\n        content = bodyTemplateFile.getEditableTemplateContent(this, parameters, body, editor.equals(C_SELECTBOX_EDITORVIEWS[0]), style);\n        //Gridnine AB Aug 8, 2002\n        content = Encoder.escapeWBlanks(content,\n            cms.getRequestContext().getEncoding());\n        parameters.put(C_PARA_CONTENT, content);\n\n        // put the body parameter so that the selectbox can set the correct current value\n        parameters.put(\"body\", body);\n        parameters.put(\"bodyfile\", bodyElementFilename);\n        parameters.put(\"bodyclass\", bodyElementClassName);\n        parameters.put(\"template\", layoutTemplateFilename);\n\n        // remove all parameters that could be relevant for the\n        // included editor.\n        parameters.remove(C_PARA_FILE);\n        parameters.remove(C_PARA_ACTION);\n        int numEditors = C_SELECTBOX_EDITORVIEWS.length;\n        for(int i = 0;i < numEditors;i++) {\n            if(editor.equals(C_SELECTBOX_EDITORVIEWS[i])) {\n                parameters.put(\"editor._CLASS_\", C_SELECTBOX_EDITORVIEWS_CLASSES[i]);\n                parameters.put(\"editor._TEMPLATE_\", \"/system/workplace/templates/\" + C_SELECTBOX_EDITORVIEWS_TEMPLATES[i]);\n            }\n        }\n        session.putValue(\"te_file\", file);\n        session.putValue(\"te_oldedit\", editor);\n        session.putValue(\"te_oldbody\", body);\n        session.putValue(\"te_oldbodytitle\", bodytitle);\n        session.putValue(\"te_oldlayout\", layoutTemplateFilename);\n        if(title != null) {\n            session.putValue(\"te_title\", title);\n        }else {\n            session.putValue(\"te_title\", \"\");\n        }\n        session.putValue(\"te_templateclass\", layoutTemplateClassName);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n        xmlTemplateDocument.setData(\"editor\", editor);\n        xmlTemplateDocument.setData(\"bodyfile\", bodyElementFilename);\n        xmlTemplateDocument.setData(\"bodyclass\", bodyElementClassName);\n        xmlTemplateDocument.setData(\"editorframe\", (String)parameters.get(\"root.editorframe\"));\n\n        // Put the \"file\" datablock for processing in the template file.\n        // It will be inserted in a hidden input field and given back when submitting.\n        xmlTemplateDocument.setData(C_PARA_FILE, file);\n        if(!\"\".equals(saveerror)){\n            templateSelector = \"errorsave\";\n            xmlTemplateDocument.setData(\"errordetail\", saveerror);\n            xmlTemplateDocument.setData(\"errorlasturl\", xmlTemplateDocument.getFilename()+\".html\");\n        }\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n    }","id":9610,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see #getContent(CmsObject, String, String, Hashtable, String)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        CmsRequestContext reqCont = cms.getRequestContext();\n        HttpServletRequest orgReq = (HttpServletRequest)reqCont.getRequest().getOriginalRequest();\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n\n        // get the temporary file projectid\n        int tempProject = 0;\n        try{\n            tempProject = Integer.parseInt((String)cms.getRegistry().getSystemValue(\"tempfileproject\"));\n        }catch(Exception e){\n            throw new CmsException(\"Can not read projectId of tempfileproject for creating temporary file for editing! \"+e.toString());\n        }\n        if(tempProject == 0){\n            throw new CmsException(\"Can not create temporary file for editing!\");\n        }\n        int curProject = cms.getRequestContext().currentProject().getId();\n\n        // Get the user's browser\n        String browser = orgReq.getHeader(\"user-agent\");;\n        String hostName = orgReq.getScheme() + \"://\" + orgReq.getServerName() + \":\" + orgReq.getServerPort();\n\n        // Get all URL parameters\n        String content = (String)parameters.get(C_PARA_CONTENT);\n        if(content == null){\n            // try to get the value from the session because we might come from errorpage\n            content = (String)session.getValue(C_PARA_CONTENT);\n            session.removeValue(C_PARA_CONTENT);\n        }\n        String body = (String)parameters.get(\"body\");\n        if(body == null){\n            // try to get the value from the session because we might come from errorpage\n            body = (String)session.getValue(\"body\");\n            session.removeValue(\"body\");\n        }\n        String file = (String)parameters.get(C_PARA_FILE);\n        if(file == null){\n            // try to get the value from the session because we might come from errorpage\n            file = (String)session.getValue(C_PARA_FILE);\n            session.removeValue(C_PARA_FILE);\n        }\n        String editor = (String)parameters.get(\"editor\");\n        if((editor == null) || \"\".equals(editor)){\n            // try to get the value from the session because we might come from errorpage\n            editor = (String)session.getValue(\"editor\");\n            if(editor != null){\n                parameters.put(\"editor\", editor);\n            }\n            session.removeValue(\"editor\");\n        }\n        String title = (String)parameters.get(C_PARA_TITLE);\n        if(title == null){\n            // try to get the value from the session because we might come from errorpage\n            title = (String)session.getValue(C_PARA_TITLE);\n            session.removeValue(C_PARA_TITLE);\n        }\n        String bodytitle = (String)parameters.get(\"bodytitle\");\n        if(bodytitle == null){\n            // try to get the value from the session because we might come from errorpage\n            bodytitle = (String)session.getValue(\"bodytitle\");\n            session.removeValue(\"bodytitle\");\n        }\n        String layoutTemplateFilename = (String)parameters.get(\"template\");\n        if(layoutTemplateFilename == null){\n            // try to get the value from the session because we might come from errorpage\n            layoutTemplateFilename = (String)session.getValue(\"template\");\n            session.removeValue(\"template\");\n        }\n        String layoutTemplatFilenameRelative = layoutTemplateFilename;\n        layoutTemplateFilename = Utils.mergeAbsolutePath(file, layoutTemplateFilename);\n        String bodyElementClassName = (String)parameters.get(\"bodyclass\");\n        if(bodyElementClassName == null){\n            // try to get the value from the session because we might come from errorpage\n            bodyElementClassName = (String)session.getValue(\"bodyclass\");\n            session.removeValue(\"bodyclass\");\n        }\n        String bodyElementFilename = (String)parameters.get(\"bodyfile\");\n        if(bodyElementFilename == null){\n            // try to get the value from the session because we might come from errorpage\n            bodyElementFilename = (String)session.getValue(\"bodyfile\");\n            session.removeValue(\"bodyfile\");\n        }\n        String action = (String)parameters.get(C_PARA_ACTION);\n\n        String startView = (String)parameters.get(\"startview\");\n        if((startView == null) || (\"\".equals(startView))){\n            // try to get the value from the session because we might come from errorpage\n            startView = (String)session.getValue(\"startview\");\n            session.removeValue(\"startview\");\n        }\n\n        // Get all session parameters\n        String oldEdit = (String)session.getValue(\"te_oldedit\");\n        String oldLayoutFilename = (String)session.getValue(\"te_oldlayout\");\n        String oldTitle = (String)session.getValue(\"te_title\");\n        String oldBody = (String)session.getValue(\"te_oldbody\");\n        String oldBodytitle = (String)session.getValue(\"te_oldbodytitle\");\n        String layoutTemplateClassName = (String)session.getValue(\"te_templateclass\");\n        String tempPageFilename = (String)session.getValue(\"te_temppagefile\");\n        String tempBodyFilename = (String)session.getValue(\"te_tempbodyfile\");\n        String style = (String)session.getValue(\"te_stylesheet\");\n\n        boolean existsContentParam = content != null;\n        boolean existsFileParam = (file != null && (!\"\".equals(file)));\n        boolean saveRequested = ((action != null) && (C_EDIT_ACTION_SAVE.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n        boolean exitRequested = ((action != null) && (C_EDIT_ACTION_EXIT.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n        boolean bodychangeRequested = ((oldBody != null) && (body != null) && (!(oldBody.equals(body))));\n        boolean templatechangeRequested = (oldLayoutFilename != null && layoutTemplateFilename != null\n               && (!(oldLayoutFilename.equals(layoutTemplateFilename))));\n        boolean titlechangeRequested = (oldTitle != null && title != null && (!(oldTitle.equals(title))));\n        boolean newbodyRequested = ((action != null) && \"newbody\".equals(action));\n        boolean previewRequested = ((action != null) && \"preview\".equals(action));\n        boolean bodytitlechangeRequested = (oldBodytitle != null && bodytitle != null && (!(oldBodytitle.equals(bodytitle))));\n\n        String saveerror = \"\";\n\n        // Check if there is a file parameter in the request\n        if(!existsFileParam) {\n            throwException(\"No \\\"file\\\" parameter given. Don't know which file should be edited.\");\n        }\n\n        // If there is no content parameter this seems to be\n        // a new request of the page editor.\n        // So we have to read all files and set some initial values.\n        parameters.put(\"root.pagetype\", cms.getResourceType(cms.readFileHeader(file).getType()).getResourceTypeName());\n        parameters.put(\"filename_for_relative_template\", file);\n        if(!existsContentParam) {\n            CmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n            if(originalControlFile.isElementClassDefined(C_BODY_ELEMENT)) {\n                bodyElementClassName = originalControlFile.getElementClass(C_BODY_ELEMENT);\n            }\n            if(originalControlFile.isElementTemplateDefined(C_BODY_ELEMENT)) {\n                bodyElementFilename = originalControlFile.getElementTemplate(C_BODY_ELEMENT);\n            }\n            if((bodyElementClassName == null) || (bodyElementFilename == null)) {\n                // Either the template class or the template file\n                // for the body element could not be determined.\n                // BUG: Send error here\n            }\n            // Check, if the selected page file is locked\n            CmsResource pageFileResource = cms.readFileHeader(file);\n            if(!pageFileResource.isLocked()) {\n                // BUG: Check only, dont't lock here!\n                cms.lockResource(file);\n            }\n            // The content file must be locked before editing\n            CmsResource contentFileResource = cms.readFileHeader(bodyElementFilename);\n            if(!contentFileResource.isLocked()) {\n                cms.lockResource(bodyElementFilename);\n            }\n            // Now get the currently selected master template file\n            layoutTemplateFilename = originalControlFile.getMasterTemplate();\n            layoutTemplatFilenameRelative = layoutTemplateFilename;\n            layoutTemplateFilename = Utils.mergeAbsolutePath(originalControlFile.getAbsoluteFilename()\n                                                            , layoutTemplateFilename);\n            layoutTemplateClassName = originalControlFile.getTemplateClass();\n            int browserId;\n            if(browser.indexOf(\"MSIE\") > -1) {\n                browserId = 0;\n            }else {\n                browserId = 1;\n            }\n\n            if(editor == null || \"\".equals(editor)) {\n                if(startView == null || \"\".equals(startView)){\n                    editor = C_SELECTBOX_EDITORVIEWS[C_SELECTBOX_EDITORVIEWS_DEFAULT[browserId]];\n                } else {\n                    editor = startView;\n                }\n                session.putValue(\"te_pageeditor\", editor);\n                parameters.put(\"editor\", editor);\n            }\n\n            // And finally the document title\n            title = cms.readProperty(file, C_PROPERTY_TITLE);\n            if(title == null) {\n                title = \"\";\n            }\n\n            // We don't want the user to go on and create any temporary\n            // files, if he has insufficient rights. Check this now.\n            if(!cms.accessWrite(file)) {\n                throw new CmsException(getClassName() + \"Insufficient rights for editing the file \" + file, CmsException.C_NO_ACCESS);\n            }\n            if(!cms.accessWrite(bodyElementFilename)) {\n                throw new CmsException(getClassName() + \"Insufficient rights for editing the file \" + bodyElementFilename, CmsException.C_NO_ACCESS);\n            }\n\n            // Okay. All values are initialized. Now we can create\n            // the temporary files.\n            // if the parameter noactivex is set the temp file was already created,\n            // so read the filename from the session\n            String noactivex = (String)parameters.get(\"noactivex\");\n            if(noactivex == null || \"\".equals(noactivex.trim())){\n                tempPageFilename = createTemporaryFile(cms, pageFileResource, tempProject, curProject);\n            } else {\n                tempPageFilename = (String)session.getValue(\"te_temppagefile\");\n            }\n            cms.getRequestContext().setCurrentProject(curProject);\n            tempBodyFilename = C_VFS_PATH_BODIES.substring(0, C_VFS_PATH_BODIES.length()-1) + tempPageFilename;\n\n            session.putValue(\"te_temppagefile\", tempPageFilename);\n            session.putValue(\"te_tempbodyfile\", tempBodyFilename);\n        }\n        // Get the XML parsed content of the layout file.\n        // This can be done by calling the getOwnTemplateFile() method of the\n        // layout's template class.\n        // The content is needed to determine the HTML style of the body element.\n        Object tempObj = CmsTemplateClassManager.getClassInstance(cms, layoutTemplateClassName);\n        CmsXmlTemplate layoutTemplateClassObject = (CmsXmlTemplate)tempObj;\n        CmsXmlTemplateFile layoutTemplateFile = layoutTemplateClassObject.getOwnTemplateFile(cms,\n                layoutTemplateFilename, null, parameters, null);\n\n        // Get the XML parsed content of the body file.\n        // This can be done by calling the getOwnTemplateFile() method of the\n        // body's template class.\n        tempObj = CmsTemplateClassManager.getClassInstance(cms, bodyElementClassName);\n        CmsXmlTemplate bodyElementClassObject = (CmsXmlTemplate)tempObj;\n        CmsXmlTemplateFile bodyTemplateFile = bodyElementClassObject.getOwnTemplateFile(cms,\n                tempBodyFilename, C_BODY_ELEMENT, parameters, null);\n\n        // Get the temporary page file object\n        CmsXmlControlFile temporaryControlFile = new CmsXmlControlFile(cms, tempPageFilename);\n        if(!existsContentParam) {\n            Vector allBodys = bodyTemplateFile.getAllSections();\n            if(allBodys == null || allBodys.size() == 0) {\n                body = \"\";\n            }else {\n                body = (String)allBodys.elementAt(0);\n            }\n            bodytitle = body.equals(\"(default)\") ? \"\" : body;\n            temporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n            temporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n            // change the current project to temp file project\n            cms.getRequestContext().setCurrentProject(tempProject);\n            temporaryControlFile.write();\n            cms.getRequestContext().setCurrentProject(curProject);\n            try {\n                style = getStylesheet(cms, null, layoutTemplateFile, null);\n                if(style != null && !\"\".equals(style)) {\n                    style = hostName + style;\n                }\n            }catch(Exception e) {\n                style = \"\";\n            }\n            session.putValue(\"te_stylesheet\", style);\n        }else {\n            // There exists a content parameter.\n            // We have to check all possible changes requested by the user.\n            if(titlechangeRequested) {\n                // The user entered a new document title\n                try {\n                    cms.getRequestContext().setCurrentProject(tempProject);\n                    cms.writeProperty(tempPageFilename, C_PROPERTY_TITLE, title);\n                    cms.getRequestContext().setCurrentProject(curProject);\n                }catch(CmsException e) {\n                    cms.getRequestContext().setCurrentProject(curProject);\n                    if(I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && A_OpenCms.isLogging() ) {\n                        A_OpenCms.log(C_OPENCMS_INFO, getClassName()\n                                + \"Could not write property \" + C_PROPERTY_TITLE + \" for file \" + file + \".\");\n                        A_OpenCms.log(C_OPENCMS_INFO, getClassName() + e);\n                    }\n                }\n            }\n            if(templatechangeRequested) {\n                // The user requested a change of the layout template\n                temporaryControlFile.setMasterTemplate(layoutTemplatFilenameRelative );\n                try {\n                    style = getStylesheet(cms, null, layoutTemplateFile, null);\n                    if(style != null && !\"\".equals(style)) {\n                        style = hostName + style;\n                    }\n                }catch(Exception e) {\n                    style = \"\";\n                }\n                session.putValue(\"te_stylesheet\", style);\n            }\n            if(bodytitlechangeRequested) {\n                // The user entered a new title for the current body\n                if((!oldBody.equals(\"(default)\")) && (!oldBody.equals(\"script\"))) {\n                    if(bodytitle.toLowerCase().equals(\"script\")) {\n                        bodytitle = \"script\";\n                    }\n                    try {\n                        bodyTemplateFile.renameSection(oldBody, bodytitle);\n                        oldBody = bodytitle;\n                        if(!bodychangeRequested) {\n                            body = bodytitle;\n                        }\n                    }catch(Exception e) {\n                        bodytitle = oldBodytitle;\n                    }\n                    if(bodytitle.equals(\"script\")) {\n                        session.putValue(\"te_pageeditor\", editor);\n                        editor = C_SELECTBOX_EDITORVIEWS[1];\n                        parameters.put(\"editor\", editor);\n                    }\n                }else {\n                    bodytitle = oldBodytitle;\n                }\n            }\n            if(bodychangeRequested) {\n                temporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n                bodytitle = body.equals(\"(default)\") ? \"\" : body;\n                if(body.equals(\"script\")) {\n                    // User wants to edit javascript code\n                    // Select text editor\n                    session.putValue(\"te_pageeditor\", editor);\n                    editor = C_SELECTBOX_EDITORVIEWS[1];\n                    parameters.put(\"editor\", editor);\n                }else {\n                    if(oldBody.equals(\"script\")) {\n                        // User wants to switch back from javascript mode\n                        // Select old editor\n                        editor = (String)session.getValue(\"te_pageeditor\");\n                        parameters.put(\"editor\", editor);\n                    }\n                }\n            }\n            if(newbodyRequested) {\n                body = C_BODY_ELEMENT + bodyTemplateFile.createNewSection(C_BODY_ELEMENT);\n                bodytitle = body;\n                temporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n                temporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n            }\n            \n            // check for C_PROPERTY_RELATIVEROOT property (with directory search)\n            String relativeRoot = cms.readProperty(file, C_PROPERTY_RELATIVEROOT, true);\n            \n            // save file contents to our temporary file.\n            content = Encoder.unescape(content, Encoder.C_URI_ENCODING);\n            if((!exitRequested) || saveRequested) {\n                bodyTemplateFile.setEditedTemplateContent(cms, content, oldBody, oldEdit.equals(C_SELECTBOX_EDITORVIEWS[0]), file, relativeRoot);\n            }\n            cms.getRequestContext().setCurrentProject(tempProject);\n            bodyTemplateFile.write();\n            temporaryControlFile.write();\n            cms.getRequestContext().setCurrentProject(curProject);\n        }\n\n        // If the user requested a preview then send a redirect\n        // to the temporary page file.\n        if(previewRequested) {\n            preview(tempPageFilename, reqCont);\n            return \"\".getBytes();\n        }\n\n        // If the user requested a \"save\" expilitly by pressing one of\n        // the \"save\" buttons, copy all informations of the temporary\n        // files to the original files.\n        if(saveRequested) {\n            try{\n                commitTemporaryFile(cms, bodyElementFilename, tempBodyFilename, tempProject, curProject);\n                cms.getRequestContext().setCurrentProject(tempProject);\n                title = cms.readProperty(tempPageFilename, C_PROPERTY_TITLE);\n                cms.getRequestContext().setCurrentProject(curProject);\n                if(title != null && !\"\".equals(title)) {\n                    cms.writeProperty(file, C_PROPERTY_TITLE, title);\n                }\n                CmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n                originalControlFile.setMasterTemplate(temporaryControlFile.getMasterTemplate());\n                originalControlFile.write();\n                // here we care about the linkmanagement\n                CmsPageLinks linkObject = cms.getPageLinks(file);\n                cms.createLinkEntrys(linkObject.getResourceId(), linkObject.getLinkTargets());\n            } catch (CmsException e){\n                // there was an exception while the file should be saved\n                // return to the editor and show the exception so the user can save the changes\n                saveerror = e.getShortException();\n                if(content != null){\n                    session.putValue(C_PARA_CONTENT, content);\n                }\n                if(body != null){\n                    session.putValue(\"body\", body);\n                }\n                if(file != null){\n                    session.putValue(C_PARA_FILE, file);\n                }\n                if(editor != null){\n                    session.putValue(\"editor\", editor);\n                }\n                if(title != null){\n                    session.putValue(C_PARA_TITLE, title);\n                }\n                if(bodytitle != null){\n                    session.putValue(\"bodytitle\", bodytitle);\n                }\n                if(layoutTemplatFilenameRelative != null){\n                    session.putValue(\"template\", layoutTemplatFilenameRelative);\n                }\n                if(bodyElementClassName != null){\n                    session.putValue(\"bodyclass\", bodyElementClassName);\n                }\n                if(bodyElementFilename != null){\n                    session.putValue(\"bodyfile\", bodyElementFilename);\n                }\n                if(startView != null){\n                    session.putValue(\"startview\", startView);\n                }\n            }\n        }\n\n        // Check if we should leave th editor instead of start processing\n        if(exitRequested && ((saveerror == null) || \"\".equals(saveerror))) {\n\n            // First delete temporary files\n            temporaryControlFile.removeFromFileCache();\n            bodyTemplateFile.removeFromFileCache();\n            // deleting the pagefile will delete the bodyfile too\n            cms.getRequestContext().setCurrentProject(tempProject);\n            cms.deleteResource(tempPageFilename);\n            cms.getRequestContext().setCurrentProject(curProject);\n            try {\n                cms.getRequestContext().getResponse().sendCmsRedirect(\"/system/workplace/action/index.html\");\n            }catch(IOException e) {\n                throwException(\"Could not send redirect to workplace main screen.\", e);\n            }\n            return null;\n        }\n\n        // Include the datablocks of the layout file into the body file.\n        // So the \"bodytag\" and \"style\" data can be accessed by the body file.\n        Element bodyTag = layoutTemplateFile.getBodyTag();\n        bodyTemplateFile.setBodyTag(bodyTag);\n\n        // Load the body!\n        content = bodyTemplateFile.getEditableTemplateContent(this, parameters, body, editor.equals(C_SELECTBOX_EDITORVIEWS[0]), style);\n        //Gridnine AB Aug 8, 2002\n        content = Encoder.escapeWBlanks(content, Encoder.C_URI_ENCODING);\n        parameters.put(C_PARA_CONTENT, content);\n\n        // put the body parameter so that the selectbox can set the correct current value\n        parameters.put(\"body\", body);\n        parameters.put(\"bodyfile\", bodyElementFilename);\n        parameters.put(\"bodyclass\", bodyElementClassName);\n        parameters.put(\"template\", layoutTemplateFilename);\n\n        // remove all parameters that could be relevant for the\n        // included editor.\n        parameters.remove(C_PARA_FILE);\n        parameters.remove(C_PARA_ACTION);\n        int numEditors = C_SELECTBOX_EDITORVIEWS.length;\n        for(int i = 0;i < numEditors;i++) {\n            if(editor.equals(C_SELECTBOX_EDITORVIEWS[i])) {\n                parameters.put(\"editor._CLASS_\", C_SELECTBOX_EDITORVIEWS_CLASSES[i]);\n                parameters.put(\"editor._TEMPLATE_\", \"/system/workplace/templates/\" + C_SELECTBOX_EDITORVIEWS_TEMPLATES[i]);\n            }\n        }\n        session.putValue(\"te_file\", file);\n        session.putValue(\"te_oldedit\", editor);\n        session.putValue(\"te_oldbody\", body);\n        session.putValue(\"te_oldbodytitle\", bodytitle);\n        session.putValue(\"te_oldlayout\", layoutTemplateFilename);\n        if(title != null) {\n            session.putValue(\"te_title\", title);\n        }else {\n            session.putValue(\"te_title\", \"\");\n        }\n        session.putValue(\"te_templateclass\", layoutTemplateClassName);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n        xmlTemplateDocument.setData(\"editor\", editor);\n        xmlTemplateDocument.setData(\"bodyfile\", bodyElementFilename);\n        xmlTemplateDocument.setData(\"bodyclass\", bodyElementClassName);\n        xmlTemplateDocument.setData(\"editorframe\", (String)parameters.get(\"root.editorframe\"));\n\n        // Put the \"file\" datablock for processing in the template file.\n        // It will be inserted in a hidden input field and given back when submitting.\n        xmlTemplateDocument.setData(C_PARA_FILE, file);\n        if(!\"\".equals(saveerror)){\n            templateSelector = \"errorsave\";\n            xmlTemplateDocument.setData(\"errordetail\", saveerror);\n            xmlTemplateDocument.setData(\"errorlasturl\", xmlTemplateDocument.getFilename()+\".html\");\n        }\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Does the job of including the XMLTemplate, \n     * this method is called directly if the element is \n     * called as a sub-element from another I_CmsResourceLoader.\n     * \n     * @param cms Used to access the OpenCms VFS\n     * @param file The reqested JSP file resource in the VFS\n     * @param req The current request\n     * @param res The current response\n     * \n     * @throws ServletException might be thrown in the process of including the JSP \n     * @throws IOException might be thrown in the process of including the JSP \n     * \n     * @see com.opencms.flex.cache.CmsFlexRequestDispatcher\n     */    \n    public void service(CmsObject cms, CmsResource file, CmsFlexRequest req, CmsFlexResponse res)\n    throws ServletException, IOException {\n        long timer1 = 0;\n        if (DEBUG > 0) {\n            timer1 = System.currentTimeMillis();        \n            System.err.println(\"========== XmlTemplateLoader loading: \" + file.getAbsolutePath());            \n        }\n        // save the original context settings\n        String rnc = cms.getRequestContext().getEncoding().trim();\n        I_CmsRequest cms_req = cms.getRequestContext().getRequest();\n        HttpServletRequest originalreq = (HttpServletRequest)cms_req.getOriginalRequest();\n        try {                        \n            // get the CmsRequest\n            byte[] result = null;\n            com.opencms.file.CmsFile fx = req.getCmsObject().readFile(file.getAbsolutePath());            \n            // care about encoding issues\n            String dnc = A_OpenCms.getDefaultEncoding().trim();\n            String enc = cms.readProperty(fx.getAbsolutePath(), C_PROPERTY_CONTENT_ENCODING, true, dnc).trim();\n            // fake the called URI (otherwise XMLTemplate / ElementCache would not work)\n            cms.getRequestContext().setUri(fx.getAbsolutePath());            \n            cms_req.setOriginalRequest(req);\n            cms.getRequestContext().setEncoding(enc);            \n            // process the included XMLTemplate\n            result = generateOutput(cms, fx, fx.getLauncherClassname(), cms_req, m_openCms);                                    \n            // append the result to the output stream\n            if(result != null) {\n                // Encoding project:\n                // The byte array must internally be encoded in the OpenCms\n                // default encoding. It will be converted to the requested encoding \n                // on the most top-level JSP element\n                if (DEBUG > 1) System.out.println(\"CmsXmlTemplateLoader.service(): encoding=\" + enc + \" requestEncoding=\" + rnc + \" defaultEncoding=\" + dnc);\n                if (! enc.equalsIgnoreCase(dnc)) {\n                    result = (new String(result, enc)).getBytes(dnc);\n                }                                \n                res.getOutputStream().write(result);\n            }        \n        }  catch (Exception e) {\n            System.err.println(\"Error in CmsXmlTemplateLoader: \" + e.toString());\n            if (DEBUG > 0) e.printStackTrace(System.err);\n            throw new ServletException(\"Error in CmsXmlTemplateLoader processing\", e);       \n        } finally {\n            // restore the context settings\n            cms_req.setOriginalRequest(originalreq);\n            cms.getRequestContext().setEncoding(rnc);\n            cms.getRequestContext().setUri(null);\n        }\n        if (DEBUG > 0) {\n            long timer2 = System.currentTimeMillis() - timer1;        \n            System.err.println(\"========== Time delivering XmlTemplate for \" + file.getAbsolutePath() + \": \" + timer2 + \"ms\");            \n        }\n    }","id":9611,"modified_method":"/**\n     * Does the job of including the XMLTemplate, \n     * this method is called directly if the element is \n     * called as a sub-element from another I_CmsResourceLoader.\n     * \n     * @param cms Used to access the OpenCms VFS\n     * @param file The reqested JSP file resource in the VFS\n     * @param req The current request\n     * @param res The current response\n     * \n     * @throws ServletException might be thrown in the process of including the JSP \n     * @throws IOException might be thrown in the process of including the JSP \n     * \n     * @see com.opencms.flex.cache.CmsFlexRequestDispatcher\n     */    \n    public void service(CmsObject cms, CmsResource file, CmsFlexRequest req, CmsFlexResponse res)\n    throws ServletException, IOException {\n        long timer1 = 0;\n        if (DEBUG > 0) {\n            timer1 = System.currentTimeMillis();        \n            System.err.println(\"========== XmlTemplateLoader loading: \" + file.getAbsolutePath());            \n        }\n        // save the original context settings\n        String rnc = cms.getRequestContext().getEncoding().trim();\n        I_CmsRequest cms_req = cms.getRequestContext().getRequest();\n        HttpServletRequest originalreq = (HttpServletRequest)cms_req.getOriginalRequest();\n        try {                        \n            // get the CmsRequest\n            byte[] result = null;\n            com.opencms.file.CmsFile fx = req.getCmsObject().readFile(file.getAbsolutePath());            \n            // care about encoding issues\n            String dnc = A_OpenCms.getDefaultEncoding().trim();\n            String enc = cms.readProperty(fx.getAbsolutePath(), C_PROPERTY_CONTENT_ENCODING, true, dnc).trim();\n            // fake the called URI (otherwise XMLTemplate / ElementCache would not work)\n            cms.getRequestContext().setUri(fx.getAbsolutePath());            \n            cms_req.setOriginalRequest(req);\n            cms.getRequestContext().setEncoding(enc);            \n            // process the included XMLTemplate\n            result = generateOutput(cms, fx, fx.getLauncherClassname(), cms_req, m_openCms);                                    \n            // append the result to the output stream\n            if(result != null) {\n                // Encoding project:\n                // The byte array must internally be encoded in the OpenCms\n                // default encoding. It will be converted to the requested encoding \n                // on the most top-level JSP element\n                result = Encoder.changeEncoding(result, enc, dnc);\n                if (DEBUG > 1) System.out.println(\"CmsXmlTemplateLoader.service(): encoding=\" + enc + \" requestEncoding=\" + rnc + \" defaultEncoding=\" + dnc);                             \n                res.getOutputStream().write(result);\n            }        \n        }  catch (Exception e) {\n            System.err.println(\"Error in CmsXmlTemplateLoader: \" + e.toString());\n            if (DEBUG > 0) e.printStackTrace(System.err);\n            throw new ServletException(\"Error in CmsXmlTemplateLoader processing\", e);       \n        } finally {\n            // restore the context settings\n            cms_req.setOriginalRequest(originalreq);\n            cms.getRequestContext().setEncoding(rnc);\n            cms.getRequestContext().setUri(null);\n        }\n        if (DEBUG > 0) {\n            long timer2 = System.currentTimeMillis() - timer1;        \n            System.err.println(\"========== Time delivering XmlTemplate for \" + file.getAbsolutePath() + \": \" + timer2 + \"ms\");            \n        }\n    }","commit_id":"67e3d36f37d946c6f584f3b1dd730bb3ced5e764","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {\n\n\n        services.postMessage(IngestMessage.createMessage(IngestMessage.MessageType.INFO, AndroidModuleFactory.getModuleName(), \"Started {0}\"));\n\n\n        ArrayList<String> errors = new ArrayList<>();\n        progressBar.switchToDeterminate(9);\n\n        try {\n            ContactAnalyzer FindContacts = new ContactAnalyzer();\n            FindContacts.findContacts();\n            progressBar.progress(1);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Contacts\");\n        }\n        try {\n            CallLogAnalyzer FindCallLogs = new CallLogAnalyzer();\n            FindCallLogs.findCallLogs();\n            progressBar.progress(2);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Call Logs\");\n        }\n        try {\n            TextMessageAnalyzer FindTexts = new TextMessageAnalyzer();\n            FindTexts.findTexts();\n            progressBar.progress(3);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Text Messages\");\n        }\n        try {\n            TangoMessageAnalyzer FindTangoMessages = new TangoMessageAnalyzer();\n            FindTangoMessages.findTangoMessages();\n            progressBar.progress(4);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Tango Messages\");\n        }\n        try {\n            WWFMessageAnalyzer FindWWFMessages = new WWFMessageAnalyzer();\n            FindWWFMessages.findWWFMessages();\n            progressBar.progress(5);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Words with Friends Messages\");\n        }\n        try {\n            GoogleMapLocationAnalyzer FindGoogleMapLocations = new GoogleMapLocationAnalyzer();\n            FindGoogleMapLocations.findGeoLocations();\n            progressBar.progress(6);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add( \"Error getting Google Map Locations\");\n        }\n        try {\n            BrowserLocationAnalyzer FindBrowserLocations = new BrowserLocationAnalyzer();\n            FindBrowserLocations.findGeoLocations();\n            progressBar.progress(7);\n        } catch (Exception e) {\n            errors.add(\"Error getting Browser Locations\");\n        }\n        if (context.isJobCancelled()) {\n            return IngestModule.ProcessResult.OK;\n        }\n        try {\n            CacheLocationAnalyzer FindCacheLocations = new CacheLocationAnalyzer();\n            FindCacheLocations.findGeoLocations();\n            progressBar.progress(8);\n        } catch (Exception e) {\n            errors.add(\"Error getting Cache Locations\");\n        }\n        try {\n            KMLFileCreator KMLFileCreator = new KMLFileCreator();\n            KMLFileCreator.CreateKML();\n            progressBar.progress(9);\n        } catch (Exception e) {\n            errors.add(\"Error creating KML\");\n        }\n\n        // create the final message for inbox\n        StringBuilder errorMessage = new StringBuilder();\n        String errorMsgSubject;\n        IngestMessage.MessageType msgLevel = IngestMessage.MessageType.INFO;\n        if (errors.isEmpty() == false) {\n            msgLevel = IngestMessage.MessageType.ERROR;\n            errorMessage.append(\"Errors were encountered\");\n            for (String msg : errors) {\n                errorMessage.append(\"<li>\").append(msg).append(\"<\/li>\\n\"); //NON-NLS\n            }\n            errorMessage.append(\"<\/ul>\\n\"); //NON-NLS\n\n            if (errors.size() == 1) {\n                errorMsgSubject =  \"One error was found\";\n            } else {\n                errorMsgSubject = \"errors found: \" +errors.size();\n            }\n        } else {\n            errorMessage.append( \"No errors\");\n            errorMsgSubject =\"No errors\";\n        }\n        final IngestMessage msg = IngestMessage.createMessage(msgLevel, AndroidModuleFactory.getModuleName(),\"Ingest Finished\");\n        services.postMessage(msg);\n\n        return IngestModule.ProcessResult.OK;\n    }","id":9612,"modified_method":"@Override\n    public ProcessResult process(Content dataSource, DataSourceIngestModuleProgress progressBar) {\n        services.postMessage(IngestMessage.createMessage(IngestMessage.MessageType.INFO, AndroidModuleFactory.getModuleName(), \"Started {0}\"));\n\n        ArrayList<String> errors = new ArrayList<>();\n        progressBar.switchToDeterminate(9);\n\n        try {\n            ContactAnalyzer.findContacts();\n            progressBar.progress(1);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Contacts\");\n        }\n\n        try {\n            CallLogAnalyzer.findCallLogs();\n            progressBar.progress(2);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Call Logs\");\n        }\n\n        try {\n            TextMessageAnalyzer.findTexts();\n            progressBar.progress(3);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Text Messages\");\n        }\n\n        try {\n            TangoMessageAnalyzer.findTangoMessages();\n            progressBar.progress(4);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Tango Messages\");\n        }\n\n        try {\n            WWFMessageAnalyzer.findWWFMessages();\n            progressBar.progress(5);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Words with Friends Messages\");\n        }\n\n        try {\n            GoogleMapLocationAnalyzer.findGeoLocations();\n            progressBar.progress(6);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Google Map Locations\");\n        }\n\n        try {\n            BrowserLocationAnalyzer.findGeoLocations();\n            progressBar.progress(7);\n            if (context.isJobCancelled()) {\n                return IngestModule.ProcessResult.OK;\n            }\n        } catch (Exception e) {\n            errors.add(\"Error getting Browser Locations\");\n        }\n\n        try {\n            CacheLocationAnalyzer.findGeoLocations();\n            progressBar.progress(8);\n        } catch (Exception e) {\n            errors.add(\"Error getting Cache Locations\");\n        }\n\n        /* I'm not sure why we have this in here since we have a KML report module ...\n        try {\n            KMLFileCreator kMLFileCreator = new KMLFileCreator();\n            kMLFileCreator.createKml();\n            progressBar.progress(9);\n        } catch (Exception e) {\n            errors.add(\"Error creating KML\");\n        }\n         */\n\n        // create the final message for inbox\n        StringBuilder errorMessage = new StringBuilder();\n        String errorMsgSubject;\n        IngestMessage.MessageType msgLevel = IngestMessage.MessageType.INFO;\n        if (errors.isEmpty() == false) {\n            msgLevel = IngestMessage.MessageType.ERROR;\n            errorMessage.append(\"Errors were encountered\");\n            for (String msg : errors) {\n                errorMessage.append(\"<li>\").append(msg).append(\"<\/li>\\n\"); //NON-NLS\n            }\n            errorMessage.append(\"<\/ul>\\n\"); //NON-NLS\n\n            if (errors.size() == 1) {\n                errorMsgSubject = \"One error was found\";\n            } else {\n                errorMsgSubject = \"errors found: \" + errors.size();\n            }\n        } else {\n            errorMessage.append(\"No errors\");\n            errorMsgSubject = \"No errors\";\n        }\n        final IngestMessage msg = IngestMessage.createMessage(msgLevel, AndroidModuleFactory.getModuleName(), \"Ingest Finished\");\n        services.postMessage(msg);\n\n        return IngestModule.ProcessResult.OK;\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findGeoLocations() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name LIKE 'CachedGeoposition%.db'\"); //get exact file names\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    if (AF.getSize() ==0) continue;\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findGeoLocationsInDB(dbPath, fileId);\n                } catch (Exception e) {\n                   logger.log(Level.SEVERE, \"Error parsing Browser Location files\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Browser Location files\", e);\n\n        }\n    }","id":9613,"modified_method":"public static void findGeoLocations() {\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            List<AbstractFile> abstractFiles = skCase.findAllFilesWhere(\"name LIKE 'CachedGeoposition%.db'\"); //get exact file names\n\n            for (AbstractFile abstractFile : abstractFiles) {\n                try {\n                    if (abstractFile.getSize() == 0) {\n                        continue;\n                    }\n                    File jFile = new File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n                    findGeoLocationsInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Browser Location files\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Browser Location files\", e);\n\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findGeoLocationsInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error connecting to sql database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                resultSet = statement.executeQuery(\n                        \"Select timestamp, latitude, longitude, accuracy FROM CachedPosition;\");\n\n                BlackboardArtifact bba;\n                Long timestamp; // unix time\n                String latitude; \n                String longitude; \n                \n\n                while (resultSet.next()) {\n                    timestamp = Long.valueOf(resultSet.getString(\"timestamp\")) / 1000;\n                    latitude= resultSet.getString(\"latitude\");\n                    longitude = resultSet.getString(\"longitude\");\n\n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(),moduleName,latitude));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(),moduleName, longitude));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(),moduleName, timestamp));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),moduleName, \"Browser Location History\"));\n                  //  bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(),moduleName, accuracy)); \n                    \n\n                }\n\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error Putting artifacts to Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error closing database\", e);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error Putting artifacts to Blackboard\", e);\n        }\n    }","id":9614,"modified_method":"private static void findGeoLocationsInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error connecting to sql database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"Select timestamp, latitude, longitude, accuracy FROM CachedPosition;\");\n\n            while (resultSet.next()) {\n                Long timestamp = Long.valueOf(resultSet.getString(\"timestamp\")) / 1000;\n                double latitude = Double.valueOf(resultSet.getString(\"latitude\"));\n                double longitude = Double.valueOf(resultSet.getString(\"longitude\"));\n\n                BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, latitude));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, longitude));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, timestamp));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, \"Browser Location History\"));\n                //  bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(),moduleName, accuracy)); \n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error Putting artifacts to Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing database\", e);\n            }\n        }\n\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findGeoLocations() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='cache.cell'OR name='cache.wifi'\"); //get exact file names\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    if (AF.getSize() ==0) continue;\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    filePath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findGeoLocationsInFile(filePath, fileId);\n                } catch (Exception e) {\n                   logger.log(Level.SEVERE, \"Error parsing cached Location files\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding cached Location files\", e);\n        }\n    }","id":9615,"modified_method":"public static void findGeoLocations() {\n\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            List<AbstractFile> abstractFiles = skCase.findAllFilesWhere(\"name ='cache.cell' OR name='cache.wifi'\"); //get exact file names\n\n            for (AbstractFile abstractFile : abstractFiles) {\n                try {\n                    if (abstractFile.getSize() == 0) {\n                        continue;\n                    }\n                    File jFile = new File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n\n                    findGeoLocationsInFile(jFile, abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing cached Location files\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding cached Location files\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findGeoLocationsInFile(String filePath, long fId) {\n        if (filePath == null || filePath.isEmpty()) {\n            return;\n        }\n        String fileName=filePath.contains(\"cell\")? \"cache.cell\":\"cache.wifi\";\n        File file = new File(filePath); //cache.cell or cache.wifi\n        byte[] bytes; // will temporarily hold bytes to be converted into the correct data types\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            InputStream inputStream = new FileInputStream(file);\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            BlackboardArtifact bba;\n            \n            String latitude; \n            String longitude; \n            String confidence;\n            String accuracy; //measure of how accurate the gps location is.\n\n            bytes = new byte[2]; // version\n            inputStream.read(bytes);\n            bytes = new byte[2];\n            inputStream.read(bytes); //number of location entries\n            int iterations = new BigInteger(bytes).intValue();\n            \n            for (int i = 0; i < iterations; i++) { //loop through every entry\n                bytes = new byte[2];\n                inputStream.read(bytes);\n                bytes = new byte[1];\n                inputStream.read(bytes);\n                while (new BigInteger(bytes).intValue() != 0) //pass through non important values until the start of accuracy(around 7-10 bytes)\n                {\n                    inputStream.read(bytes);\n                }\n                bytes = new byte[3];\n                inputStream.read(bytes);\n                if (new BigInteger(bytes).intValue()<=0){//This refers to a location that could not be calculated.\n                    bytes = new byte[28]; //read rest of the row's bytes\n                    inputStream.read(bytes);\n                    continue;\n                } \n                accuracy=\"\"+new BigInteger(bytes).intValue(); \n                \n                bytes = new byte[4];\n                inputStream.read(bytes);\n                confidence=\"\"+new BigInteger(bytes).intValue();\n                \n                bytes = new byte[8];\n                inputStream.read(bytes);\n                latitude=\"\"+toDouble(bytes);\n                \n                bytes = new byte[8];\n                inputStream.read(bytes);\n                longitude= \"\"+toDouble(bytes);\n                \n                bytes = new byte[8];\n                inputStream.read(bytes);\n                Long timestamp = new BigInteger(bytes).longValue();\n                \n                bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(),moduleName,latitude));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(),moduleName, longitude));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(),moduleName, timestamp));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(),moduleName, fileName+\" Location History\"));\n                \n             //Not storing these for now.\n            //    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(),moduleName, accuracy));       \n            //    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT.getTypeID(),moduleName, confidence));\n            }\n                \n        }catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Cached GPS locations to Blackboard\", e);\n        }\n    }","id":9616,"modified_method":"private static void findGeoLocationsInFile(File file, AbstractFile f) {\n\n        byte[] bytes; // will temporarily hold bytes to be converted into the correct data types\n\n        try {\n            InputStream inputStream = new FileInputStream(file);\n\n            bytes = new byte[2]; // version\n            inputStream.read(bytes);\n\n            bytes = new byte[2];\n            inputStream.read(bytes); //number of location entries\n\n            int iterations = new BigInteger(bytes).intValue();\n\n            for (int i = 0; i < iterations; i++) { //loop through every entry\n                bytes = new byte[2];\n                inputStream.read(bytes);\n\n                bytes = new byte[1];\n                inputStream.read(bytes);\n                while (new BigInteger(bytes).intValue() != 0) { //pass through non important values until the start of accuracy(around 7-10 bytes)\n                    inputStream.read(bytes);\n                }\n                bytes = new byte[3];\n                inputStream.read(bytes);\n                if (new BigInteger(bytes).intValue() <= 0) {//This refers to a location that could not be calculated.\n                    bytes = new byte[28]; //read rest of the row's bytes\n                    inputStream.read(bytes);\n                    continue;\n                }\n                String accuracy = \"\" + new BigInteger(bytes).intValue();\n\n                bytes = new byte[4];\n                inputStream.read(bytes);\n                String confidence = \"\" + new BigInteger(bytes).intValue();\n\n                bytes = new byte[8];\n                inputStream.read(bytes);\n                double latitude = toDouble(bytes);\n\n                bytes = new byte[8];\n                inputStream.read(bytes);\n                double longitude = toDouble(bytes);\n\n                bytes = new byte[8];\n                inputStream.read(bytes);\n                Long timestamp = new BigInteger(bytes).longValue() / 1000;\n\n                BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, latitude));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, longitude));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, timestamp));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, file.getName() + \" Location History\"));\n\n             //Not storing these for now.\n                //    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(),moduleName, accuracy));       \n                //    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_COMMENT.getTypeID(),moduleName, confidence));\n            }\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Cached GPS locations to Blackboard\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static double toDouble(byte[] bytes) {\n    return ByteBuffer.wrap(bytes).getDouble();\n    }","id":9617,"modified_method":"private static double toDouble(byte[] bytes) {\n        return ByteBuffer.wrap(bytes).getDouble();\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findCallLogs() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='contacts2.db' OR name ='contacts.db'\"); //get exact file names \n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findCallLogsInDB(dbPath, fileId);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Call logs\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Call logs\", e);\n        }\n    }","id":9618,"modified_method":"public static void findCallLogs() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='contacts2.db' OR name ='contacts.db'\"); //get exact file names \n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile abstractFile : absFiles) {\n                try {\n                    File jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n\n                    findCallLogsInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Call logs\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Call logs\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findCallLogsInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n             logger.log(Level.SEVERE, \"Error opening database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                resultSet = statement.executeQuery(\n                        \"SELECT number,date,duration,type, name FROM calls ORDER BY date DESC;\");\n\n                BlackboardArtifact bba;\n\n                while (resultSet.next()) {\n                    // name of person dialed or called. null if unregistered\n                    String name = resultSet.getString(\"name\");\n                    String number = resultSet.getString(\"number\");\n                    //duration of call in seconds\n                    Long duration = Long.valueOf(resultSet.getString(\"duration\"));\n                    Long date = Long.valueOf(resultSet.getString(\"date\")) / 1000;\n                    \n                    String direction = \"\";\n                    switch (Integer.valueOf(resultSet.getString(\"type\"))) {\n                        case 1:\n                            direction = \"Incoming\";\n                            break;\n                        case 2:\n                            direction = \"Outgoing\";\n                            break;\n                        case 3:\n                            direction = \"Missed\";\n                            break;\n                    }\n\n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG); //create a call log and then add attributes from result set.\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(),moduleName, number));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), moduleName, date));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(), moduleName, duration+date));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, direction));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, name));\n                }\n            } catch (Exception e) {\n                 logger.log(Level.SEVERE, \"Error parsing Call logs to the Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                     logger.log(Level.SEVERE, \"Error closing the database\", e);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Call logs to the Blackboard\", e);\n        }\n    }","id":9619,"modified_method":"private static void findCallLogsInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"SELECT number,date,duration,type, name FROM calls ORDER BY date DESC;\");\n\n            BlackboardArtifact bba;\n\n            while (resultSet.next()) {\n                // name of person dialed or called. null if unregistered\n                String name = resultSet.getString(\"name\");\n                String number = resultSet.getString(\"number\");\n                //duration of call in seconds\n                Long duration = Long.valueOf(resultSet.getString(\"duration\"));\n                Long date = Long.valueOf(resultSet.getString(\"date\")) / 1000;\n\n                String direction = \"\";\n                switch (Integer.valueOf(resultSet.getString(\"type\"))) {\n                    case 1:\n                        direction = \"Incoming\";\n                        break;\n                    case 2:\n                        direction = \"Outgoing\";\n                        break;\n                    case 3:\n                        direction = \"Missed\";\n                        break;\n                }\n\n                bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG); //create a call log and then add attributes from result set.\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, number));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_START.getTypeID(), moduleName, date));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_END.getTypeID(), moduleName, duration + date));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, direction));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, name));\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Call logs to the Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing the database\", e);\n            }\n        }\n\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     *\n     * @param DatabasePath\n     * @param fId Will create artifact from a database given by the path The\n     * fileId will be the Abstract file associated with the artifacts\n     */\n    private void findContactsInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                // get display_name, mimetype(email or phone number) and data1 (phonenumber or email address depending on mimetype)\n                //sorted by name, so phonenumber/email would be consecutive for a person if they exist.\n                resultSet = statement.executeQuery(\n                        \"SELECT mimetype,data1, name_raw_contact.display_name AS display_name \\n\"\n                        + \"FROM raw_contacts JOIN contacts ON (raw_contacts.contact_id=contacts._id) \\n\"\n                        + \"JOIN raw_contacts AS name_raw_contact ON(name_raw_contact_id=name_raw_contact._id) \"\n                        + \"LEFT OUTER JOIN data ON (data.raw_contact_id=raw_contacts._id) \\n\"\n                        + \"LEFT OUTER JOIN mimetypes ON (data.mimetype_id=mimetypes._id) \\n\"\n                        + \"WHERE mimetype = 'vnd.android.cursor.item/phone_v2' OR mimetype = 'vnd.android.cursor.item/email_v2'\\n\"\n                        + \"ORDER BY name_raw_contact.display_name ASC;\");\n\n                BlackboardArtifact bba;               \n                bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n                String name;\n                String oldName = \"\";\n                String mimetype; // either phone or email\n                String data1; // the phone number or email\n                while (resultSet.next()) {\n                    name = resultSet.getString(\"display_name\");\n                    data1 = resultSet.getString(\"data1\");\n                    mimetype = resultSet.getString(\"mimetype\");\n//                    System.out.println(resultSet.getString(\"data1\") + resultSet.getString(\"mimetype\") + resultSet.getString(\"display_name\")); //Test code\n                    if (name.equals(oldName) == false) {\n                        bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n                        bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, name));\n                    }\n                    if (mimetype.equals(\"vnd.android.cursor.item/phone_v2\")) {\n                        bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, data1));\n                    } else {\n                        bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL.getTypeID(), moduleName, data1));\n                    }\n                    oldName = name;\n                }\n\n            } catch (Exception e) {\n                 logger.log(Level.SEVERE, \"Error parsing Contacts to Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                     logger.log(Level.SEVERE, \"Error closing database\", e);\n                }\n            }\n        } catch (Exception e) {\n             logger.log(Level.SEVERE, \"Error parsing Contacts to Blackboard\", e);\n        }\n\n    }","id":9620,"modified_method":"/**\n     *\n     * @param DatabasePath\n     * @param fId Will create artifact from a database given by the path The\n     * fileId will be the Abstract file associated with the artifacts\n     */\n    private static void findContactsInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            // get display_name, mimetype(email or phone number) and data1 (phonenumber or email address depending on mimetype)\n            //sorted by name, so phonenumber/email would be consecutive for a person if they exist.\n            resultSet = statement.executeQuery(\n                    \"SELECT mimetype,data1, name_raw_contact.display_name AS display_name \\n\"\n                    + \"FROM raw_contacts JOIN contacts ON (raw_contacts.contact_id=contacts._id) \\n\"\n                    + \"JOIN raw_contacts AS name_raw_contact ON(name_raw_contact_id=name_raw_contact._id) \"\n                    + \"LEFT OUTER JOIN data ON (data.raw_contact_id=raw_contacts._id) \\n\"\n                    + \"LEFT OUTER JOIN mimetypes ON (data.mimetype_id=mimetypes._id) \\n\"\n                    + \"WHERE mimetype = 'vnd.android.cursor.item/phone_v2' OR mimetype = 'vnd.android.cursor.item/email_v2'\\n\"\n                    + \"ORDER BY name_raw_contact.display_name ASC;\");\n\n            BlackboardArtifact bba;\n            bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n            String name;\n            String oldName = \"\";\n            String mimetype; // either phone or email\n            String data1; // the phone number or email\n            while (resultSet.next()) {\n                name = resultSet.getString(\"display_name\");\n                data1 = resultSet.getString(\"data1\");\n                mimetype = resultSet.getString(\"mimetype\");\n//                    System.out.println(resultSet.getString(\"data1\") + resultSet.getString(\"mimetype\") + resultSet.getString(\"display_name\")); //Test code\n                if (name.equals(oldName) == false) {\n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT);\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, name));\n                }\n                if (mimetype.equals(\"vnd.android.cursor.item/phone_v2\")) {\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, data1));\n                } else {\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL.getTypeID(), moduleName, data1));\n                }\n                oldName = name;\n            }\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Contacts to Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing database\", e);\n            }\n        }\n\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findContacts() {\n\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='contacts2.db' OR name ='contacts.db'\"); //get exact file names\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findContactsInDB(dbPath, fileId);\n                } catch (Exception e) {\n                     logger.log(Level.SEVERE, \"Error parsing Contacts\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n             logger.log(Level.SEVERE, \"Error finding Contacts\", e);\n        }\n    }","id":9621,"modified_method":"public static void findContacts() {\n\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='contacts2.db' OR name ='contacts.db'\"); //get exact file names\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    File jFile = new File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF, jFile);\n                    findContactsInDB(jFile.toString(), AF);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Contacts\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Contacts\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findGeoLocationsInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                resultSet = statement.executeQuery(\n                        \"Select time,dest_lat,dest_lng,dest_title,dest_address,source_lat,source_lng FROM destination_history;\");\n\n                BlackboardArtifact bba;\n                \n\n\n                while (resultSet.next()) {\n                    Long time = Long.valueOf(resultSet.getString(\"time\")) / 1000;\n                    String dest_lat = resultSet.getString(\"dest_lat\");\n                    String dest_lng = resultSet.getString(\"dest_lng\");\n                    String dest_title = resultSet.getString(\"dest_title\");\n                    String dest_address = resultSet.getString(\"dest_address\");\n                    String source_lat = resultSet.getString(\"source_lat\");\n                    String source_lng = resultSet.getString(\"source_lng\");\n                    \n                    //add periods 6 decimal places before the end.\n                    if(dest_lat.length()>6)\n                        dest_lat =  dest_lat.substring(0, dest_lat.length()-6) + \".\" + dest_lat.substring(dest_lat.length()-6, dest_lat.length()) ;\n                    if(dest_lng.length()>6)\n                        dest_lng =  dest_lng.substring(0, dest_lng.length()-6) + \".\" + dest_lng.substring(dest_lng.length()-6, dest_lng.length())  ;\n                    if(source_lat.length()>6)\n                        source_lat = source_lat.substring(0, source_lat.length()-6) + \".\" + source_lat.substring(source_lat.length()-6, source_lat.length()) ;\n                    if(source_lng.length()>6)\n                        source_lng = source_lng.substring(0, source_lng.length()-6) + \".\" + source_lng.substring(source_lng.length()-6, source_lng.length()) ;\n                    \n//                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);//src\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, \"Source\"));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, source_lat));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, source_lng));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, time));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION.getTypeID(), moduleName, \"Google Maps History\"));\n//\n//                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);//dest \n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, \"Destination\"));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, time));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, dest_lat));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, dest_lng));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, dest_title));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION.getTypeID(), moduleName, dest_address));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, \"Google Maps History\"));\n                 \n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE);\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, \"Destination\"));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, time));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END.getTypeID(), moduleName, dest_lat));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END.getTypeID(), moduleName, dest_lng));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START.getTypeID(), moduleName, source_lat));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START.getTypeID(), moduleName, source_lng));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, dest_title));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION.getTypeID(), moduleName, dest_address));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, \"Google Maps History\"));\n                     \n                }\n\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error parsing Google map locations to the Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error closing the database\", e);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Google map locations to the Blackboard\", e);\n        }\n    }","id":9622,"modified_method":"private static void findGeoLocationsInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"Select time,dest_lat,dest_lng,dest_title,dest_address,source_lat,source_lng FROM destination_history;\");\n\n            while (resultSet.next()) {\n                Long time = Long.valueOf(resultSet.getString(\"time\")) / 1000;\n                String dest_title = resultSet.getString(\"dest_title\");\n                String dest_address = resultSet.getString(\"dest_address\");\n                \n                double dest_lat = convertGeo(resultSet.getString(\"dest_lat\"));\n                double dest_lng = convertGeo(resultSet.getString(\"dest_lng\"));\n                double source_lat = convertGeo(resultSet.getString(\"source_lat\"));\n                double source_lng = convertGeo(resultSet.getString(\"source_lng\"));\n                \n\n//                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);//src\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, \"Source\"));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, source_lat));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, source_lng));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, time));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION.getTypeID(), moduleName, \"Google Maps History\"));\n//\n//                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT);//dest \n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, \"Destination\"));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, time));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID(), moduleName, dest_lat));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID(), moduleName, dest_lng));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, dest_title));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION.getTypeID(), moduleName, dest_address));\n//                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, \"Google Maps History\"));\n                BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE);\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, \"Destination\"));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, time));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END.getTypeID(), moduleName, dest_lat));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END.getTypeID(), moduleName, dest_lng));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START.getTypeID(), moduleName, source_lat));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START.getTypeID(), moduleName, source_lng));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, dest_title));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_LOCATION.getTypeID(), moduleName, dest_address));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), moduleName, \"Google Maps History\"));\n\n            }\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Google map locations to the Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing the database\", e);\n            }\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findGeoLocations() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='da_destination_history'\"); //get exact file name\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                   ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findGeoLocationsInDB(dbPath, fileId);\n                } catch (Exception e) {\n                     logger.log(Level.SEVERE, \"Error parsing Google map locations\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n             logger.log(Level.SEVERE, \"Error finding Google map locations\", e);\n        }\n    }","id":9623,"modified_method":"public static void findGeoLocations() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='da_destination_history'\"); //get exact file name\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile abstractFile : absFiles) {\n                try {\n                    File jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n                    findGeoLocationsInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Google map locations\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Google map locations\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void CreateKML() {\n\n        reportPath = Case.getCurrentCase().getTempDirectory() + \"ReportKML.kml\"; //NON-NLS\n        String reportPath2 = Case.getCurrentCase().getTempDirectory() + \"ReportKML.txt\"; //NON-NLS\n        currentCase = Case.getCurrentCase();\n        skCase = currentCase.getSleuthkitCase();\n\n        try {\n\n            BufferedWriter out = null;\n            try {\n                out = new BufferedWriter(new FileWriter(reportPath2));\n\n                String lat = \"\"; // temp latitude\n                String lon = \"\"; //temp longitude\n                String destlon = \"\";\n                String destlat = \"\";\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT)) {\n                    lat = \"\";\n                    lon = \"\";\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID()) //latitude\n                        {\n                            lat = attribute.getValueString();\n                        }\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueString();\n                        }\n                    }\n                    if (!lon.isEmpty() && !lat.isEmpty()) {\n                        out.write(lat + \";\" + lon + \"\\n\");\n\n                    }\n                }\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE)) {\n                    lat = \"\";\n                    lon = \"\";\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START.getTypeID()) //latitude\n                        {\n                            lat = attribute.getValueString();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END.getTypeID()) //longitude\n                        {\n                            destlat = attribute.getValueString();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueString();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END.getTypeID()) //longitude\n                        {\n                            destlon = attribute.getValueString();\n                        }\n\n                    }\n                    if (!lon.isEmpty() && !lat.isEmpty()) {\n                        out.write(lat + \";\" + lon + \"\\n\");\n                    }\n                    if (!destlon.isEmpty() && !destlat.isEmpty()) {\n                        out.write(destlat + \";\" + destlon + \"\\n\");\n\n                    }\n                }\n                out.flush();\n                out.close();\n                /*\n                 * Step 1: generate XML stub\n                 */\n                Namespace ns = Namespace.getNamespace(\"\", \"http://earth.google.com/kml/2.2\"); //NON-NLS\n                // kml\n                Element kml = new Element(\"kml\", ns); //NON-NLS\n                Document kmlDocument = new Document(kml);\n\n                // Document\n                Element document = new Element(\"Document\", ns); //NON-NLS\n                kml.addContent(document);\n\n                // name\n                Element name = new Element(\"name\", ns); //NON-NLS\n                name.setText(\"Java Generated KML Document\"); //NON-NLS\n                document.addContent(name);\n\n                /*\n                 * Step 2: add in Style elements\n                 */\n\n                // Style\n                Element style = new Element(\"Style\", ns); //NON-NLS\n                style.setAttribute(\"id\", \"redIcon\"); //NON-NLS\n                document.addContent(style);\n\n                // IconStyle\n                Element iconStyle = new Element(\"IconStyle\", ns); //NON-NLS\n                style.addContent(iconStyle);\n\n                // color\n                Element color = new Element(\"color\", ns); //NON-NLS\n                color.setText(\"990000ff\"); //NON-NLS\n                iconStyle.addContent(color);\n\n                // Icon\n                Element icon = new Element(\"Icon\", ns); //NON-NLS\n                iconStyle.addContent(icon);\n\n                // href\n                Element href = new Element(\"href\", ns); //NON-NLS\n                href.setText(\"http://www.cs.mun.ca/~hoeber/teaching/cs4767/notes/02.1-kml/circle.png\"); //NON-NLS\n                icon.addContent(href);\n                /*\n                 * Step 3: read data from source location and\n                 * add in a Placemark for each data element\n                 */\n\n                File file = new File(reportPath2);\n                BufferedReader reader;\n\n                reader = new BufferedReader(new FileReader(file));\n\n                String line = reader.readLine();\n                while (line != null) {\n                    String[] lineParts = line.split(\";\");\n                    if (lineParts.length == 2) {\n                        String coordinates = lineParts[1].trim() + \",\" + lineParts[0].trim(); //lat,lon\n                        // Placemark\n                        Element placemark = new Element(\"Placemark\", ns); //NON-NLS\n                        document.addContent(placemark);\n\n                        // styleUrl\n                        Element pmStyleUrl = new Element(\"styleUrl\", ns); //NON-NLS\n                        pmStyleUrl.setText(\"#redIcon\"); //NON-NLS\n                        placemark.addContent(pmStyleUrl);\n\n                        // Point\n                        Element pmPoint = new Element(\"Point\", ns); //NON-NLS\n                        placemark.addContent(pmPoint);\n\n                        // coordinates\n                        Element pmCoordinates = new Element(\"coordinates\", ns); //NON-NLS\n\n                        pmCoordinates.setText(coordinates);\n                        pmPoint.addContent(pmCoordinates);\n\n                    }\n                    // read the next line\n                    line = reader.readLine();\n                }\n                /*\n                 * Step 4: write the XML file\n                 */\n                try {\n                    XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());\n                    FileOutputStream writer = new FileOutputStream(reportPath);\n                    outputter.output(kmlDocument, writer);\n                    writer.close();\n                } catch (IOException ex) {\n                }\n            } catch (IOException ex) {\n            }\n        } catch (TskCoreException ex) {\n        }\n\n\n    }","id":9624,"modified_method":"public void createKml() {\n\n        reportPath = Case.getCurrentCase().getTempDirectory() + \"ReportKML.kml\"; //NON-NLS\n        String reportPath2 = Case.getCurrentCase().getTempDirectory() + \"ReportKML.txt\"; //NON-NLS\n        currentCase = Case.getCurrentCase();\n        skCase = currentCase.getSleuthkitCase();\n\n        try {\n\n            BufferedWriter out = null;\n            try {\n                out = new BufferedWriter(new FileWriter(reportPath2));\n\n                String lat = \"\"; // temp latitude\n                String lon = \"\"; //temp longitude\n                String destlon = \"\";\n                String destlat = \"\";\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT)) {\n                    lat = \"\";\n                    lon = \"\";\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID()) //latitude\n                        {\n                            lat = attribute.getValueString();\n                        }\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueString();\n                        }\n                    }\n                    if (!lon.isEmpty() && !lat.isEmpty()) {\n                        out.write(lat + \";\" + lon + \"\\n\");\n\n                    }\n                }\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE)) {\n                    lat = \"\";\n                    lon = \"\";\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START.getTypeID()) //latitude\n                        {\n                            lat = attribute.getValueString();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END.getTypeID()) //longitude\n                        {\n                            destlat = attribute.getValueString();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueString();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END.getTypeID()) //longitude\n                        {\n                            destlon = attribute.getValueString();\n                        }\n\n                    }\n                    if (!lon.isEmpty() && !lat.isEmpty()) {\n                        out.write(lat + \";\" + lon + \"\\n\");\n                    }\n                    if (!destlon.isEmpty() && !destlat.isEmpty()) {\n                        out.write(destlat + \";\" + destlon + \"\\n\");\n\n                    }\n                }\n                out.flush();\n                out.close();\n                /*\n                 * Step 1: generate XML stub\n                 */\n                Namespace ns = Namespace.getNamespace(\"\", \"http://earth.google.com/kml/2.2\"); //NON-NLS\n                // kml\n                Element kml = new Element(\"kml\", ns); //NON-NLS\n                Document kmlDocument = new Document(kml);\n\n                // Document\n                Element document = new Element(\"Document\", ns); //NON-NLS\n                kml.addContent(document);\n\n                // name\n                Element name = new Element(\"name\", ns); //NON-NLS\n                name.setText(\"Java Generated KML Document\"); //NON-NLS\n                document.addContent(name);\n\n                /*\n                 * Step 2: add in Style elements\n                 */\n                // Style\n                Element style = new Element(\"Style\", ns); //NON-NLS\n                style.setAttribute(\"id\", \"redIcon\"); //NON-NLS\n                document.addContent(style);\n\n                // IconStyle\n                Element iconStyle = new Element(\"IconStyle\", ns); //NON-NLS\n                style.addContent(iconStyle);\n\n                // color\n                Element color = new Element(\"color\", ns); //NON-NLS\n                color.setText(\"990000ff\"); //NON-NLS\n                iconStyle.addContent(color);\n\n                // Icon\n                Element icon = new Element(\"Icon\", ns); //NON-NLS\n                iconStyle.addContent(icon);\n\n                // href\n                Element href = new Element(\"href\", ns); //NON-NLS\n                href.setText(\"http://www.cs.mun.ca/~hoeber/teaching/cs4767/notes/02.1-kml/circle.png\"); //NON-NLS\n                icon.addContent(href);\n                /*\n                 * Step 3: read data from source location and\n                 * add in a Placemark for each data element\n                 */\n\n                File file = new File(reportPath2);\n                BufferedReader reader;\n\n                reader = new BufferedReader(new FileReader(file));\n\n                String line = reader.readLine();\n                while (line != null) {\n                    String[] lineParts = line.split(\";\");\n                    if (lineParts.length == 2) {\n                        String coordinates = lineParts[1].trim() + \",\" + lineParts[0].trim(); //lat,lon\n                        // Placemark\n                        Element placemark = new Element(\"Placemark\", ns); //NON-NLS\n                        document.addContent(placemark);\n\n                        // styleUrl\n                        Element pmStyleUrl = new Element(\"styleUrl\", ns); //NON-NLS\n                        pmStyleUrl.setText(\"#redIcon\"); //NON-NLS\n                        placemark.addContent(pmStyleUrl);\n\n                        // Point\n                        Element pmPoint = new Element(\"Point\", ns); //NON-NLS\n                        placemark.addContent(pmPoint);\n\n                        // coordinates\n                        Element pmCoordinates = new Element(\"coordinates\", ns); //NON-NLS\n\n                        pmCoordinates.setText(coordinates);\n                        pmPoint.addContent(pmCoordinates);\n\n                    }\n                    // read the next line\n                    line = reader.readLine();\n                }\n                /*\n                 * Step 4: write the XML file\n                 */\n                try {\n                    XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());\n                    FileOutputStream writer = new FileOutputStream(reportPath);\n                    outputter.output(kmlDocument, writer);\n                    writer.close();\n                } catch (IOException ex) {\n                }\n            } catch (IOException ex) {\n            }\n        } catch (TskCoreException ex) {\n        }\n\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Generates a body file format report for use with the MAC time tool.\n     *\n     * @param path path to save the report\n     * @param progressPanel panel to update the report's progress\n     */\n    @Override\n    public void generateReport(String path, ReportProgressPanel progressPanel) {\n\n        // Start the progress bar and setup the report\n        progressPanel.setIndeterminate(false);\n        progressPanel.start();\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportKML.progress.querying\"));\n        reportPath = path + \"ReportKML.kml\"; //NON-NLS\n        String reportPath2 = path + \"ReportKML.txt\"; //NON-NLS\n        currentCase = Case.getCurrentCase();\n        skCase = currentCase.getSleuthkitCase();\n\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportKML.progress.loading\"));\n        // Check if ingest has finished\n        String ingestwarning = \"\";\n        if (IngestManager.getInstance().isIngestRunning()) {\n            ingestwarning = NbBundle.getMessage(this.getClass(), \"ReportBodyFile.ingestWarning.text\");\n        }\n        progressPanel.setMaximumProgress(5);\n        progressPanel.increment();\n\n\n        try {\n\n            BufferedWriter out = null;\n            try {\n                out = new BufferedWriter(new FileWriter(reportPath2));\n\n                double lat = 0; // temp latitude\n                double lon = 0; //temp longitude\n                AbstractFile aFile;\n                String geoPath = \"\"; // will hold values of images to put in kml\n                String imageName = \"\";\n\n\n                File f;\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_METADATA_EXIF)) {\n                    lat = 0;\n                    lon = 0;\n                    geoPath = \"\";\n                    String extractedToPath;\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID()) //latitude\n                        {\n\n                            lat = attribute.getValueDouble();\n                        }\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueDouble();\n                        }\n                    }\n                    if (lon != 0 && lat != 0) {\n                        aFile = artifact.getSleuthkitCase().getAbstractFileById(artifact.getObjectID());\n\n                        extractedToPath = reportPath + aFile.getName();\n                        geoPath = extractedToPath;\n                        f = new File(extractedToPath);\n                        f.createNewFile();\n                        copyFileUsingStream(aFile, f);\n                        imageName = aFile.getName();\n                        out.write(String.valueOf(lat));\n                        out.write(\";\");\n                        out.write(String.valueOf(lon));\n                        out.write(\";\");\n                        out.write(String.valueOf(geoPath));\n                        out.write(\";\");\n                        out.write(String.valueOf(imageName));\n                        out.write(\"\\n\");\n                        // lat lon path name\n                    }\n                }\n                out.flush();\n                out.close();\n                progressPanel.increment();\n                /*\n                 * Step 1: generate XML stub\n                 */\n                Namespace ns = Namespace.getNamespace(\"\", \"http://earth.google.com/kml/2.2\"); //NON-NLS\n                // kml\n                Element kml = new Element(\"kml\", ns); //NON-NLS\n                Document kmlDocument = new Document(kml);\n\n                // Document\n                Element document = new Element(\"Document\", ns); //NON-NLS\n                kml.addContent(document);\n\n                // name\n                Element name = new Element(\"name\", ns); //NON-NLS\n                name.setText(\"Java Generated KML Document\"); //NON-NLS\n                document.addContent(name);\n\n                /*\n                 * Step 2: add in Style elements\n                 */\n\n                // Style\n                Element style = new Element(\"Style\", ns); //NON-NLS\n                style.setAttribute(\"id\", \"redIcon\"); //NON-NLS\n                document.addContent(style);\n\n                // IconStyle\n                Element iconStyle = new Element(\"IconStyle\", ns); //NON-NLS\n                style.addContent(iconStyle);\n\n                // color\n                Element color = new Element(\"color\", ns); //NON-NLS\n                color.setText(\"990000ff\"); //NON-NLS\n                iconStyle.addContent(color);\n\n                // Icon\n                Element icon = new Element(\"Icon\", ns); //NON-NLS\n                iconStyle.addContent(icon);\n\n                // href\n                Element href = new Element(\"href\", ns); //NON-NLS\n                href.setText(\"http://www.cs.mun.ca/~hoeber/teaching/cs4767/notes/02.1-kml/circle.png\"); //NON-NLS\n                icon.addContent(href);\n                progressPanel.increment();\n                /*\n                 * Step 3: read data from source location and\n                 * add in a Placemark for each data element\n                 */\n\n                File file = new File(reportPath2);\n                BufferedReader reader;\n\n                reader = new BufferedReader(new FileReader(file));\n\n                String line = reader.readLine();\n                while (line != null) {\n                    String[] lineParts = line.split(\";\");\n                    if (lineParts.length == 4) {\n                        String coordinates = lineParts[1].trim() + \",\" + lineParts[0].trim(); //lat,lon\n                        // Placemark\n                        Element placemark = new Element(\"Placemark\", ns); //NON-NLS\n                        document.addContent(placemark);\n\n                        // name\n                        Element pmName = new Element(\"name\", ns); //NON-NLS\n                        pmName.setText(lineParts[3].trim());\n                        placemark.addContent(pmName);\n\n                        // Path\n                        Element pmPath = new Element(\"Path\", ns); //NON-NLS\n                        pmPath.setText(lineParts[2].trim());\n                        placemark.addContent(pmPath);\n\n                        // description\n                        Element pmDescription = new Element(\"description\", ns); //NON-NLS\n                        String xml = \"<![CDATA[  \\n\" + \" <img src='file:///\" + lineParts[2].trim() + \"' width='400' /><br/&gt;  \\n\"; //NON-NLS\n                        StringEscapeUtils.unescapeXml(xml);\n                        pmDescription.setText(xml);\n                        placemark.addContent(pmDescription);\n\n                        // styleUrl\n                        Element pmStyleUrl = new Element(\"styleUrl\", ns); //NON-NLS\n                        pmStyleUrl.setText(\"#redIcon\"); //NON-NLS\n                        placemark.addContent(pmStyleUrl);\n\n                        // Point\n                        Element pmPoint = new Element(\"Point\", ns); //NON-NLS\n                        placemark.addContent(pmPoint);\n\n                        // coordinates\n                        Element pmCoordinates = new Element(\"coordinates\", ns); //NON-NLS\n\n                        pmCoordinates.setText(coordinates);\n                        pmPoint.addContent(pmCoordinates);\n\n                    }\n                    // read the next line\n                    line = reader.readLine();\n                }\n                progressPanel.increment();\n                /*\n                 * Step 4: write the XML file\n                 */\n                try {\n                    XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());\n                    FileOutputStream writer = new FileOutputStream(reportPath);\n                    outputter.output(kmlDocument, writer);\n                    writer.close();\n                    Case.getCurrentCase().addReport(reportPath, NbBundle.getMessage(this.getClass(),\n                                                                                    \"ReportKML.genReport.srcModuleName.text\"), \"\");\n                } catch (IOException ex) {\n                    logger.log(Level.WARNING, \"Could not write the KML file.\", ex); //NON-NLS\n                } catch (TskCoreException ex) {\n                    String errorMessage = String.format(\"Error adding %s to case as a report\", reportPath); //NON-NLS\n                    logger.log(Level.SEVERE, errorMessage, ex);\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Could not write the KML report.\", ex); //NON-NLS\n            }\n            progressPanel.complete();\n        } catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Failed to get the unique path.\", ex); //NON-NLS\n        }\n        progressPanel.increment();\n        progressPanel.complete();\n    }","id":9625,"modified_method":"/**\n     * Generates a body file format report for use with the MAC time tool.\n     *\n     * @param path path to save the report\n     * @param progressPanel panel to update the report's progress\n     */\n    @Override\n    public void generateReport(String path, ReportProgressPanel progressPanel) {\n\n        // Start the progress bar and setup the report\n        progressPanel.setIndeterminate(false);\n        progressPanel.start();\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportKML.progress.querying\"));\n        reportPath = path + \"ReportKML.kml\"; //NON-NLS\n        String reportPath2 = path + \"ReportKML.txt\"; //NON-NLS\n        currentCase = Case.getCurrentCase();\n        skCase = currentCase.getSleuthkitCase();\n\n        progressPanel.updateStatusLabel(NbBundle.getMessage(this.getClass(), \"ReportKML.progress.loading\"));\n        // Check if ingest has finished\n        String ingestwarning = \"\";\n        if (IngestManager.getInstance().isIngestRunning()) {\n            ingestwarning = NbBundle.getMessage(this.getClass(), \"ReportBodyFile.ingestWarning.text\");\n        }\n        progressPanel.setMaximumProgress(5);\n        progressPanel.increment();\n\n\n        try {\n\n            BufferedWriter out = null;\n            try {\n                out = new BufferedWriter(new FileWriter(reportPath2));\n\n                double lat = 0; // temp latitude\n                double lon = 0; //temp longitude\n                AbstractFile aFile;\n                String geoPath = \"\"; // will hold values of images to put in kml\n                String imageName = \"\";\n\n\n                File f;\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_METADATA_EXIF)) {\n                    lat = 0;\n                    lon = 0;\n                    geoPath = \"\";\n                    String extractedToPath;\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID()) //latitude\n                        {\n\n                            lat = attribute.getValueDouble();\n                        }\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueDouble();\n                        }\n                    }\n                    if (lon != 0 && lat != 0) {\n                        aFile = artifact.getSleuthkitCase().getAbstractFileById(artifact.getObjectID());\n\n                        extractedToPath = reportPath + aFile.getName();\n                        geoPath = extractedToPath;\n                        f = new File(extractedToPath);\n                        f.createNewFile();\n                        copyFileUsingStream(aFile, f);\n                        imageName = aFile.getName();\n                        out.write(String.valueOf(lat));\n                        out.write(\";\");\n                        out.write(String.valueOf(lon));\n                        out.write(\";\");\n                        out.write(String.valueOf(geoPath));\n                        out.write(\";\");\n                        out.write(String.valueOf(imageName));\n                        out.write(\"\\n\");\n                        // lat lon path name\n                    }\n                }\n                \n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_TRACKPOINT)) {\n                    lat = 0;\n                    lon = 0;\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID()) //latitude\n                        {\n                            lat = attribute.getValueDouble();\n                        }\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueDouble();\n                        }\n                    }\n                    if (lon != 0 && lat != 0) {\n                        out.write(lat + \";\" + lon + \"\\n\");\n                    }\n                }\n                for (BlackboardArtifact artifact : skCase.getBlackboardArtifacts(BlackboardArtifact.ARTIFACT_TYPE.TSK_GPS_ROUTE)) {\n                    lat = 0;\n                    lon = 0;\n                    double destlat = 0;\n                    double destlon = 0;\n                    String name = \"\";\n                    for (BlackboardAttribute attribute : artifact.getAttributes()) {\n                        if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_START.getTypeID()) //latitude\n                        {\n                            lat = attribute.getValueDouble();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE_END.getTypeID()) //longitude\n                        {\n                            destlat = attribute.getValueDouble();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_START.getTypeID()) //longitude\n                        {\n                            lon = attribute.getValueDouble();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE_END.getTypeID()) //longitude \n                        {\n                            destlon = attribute.getValueDouble();\n                        } else if (attribute.getAttributeTypeID() == BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID()) //longitude \n                        {\n                            name = attribute.getValueString();\n                        }\n\n                    }\n                    if (lon != 0 && lat != 0) {\n                        out.write(lat + \";\" + lon + \";;\" + name + \"\\n\");\n                    }\n                    if (destlat != 0 && destlon != 0) {\n                        out.write(destlat + \";\" + destlon + \";;\" + name + \"\\n\");\n                    }\n                }\n                \n                out.flush();\n                out.close();\n                \n                progressPanel.increment();\n                /*\n                 * Step 1: generate XML stub\n                 */\n                Namespace ns = Namespace.getNamespace(\"\", \"http://earth.google.com/kml/2.2\"); //NON-NLS\n                // kml\n                Element kml = new Element(\"kml\", ns); //NON-NLS\n                Document kmlDocument = new Document(kml);\n\n                // Document\n                Element document = new Element(\"Document\", ns); //NON-NLS\n                kml.addContent(document);\n\n                // name\n                Element name = new Element(\"name\", ns); //NON-NLS\n                name.setText(\"Java Generated KML Document\"); //NON-NLS\n                document.addContent(name);\n\n                /*\n                 * Step 2: add in Style elements\n                 */\n\n                // Style\n                Element style = new Element(\"Style\", ns); //NON-NLS\n                style.setAttribute(\"id\", \"redIcon\"); //NON-NLS\n                document.addContent(style);\n\n                // IconStyle\n                Element iconStyle = new Element(\"IconStyle\", ns); //NON-NLS\n                style.addContent(iconStyle);\n\n                // color\n                Element color = new Element(\"color\", ns); //NON-NLS\n                color.setText(\"990000ff\"); //NON-NLS\n                iconStyle.addContent(color);\n\n                // Icon\n                Element icon = new Element(\"Icon\", ns); //NON-NLS\n                iconStyle.addContent(icon);\n\n                // href\n                Element href = new Element(\"href\", ns); //NON-NLS\n                href.setText(\"http://www.cs.mun.ca/~hoeber/teaching/cs4767/notes/02.1-kml/circle.png\"); //NON-NLS\n                icon.addContent(href);\n                progressPanel.increment();\n                /*\n                 * Step 3: read data from source location and\n                 * add in a Placemark for each data element\n                 */\n\n                File file = new File(reportPath2);\n                BufferedReader reader;\n\n                reader = new BufferedReader(new FileReader(file));\n\n                String line = reader.readLine();\n                while (line != null) {\n                    String[] lineParts = line.split(\";\");\n                    if (lineParts.length == 4) {\n                        String coordinates = lineParts[1].trim() + \",\" + lineParts[0].trim(); //lat,lon\n                        // Placemark\n                        Element placemark = new Element(\"Placemark\", ns); //NON-NLS\n                        document.addContent(placemark);\n\n                        // name\n                        Element pmName = new Element(\"name\", ns); //NON-NLS\n                        pmName.setText(lineParts[3].trim());\n                        placemark.addContent(pmName);\n\n                        // Path\n                        Element pmPath = new Element(\"Path\", ns); //NON-NLS\n                        pmPath.setText(lineParts[2].trim());\n                        placemark.addContent(pmPath);\n\n                        // description\n                        Element pmDescription = new Element(\"description\", ns); //NON-NLS\n                        String xml = \"<![CDATA[  \\n\" + \" <img src='file:///\" + lineParts[2].trim() + \"' width='400' /><br/&gt;  \\n\"; //NON-NLS\n                        StringEscapeUtils.unescapeXml(xml);\n                        pmDescription.setText(xml);\n                        placemark.addContent(pmDescription);\n\n                        // styleUrl\n                        Element pmStyleUrl = new Element(\"styleUrl\", ns); //NON-NLS\n                        pmStyleUrl.setText(\"#redIcon\"); //NON-NLS\n                        placemark.addContent(pmStyleUrl);\n\n                        // Point\n                        Element pmPoint = new Element(\"Point\", ns); //NON-NLS\n                        placemark.addContent(pmPoint);\n\n                        // coordinates\n                        Element pmCoordinates = new Element(\"coordinates\", ns); //NON-NLS\n\n                        pmCoordinates.setText(coordinates);\n                        pmPoint.addContent(pmCoordinates);\n\n                    }\n                    // read the next line\n                    line = reader.readLine();\n                }\n                progressPanel.increment();\n                /*\n                 * Step 4: write the XML file\n                 */\n                try {\n                    XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());\n                    FileOutputStream writer = new FileOutputStream(reportPath);\n                    outputter.output(kmlDocument, writer);\n                    writer.close();\n                    Case.getCurrentCase().addReport(reportPath, NbBundle.getMessage(this.getClass(),\n                                                                                    \"ReportKML.genReport.srcModuleName.text\"), \"\");\n                } catch (IOException ex) {\n                    logger.log(Level.WARNING, \"Could not write the KML file.\", ex); //NON-NLS\n                } catch (TskCoreException ex) {\n                    String errorMessage = String.format(\"Error adding %s to case as a report\", reportPath); //NON-NLS\n                    logger.log(Level.SEVERE, errorMessage, ex);\n                }\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Could not write the KML report.\", ex); //NON-NLS\n            }\n            progressPanel.complete();\n        } catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Failed to get the unique path.\", ex); //NON-NLS\n        }\n        progressPanel.increment();\n        progressPanel.complete();\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findTangoMessages() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='tc.db' \"); //get exact file names\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findTangoMessagesInDB(dbPath, fileId);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Tango messages\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Tango messages\", e);\n        }\n        \n    }","id":9626,"modified_method":"public static void findTangoMessages() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='tc.db' \"); //get exact file names\n            for (AbstractFile abstractFile : absFiles) {\n                try {\n                    File jFile = new File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n                    findTangoMessagesInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing Tango messages\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding Tango messages\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findTangoMessagesInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                resultSet = statement.executeQuery(\n                        \"Select conv_id, create_time,direction,payload FROM messages ORDER BY create_time DESC;\");\n\n                BlackboardArtifact bba;\n                String conv_id; // seems to wrap around the message found in payload after decoding from base-64\n                String direction; // 1 incoming, 2 outgoing\n                String payload; // seems to be a base64 message wrapped by the conv_id\n              \n\n                while (resultSet.next()) {\n                    conv_id = resultSet.getString(\"conv_id\");\n                    Long create_time = Long.valueOf(resultSet.getString(\"create_time\")) / 1000;\n                    direction = resultSet.getString(\"direction\");\n                    payload = resultSet.getString(\"payload\");\n\n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE); //create a call log and then add attributes from result set.\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, create_time));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, direction));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), moduleName, decodeMessage(conv_id,payload)));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE.getTypeID(), moduleName,\"Tango Message\" ));\n\n                }\n\n            } catch (Exception e) {\n               logger.log(Level.SEVERE, \"Error parsing Tango messages to the Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error closing database\", e);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Tango messages to the Blackboard\", e);\n        }\n    }","id":9627,"modified_method":"private static void findTangoMessagesInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"Select conv_id, create_time,direction,payload FROM messages ORDER BY create_time DESC;\");\n\n            String conv_id; // seems to wrap around the message found in payload after decoding from base-64\n            String direction; // 1 incoming, 2 outgoing\n            String payload; // seems to be a base64 message wrapped by the conv_id\n\n            while (resultSet.next()) {\n                conv_id = resultSet.getString(\"conv_id\");\n                Long create_time = Long.valueOf(resultSet.getString(\"create_time\")) / 1000;\n                if (resultSet.getString(\"direction\").equals(\"1\")) {\n                    direction = \"Incoming\";\n                } else {\n                    direction = \"Outgoing\";\n                }\n                payload = resultSet.getString(\"payload\");\n\n                BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE); //create a call log and then add attributes from result set.\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, create_time));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, direction));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), moduleName, decodeMessage(conv_id, payload)));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE.getTypeID(), moduleName, \"Tango Message\"));\n\n            }\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing Tango messages to the Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing database\", e);\n            }\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findTextsInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                resultSet = statement.executeQuery(\n                        \"Select address,date,type,subject,body FROM sms;\");\n\n                BlackboardArtifact bba;               \n                String address; // may be phone number, or other addresses\n                \n                String type; // message received in inbox = 1, message sent = 2\n                String subject;//message subject\n                String body; //message body\n                while (resultSet.next()) {\n                    address = resultSet.getString(\"address\");\n                    Long date = Long.valueOf(resultSet.getString(\"date\")) / 1000;\n                    type = resultSet.getString(\"type\");\n                    subject = resultSet.getString(\"subject\");\n                    body = resultSet.getString(\"body\");\n                    \n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE); //create Message artifact and then add attributes from result set.\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, address));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, date));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, type));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID(), moduleName, subject));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), moduleName, body));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE.getTypeID(), moduleName,\"SMS Message\" ));\n\n                }\n\n            } catch (Exception e) {\n               logger.log(Level.SEVERE, \"Error parsing text messages to Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                   logger.log(Level.SEVERE, \"Error closing database\", e);\n                }\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing text messages to Blackboard\", e);\n        }\n\n    }","id":9628,"modified_method":"private static void findTextsInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"Select address,date,type,subject,body FROM sms;\");\n\n            String address; // may be phone number, or other addresses\n\n            String direction; // message received in inbox = 1, message sent = 2\n            String subject;//message subject\n            String body; //message body\n            while (resultSet.next()) {\n                address = resultSet.getString(\"address\");\n                Long date = Long.valueOf(resultSet.getString(\"date\")) / 1000;\n                if (resultSet.getString(\"type\").equals(\"1\")) {\n                    direction = \"Incoming\";\n                } else {\n                    direction = \"Outgoing\";\n                }\n                subject = resultSet.getString(\"subject\");\n                body = resultSet.getString(\"body\");\n\n                BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE); //create Message artifact and then add attributes from result set.\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER.getTypeID(), moduleName, address));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, date));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DIRECTION.getTypeID(), moduleName, direction));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SUBJECT.getTypeID(), moduleName, subject));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), moduleName, body));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE.getTypeID(), moduleName, \"SMS Message\"));\n            }\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing text messages to Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing database\", e);\n            }\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void findTexts() {\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='mmssms.db'\"); //get exact file name\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findTextsInDB(dbPath, fileId);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing text messages\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding text messages\", e);\n        }\n    }","id":9629,"modified_method":"public static void findTexts() {\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            List<AbstractFile> absFiles = skCase.findAllFilesWhere(\"name ='mmssms.db'\"); //get exact file name\n\n            for (AbstractFile abstractFile : absFiles) {\n                try {\n                    File jFile = new File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n                    findTextsInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing text messages\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding text messages\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void findWWFMessages() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='WordsFramework' \"); //get exact file names\n            if (absFiles.isEmpty()) {\n                return;\n            }\n            for (AbstractFile AF : absFiles) {\n                try {\n                    jFile = new java.io.File(Case.getCurrentCase().getTempDirectory(), AF.getName());\n                    ContentUtils.writeToFile(AF,jFile);\n                    dbPath = jFile.toString(); //path of file as string\n                    fileId = AF.getId();\n                    findWWFMessagesInDB(dbPath, fileId);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing WWF messages\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding WWF messages\", e);\n        }\n    }","id":9630,"modified_method":"public static void findWWFMessages() {\n        List<AbstractFile> absFiles;\n        try {\n            SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n            absFiles = skCase.findAllFilesWhere(\"name ='WordsFramework' \"); //get exact file names\n\n            for (AbstractFile abstractFile : absFiles) {\n                try {\n                    File jFile = new File(Case.getCurrentCase().getTempDirectory(), abstractFile.getName());\n                    ContentUtils.writeToFile(abstractFile, jFile);\n\n                    findWWFMessagesInDB(jFile.toString(), abstractFile);\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Error parsing WWF messages\", e);\n                }\n            }\n        } catch (TskCoreException e) {\n            logger.log(Level.SEVERE, \"Error finding WWF messages\", e);\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void findWWFMessagesInDB(String DatabasePath, long fId) {\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n             logger.log(Level.SEVERE, \"Error opening database\", e);\n        }\n\n        Case currentCase = Case.getCurrentCase();\n        SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        try {\n            AbstractFile f = skCase.getAbstractFileById(fId);\n            try {\n                resultSet = statement.executeQuery(\n                        \"SELECT message,created_at,user_id,game_id FROM chat_messages ORDER BY game_id DESC, created_at DESC;\");\n\n                BlackboardArtifact bba;\n                String message; // WWF Message\n                String user_id; // the ID of the user who sent the message.\n                String game_id; // ID of the game which the the message was sent.\n              \n\n                while (resultSet.next()) {\n                    message = resultSet.getString(\"message\");\n                    Long created_at = Long.valueOf(resultSet.getString(\"created_at\")) / 1000;\n                    user_id = resultSet.getString(\"user_id\");\n                    game_id = resultSet.getString(\"game_id\");\n\n                    bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE); //create a call log and then add attributes from result set.\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, created_at));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, user_id));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MSG_ID.getTypeID(), moduleName, game_id));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), moduleName,message));\n                    bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE.getTypeID(), moduleName,\"Words With Friends Message\" ));\n                }\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error parsing WWF messages to the Blackboard\", e);\n            } finally {\n                try {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                } catch (Exception e) {\n                     logger.log(Level.SEVERE, \"Error closing database\", e);\n                }\n            }\n        } catch (Exception e) {\n             logger.log(Level.SEVERE, \"Error parsing WWF messages to the Blackboard\", e);\n        }\n    }","id":9631,"modified_method":"private static void findWWFMessagesInDB(String DatabasePath, AbstractFile f) {\n        Connection connection = null;\n        ResultSet resultSet = null;\n        Statement statement = null;\n\n        if (DatabasePath == null || DatabasePath.isEmpty()) {\n            return;\n        }\n        try {\n            Class.forName(\"org.sqlite.JDBC\"); //load JDBC driver\n            connection = DriverManager.getConnection(\"jdbc:sqlite:\" + DatabasePath);\n            statement = connection.createStatement();\n        } catch (ClassNotFoundException | SQLException e) {\n            logger.log(Level.SEVERE, \"Error opening database\", e);\n            return;\n        }\n\n        try {\n            resultSet = statement.executeQuery(\n                    \"SELECT message,created_at,user_id,game_id FROM chat_messages ORDER BY game_id DESC, created_at DESC;\");\n\n            String message; // WWF Message\n            String user_id; // the ID of the user who sent the message.\n            String game_id; // ID of the game which the the message was sent.\n\n            while (resultSet.next()) {\n                message = resultSet.getString(\"message\");\n                Long created_at = Long.valueOf(resultSet.getString(\"created_at\")) / 1000;\n                user_id = resultSet.getString(\"user_id\");\n                game_id = resultSet.getString(\"game_id\");\n\n                BlackboardArtifact bba = f.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE); //create a call log and then add attributes from result set.\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), moduleName, created_at));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), moduleName, user_id));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MSG_ID.getTypeID(), moduleName, game_id));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID(), moduleName, message));\n                bba.addAttribute(new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_MESSAGE_TYPE.getTypeID(), moduleName, \"Words With Friends Message\"));\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error parsing WWF messages to the Blackboard\", e);\n        } finally {\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n                statement.close();\n                connection.close();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error closing database\", e);\n            }\n        }\n    }","commit_id":"4bc93248a45099b5e5876dae86ee30aa4f7eb2bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void testJob( Job<Void> job ) throws Exception\n    {\n        SingleJvmTesting single = new SingleJvmTesting();\n        single.initializeDbs( 1 );\n        time( \"No HA\", executeOnMaster( single, job ) );\n        single.shutdownDbs();\n        single.initializeDbs( 1 );\n        time( \"Single JVM HA\", executeOnSlave( single, job ) );\n        single.shutdownDbs();\n        \n        MultiJvmTesting multi = new MultiJvmTesting();\n        multi.initializeDbs( 1 );\n        time( \"Multi JVM HA\", executeOnSlave( multi, job ) );\n        multi.shutdownDbs();\n        \n        MultiJvmWithZooKeeperTesting multiZoo = new MultiJvmWithZooKeeperTesting();\n        MultiJvmWithZooKeeperTesting.startZooKeeperCluster();\n        multiZoo.initializeDbs( 1 );\n        time( \"Multi JVM HA with ZooKeeper\", executeOnSlave( multiZoo, job ) );\n        multiZoo.shutdownDbs();\n        MultiJvmWithZooKeeperTesting.shutdownZooKeeperCluster();\n    }","id":9632,"modified_method":"private void testJob( Job<Void> job ) throws Exception\n    {\n        final boolean noHa = doTest( \"NO_HA\" );\n        final boolean singleJvm = doTest( \"SINGLE_JVM\" );\n        if ( noHa || singleJvm )\n        {\n            SingleJvmTesting single = new SingleJvmTesting();\n            if ( noHa )\n            {\n                single.initializeDbs( 1 );\n                time( \"No HA\", executeOnMaster( single, job ) );\n                single.shutdownDbs();\n            }\n            if ( singleJvm )\n            {\n                single.initializeDbs( 1 );\n                time( \"Single JVM HA\", executeOnSlave( single, job ) );\n                single.shutdownDbs();\n            }\n        }\n\n        if ( doTest( \"MULTI_JVM\" ) )\n        {\n            MultiJvmTesting multi = new MultiJvmTesting();\n            multi.initializeDbs( 1 );\n            time( \"Multi JVM HA\", executeOnSlave( multi, job ) );\n            multi.shutdownDbs();\n        }\n        if ( doTest( \"FULL_HA\" ) )\n        {\n            MultiJvmWithZooKeeperTesting multiZoo = new MultiJvmWithZooKeeperTesting();\n            MultiJvmWithZooKeeperTesting.startZooKeeperCluster();\n            multiZoo.initializeDbs( 1 );\n            time( \"Multi JVM HA with ZooKeeper\", executeOnSlave( multiZoo, job ) );\n            multiZoo.shutdownDbs();\n            MultiJvmWithZooKeeperTesting.shutdownZooKeeperCluster();\n        }\n    }","commit_id":"c494ca3ce901e849321bcfa48b481a1d7a614eb8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testJob( Job<Void> job ) throws Exception\n    {\n        SingleJvmTesting single = new SingleJvmTesting();\n        single.initializeDbs( 1 );\n        time( \"No HA\", executeOnMaster( single, job ) );\n        single.shutdownDbs();\n        single.initializeDbs( 1 );\n        time( \"Single JVM HA\", executeOnSlave( single, job ) );\n        single.shutdownDbs();\n        \n        MultiJvmTesting multi = new MultiJvmTesting();\n        multi.initializeDbs( 1 );\n        time( \"Multi JVM HA\", executeOnSlave( multi, job ) );\n        multi.shutdownDbs();\n        \n        MultiJvmWithZooKeeperTesting multiZoo = new MultiJvmWithZooKeeperTesting();\n        MultiJvmWithZooKeeperTesting.startZooKeeperCluster();\n        multiZoo.initializeDbs( 1 );\n        time( \"Multi JVM HA with ZooKeeper\", executeOnSlave( multiZoo, job ) );\n        multiZoo.shutdownDbs();\n        MultiJvmWithZooKeeperTesting.shutdownZooKeeperCluster();\n    }","id":9633,"modified_method":"private void testJob( Job<Void> job ) throws Exception\n    {\n        final boolean noHa = doTest( \"NO_HA\" );\n        final boolean singleJvm = doTest( \"SINGLE_JVM\" );\n        if ( noHa || singleJvm )\n        {\n            SingleJvmTesting single = new SingleJvmTesting();\n            if ( noHa )\n            {\n                single.initializeDbs( 1 );\n                time( \"No HA\", executeOnMaster( single, job ) );\n                single.shutdownDbs();\n            }\n            if ( singleJvm )\n            {\n                single.initializeDbs( 1 );\n                time( \"Single JVM HA\", executeOnSlave( single, job ) );\n                single.shutdownDbs();\n            }\n        }\n\n        if ( doTest( \"MULTI_JVM\" ) )\n        {\n            MultiJvmTesting multi = new MultiJvmTesting();\n            multi.initializeDbs( 1 );\n            time( \"Multi JVM HA\", executeOnSlave( multi, job ) );\n            multi.shutdownDbs();\n        }\n        if ( doTest( \"FULL_HA\" ) )\n        {\n            MultiJvmWithZooKeeperTesting multiZoo = new MultiJvmWithZooKeeperTesting();\n            MultiJvmWithZooKeeperTesting.startZooKeeperCluster();\n            multiZoo.initializeDbs( 1 );\n            time( \"Multi JVM HA with ZooKeeper\", executeOnSlave( multiZoo, job ) );\n            multiZoo.shutdownDbs();\n            MultiJvmWithZooKeeperTesting.shutdownZooKeeperCluster();\n        }\n    }","commit_id":"7d3c4f78fea2e733277f374832a2d71f20a8f5b9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void testJob( Job<Void> job ) throws Exception\n    {\n        SingleJvmTesting single = new SingleJvmTesting();\n        single.initializeDbs( 1 );\n        time( \"No HA\", executeOnMaster( single, job ) );\n        single.shutdownDbs();\n        single.initializeDbs( 1 );\n        time( \"Single JVM HA\", executeOnSlave( single, job ) );\n        single.shutdownDbs();\n        \n        MultiJvmTesting multi = new MultiJvmTesting();\n        multi.initializeDbs( 1 );\n        time( \"Multi JVM HA\", executeOnSlave( multi, job ) );\n        multi.shutdownDbs();\n        \n        MultiJvmWithZooKeeperTesting multiZoo = new MultiJvmWithZooKeeperTesting();\n        MultiJvmWithZooKeeperTesting.startZooKeeperCluster();\n        multiZoo.initializeDbs( 1 );\n        time( \"Multi JVM HA with ZooKeeper\", executeOnSlave( multiZoo, job ) );\n        multiZoo.shutdownDbs();\n        MultiJvmWithZooKeeperTesting.shutdownZooKeeperCluster();\n    }","id":9634,"modified_method":"private void testJob( Job<Void> job ) throws Exception\n    {\n        final boolean noHa = doTest( \"NO_HA\" );\n        final boolean singleJvm = doTest( \"SINGLE_JVM\" );\n        if ( noHa || singleJvm )\n        {\n            SingleJvmTesting single = new SingleJvmTesting();\n            if ( noHa )\n            {\n                single.initializeDbs( 1 );\n                time( \"No HA\", executeOnMaster( single, job ) );\n                single.shutdownDbs();\n            }\n            if ( singleJvm )\n            {\n                single.initializeDbs( 1 );\n                time( \"Single JVM HA\", executeOnSlave( single, job ) );\n                single.shutdownDbs();\n            }\n        }\n\n        if ( doTest( \"MULTI_JVM\" ) )\n        {\n            MultiJvmTesting multi = new MultiJvmTesting();\n            multi.initializeDbs( 1 );\n            time( \"Multi JVM HA\", executeOnSlave( multi, job ) );\n            multi.shutdownDbs();\n        }\n        if ( doTest( \"FULL_HA\" ) )\n        {\n            MultiJvmWithZooKeeperTesting multiZoo = new MultiJvmWithZooKeeperTesting();\n            MultiJvmWithZooKeeperTesting.startZooKeeperCluster();\n            multiZoo.initializeDbs( 1 );\n            time( \"Multi JVM HA with ZooKeeper\", executeOnSlave( multiZoo, job ) );\n            multiZoo.shutdownDbs();\n            MultiJvmWithZooKeeperTesting.shutdownZooKeeperCluster();\n        }\n    }","commit_id":"010606af17c1f1dd4d14cd44ebca56374b9b35d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public MockHost getHost(String guid) {\n        return _mockHostDao.findByGuid(guid);\n    }","id":9635,"modified_method":"@Override\n\tpublic MockHost getHost(String guid) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockHost _host = _mockHostDao.findByGuid(guid);\n\t\t\ttxn.commit();\n\t\t\tif (_host != null) {\n\t\t\t\treturn _host;\n\t\t\t} else {\n\t\t\t\ts_logger.error(\"Host with guid \" + guid + \" was not found\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to get host \" + guid + \" due to \" + ex.getMessage(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n        @DB\n        public void run() {\n            if (this.mode.equalsIgnoreCase(\"Stop\")) {\n                MockHost host = _mockHostDao.findByVmId(this.vmId);\n                if (host != null) {\n                    String guid = host.getGuid();\n                    if (guid != null) {\n                        AgentResourceBase res = _resources.get(guid);\n                        if (res != null) {\n                            res.stop();\n                            _resources.remove(guid);\n                        }\n                    }\n                }\n                return;\n            }\n            \n            String resource = null;\n            if (vmType.equalsIgnoreCase(\"secstorage\")) {\n                resource = \"com.cloud.agent.AgentStorageResource\";\n            }\n            MockHostVO mockHost = new MockHostVO();\n            mockHost.setDataCenterId(this.dcId);\n            mockHost.setPodId(this.podId);\n            mockHost.setCpuCount(DEFAULT_HOST_CPU_CORES);\n            mockHost.setCpuSpeed(DEFAULT_HOST_SPEED_MHZ);\n            mockHost.setMemorySize(DEFAULT_HOST_MEM_SIZE);\n            mockHost.setGuid(this.guid);\n            mockHost.setName(name);\n            mockHost.setPrivateIpAddress(this.privateIpAddress);\n            mockHost.setPublicIpAddress(this.privateIpAddress);\n            mockHost.setStorageIpAddress(this.privateIpAddress);\n            mockHost.setPrivateMacAddress(this.privateMacAddress);\n            mockHost.setPublicMacAddress(this.privateMacAddress);\n            mockHost.setStorageMacAddress(this.privateMacAddress);\n            mockHost.setVersion(this.getClass().getPackage().getImplementationVersion());\n            mockHost.setResource(resource);\n            mockHost.setVmId(vmId);\n            mockHost = _mockHostDao.persist(mockHost);\n           \n            if (vmType.equalsIgnoreCase(\"secstorage\")) {\n                AgentStorageResource storageResource = new AgentStorageResource();\n                try {\n                    Map<String, Object> params =  new HashMap<String, Object>();\n                    Map<String, String> details = new HashMap<String, String>();\n                    params.put(\"guid\", this.guid);\n                    details.put(\"guid\", this.guid);\n                    storageResource.configure(\"secondaryStorage\", params);\n                    storageResource.start();\n                    //on the simulator the ssvm is as good as a direct agent\n                    _resourceMgr.addHost(mockHost.getDataCenterId(), storageResource, Host.Type.SecondaryStorageVM, details);\n                    _resources.put(this.guid, storageResource);\n                } catch (ConfigurationException e) {\n                    s_logger.debug(\"Failed to load secondary storage resource: \" + e.toString());\n                    return;\n                }\n            }            \n        }","id":9636,"modified_method":"@Override\n\t\t@DB\n\t\tpublic void run() {\n\n\t\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\tif (this.mode.equalsIgnoreCase(\"Stop\")) {\n\t\t\t\t\ttxn.start();\n\t\t\t\t\tMockHost host = _mockHostDao.findByVmId(this.vmId);\n\t\t\t\t\tif (host != null) {\n\t\t\t\t\t\tString guid = host.getGuid();\n\t\t\t\t\t\tif (guid != null) {\n\t\t\t\t\t\t\tAgentResourceBase res = _resources.get(guid);\n\t\t\t\t\t\t\tif (res != null) {\n\t\t\t\t\t\t\t\tres.stop();\n\t\t\t\t\t\t\t\t_resources.remove(guid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttxn.commit();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Unable to get host \" + guid + \" due to \" + ex.getMessage(), ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\n\t\t\tString resource = null;\n\t\t\tif (vmType.equalsIgnoreCase(\"secstorage\")) {\n\t\t\t\tresource = \"com.cloud.agent.AgentStorageResource\";\n\t\t\t}\n\t\t\tMockHostVO mockHost = new MockHostVO();\n\t\t\tmockHost.setDataCenterId(this.dcId);\n\t\t\tmockHost.setPodId(this.podId);\n\t\t\tmockHost.setCpuCount(DEFAULT_HOST_CPU_CORES);\n\t\t\tmockHost.setCpuSpeed(DEFAULT_HOST_SPEED_MHZ);\n\t\t\tmockHost.setMemorySize(DEFAULT_HOST_MEM_SIZE);\n\t\t\tmockHost.setGuid(this.guid);\n\t\t\tmockHost.setName(name);\n\t\t\tmockHost.setPrivateIpAddress(this.privateIpAddress);\n\t\t\tmockHost.setPublicIpAddress(this.privateIpAddress);\n\t\t\tmockHost.setStorageIpAddress(this.privateIpAddress);\n\t\t\tmockHost.setPrivateMacAddress(this.privateMacAddress);\n\t\t\tmockHost.setPublicMacAddress(this.privateMacAddress);\n\t\t\tmockHost.setStorageMacAddress(this.privateMacAddress);\n\t\t\tmockHost.setVersion(this.getClass().getPackage().getImplementationVersion());\n\t\t\tmockHost.setResource(resource);\n\t\t\tmockHost.setVmId(vmId);\n\t\t\tTransaction simtxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\tsimtxn.start();\n\t\t\t\tmockHost = _mockHostDao.persist(mockHost);\n\t\t\t\tsimtxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\tsimtxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Unable to persist host \" + mockHost.getGuid() + \" due to \"\n\t\t\t\t\t\t+ ex.getMessage(), ex);\n\t\t\t} finally {\n\t\t\t\tsimtxn.close();\n                simtxn = Transaction.open(Transaction.CLOUD_DB);\n                simtxn.close();\n\t\t\t}\n\n\t\t\tif (vmType.equalsIgnoreCase(\"secstorage\")) {\n\t\t\t\tAgentStorageResource storageResource = new AgentStorageResource();\n\t\t\t\ttry {\n\t\t\t\t\tMap<String, Object> params = new HashMap<String, Object>();\n\t\t\t\t\tMap<String, String> details = new HashMap<String, String>();\n\t\t\t\t\tparams.put(\"guid\", this.guid);\n\t\t\t\t\tdetails.put(\"guid\", this.guid);\n\t\t\t\t\tstorageResource.configure(\"secondaryStorage\", params);\n\t\t\t\t\tstorageResource.start();\n\t\t\t\t\t// on the simulator the ssvm is as good as a direct\n\t\t\t\t\t// agent\n\t\t\t\t\t_resourceMgr.addHost(mockHost.getDataCenterId(), storageResource, Host.Type.SecondaryStorageVM,\n\t\t\t\t\t\t\tdetails);\n\t\t\t\t\t_resources.put(this.guid, storageResource);\n\t\t\t\t} catch (ConfigurationException e) {\n\t\t\t\t\ts_logger.debug(\"Failed to load secondary storage resource: \" + e.toString());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public GetHostStatsAnswer getHostStatistic(GetHostStatsCommand cmd) {\n        String hostGuid = cmd.getHostGuid();\n        MockHost host = _mockHostDao.findByGuid(hostGuid);\n        if (host == null) {\n            return null;\n        }\n        List<MockVMVO> vms = _mockVmDao.findByHostId(host.getId());\n        double usedMem = 0.0;\n        double usedCpu = 0.0;\n        for (MockVMVO vm : vms) {\n            usedMem += vm.getMemory();\n            usedCpu += vm.getCpu();\n        }\n        \n        HostStatsEntry hostStats = new HostStatsEntry();\n        hostStats.setTotalMemoryKBs(host.getMemorySize());\n        hostStats.setFreeMemoryKBs(host.getMemorySize() - usedMem);\n        hostStats.setNetworkReadKBs(32768);\n        hostStats.setNetworkWriteKBs(16384);\n        hostStats.setCpuUtilization(usedCpu/(host.getCpuCount() * host.getCpuSpeed()));\n        hostStats.setEntityType(\"simulator-host\");\n        hostStats.setHostId(cmd.getHostId());\n        return new GetHostStatsAnswer(cmd, hostStats);\n    }","id":9637,"modified_method":"@Override\n\tpublic GetHostStatsAnswer getHostStatistic(GetHostStatsCommand cmd) {\n\t\tString hostGuid = cmd.getHostGuid();\n\t\tMockHost host = null;\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\thost = _mockHostDao.findByGuid(hostGuid);\n\t\t\ttxn.commit();\n\t\t\tif (host == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to get host \" + hostGuid + \" due to \" + ex.getMessage(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tTransaction vmtxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\tvmtxn.start();\n\t\t\tList<MockVMVO> vms = _mockVmDao.findByHostId(host.getId());\n\t\t\tvmtxn.commit();\n\t\t\tdouble usedMem = 0.0;\n\t\t\tdouble usedCpu = 0.0;\n\t\t\tfor (MockVMVO vm : vms) {\n\t\t\t\tusedMem += vm.getMemory();\n\t\t\t\tusedCpu += vm.getCpu();\n\t\t\t}\n\n\t\t\tHostStatsEntry hostStats = new HostStatsEntry();\n\t\t\thostStats.setTotalMemoryKBs(host.getMemorySize());\n\t\t\thostStats.setFreeMemoryKBs(host.getMemorySize() - usedMem);\n\t\t\thostStats.setNetworkReadKBs(32768);\n\t\t\thostStats.setNetworkWriteKBs(16384);\n\t\t\thostStats.setCpuUtilization(usedCpu / (host.getCpuCount() * host.getCpuSpeed()));\n\t\t\thostStats.setEntityType(\"simulator-host\");\n\t\t\thostStats.setHostId(cmd.getHostId());\n\t\t\treturn new GetHostStatsAnswer(cmd, hostStats);\n\t\t} catch (Exception ex) {\n\t\t\tvmtxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to get Vms on host \" + host.getGuid() + \" due to \"\n\t\t\t\t\t+ ex.getMessage(), ex);\n\t\t} finally {\n\t\t\tvmtxn.close();\n            vmtxn = Transaction.open(Transaction.CLOUD_DB);\n            vmtxn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public Map<AgentResourceBase, Map<String, String>> createServerResources(\n            Map<String, Object> params) {\n      \n        Map<String, String> args = new HashMap<String, String>();\n        Map<AgentResourceBase, Map<String,String>> newResources = new HashMap<AgentResourceBase, Map<String,String>>();\n        AgentResourceBase agentResource;\n        long cpuCore = Long.parseLong((String)params.get(\"cpucore\"));\n        long cpuSpeed = Long.parseLong((String)params.get(\"cpuspeed\"));\n        long memory = Long.parseLong((String)params.get(\"memory\"));\n        long localStorageSize = Long.parseLong((String)params.get(\"localstorage\"));\n        synchronized (this) {\n            long dataCenterId = Long.parseLong((String)params.get(\"zone\"));\n            long podId = Long.parseLong((String)params.get(\"pod\"));\n            long clusterId = Long.parseLong((String)params.get(\"cluster\"));\n            long cidrSize = getPodCidr(podId, dataCenterId).second();\n\n            int agentId = getNextAgentId(cidrSize);\n            String ipAddress = getIpAddress(agentId, dataCenterId, podId);\n            String macAddress = getMacAddress(dataCenterId, podId, clusterId, agentId);\n            MockHostVO mockHost = new MockHostVO();\n            mockHost.setDataCenterId(dataCenterId);\n            mockHost.setPodId(podId);\n            mockHost.setClusterId(clusterId);\n            mockHost.setCapabilities(\"hvm\");\n            mockHost.setCpuCount(cpuCore);\n            mockHost.setCpuSpeed(cpuSpeed);\n            mockHost.setMemorySize(memory);\n            String guid = UUID.randomUUID().toString();\n            mockHost.setGuid(guid);\n            mockHost.setName(\"SimulatedAgent.\" + guid);\n            mockHost.setPrivateIpAddress(ipAddress);\n            mockHost.setPublicIpAddress(ipAddress);\n            mockHost.setStorageIpAddress(ipAddress);\n            mockHost.setPrivateMacAddress(macAddress);\n            mockHost.setPublicMacAddress(macAddress);\n            mockHost.setStorageMacAddress(macAddress);\n            mockHost.setVersion(this.getClass().getPackage().getImplementationVersion());\n            mockHost.setResource(\"com.cloud.agent.AgentRoutingResource\");\n            mockHost = _mockHostDao.persist(mockHost);\n            \n            _storageMgr.getLocalStorage(guid, localStorageSize);\n\n            agentResource = new AgentRoutingResource();\n            if (agentResource != null) {\n                try {\n                    params.put(\"guid\", mockHost.getGuid());\n                    agentResource.start();\n                    agentResource.configure(mockHost.getName(),\n                            params);\n\n                    newResources.put(agentResource, args);\n                } catch (ConfigurationException e) {\n                    s_logger\n                    .error(\"error while configuring server resource\"\n                            + e.getMessage());\n                }\n            }\n        }\n        return newResources;\n    }","id":9638,"modified_method":"@Override\n\t@DB\n\tpublic Map<AgentResourceBase, Map<String, String>> createServerResources(Map<String, Object> params) {\n\n\t\tMap<String, String> args = new HashMap<String, String>();\n\t\tMap<AgentResourceBase, Map<String, String>> newResources = new HashMap<AgentResourceBase, Map<String, String>>();\n\t\tAgentResourceBase agentResource;\n\t\tlong cpuCore = Long.parseLong((String) params.get(\"cpucore\"));\n\t\tlong cpuSpeed = Long.parseLong((String) params.get(\"cpuspeed\"));\n\t\tlong memory = Long.parseLong((String) params.get(\"memory\"));\n\t\tlong localStorageSize = Long.parseLong((String) params.get(\"localstorage\"));\n\t\tsynchronized (this) {\n\t\t\tlong dataCenterId = Long.parseLong((String) params.get(\"zone\"));\n\t\t\tlong podId = Long.parseLong((String) params.get(\"pod\"));\n\t\t\tlong clusterId = Long.parseLong((String) params.get(\"cluster\"));\n\t\t\tlong cidrSize = getPodCidr(podId, dataCenterId).second();\n\n\t\t\tint agentId = getNextAgentId(cidrSize);\n\t\t\tString ipAddress = getIpAddress(agentId, dataCenterId, podId);\n\t\t\tString macAddress = getMacAddress(dataCenterId, podId, clusterId, agentId);\n\t\t\tMockHostVO mockHost = new MockHostVO();\n\t\t\tmockHost.setDataCenterId(dataCenterId);\n\t\t\tmockHost.setPodId(podId);\n\t\t\tmockHost.setClusterId(clusterId);\n\t\t\tmockHost.setCapabilities(\"hvm\");\n\t\t\tmockHost.setCpuCount(cpuCore);\n\t\t\tmockHost.setCpuSpeed(cpuSpeed);\n\t\t\tmockHost.setMemorySize(memory);\n\t\t\tString guid = UUID.randomUUID().toString();\n\t\t\tmockHost.setGuid(guid);\n\t\t\tmockHost.setName(\"SimulatedAgent.\" + guid);\n\t\t\tmockHost.setPrivateIpAddress(ipAddress);\n\t\t\tmockHost.setPublicIpAddress(ipAddress);\n\t\t\tmockHost.setStorageIpAddress(ipAddress);\n\t\t\tmockHost.setPrivateMacAddress(macAddress);\n\t\t\tmockHost.setPublicMacAddress(macAddress);\n\t\t\tmockHost.setStorageMacAddress(macAddress);\n\t\t\tmockHost.setVersion(this.getClass().getPackage().getImplementationVersion());\n\t\t\tmockHost.setResource(\"com.cloud.agent.AgentRoutingResource\");\n\n\t\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tmockHost = _mockHostDao.persist(mockHost);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\ts_logger.error(\"Error while configuring mock agent \" + ex.getMessage());\n\t\t\t\tthrow new CloudRuntimeException(\"Error configuring agent\", ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\n\t\t\t_storageMgr.getLocalStorage(guid, localStorageSize);\n\n\t\t\tagentResource = new AgentRoutingResource();\n\t\t\tif (agentResource != null) {\n\t\t\t\ttry {\n\t\t\t\t\tparams.put(\"guid\", mockHost.getGuid());\n\t\t\t\t\tagentResource.start();\n\t\t\t\t\tagentResource.configure(mockHost.getName(), params);\n\n\t\t\t\t\tnewResources.put(agentResource, args);\n\t\t\t\t} catch (ConfigurationException e) {\n\t\t\t\t\ts_logger.error(\"error while configuring server resource\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newResources;\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ModifyStoragePoolAnswer ModifyStoragePool(ModifyStoragePoolCommand cmd) {\n        StorageFilerTO sf = cmd.getPool();\n        MockStoragePoolVO storagePool = _mockStoragePoolDao.findByUuid(sf.getUuid());\n        if (storagePool == null) {\n            storagePool = new MockStoragePoolVO();\n            storagePool.setUuid(sf.getUuid());\n            storagePool.setMountPoint(\"/mnt/\" + sf.getUuid() + File.separator);\n            \n            Long size = DEFAULT_HOST_STORAGE_SIZE;\n            String path = sf.getPath();\n            int index = path.lastIndexOf(\"/\");\n            if (index != -1) {\n                path = path.substring(index+1);\n                if (path != null) {\n                    String values[] =  path.split(\"=\");\n                    if (values.length > 1 && values[0].equalsIgnoreCase(\"size\")) {\n                        size = Long.parseLong(values[1]);\n                    }\n                }\n            }\n           \n            storagePool.setCapacity(size);\n         \n            storagePool.setStorageType(sf.getType());\n            storagePool =  _mockStoragePoolDao.persist(storagePool);\n        }\n\n        return new ModifyStoragePoolAnswer(cmd, storagePool.getCapacity(), 0, new HashMap<String, TemplateInfo>());\n    }","id":9639,"modified_method":"@Override\n\tpublic ModifyStoragePoolAnswer ModifyStoragePool(ModifyStoragePoolCommand cmd) {\n\t\tStorageFilerTO sf = cmd.getPool();\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockStoragePoolVO storagePool = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstoragePool = _mockStoragePoolDao.findByUuid(sf.getUuid());\n\t\t\tif (storagePool == null) {\n\t\t\t\tstoragePool = new MockStoragePoolVO();\n\t\t\t\tstoragePool.setUuid(sf.getUuid());\n\t\t\t\tstoragePool.setMountPoint(\"/mnt/\" + sf.getUuid() + File.separator);\n\n\t\t\t\tLong size = DEFAULT_HOST_STORAGE_SIZE;\n\t\t\t\tString path = sf.getPath();\n\t\t\t\tint index = path.lastIndexOf(\"/\");\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tpath = path.substring(index + 1);\n\t\t\t\t\tif (path != null) {\n\t\t\t\t\t\tString values[] = path.split(\"=\");\n\t\t\t\t\t\tif (values.length > 1 && values[0].equalsIgnoreCase(\"size\")) {\n\t\t\t\t\t\t\tsize = Long.parseLong(values[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstoragePool.setCapacity(size);\n\t\t\t\tstoragePool.setStorageType(sf.getType());\n\t\t\t\tstoragePool = _mockStoragePoolDao.persist(storagePool);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when modifying storage pool \" + cmd.getPool().getPath(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new ModifyStoragePoolAnswer(cmd, storagePool.getCapacity(), 0, new HashMap<String, TemplateInfo>());\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public BackupSnapshotAnswer BackupSnapshot(BackupSnapshotCommand cmd, SimulatorInfo info) {\n    \t//emulate xenserver backupsnapshot, if the base volume is deleted, then backupsnapshot failed\n    \tMockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n    \tif (volume == null) {\n    \t\treturn new BackupSnapshotAnswer(cmd, false, \"Can't find base volume: \" + cmd.getVolumePath(), null, true);\n    \t}\n        String snapshotPath = cmd.getSnapshotUuid();\n        MockVolumeVO snapshot = _mockVolumeDao.findByStoragePathAndType(snapshotPath);\n        if (snapshot == null) {\n            return new BackupSnapshotAnswer(cmd, false, \"can't find snapshot\" + snapshotPath, null, true);\n        }\n        \n        String secStorageUrl = cmd.getSecondaryStorageUrl();\n        MockSecStorageVO secStorage = _mockSecStorageDao.findByUrl(secStorageUrl);\n        if (secStorage == null) {\n            return new BackupSnapshotAnswer(cmd, false, \"can't find sec storage\" + snapshotPath, null, true);\n        }\n        MockVolumeVO newsnapshot = new MockVolumeVO();\n        String name = UUID.randomUUID().toString();\n        newsnapshot.setName(name);\n        newsnapshot.setPath(secStorage.getMountPoint() + name);\n        newsnapshot.setPoolId(secStorage.getId());\n        newsnapshot.setSize(snapshot.getSize());\n        newsnapshot.setStatus(Status.DOWNLOADED);\n        newsnapshot.setType(MockVolumeType.SNAPSHOT);\n        newsnapshot = _mockVolumeDao.persist(newsnapshot);\n        \n        return new BackupSnapshotAnswer(cmd, true, null, newsnapshot.getName(), true);\n    }","id":9640,"modified_method":"@Override\n\tpublic BackupSnapshotAnswer BackupSnapshot(BackupSnapshotCommand cmd, SimulatorInfo info) {\n\t\t// emulate xenserver backupsnapshot, if the base volume is deleted, then\n\t\t// backupsnapshot failed\n\t\tMockVolumeVO volume = null;\n\t\tMockVolumeVO snapshot = null;\n\t\tMockSecStorageVO secStorage = null;\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvolume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n\t\t\tif (volume == null) {\n\t\t\t\treturn new BackupSnapshotAnswer(cmd, false, \"Can't find base volume: \" + cmd.getVolumePath(), null,\n\t\t\t\t\t\ttrue);\n\t\t\t}\n\t\t\tString snapshotPath = cmd.getSnapshotUuid();\n\t\t\tsnapshot = _mockVolumeDao.findByStoragePathAndType(snapshotPath);\n\t\t\tif (snapshot == null) {\n\t\t\t\treturn new BackupSnapshotAnswer(cmd, false, \"can't find snapshot\" + snapshotPath, null, true);\n\t\t\t}\n\n\t\t\tString secStorageUrl = cmd.getSecondaryStorageUrl();\n\t\t\tsecStorage = _mockSecStorageDao.findByUrl(secStorageUrl);\n\t\t\tif (secStorage == null) {\n\t\t\t\treturn new BackupSnapshotAnswer(cmd, false, \"can't find sec storage\" + snapshotPath, null, true);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when backing up snapshot\");\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\t\n\t\tMockVolumeVO newsnapshot = new MockVolumeVO();\n\t\tString name = UUID.randomUUID().toString();\n\t\tnewsnapshot.setName(name);\n\t\tnewsnapshot.setPath(secStorage.getMountPoint() + name);\n\t\tnewsnapshot.setPoolId(secStorage.getId());\n\t\tnewsnapshot.setSize(snapshot.getSize());\n\t\tnewsnapshot.setStatus(Status.DOWNLOADED);\n\t\tnewsnapshot.setType(MockVolumeType.SNAPSHOT);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tsnapshot = _mockVolumeDao.persist(snapshot);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when backing up snapshot \" + newsnapshot, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\treturn new BackupSnapshotAnswer(cmd, true, null, newsnapshot.getName(), true);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public GetStorageStatsAnswer GetStorageStats(GetStorageStatsCommand cmd) {\n        String uuid = cmd.getStorageId();\n        if (uuid == null) {\n            String secUrl = cmd.getSecUrl();\n            MockSecStorageVO secondary = _mockSecStorageDao.findByUrl(secUrl);\n            if (secondary == null) {\n                return new GetStorageStatsAnswer(cmd, \"Can't find the secondary storage:\" + secUrl);\n            }\n            Long totalUsed = _mockVolumeDao.findTotalStorageId(secondary.getId());\n            return new GetStorageStatsAnswer(cmd, secondary.getCapacity(), totalUsed);\n        } else {\n            MockStoragePoolVO pool = _mockStoragePoolDao.findByUuid(uuid);\n            if (pool == null) {\n                return new GetStorageStatsAnswer(cmd, \"Can't find the pool\");\n            }\n            Long totalUsed = _mockVolumeDao.findTotalStorageId(pool.getId());\n            if (totalUsed == null) {\n                totalUsed = 0L;\n            }\n            return new GetStorageStatsAnswer(cmd, pool.getCapacity(), totalUsed);\n        }\n    }","id":9641,"modified_method":"@Override\n\tpublic GetStorageStatsAnswer GetStorageStats(GetStorageStatsCommand cmd) {\n\t\tString uuid = cmd.getStorageId();\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tif (uuid == null) {\n\t\t\t\tString secUrl = cmd.getSecUrl();\n\t\t\t\tMockSecStorageVO secondary = _mockSecStorageDao.findByUrl(secUrl);\n\t\t\t\tif (secondary == null) {\n\t\t\t\t\treturn new GetStorageStatsAnswer(cmd, \"Can't find the secondary storage:\" + secUrl);\n\t\t\t\t}\n\t\t\t\tLong totalUsed = _mockVolumeDao.findTotalStorageId(secondary.getId());\n\t\t\t\ttxn.commit();\n\t\t\t\treturn new GetStorageStatsAnswer(cmd, secondary.getCapacity(), totalUsed);\n\t\t\t} else {\n\t\t\t\tMockStoragePoolVO pool = _mockStoragePoolDao.findByUuid(uuid);\n\t\t\t\tif (pool == null) {\n\t\t\t\t\treturn new GetStorageStatsAnswer(cmd, \"Can't find the pool\");\n\t\t\t\t}\n\t\t\t\tLong totalUsed = _mockVolumeDao.findTotalStorageId(pool.getId());\n\t\t\t\tif (totalUsed == null) {\n\t\t\t\t\ttotalUsed = 0L;\n\t\t\t\t}\n\t\t\t\ttxn.commit();\n\t\t\t\treturn new GetStorageStatsAnswer(cmd, pool.getCapacity(), totalUsed);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"DBException during storage stats collection for pool \" + uuid, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer DeleteTemplate(DeleteTemplateCommand cmd) {\n        MockVolumeVO template = _mockVolumeDao.findByStoragePathAndType(cmd.getTemplatePath());\n        if (template == null) {\n            return new Answer(cmd, false, \"can't find template:\" + cmd.getTemplatePath());\n        }\n        \n        _mockVolumeDao.remove(template.getId());\n        \n        return new Answer(cmd);\n    }","id":9642,"modified_method":"@Override\n\tpublic Answer DeleteTemplate(DeleteTemplateCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVolumeVO template = _mockVolumeDao.findByStoragePathAndType(cmd.getTemplatePath());\n\t\t\tif (template == null) {\n\t\t\t\treturn new Answer(cmd, false, \"can't find template:\" + cmd.getTemplatePath());\n\t\t\t}\n\t\t\t_mockVolumeDao.remove(template.getId());\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when deleting template\");\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new Answer(cmd);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CreatePrivateTemplateAnswer CreatePrivateTemplateFromVolume(CreatePrivateTemplateFromVolumeCommand cmd) {\n        MockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n        if (volume == null) {\n            return new CreatePrivateTemplateAnswer(cmd, false, \"cant' find volume\" + cmd.getVolumePath());\n        }\n        \n        MockSecStorageVO sec = _mockSecStorageDao.findByUrl(cmd.getSecondaryStorageUrl());\n        if (sec == null) {\n            return new CreatePrivateTemplateAnswer(cmd, false, \"can't find secondary storage\");\n        }\n        \n        MockVolumeVO template = new MockVolumeVO();\n        String uuid = UUID.randomUUID().toString();\n        template.setName(uuid);\n        template.setPath(sec.getMountPoint() + uuid);\n        template.setPoolId(sec.getId());\n        template.setSize(volume.getSize());\n        template.setStatus(Status.DOWNLOADED);\n        template.setType(MockVolumeType.TEMPLATE);\n        template = _mockVolumeDao.persist(template);\n        \n        return new CreatePrivateTemplateAnswer(cmd, true, \"\", template.getName(), template.getSize(), template.getSize(), template.getName(), ImageFormat.QCOW2);\n    }","id":9643,"modified_method":"@Override\n\tpublic CreatePrivateTemplateAnswer CreatePrivateTemplateFromVolume(CreatePrivateTemplateFromVolumeCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockVolumeVO volume = null;\n\t\tMockSecStorageVO sec = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvolume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n\t\t\tif (volume == null) {\n\t\t\t\treturn new CreatePrivateTemplateAnswer(cmd, false, \"cant' find volume\" + cmd.getVolumePath());\n\t\t\t}\n\n\t\t\tsec = _mockSecStorageDao.findByUrl(cmd.getSecondaryStorageUrl());\n\t\t\tif (sec == null) {\n\t\t\t\treturn new CreatePrivateTemplateAnswer(cmd, false, \"can't find secondary storage\");\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when creating private template from volume\");\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tMockVolumeVO template = new MockVolumeVO();\n\t\tString uuid = UUID.randomUUID().toString();\n\t\ttemplate.setName(uuid);\n\t\ttemplate.setPath(sec.getMountPoint() + uuid);\n\t\ttemplate.setPoolId(sec.getId());\n\t\ttemplate.setSize(volume.getSize());\n\t\ttemplate.setStatus(Status.DOWNLOADED);\n\t\ttemplate.setType(MockVolumeType.TEMPLATE);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\ttemplate = _mockVolumeDao.persist(template);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Encountered \" + ex.getMessage() + \" when persisting template \"\n\t\t\t\t\t+ template.getName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\treturn new CreatePrivateTemplateAnswer(cmd, true, \"\", template.getName(), template.getSize(),\n\t\t\t\ttemplate.getSize(), template.getName(), ImageFormat.QCOW2);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public StoragePoolInfo getLocalStorage(String hostGuid, Long storageSize) {\n        MockHost host = _mockHostDao.findByGuid(hostGuid);\n        if (storageSize == null) {\n            storageSize = DEFAULT_HOST_STORAGE_SIZE;\n        }\n        MockStoragePoolVO storagePool = _mockStoragePoolDao.findByHost(hostGuid);\n        if (storagePool == null) {\n            String uuid = UUID.randomUUID().toString();\n            storagePool = new MockStoragePoolVO();\n            storagePool.setUuid(uuid);\n            storagePool.setMountPoint(\"/mnt/\" + uuid + File.separator);\n            storagePool.setCapacity(storageSize);\n            storagePool.setHostGuid(hostGuid);\n            storagePool.setStorageType(StoragePoolType.Filesystem);\n            storagePool =  _mockStoragePoolDao.persist(storagePool);\n        }\n        \n        \n        return new StoragePoolInfo(storagePool.getUuid(), host.getPrivateIpAddress(), storagePool.getMountPoint(), storagePool.getMountPoint(), storagePool.getPoolType(), storagePool.getCapacity(), 0 );\n    }","id":9644,"modified_method":"@Override\n\tpublic StoragePoolInfo getLocalStorage(String hostGuid, Long storageSize) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockHost host = null; \n\t\ttry {\n\t\t\ttxn.start();\n\t\t\thost = _mockHostDao.findByGuid(hostGuid);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to find host \" + hostGuid, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\tif (storageSize == null) {\n\t\t\tstorageSize = DEFAULT_HOST_STORAGE_SIZE;\n\t\t}\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockStoragePoolVO storagePool = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstoragePool = _mockStoragePoolDao.findByHost(hostGuid);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when finding storagePool \" + storagePool, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\tif (storagePool == null) {\n\t\t\tString uuid = UUID.randomUUID().toString();\n\t\t\tstoragePool = new MockStoragePoolVO();\n\t\t\tstoragePool.setUuid(uuid);\n\t\t\tstoragePool.setMountPoint(\"/mnt/\" + uuid + File.separator);\n\t\t\tstoragePool.setCapacity(storageSize);\n\t\t\tstoragePool.setHostGuid(hostGuid);\n\t\t\tstoragePool.setStorageType(StoragePoolType.Filesystem);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tstoragePool = _mockStoragePoolDao.persist(storagePool);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Error when saving storagePool \" + storagePool, ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\t\t}\n\t\treturn new StoragePoolInfo(storagePool.getUuid(), host.getPrivateIpAddress(), storagePool.getMountPoint(),\n\t\t\t\tstoragePool.getMountPoint(), storagePool.getPoolType(), storagePool.getCapacity(), 0);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer DeleteStoragePool(DeleteStoragePoolCommand cmd) {\n        MockStoragePoolVO storage = _mockStoragePoolDao.findByUuid(cmd.getPool().getUuid());\n        if (storage == null) {\n            return new Answer(cmd, false, \"can't find storage pool:\" + cmd.getPool().getUuid());\n        }\n        _mockStoragePoolDao.remove(storage.getId());\n        return new Answer(cmd);\n    }","id":9645,"modified_method":"@Override\n\tpublic Answer DeleteStoragePool(DeleteStoragePoolCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockStoragePoolVO storage = _mockStoragePoolDao.findByUuid(cmd.getPool().getUuid());\n\t\t\tif (storage == null) {\n\t\t\t\treturn new Answer(cmd, false, \"can't find storage pool:\" + cmd.getPool().getUuid());\n\t\t\t}\n\t\t\t_mockStoragePoolDao.remove(storage.getId());\n\t\t\ttxn.commit();\n\t\t\treturn new Answer(cmd);\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when deleting storage pool \" + cmd.getPool().getPath(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public DownloadAnswer DownloadProcess(DownloadProgressCommand cmd) {\n        String volumeId = cmd.getJobId();\n        MockVolumeVO volume = _mockVolumeDao.findById(Long.parseLong(volumeId));\n        if (volume == null) {\n            return new DownloadAnswer(\"Can't find the downloading volume\", Status.ABANDONED);\n        }\n        \n        long size = Math.min(volume.getSize() + DEFAULT_TEMPLATE_SIZE/5, DEFAULT_TEMPLATE_SIZE);\n        volume.setSize(size);\n       \n        double volumeSize = volume.getSize();\n        double pct = volumeSize/DEFAULT_TEMPLATE_SIZE;\n        if (pct >= 1.0) {\n            volume.setStatus(Status.DOWNLOADED);\n            _mockVolumeDao.update(volume.getId(), volume);\n            return new DownloadAnswer(cmd.getJobId(), 100, cmd, com.cloud.storage.VMTemplateStorageResourceAssoc.Status.DOWNLOADED, volume.getPath(), volume.getName());\n        } else {\n            _mockVolumeDao.update(volume.getId(), volume);\n            return new DownloadAnswer(cmd.getJobId(), (int)(pct*100.0) , cmd, com.cloud.storage.VMTemplateStorageResourceAssoc.Status.DOWNLOAD_IN_PROGRESS, volume.getPath(), volume.getName()); \n        }\n    }","id":9646,"modified_method":"@Override\n\tpublic DownloadAnswer DownloadProcess(DownloadProgressCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tString volumeId = cmd.getJobId();\n\t\t\tMockVolumeVO volume = _mockVolumeDao.findById(Long.parseLong(volumeId));\n\t\t\tif (volume == null) {\n\t\t\t\treturn new DownloadAnswer(\"Can't find the downloading volume\", Status.ABANDONED);\n\t\t\t}\n\n\t\t\tlong size = Math.min(volume.getSize() + DEFAULT_TEMPLATE_SIZE / 5, DEFAULT_TEMPLATE_SIZE);\n\t\t\tvolume.setSize(size);\n\n\t\t\tdouble volumeSize = volume.getSize();\n\t\t\tdouble pct = volumeSize / DEFAULT_TEMPLATE_SIZE;\n\t\t\tif (pct >= 1.0) {\n\t\t\t\tvolume.setStatus(Status.DOWNLOADED);\n\t\t\t\t_mockVolumeDao.update(volume.getId(), volume);\n\t\t\t\ttxn.commit();\n\t\t\t\treturn new DownloadAnswer(cmd.getJobId(), 100, cmd,\n\t\t\t\t\t\tcom.cloud.storage.VMTemplateStorageResourceAssoc.Status.DOWNLOADED, volume.getPath(),\n\t\t\t\t\t\tvolume.getName());\n\t\t\t} else {\n\t\t\t\t_mockVolumeDao.update(volume.getId(), volume);\n\t\t\t\ttxn.commit();\n\t\t\t\treturn new DownloadAnswer(cmd.getJobId(), (int) (pct * 100.0), cmd,\n\t\t\t\t\t\tcom.cloud.storage.VMTemplateStorageResourceAssoc.Status.DOWNLOAD_IN_PROGRESS, volume.getPath(),\n\t\t\t\t\t\tvolume.getName());\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error during download job \" + cmd.getJobId(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public AttachVolumeAnswer AttachVolume(AttachVolumeCommand cmd) {\n        String poolid = cmd.getPoolUuid();\n        String volumeName = cmd.getVolumeName();\n        MockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n        if (volume == null) {\n            return new AttachVolumeAnswer(cmd, \"Can't find volume:\" + volumeName + \"on pool:\" + poolid);\n        }\n        \n        String vmName = cmd.getVmName();\n        MockVMVO vm = _mockVMDao.findByVmName(vmName);\n        if (vm == null) {\n            return new AttachVolumeAnswer(cmd, \"can't vm :\" + vmName);\n        }\n        \n        return new AttachVolumeAnswer(cmd, cmd.getDeviceId());\n    }","id":9647,"modified_method":"@Override\n\tpublic AttachVolumeAnswer AttachVolume(AttachVolumeCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tString poolid = cmd.getPoolUuid();\n\t\t\tString volumeName = cmd.getVolumeName();\n\t\t\tMockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n\t\t\tif (volume == null) {\n\t\t\t\treturn new AttachVolumeAnswer(cmd, \"Can't find volume:\" + volumeName + \"on pool:\" + poolid);\n\t\t\t}\n\n\t\t\tString vmName = cmd.getVmName();\n\t\t\tMockVMVO vm = _mockVMDao.findByVmName(vmName);\n\t\t\tif (vm == null) {\n\t\t\t\treturn new AttachVolumeAnswer(cmd, \"can't vm :\" + vmName);\n\t\t\t}\n\t\t\ttxn.commit();\n\n\t\t\treturn new AttachVolumeAnswer(cmd, cmd.getDeviceId());\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when attaching volume \" + cmd.getVolumeName() + \" to VM \"\n\t\t\t\t\t+ cmd.getVmName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public StoragePoolInfo getLocalStorage(String hostGuid) {\n        MockHost host = _mockHostDao.findByGuid(hostGuid);\n        \n        MockStoragePoolVO storagePool = _mockStoragePoolDao.findByHost(hostGuid);\n        if (storagePool == null) {\n            String uuid = UUID.randomUUID().toString();\n            storagePool = new MockStoragePoolVO();\n            storagePool.setUuid(uuid);\n            storagePool.setMountPoint(\"/mnt/\" + uuid + File.separator);\n            storagePool.setCapacity(DEFAULT_HOST_STORAGE_SIZE);\n            storagePool.setHostGuid(hostGuid);\n            storagePool.setStorageType(StoragePoolType.Filesystem);\n            storagePool =  _mockStoragePoolDao.persist(storagePool);\n        }\n        \n        \n        return new StoragePoolInfo(storagePool.getUuid(), host.getPrivateIpAddress(), storagePool.getMountPoint(), storagePool.getMountPoint(), storagePool.getPoolType(), storagePool.getCapacity(), 0 );\n    }","id":9648,"modified_method":"@Override\n\tpublic StoragePoolInfo getLocalStorage(String hostGuid) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockHost host = null; \n\t\tMockStoragePoolVO storagePool = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\thost = _mockHostDao.findByGuid(hostGuid);\n\t\t\tstoragePool = _mockStoragePoolDao.findByHost(hostGuid);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to find host \" + hostGuid, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\t\n\t\tif (storagePool == null) {\n\t\t\tString uuid = UUID.randomUUID().toString();\n\t\t\tstoragePool = new MockStoragePoolVO();\n\t\t\tstoragePool.setUuid(uuid);\n\t\t\tstoragePool.setMountPoint(\"/mnt/\" + uuid + File.separator);\n\t\t\tstoragePool.setCapacity(DEFAULT_HOST_STORAGE_SIZE);\n\t\t\tstoragePool.setHostGuid(hostGuid);\n\t\t\tstoragePool.setStorageType(StoragePoolType.Filesystem);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tstoragePool = _mockStoragePoolDao.persist(storagePool);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Error when saving storagePool \" + storagePool, ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\t\t}\n\t\treturn new StoragePoolInfo(storagePool.getUuid(), host.getPrivateIpAddress(), storagePool.getMountPoint(),\n\t\t\t\tstoragePool.getMountPoint(), storagePool.getPoolType(), storagePool.getCapacity(), 0);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"private MockVolumeVO findVolumeFromSecondary(String path, String ssUrl, MockVolumeType type) {\n       \n        String volumePath = path.replaceAll(ssUrl, \"\");\n        \n        MockSecStorageVO secStorage = _mockSecStorageDao.findByUrl(ssUrl);\n        if (secStorage == null) {\n            return null;\n        }\n        \n        volumePath = secStorage.getMountPoint() + volumePath;\n        volumePath = volumePath.replaceAll(\"//\", \"/\");\n        \n        MockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(volumePath);\n        if (volume == null) {\n            return null;\n        }\n        \n        return volume;\n    }","id":9649,"modified_method":"private MockVolumeVO findVolumeFromSecondary(String path, String ssUrl, MockVolumeType type) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tString volumePath = path.replaceAll(ssUrl, \"\");\n\t\t\tMockSecStorageVO secStorage = _mockSecStorageDao.findByUrl(ssUrl);\n\t\t\tif (secStorage == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvolumePath = secStorage.getMountPoint() + volumePath;\n\t\t\tvolumePath = volumePath.replaceAll(\"//\", \"/\");\n\t\t\tMockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(volumePath);\n\t\t\ttxn.commit();\n\t\t\tif (volume == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn volume;\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to find volume \" + path + \" on secondary \" + ssUrl, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public ManageSnapshotAnswer ManageSnapshot(ManageSnapshotCommand cmd) {\n        String volPath = cmd.getVolumePath();\n        \n        MockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(volPath);\n        if (volume == null) {\n            return new ManageSnapshotAnswer(cmd, false, \"Can't find the volume\");\n        }\n        MockStoragePoolVO storagePool = _mockStoragePoolDao.findById(volume.getPoolId());\n        if (storagePool == null) {\n            return new ManageSnapshotAnswer(cmd, false, \"Can't find the storage pooll\"); \n        }\n        \n        String mountPoint = storagePool.getMountPoint();\n        MockVolumeVO snapshot = new MockVolumeVO();\n        \n        snapshot.setName(cmd.getSnapshotName());\n        snapshot.setPath(mountPoint + cmd.getSnapshotName());\n        snapshot.setSize(volume.getSize());\n        snapshot.setPoolId(storagePool.getId());\n        snapshot.setType(MockVolumeType.SNAPSHOT);\n        snapshot.setStatus(Status.DOWNLOADED);\n        \n        snapshot = _mockVolumeDao.persist(snapshot);\n        \n        return new ManageSnapshotAnswer(cmd, snapshot.getId(), snapshot.getPath(), true, \"\");\n    }","id":9650,"modified_method":"@Override\n\tpublic ManageSnapshotAnswer ManageSnapshot(ManageSnapshotCommand cmd) {\n\t\tString volPath = cmd.getVolumePath();\n\t\tMockVolumeVO volume = null;\n\t\tMockStoragePoolVO storagePool = null;\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvolume = _mockVolumeDao.findByStoragePathAndType(volPath);\n\t\t\tif (volume == null) {\n\t\t\t\treturn new ManageSnapshotAnswer(cmd, false, \"Can't find the volume\");\n\t\t\t}\n\t\t\tstoragePool = _mockStoragePoolDao.findById(volume.getPoolId());\n\t\t\tif (storagePool == null) {\n\t\t\t\treturn new ManageSnapshotAnswer(cmd, false, \"Can't find the storage pooll\");\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to perform snapshot\", ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tString mountPoint = storagePool.getMountPoint();\n\t\tMockVolumeVO snapshot = new MockVolumeVO();\n\n\t\tsnapshot.setName(cmd.getSnapshotName());\n\t\tsnapshot.setPath(mountPoint + cmd.getSnapshotName());\n\t\tsnapshot.setSize(volume.getSize());\n\t\tsnapshot.setPoolId(storagePool.getId());\n\t\tsnapshot.setType(MockVolumeType.SNAPSHOT);\n\t\tsnapshot.setStatus(Status.DOWNLOADED);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tsnapshot = _mockVolumeDao.persist(snapshot);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when saving snapshot \" + snapshot, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\treturn new ManageSnapshotAnswer(cmd, snapshot.getId(), snapshot.getPath(), true, \"\");\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void preinstallTemplates(String url, long zoneId) {\n        MockSecStorageVO storage = _mockSecStorageDao.findByUrl(url);\n        if (storage == null) {\n            storage = new MockSecStorageVO();\n            URI uri;\n            try {\n                uri = new URI(url);\n            } catch (URISyntaxException e) {\n                return;\n            }\n            \n            String nfsHost = uri.getHost();\n            String nfsPath = uri.getPath();\n            String path = nfsHost + \":\" + nfsPath;\n            String dir = \"/mnt/\" + UUID.nameUUIDFromBytes(path.getBytes()).toString() + File.separator;\n            \n            storage.setUrl(url);\n            storage.setCapacity(DEFAULT_HOST_STORAGE_SIZE);\n           \n            storage.setMountPoint(dir);\n            \n            storage = _mockSecStorageDao.persist(storage);\n            \n            //preinstall default templates into secondary storage\n            long defaultTemplateSize = 2 * 1024 * 1024 * 1024L;\n            MockVolumeVO template = new MockVolumeVO();\n            template.setName(\"simulator-domR\");\n            template.setPath(storage.getMountPoint() + \"template/tmpl/1/9/\" + UUID.randomUUID().toString());\n            template.setPoolId(storage.getId());\n            template.setSize(defaultTemplateSize);\n            template.setType(MockVolumeType.TEMPLATE);\n            template.setStatus(Status.DOWNLOADED);\n            _mockVolumeDao.persist(template);\n            \n            template = new MockVolumeVO();\n            template.setName(\"simulator-Centos\");\n            template.setPath(storage.getMountPoint() + \"template/tmpl/1/10/\" + UUID.randomUUID().toString());\n            template.setPoolId(storage.getId());\n            template.setSize(defaultTemplateSize);\n            template.setType(MockVolumeType.TEMPLATE);\n            template.setStatus(Status.DOWNLOADED);\n            _mockVolumeDao.persist(template);\n        }\n        \n    }","id":9651,"modified_method":"@Override\n\tpublic void preinstallTemplates(String url, long zoneId) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockSecStorageVO storage = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstorage = _mockSecStorageDao.findByUrl(url);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to find sec storage at \" + url, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\tif (storage == null) {\n\t\t\tstorage = new MockSecStorageVO();\n\t\t\tURI uri;\n\t\t\ttry {\n\t\t\t\turi = new URI(url);\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString nfsHost = uri.getHost();\n\t\t\tString nfsPath = uri.getPath();\n\t\t\tString path = nfsHost + \":\" + nfsPath;\n\t\t\tString dir = \"/mnt/\" + UUID.nameUUIDFromBytes(path.getBytes()).toString() + File.separator;\n\n\t\t\tstorage.setUrl(url);\n\t\t\tstorage.setCapacity(DEFAULT_HOST_STORAGE_SIZE);\n\n\t\t\tstorage.setMountPoint(dir);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tstorage = _mockSecStorageDao.persist(storage);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Error when saving storage \" + storage, ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\n\t\t\t// preinstall default templates into secondary storage\n\t\t\tlong defaultTemplateSize = 2 * 1024 * 1024 * 1024L;\n\t\t\tMockVolumeVO template = new MockVolumeVO();\n\t\t\ttemplate.setName(\"simulator-domR\");\n\t\t\ttemplate.setPath(storage.getMountPoint() + \"template/tmpl/1/9/\" + UUID.randomUUID().toString());\n\t\t\ttemplate.setPoolId(storage.getId());\n\t\t\ttemplate.setSize(defaultTemplateSize);\n\t\t\ttemplate.setType(MockVolumeType.TEMPLATE);\n\t\t\ttemplate.setStatus(Status.DOWNLOADED);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\ttemplate = _mockVolumeDao.persist(template);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Error when saving template \" + template, ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\n\t\t\ttemplate = new MockVolumeVO();\n\t\t\ttemplate.setName(\"simulator-Centos\");\n\t\t\ttemplate.setPath(storage.getMountPoint() + \"template/tmpl/1/10/\" + UUID.randomUUID().toString());\n\t\t\ttemplate.setPoolId(storage.getId());\n\t\t\ttemplate.setSize(defaultTemplateSize);\n\t\t\ttemplate.setType(MockVolumeType.TEMPLATE);\n\t\t\ttemplate.setStatus(Status.DOWNLOADED);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\ttemplate = _mockVolumeDao.persist(template);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Error when saving template \" + template, ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CopyVolumeAnswer CopyVolume(CopyVolumeCommand cmd) {\n    \t boolean toSecondaryStorage = cmd.toSecondaryStorage();\n    \t MockSecStorageVO sec = _mockSecStorageDao.findByUrl(cmd.getSecondaryStorageURL());\n         if (sec == null) {\n             return new CopyVolumeAnswer(cmd, false, \"can't find secondary storage\", null, null);\n         }\n         MockStoragePoolVO primaryStorage = _mockStoragePoolDao.findByUuid(cmd.getPool().getUuid());\n         if (primaryStorage == null) {\n        \t return new CopyVolumeAnswer(cmd, false, \"Can't find primary storage\", null, null);\n         }\n         \n         MockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n         if (volume == null) {\n             return new CopyVolumeAnswer(cmd, false, \"cant' find volume\" + cmd.getVolumePath(), null, null);\n         }\n         \n         String name = UUID.randomUUID().toString();\n    \t if (toSecondaryStorage) {\n    \t\t \n    \t\t MockVolumeVO vol = new MockVolumeVO();\n    \t\t \n    \t\t vol.setName(name);\n    \t\t vol.setPath(sec.getMountPoint() + name);\n    \t\t vol.setPoolId(sec.getId());\n    \t\t vol.setSize(volume.getSize());\n    \t\t vol.setStatus(Status.DOWNLOADED);\n    \t\t vol.setType(MockVolumeType.VOLUME);\n    \t\t vol = _mockVolumeDao.persist(vol);\n    \t\t return new CopyVolumeAnswer(cmd, true, null, sec.getMountPoint(), vol.getPath());\n    \t }\n    \t else {\n    \t\t MockVolumeVO vol = new MockVolumeVO();\n    \t\t vol.setName(name);\n    \t\t vol.setPath(primaryStorage.getMountPoint() + name);\n    \t\t vol.setPoolId(primaryStorage.getId());\n    \t\t vol.setSize(volume.getSize());\n    \t\t vol.setStatus(Status.DOWNLOADED);\n    \t\t vol.setType(MockVolumeType.VOLUME);\n    \t\t vol = _mockVolumeDao.persist(vol);\n    \t\t return new CopyVolumeAnswer(cmd, true, null, primaryStorage.getMountPoint(), vol.getPath());\n    \t }\n    }","id":9652,"modified_method":"@Override\n\tpublic CopyVolumeAnswer CopyVolume(CopyVolumeCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tboolean toSecondaryStorage = cmd.toSecondaryStorage();\n\t\tMockSecStorageVO sec = null;\n\t\tMockStoragePoolVO primaryStorage = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tsec = _mockSecStorageDao.findByUrl(cmd.getSecondaryStorageURL());\n\t\t\tif (sec == null) {\n\t\t\t\treturn new CopyVolumeAnswer(cmd, false, \"can't find secondary storage\", null, null);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Encountered \" + ex.getMessage() + \" when accessing secondary at \"\n\t\t\t\t\t+ cmd.getSecondaryStorageURL(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tprimaryStorage = _mockStoragePoolDao.findByUuid(cmd.getPool().getUuid());\n\t\t\tif (primaryStorage == null) {\n\t\t\t\treturn new CopyVolumeAnswer(cmd, false, \"Can't find primary storage\", null, null);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Encountered \" + ex.getMessage() + \" when accessing primary at \"\n\t\t\t\t\t+ cmd.getPool(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tMockVolumeVO volume = null;\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvolume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolumePath());\n\t\t\tif (volume == null) {\n\t\t\t\treturn new CopyVolumeAnswer(cmd, false, \"cant' find volume\" + cmd.getVolumePath(), null, null);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Encountered \" + ex.getMessage() + \" when accessing volume at \"\n\t\t\t\t\t+ cmd.getVolumePath(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tString name = UUID.randomUUID().toString();\n\t\tif (toSecondaryStorage) {\n\t\t\tMockVolumeVO vol = new MockVolumeVO();\n\t\t\tvol.setName(name);\n\t\t\tvol.setPath(sec.getMountPoint() + name);\n\t\t\tvol.setPoolId(sec.getId());\n\t\t\tvol.setSize(volume.getSize());\n\t\t\tvol.setStatus(Status.DOWNLOADED);\n\t\t\tvol.setType(MockVolumeType.VOLUME);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tvol = _mockVolumeDao.persist(vol);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Encountered \" + ex.getMessage() + \" when persisting volume \"\n\t\t\t\t\t\t+ vol.getName(), ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\t\t\treturn new CopyVolumeAnswer(cmd, true, null, sec.getMountPoint(), vol.getPath());\n\t\t} else {\n\t\t\tMockVolumeVO vol = new MockVolumeVO();\n\t\t\tvol.setName(name);\n\t\t\tvol.setPath(primaryStorage.getMountPoint() + name);\n\t\t\tvol.setPoolId(primaryStorage.getId());\n\t\t\tvol.setSize(volume.getSize());\n\t\t\tvol.setStatus(Status.DOWNLOADED);\n\t\t\tvol.setType(MockVolumeType.VOLUME);\n\t\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tvol = _mockVolumeDao.persist(vol);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"Encountered \" + ex.getMessage() + \" when persisting volume \"\n\t\t\t\t\t\t+ vol.getName(), ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n\t\t\treturn new CopyVolumeAnswer(cmd, true, null, primaryStorage.getMountPoint(), vol.getPath());\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer Destroy(DestroyCommand cmd) {\n\n        MockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolume().getPath());\n        if (volume != null) {\n            _mockVolumeDao.remove(volume.getId());\n        }\n        \n        if (cmd.getVmName() != null) {\n        \tMockVm vm = _mockVMDao.findByVmName(cmd.getVmName());\n        \tvm.setState(State.Expunging);\n        \tif (vm != null ) {\n        \t\tMockVMVO vmVo = _mockVMDao.createForUpdate(vm.getId());\n        \t\t_mockVMDao.update(vm.getId(), vmVo);\n        \t}\n        }\n        return new Answer(cmd);\n    }","id":9653,"modified_method":"@Override\n\tpublic Answer Destroy(DestroyCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVolumeVO volume = _mockVolumeDao.findByStoragePathAndType(cmd.getVolume().getPath());\n\t\t\tif (volume != null) {\n\t\t\t\t_mockVolumeDao.remove(volume.getId());\n\t\t\t}\n\n\t\t\tif (cmd.getVmName() != null) {\n\t\t\t\tMockVm vm = _mockVMDao.findByVmName(cmd.getVmName());\n\t\t\t\tvm.setState(State.Expunging);\n\t\t\t\tif (vm != null) {\n\t\t\t\t\tMockVMVO vmVo = _mockVMDao.createForUpdate(vm.getId());\n\t\t\t\t\t_mockVMDao.update(vm.getId(), vmVo);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when destroying volume \" + cmd.getVolume().getPath(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new Answer(cmd);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer CreateStoragePool(CreateStoragePoolCommand cmd) {\n        StorageFilerTO sf = cmd.getPool();\n        MockStoragePoolVO storagePool = _mockStoragePoolDao.findByUuid(sf.getUuid());\n        if (storagePool == null) {\n            storagePool = new MockStoragePoolVO();\n            storagePool.setUuid(sf.getUuid());\n            storagePool.setMountPoint(\"/mnt/\" + sf.getUuid() + File.separator);\n\n            Long size = DEFAULT_HOST_STORAGE_SIZE;\n            String path = sf.getPath();\n            int index = path.lastIndexOf(\"/\");\n            if (index != -1) {\n                path = path.substring(index+1);\n                if (path != null) {\n                    String values[] =  path.split(\"=\");\n                    if (values.length > 1 && values[0].equalsIgnoreCase(\"size\")) {\n                        size = Long.parseLong(values[1]);\n                    }\n                }\n            }\n            storagePool.setCapacity(size);\n         \n            storagePool.setStorageType(sf.getType());\n            storagePool =  _mockStoragePoolDao.persist(storagePool);\n        }\n\n        return new ModifyStoragePoolAnswer(cmd, storagePool.getCapacity(), 0, new HashMap<String, TemplateInfo>());\n    }","id":9654,"modified_method":"@Override\n\tpublic Answer CreateStoragePool(CreateStoragePoolCommand cmd) {\n\t\tStorageFilerTO sf = cmd.getPool();\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockStoragePoolVO storagePool = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstoragePool = _mockStoragePoolDao.findByUuid(sf.getUuid());\n\t\t\tif (storagePool == null) {\n\t\t\t\tstoragePool = new MockStoragePoolVO();\n\t\t\t\tstoragePool.setUuid(sf.getUuid());\n\t\t\t\tstoragePool.setMountPoint(\"/mnt/\" + sf.getUuid() + File.separator);\n\n\t\t\t\tLong size = DEFAULT_HOST_STORAGE_SIZE;\n\t\t\t\tString path = sf.getPath();\n\t\t\t\tint index = path.lastIndexOf(\"/\");\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tpath = path.substring(index + 1);\n\t\t\t\t\tif (path != null) {\n\t\t\t\t\t\tString values[] = path.split(\"=\");\n\t\t\t\t\t\tif (values.length > 1 && values[0].equalsIgnoreCase(\"size\")) {\n\t\t\t\t\t\t\tsize = Long.parseLong(values[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstoragePool.setCapacity(size);\n\t\t\t\tstoragePool.setStorageType(sf.getType());\n\t\t\t\tstoragePool = _mockStoragePoolDao.persist(storagePool);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when creating storage pool \" + cmd.getPool().getPath(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new ModifyStoragePoolAnswer(cmd, storagePool.getCapacity(), 0, new HashMap<String, TemplateInfo>());\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public PrimaryStorageDownloadAnswer primaryStorageDownload(PrimaryStorageDownloadCommand cmd) {\n        MockVolumeVO template = findVolumeFromSecondary(cmd.getUrl(),cmd.getSecondaryStorageUrl(), MockVolumeType.TEMPLATE);\n        if (template == null) {\n            return new PrimaryStorageDownloadAnswer(\"Can't find primary storage\");\n        }\n        \n        MockStoragePoolVO primaryStorage = _mockStoragePoolDao.findByUuid(cmd.getPoolUuid());\n        if (primaryStorage == null) {\n            return new PrimaryStorageDownloadAnswer(\"Can't find primary storage\"); \n        }\n        \n        String volumeName = UUID.randomUUID().toString();\n        MockVolumeVO newVolume = new MockVolumeVO();\n        newVolume.setName(volumeName);\n        newVolume.setPath(primaryStorage.getMountPoint() + volumeName);\n        newVolume.setPoolId(primaryStorage.getId());\n        newVolume.setSize(template.getSize());\n        newVolume.setType(MockVolumeType.VOLUME);\n        _mockVolumeDao.persist(newVolume);\n        \n       \n        return new PrimaryStorageDownloadAnswer(newVolume.getPath(), newVolume.getSize());\n    }","id":9655,"modified_method":"@Override\n\tpublic PrimaryStorageDownloadAnswer primaryStorageDownload(PrimaryStorageDownloadCommand cmd) {\n\t\tMockVolumeVO template = findVolumeFromSecondary(cmd.getUrl(), cmd.getSecondaryStorageUrl(),\n\t\t\t\tMockVolumeType.TEMPLATE);\n\t\tif (template == null) {\n\t\t\treturn new PrimaryStorageDownloadAnswer(\"Can't find primary storage\");\n\t\t}\n\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockStoragePoolVO primaryStorage = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tprimaryStorage = _mockStoragePoolDao.findByUuid(cmd.getPoolUuid());\n\t\t\ttxn.commit();\n\t\t\tif (primaryStorage == null) {\n\t\t\t\treturn new PrimaryStorageDownloadAnswer(\"Can't find primary storage\");\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when finding primary storagee \" + cmd.getPoolUuid(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tString volumeName = UUID.randomUUID().toString();\n\t\tMockVolumeVO newVolume = new MockVolumeVO();\n\t\tnewVolume.setName(volumeName);\n\t\tnewVolume.setPath(primaryStorage.getMountPoint() + volumeName);\n\t\tnewVolume.setPoolId(primaryStorage.getId());\n\t\tnewVolume.setSize(template.getSize());\n\t\tnewVolume.setType(MockVolumeType.VOLUME);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\t_mockVolumeDao.persist(newVolume);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when saving volume \" + newVolume, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new PrimaryStorageDownloadAnswer(newVolume.getPath(), newVolume.getSize());\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer ListTemplates(ListTemplateCommand cmd) {\n        MockSecStorageVO storage = _mockSecStorageDao.findByUrl(cmd.getSecUrl());\n        if (storage == null) {\n            return new Answer(cmd, false, \"Failed to get secondary storage\");\n        }\n        \n        List<MockVolumeVO> templates = _mockVolumeDao.findByStorageIdAndType(storage.getId(), MockVolumeType.TEMPLATE);\n        Map<String, TemplateInfo> templateInfos = new HashMap<String, TemplateInfo>();\n        for (MockVolumeVO template : templates) {\n            templateInfos.put(template.getName(), new TemplateInfo(template.getName(), template.getPath().replaceAll(storage.getMountPoint(), \"\"), template.getSize(), template.getSize(), true, false));\n        }\n        \n        return new ListTemplateAnswer(cmd.getSecUrl(), templateInfos);\n        \n    }","id":9656,"modified_method":"@Override\n\tpublic Answer ListTemplates(ListTemplateCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockSecStorageVO storage = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstorage = _mockSecStorageDao.findByUrl(cmd.getSecUrl());\n\t\t\tif (storage == null) {\n\t\t\t\treturn new Answer(cmd, false, \"Failed to get secondary storage\");\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when finding sec storage \" + cmd.getSecUrl(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tList<MockVolumeVO> templates = _mockVolumeDao.findByStorageIdAndType(storage.getId(),\n\t\t\t\t\tMockVolumeType.TEMPLATE);\n\n\t\t\tMap<String, TemplateInfo> templateInfos = new HashMap<String, TemplateInfo>();\n\t\t\tfor (MockVolumeVO template : templates) {\n\t\t\t\ttemplateInfos.put(template.getName(), new TemplateInfo(template.getName(), template.getPath()\n\t\t\t\t\t\t.replaceAll(storage.getMountPoint(), \"\"), template.getSize(), template.getSize(), true, false));\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn new ListTemplateAnswer(cmd.getSecUrl(), templateInfos);\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when finding template on sec storage \" + storage.getId(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer DeleteSnapshotBackup(DeleteSnapshotBackupCommand cmd) {\n        \n        MockVolumeVO backSnapshot = _mockVolumeDao.findByName(cmd.getSnapshotUuid());\n        if (backSnapshot == null) {\n            return new Answer(cmd, false, \"can't find the backupsnapshot: \" + cmd.getSnapshotUuid());\n        }\n        \n        _mockVolumeDao.remove(backSnapshot.getId());\n        \n        return new Answer(cmd);\n    }","id":9657,"modified_method":"@Override\n\tpublic Answer DeleteSnapshotBackup(DeleteSnapshotBackupCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVolumeVO backSnapshot = _mockVolumeDao.findByName(cmd.getSnapshotUuid());\n\t\t\tif (backSnapshot == null) {\n\t\t\t\treturn new Answer(cmd, false, \"can't find the backupsnapshot: \" + cmd.getSnapshotUuid());\n\t\t\t}\n\t\t\t_mockVolumeDao.remove(backSnapshot.getId());\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when deleting snapshot\");\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new Answer(cmd);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer SecStorageSetup(SecStorageSetupCommand cmd) {\n        MockSecStorageVO storage = _mockSecStorageDao.findByUrl(cmd.getSecUrl());\n        if (storage == null) {\n            return new Answer(cmd, false, \"can't find the storage\");\n        }\n        return new SecStorageSetupAnswer(storage.getMountPoint());\n    }","id":9658,"modified_method":"@Override\n\tpublic Answer SecStorageSetup(SecStorageSetupCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockSecStorageVO storage = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstorage = _mockSecStorageDao.findByUrl(cmd.getSecUrl());\n\t\t\tif (storage == null) {\n\t\t\t\treturn new Answer(cmd, false, \"can't find the storage\");\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when setting up sec storage\" + cmd.getSecUrl(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new SecStorageSetupAnswer(storage.getMountPoint());\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer AttachIso(AttachIsoCommand cmd) {\n       MockVolumeVO iso = findVolumeFromSecondary(cmd.getIsoPath(), cmd.getStoreUrl(), MockVolumeType.ISO);\n       if (iso == null) {\n           return new Answer(cmd, false, \"Failed to find the iso: \" + cmd.getIsoPath() + \"on secondary storage \" + cmd.getStoreUrl());\n       }\n       \n       String vmName = cmd.getVmName();\n       MockVMVO vm = _mockVMDao.findByVmName(vmName);\n       if (vm == null) {\n           return new Answer(cmd, false, \"can't vm :\" + vmName);\n       }\n       \n       return new Answer(cmd);\n    }","id":9659,"modified_method":"@Override\n\tpublic Answer AttachIso(AttachIsoCommand cmd) {\n\t\tMockVolumeVO iso = findVolumeFromSecondary(cmd.getIsoPath(), cmd.getStoreUrl(), MockVolumeType.ISO);\n\t\tif (iso == null) {\n\t\t\treturn new Answer(cmd, false, \"Failed to find the iso: \" + cmd.getIsoPath() + \"on secondary storage \"\n\t\t\t\t\t+ cmd.getStoreUrl());\n\t\t}\n\n\t\tString vmName = cmd.getVmName();\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockVMVO vm = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvm = _mockVMDao.findByVmName(vmName);\n\t\t\ttxn.commit();\n\t\t\tif (vm == null) {\n\t\t\t\treturn new Answer(cmd, false, \"can't vm :\" + vmName);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when attaching iso to vm \" + vm.getName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new Answer(cmd);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CreateVolumeFromSnapshotAnswer CreateVolumeFromSnapshot(CreateVolumeFromSnapshotCommand cmd) {\n        MockVolumeVO backSnapshot = _mockVolumeDao.findByName(cmd.getSnapshotUuid());\n        if (backSnapshot == null) {\n            return new CreateVolumeFromSnapshotAnswer(cmd, false, \"can't find the backupsnapshot: \" + cmd.getSnapshotUuid(), null);\n        }\n        \n        MockStoragePoolVO primary = _mockStoragePoolDao.findByUuid(cmd.getPrimaryStoragePoolNameLabel());\n        if (primary == null) {\n            return new CreateVolumeFromSnapshotAnswer(cmd, false, \"can't find the primary storage: \" + cmd.getPrimaryStoragePoolNameLabel(), null);\n        }\n        \n        String uuid = UUID.randomUUID().toString();\n        MockVolumeVO volume = new MockVolumeVO();\n        \n        volume.setName(uuid);\n        volume.setPath(primary.getMountPoint() + uuid);\n        volume.setPoolId(primary.getId());\n        volume.setSize(backSnapshot.getSize());\n        volume.setStatus(Status.DOWNLOADED);\n        volume.setType(MockVolumeType.VOLUME);\n        _mockVolumeDao.persist(volume);\n        \n        return new CreateVolumeFromSnapshotAnswer(cmd, true, null, volume.getPath());\n    }","id":9660,"modified_method":"@Override\n\tpublic CreateVolumeFromSnapshotAnswer CreateVolumeFromSnapshot(CreateVolumeFromSnapshotCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockVolumeVO backSnapshot = null;\n\t\tMockStoragePoolVO primary = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tbackSnapshot = _mockVolumeDao.findByName(cmd.getSnapshotUuid());\n\t\t\tif (backSnapshot == null) {\n\t\t\t\treturn new CreateVolumeFromSnapshotAnswer(cmd, false, \"can't find the backupsnapshot: \"\n\t\t\t\t\t\t+ cmd.getSnapshotUuid(), null);\n\t\t\t}\n\n\t\t\tprimary = _mockStoragePoolDao.findByUuid(cmd.getPrimaryStoragePoolNameLabel());\n\t\t\tif (primary == null) {\n\t\t\t\treturn new CreateVolumeFromSnapshotAnswer(cmd, false, \"can't find the primary storage: \"\n\t\t\t\t\t\t+ cmd.getPrimaryStoragePoolNameLabel(), null);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when creating volume from snapshot\", ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tString uuid = UUID.randomUUID().toString();\n\t\tMockVolumeVO volume = new MockVolumeVO();\n\n\t\tvolume.setName(uuid);\n\t\tvolume.setPath(primary.getMountPoint() + uuid);\n\t\tvolume.setPoolId(primary.getId());\n\t\tvolume.setSize(backSnapshot.getSize());\n\t\tvolume.setStatus(Status.DOWNLOADED);\n\t\tvolume.setType(MockVolumeType.VOLUME);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\t_mockVolumeDao.persist(volume);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when creating volume from snapshot \" + volume, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\treturn new CreateVolumeFromSnapshotAnswer(cmd, true, null, volume.getPath());\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CreatePrivateTemplateAnswer CreatePrivateTemplateFromSnapshot(CreatePrivateTemplateFromSnapshotCommand cmd) {\n        String snapshotUUId = cmd.getSnapshotUuid();\n        MockVolumeVO snapshot = _mockVolumeDao.findByName(snapshotUUId);\n        if (snapshot == null) {\n            snapshotUUId = cmd.getSnapshotName();\n            snapshot = _mockVolumeDao.findByName(snapshotUUId);\n            if (snapshot == null) {\n                return new CreatePrivateTemplateAnswer(cmd, false, \"can't find snapshot:\" + snapshotUUId);\n            }\n        }\n        \n        MockSecStorageVO sec = _mockSecStorageDao.findByUrl(cmd.getSecondaryStorageUrl());\n        if (sec == null) {\n            return new CreatePrivateTemplateAnswer(cmd, false, \"can't find secondary storage\");\n        }\n        \n        MockVolumeVO template = new MockVolumeVO();\n        String uuid = UUID.randomUUID().toString();\n        template.setName(uuid);\n        template.setPath(sec.getMountPoint() + uuid);\n        template.setPoolId(sec.getId());\n        template.setSize(snapshot.getSize());\n        template.setStatus(Status.DOWNLOADED);\n        template.setType(MockVolumeType.TEMPLATE);\n        template = _mockVolumeDao.persist(template);\n        \n        return new CreatePrivateTemplateAnswer(cmd, true, \"\", template.getName(), template.getSize(), template.getSize(), template.getName(), ImageFormat.QCOW2);\n    }","id":9661,"modified_method":"@Override\n\tpublic CreatePrivateTemplateAnswer CreatePrivateTemplateFromSnapshot(CreatePrivateTemplateFromSnapshotCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockVolumeVO snapshot = null;\n\t\tMockSecStorageVO sec = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tString snapshotUUId = cmd.getSnapshotUuid();\n\t\t\tsnapshot = _mockVolumeDao.findByName(snapshotUUId);\n\t\t\tif (snapshot == null) {\n\t\t\t\tsnapshotUUId = cmd.getSnapshotName();\n\t\t\t\tsnapshot = _mockVolumeDao.findByName(snapshotUUId);\n\t\t\t\tif (snapshot == null) {\n\t\t\t\t\treturn new CreatePrivateTemplateAnswer(cmd, false, \"can't find snapshot:\" + snapshotUUId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsec = _mockSecStorageDao.findByUrl(cmd.getSecondaryStorageUrl());\n\t\t\tif (sec == null) {\n\t\t\t\treturn new CreatePrivateTemplateAnswer(cmd, false, \"can't find secondary storage\");\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tMockVolumeVO template = new MockVolumeVO();\n\t\tString uuid = UUID.randomUUID().toString();\n\t\ttemplate.setName(uuid);\n\t\ttemplate.setPath(sec.getMountPoint() + uuid);\n\t\ttemplate.setPoolId(sec.getId());\n\t\ttemplate.setSize(snapshot.getSize());\n\t\ttemplate.setStatus(Status.DOWNLOADED);\n\t\ttemplate.setType(MockVolumeType.TEMPLATE);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\ttemplate = _mockVolumeDao.persist(template);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when saving template \" + template, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\treturn new CreatePrivateTemplateAnswer(cmd, true, \"\", template.getName(), template.getSize(),\n\t\t\t\ttemplate.getSize(), template.getName(), ImageFormat.QCOW2);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CreateAnswer createVolume(CreateCommand cmd) {\n        StorageFilerTO sf = cmd.getPool();\n        DiskProfile dskch = cmd.getDiskCharacteristics();\n        MockStoragePoolVO storagePool = _mockStoragePoolDao.findByUuid(sf.getUuid());\n        if (storagePool == null) {\n            return new CreateAnswer(cmd, \"Failed to find storage pool: \" + sf.getUuid());\n        }\n        \n        String volumeName = UUID.randomUUID().toString();\n        MockVolumeVO volume = new MockVolumeVO();\n        volume.setPoolId(storagePool.getId());\n        volume.setName(volumeName);\n        volume.setPath(storagePool.getMountPoint() + volumeName);\n        volume.setSize(dskch.getSize());\n        volume.setType(MockVolumeType.VOLUME);\n        volume = _mockVolumeDao.persist(volume);\n        \n        VolumeTO volumeTo = new VolumeTO(cmd.getVolumeId(), dskch.getType(), sf.getType(), sf.getUuid(), \n                volume.getName(), storagePool.getMountPoint(), volume.getPath(), volume.getSize(), null);\n        \n        return new CreateAnswer(cmd, volumeTo);\n    }","id":9662,"modified_method":"@Override\n\tpublic CreateAnswer createVolume(CreateCommand cmd) {\n\t\tStorageFilerTO sf = cmd.getPool();\n\t\tDiskProfile dskch = cmd.getDiskCharacteristics();\n\t\tMockStoragePoolVO storagePool = null;\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tstoragePool = _mockStoragePoolDao.findByUuid(sf.getUuid());\n\t\t\ttxn.commit();\n\t\t\tif (storagePool == null) {\n\t\t\t\treturn new CreateAnswer(cmd, \"Failed to find storage pool: \" + sf.getUuid());\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when finding storage \" + sf.getUuid(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tString volumeName = UUID.randomUUID().toString();\n\t\tMockVolumeVO volume = new MockVolumeVO();\n\t\tvolume.setPoolId(storagePool.getId());\n\t\tvolume.setName(volumeName);\n\t\tvolume.setPath(storagePool.getMountPoint() + volumeName);\n\t\tvolume.setSize(dskch.getSize());\n\t\tvolume.setType(MockVolumeType.VOLUME);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvolume = _mockVolumeDao.persist(volume);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when saving volume \" + volume, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tVolumeTO volumeTo = new VolumeTO(cmd.getVolumeId(), dskch.getType(), sf.getType(), sf.getUuid(),\n\t\t\t\tvolume.getName(), storagePool.getMountPoint(), volume.getPath(), volume.getSize(), null);\n\n\t\treturn new CreateAnswer(cmd, volumeTo);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public DownloadAnswer Download(DownloadCommand cmd) {\n        MockSecStorageVO ssvo = _mockSecStorageDao.findByUrl(cmd.getSecUrl());\n        if (ssvo == null) {\n            return new DownloadAnswer(\"can't find secondary storage\", VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR);\n        }\n        \n        MockVolumeVO volume = new MockVolumeVO();\n        volume.setPoolId(ssvo.getId());\n        volume.setName(cmd.getName());\n        volume.setPath(ssvo.getMountPoint() + cmd.getName());\n        volume.setSize(0);\n        volume.setType(MockVolumeType.TEMPLATE);\n        volume.setStatus(Status.DOWNLOAD_IN_PROGRESS);\n        volume = _mockVolumeDao.persist(volume);\n       \n        return new DownloadAnswer(String.valueOf(volume.getId()), 0, \"Downloading\", Status.DOWNLOAD_IN_PROGRESS, cmd.getName(), cmd.getName(), volume.getSize(), volume.getSize(), null);\n    }","id":9663,"modified_method":"@Override\n\tpublic DownloadAnswer Download(DownloadCommand cmd) {\n\t\tMockSecStorageVO ssvo = null;\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tssvo = _mockSecStorageDao.findByUrl(cmd.getSecUrl());\n\t\t\tif (ssvo == null) {\n\t\t\t\treturn new DownloadAnswer(\"can't find secondary storage\",\n\t\t\t\t\t\tVMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error accessing secondary storage \" + cmd.getSecUrl(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\n\t\tMockVolumeVO volume = new MockVolumeVO();\n\t\tvolume.setPoolId(ssvo.getId());\n\t\tvolume.setName(cmd.getName());\n\t\tvolume.setPath(ssvo.getMountPoint() + cmd.getName());\n\t\tvolume.setSize(0);\n\t\tvolume.setType(MockVolumeType.TEMPLATE);\n\t\tvolume.setStatus(Status.DOWNLOAD_IN_PROGRESS);\n\t\ttxn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tvolume = _mockVolumeDao.persist(volume);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Error when saving volume \" + volume, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn new DownloadAnswer(String.valueOf(volume.getId()), 0, \"Downloading\", Status.DOWNLOAD_IN_PROGRESS,\n\t\t\t\tcmd.getName(), cmd.getName(), volume.getSize(), volume.getSize(), null);\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer ComputeChecksum(ComputeChecksumCommand cmd) {\n        MockVolumeVO volume = _mockVolumeDao.findByName(cmd.getTemplatePath());\n        if (volume == null) {\n            return new Answer(cmd, false, \"cant' find volume:\" + cmd.getTemplatePath());\n        }\n        String md5 = null;\n        try {\n            MessageDigest md =  MessageDigest.getInstance(\"md5\");\n            md5 = String.format(\"%032x\", new BigInteger(1, md.digest(cmd.getTemplatePath().getBytes())));\n        } catch (NoSuchAlgorithmException e) {\n            s_logger.debug(\"failed to gernerate md5:\" + e.toString());\n        }\n        \n        return new Answer(cmd, true, md5);\n    }","id":9664,"modified_method":"@Override\n\tpublic Answer ComputeChecksum(ComputeChecksumCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVolumeVO volume = _mockVolumeDao.findByName(cmd.getTemplatePath());\n\t\t\tif (volume == null) {\n\t\t\t\treturn new Answer(cmd, false, \"cant' find volume:\" + cmd.getTemplatePath());\n\t\t\t}\n\t\t\tString md5 = null;\n\t\t\ttry {\n\t\t\t\tMessageDigest md = MessageDigest.getInstance(\"md5\");\n\t\t\t\tmd5 = String.format(\"%032x\", new BigInteger(1, md.digest(cmd.getTemplatePath().getBytes())));\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\ts_logger.debug(\"failed to gernerate md5:\" + e.toString());\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn new Answer(cmd, true, md5);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Map<String, MockVMVO> getVms(String hostGuid) {\n\t\tList<MockVMVO> vms = _mockVmDao.findByHostGuid(hostGuid);\n\t\tMap<String, MockVMVO> vmMap = new HashMap<String, MockVMVO>();\n\t\tfor (MockVMVO vm : vms) {\n\t\t\tvmMap.put(vm.getName(), vm);\n\t\t}\n\t\treturn vmMap;\n\t}","id":9665,"modified_method":"@Override\n\tpublic Map<String, MockVMVO> getVms(String hostGuid) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tList<MockVMVO> vms = _mockVmDao.findByHostGuid(hostGuid);\n\t\t\tMap<String, MockVMVO> vmMap = new HashMap<String, MockVMVO>();\n\t\t\tfor (MockVMVO vm : vms) {\n\t\t\t\tvmMap.put(vm.getName(), vm);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn vmMap;\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to fetch vms  from host \" + hostGuid, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer stopVM(StopCommand cmd) {\n        String vmName = cmd.getVmName();\n        MockVm vm = _mockVmDao.findByVmName(vmName);\n        if(vm != null) {\n            vm.setState(State.Stopped);\n            _mockVmDao.update(vm.getId(), (MockVMVO)vm);\n        }\n\n        if (vmName.startsWith(\"s-\")) {\n            _mockAgentMgr.handleSystemVMStop(vm.getId());\n        }\n\n        return new StopAnswer(cmd, null, new Integer(0), true);\n    }","id":9666,"modified_method":"@Override\n\tpublic Answer stopVM(StopCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tString vmName = cmd.getVmName();\n\t\t\tMockVm vm = _mockVmDao.findByVmName(vmName);\n\t\t\tif (vm != null) {\n\t\t\t\tvm.setState(State.Stopped);\n\t\t\t\t_mockVmDao.update(vm.getId(), (MockVMVO) vm);\n\t\t\t}\n\n\t\t\tif (vmName.startsWith(\"s-\")) {\n\t\t\t\t_mockAgentMgr.handleSystemVMStop(vm.getId());\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn new StopAnswer(cmd, null, new Integer(0), true);\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to stop vm \" + cmd.getVmName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean rebootVM(String vmName) {\n\t    MockVm vm = _mockVmDao.findByVmName(vmName);\n\t    if(vm != null) {\n\t        vm.setState(State.Running);\n\t        _mockVmDao.update(vm.getId(), (MockVMVO)vm);\n\t    }\n\t    return true;\n\t}","id":9667,"modified_method":"public boolean rebootVM(String vmName) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVm vm = _mockVmDao.findByVmName(vmName);\n\t\t\tif (vm != null) {\n\t\t\t\tvm.setState(State.Running);\n\t\t\t\t_mockVmDao.update(vm.getId(), (MockVMVO) vm);\n\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to reboot vm \" + vmName, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t\treturn true;\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Map<String, State> getVmStates(String hostGuid) {\n\t\tMap<String, State> states = new HashMap<String, State>();\n\t\tList<MockVMVO> vms = _mockVmDao.findByHostGuid(hostGuid);\n\t\tif (vms.isEmpty()) {\n\t\t    return states;\n\t\t}\n\n\t\tfor(MockVm vm : vms) {\n\t\t    states.put(vm.getName(), vm.getState());\n\t\t}\n\n\t\treturn states;\n\t}","id":9668,"modified_method":"@Override\n\tpublic Map<String, State> getVmStates(String hostGuid) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMap<String, State> states = new HashMap<String, State>();\n\t\t\tList<MockVMVO> vms = _mockVmDao.findByHostGuid(hostGuid);\n\t\t\tif (vms.isEmpty()) {\n\t\t\t\ttxn.commit();\n\t\t\t\treturn states;\n\t\t\t}\n\t\t\tfor (MockVm vm : vms) {\n\t\t\t\tstates.put(vm.getName(), vm.getState());\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn states;\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to fetch vms  from host \" + hostGuid, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public CheckVirtualMachineAnswer checkVmState(CheckVirtualMachineCommand cmd) {\n        MockVMVO vm = _mockVmDao.findByVmName(cmd.getVmName());\n        if (vm == null) {\n            return new CheckVirtualMachineAnswer(cmd, \"can't find vm:\" + cmd.getVmName());\n        }\n        \n        return new CheckVirtualMachineAnswer(cmd, vm.getState(), vm.getVncPort());\n    }","id":9669,"modified_method":"@Override\n\tpublic CheckVirtualMachineAnswer checkVmState(CheckVirtualMachineCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVMVO vm = _mockVmDao.findByVmName(cmd.getVmName());\n\t\t\tif (vm == null) {\n\t\t\t\treturn new CheckVirtualMachineAnswer(cmd, \"can't find vm:\" + cmd.getVmName());\n\t\t\t}\n\n\t\t\ttxn.commit();\n\t\t\treturn new CheckVirtualMachineAnswer(cmd, vm.getState(), vm.getVncPort());\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to fetch vm state \" + cmd.getVmName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"public String startVM(String vmName, NicTO[] nics,\n        \tint cpuHz, long ramSize,\n        \tString bootArgs, String hostGuid) {\n\n        MockHost host = _mockHostDao.findByGuid(hostGuid);\n        if (host == null) {\n            return \"can't find host\";\n        }\n        \n        MockVm vm = _mockVmDao.findByVmName(vmName);\n        if(vm == null) {\n            int vncPort = 0;\n            if(vncPort < 0)\n                return \"Unable to allocate VNC port\";\n            vm = new MockVMVO();\n            vm.setCpu(cpuHz);\n            vm.setMemory(ramSize);\n            vm.setState(State.Running);\n            vm.setName(vmName);\n            vm.setVncPort(vncPort);\n            vm.setHostId(host.getId());\n            if(vmName.startsWith(\"s-\")) {\n            \tvm.setType(\"SecondaryStorageVm\");\n            } else if (vmName.startsWith(\"v-\")) {\n            \tvm.setType(\"ConsoleProxy\");\n            } else if (vmName.startsWith(\"r-\")) {\n            \tvm.setType(\"DomainRouter\");\n            } else if (vmName.startsWith(\"i-\")) {\n            \tvm.setType(\"User\");\n            }\n            vm = _mockVmDao.persist((MockVMVO)vm);\n        } else {\n            if(vm.getState() == State.Stopped) {\n                vm.setState(State.Running);\n                _mockVmDao.update(vm.getId(), (MockVMVO)vm);\n            }\n        }\n\n        if (vm.getState() == State.Running && vmName.startsWith(\"s-\")) {\n            String prvIp = null;\n            String prvMac = null;\n            String prvNetMask = null;\n\n            for (NicTO nic : nics) {\n                if (nic.getType() == TrafficType.Management) {\n                    prvIp = nic.getIp();\n                    prvMac = nic.getMac();\n                    prvNetMask = nic.getNetmask();\n                }\n            }\n            long dcId = 0;\n            long podId = 0;\n            String name = null;\n            String vmType = null;\n            String url = null;\n            String[] args = bootArgs.trim().split(\" \");\n            for (String arg : args) {\n                String[] params = arg.split(\"=\");\n                if (params.length < 1) {\n                    continue;\n                }\n\n                if (params[0].equalsIgnoreCase(\"zone\")) {\n                    dcId = Long.parseLong(params[1]);\n                } else if (params[0].equalsIgnoreCase(\"name\")) {\n                    name = params[1];\n                } else if (params[0].equalsIgnoreCase(\"type\")) {\n                    vmType = params[1];\n                } else if (params[0].equalsIgnoreCase(\"url\")) {\n                    url = params[1];\n                } else if (params[0].equalsIgnoreCase(\"pod\")) {\n                    podId = Long.parseLong(params[1]);\n                }\n            }\n\n            _mockAgentMgr.handleSystemVMStart(vm.getId(), prvIp, prvMac, prvNetMask, dcId, podId, name, vmType, url);\n        }\n\n        return null;\n    }","id":9670,"modified_method":"public String startVM(String vmName, NicTO[] nics,\n        \tint cpuHz, long ramSize,\n        \tString bootArgs, String hostGuid) {\n\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\tMockHost host = null;\n\t\tMockVm vm = null;\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\thost = _mockHostDao.findByGuid(hostGuid);\n\t\t\tif (host == null) {\n\t\t\t\treturn \"can't find host\";\n\t\t\t}\n\n\t\t\tvm = _mockVmDao.findByVmName(vmName);\n\t\t\ttxn.commit();\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to start VM \" + vmName, ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n    \t\n        if(vm == null) {\n            int vncPort = 0;\n            if(vncPort < 0)\n                return \"Unable to allocate VNC port\";\n            vm = new MockVMVO();\n            vm.setCpu(cpuHz);\n            vm.setMemory(ramSize);\n            vm.setState(State.Running);\n            vm.setName(vmName);\n            vm.setVncPort(vncPort);\n            vm.setHostId(host.getId());\n            if(vmName.startsWith(\"s-\")) {\n            \tvm.setType(\"SecondaryStorageVm\");\n            } else if (vmName.startsWith(\"v-\")) {\n            \tvm.setType(\"ConsoleProxy\");\n            } else if (vmName.startsWith(\"r-\")) {\n            \tvm.setType(\"DomainRouter\");\n            } else if (vmName.startsWith(\"i-\")) {\n            \tvm.setType(\"User\");\n            }\n            txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\t\ttry {\n\t\t\t\ttxn.start();\n\t\t\t\tvm = _mockVmDao.persist((MockVMVO) vm);\n\t\t\t\ttxn.commit();\n\t\t\t} catch (Exception ex) {\n\t\t\t\ttxn.rollback();\n\t\t\t\tthrow new CloudRuntimeException(\"unable to save vm to db \" + vm.getName(), ex);\n\t\t\t} finally {\n\t\t\t\ttxn.close();\n                txn = Transaction.open(Transaction.CLOUD_DB);\n                txn.close();\n\t\t\t}\n        } else {\n            if(vm.getState() == State.Stopped) {\n                vm.setState(State.Running);\n                txn = Transaction.open(Transaction.SIMULATOR_DB);\n    \t\t\ttry {\n    \t\t\t\ttxn.start();\n    \t\t\t\t_mockVmDao.update(vm.getId(), (MockVMVO)vm);\n    \t\t\t\ttxn.commit();\n    \t\t\t} catch (Exception ex) {\n    \t\t\t\ttxn.rollback();\n    \t\t\t\tthrow new CloudRuntimeException(\"unable to update vm \" + vm.getName(), ex);\n    \t\t\t} finally {\n    \t\t\t\ttxn.close();\n                    txn = Transaction.open(Transaction.CLOUD_DB);\n                    txn.close();\n    \t\t\t}\n            }\n        }\n\n        if (vm.getState() == State.Running && vmName.startsWith(\"s-\")) {\n            String prvIp = null;\n            String prvMac = null;\n            String prvNetMask = null;\n\n            for (NicTO nic : nics) {\n                if (nic.getType() == TrafficType.Management) {\n                    prvIp = nic.getIp();\n                    prvMac = nic.getMac();\n                    prvNetMask = nic.getNetmask();\n                }\n            }\n            long dcId = 0;\n            long podId = 0;\n            String name = null;\n            String vmType = null;\n            String url = null;\n            String[] args = bootArgs.trim().split(\" \");\n            for (String arg : args) {\n                String[] params = arg.split(\"=\");\n                if (params.length < 1) {\n                    continue;\n                }\n\n                if (params[0].equalsIgnoreCase(\"zone\")) {\n                    dcId = Long.parseLong(params[1]);\n                } else if (params[0].equalsIgnoreCase(\"name\")) {\n                    name = params[1];\n                } else if (params[0].equalsIgnoreCase(\"type\")) {\n                    vmType = params[1];\n                } else if (params[0].equalsIgnoreCase(\"url\")) {\n                    url = params[1];\n                } else if (params[0].equalsIgnoreCase(\"pod\")) {\n                    podId = Long.parseLong(params[1]);\n                }\n            }\n\n            _mockAgentMgr.handleSystemVMStart(vm.getId(), prvIp, prvMac, prvNetMask, dcId, podId, name, vmType, url);\n        }\n\n        return null;\n    }","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer rebootVM(RebootCommand cmd) {\n        return new RebootAnswer(cmd, \"Rebooted \"+cmd.getVmName(), false);\n    }","id":9671,"modified_method":"@Override\n\tpublic Answer rebootVM(RebootCommand cmd) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockVm vm = _mockVmDao.findByVmName(cmd.getVmName());\n\t\t\tif (vm != null) {\n\t\t\t\tvm.setState(State.Running);\n\t\t\t\t_mockVmDao.update(vm.getId(), (MockVMVO) vm);\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn new RebootAnswer(cmd, \"Rebooted \" + cmd.getVmName(), true);\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to stop vm \" + cmd.getVmName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n\t\t\ttxn = Transaction.open(Transaction.CLOUD_DB);\n\t\t\ttxn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Answer CleanupNetworkRules(CleanupNetworkRulesCmd cmd, SimulatorInfo info) {\n        List<MockSecurityRulesVO> rules = _mockSecurityDao.findByHost(info.getHostUuid());\n        for (MockSecurityRulesVO rule : rules) {\n            MockVMVO vm = _mockVmDao.findByVmNameAndHost(rule.getVmName(), info.getHostUuid());\n            if (vm == null) {\n                _mockSecurityDao.remove(rule.getId());\n            }\n        }\n        return new Answer(cmd);\n    }","id":9672,"modified_method":"@Override\n\tpublic Answer CleanupNetworkRules(CleanupNetworkRulesCmd cmd, SimulatorInfo info) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tList<MockSecurityRulesVO> rules = _mockSecurityDao.findByHost(info.getHostUuid());\n\t\t\tfor (MockSecurityRulesVO rule : rules) {\n\t\t\t\tMockVMVO vm = _mockVmDao.findByVmNameAndHost(rule.getVmName(), info.getHostUuid());\n\t\t\t\tif (vm == null) {\n\t\t\t\t\t_mockSecurityDao.remove(rule.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t\ttxn.commit();\n\t\t\treturn new Answer(cmd);\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to clean up rules\", ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public MigrateAnswer Migrate(MigrateCommand cmd, SimulatorInfo info) {\n        String vmName = cmd.getVmName();\n        String destGuid = cmd.getHostGuid();\n        MockVMVO vm = _mockVmDao.findByVmNameAndHost(vmName, info.getHostUuid());\n        if (vm == null) {\n            return new MigrateAnswer(cmd, false, \"can;t find vm:\" + vmName + \" on host:\" + info.getHostUuid(), null);\n        }\n        \n        MockHost destHost = _mockHostDao.findByGuid(destGuid);\n        if (destHost == null) {\n            return new MigrateAnswer(cmd, false, \"can;t find host:\" + info.getHostUuid(), null);\n        }\n        vm.setHostId(destHost.getId());\n        _mockVmDao.update(vm.getId(), vm);\n        return new MigrateAnswer(cmd, true,null, 0);\n    }","id":9673,"modified_method":"@Override\n\tpublic MigrateAnswer Migrate(MigrateCommand cmd, SimulatorInfo info) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tString vmName = cmd.getVmName();\n\t\t\tString destGuid = cmd.getHostGuid();\n\t\t\tMockVMVO vm = _mockVmDao.findByVmNameAndHost(vmName, info.getHostUuid());\n\t\t\tif (vm == null) {\n\t\t\t\treturn new MigrateAnswer(cmd, false, \"can;t find vm:\" + vmName + \" on host:\" + info.getHostUuid(), null);\n\t\t\t}\n\n\t\t\tMockHost destHost = _mockHostDao.findByGuid(destGuid);\n\t\t\tif (destHost == null) {\n\t\t\t\treturn new MigrateAnswer(cmd, false, \"can;t find host:\" + info.getHostUuid(), null);\n\t\t\t}\n\t\t\tvm.setHostId(destHost.getId());\n\t\t\t_mockVmDao.update(vm.getId(), vm);\n\t\t\ttxn.commit();\n\t\t\treturn new MigrateAnswer(cmd, true, null, 0);\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"unable to migrate vm \" + cmd.getVmName(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n\t\t}\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean configureSimulator(Long zoneId, Long podId, Long clusterId, Long hostId, String command, String values) {\n    \tMockConfigurationVO config = _mockConfigDao.findByCommand(zoneId, podId, clusterId, hostId, command);\n    \tif (config == null) {\n    \t\tconfig = new MockConfigurationVO();\n    \t\tconfig.setClusterId(clusterId);\n    \t\tconfig.setDataCenterId(zoneId);\n    \t\tconfig.setPodId(podId);\n    \t\tconfig.setHostId(hostId);\n    \t\tconfig.setName(command);\n    \t\tconfig.setValues(values);\n    \t\t_mockConfigDao.persist(config);\n    \t} else {\n    \t\tconfig.setValues(values);\n    \t\t_mockConfigDao.update(config.getId(), config);\n    \t}\n        return true;\n    }","id":9674,"modified_method":"@Override\n\tpublic boolean configureSimulator(Long zoneId, Long podId, Long clusterId, Long hostId, String command,\n\t\t\tString values) {\n\t\tTransaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n\t\ttry {\n\t\t\ttxn.start();\n\t\t\tMockConfigurationVO config = _mockConfigDao.findByCommand(zoneId, podId, clusterId, hostId, command);\n\t\t\tif (config == null) {\n\t\t\t\tconfig = new MockConfigurationVO();\n\t\t\t\tconfig.setClusterId(clusterId);\n\t\t\t\tconfig.setDataCenterId(zoneId);\n\t\t\t\tconfig.setPodId(podId);\n\t\t\t\tconfig.setHostId(hostId);\n\t\t\t\tconfig.setName(command);\n\t\t\t\tconfig.setValues(values);\n\t\t\t\t_mockConfigDao.persist(config);\n\t\t\t\ttxn.commit();\n\t\t\t} else {\n\t\t\t\tconfig.setValues(values);\n\t\t\t\t_mockConfigDao.update(config.getId(), config);\n\t\t\t\ttxn.commit();\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\ttxn.rollback();\n\t\t\tthrow new CloudRuntimeException(\"Unable to configure simulator because of \" + ex.getMessage(), ex);\n\t\t} finally {\n\t\t\ttxn.close();\n\t\t}\n\t\treturn true;\n\t}","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    @Override\n    public Answer simulate(Command cmd, String hostGuid) {\n        Transaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n //       txn.transitToUserManagedConnection(_concierge.conn());\n        \n        try {\n            MockHost host = _mockHost.findByGuid(hostGuid);\n            String cmdName = cmd.toString();\n            int index = cmdName.lastIndexOf(\".\");\n            if (index != -1) {\n            \tcmdName = cmdName.substring(index + 1);\n            }\n            MockConfigurationVO config = _mockConfigDao.findByNameBottomUP(host.getDataCenterId(), host.getPodId(), host.getClusterId(), host.getId(), cmdName);\n            \n            SimulatorInfo info = new SimulatorInfo();\n            info.setHostUuid(hostGuid);\n            \n            if (config != null) {\n                Map<String, String> configParameters = config.getParameters();\n                for (Map.Entry<String, String> entry : configParameters.entrySet()) {\n                \tif (entry.getKey().equalsIgnoreCase(\"enabled\")) {\n                \t\tinfo.setEnabled(Boolean.parseBoolean(entry.getValue()));\n                \t} else if (entry.getKey().equalsIgnoreCase(\"timeout\")) {\n                \t\ttry {\n                \t\t\tinfo.setTimeout(Integer.valueOf(entry.getValue()));\n                \t\t} catch (NumberFormatException e) {\n                \t\t\ts_logger.debug(\"invalid timeout parameter: \" + e.toString());\n                \t\t}\n                \t} else if (entry.getKey().equalsIgnoreCase(\"wait\")) {\n                \t\ttry {\n                \t\t\tint wait = Integer.valueOf(entry.getValue());\n                \t\t\tThread.sleep(wait * 1000);\n                \t\t} catch (NumberFormatException e) {\n                \t\t\ts_logger.debug(\"invalid timeout parameter: \" + e.toString());\n                \t\t} catch (InterruptedException e) {\n                \t\t\ts_logger.debug(\"thread is interrupted: \" + e.toString());\n                \t\t}\n                \t}\n                }\n            }\n            \n            if (cmd instanceof GetHostStatsCommand) {\n                return _mockAgentMgr.getHostStatistic((GetHostStatsCommand)cmd);\n            } else if (cmd instanceof CheckHealthCommand) {\n                return _mockAgentMgr.checkHealth((CheckHealthCommand)cmd);\n            } else if (cmd instanceof PingTestCommand) {\n                return _mockAgentMgr.pingTest((PingTestCommand)cmd);\n            } else if (cmd instanceof PrepareForMigrationCommand) {\n            \treturn _mockAgentMgr.prepareForMigrate((PrepareForMigrationCommand)cmd);\n            } else if (cmd instanceof MigrateCommand) {\n                return _mockVmMgr.Migrate((MigrateCommand)cmd, info);\n            } else if (cmd instanceof StartCommand) {\n                return _mockVmMgr.startVM((StartCommand)cmd, info);\n            } else if (cmd instanceof CheckSshCommand) {\n                return _mockVmMgr.checkSshCommand((CheckSshCommand)cmd);\n            } else if (cmd instanceof CheckVirtualMachineCommand) {\n            \treturn _mockVmMgr.checkVmState((CheckVirtualMachineCommand)cmd);\n            } else if (cmd instanceof SetStaticNatRulesCommand) {\n                return _mockVmMgr.SetStaticNatRules((SetStaticNatRulesCommand)cmd);\n            } else if (cmd instanceof SetFirewallRulesCommand) {\n            \treturn _mockVmMgr.SetFirewallRules((SetFirewallRulesCommand)cmd); \n            } else if (cmd instanceof SetPortForwardingRulesCommand) {\n                return _mockVmMgr.SetPortForwardingRules((SetPortForwardingRulesCommand)cmd);\n            } else if (cmd instanceof NetworkUsageCommand) {\n                return _mockVmMgr.getNetworkUsage((NetworkUsageCommand)cmd);\n            } else if (cmd instanceof IpAssocCommand) {\n                return _mockVmMgr.IpAssoc((IpAssocCommand)cmd);\n            } else if (cmd instanceof LoadBalancerConfigCommand) {\n                return _mockVmMgr.LoadBalancerConfig((LoadBalancerConfigCommand)cmd);\n            } else if (cmd instanceof DhcpEntryCommand) {\n                return _mockVmMgr.AddDhcpEntry((DhcpEntryCommand)cmd);\n            } else if (cmd instanceof VmDataCommand) {\n                return _mockVmMgr.setVmData((VmDataCommand)cmd);\n            } else if (cmd instanceof CleanupNetworkRulesCmd) {\n                return _mockVmMgr.CleanupNetworkRules((CleanupNetworkRulesCmd)cmd, info);\n            } else if (cmd instanceof CheckNetworkCommand) {\n            \treturn _mockAgentMgr.checkNetworkCommand((CheckNetworkCommand) cmd);\n            }else if (cmd instanceof StopCommand) {\n                return _mockVmMgr.stopVM((StopCommand)cmd);\n            } else if (cmd instanceof RebootCommand) {\n                return _mockVmMgr.rebootVM((RebootCommand)cmd);\n            } else if (cmd instanceof GetVncPortCommand) {\n                return _mockVmMgr.getVncPort((GetVncPortCommand)cmd);\n            } else if (cmd instanceof CheckConsoleProxyLoadCommand) {\n                return _mockVmMgr.CheckConsoleProxyLoad((CheckConsoleProxyLoadCommand)cmd);\n            } else if (cmd instanceof WatchConsoleProxyLoadCommand) {\n                return _mockVmMgr.WatchConsoleProxyLoad((WatchConsoleProxyLoadCommand)cmd);\n            } else if (cmd instanceof SecurityGroupRulesCmd) {\n                return _mockVmMgr.AddSecurityGroupRules((SecurityGroupRulesCmd)cmd, info);\n            } else if (cmd instanceof SavePasswordCommand) {\n                return _mockVmMgr.SavePassword((SavePasswordCommand)cmd);\n            } else if (cmd instanceof PrimaryStorageDownloadCommand) {\n                return _mockStorageMgr.primaryStorageDownload((PrimaryStorageDownloadCommand)cmd);\n            } else if (cmd instanceof CreateCommand) {\n                return _mockStorageMgr.createVolume((CreateCommand)cmd);\n            } else if (cmd instanceof AttachVolumeCommand) {\n                return _mockStorageMgr.AttachVolume((AttachVolumeCommand)cmd);\n            } else if (cmd instanceof AttachIsoCommand) {\n                return _mockStorageMgr.AttachIso((AttachIsoCommand)cmd);\n            } else if (cmd instanceof DeleteStoragePoolCommand) {\n                return _mockStorageMgr.DeleteStoragePool((DeleteStoragePoolCommand)cmd);\n            } else if (cmd instanceof ModifyStoragePoolCommand) {\n                return _mockStorageMgr.ModifyStoragePool((ModifyStoragePoolCommand)cmd);\n            } else if (cmd instanceof CreateStoragePoolCommand) {\n                return _mockStorageMgr.CreateStoragePool((CreateStoragePoolCommand)cmd);\n            } else if (cmd instanceof SecStorageSetupCommand) {\n                return _mockStorageMgr.SecStorageSetup((SecStorageSetupCommand)cmd);\n            } else if (cmd instanceof ListTemplateCommand) {\n                return _mockStorageMgr.ListTemplates((ListTemplateCommand)cmd);\n            } else if (cmd instanceof DestroyCommand) {\n                return _mockStorageMgr.Destroy((DestroyCommand)cmd);\n            } else if (cmd instanceof DownloadProgressCommand) {\n                return _mockStorageMgr.DownloadProcess((DownloadProgressCommand)cmd);\n            } else if (cmd instanceof DownloadCommand) {\n                return _mockStorageMgr.Download((DownloadCommand)cmd);\n            } else if (cmd instanceof GetStorageStatsCommand) {\n                return _mockStorageMgr.GetStorageStats((GetStorageStatsCommand)cmd);\n            } else if (cmd instanceof ManageSnapshotCommand) {\n                return _mockStorageMgr.ManageSnapshot((ManageSnapshotCommand)cmd);\n            } else if (cmd instanceof BackupSnapshotCommand) {\n                return _mockStorageMgr.BackupSnapshot((BackupSnapshotCommand)cmd, info);\n            } else if (cmd instanceof DeleteSnapshotBackupCommand) {\n                return _mockStorageMgr.DeleteSnapshotBackup((DeleteSnapshotBackupCommand)cmd);\n            } else if (cmd instanceof CreateVolumeFromSnapshotCommand) {\n                return _mockStorageMgr.CreateVolumeFromSnapshot((CreateVolumeFromSnapshotCommand)cmd);\n            } else if (cmd instanceof DeleteTemplateCommand) {\n                return _mockStorageMgr.DeleteTemplate((DeleteTemplateCommand)cmd);\n            } else if (cmd instanceof SecStorageVMSetupCommand) {\n                return _mockStorageMgr.SecStorageVMSetup((SecStorageVMSetupCommand)cmd);\n            } else if (cmd instanceof CreatePrivateTemplateFromSnapshotCommand) {\n                return _mockStorageMgr.CreatePrivateTemplateFromSnapshot((CreatePrivateTemplateFromSnapshotCommand)cmd);\n            } else if (cmd instanceof ComputeChecksumCommand) {\n                return _mockStorageMgr.ComputeChecksum((ComputeChecksumCommand)cmd);\n            } else if (cmd instanceof CreatePrivateTemplateFromVolumeCommand) {\n                return _mockStorageMgr.CreatePrivateTemplateFromVolume((CreatePrivateTemplateFromVolumeCommand)cmd);\n            } else if (cmd instanceof MaintainCommand) {\n                return _mockAgentMgr.maintain((MaintainCommand)cmd);\n            } else if (cmd instanceof GetVmStatsCommand) {\n                return _mockVmMgr.getVmStats((GetVmStatsCommand)cmd);\n            } else if (cmd instanceof GetDomRVersionCmd) {\n            \treturn _mockVmMgr.getDomRVersion((GetDomRVersionCmd)cmd);\n            } else if (cmd instanceof ClusterSyncCommand) {\n            \treturn new Answer(cmd);\n            } else if (cmd instanceof CopyVolumeCommand) {\n            \treturn _mockStorageMgr.CopyVolume((CopyVolumeCommand)cmd);\n            } else {\n                return Answer.createUnsupportedCommandAnswer(cmd);\n            }\n        } catch(Exception e) {\n            s_logger.debug(\"Failed execute cmd: \" + e.toString());\n            txn.rollback();\n            return new Answer(cmd, false, e.toString());\n        } finally {\n            txn.transitToAutoManagedConnection(Transaction.CLOUD_DB);\n        }\n    }","id":9675,"modified_method":"@DB\n    @Override\n    public Answer simulate(Command cmd, String hostGuid) {\n        Transaction txn = Transaction.open(Transaction.SIMULATOR_DB);\n //       txn.transitToUserManagedConnection(_concierge.conn());\n        \n        try {\n            MockHost host = _mockHost.findByGuid(hostGuid);\n            String cmdName = cmd.toString();\n            int index = cmdName.lastIndexOf(\".\");\n            if (index != -1) {\n            \tcmdName = cmdName.substring(index + 1);\n            }\n            MockConfigurationVO config = _mockConfigDao.findByNameBottomUP(host.getDataCenterId(), host.getPodId(), host.getClusterId(), host.getId(), cmdName);\n            \n            SimulatorInfo info = new SimulatorInfo();\n            info.setHostUuid(hostGuid);\n            \n            if (config != null) {\n                Map<String, String> configParameters = config.getParameters();\n                for (Map.Entry<String, String> entry : configParameters.entrySet()) {\n                \tif (entry.getKey().equalsIgnoreCase(\"enabled\")) {\n                \t\tinfo.setEnabled(Boolean.parseBoolean(entry.getValue()));\n                \t} else if (entry.getKey().equalsIgnoreCase(\"timeout\")) {\n                \t\ttry {\n                \t\t\tinfo.setTimeout(Integer.valueOf(entry.getValue()));\n                \t\t} catch (NumberFormatException e) {\n                \t\t\ts_logger.debug(\"invalid timeout parameter: \" + e.toString());\n                \t\t}\n                \t} else if (entry.getKey().equalsIgnoreCase(\"wait\")) {\n                \t\ttry {\n                \t\t\tint wait = Integer.valueOf(entry.getValue());\n                \t\t\tThread.sleep(wait * 1000);\n                \t\t} catch (NumberFormatException e) {\n                \t\t\ts_logger.debug(\"invalid timeout parameter: \" + e.toString());\n                \t\t} catch (InterruptedException e) {\n                \t\t\ts_logger.debug(\"thread is interrupted: \" + e.toString());\n                \t\t}\n                \t}\n                }\n            }\n            \n            if (cmd instanceof GetHostStatsCommand) {\n                return _mockAgentMgr.getHostStatistic((GetHostStatsCommand)cmd);\n            } else if (cmd instanceof CheckHealthCommand) {\n                return _mockAgentMgr.checkHealth((CheckHealthCommand)cmd);\n            } else if (cmd instanceof PingTestCommand) {\n                return _mockAgentMgr.pingTest((PingTestCommand)cmd);\n            } else if (cmd instanceof PrepareForMigrationCommand) {\n            \treturn _mockAgentMgr.prepareForMigrate((PrepareForMigrationCommand)cmd);\n            } else if (cmd instanceof MigrateCommand) {\n                return _mockVmMgr.Migrate((MigrateCommand)cmd, info);\n            } else if (cmd instanceof StartCommand) {\n                return _mockVmMgr.startVM((StartCommand)cmd, info);\n            } else if (cmd instanceof CheckSshCommand) {\n                return _mockVmMgr.checkSshCommand((CheckSshCommand)cmd);\n            } else if (cmd instanceof CheckVirtualMachineCommand) {\n            \treturn _mockVmMgr.checkVmState((CheckVirtualMachineCommand)cmd);\n            } else if (cmd instanceof SetStaticNatRulesCommand) {\n                return _mockVmMgr.SetStaticNatRules((SetStaticNatRulesCommand)cmd);\n            } else if (cmd instanceof SetFirewallRulesCommand) {\n            \treturn _mockVmMgr.SetFirewallRules((SetFirewallRulesCommand)cmd); \n            } else if (cmd instanceof SetPortForwardingRulesCommand) {\n                return _mockVmMgr.SetPortForwardingRules((SetPortForwardingRulesCommand)cmd);\n            } else if (cmd instanceof NetworkUsageCommand) {\n                return _mockVmMgr.getNetworkUsage((NetworkUsageCommand)cmd);\n            } else if (cmd instanceof IpAssocCommand) {\n                return _mockVmMgr.IpAssoc((IpAssocCommand)cmd);\n            } else if (cmd instanceof LoadBalancerConfigCommand) {\n                return _mockVmMgr.LoadBalancerConfig((LoadBalancerConfigCommand)cmd);\n            } else if (cmd instanceof DhcpEntryCommand) {\n                return _mockVmMgr.AddDhcpEntry((DhcpEntryCommand)cmd);\n            } else if (cmd instanceof VmDataCommand) {\n                return _mockVmMgr.setVmData((VmDataCommand)cmd);\n            } else if (cmd instanceof CleanupNetworkRulesCmd) {\n                return _mockVmMgr.CleanupNetworkRules((CleanupNetworkRulesCmd)cmd, info);\n            } else if (cmd instanceof CheckNetworkCommand) {\n            \treturn _mockAgentMgr.checkNetworkCommand((CheckNetworkCommand) cmd);\n            }else if (cmd instanceof StopCommand) {\n                return _mockVmMgr.stopVM((StopCommand)cmd);\n            } else if (cmd instanceof RebootCommand) {\n                return _mockVmMgr.rebootVM((RebootCommand)cmd);\n            } else if (cmd instanceof GetVncPortCommand) {\n                return _mockVmMgr.getVncPort((GetVncPortCommand)cmd);\n            } else if (cmd instanceof CheckConsoleProxyLoadCommand) {\n                return _mockVmMgr.CheckConsoleProxyLoad((CheckConsoleProxyLoadCommand)cmd);\n            } else if (cmd instanceof WatchConsoleProxyLoadCommand) {\n                return _mockVmMgr.WatchConsoleProxyLoad((WatchConsoleProxyLoadCommand)cmd);\n            } else if (cmd instanceof SecurityGroupRulesCmd) {\n                return _mockVmMgr.AddSecurityGroupRules((SecurityGroupRulesCmd)cmd, info);\n            } else if (cmd instanceof SavePasswordCommand) {\n                return _mockVmMgr.SavePassword((SavePasswordCommand)cmd);\n            } else if (cmd instanceof PrimaryStorageDownloadCommand) {\n                return _mockStorageMgr.primaryStorageDownload((PrimaryStorageDownloadCommand)cmd);\n            } else if (cmd instanceof CreateCommand) {\n                return _mockStorageMgr.createVolume((CreateCommand)cmd);\n            } else if (cmd instanceof AttachVolumeCommand) {\n                return _mockStorageMgr.AttachVolume((AttachVolumeCommand)cmd);\n            } else if (cmd instanceof AttachIsoCommand) {\n                return _mockStorageMgr.AttachIso((AttachIsoCommand)cmd);\n            } else if (cmd instanceof DeleteStoragePoolCommand) {\n                return _mockStorageMgr.DeleteStoragePool((DeleteStoragePoolCommand)cmd);\n            } else if (cmd instanceof ModifyStoragePoolCommand) {\n                return _mockStorageMgr.ModifyStoragePool((ModifyStoragePoolCommand)cmd);\n            } else if (cmd instanceof CreateStoragePoolCommand) {\n                return _mockStorageMgr.CreateStoragePool((CreateStoragePoolCommand)cmd);\n            } else if (cmd instanceof SecStorageSetupCommand) {\n                return _mockStorageMgr.SecStorageSetup((SecStorageSetupCommand)cmd);\n            } else if (cmd instanceof ListTemplateCommand) {\n                return _mockStorageMgr.ListTemplates((ListTemplateCommand)cmd);\n            } else if (cmd instanceof DestroyCommand) {\n                return _mockStorageMgr.Destroy((DestroyCommand)cmd);\n            } else if (cmd instanceof DownloadProgressCommand) {\n                return _mockStorageMgr.DownloadProcess((DownloadProgressCommand)cmd);\n            } else if (cmd instanceof DownloadCommand) {\n                return _mockStorageMgr.Download((DownloadCommand)cmd);\n            } else if (cmd instanceof GetStorageStatsCommand) {\n                return _mockStorageMgr.GetStorageStats((GetStorageStatsCommand)cmd);\n            } else if (cmd instanceof ManageSnapshotCommand) {\n                return _mockStorageMgr.ManageSnapshot((ManageSnapshotCommand)cmd);\n            } else if (cmd instanceof BackupSnapshotCommand) {\n                return _mockStorageMgr.BackupSnapshot((BackupSnapshotCommand)cmd, info);\n            } else if (cmd instanceof DeleteSnapshotBackupCommand) {\n                return _mockStorageMgr.DeleteSnapshotBackup((DeleteSnapshotBackupCommand)cmd);\n            } else if (cmd instanceof CreateVolumeFromSnapshotCommand) {\n                return _mockStorageMgr.CreateVolumeFromSnapshot((CreateVolumeFromSnapshotCommand)cmd);\n            } else if (cmd instanceof DeleteTemplateCommand) {\n                return _mockStorageMgr.DeleteTemplate((DeleteTemplateCommand)cmd);\n            } else if (cmd instanceof SecStorageVMSetupCommand) {\n                return _mockStorageMgr.SecStorageVMSetup((SecStorageVMSetupCommand)cmd);\n            } else if (cmd instanceof CreatePrivateTemplateFromSnapshotCommand) {\n                return _mockStorageMgr.CreatePrivateTemplateFromSnapshot((CreatePrivateTemplateFromSnapshotCommand)cmd);\n            } else if (cmd instanceof ComputeChecksumCommand) {\n                return _mockStorageMgr.ComputeChecksum((ComputeChecksumCommand)cmd);\n            } else if (cmd instanceof CreatePrivateTemplateFromVolumeCommand) {\n                return _mockStorageMgr.CreatePrivateTemplateFromVolume((CreatePrivateTemplateFromVolumeCommand)cmd);\n            } else if (cmd instanceof MaintainCommand) {\n                return _mockAgentMgr.maintain((MaintainCommand)cmd);\n            } else if (cmd instanceof GetVmStatsCommand) {\n                return _mockVmMgr.getVmStats((GetVmStatsCommand)cmd);\n            } else if (cmd instanceof GetDomRVersionCmd) {\n            \treturn _mockVmMgr.getDomRVersion((GetDomRVersionCmd)cmd);\n            } else if (cmd instanceof ClusterSyncCommand) {\n            \treturn new Answer(cmd);\n            \t//return new ClusterSyncAnswer(((ClusterSyncCommand) cmd).getClusterId(), this.getVmStates(hostGuid));\n            } else if (cmd instanceof CopyVolumeCommand) {\n            \treturn _mockStorageMgr.CopyVolume((CopyVolumeCommand)cmd);\n            } else {\n                return Answer.createUnsupportedCommandAnswer(cmd);\n            }\n        } catch(Exception e) {\n            s_logger.error(\"Failed execute cmd: \" + e.toString());\n            txn.rollback();\n            return new Answer(cmd, false, e.toString());\n        } finally {\n            txn.close();\n            txn = Transaction.open(Transaction.CLOUD_DB);\n            txn.close();\n        }\n    }","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public Map<String, MockVMVO> getVms(String hostGuid) {\n        Transaction txn = Transaction.currentTxn();\n        txn.transitToUserManagedConnection(_concierge.conn());\n        try {\n            return _mockVmMgr.getVms(hostGuid);\n        } finally {\n            txn.transitToAutoManagedConnection(Transaction.CLOUD_DB);\n        }\n    }","id":9676,"modified_method":"@Override\n    public Map<String, MockVMVO> getVms(String hostGuid) {\n    \treturn _mockVmMgr.getVms(hostGuid);\n    }","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public Map<String, State> getVmStates(String hostGuid) {\n        Transaction txn = Transaction.currentTxn();\n        txn.transitToUserManagedConnection(_concierge.conn());\n        try {\n            return _mockVmMgr.getVmStates(hostGuid);\n        } finally {\n            txn.transitToAutoManagedConnection(Transaction.CLOUD_DB);\n        }\n    }","id":9677,"modified_method":"@Override\n    public Map<String, State> getVmStates(String hostGuid) {\n    \treturn _mockVmMgr.getVmStates(hostGuid);\n    }","commit_id":"efc58cdea3917b0b7e88240c03d51c2a2e64a62e","url":"https://github.com/apache/cloudstack"},{"original_method":"protected GeoPointFieldType(GeoPointFieldType ref) {\n            super(ref);\n            this.geohashFieldType = ref.geohashFieldType; // copying ref is ok, this can never be modified\n            this.geohashPrecision = ref.geohashPrecision;\n            this.geohashPrefixEnabled = ref.geohashPrefixEnabled;\n            this.latFieldType = ref.latFieldType; // copying ref is ok, this can never be modified\n            this.lonFieldType = ref.lonFieldType; // copying ref is ok, this can never be modified\n            this.coerce = ref.coerce;\n            this.ignoreMalformed = ref.ignoreMalformed;\n        }","id":9678,"modified_method":"protected GeoPointFieldType(GeoPointFieldType ref) {\n            super(ref);\n            this.geohashFieldType = ref.geohashFieldType; // copying ref is ok, this can never be modified\n            this.geohashPrecision = ref.geohashPrecision;\n            this.geohashPrefixEnabled = ref.geohashPrefixEnabled;\n            this.latFieldType = ref.latFieldType; // copying ref is ok, this can never be modified\n            this.lonFieldType = ref.lonFieldType; // copying ref is ok, this can never be modified\n        }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public GeoPointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType, Settings indexSettings,\n            ContentPath.Type pathType, DoubleFieldMapper latMapper, DoubleFieldMapper lonMapper, StringFieldMapper geohashMapper,\n            MultiFields multiFields) {\n        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, null);\n        this.pathType = pathType;\n        this.latMapper = latMapper;\n        this.lonMapper = lonMapper;\n        this.geohashMapper = geohashMapper;\n    }","id":9679,"modified_method":"public GeoPointFieldMapper(String simpleName, MappedFieldType fieldType, MappedFieldType defaultFieldType, Settings indexSettings,\n            ContentPath.Type pathType, DoubleFieldMapper latMapper, DoubleFieldMapper lonMapper, StringFieldMapper geohashMapper,\n            MultiFields multiFields, Explicit<Boolean> ignoreMalformed, Explicit<Boolean> coerce) {\n        super(simpleName, fieldType, defaultFieldType, indexSettings, multiFields, null);\n        this.pathType = pathType;\n        this.latMapper = latMapper;\n        this.lonMapper = lonMapper;\n        this.geohashMapper = geohashMapper;\n        this.ignoreMalformed = ignoreMalformed;\n        this.coerce = coerce;\n    }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public int hashCode() {\n            return java.util.Objects.hash(super.hashCode(), geohashFieldType, geohashPrecision, geohashPrefixEnabled, latFieldType,\n                    lonFieldType, coerce, ignoreMalformed);\n        }","id":9680,"modified_method":"@Override\n        public int hashCode() {\n            return java.util.Objects.hash(super.hashCode(), geohashFieldType, geohashPrecision, geohashPrefixEnabled, latFieldType,\n                    lonFieldType);\n        }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public GeoPointFieldMapper build(BuilderContext context) {\n            ContentPath.Type origPathType = context.path().pathType();\n            context.path().pathType(pathType);\n\n            DoubleFieldMapper latMapper = null;\n            DoubleFieldMapper lonMapper = null;\n            GeoPointFieldType geoPointFieldType = (GeoPointFieldType)fieldType;\n\n            context.path().add(name);\n            if (enableLatLon) {\n                NumberFieldMapper.Builder<?, ?> latMapperBuilder = doubleField(Names.LAT).includeInAll(false);\n                NumberFieldMapper.Builder<?, ?> lonMapperBuilder = doubleField(Names.LON).includeInAll(false);\n                if (precisionStep != null) {\n                    latMapperBuilder.precisionStep(precisionStep);\n                    lonMapperBuilder.precisionStep(precisionStep);\n                }\n                latMapper = (DoubleFieldMapper) latMapperBuilder.includeInAll(false).store(fieldType.stored()).docValues(false).build(context);\n                lonMapper = (DoubleFieldMapper) lonMapperBuilder.includeInAll(false).store(fieldType.stored()).docValues(false).build(context);\n                geoPointFieldType.setLatLonEnabled(latMapper.fieldType(), lonMapper.fieldType());\n            }\n            StringFieldMapper geohashMapper = null;\n            if (enableGeoHash || enableGeohashPrefix) {\n                // TODO: possible also implicitly enable geohash if geohash precision is set\n                geohashMapper = stringField(Names.GEOHASH).index(true).tokenized(false).includeInAll(false).omitNorms(true).indexOptions(IndexOptions.DOCS).build(context);\n                geoPointFieldType.setGeohashEnabled(geohashMapper.fieldType(), geoHashPrecision, enableGeohashPrefix);\n            }\n            context.path().remove();\n\n            context.path().pathType(origPathType);\n\n            // this is important: even if geo points feel like they need to be tokenized to distinguish lat from lon, we actually want to\n            // store them as a single token.\n            fieldType.setTokenized(false);\n            setupFieldType(context);\n            fieldType.setHasDocValues(false);\n            defaultFieldType.setHasDocValues(false);\n            return new GeoPointFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), origPathType,\n                     latMapper, lonMapper, geohashMapper, multiFieldsBuilder.build(this, context));\n        }","id":9681,"modified_method":"@Override\n        public GeoPointFieldMapper build(BuilderContext context) {\n            ContentPath.Type origPathType = context.path().pathType();\n            context.path().pathType(pathType);\n\n            DoubleFieldMapper latMapper = null;\n            DoubleFieldMapper lonMapper = null;\n            GeoPointFieldType geoPointFieldType = (GeoPointFieldType)fieldType;\n\n            context.path().add(name);\n            if (enableLatLon) {\n                NumberFieldMapper.Builder<?, ?> latMapperBuilder = doubleField(Names.LAT).includeInAll(false);\n                NumberFieldMapper.Builder<?, ?> lonMapperBuilder = doubleField(Names.LON).includeInAll(false);\n                if (precisionStep != null) {\n                    latMapperBuilder.precisionStep(precisionStep);\n                    lonMapperBuilder.precisionStep(precisionStep);\n                }\n                latMapper = (DoubleFieldMapper) latMapperBuilder.includeInAll(false).store(fieldType.stored()).docValues(false).build(context);\n                lonMapper = (DoubleFieldMapper) lonMapperBuilder.includeInAll(false).store(fieldType.stored()).docValues(false).build(context);\n                geoPointFieldType.setLatLonEnabled(latMapper.fieldType(), lonMapper.fieldType());\n            }\n            StringFieldMapper geohashMapper = null;\n            if (enableGeoHash || enableGeohashPrefix) {\n                // TODO: possible also implicitly enable geohash if geohash precision is set\n                geohashMapper = stringField(Names.GEOHASH).index(true).tokenized(false).includeInAll(false).omitNorms(true).indexOptions(IndexOptions.DOCS).build(context);\n                geoPointFieldType.setGeohashEnabled(geohashMapper.fieldType(), geoHashPrecision, enableGeohashPrefix);\n            }\n            context.path().remove();\n\n            context.path().pathType(origPathType);\n\n            // this is important: even if geo points feel like they need to be tokenized to distinguish lat from lon, we actually want to\n            // store them as a single token.\n            fieldType.setTokenized(false);\n            setupFieldType(context);\n            fieldType.setHasDocValues(false);\n            defaultFieldType.setHasDocValues(false);\n            return new GeoPointFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), origPathType,\n                     latMapper, lonMapper, geohashMapper, multiFieldsBuilder.build(this, context), ignoreMalformed(context), coerce(context));\n        }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            Builder builder = geoPointField(name);\n            final boolean indexCreatedBeforeV2_0 = parserContext.indexVersionCreated().before(Version.V_2_0_0);\n            parseField(builder, name, node, parserContext);\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String fieldName = Strings.toUnderscoreCase(entry.getKey());\n                Object fieldNode = entry.getValue();\n                if (fieldName.equals(\"path\") && parserContext.indexVersionCreated().before(Version.V_2_0_0_beta1)) {\n                    builder.multiFieldPathType(parsePathType(name, fieldNode.toString()));\n                    iterator.remove();\n                } else if (fieldName.equals(\"lat_lon\")) {\n                    builder.enableLatLon(XContentMapValues.nodeBooleanValue(fieldNode));\n                    iterator.remove();\n                } else if (fieldName.equals(\"geohash\")) {\n                    builder.enableGeoHash(XContentMapValues.nodeBooleanValue(fieldNode));\n                    iterator.remove();\n                } else if (fieldName.equals(\"geohash_prefix\")) {\n                    builder.geohashPrefix(XContentMapValues.nodeBooleanValue(fieldNode));\n                    if (XContentMapValues.nodeBooleanValue(fieldNode)) {\n                        builder.enableGeoHash(true);\n                    }\n                    iterator.remove();\n                } else if (fieldName.equals(\"precision_step\")) {\n                    builder.precisionStep(XContentMapValues.nodeIntegerValue(fieldNode));\n                    iterator.remove();\n                } else if (fieldName.equals(\"geohash_precision\")) {\n                    if (fieldNode instanceof Integer) {\n                        builder.geoHashPrecision(XContentMapValues.nodeIntegerValue(fieldNode));\n                    } else {\n                        builder.geoHashPrecision(GeoUtils.geoHashLevelsForPrecision(fieldNode.toString()));\n                    }\n                    iterator.remove();\n                } else if (fieldName.equals(Names.IGNORE_MALFORMED)) {\n                    if (builder.fieldType().coerce == false) {\n                        builder.fieldType().ignoreMalformed = XContentMapValues.nodeBooleanValue(fieldNode);\n                    }\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && fieldName.equals(\"validate\")) {\n                    if (builder.fieldType().ignoreMalformed == false) {\n                        builder.fieldType().ignoreMalformed = !XContentMapValues.nodeBooleanValue(fieldNode);\n                    }\n                   iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && fieldName.equals(\"validate_lon\")) {\n                    if (builder.fieldType().ignoreMalformed() == false) {\n                        builder.fieldType().ignoreMalformed = !XContentMapValues.nodeBooleanValue(fieldNode);\n                    }\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && fieldName.equals(\"validate_lat\")) {\n                    if (builder.fieldType().ignoreMalformed == false) {\n                        builder.fieldType().ignoreMalformed = !XContentMapValues.nodeBooleanValue(fieldNode);\n                    }\n                    iterator.remove();\n                } else if (fieldName.equals(Names.COERCE)) {\n                    builder.fieldType().coerce = XContentMapValues.nodeBooleanValue(fieldNode);\n                    if (builder.fieldType().coerce == true) {\n                        builder.fieldType().ignoreMalformed = true;\n                    }\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && fieldName.equals(\"normalize\")) {\n                    builder.fieldType().coerce = XContentMapValues.nodeBooleanValue(fieldNode);\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && fieldName.equals(\"normalize_lat\")) {\n                    builder.fieldType().coerce = XContentMapValues.nodeBooleanValue(fieldNode);\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && fieldName.equals(\"normalize_lon\")) {\n                    if (builder.fieldType().coerce == false) {\n                        builder.fieldType().coerce = XContentMapValues.nodeBooleanValue(fieldNode);\n                    }\n                    iterator.remove();\n                } else if (parseMultiField(builder, name, parserContext, fieldName, fieldNode)) {\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","id":9682,"modified_method":"@Override\n        public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {\n            Builder builder = geoPointField(name);\n            final boolean indexCreatedBeforeV2_0 = parserContext.indexVersionCreated().before(Version.V_2_0_0);\n            parseField(builder, name, node, parserContext);\n            for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(); iterator.hasNext();) {\n                Map.Entry<String, Object> entry = iterator.next();\n                String propName = Strings.toUnderscoreCase(entry.getKey());\n                Object propNode = entry.getValue();\n                if (propName.equals(\"path\") && parserContext.indexVersionCreated().before(Version.V_2_0_0_beta1)) {\n                    builder.multiFieldPathType(parsePathType(name, propNode.toString()));\n                    iterator.remove();\n                } else if (propName.equals(\"lat_lon\")) {\n                    builder.enableLatLon(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (propName.equals(\"geohash\")) {\n                    builder.enableGeoHash(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (propName.equals(\"geohash_prefix\")) {\n                    builder.geohashPrefix(XContentMapValues.nodeBooleanValue(propNode));\n                    if (XContentMapValues.nodeBooleanValue(propNode)) {\n                        builder.enableGeoHash(true);\n                    }\n                    iterator.remove();\n                } else if (propName.equals(\"precision_step\")) {\n                    builder.precisionStep(XContentMapValues.nodeIntegerValue(propNode));\n                    iterator.remove();\n                } else if (propName.equals(\"geohash_precision\")) {\n                    if (propNode instanceof Integer) {\n                        builder.geoHashPrecision(XContentMapValues.nodeIntegerValue(propNode));\n                    } else {\n                        builder.geoHashPrecision(GeoUtils.geoHashLevelsForPrecision(propNode.toString()));\n                    }\n                    iterator.remove();\n                } else if (propName.equals(Names.IGNORE_MALFORMED)) {\n                    builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && propName.equals(\"validate\")) {\n                    builder.ignoreMalformed(!XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && propName.equals(\"validate_lon\")) {\n                    builder.ignoreMalformed(!XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && propName.equals(\"validate_lat\")) {\n                    builder.ignoreMalformed(!XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (propName.equals(Names.COERCE)) {\n                    builder.coerce(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && propName.equals(\"normalize\")) {\n                    builder.coerce(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && propName.equals(\"normalize_lat\")) {\n                    builder.coerce(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (indexCreatedBeforeV2_0 && propName.equals(\"normalize_lon\")) {\n                    builder.coerce(XContentMapValues.nodeBooleanValue(propNode));\n                    iterator.remove();\n                } else if (parseMultiField(builder, name, parserContext, propName, propNode)) {\n                    iterator.remove();\n                }\n            }\n            return builder;\n        }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void checkCompatibility(MappedFieldType fieldType, List<String> conflicts, boolean strict) {\n            super.checkCompatibility(fieldType, conflicts, strict);\n            GeoPointFieldType other = (GeoPointFieldType)fieldType;\n            if (isLatLonEnabled() != other.isLatLonEnabled()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [lat_lon]\");\n            }\n            if (isGeohashEnabled() != other.isGeohashEnabled()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [geohash]\");\n            }\n            if (geohashPrecision() != other.geohashPrecision()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [geohash_precision]\");\n            }\n            if (isGeohashPrefixEnabled() != other.isGeohashPrefixEnabled()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [geohash_prefix]\");\n            }\n            if (isLatLonEnabled() && other.isLatLonEnabled() &&\n                latFieldType().numericPrecisionStep() != other.latFieldType().numericPrecisionStep()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [precision_step]\");\n            }\n            if (ignoreMalformed() != other.ignoreMalformed()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [ignore_malformed]\");\n            }\n            if (coerce() != other.coerce()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [coerce]\");\n            }\n        }","id":9683,"modified_method":"@Override\n        public void checkCompatibility(MappedFieldType fieldType, List<String> conflicts, boolean strict) {\n            super.checkCompatibility(fieldType, conflicts, strict);\n            GeoPointFieldType other = (GeoPointFieldType)fieldType;\n            if (isLatLonEnabled() != other.isLatLonEnabled()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [lat_lon]\");\n            }\n            if (isGeohashEnabled() != other.isGeohashEnabled()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [geohash]\");\n            }\n            if (geohashPrecision() != other.geohashPrecision()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [geohash_precision]\");\n            }\n            if (isGeohashPrefixEnabled() != other.isGeohashPrefixEnabled()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [geohash_prefix]\");\n            }\n            if (isLatLonEnabled() && other.isLatLonEnabled() &&\n                latFieldType().numericPrecisionStep() != other.latFieldType().numericPrecisionStep()) {\n                conflicts.add(\"mapper [\" + names().fullName() + \"] has different [precision_step]\");\n            }\n        }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public boolean equals(Object o) {\n            if (!super.equals(o)) return false;\n            GeoPointFieldType that = (GeoPointFieldType) o;\n            return geohashPrecision == that.geohashPrecision &&\n                geohashPrefixEnabled == that.geohashPrefixEnabled &&\n                coerce == that.coerce &&\n                ignoreMalformed == that.ignoreMalformed &&\n                java.util.Objects.equals(geohashFieldType, that.geohashFieldType) &&\n                java.util.Objects.equals(latFieldType, that.latFieldType) &&\n                java.util.Objects.equals(lonFieldType, that.lonFieldType);\n        }","id":9684,"modified_method":"@Override\n        public boolean equals(Object o) {\n            if (!super.equals(o)) return false;\n            GeoPointFieldType that = (GeoPointFieldType) o;\n            return geohashPrecision == that.geohashPrecision &&\n                geohashPrefixEnabled == that.geohashPrefixEnabled &&\n                java.util.Objects.equals(geohashFieldType, that.geohashFieldType) &&\n                java.util.Objects.equals(latFieldType, that.latFieldType) &&\n                java.util.Objects.equals(lonFieldType, that.lonFieldType);\n        }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n        super.doXContentBody(builder, includeDefaults, params);\n        if (includeDefaults || pathType != Defaults.PATH_TYPE) {\n            builder.field(\"path\", pathType.name().toLowerCase(Locale.ROOT));\n        }\n        if (includeDefaults || fieldType().isLatLonEnabled() != Defaults.ENABLE_LATLON) {\n            builder.field(\"lat_lon\", fieldType().isLatLonEnabled());\n        }\n        if (includeDefaults || fieldType().isGeohashEnabled() != Defaults.ENABLE_GEOHASH) {\n            builder.field(\"geohash\", fieldType().isGeohashEnabled());\n        }\n        if (includeDefaults || fieldType().isGeohashPrefixEnabled() != Defaults.ENABLE_GEOHASH_PREFIX) {\n            builder.field(\"geohash_prefix\", fieldType().isGeohashPrefixEnabled());\n        }\n        if (fieldType().isGeohashEnabled() && (includeDefaults || fieldType().geohashPrecision() != Defaults.GEO_HASH_PRECISION)) {\n            builder.field(\"geohash_precision\", fieldType().geohashPrecision());\n        }\n        if (fieldType().isLatLonEnabled() && (includeDefaults || fieldType().latFieldType().numericPrecisionStep() != NumericUtils.PRECISION_STEP_DEFAULT)) {\n            builder.field(\"precision_step\", fieldType().latFieldType().numericPrecisionStep());\n        }\n        if (includeDefaults || fieldType().coerce != Defaults.COERCE) {\n            builder.field(Names.COERCE, fieldType().coerce);\n        }\n        if (includeDefaults || fieldType().ignoreMalformed != Defaults.IGNORE_MALFORMED) {\n            builder.field(Names.IGNORE_MALFORMED, fieldType().ignoreMalformed);\n        }\n    }","id":9685,"modified_method":"@Override\n    protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {\n        super.doXContentBody(builder, includeDefaults, params);\n        if (includeDefaults || pathType != Defaults.PATH_TYPE) {\n            builder.field(\"path\", pathType.name().toLowerCase(Locale.ROOT));\n        }\n        if (includeDefaults || fieldType().isLatLonEnabled() != Defaults.ENABLE_LATLON) {\n            builder.field(\"lat_lon\", fieldType().isLatLonEnabled());\n        }\n        if (includeDefaults || fieldType().isGeohashEnabled() != Defaults.ENABLE_GEOHASH) {\n            builder.field(\"geohash\", fieldType().isGeohashEnabled());\n        }\n        if (includeDefaults || fieldType().isGeohashPrefixEnabled() != Defaults.ENABLE_GEOHASH_PREFIX) {\n            builder.field(\"geohash_prefix\", fieldType().isGeohashPrefixEnabled());\n        }\n        if (fieldType().isGeohashEnabled() && (includeDefaults || fieldType().geohashPrecision() != Defaults.GEO_HASH_PRECISION)) {\n            builder.field(\"geohash_precision\", fieldType().geohashPrecision());\n        }\n        if (fieldType().isLatLonEnabled() && (includeDefaults || fieldType().latFieldType().numericPrecisionStep() != NumericUtils.PRECISION_STEP_DEFAULT)) {\n            builder.field(\"precision_step\", fieldType().latFieldType().numericPrecisionStep());\n        }\n        if (includeDefaults || coerce.explicit()) {\n            builder.field(Names.COERCE, coerce.value());\n        }\n        if (includeDefaults || ignoreMalformed.explicit()) {\n            builder.field(Names.IGNORE_MALFORMED, ignoreMalformed.value());\n        }\n    }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void parse(ParseContext context, GeoPoint point, String geohash) throws IOException {\n        if (fieldType().ignoreMalformed == false) {\n            if (point.lat() > 90.0 || point.lat() < -90.0) {\n                throw new IllegalArgumentException(\"illegal latitude value [\" + point.lat() + \"] for \" + name());\n            }\n            if (point.lon() > 180.0 || point.lon() < -180) {\n                throw new IllegalArgumentException(\"illegal longitude value [\" + point.lon() + \"] for \" + name());\n            }\n        }\n\n        if (fieldType().coerce) {\n            // by setting coerce to false we are assuming all geopoints are already in a valid coordinate system\n            // thus this extra step can be skipped\n            // LUCENE WATCH: This will be folded back into Lucene's GeoPointField\n            GeoUtils.normalizePoint(point, true, true);\n        }\n\n        if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {\n            Field field = new Field(fieldType().names().indexName(), Double.toString(point.lat()) + ',' + Double.toString(point.lon()), fieldType());\n            context.doc().add(field);\n        }\n        if (fieldType().isGeohashEnabled()) {\n            if (geohash == null) {\n                geohash = GeoHashUtils.encode(point.lat(), point.lon());\n            }\n            addGeohashField(context, geohash);\n        }\n        if (fieldType().isLatLonEnabled()) {\n            latMapper.parse(context.createExternalValueContext(point.lat()));\n            lonMapper.parse(context.createExternalValueContext(point.lon()));\n        }\n        if (fieldType().hasDocValues()) {\n            CustomGeoPointDocValuesField field = (CustomGeoPointDocValuesField) context.doc().getByKey(fieldType().names().indexName());\n            if (field == null) {\n                field = new CustomGeoPointDocValuesField(fieldType().names().indexName(), point.lat(), point.lon());\n                context.doc().addWithKey(fieldType().names().indexName(), field);\n            } else {\n                field.add(point.lat(), point.lon());\n            }\n        }\n        multiFields.parse(this, context);\n    }","id":9686,"modified_method":"private void parse(ParseContext context, GeoPoint point, String geohash) throws IOException {\n        boolean validPoint = false;\n        if (coerce.value() == false && ignoreMalformed.value() == false) {\n            if (point.lat() > 90.0 || point.lat() < -90.0) {\n                throw new IllegalArgumentException(\"illegal latitude value [\" + point.lat() + \"] for \" + name());\n            }\n            if (point.lon() > 180.0 || point.lon() < -180) {\n                throw new IllegalArgumentException(\"illegal longitude value [\" + point.lon() + \"] for \" + name());\n            }\n            validPoint = true;\n        }\n\n        if (coerce.value() == true && validPoint == false) {\n            // by setting coerce to false we are assuming all geopoints are already in a valid coordinate system\n            // thus this extra step can be skipped\n            // LUCENE WATCH: This will be folded back into Lucene's GeoPointField\n            GeoUtils.normalizePoint(point, true, true);\n        }\n\n        if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {\n            Field field = new Field(fieldType().names().indexName(), Double.toString(point.lat()) + ',' + Double.toString(point.lon()), fieldType());\n            context.doc().add(field);\n        }\n        if (fieldType().isGeohashEnabled()) {\n            if (geohash == null) {\n                geohash = GeoHashUtils.encode(point.lat(), point.lon());\n            }\n            addGeohashField(context, geohash);\n        }\n        if (fieldType().isLatLonEnabled()) {\n            latMapper.parse(context.createExternalValueContext(point.lat()));\n            lonMapper.parse(context.createExternalValueContext(point.lon()));\n        }\n        if (fieldType().hasDocValues()) {\n            CustomGeoPointDocValuesField field = (CustomGeoPointDocValuesField) context.doc().getByKey(fieldType().names().indexName());\n            if (field == null) {\n                field = new CustomGeoPointDocValuesField(fieldType().names().indexName(), point.lat(), point.lon());\n                context.doc().addWithKey(fieldType().names().indexName(), field);\n            } else {\n                field.add(point.lat(), point.lon());\n            }\n        }\n        multiFields.parse(this, context);\n    }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testGeoPointMapperMerge() throws Exception {\n        String stage1Mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"properties\").startObject(\"point\").field(\"type\", \"geo_point\").field(\"lat_lon\", true).field(\"geohash\", true)\n                .field(\"ignore_malformed\", true).endObject().endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\").mapperService().documentMapperParser();\n        DocumentMapper stage1 = parser.parse(stage1Mapping);\n        String stage2Mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"properties\").startObject(\"point\").field(\"type\", \"geo_point\").field(\"lat_lon\", false).field(\"geohash\", true)\n                .field(\"ignore_malformed\", false).endObject().endObject()\n                .endObject().endObject().string();\n        DocumentMapper stage2 = parser.parse(stage2Mapping);\n\n        MergeResult mergeResult = stage1.merge(stage2.mapping(), false, false);\n        assertThat(mergeResult.hasConflicts(), equalTo(true));\n        assertThat(mergeResult.buildConflicts().length, equalTo(2));\n        // todo better way of checking conflict?\n        assertThat(\"mapper [point] has different [lat_lon]\", isIn(new ArrayList<>(Arrays.asList(mergeResult.buildConflicts()))));\n        assertThat(\"mapper [point] has different [ignore_malformed]\", isIn(new ArrayList<>(Arrays.asList(mergeResult.buildConflicts()))));\n\n        // correct mapping and ensure no failures\n        stage2Mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"properties\").startObject(\"point\").field(\"type\", \"geo_point\").field(\"lat_lon\", true).field(\"geohash\", true)\n                .field(\"ignore_malformed\", true).endObject().endObject()\n                .endObject().endObject().string();\n        stage2 = parser.parse(stage2Mapping);\n        mergeResult = stage1.merge(stage2.mapping(), false, false);\n        assertThat(Arrays.toString(mergeResult.buildConflicts()), mergeResult.hasConflicts(), equalTo(false));\n    }","id":9687,"modified_method":"@Test\n    public void testGeoPointMapperMerge() throws Exception {\n        String stage1Mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"properties\").startObject(\"point\").field(\"type\", \"geo_point\").field(\"lat_lon\", true).field(\"geohash\", true)\n                .field(\"coerce\", true).endObject().endObject()\n                .endObject().endObject().string();\n        DocumentMapperParser parser = createIndex(\"test\").mapperService().documentMapperParser();\n        DocumentMapper stage1 = parser.parse(stage1Mapping);\n        String stage2Mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"properties\").startObject(\"point\").field(\"type\", \"geo_point\").field(\"lat_lon\", false).field(\"geohash\", true)\n                .field(\"coerce\", false).endObject().endObject()\n                .endObject().endObject().string();\n        DocumentMapper stage2 = parser.parse(stage2Mapping);\n\n        MergeResult mergeResult = stage1.merge(stage2.mapping(), false, false);\n        assertThat(mergeResult.hasConflicts(), equalTo(true));\n        assertThat(mergeResult.buildConflicts().length, equalTo(2));\n        // todo better way of checking conflict?\n        assertThat(\"mapper [point] has different [lat_lon]\", isIn(new ArrayList<>(Arrays.asList(mergeResult.buildConflicts()))));\n        assertThat(\"mapper [point] has different [coerce]\", isIn(new ArrayList<>(Arrays.asList(mergeResult.buildConflicts()))));\n\n        // correct mapping and ensure no failures\n        stage2Mapping = XContentFactory.jsonBuilder().startObject().startObject(\"type\")\n                .startObject(\"properties\").startObject(\"point\").field(\"type\", \"geo_point\").field(\"lat_lon\", true).field(\"geohash\", true)\n                .field(\"coerce\", true).endObject().endObject()\n                .endObject().endObject().string();\n        stage2 = parser.parse(stage2Mapping);\n        mergeResult = stage1.merge(stage2.mapping(), false, false);\n        assertThat(Arrays.toString(mergeResult.buildConflicts()), mergeResult.hasConflicts(), equalTo(false));\n    }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void setupProperties() {\n        addModifier(new Modifier(\"geohash\", false, true) {\n            @Override\n            public void modify(MappedFieldType ft) {\n                ((GeoPointFieldMapper.GeoPointFieldType)ft).setGeohashEnabled(new StringFieldMapper.StringFieldType(), 1, true);\n            }\n        });\n        addModifier(new Modifier(\"lat_lon\", false, true) {\n            @Override\n            public void modify(MappedFieldType ft) {\n                ((GeoPointFieldMapper.GeoPointFieldType)ft).setLatLonEnabled(new DoubleFieldMapper.DoubleFieldType(), new DoubleFieldMapper.DoubleFieldType());\n            }\n        });\n        addModifier(new Modifier(\"ignore_malformed\", false, true) {\n            @Override\n            public void modify(MappedFieldType ft) {\n                GeoPointFieldMapper.GeoPointFieldType gft = (GeoPointFieldMapper.GeoPointFieldType)ft;\n                gft.setIgnoreMalformed(!gft.ignoreMalformed());\n            }\n        });\n        addModifier(new Modifier(\"coerce\", false, true) {\n            @Override\n            public void modify(MappedFieldType ft) {\n                GeoPointFieldMapper.GeoPointFieldType gft = (GeoPointFieldMapper.GeoPointFieldType)ft;\n                gft.setCoerce(!gft.coerce());\n            }\n        });\n    }","id":9688,"modified_method":"@Before\n    public void setupProperties() {\n        addModifier(new Modifier(\"geohash\", false, true) {\n            @Override\n            public void modify(MappedFieldType ft) {\n                ((GeoPointFieldMapper.GeoPointFieldType)ft).setGeohashEnabled(new StringFieldMapper.StringFieldType(), 1, true);\n            }\n        });\n        addModifier(new Modifier(\"lat_lon\", false, true) {\n            @Override\n            public void modify(MappedFieldType ft) {\n                ((GeoPointFieldMapper.GeoPointFieldType)ft).setLatLonEnabled(new DoubleFieldMapper.DoubleFieldType(), new DoubleFieldMapper.DoubleFieldType());\n            }\n        });\n    }","commit_id":"17460ae92d432948e79d3e880c082b6990170e39","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void visit(JavaClass obj) {\n\t\textendsObject = getDottedSuperclassName().equals(\"java.lang.Object\");\n\t\thasFields = false;\n\t\thasHashCode = false;\n\t\thasCompareToObject = false;\n\t\thasCompareToSelf = false;\n\t\thasEqualsObject = false;\n\t\thasEqualsSelf = false;\n\t\thashCodeIsAbstract = false;\n\t\tequalsObjectIsAbstract = false;\n\t\tequalsMethodIsInstanceOfEquals = false;\n\t}","id":9689,"modified_method":"public void visit(JavaClass obj) {\n\t\textendsObject = getDottedSuperclassName().equals(\"java.lang.Object\");\n\t\thasFields = false;\n\t\thasHashCode = false;\n\t\thasCompareToObject = false;\n\t\thasCompareToSelf = false;\n\t\thasEqualsObject = false;\n\t\thasEqualsSelf = false;\n\t\thashCodeIsAbstract = false;\n\t\tequalsObjectIsAbstract = false;\n\t\tequalsMethodIsInstanceOfEquals = false;\n\t\tequalsMethod = null;\n\t}","commit_id":"1681346e8e7a89e92204133cfb9732dba1c7f746","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitAfter(JavaClass obj) {\n\t\tif (!obj.isClass()) return;\n\t\tif (getDottedClassName().equals(\"java.lang.Object\")) return;\n\t\tint accessFlags = obj.getAccessFlags();\n\t\tif ((accessFlags & ACC_INTERFACE) != 0) return;\n\t\tvisibleOutsidePackage = obj.isPublic() || obj.isProtected();\n\t\tString whereEqual = getDottedClassName();\n\t\tboolean classThatDefinesEqualsIsAbstract = false;\n\t\tboolean inheritedHashCodeIsFinal = false;\n\t\tboolean inheritedEqualsIsFinal = false;\n\t\tboolean inheritedEqualsIsAbstract = false;\n\t\tif (!hasEqualsObject) {\n\t\t\tJavaClass we = Lookup.findSuperImplementor(obj, \"equals\",\n\t\t\t        \"(Ljava/lang/Object;)Z\", bugReporter);\n\t\t\tif (we == null) {\n\t\t\t\twhereEqual = \"java.lang.Object\";\n\t\t\t} else {\n\t\t\t\twhereEqual = we.getClassName();\n\t\t\t\tclassThatDefinesEqualsIsAbstract = we.isAbstract();\n\t\t\t\tMethod m = findMethod(we, \"equals\", \"(Ljava/lang/Object;)Z\");\n\t\t\t\tif (m != null && m.isFinal()) inheritedEqualsIsFinal = true;\n\t\t\t\tif (m != null && m.isAbstract()) inheritedEqualsIsAbstract = true;\n\t\t\t}\n\t\t}\n\t\tboolean usesDefaultEquals = whereEqual.equals(\"java.lang.Object\");\n\t\tString whereHashCode = getDottedClassName();\n\t\tif (!hasHashCode) {\n\t\t\tJavaClass wh = Lookup.findSuperImplementor(obj, \"hashCode\",\n\t\t\t        \"()I\", bugReporter);\n\t\t\tif (wh == null) {\n\t\t\t\twhereHashCode = \"java.lang.Object\";\n\t\t\t} else {\n\t\t\t\twhereHashCode = wh.getClassName();\n\t\t\t\tMethod m = findMethod(wh, \"hashCode\", \"()I\");\n\t\t\t\tif (m != null && m.isFinal()) inheritedHashCodeIsFinal = true;\n\t\t\t}\n\t\t}\n\t\tboolean usesDefaultHashCode = whereHashCode.equals(\"java.lang.Object\");\n\t\tif (false && (usesDefaultEquals || usesDefaultHashCode)) {\n\t\t\ttry {\n\t\t\t\tif (Repository.implementationOf(obj, \"java/util/Set\")\n\t\t\t\t        || Repository.implementationOf(obj, \"java/util/List\")\n\t\t\t\t        || Repository.implementationOf(obj, \"java/util/Map\")) {\n\t\t\t\t\t// System.out.println(getDottedClassName() + \" uses default hashCode or equals\");\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t// e.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tif (!hasEqualsObject && hasEqualsSelf) {\n\n\t\t\tif (usesDefaultEquals) {\n\t\t\t\tint priority = HIGH_PRIORITY;\n\t\t\t\tif (usesDefaultHashCode || obj.isAbstract())\n\t\t\t\t\tpriority++;\n\t\t\t\tif (!visibleOutsidePackage)\n\t\t\t\t\tpriority++;\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EQ_SELF_USE_OBJECT\", priority).addClass(getDottedClassName()));\n\t\t\t} else {\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\tif (hasFields)\n\t\t\t\t\tpriority--;\n\t\t\t\tif (obj.isAbstract()) priority++;\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EQ_SELF_NO_OBJECT\", priority).addClass(getDottedClassName()));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tSystem.out.println(\"Class \" + betterClassName);\n\t\tSystem.out.println(\"usesDefaultEquals: \" + usesDefaultEquals);\n\t\tSystem.out.println(\"hasHashCode: : \" + hasHashCode);\n\t\tSystem.out.println(\"usesDefaultHashCode: \" + usesDefaultHashCode);\n\t\tSystem.out.println(\"hasEquals: : \" + hasEqualsObject);\n\t\t*/\n\n\t\tif (!hasCompareToObject && hasCompareToSelf) {\n\t\t\tif (!extendsObject)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"CO_SELF_NO_OBJECT\", NORMAL_PRIORITY).addClass(getDottedClassName()));\n\t\t}\n\n\t\t// if (!hasFields) return;\n\t\tif (hasHashCode && !hashCodeIsAbstract && !(hasEqualsObject || hasEqualsSelf)) {\n\t\t\tint priority = LOW_PRIORITY;\n\t\t\tif (usesDefaultEquals)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_HASHCODE_USE_OBJECT_EQUALS\", priority).addClass(getDottedClassName()));\n\t\t\telse if (!inheritedEqualsIsFinal)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_HASHCODE_NO_EQUALS\", priority).addClass(getDottedClassName()));\n\t\t}\n\t\tif (!hasHashCode\n\t\t        && (hasEqualsObject && !equalsObjectIsAbstract || hasEqualsSelf)) {\n\t\t\tif (usesDefaultHashCode) {\n\t\t\t\tint priority = HIGH_PRIORITY;\n\t\t\t\tif (equalsMethodIsInstanceOfEquals)\n\t\t\t\t\tpriority += 2;\n\t\t\t\telse if (obj.isAbstract() || !hasEqualsObject) priority++;\n\t\t\t\tif (!visibleOutsidePackage) {\n\t\t\t\t\tpriority++;\n\t\t\t\t}\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_EQUALS_USE_HASHCODE\",\n\t\t\t\t        priority).addClass(getDottedClassName()));\n\t\t\t} else if (!inheritedHashCodeIsFinal) {\n\t\t\t\tint priority = LOW_PRIORITY;\n\t\t\t\tif (hasEqualsObject && inheritedEqualsIsAbstract)\n\t\t\t\t\tpriority++;\n\t\t\t\tif (hasFields) priority--;\n\t\t\t\tif (equalsMethodIsInstanceOfEquals || !hasEqualsObject)\n\t\t\t\t\tpriority += 2;\n\t\t\t\telse if (obj.isAbstract()) priority++;\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_EQUALS_NO_HASHCODE\",\n\t\t\t\t        priority)\n\t\t\t\t        .addClass(getDottedClassName()));\n\t\t\t}\n\t\t}\n\t\tif (!hasHashCode && !hasEqualsObject && !hasEqualsSelf\n\t\t        && !usesDefaultEquals && usesDefaultHashCode\n\t\t        && !obj.isAbstract() && classThatDefinesEqualsIsAbstract) {\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_INHERITS_EQUALS_USE_HASHCODE\",\n\t\t\t        NORMAL_PRIORITY).addClass(getDottedClassName()));\n\t\t}\n\t}","id":9690,"modified_method":"public void visitAfter(JavaClass obj) {\n\t\tif (!obj.isClass()) return;\n\t\tif (getDottedClassName().equals(\"java.lang.Object\")) return;\n\t\tint accessFlags = obj.getAccessFlags();\n\t\tif ((accessFlags & ACC_INTERFACE) != 0) return;\n\t\tvisibleOutsidePackage = obj.isPublic() || obj.isProtected();\n\t\tString whereEqual = getDottedClassName();\n\t\tboolean classThatDefinesEqualsIsAbstract = false;\n\t\tboolean inheritedHashCodeIsFinal = false;\n\t\tboolean inheritedEqualsIsFinal = false;\n\t\tboolean inheritedEqualsIsAbstract = false;\n\t\tif (!hasEqualsObject) {\n\t\t\tJavaClass we = Lookup.findSuperImplementor(obj, \"equals\",\n\t\t\t        \"(Ljava/lang/Object;)Z\", bugReporter);\n\t\t\tif (we == null) {\n\t\t\t\twhereEqual = \"java.lang.Object\";\n\t\t\t} else {\n\t\t\t\twhereEqual = we.getClassName();\n\t\t\t\tclassThatDefinesEqualsIsAbstract = we.isAbstract();\n\t\t\t\tMethod m = findMethod(we, \"equals\", \"(Ljava/lang/Object;)Z\");\n\t\t\t\tif (m != null && m.isFinal()) inheritedEqualsIsFinal = true;\n\t\t\t\tif (m != null && m.isAbstract()) inheritedEqualsIsAbstract = true;\n\t\t\t}\n\t\t}\n\t\tboolean usesDefaultEquals = whereEqual.equals(\"java.lang.Object\");\n\t\tString whereHashCode = getDottedClassName();\n\t\tif (!hasHashCode) {\n\t\t\tJavaClass wh = Lookup.findSuperImplementor(obj, \"hashCode\",\n\t\t\t        \"()I\", bugReporter);\n\t\t\tif (wh == null) {\n\t\t\t\twhereHashCode = \"java.lang.Object\";\n\t\t\t} else {\n\t\t\t\twhereHashCode = wh.getClassName();\n\t\t\t\tMethod m = findMethod(wh, \"hashCode\", \"()I\");\n\t\t\t\tif (m != null && m.isFinal()) inheritedHashCodeIsFinal = true;\n\t\t\t}\n\t\t}\n\t\tboolean usesDefaultHashCode = whereHashCode.equals(\"java.lang.Object\");\n\t\tif (false && (usesDefaultEquals || usesDefaultHashCode)) {\n\t\t\ttry {\n\t\t\t\tif (Repository.implementationOf(obj, \"java/util/Set\")\n\t\t\t\t        || Repository.implementationOf(obj, \"java/util/List\")\n\t\t\t\t        || Repository.implementationOf(obj, \"java/util/Map\")) {\n\t\t\t\t\t// System.out.println(getDottedClassName() + \" uses default hashCode or equals\");\n\t\t\t\t}\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t// e.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tif (!hasEqualsObject && hasEqualsSelf) {\n\n\t\t\tif (usesDefaultEquals) {\n\t\t\t\tint priority = HIGH_PRIORITY;\n\t\t\t\tif (usesDefaultHashCode || obj.isAbstract())\n\t\t\t\t\tpriority++;\n\t\t\t\tif (!visibleOutsidePackage)\n\t\t\t\t\tpriority++;\n\t\t\t\tBugInstance bug = new BugInstance(this, \"EQ_SELF_USE_OBJECT\", priority).addClass(getDottedClassName());\n\t\t\t\tif (equalsMethod != null) bug.addMethod(equalsMethod);\n\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t} else {\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\tif (hasFields)\n\t\t\t\t\tpriority--;\n\t\t\t\tif (obj.isAbstract()) priority++;\n\t\t\t\tBugInstance bug = new BugInstance(this, \"EQ_SELF_NO_OBJECT\", priority).addClass(getDottedClassName());\n\t\t\t\tif (equalsMethod != null) bug.addMethod(equalsMethod);\n\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tSystem.out.println(\"Class \" + betterClassName);\n\t\tSystem.out.println(\"usesDefaultEquals: \" + usesDefaultEquals);\n\t\tSystem.out.println(\"hasHashCode: : \" + hasHashCode);\n\t\tSystem.out.println(\"usesDefaultHashCode: \" + usesDefaultHashCode);\n\t\tSystem.out.println(\"hasEquals: : \" + hasEqualsObject);\n\t\t*/\n\n\t\tif (!hasCompareToObject && hasCompareToSelf) {\n\t\t\tif (!extendsObject)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"CO_SELF_NO_OBJECT\", NORMAL_PRIORITY).addClass(getDottedClassName()));\n\t\t}\n\n\t\t// if (!hasFields) return;\n\t\tif (hasHashCode && !hashCodeIsAbstract && !(hasEqualsObject || hasEqualsSelf)) {\n\t\t\tint priority = LOW_PRIORITY;\n\t\t\tif (usesDefaultEquals)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_HASHCODE_USE_OBJECT_EQUALS\", priority).addClass(getDottedClassName()));\n\t\t\telse if (!inheritedEqualsIsFinal)\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"HE_HASHCODE_NO_EQUALS\", priority).addClass(getDottedClassName()));\n\t\t}\n\t\tif (!hasHashCode\n\t\t        && (hasEqualsObject && !equalsObjectIsAbstract || hasEqualsSelf)) {\n\t\t\tif (usesDefaultHashCode) {\n\t\t\t\tint priority = HIGH_PRIORITY;\n\t\t\t\tif (equalsMethodIsInstanceOfEquals)\n\t\t\t\t\tpriority += 2;\n\t\t\t\telse if (obj.isAbstract() || !hasEqualsObject) priority++;\n\t\t\t\tif (!visibleOutsidePackage) {\n\t\t\t\t\tpriority++;\n\t\t\t\t}\n\t\t\t\tBugInstance bug = new BugInstance(this, \"HE_EQUALS_USE_HASHCODE\",\n\t\t\t\t        priority).addClass(getDottedClassName());\n\t\t\t\tif (equalsMethod != null) bug.addMethod(equalsMethod);\n\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t} else if (!inheritedHashCodeIsFinal) {\n\t\t\t\tint priority = LOW_PRIORITY;\n\t\t\t\tif (hasEqualsObject && inheritedEqualsIsAbstract)\n\t\t\t\t\tpriority++;\n\t\t\t\tif (hasFields) priority--;\n\t\t\t\tif (equalsMethodIsInstanceOfEquals || !hasEqualsObject)\n\t\t\t\t\tpriority += 2;\n\t\t\t\telse if (obj.isAbstract()) priority++;\n\t\t\t\tBugInstance bug = new BugInstance(this, \"HE_EQUALS_NO_HASHCODE\",\n\t\t\t\t        priority)\n\t\t\t\t        .addClass(getDottedClassName());\n\t\t\t\tif (equalsMethod != null) bug.addMethod(equalsMethod);\n\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t}\n\t\t}\n\t\tif (!hasHashCode && !hasEqualsObject && !hasEqualsSelf\n\t\t        && !usesDefaultEquals && usesDefaultHashCode\n\t\t        && !obj.isAbstract() && classThatDefinesEqualsIsAbstract) {\n\t\t\tBugInstance bug = new BugInstance(this, \"HE_INHERITS_EQUALS_USE_HASHCODE\",\n\t\t\t        NORMAL_PRIORITY).addClass(getDottedClassName());\n\t\t\tif (equalsMethod != null) bug.addMethod(equalsMethod);\n\t\t\tbugReporter.reportBug(bug);\n\t\t}\n\t}","commit_id":"1681346e8e7a89e92204133cfb9732dba1c7f746","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Method obj) {\n\t\tint accessFlags = obj.getAccessFlags();\n\t\tif ((accessFlags & ACC_STATIC) != 0) return;\n\t\tString name = obj.getName();\n\t\tString sig = obj.getSignature();\n\t\tif ((accessFlags & ACC_ABSTRACT) != 0) {\n\t\t\tif (name.equals(\"equals\")\n\t\t\t        && sig.equals(\"(L\" + getClassName() + \";)Z\")) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EQ_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\t\t\treturn;\n\t\t\t} else if (name.equals(\"compareTo\")\n\t\t\t        && sig.equals(\"(L\" + getClassName() + \";)I\")) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"CO_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean sigIsObject = sig.equals(\"(Ljava/lang/Object;)Z\");\n\t\tif (name.equals(\"hashCode\")\n\t\t        && sig.equals(\"()I\")) {\n\t\t\thasHashCode = true;\n\t\t\tif (obj.isAbstract()) hashCodeIsAbstract = true;\n\t\t\t// System.out.println(\"Found hashCode for \" + betterClassName);\n\t\t} else if (name.equals(\"equals\")) {\n\t\t\tif (sigIsObject) {\n\t\t\t\thasEqualsObject = true;\n\t\t\t\tif (obj.isAbstract())\n\t\t\t\t\tequalsObjectIsAbstract = true;\n\t\t\t\telse if (!obj.isNative()) {\n\t\t\t\t\tCode code = obj.getCode();\n\t\t\t\t\tbyte[] codeBytes = code.getCode();\n\n\t\t\t\t\tif ((codeBytes.length == 5 &&\n\t\t\t\t\t        (codeBytes[1] & 0xff) == INSTANCEOF)\n\t\t\t\t\t        || (codeBytes.length == 15 &&\n\t\t\t\t\t        (codeBytes[1] & 0xff) == INSTANCEOF &&\n\t\t\t\t\t        (codeBytes[11] & 0xff) == INVOKESPECIAL)) {\n\t\t\t\t\t\tequalsMethodIsInstanceOfEquals = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (sig.equals(\"(L\" + getClassName() + \";)Z\"))\n\t\t\t\thasEqualsSelf = true;\n\t\t} else if (name.equals(\"compareTo\")) {\n\t\t\tif (sig.equals(\"(Ljava/lang/Object;)I\"))\n\t\t\t\thasCompareToObject = true;\n\t\t\telse if (sig.equals(\"(L\" + getClassName() + \";)I\"))\n\t\t\t\thasCompareToSelf = true;\n\t\t}\n\t}","id":9691,"modified_method":"public void visit(Method obj) {\n\t\tint accessFlags = obj.getAccessFlags();\n\t\tif ((accessFlags & ACC_STATIC) != 0) return;\n\t\tString name = obj.getName();\n\t\tString sig = obj.getSignature();\n\t\tif ((accessFlags & ACC_ABSTRACT) != 0) {\n\t\t\tif (name.equals(\"equals\")\n\t\t\t        && sig.equals(\"(L\" + getClassName() + \";)Z\")) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"EQ_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\t\t\treturn;\n\t\t\t} else if (name.equals(\"compareTo\")\n\t\t\t        && sig.equals(\"(L\" + getClassName() + \";)I\")) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"CO_ABSTRACT_SELF\", LOW_PRIORITY).addClass(getDottedClassName()));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tboolean sigIsObject = sig.equals(\"(Ljava/lang/Object;)Z\");\n\t\tif (name.equals(\"hashCode\")\n\t\t        && sig.equals(\"()I\")) {\n\t\t\thasHashCode = true;\n\t\t\tif (obj.isAbstract()) hashCodeIsAbstract = true;\n\t\t\t// System.out.println(\"Found hashCode for \" + betterClassName);\n\t\t} else if (name.equals(\"equals\")) {\n\t\t\tif (sigIsObject) {\n\t\t\t\tequalsMethod = MethodAnnotation.fromVisitedMethod(this);\n\t\t\t\thasEqualsObject = true;\n\t\t\t\tif (obj.isAbstract())\n\t\t\t\t\tequalsObjectIsAbstract = true;\n\t\t\t\telse if (!obj.isNative()) {\n\t\t\t\t\tCode code = obj.getCode();\n\t\t\t\t\tbyte[] codeBytes = code.getCode();\n\n\t\t\t\t\tif ((codeBytes.length == 5 &&\n\t\t\t\t\t        (codeBytes[1] & 0xff) == INSTANCEOF)\n\t\t\t\t\t        || (codeBytes.length == 15 &&\n\t\t\t\t\t        (codeBytes[1] & 0xff) == INSTANCEOF &&\n\t\t\t\t\t        (codeBytes[11] & 0xff) == INVOKESPECIAL)) {\n\t\t\t\t\t\tequalsMethodIsInstanceOfEquals = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (sig.equals(\"(L\" + getClassName() + \";)Z\")) {\n\t\t\t\thasEqualsSelf = true;\n\t\t\t\tif (equalsMethod == null) \n\t\t\t\t\tequalsMethod = MethodAnnotation.fromVisitedMethod(this);\n\t\t\t}\n\t\t} else if (name.equals(\"compareTo\")) {\n\t\t\tif (sig.equals(\"(Ljava/lang/Object;)I\"))\n\t\t\t\thasCompareToObject = true;\n\t\t\telse if (sig.equals(\"(L\" + getClassName() + \";)I\"))\n\t\t\t\thasCompareToSelf = true;\n\t\t}\n\t}","commit_id":"1681346e8e7a89e92204133cfb9732dba1c7f746","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"protected void updateEquitySettings(\n\t\t\tlong groupId, String className,\n\t\t\tSocialEquityActionMapping equityActionMapping)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tList<SocialEquitySetting> equitySettings = getEquitySettings(\n\t\t\tgroupId, className, equityActionMapping.getActionId());\n\n\t\tif (equitySettings.isEmpty()) {\n\t\t\tequitySettings.add(\n\t\t\t\tnew SocialEquitySettingImpl(\n\t\t\t\t\tequityActionMapping.getActionId(),\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION));\n\n\t\t\tequitySettings.add(\n\t\t\t\tnew SocialEquitySettingImpl(\n\t\t\t\t\tequityActionMapping.getActionId(),\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_PARTICIPATION));\n\t\t}\n\t\telse if (equitySettings.size() == 1) {\n\t\t\tif (equitySettings.get(0).getType() ==\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION) {\n\n\t\t\t\tequitySettings.add(\n\t\t\t\t\tnew SocialEquitySettingImpl(\n\t\t\t\t\t\tequityActionMapping.getActionId(),\n\t\t\t\t\t\tSocialEquitySettingConstants.TYPE_PARTICIPATION));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tequitySettings.add(\n\t\t\t\t\tnew SocialEquitySettingImpl(\n\t\t\t\t\t\tequityActionMapping.getActionId(),\n\t\t\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION));\n\t\t\t}\n\t\t}\n\n\t\tfor (SocialEquitySetting equitySetting : equitySettings) {\n\t\t\tif (!equityActionMapping.equals(equitySetting)) {\n\t\t\t\tequitySetting.update(equityActionMapping);\n\n\t\t\t\tif (equitySetting.getPrimaryKey() == 0) {\n\t\t\t\t\tGroup group = groupLocalService.getGroup(groupId);\n\n\t\t\t\t\tequitySetting.setEquitySettingId(\n\t\t\t\t\t\tcounterLocalService.increment());\n\t\t\t\t\tequitySetting.setGroupId(groupId);\n\t\t\t\t\tequitySetting.setCompanyId(group.getCompanyId());\n\t\t\t\t\tequitySetting.setClassNameId(classNameId);\n\t\t\t\t}\n\n\t\t\t\tsocialEquitySettingPersistence.update(equitySetting, false);\n\t\t\t}\n\t\t}\n\n\t\tString key = encodeKey(classNameId, equityActionMapping.getActionId());\n\n\t\t_portalCache.remove(key);\n\t}","id":9692,"modified_method":"protected void updateEquitySettings(\n\t\t\tlong groupId, String className,\n\t\t\tSocialEquityActionMapping equityActionMapping)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tList<SocialEquitySetting> equitySettings = getEquitySettings(\n\t\t\tgroupId, className, equityActionMapping.getActionId());\n\n\t\tif (equitySettings.isEmpty()) {\n\t\t\tSocialEquitySetting equitySetting = new SocialEquitySettingImpl();\n\n\t\t\tequitySetting.setActionId(equityActionMapping.getActionId());\n\t\t\tequitySetting.setType(\n\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION);\n\n\t\t\tequitySettings.add(equitySetting);\n\n\t\t\tequitySetting = new SocialEquitySettingImpl();\n\n\t\t\tequitySetting.setActionId(equityActionMapping.getActionId());\n\t\t\tequitySetting.setType(\n\t\t\t\tSocialEquitySettingConstants.TYPE_PARTICIPATION);\n\n\t\t\tequitySettings.add(equitySetting);\n\t\t}\n\t\telse if (equitySettings.size() == 1) {\n\t\t\tif (equitySettings.get(0).getType() ==\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION) {\n\n\t\t\t\tSocialEquitySetting equitySetting =\n\t\t\t\t\tnew SocialEquitySettingImpl();\n\n\t\t\t\tequitySetting.setActionId(equityActionMapping.getActionId());\n\t\t\t\tequitySetting.setType(\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_PARTICIPATION);\n\n\t\t\t\tequitySettings.add(equitySetting);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSocialEquitySetting equitySetting =\n\t\t\t\t\tnew SocialEquitySettingImpl();\n\n\t\t\t\tequitySetting.setActionId(equityActionMapping.getActionId());\n\t\t\t\tequitySetting.setType(\n\t\t\t\t\tSocialEquitySettingConstants.TYPE_INFORMATION);\n\n\t\t\t\tequitySettings.add(equitySetting);\n\t\t\t}\n\t\t}\n\n\t\tfor (SocialEquitySetting equitySetting : equitySettings) {\n\t\t\tif (!equityActionMapping.equals(equitySetting)) {\n\t\t\t\tequitySetting.update(equityActionMapping);\n\n\t\t\t\tif (equitySetting.getPrimaryKey() == 0) {\n\t\t\t\t\tGroup group = groupLocalService.getGroup(groupId);\n\n\t\t\t\t\tequitySetting.setEquitySettingId(\n\t\t\t\t\t\tcounterLocalService.increment());\n\t\t\t\t\tequitySetting.setGroupId(groupId);\n\t\t\t\t\tequitySetting.setCompanyId(group.getCompanyId());\n\t\t\t\t\tequitySetting.setClassNameId(classNameId);\n\t\t\t\t}\n\n\t\t\t\tsocialEquitySettingPersistence.update(equitySetting, false);\n\t\t\t}\n\t\t}\n\n\t\tString key = encodeKey(classNameId, equityActionMapping.getActionId());\n\n\t\t_portalCache.remove(key);\n\t}","commit_id":"498f8bc0194946d90e61a807b6d8649c01c84075","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String toLocaleString(Double v) {\r\n\t\tfinal DecimalFormatSymbols symbols =\r\n\t\t\tnew DecimalFormatSymbols(getDefaultLocale());\r\n\t\tfinal char DECIMAL = symbols.getDecimalSeparator();\r\n\t\tfinal char MINUS = symbols.getMinusSign();\r\n\t\t// only replace MINUS and DECIMAL as toPlainString() implementation\r\n\t\t// only involves these two chars. \r\n\t\treturn v.toString().replace('.', DECIMAL).replace('-', MINUS);\r\n\t}","id":9693,"modified_method":"static String toLocaleString(Double v, java.util.Locale locale) {\r\n\t\tfinal DecimalFormatSymbols symbols =\r\n\t\t\tnew DecimalFormatSymbols(locale);\r\n\t\tfinal char DECIMAL = symbols.getDecimalSeparator();\r\n\t\tfinal char MINUS = symbols.getMinusSign();\r\n\t\t// only replace MINUS and DECIMAL as toPlainString() implementation\r\n\t\t// only involves these two chars. \r\n\t\treturn v.toString().replace('.', DECIMAL).replace('-', MINUS);\r\n\t}","commit_id":"16d6c5705ae9e6e9f2af3ad0837f2b020d953188","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\r\n\t\treturn value != null && getFormat() == null ?\r\n\t\t\tvalue instanceof Double ? toLocaleString((Double)value):\r\n\t\t\tvalue.toString()/*just in case*/: formatNumber(value, null);\r\n\t}","id":9694,"modified_method":"protected String coerceToString(Object value) {\r\n\t\treturn value != null && getFormat() == null ?\r\n\t\t\tvalue instanceof Double ?\r\n\t\t\t\ttoLocaleString((Double)value, getDefaultLocale()):\r\n\t\t\tvalue.toString()/*just in case*/: formatNumber(value, null);\r\n\t}","commit_id":"16d6c5705ae9e6e9f2af3ad0837f2b020d953188","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\r\n\t\treturn formatNumber(value, null);\r\n\t}","id":9695,"modified_method":"protected String coerceToString(Object value) {\r\n\t\treturn value != null && getFormat() == null ?\r\n\t\t\tvalue instanceof Double ?\r\n\t\t\t\tDoublebox.toLocaleString((Double)value, getDefaultLocale()):\r\n\t\t\tvalue.toString()/*just in case*/: formatNumber(value, null);\r\n\t}","commit_id":"16d6c5705ae9e6e9f2af3ad0837f2b020d953188","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\n\t\treturn value instanceof BigDecimal ? \n\t\t\t\tBigDecimals.toLocaleString((BigDecimal)value, null):\n\t\t\t\tformatNumber(value, null);\n\t}","id":9696,"modified_method":"protected String coerceToString(Object value) {\n\t\treturn value != null && getFormat() == null ?\n\t\t\tvalue instanceof BigDecimal ?\n\t\t\t\tBigDecimals.toLocaleString((BigDecimal)value, getDefaultLocale()):\n\t\t\t\tvalue.toString()/*just in case*/: formatNumber(value, null);\n\t}","commit_id":"aa2c4cce5cb375a54be0a6aca63b51875dee3657","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\r\n\t\treturn formatNumber(value, null);\r\n\t}","id":9697,"modified_method":"protected String coerceToString(Object value) {\r\n\t\treturn value != null && getFormat() == null ?\r\n\t\t\tvalue instanceof Double ? toLocaleString((Double)value):\r\n\t\t\tvalue.toString()/*just in case*/: formatNumber(value, null);\r\n\t}","commit_id":"aa2c4cce5cb375a54be0a6aca63b51875dee3657","url":"https://github.com/zkoss/zk"},{"original_method":"private Locale getDefaultLocale() {\n\t\treturn _locale != null ? _locale : Locales.getCurrent(); \n\t}","id":9698,"modified_method":"/** Returns the default locale, either {@link #getLocale} or\n\t * {@link Locales#getCurrent} (never null).\n\t * It is useful when you wan to get a locale for this input.\n\t * @since 5.0.10\n\t */\n\tprotected Locale getDefaultLocale() {\n\t\treturn _locale != null ? _locale : Locales.getCurrent(); \n\t}","commit_id":"aa2c4cce5cb375a54be0a6aca63b51875dee3657","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\n\t\treturn formatNumber(value, \"0.##########\");\n\t}","id":9699,"modified_method":"protected String coerceToString(Object value) {\n\t\treturn value != null && getFormat() == null ?\n\t\t\t\tvalue.toString(): formatNumber(value, null);\n\t}","commit_id":"d550c10649a6726d28d3eab445017607e76013bf","url":"https://github.com/zkoss/zk"},{"original_method":"protected String coerceToString(Object value) {\r\n\t\treturn formatNumber(value, \"0.##########\");\r\n\t}","id":9700,"modified_method":"protected String coerceToString(Object value) {\r\n\t\treturn value != null && getFormat() == null ?\r\n\t\t\t\tvalue.toString(): formatNumber(value, null);\r\n\t}","commit_id":"d550c10649a6726d28d3eab445017607e76013bf","url":"https://github.com/zkoss/zk"},{"original_method":"@Override\n    public void doPostSetup() {\n        mongo = applicationContext.getBean(Mongo.class);\n        db = mongo.getDB(dbName);\n\n        // Refresh the test collection - drop it and recreate it. We don't do this for the database because MongoDB would create large\n        // store files each time\n        testCollectionName = \"camelTest\";\n        testCollection = db.getCollection(testCollectionName);\n        testCollection.drop();\n        testCollection = db.getCollection(testCollectionName);\n        \n        dynamicCollectionName = testCollectionName.concat(\"Dynamic\");\n        dynamicCollection = db.getCollection(dynamicCollectionName);\n        dynamicCollection.drop();\n        dynamicCollection = db.getCollection(dynamicCollectionName);\n\n    }","id":9701,"modified_method":"@Override\n    public void doPostSetup() {\n        mongo = applicationContext.getBean(MongoClient.class);\n        db = mongo.getDatabase(dbName);\n\n        // Refresh the test collection - drop it and recreate it. We don't do this for the database because MongoDB would create large\n        // store files each time\n        testCollectionName = \"camelTest\";\n        testCollection = db.getCollection(testCollectionName, BasicDBObject.class);\n        testCollection.drop();\n        testCollection = db.getCollection(testCollectionName, BasicDBObject.class);\n        \n        dynamicCollectionName = testCollectionName.concat(\"Dynamic\");\n        dynamicCollection = db.getCollection(dynamicCollectionName, BasicDBObject.class);\n        dynamicCollection.drop();\n        dynamicCollection = db.getCollection(dynamicCollectionName, BasicDBObject.class);\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"protected void pumpDataIntoTestCollection() {\n        // there should be 100 of each\n        String[] scientists = {\"Einstein\", \"Darwin\", \"Copernicus\", \"Pasteur\", \"Curie\", \"Faraday\", \"Newton\", \"Bohr\", \"Galilei\", \"Maxwell\"};\n        for (int i = 1; i <= 1000; i++) {\n            int index = i % scientists.length;\n            Formatter f = new Formatter();\n            String doc = f.format(\"{\\\"_id\\\":\\\"%d\\\", \\\"scientist\\\":\\\"%s\\\", \\\"fixedField\\\": \\\"fixedValue\\\"}\", i, scientists[index]).toString();\n            IOHelper.close(f);\n            testCollection.insert((DBObject) JSON.parse(doc), WriteConcern.SAFE);\n        }\n        assertEquals(\"Data pumping of 1000 entries did not complete entirely\", 1000L, testCollection.count());\n    }","id":9702,"modified_method":"protected void pumpDataIntoTestCollection() {\n        // there should be 100 of each\n        String[] scientists = {\"Einstein\", \"Darwin\", \"Copernicus\", \"Pasteur\", \"Curie\", \"Faraday\", \"Newton\", \"Bohr\", \"Galilei\", \"Maxwell\"};\n        for (int i = 1; i <= 1000; i++) {\n            int index = i % scientists.length;\n            Formatter f = new Formatter();\n            String doc = f.format(\"{\\\"_id\\\":\\\"%d\\\", \\\"scientist\\\":\\\"%s\\\", \\\"fixedField\\\": \\\"fixedValue\\\"}\", i, scientists[index]).toString();\n            IOHelper.close(f);\n            testCollection.insertOne((BasicDBObject) JSON.parse(doc));\n        }\n        assertEquals(\"Data pumping of 1000 entries did not complete entirely\", 1000L, testCollection.count());\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertPojo() {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insertPojo\", new MyPojoTest());\n        DBObject b = testCollection.findOne(\"testInsertPojo\");\n        assertNotNull(\"No record with 'testInsertPojo' _id\", b);\n    }","id":9703,"modified_method":"@Test\n    public void testInsertPojo() {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insertPojo\", new MyPojoTest());\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertPojo\")).first();\n        assertNotNull(\"No record with 'testInsertPojo' _id\", b);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertJsonString() {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insertJsonString\", \"{\\\"fruits\\\": [\\\"apple\\\", \\\"banana\\\", \\\"papaya\\\"], \\\"veggie\\\": \\\"broccoli\\\", \\\"_id\\\": \\\"testInsertJsonString\\\"}\");\n        //assertTrue(result instanceof WriteResult);\n        DBObject b = testCollection.findOne(\"testInsertJsonString\");\n        assertNotNull(\"No record with 'testInsertJsonString' _id\", b);\n    }","id":9704,"modified_method":"@Test\n    public void testInsertJsonString() {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insertJsonString\", \"{\\\"fruits\\\": [\\\"apple\\\", \\\"banana\\\", \\\"papaya\\\"], \\\"veggie\\\": \\\"broccoli\\\", \\\"_id\\\": \\\"testInsertJsonString\\\"}\");\n        //assertTrue(result instanceof WriteResult);\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertJsonString\")).first();\n        assertNotNull(\"No record with 'testInsertJsonString' _id\", b);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertMap() throws InterruptedException {\n        assertEquals(0, testCollection.count());\n        \n        Map<String, Object> m1 = new HashMap<String, Object>();\n        Map<String, String> m1Nested = new HashMap<String, String>();\n\n        m1Nested.put(\"nested1\", \"nestedValue1\");\n        m1Nested.put(\"nested2\", \"nestedValue2\");\n        \n        m1.put(\"field1\", \"value1\");\n        m1.put(\"field2\", \"value2\");\n        m1.put(\"nestedField\", m1Nested);\n        m1.put(\"_id\", \"testInsertMap\");\n\n        Object result = template.requestBody(\"direct:insertMap\", m1);\n        DBObject b = testCollection.findOne(\"testInsertMap\");\n        assertNotNull(\"No record with 'testInsertMap' _id\", b);\n\n    }","id":9705,"modified_method":"@Test\n    public void testInsertMap() throws InterruptedException {\n        assertEquals(0, testCollection.count());\n        \n        Map<String, Object> m1 = new HashMap<String, Object>();\n        Map<String, String> m1Nested = new HashMap<String, String>();\n\n        m1Nested.put(\"nested1\", \"nestedValue1\");\n        m1Nested.put(\"nested2\", \"nestedValue2\");\n        \n        m1.put(\"field1\", \"value1\");\n        m1.put(\"field2\", \"value2\");\n        m1.put(\"nestedField\", m1Nested);\n        m1.put(\"_id\", \"testInsertMap\");\n\n        Object result = template.requestBody(\"direct:insertMap\", m1);\n        BasicDBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertMap\")).first();\n        assertNotNull(\"No record with 'testInsertMap' _id\", b);\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertBsonInputStream() {\n        assertEquals(0, testCollection.count());\n        \n        DefaultDBEncoder encoder = new DefaultDBEncoder();\n        BSONObject bsonObject = new BasicDBObject();\n        bsonObject.put(\"_id\", \"testInsertBsonString\");\n        \n        Object result = template.requestBody(\"direct:insertJsonString\", new ByteArrayInputStream(encoder.encode(bsonObject)));\n        DBObject b = testCollection.findOne(\"testInsertBsonString\");\n        assertNotNull(\"No record with 'testInsertBsonString' _id\", b);\n    }","id":9706,"modified_method":"@Test\n    public void testInsertBsonInputStream() {\n        assertEquals(0, testCollection.count());\n        \n        DefaultDBEncoder encoder = new DefaultDBEncoder();\n        BSONObject bsonObject = new BasicDBObject();\n        bsonObject.put(\"_id\", \"testInsertBsonString\");\n        \n        Object result = template.requestBody(\"direct:insertJsonString\", new ByteArrayInputStream(encoder.encode(bsonObject)));\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertBsonString\")).first();\n        assertNotNull(\"No record with 'testInsertBsonString' _id\", b);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertJsonInputStream() throws Exception {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insertJsonString\", \n                        IOConverter.toInputStream(\"{\\\"fruits\\\": [\\\"apple\\\", \\\"banana\\\"], \\\"veggie\\\": \\\"broccoli\\\", \\\"_id\\\": \\\"testInsertJsonString\\\"}\\n\", null));\n        DBObject b = testCollection.findOne(\"testInsertJsonString\");\n        assertNotNull(\"No record with 'testInsertJsonString' _id\", b);\n    }","id":9707,"modified_method":"@Test\n    public void testInsertJsonInputStream() throws Exception {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insertJsonString\", \n                        IOConverter.toInputStream(\"{\\\"fruits\\\": [\\\"apple\\\", \\\"banana\\\"], \\\"veggie\\\": \\\"broccoli\\\", \\\"_id\\\": \\\"testInsertJsonString\\\"}\\n\", null));\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertJsonString\")).first();\n        assertNotNull(\"No record with 'testInsertJsonString' _id\", b);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityDisabled() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityDisabled\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n        Object result = template.requestBodyAndHeaders(\"direct:noDynamicity\", body, headers);\n\n        DBObject b = testCollection.findOne(\"testInsertDynamicityDisabled\");\n        assertNotNull(\"No record with 'testInsertDynamicityDisabled' _id\", b);\n        \n        body = \"{\\\"_id\\\": \\\"testInsertDynamicityDisabledExplicitly\\\", \\\"a\\\" : \\\"1\\\"}\";\n        result = template.requestBodyAndHeaders(\"direct:noDynamicityExplicit\", body, headers);\n\n        b = testCollection.findOne(\"testInsertDynamicityDisabledExplicitly\");\n        assertNotNull(\"No record with 'testInsertDynamicityDisabledExplicitly' _id\", b);\n        \n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n    }","id":9708,"modified_method":"@Test\n    public void testInsertDynamicityDisabled() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityDisabled\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n        Object result = template.requestBodyAndHeaders(\"direct:noDynamicity\", body, headers);\n\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityDisabled\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityDisabled' _id\", b);\n        \n        body = \"{\\\"_id\\\": \\\"testInsertDynamicityDisabledExplicitly\\\", \\\"a\\\" : \\\"1\\\"}\";\n        result = template.requestBodyAndHeaders(\"direct:noDynamicityExplicit\", body, headers);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityDisabledExplicitly\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityDisabledExplicitly' _id\", b);\n        \n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityEnabledCollectionOnly() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledCollectionOnly\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n        \n        DBCollection dynamicCollection = db.getCollection(\"otherCollection\");\n        \n        DBObject b = dynamicCollection.findOne(\"testInsertDynamicityEnabledCollectionOnly\");\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledCollectionOnly' _id\", b);\n        \n        b = testCollection.findOne(\"testInsertDynamicityEnabledDBOnly\");\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledCollectionOnly' _id in the test collection\", b);\n        \n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n    }","id":9709,"modified_method":"@Test\n    public void testInsertDynamicityEnabledCollectionOnly() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledCollectionOnly\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n        \n        MongoCollection<BasicDBObject> dynamicCollection = db.getCollection(\"otherCollection\", BasicDBObject.class);\n\n        DBObject b = dynamicCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledCollectionOnly\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledCollectionOnly' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBOnly\")).first();\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledCollectionOnly' _id in the test collection\", b);\n        \n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityEnabledDBOnly() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledDBOnly\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n        \n        DBCollection dynamicCollection = mongo.getDB(\"otherDB\").getCollection(testCollection.getName());\n        \n        DBObject b = dynamicCollection.findOne(\"testInsertDynamicityEnabledDBOnly\");\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledDBOnly' _id\", b);\n        \n        b = testCollection.findOne(\"testInsertDynamicityEnabledDBOnly\");\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBOnly' _id in the test collection\", b);\n        \n        assertTrue(\"The otherDB database should exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n        \n    }","id":9710,"modified_method":"@Test\n    public void testInsertDynamicityEnabledDBOnly() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledDBOnly\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n        \n        MongoCollection<BasicDBObject> dynamicCollection = mongo.getDatabase(\"otherDB\").getCollection(testCollection.getNamespace().getCollectionName(), BasicDBObject.class);\n\n        DBObject b = dynamicCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBOnly\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledDBOnly' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBOnly\")).first();\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBOnly' _id in the test collection\", b);\n        \n        assertTrue(\"The otherDB database should exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n        \n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityEnabledDBAndCollection() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledDBAndCollection\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n        \n        DBCollection dynamicCollection = mongo.getDB(\"otherDB\").getCollection(\"otherCollection\");\n        \n        DBObject b = dynamicCollection.findOne(\"testInsertDynamicityEnabledDBAndCollection\");\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledDBAndCollection' _id\", b);\n        \n        b = testCollection.findOne(\"testInsertDynamicityEnabledDBOnly\");\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBAndCollection' _id in the test collection\", b);\n        \n        assertTrue(\"The otherDB database should exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n    }","id":9711,"modified_method":"@Test\n    public void testInsertDynamicityEnabledDBAndCollection() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledDBAndCollection\\\", \\\"a\\\" : \\\"1\\\"}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n        \n        MongoCollection<BasicDBObject> dynamicCollection = mongo.getDatabase(\"otherDB\").getCollection(\"otherCollection\", BasicDBObject.class);\n\n        DBObject b = dynamicCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBAndCollection\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledDBAndCollection' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBOnly\")).first();\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBAndCollection' _id in the test collection\", b);\n        \n        assertTrue(\"The otherDB database should exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInHeadersTransferredToOutOnInsert() {\n        Exchange result = template.request(\"direct:insert\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(\"{\\\"_id\\\":\\\"testInsertString\\\", \\\"scientist\\\":\\\"Einstein\\\"}\");\n                exchange.getIn().setHeader(\"abc\", \"def\");\n            }\n        });\n\n        //TODO: WriteResult isn't return when inserting\n        //assertTrue(result.getOut().getBody() instanceof WriteResult);\n        assertEquals(\"An input header was not returned\", \"def\", result.getOut().getHeader(\"abc\"));\n        DBObject b = testCollection.findOne(\"testInsertString\");\n        assertNotNull(\"No record with 'testInsertString' _id\", b);\n    }","id":9712,"modified_method":"@Test\n    public void testInHeadersTransferredToOutOnInsert() {\n        Exchange result = template.request(\"direct:insert\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(\"{\\\"_id\\\":\\\"testInsertString\\\", \\\"scientist\\\":\\\"Einstein\\\"}\");\n                exchange.getIn().setHeader(\"abc\", \"def\");\n            }\n        });\n\n        //TODO: WriteResult isn't return when inserting\n        //assertTrue(result.getOut().getBody() instanceof WriteResult);\n        assertEquals(\"An input header was not returned\", \"def\", result.getOut().getHeader(\"abc\"));\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertString\")).first();\n        assertNotNull(\"No record with 'testInsertString' _id\", b);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWriteResultAsHeaderWithWriteOp() {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        Object[] req = new Object[] {\"{\\\"_id\\\":\\\"testSave1\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", \"{\\\"_id\\\":\\\"testSave2\\\", \\\"scientist\\\":\\\"Copernicus\\\"}\"};\n        Object result = template.requestBody(\"direct:insert\", req);\n        //assertTrue(result instanceof WriteResult);\n        assertEquals(\"Number of records persisted must be 2\", 2, testCollection.count());\n        \n        // Testing the save logic\n        final DBObject record1 = testCollection.findOne(\"testSave1\");\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Einstein'\", \"Einstein\", record1.get(\"scientist\"));\n        record1.put(\"scientist\", \"Darwin\");\n        \n        // test that as a payload, we get back exactly our input, but enriched with the CamelMongoDbWriteResult header\n        Exchange resultExch = template.request(\"direct:save\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(record1);\n            }\n        });\n        assertTrue(resultExch.getOut().getBody() instanceof BasicDBObject);\n        assertTrue(resultExch.getOut().getBody().equals(record1));\n        assertTrue(resultExch.getOut().getHeader(MongoDbConstants.WRITERESULT) instanceof UpdateResult);\n\n        DBObject record2 = testCollection.findOne(\"testSave1\");\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Darwin' after save operation\", \"Darwin\", record2.get(\"scientist\"));\n\n    }","id":9713,"modified_method":"@Test\n    public void testWriteResultAsHeaderWithWriteOp() {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        Object[] req = new Object[] {\"{\\\"_id\\\":\\\"testSave1\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", \"{\\\"_id\\\":\\\"testSave2\\\", \\\"scientist\\\":\\\"Copernicus\\\"}\"};\n        Object result = template.requestBody(\"direct:insert\", req);\n        //assertTrue(result instanceof WriteResult);\n        assertEquals(\"Number of records persisted must be 2\", 2, testCollection.count());\n        \n        // Testing the save logic\n        final DBObject record1 = testCollection.find(new BasicDBObject(\"_id\", \"testSave1\")).first();\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Einstein'\", \"Einstein\", record1.get(\"scientist\"));\n        record1.put(\"scientist\", \"Darwin\");\n        \n        // test that as a payload, we get back exactly our input, but enriched with the CamelMongoDbWriteResult header\n        Exchange resultExch = template.request(\"direct:save\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setBody(record1);\n            }\n        });\n        assertTrue(resultExch.getOut().getBody() instanceof BasicDBObject);\n        assertTrue(resultExch.getOut().getBody().equals(record1));\n        assertTrue(resultExch.getOut().getHeader(MongoDbConstants.WRITERESULT) instanceof UpdateResult);\n\n        DBObject record2 = testCollection.find(new BasicDBObject(\"_id\", \"testSave1\")).first();\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Darwin' after save operation\", \"Darwin\", record2.get(\"scientist\"));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityEnabledCollectionAndIndex() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledCollectionAndIndex\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n\n        List<DBObject> objIndex = new ArrayList<DBObject>();\n        DBObject index1 = new BasicDBObject();\n        index1.put(\"a\", 1);\n        DBObject index2 = new BasicDBObject();\n        index2.put(\"b\", -1);\n        objIndex.add(index1);\n        objIndex.add(index2);\n        headers.put(MongoDbConstants.COLLECTION_INDEX, objIndex);\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n\n        assertEquals(\"Response isn't of type WriteResult\", BasicDBObject.class, result.getClass());\n\n        DBCollection dynamicCollection = db.getCollection(\"otherCollection\");\n\n        List<DBObject> indexInfos = dynamicCollection.getIndexInfo();\n\n        BasicDBObject key1 = (BasicDBObject) indexInfos.get(1).get(\"key\");\n        BasicDBObject key2 = (BasicDBObject) indexInfos.get(2).get(\"key\");\n\n        assertTrue(\"No index on the field a\", key1.containsField(\"a\") && \"1\".equals(key1.getString(\"a\")));\n        assertTrue(\"No index on the field b\", key2.containsField(\"b\") && \"-1\".equals(key2.getString(\"b\")));\n\n        DBObject b = dynamicCollection.findOne(\"testInsertDynamicityEnabledCollectionAndIndex\");\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledCollectionAndIndex' _id\", b);\n\n        b = testCollection.findOne(\"testInsertDynamicityEnabledDBOnly\");\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBAndCollection' _id in the test collection\", b);\n\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n    }","id":9714,"modified_method":"@Test\n    public void testInsertDynamicityEnabledCollectionAndIndex() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledCollectionAndIndex\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n\n        List<DBObject> objIndex = new ArrayList<DBObject>();\n        DBObject index1 = new BasicDBObject();\n        index1.put(\"a\", 1);\n        DBObject index2 = new BasicDBObject();\n        index2.put(\"b\", -1);\n        objIndex.add(index1);\n        objIndex.add(index2);\n        headers.put(MongoDbConstants.COLLECTION_INDEX, objIndex);\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n\n        assertEquals(\"Response isn't of type WriteResult\", BasicDBObject.class, result.getClass());\n\n        MongoCollection<BasicDBObject> dynamicCollection = db.getCollection(\"otherCollection\", BasicDBObject.class);\n\n        MongoCursor<BasicDBObject> indexInfos = dynamicCollection.listIndexes(BasicDBObject.class).iterator();\n\n        indexInfos.next();\n        BasicDBObject key1 = (BasicDBObject) indexInfos.next().get(\"key\");\n        BasicDBObject key2 = (BasicDBObject) indexInfos.next().get(\"key\");\n\n        assertTrue(\"No index on the field a\", key1.containsField(\"a\") && \"1\".equals(key1.getString(\"a\")));\n        assertTrue(\"No index on the field b\", key2.containsField(\"b\") && \"-1\".equals(key2.getString(\"b\")));\n\n        DBObject b = dynamicCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledCollectionAndIndex\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledCollectionAndIndex' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBOnly\")).first();\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBAndCollection' _id in the test collection\", b);\n\n        assertFalse(\"The otherDB database should not exist\", mongo.getUsedDatabases().contains(\"otherDB\"));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityEnabledCollectionOnlyAndURIIndex() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledCollectionOnlyAndURIIndex\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabledWithIndexUri\", body, headers);\n\n        assertEquals(\"Response isn't of type WriteResult\", BasicDBObject.class, result.getClass());\n\n        DBCollection dynamicCollection = db.getCollection(\"otherCollection\");\n\n        List<DBObject> indexInfos = dynamicCollection.getIndexInfo();\n\n        BasicDBObject key1 = (BasicDBObject) indexInfos.get(1).get(\"key\");\n\n        assertFalse(\"No index on the field a\", key1.containsField(\"a\") && \"-1\".equals(key1.getString(\"a\")));\n\n        DBObject b = dynamicCollection.findOne(\"testInsertDynamicityEnabledCollectionOnlyAndURIIndex\");\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledCollectionOnlyAndURIIndex' _id\", b);\n\n        b = testCollection.findOne(\"testInsertDynamicityEnabledCollectionOnlyAndURIIndex\");\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledCollectionOnlyAndURIIndex' _id in the test collection\", b);\n\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n    }","id":9715,"modified_method":"@Test\n    public void testInsertDynamicityEnabledCollectionOnlyAndURIIndex() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledCollectionOnlyAndURIIndex\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabledWithIndexUri\", body, headers);\n\n        assertEquals(\"Response isn't of type WriteResult\", BasicDBObject.class, result.getClass());\n\n        MongoCollection<BasicDBObject> dynamicCollection = db.getCollection(\"otherCollection\", BasicDBObject.class);\n\n        MongoCursor<Document> indexInfos = dynamicCollection.listIndexes().iterator();\n\n        Document key1 = (Document) indexInfos.next().get(\"key\");\n\n        assertFalse(\"No index on the field a\", key1.containsKey(\"a\") && \"-1\".equals(key1.getString(\"a\")));\n\n        DBObject b = dynamicCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledCollectionOnlyAndURIIndex\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledCollectionOnlyAndURIIndex' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledCollectionOnlyAndURIIndex\")).first();\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledCollectionOnlyAndURIIndex' _id in the test collection\", b);\n\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertDynamicityEnabledDBAndCollectionAndIndex() {\n        assertEquals(0, testCollection.count());\n        mongo.getDB(\"otherDB\").dropDatabase();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledDBAndCollection\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n\n        List<DBObject> objIndex = new ArrayList<DBObject>();\n        DBObject index1 = new BasicDBObject();\n        index1.put(\"a\", 1);\n        DBObject index2 = new BasicDBObject();\n        index2.put(\"b\", -1);\n        objIndex.add(index1);\n        objIndex.add(index2);\n        headers.put(MongoDbConstants.COLLECTION_INDEX, objIndex);\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n\n        assertEquals(\"Response isn't of type WriteResult\", BasicDBObject.class, result.getClass());\n\n        DBCollection dynamicCollection = mongo.getDB(\"otherDB\").getCollection(\"otherCollection\");\n\n        List<DBObject> indexInfos = dynamicCollection.getIndexInfo();\n\n        BasicDBObject key1 = (BasicDBObject) indexInfos.get(1).get(\"key\");\n        BasicDBObject key2 = (BasicDBObject) indexInfos.get(2).get(\"key\");\n\n        assertTrue(\"No index on the field a\", key1.containsField(\"a\") && \"1\".equals(key1.getString(\"a\")));\n        assertTrue(\"No index on the field b\", key2.containsField(\"b\") && \"-1\".equals(key2.getString(\"b\")));\n\n        DBObject b = dynamicCollection.findOne(\"testInsertDynamicityEnabledDBAndCollection\");\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledDBAndCollection' _id\", b);\n\n        b = testCollection.findOne(\"testInsertDynamicityEnabledDBOnly\");\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBAndCollection' _id in the test collection\", b);\n\n        assertTrue(\"The otherDB database should exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n    }","id":9716,"modified_method":"@Test\n    public void testInsertDynamicityEnabledDBAndCollectionAndIndex() {\n        assertEquals(0, testCollection.count());\n        mongo.getDatabase(\"otherDB\").drop();\n        db.getCollection(\"otherCollection\").drop();\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n\n        String body = \"{\\\"_id\\\": \\\"testInsertDynamicityEnabledDBAndCollection\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(MongoDbConstants.DATABASE, \"otherDB\");\n        headers.put(MongoDbConstants.COLLECTION, \"otherCollection\");\n\n        List<DBObject> objIndex = new ArrayList<DBObject>();\n        DBObject index1 = new BasicDBObject();\n        index1.put(\"a\", 1);\n        DBObject index2 = new BasicDBObject();\n        index2.put(\"b\", -1);\n        objIndex.add(index1);\n        objIndex.add(index2);\n\n        headers.put(MongoDbConstants.COLLECTION_INDEX, objIndex);\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityEnabled\", body, headers);\n\n        assertEquals(\"Response isn't of type WriteResult\", BasicDBObject.class, result.getClass());\n\n        MongoCollection<BasicDBObject> dynamicCollection = mongo.getDatabase(\"otherDB\").getCollection(\"otherCollection\", BasicDBObject.class);\n\n        ListIndexesIterable<DBObject> indexInfos = dynamicCollection.listIndexes(DBObject.class);\n\n        MongoCursor<DBObject> iterator = indexInfos.iterator();\n        iterator.next();\n        BasicDBObject key1 = (BasicDBObject) iterator.next().get(\"key\");\n        BasicDBObject key2 = (BasicDBObject) iterator.next().get(\"key\");\n\n        assertTrue(\"No index on the field a\", key1.containsField(\"a\") && \"1\".equals(key1.getString(\"a\")));\n        assertTrue(\"No index on the field b\", key2.containsField(\"b\") && \"-1\".equals(key2.getString(\"b\")));\n\n        DBObject b = dynamicCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBAndCollection\")).first();\n        assertNotNull(\"No record with 'testInsertDynamicityEnabledDBAndCollection' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertDynamicityEnabledDBOnly\")).first();\n        assertNull(\"There is a record with 'testInsertDynamicityEnabledDBAndCollection' _id in the test collection\", b);\n\n        assertTrue(\"The otherDB database should exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Ignore\n    @Test\n    public void testInsertAutoCreateCollectionAndURIIndex() {\n        assertEquals(0, testCollection.count());\n        db.getCollection(\"otherCollection\").remove(new BasicDBObject());\n\n        String body = \"{\\\"_id\\\": \\\"testInsertAutoCreateCollectionAndURIIndex\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityDisabled\", body, headers);\n        assertEquals(\"Response isn't of type WriteResult\", WriteResult.class, result.getClass());\n\n        DBCollection collection = db.getCollection(\"otherCollection\");\n        List<DBObject> indexInfos = collection.getIndexInfo();\n\n        BasicDBObject key1 = (BasicDBObject) indexInfos.get(1).get(\"key\");\n        BasicDBObject key2 = (BasicDBObject) indexInfos.get(2).get(\"key\");\n\n        assertTrue(\"No index on the field b\", key1.containsField(\"b\") && \"-1\".equals(key1.getString(\"b\")));\n        assertTrue(\"No index on the field a\", key2.containsField(\"a\") && \"1\".equals(key2.getString(\"a\")));\n\n        DBObject b = collection.findOne(\"testInsertAutoCreateCollectionAndURIIndex\");\n        assertNotNull(\"No record with 'testInsertAutoCreateCollectionAndURIIndex' _id\", b);\n\n        b = testCollection.findOne(\"testInsertAutoCreateCollectionAndURIIndex\");\n        assertNull(\"There is a record with 'testInsertAutoCreateCollectionAndURIIndex' _id in the test collection\", b);\n\n        assertFalse(\"The otherDB database should not exist\", mongo.getDatabaseNames().contains(\"otherDB\"));\n    }","id":9717,"modified_method":"@Ignore\n    @Test\n    public void testInsertAutoCreateCollectionAndURIIndex() {\n        assertEquals(0, testCollection.count());\n        db.getCollection(\"otherCollection\").deleteOne(new BasicDBObject());\n\n        String body = \"{\\\"_id\\\": \\\"testInsertAutoCreateCollectionAndURIIndex\\\", \\\"a\\\" : 1, \\\"b\\\" : 2}\";\n        Map<String, Object> headers = new HashMap<String, Object>();\n\n        Object result = template.requestBodyAndHeaders(\"direct:dynamicityDisabled\", body, headers);\n        assertEquals(\"Response isn't of type WriteResult\", WriteResult.class, result.getClass());\n\n        MongoCollection<BasicDBObject> collection = db.getCollection(\"otherCollection\", BasicDBObject.class);\n        MongoCursor<Document> indexInfos = collection.listIndexes().iterator();\n\n        BasicDBObject key1 = (BasicDBObject) indexInfos.next().get(\"key\");\n        BasicDBObject key2 = (BasicDBObject) indexInfos.next().get(\"key\");\n\n        assertTrue(\"No index on the field b\", key1.containsField(\"b\") && \"-1\".equals(key1.getString(\"b\")));\n        assertTrue(\"No index on the field a\", key2.containsField(\"a\") && \"1\".equals(key2.getString(\"a\")));\n\n        DBObject b = collection.find(new BasicDBObject(\"_id\", \"testInsertAutoCreateCollectionAndURIIndex\")).first();\n        assertNotNull(\"No record with 'testInsertAutoCreateCollectionAndURIIndex' _id\", b);\n\n        b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertAutoCreateCollectionAndURIIndex\")).first();\n        assertNull(\"There is a record with 'testInsertAutoCreateCollectionAndURIIndex' _id in the test collection\", b);\n\n        assertFalse(\"The otherDB database should not exist\",\n                StreamSupport.stream(mongo.listDatabaseNames().spliterator(), false)\n                        .anyMatch(\"otherDB\"::equals));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testSave() throws Exception {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        Object[] req = new Object[] {\"{\\\"_id\\\":\\\"testSave1\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", \"{\\\"_id\\\":\\\"testSave2\\\", \\\"scientist\\\":\\\"Copernicus\\\"}\"};\n        Object result = template.requestBody(\"direct:insert\", req);\n        assertTrue(result instanceof List);\n        assertEquals(\"Number of records persisted must be 2\", 2, testCollection.count());\n        \n        // Testing the save logic\n        DBObject record1 = testCollection.findOne(\"testSave1\");\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Einstein'\", \"Einstein\", record1.get(\"scientist\"));\n        record1.put(\"scientist\", \"Darwin\");\n        \n        result = template.requestBody(\"direct:save\", record1);\n        assertTrue(result instanceof UpdateResult);\n        \n        record1 = testCollection.findOne(\"testSave1\");\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Darwin' after save operation\", \"Darwin\", record1.get(\"scientist\"));\n\n    }","id":9718,"modified_method":"@Test\n    public void testSave() throws Exception {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        Object[] req = new Object[] {\"{\\\"_id\\\":\\\"testSave1\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", \"{\\\"_id\\\":\\\"testSave2\\\", \\\"scientist\\\":\\\"Copernicus\\\"}\"};\n        Object result = template.requestBody(\"direct:insert\", req);\n        assertTrue(result instanceof List);\n        assertEquals(\"Number of records persisted must be 2\", 2, testCollection.count());\n        \n        // Testing the save logic\n        DBObject record1 = testCollection.find(new BasicDBObject(\"_id\", \"testSave1\")).first();\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Einstein'\", \"Einstein\", record1.get(\"scientist\"));\n        record1.put(\"scientist\", \"Darwin\");\n        \n        result = template.requestBody(\"direct:save\", record1);\n        assertTrue(result instanceof UpdateResult);\n        \n        record1 = testCollection.find(new BasicDBObject(\"_id\", \"testSave1\")).first();\n        assertEquals(\"Scientist field of 'testSave1' must equal 'Darwin' after save operation\", \"Darwin\", record1.get(\"scientist\"));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInsertString() throws Exception {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insert\", \"{\\\"_id\\\":\\\"testInsertString\\\", \\\"scientist\\\":\\\"Einstein\\\"}\");\n        assertTrue(result instanceof BasicDBObject);\n        DBObject b = testCollection.findOne(\"testInsertString\");\n        assertNotNull(\"No record with 'testInsertString' _id\", b);\n    }","id":9719,"modified_method":"@Test\n    public void testInsertString() throws Exception {\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:insert\", \"{\\\"_id\\\":\\\"testInsertString\\\", \\\"scientist\\\":\\\"Einstein\\\"}\");\n        assertTrue(result instanceof BasicDBObject);\n        DBObject b = testCollection.find(new BasicDBObject(\"_id\", \"testInsertString\")).first();\n        assertNotNull(\"No record with 'testInsertString' _id\", b);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testUpdate() throws Exception {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        for (int i = 1; i <= 100; i++) {\n            String body = null;\n            Formatter f = new Formatter();\n            if (i % 2 == 0) {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", i).toString();\n            } else {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\", \\\"extraField\\\": true}\", i).toString();\n            }\n            f.close();\n            template.requestBody(\"direct:insert\", body);\n        }\n        assertEquals(100L, testCollection.count());\n        \n        // Testing the update logic\n        DBObject extraField = new BasicDBObject(\"extraField\", true);\n        assertEquals(\"Number of records with 'extraField' flag on must equal 50\", 50L, testCollection.count(extraField));\n        assertEquals(\"Number of records with 'scientist' field = Darwin on must equal 0\", 0, testCollection.count(new BasicDBObject(\"scientist\", \"Darwin\")));\n\n        DBObject updateObj = new BasicDBObject(\"$set\", new BasicDBObject(\"scientist\", \"Darwin\"));\n        \n        Object result = template.requestBodyAndHeader(\"direct:update\", new Object[] {extraField, updateObj}, MongoDbConstants.MULTIUPDATE, true);\n        assertTrue(result instanceof UpdateResult);\n        \n        assertEquals(\"Number of records with 'scientist' field = Darwin on must equal 50 after update\", 50, \n                testCollection.count(new BasicDBObject(\"scientist\", \"Darwin\")));\n\n    }","id":9720,"modified_method":"@Test\n    public void testUpdate() throws Exception {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        for (int i = 1; i <= 100; i++) {\n            String body = null;\n            Formatter f = new Formatter();\n            if (i % 2 == 0) {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", i).toString();\n            } else {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\", \\\"extraField\\\": true}\", i).toString();\n            }\n            f.close();\n            template.requestBody(\"direct:insert\", body);\n        }\n        assertEquals(100L, testCollection.count());\n        \n        // Testing the update logic\n        BasicDBObject extraField = new BasicDBObject(\"extraField\", true);\n        assertEquals(\"Number of records with 'extraField' flag on must equal 50\", 50L, testCollection.count(extraField));\n        assertEquals(\"Number of records with 'scientist' field = Darwin on must equal 0\", 0, testCollection.count(new BasicDBObject(\"scientist\", \"Darwin\")));\n\n        DBObject updateObj = new BasicDBObject(\"$set\", new BasicDBObject(\"scientist\", \"Darwin\"));\n        \n        Object result = template.requestBodyAndHeader(\"direct:update\", new Object[] {extraField, updateObj}, MongoDbConstants.MULTIUPDATE, true);\n        assertTrue(result instanceof UpdateResult);\n        \n        assertEquals(\"Number of records with 'scientist' field = Darwin on must equal 50 after update\", 50, \n                testCollection.count(new BasicDBObject(\"scientist\", \"Darwin\")));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCountOperation() throws Exception {\n        // Test that the collection has 0 documents in it\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:count\", \"irrelevantBody\");\n        assertTrue(\"Result is not of type Long\", result instanceof Long);\n        assertEquals(\"Test collection should not contain any records\", 0L, result);\n\n        // Insert a record and test that the endpoint now returns 1\n        testCollection.insert((DBObject) JSON.parse(\"{a:60}\"));\n        result = template.requestBody(\"direct:count\", \"irrelevantBody\");\n        assertTrue(\"Result is not of type Long\", result instanceof Long);\n        assertEquals(\"Test collection should contain 1 record\", 1L, result);\n        testCollection.remove(new BasicDBObject());\n        \n        // test dynamicity\n        dynamicCollection.insert((DBObject) JSON.parse(\"{a:60}\"));\n        result = template.requestBodyAndHeader(\"direct:count\", \"irrelevantBody\", MongoDbConstants.COLLECTION, dynamicCollectionName);\n        assertTrue(\"Result is not of type Long\", result instanceof Long);\n        assertEquals(\"Dynamic collection should contain 1 record\", 1L, result);\n        \n    }","id":9721,"modified_method":"@Test\n    public void testCountOperation() throws Exception {\n        // Test that the collection has 0 documents in it\n        assertEquals(0, testCollection.count());\n        Object result = template.requestBody(\"direct:count\", \"irrelevantBody\");\n        assertTrue(\"Result is not of type Long\", result instanceof Long);\n        assertEquals(\"Test collection should not contain any records\", 0L, result);\n\n        // Insert a record and test that the endpoint now returns 1\n        testCollection.insertOne((BasicDBObject) JSON.parse(\"{a:60}\"));\n        result = template.requestBody(\"direct:count\", \"irrelevantBody\");\n        assertTrue(\"Result is not of type Long\", result instanceof Long);\n        assertEquals(\"Test collection should contain 1 record\", 1L, result);\n        testCollection.deleteOne(new BasicDBObject());\n        \n        // test dynamicity\n        dynamicCollection.insertOne((BasicDBObject) JSON.parse(\"{a:60}\"));\n        result = template.requestBodyAndHeader(\"direct:count\", \"irrelevantBody\", MongoDbConstants.COLLECTION, dynamicCollectionName);\n        assertTrue(\"Result is not of type Long\", result instanceof Long);\n        assertEquals(\"Dynamic collection should contain 1 record\", 1L, result);\n        \n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testRemove() throws Exception {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        for (int i = 1; i <= 100; i++) {\n            String body = null;\n            Formatter f = new Formatter();\n            if (i % 2 == 0) {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", i).toString();\n            } else {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\", \\\"extraField\\\": true}\", i).toString();\n            }\n            f.close();\n            template.requestBody(\"direct:insert\", body);\n        }\n        assertEquals(100L, testCollection.count());\n        \n        // Testing the update logic\n        DBObject extraField = new BasicDBObject(\"extraField\", true);\n        assertEquals(\"Number of records with 'extraField' flag on must equal 50\", 50L, testCollection.count(extraField));\n        \n        Object result = template.requestBody(\"direct:remove\", extraField);\n        assertTrue(result instanceof DeleteResult);\n        \n        assertEquals(\"Number of records with 'extraField' flag on must be 0 after remove\", 0, \n                testCollection.count(extraField));\n\n    }","id":9722,"modified_method":"@Test\n    public void testRemove() throws Exception {\n        // Prepare test\n        assertEquals(0, testCollection.count());\n        for (int i = 1; i <= 100; i++) {\n            String body = null;\n            Formatter f = new Formatter();\n            if (i % 2 == 0) {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\"}\", i).toString();\n            } else {\n                body = f.format(\"{\\\"_id\\\":\\\"testSave%d\\\", \\\"scientist\\\":\\\"Einstein\\\", \\\"extraField\\\": true}\", i).toString();\n            }\n            f.close();\n            template.requestBody(\"direct:insert\", body);\n        }\n        assertEquals(100L, testCollection.count());\n        \n        // Testing the update logic\n        BasicDBObject extraField = new BasicDBObject(\"extraField\", true);\n        assertEquals(\"Number of records with 'extraField' flag on must equal 50\", 50L, testCollection.count(extraField));\n        \n        Object result = template.requestBody(\"direct:remove\", extraField);\n        assertTrue(result instanceof DeleteResult);\n        \n        assertEquals(\"Number of records with 'extraField' flag on must be 0 after remove\", 0, \n                testCollection.count(extraField));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testCustomTailTrackLocation() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        \n        // get the custom tracking collection and drop it (tailTrackDb=einstein&tailTrackCollection=curie&tailTrackField=newton)\n        DBCollection trackingCol = mongo.getDB(\"einstein\").getCollection(\"curie\");\n        trackingCol.drop();\n        trackingCol = mongo.getDB(\"einstein\").getCollection(\"curie\");\n        \n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        \n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer3\");\n        \n        mock.expectedMessageCount(300);\n        // pump 300 records\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 300; i++) {\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);  \n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        mock.reset();\n        \n        // stop the route to ensure that our lastVal is persisted, and check it\n        context.stopRoute(\"tailableCursorConsumer3\");\n        // ensure that the persisted lastVal is 300, newton is the name of the trackingField we are using\n        assertEquals(300, trackingCol.findOne(new BasicDBObject(\"persistentId\", \"darwin\")).get(\"newton\"));\n        context.startRoute(\"tailableCursorConsumer3\");\n        \n        // expect 300 messages and not 600\n        mock.expectedMessageCount(300);\n        // pump 300 records\n        t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 301; i <= 600; i++) {\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);  \n                }\n            }\n        });\n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        // check that the first received body contains increasing=301 and not increasing=1, i.e. it's not starting from the top\n        Object firstBody = mock.getExchanges().get(0).getIn().getBody();\n        assertTrue(firstBody instanceof DBObject);\n        assertEquals(301, ((DBObject) firstBody).get(\"increasing\"));\n        // check that the persisted lastVal after stopping the route is 600, newton is the name of the trackingField we are using\n        context.stopRoute(\"tailableCursorConsumer3\");\n        assertEquals(600, trackingCol.findOne(new BasicDBObject(\"persistentId\", \"darwin\")).get(\"newton\"));\n\n    }","id":9723,"modified_method":"@Test\n    public void testCustomTailTrackLocation() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        \n        // get the custom tracking collection and drop it (tailTrackDb=einstein&tailTrackCollection=curie&tailTrackField=newton)\n        MongoCollection<BasicDBObject> trackingCol = mongo.getDatabase(\"einstein\").getCollection(\"curie\", BasicDBObject.class);\n        trackingCol.drop();\n        trackingCol = mongo.getDatabase(\"einstein\").getCollection(\"curie\", BasicDBObject.class);\n        \n        // create a capped collection with max = 1000\n        //BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get()\n        db.createCollection(cappedTestCollectionName,\n                new CreateCollectionOptions().capped(true).sizeInBytes(1000000000).maxDocuments(1000));\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer3\");\n        \n        mock.expectedMessageCount(300);\n        // pump 300 records\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 300; i++) {\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        mock.reset();\n        \n        // stop the route to ensure that our lastVal is persisted, and check it\n        context.stopRoute(\"tailableCursorConsumer3\");\n        // ensure that the persisted lastVal is 300, newton is the name of the trackingField we are using\n        assertEquals(300, trackingCol.find(new BasicDBObject(\"persistentId\", \"darwin\")).first().get(\"newton\"));\n        context.startRoute(\"tailableCursorConsumer3\");\n        \n        // expect 300 messages and not 600\n        mock.expectedMessageCount(300);\n        // pump 300 records\n        t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 301; i <= 600; i++) {\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n                }\n            }\n        });\n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        // check that the first received body contains increasing=301 and not increasing=1, i.e. it's not starting from the top\n        Object firstBody = mock.getExchanges().get(0).getIn().getBody();\n        assertTrue(firstBody instanceof DBObject);\n        assertEquals(301, ((DBObject) firstBody).get(\"increasing\"));\n        // check that the persisted lastVal after stopping the route is 600, newton is the name of the trackingField we are using\n        context.stopRoute(\"tailableCursorConsumer3\");\n        assertEquals(600, trackingCol.find(new BasicDBObject(\"persistentId\", \"darwin\")).first().get(\"newton\"));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPersistentTailTrack() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        \n        // drop the tracking collection\n        db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION).drop();\n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        cappedTestCollection.createIndex(\"increasing\");\n        \n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        mock.expectedMessageCount(300);\n        // pump 300 records\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 300; i++) {\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);  \n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        mock.reset();\n        context.stopRoute(\"tailableCursorConsumer2\");\n        while (context.getRouteStatus(\"tailableCursorConsumer2\") != ServiceStatus.Stopped) { }\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        // expect 300 messages and not 600\n        mock.expectedMessageCount(300);\n        // pump 300 records\n        t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 301; i <= 600; i++) {\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);  \n                }\n            }\n        });\n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        \n        // check that the first message received in this second batch corresponds to increasing=301\n        Object firstBody = mock.getExchanges().get(0).getIn().getBody();\n        assertTrue(firstBody instanceof DBObject);\n        assertEquals(301, ((DBObject) firstBody).get(\"increasing\"));\n        \n        // check that the lastVal is persisted at the right time: check before and after stopping the route\n        assertEquals(300, db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION).findOne(new BasicDBObject(\"persistentId\", \"darwin\")).get(\"lastTrackingValue\"));\n        // stop the route and verify the last value has been updated\n        context.stopRoute(\"tailableCursorConsumer2\");\n        while (context.getRouteStatus(\"tailableCursorConsumer2\") != ServiceStatus.Stopped) { }\n        assertEquals(600, db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION).findOne(new BasicDBObject(\"persistentId\", \"darwin\")).get(\"lastTrackingValue\"));\n\n    }","id":9724,"modified_method":"@Test\n    public void testPersistentTailTrack() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        \n        // drop the tracking collection\n        db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION).drop();\n        // create a capped collection with max = 1000\n        // BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get()\n        db.createCollection(cappedTestCollectionName,\n                new CreateCollectionOptions().capped(true).sizeInBytes(1000000000).maxDocuments(1000));\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        cappedTestCollection.createIndex(new BasicDBObject(\"increasing\", 1));\n\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        mock.expectedMessageCount(300);\n        // pump 300 records\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 300; i++) {\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        mock.reset();\n        context.stopRoute(\"tailableCursorConsumer2\");\n        while (context.getRouteStatus(\"tailableCursorConsumer2\") != ServiceStatus.Stopped) { }\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        // expect 300 messages and not 600\n        mock.expectedMessageCount(300);\n        // pump 300 records\n        t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 301; i <= 600; i++) {\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n                }\n            }\n        });\n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        \n        // check that the first message received in this second batch corresponds to increasing=301\n        Object firstBody = mock.getExchanges().get(0).getIn().getBody();\n        assertTrue(firstBody instanceof DBObject);\n        assertEquals(301, ((DBObject) firstBody).get(\"increasing\"));\n        \n        // check that the lastVal is persisted at the right time: check before and after stopping the route\n        assertEquals(300, db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION).find(new BasicDBObject(\"persistentId\", \"darwin\")).first().get(\"lastTrackingValue\"));\n        // stop the route and verify the last value has been updated\n        context.stopRoute(\"tailableCursorConsumer2\");\n        while (context.getRouteStatus(\"tailableCursorConsumer2\") != ServiceStatus.Stopped) { }\n        assertEquals(600, db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION).find(new BasicDBObject(\"persistentId\", \"darwin\")).first().get(\"lastTrackingValue\"));\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void doPostSetup() {\n        super.doPostSetup();\n        // drop the capped collection and let each test create what it needs\n        cappedTestCollectionName = \"camelTestCapped\";\n        cappedTestCollection = db.getCollection(cappedTestCollectionName);\n        cappedTestCollection.drop();\n    }","id":9725,"modified_method":"@Override\n    public void doPostSetup() {\n        super.doPostSetup();\n        // drop the capped collection and let each test create what it needs\n        cappedTestCollectionName = \"camelTestCapped\";\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        cappedTestCollection.drop();\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testHundredThousandRecords() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(1000);\n       \n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        \n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer1\");\n        \n        // continuous pump of 100000 records, asserting incrementally to reduce overhead on the mock endpoint\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 100000; i++) {\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);\n                    \n                    // incrementally assert, as the mock endpoint stores all messages and otherwise the test would be sluggish\n                    if (i % 1000 == 0) {\n                        try {\n                            MongoDbTailableCursorConsumerTest.this.assertAndResetMockEndpoint(mock);\n                        } catch (Exception e) {\n                            return;\n                        }\n                    }       \n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we stop the route, wait for the data pumping to end\n        t.join();\n        \n        context.stopRoute(\"tailableCursorConsumer1\");\n\n    }","id":9726,"modified_method":"@Test\n    public void testHundredThousandRecords() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(1000);\n       \n        // create a capped collection with max = 1000\n        //BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get())\n        db.createCollection(cappedTestCollectionName,\n                new CreateCollectionOptions()\n                        .capped(true)\n                        .sizeInBytes(1000000000)\n                        .maxDocuments(100));\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer1\");\n        \n        // continuous pump of 100000 records, asserting incrementally to reduce overhead on the mock endpoint\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 100000; i++) {\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n                    \n                    // incrementally assert, as the mock endpoint stores all messages and otherwise the test would be sluggish\n                    if (i % 1000 == 0) {\n                        try {\n                            MongoDbTailableCursorConsumerTest.this.assertAndResetMockEndpoint(mock);\n                        } catch (Exception e) {\n                            return;\n                        }\n                    }       \n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we stop the route, wait for the data pumping to end\n        t.join();\n        \n        context.stopRoute(\"tailableCursorConsumer1\");\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testPersistentTailTrackIncreasingDateField() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        final Calendar startTimestamp = Calendar.getInstance();\n        \n        // get default tracking collection\n        DBCollection trackingCol = db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION);\n        trackingCol.drop();\n        trackingCol = db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION);\n        \n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        \n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        mock.expectedMessageCount(300);\n        // pump 300 records\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 300; i++) {\n                    Calendar c = (Calendar) (startTimestamp.clone());\n                    c.add(Calendar.MINUTE, i);\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", c.getTime()).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);\n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        mock.reset();\n        // ensure that the persisted lastVal is startTimestamp + 300min\n        Calendar cal300 = (Calendar) startTimestamp.clone();\n        cal300.add(Calendar.MINUTE, 300);\n        context.stopRoute(\"tailableCursorConsumer2\");\n        assertEquals(cal300.getTime(), trackingCol.findOne(new BasicDBObject(\"persistentId\", \"darwin\")).get(MongoDbTailTrackingConfig.DEFAULT_FIELD));\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        // expect 300 messages and not 600\n        mock.expectedMessageCount(300);\n        // pump 300 records\n        t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 301; i <= 600; i++) {\n                    Calendar c = (Calendar) (startTimestamp.clone());\n                    c.add(Calendar.MINUTE, i);\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", c.getTime()).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);\n                }\n            }\n        });\n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        Object firstBody = mock.getExchanges().get(0).getIn().getBody();\n        assertTrue(firstBody instanceof DBObject);\n        Calendar cal301 = (Calendar) startTimestamp.clone();\n        cal301.add(Calendar.MINUTE, 301);\n        assertEquals(cal301.getTime(), ((DBObject) firstBody).get(\"increasing\"));\n        // check that the persisted lastVal after stopping the route is startTimestamp + 600min\n        context.stopRoute(\"tailableCursorConsumer2\");\n        Calendar cal600 = (Calendar) startTimestamp.clone();\n        cal600.add(Calendar.MINUTE, 600);\n        assertEquals(cal600.getTime(), trackingCol.findOne(new BasicDBObject(\"persistentId\", \"darwin\")).get(MongoDbTailTrackingConfig.DEFAULT_FIELD));\n    }","id":9727,"modified_method":"@Test\n    public void testPersistentTailTrackIncreasingDateField() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        final MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        final Calendar startTimestamp = Calendar.getInstance();\n        \n        // get default tracking collection\n        MongoCollection<BasicDBObject> trackingCol = db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION, BasicDBObject.class);\n        trackingCol.drop();\n        trackingCol = db.getCollection(MongoDbTailTrackingConfig.DEFAULT_COLLECTION, BasicDBObject.class);\n        \n        // create a capped collection with max = 1000\n        //BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get()\n        db.createCollection(cappedTestCollectionName,\n                new CreateCollectionOptions().capped(true).sizeInBytes(1000000000).maxDocuments(1000));\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        mock.expectedMessageCount(300);\n        // pump 300 records\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 1; i <= 300; i++) {\n                    Calendar c = (Calendar) (startTimestamp.clone());\n                    c.add(Calendar.MINUTE, i);\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", c.getTime()).append(\"string\", \"value\" + i));\n                }\n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        mock.reset();\n        // ensure that the persisted lastVal is startTimestamp + 300min\n        Calendar cal300 = (Calendar) startTimestamp.clone();\n        cal300.add(Calendar.MINUTE, 300);\n        context.stopRoute(\"tailableCursorConsumer2\");\n        assertEquals(cal300.getTime(), trackingCol.find(new BasicDBObject(\"persistentId\", \"darwin\")).first().get(MongoDbTailTrackingConfig.DEFAULT_FIELD));\n        context.startRoute(\"tailableCursorConsumer2\");\n        \n        // expect 300 messages and not 600\n        mock.expectedMessageCount(300);\n        // pump 300 records\n        t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 301; i <= 600; i++) {\n                    Calendar c = (Calendar) (startTimestamp.clone());\n                    c.add(Calendar.MINUTE, i);\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", c.getTime()).append(\"string\", \"value\" + i));\n                }\n            }\n        });\n        // start the data pumping\n        t.start();\n        // before we continue wait for the data pump to end\n        t.join();\n        mock.assertIsSatisfied();\n        Object firstBody = mock.getExchanges().get(0).getIn().getBody();\n        assertTrue(firstBody instanceof DBObject);\n        Calendar cal301 = (Calendar) startTimestamp.clone();\n        cal301.add(Calendar.MINUTE, 301);\n        assertEquals(cal301.getTime(), ((DBObject) firstBody).get(\"increasing\"));\n        // check that the persisted lastVal after stopping the route is startTimestamp + 600min\n        context.stopRoute(\"tailableCursorConsumer2\");\n        Calendar cal600 = (Calendar) startTimestamp.clone();\n        cal600.add(Calendar.MINUTE, 600);\n        assertEquals(cal600.getTime(), trackingCol.find(new BasicDBObject(\"persistentId\", \"darwin\")).first().get(MongoDbTailTrackingConfig.DEFAULT_FIELD));\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testNoRecords() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(0);\n       \n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        assertEquals(0, cappedTestCollection.count());\n\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer1\");\n        Thread.sleep(1000);\n        mock.assertIsSatisfied();\n        context.stopRoute(\"tailableCursorConsumer1\");\n\n    }","id":9728,"modified_method":"@Test\n    public void testNoRecords() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(0);\n        //BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get()\n        // create a capped collection with max = 1000\n        CreateCollectionOptions collectionOptions = new CreateCollectionOptions()\n                .capped(true)\n                .sizeInBytes(1000000000)\n                .maxDocuments(1000);\n        db.createCollection(cappedTestCollectionName,\n                collectionOptions);\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        assertEquals(0, cappedTestCollection.count());\n\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer1\");\n        Thread.sleep(1000);\n        mock.assertIsSatisfied();\n        context.stopRoute(\"tailableCursorConsumer1\");\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testMultipleBursts() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(5000);\n       \n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        \n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer1\");\n        \n        // pump 5 bursts of 1000 records each with 500ms pause between burst and burst\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 5000; i++) {\n                    if (i % 1000 == 0) {\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            return;\n                        }\n                    }\n                    cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);\n                }\n                \n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we assert, wait for the data pumping to end\n        t.join();\n        \n        mock.assertIsSatisfied();\n        context.stopRoute(\"tailableCursorConsumer1\");\n\n    }","id":9729,"modified_method":"@Test\n    public void testMultipleBursts() throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(5000);\n        //BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get()\n        // create a capped collection with max = 1000\n        CreateCollectionOptions createCollectionOptions = new CreateCollectionOptions()\n                .capped(true)\n                .sizeInBytes(1000000000)\n                .maxDocuments(1000);\n        db.createCollection(cappedTestCollectionName,\n                createCollectionOptions);\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        addTestRoutes();\n        context.startRoute(\"tailableCursorConsumer1\");\n        \n        // pump 5 bursts of 1000 records each with 500ms pause between burst and burst\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 5000; i++) {\n                    if (i % 1000 == 0) {\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            return;\n                        }\n                    }\n                    cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n                }\n                \n            }\n        });\n        \n        // start the data pumping\n        t.start();\n        // before we assert, wait for the data pumping to end\n        t.join();\n        \n        mock.assertIsSatisfied();\n        context.stopRoute(\"tailableCursorConsumer1\");\n\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"private void testThousandRecordsWithRouteId(String routeId) throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(1000);\n       \n        // create a capped collection with max = 1000\n        cappedTestCollection = db.createCollection(cappedTestCollectionName, \n                BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get());\n        \n        for (int i = 0; i < 1000; i++) {\n            cappedTestCollection.insert(BasicDBObjectBuilder.start(\"increasing\", i).add(\"string\", \"value\" + i).get(), WriteConcern.SAFE);\n        }\n        assertEquals(1000, cappedTestCollection.count());\n\n        addTestRoutes();\n        context.startRoute(routeId);\n        Thread.sleep(1000);\n        mock.assertIsSatisfied();\n        context.stopRoute(routeId);\n    }","id":9730,"modified_method":"private void testThousandRecordsWithRouteId(String routeId) throws Exception {\n        assertEquals(0, cappedTestCollection.count());\n        MockEndpoint mock = getMockEndpoint(\"mock:test\");\n        mock.expectedMessageCount(1000);\n       \n        // create a capped collection with max = 1000\n        //BasicDBObjectBuilder.start().add(\"capped\", true).add(\"size\", 1000000000).add(\"max\", 1000).get()\n        db.createCollection(cappedTestCollectionName,\n                new CreateCollectionOptions()\n                        .capped(true)\n                        .sizeInBytes(1000000000)\n                        .maxDocuments(1000));\n        cappedTestCollection = db.getCollection(cappedTestCollectionName, BasicDBObject.class);\n        for (int i = 0; i < 1000; i++) {\n            cappedTestCollection.insertOne(new BasicDBObject(\"increasing\", i).append(\"string\", \"value\" + i));\n        }\n        assertEquals(1000, cappedTestCollection.count());\n\n        addTestRoutes();\n        context.startRoute(routeId);\n        Thread.sleep(1000);\n        mock.assertIsSatisfied();\n        context.stopRoute(routeId);\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    @Ignore\n    public void testDynamicWriteConcernSafe() throws Exception {\n        assertEquals(0, testCollection.count());\n        \n        // test with object first\n        Object result = template.requestBodyAndHeader(\"direct:noWriteConcern\", \"{\\\"scientist\\\":\\\"newton\\\"}\", MongoDbConstants.WRITECONCERN, WriteConcern.SAFE);\n        assertTrue(\"Result is not of type WriteResult\", result instanceof WriteResult);\n        WriteResult wr = (WriteResult) result;\n        assertTrue(wr.wasAcknowledged());\n        \n        // same behaviour should be reproduced with String 'SAFE'\n        result = template.requestBodyAndHeader(\"direct:noWriteConcern\", \"{\\\"scientist\\\":\\\"newton\\\"}\", MongoDbConstants.WRITECONCERN, \"SAFE\");\n        assertTrue(\"Result is not of type WriteResult\", result instanceof WriteResult);\n        wr = (WriteResult) result;\n        assertTrue(wr.wasAcknowledged());\n    }","id":9731,"modified_method":"@Test\n    @Ignore\n    public void testDynamicWriteConcernSafe() throws Exception {\n        assertEquals(0, testCollection.count());\n        \n        // test with object first\n        Object result = template.requestBody(\"direct:noWriteConcern\", \"{\\\"scientist\\\":\\\"newton\\\"}\");\n        assertTrue(\"Result is not of type WriteResult\", result instanceof WriteResult);\n        WriteResult wr = (WriteResult) result;\n        assertTrue(wr.wasAcknowledged());\n        \n        // same behaviour should be reproduced with String 'SAFE'\n        result = template.requestBody(\"direct:noWriteConcern\", \"{\\\"scientist\\\":\\\"newton\\\"}\");\n        assertTrue(\"Result is not of type WriteResult\", result instanceof WriteResult);\n        wr = (WriteResult) result;\n        assertTrue(wr.wasAcknowledged());\n    }","commit_id":"de1fa976680466b464e121c86266fe8dffb84d8b","url":"https://github.com/apache/camel"},{"original_method":"private static void doBuildDependencies(@NotNull Map<String, Pair<DataNode<GradleSourceSetData>, ExternalSourceSet>> sourceSetMap,\n                                          @NotNull Map<ExternalDependencyId, ExternalDependency> mergedDependencyMap,\n                                          @NotNull DataNode<? extends ExternalEntityData> ownerDataNode,\n                                          @NotNull Collection<ExternalDependency> dependencies,\n                                          @Nullable DataNode<ProjectData> ideProject) throws IllegalStateException {\n\n    Map<ExternalDependencyId, ExternalDependency> dependencyMap = ContainerUtil.newLinkedHashMap();\n    for (ExternalDependency dependency : dependencies) {\n      final ExternalDependency dep = dependencyMap.get(dependency.getId());\n      if (dep instanceof AbstractExternalDependency) {\n        dep.getDependencies().addAll(ContainerUtil.subtract(dependency.getDependencies(), dep.getDependencies()));\n      }\n      else {\n        dependencyMap.put(dependency.getId(), dependency);\n      }\n    }\n\n    for (ExternalDependency dependency : dependencyMap.values()) {\n      final ExternalDependency mergedDependency = ContainerUtil.getOrElse(mergedDependencyMap, dependency.getId(), dependency);\n      DependencyScope dependencyScope = getDependencyScope(mergedDependency.getScope());\n\n      ModuleData ownerModule = null;\n      if (ownerDataNode.getData() instanceof ModuleData) {\n        ownerModule = (ModuleData)ownerDataNode.getData();\n      }\n      else if (ownerDataNode.getData() instanceof DependencyData) {\n        ownerModule = ((DependencyData)ownerDataNode.getData()).getOwnerModule();\n      }\n\n      assert ownerModule != null;\n\n      if (mergedDependency instanceof ExternalProjectDependency) {\n        final ExternalProjectDependency projectDependency = (ExternalProjectDependency)mergedDependency;\n        String moduleId = getModuleId(projectDependency);\n        Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> projectPair = sourceSetMap.get(moduleId);\n        if (projectPair == null) {\n          final LibraryLevel level = LibraryLevel.MODULE;\n          final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, \"\");\n          LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n          libraryDependencyData.setScope(dependencyScope);\n          libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n          libraryDependencyData.setExported(mergedDependency.getExported());\n\n          if (!projectDependency.getProjectDependencyArtifacts().isEmpty()) {\n            for (File artifact : projectDependency.getProjectDependencyArtifacts()) {\n              library.addPath(LibraryPathType.BINARY, artifact.getPath());\n            }\n            ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n          }\n        }\n        else {\n          ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, projectPair.first.getData());\n          moduleDependencyData.setScope(dependencyScope);\n          if (\"test\".equals(projectPair.second.getName())) {\n            moduleDependencyData.setProductionOnTestDependency(true);\n          }\n          moduleDependencyData.setOrder(mergedDependency.getClasspathOrder());\n          moduleDependencyData.setExported(mergedDependency.getExported());\n          moduleDependencyData.setModuleDependencyArtifacts(ContainerUtil.map(\n            projectDependency.getProjectDependencyArtifacts(), new Function<File, String>() {\n              @Override\n              public String fun(File file) {\n                return file.getPath();\n              }\n            }));\n\n          DataNode<ModuleDependencyData> ideModuleDependencyNode =\n            ownerDataNode.createChild(ProjectKeys.MODULE_DEPENDENCY, moduleDependencyData);\n          doBuildDependencies(sourceSetMap, mergedDependencyMap, ideModuleDependencyNode, dependency.getDependencies(), ideProject);\n        }\n      }\n      if (mergedDependency instanceof ExternalLibraryDependency) {\n        String libraryName = mergedDependency.getId().getPresentableName();\n        final LibraryLevel level = StringUtil.isNotEmpty(libraryName) ? LibraryLevel.PROJECT : LibraryLevel.MODULE;\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n        libraryDependencyData.setExported(mergedDependency.getExported());\n\n        library.addPath(LibraryPathType.BINARY, ((ExternalLibraryDependency)mergedDependency).getFile().getAbsolutePath());\n        File sourcePath = ((ExternalLibraryDependency)mergedDependency).getSource();\n        if (sourcePath != null) {\n          library.addPath(LibraryPathType.SOURCE, sourcePath.getAbsolutePath());\n        }\n        File javaDocPath = ((ExternalLibraryDependency)mergedDependency).getJavadoc();\n        if (javaDocPath != null) {\n          library.addPath(LibraryPathType.DOC, javaDocPath.getAbsolutePath());\n        }\n        DataNode<LibraryDependencyData> libraryDependencyDataNode =\n          ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n\n        if (StringUtil.isNotEmpty(libraryName)) {\n          linkProjectLibrary(ideProject, library);\n        }\n        doBuildDependencies(sourceSetMap, mergedDependencyMap, libraryDependencyDataNode, dependency.getDependencies(), ideProject);\n      }\n      if (mergedDependency instanceof ExternalMultiLibraryDependency) {\n        final LibraryLevel level = LibraryLevel.MODULE;\n        String libraryName = mergedDependency.getId().getPresentableName();\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n        libraryDependencyData.setExported(mergedDependency.getExported());\n\n        for (File file : ((ExternalMultiLibraryDependency)mergedDependency).getFiles()) {\n          library.addPath(LibraryPathType.BINARY, file.getAbsolutePath());\n        }\n        for (File file : ((ExternalMultiLibraryDependency)mergedDependency).getSources()) {\n          library.addPath(LibraryPathType.SOURCE, file.getAbsolutePath());\n        }\n        for (File file : ((ExternalMultiLibraryDependency)mergedDependency).getJavadoc()) {\n          library.addPath(LibraryPathType.DOC, file.getAbsolutePath());\n        }\n\n        DataNode<LibraryDependencyData> libraryDependencyDataNode =\n          ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n\n        doBuildDependencies(sourceSetMap, mergedDependencyMap, libraryDependencyDataNode, dependency.getDependencies(), ideProject);\n      }\n      if (mergedDependency instanceof FileCollectionDependency) {\n        final LibraryLevel level = LibraryLevel.MODULE;\n        String libraryName = \"\";\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n        libraryDependencyData.setExported(mergedDependency.getExported());\n\n        for (File file : ((FileCollectionDependency)mergedDependency).getFiles()) {\n          library.addPath(LibraryPathType.BINARY, file.getAbsolutePath());\n        }\n\n        ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n      }\n      if (mergedDependency instanceof UnresolvedExternalDependency) {\n        final LibraryLevel level = LibraryLevel.PROJECT;\n        String libraryName = mergedDependency.getId().getPresentableName();\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName, true);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        final String failureMessage = ((UnresolvedExternalDependency)mergedDependency).getFailureMessage();\n        if (failureMessage != null) {\n          library.addPath(LibraryPathType.BINARY, failureMessage);\n        }\n        ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n        linkProjectLibrary(ideProject, library);\n      }\n    }\n  }","id":9732,"modified_method":"private static void doBuildDependencies(@NotNull Map<String, Pair<DataNode<GradleSourceSetData>, ExternalSourceSet>> sourceSetMap,\n                                          @NotNull Map<ExternalDependencyId, ExternalDependency> mergedDependencyMap,\n                                          @NotNull DataNode<? extends ExternalEntityData> ownerDataNode,\n                                          @NotNull Collection<ExternalDependency> dependencies,\n                                          @Nullable DataNode<ProjectData> ideProject) throws IllegalStateException {\n\n    Map<ExternalDependencyId, ExternalDependency> dependencyMap = ContainerUtil.newLinkedHashMap();\n    for (ExternalDependency dependency : dependencies) {\n      final ExternalDependency dep = dependencyMap.get(dependency.getId());\n      if (dep instanceof AbstractExternalDependency) {\n        dep.getDependencies().addAll(ContainerUtil.subtract(dependency.getDependencies(), dep.getDependencies()));\n      }\n      else {\n        dependencyMap.put(dependency.getId(), dependency);\n      }\n    }\n\n    for (ExternalDependency dependency : dependencyMap.values()) {\n      final ExternalDependency mergedDependency = ContainerUtil.getOrElse(mergedDependencyMap, dependency.getId(), dependency);\n      DependencyScope dependencyScope = getDependencyScope(mergedDependency.getScope());\n\n      ModuleData ownerModule = null;\n      if (ownerDataNode.getData() instanceof ModuleData) {\n        ownerModule = (ModuleData)ownerDataNode.getData();\n      }\n      else if (ownerDataNode.getData() instanceof DependencyData) {\n        ownerModule = ((DependencyData)ownerDataNode.getData()).getOwnerModule();\n      }\n\n      assert ownerModule != null;\n\n      DataNode<? extends ExternalEntityData> depOwnerDataNode = null;\n      if (mergedDependency instanceof ExternalProjectDependency) {\n        final ExternalProjectDependency projectDependency = (ExternalProjectDependency)mergedDependency;\n        String moduleId = getModuleId(projectDependency);\n        Pair<DataNode<GradleSourceSetData>, ExternalSourceSet> projectPair = sourceSetMap.get(moduleId);\n        if (projectPair == null) {\n          final LibraryLevel level = LibraryLevel.MODULE;\n          final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, \"\");\n          LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n          libraryDependencyData.setScope(dependencyScope);\n          libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n          libraryDependencyData.setExported(mergedDependency.getExported());\n\n          if (!projectDependency.getProjectDependencyArtifacts().isEmpty()) {\n            for (File artifact : projectDependency.getProjectDependencyArtifacts()) {\n              library.addPath(LibraryPathType.BINARY, artifact.getPath());\n            }\n            depOwnerDataNode = ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n          } else {\n            depOwnerDataNode = ownerDataNode;\n          }\n        }\n        else {\n          ModuleDependencyData moduleDependencyData = new ModuleDependencyData(ownerModule, projectPair.first.getData());\n          moduleDependencyData.setScope(dependencyScope);\n          if (\"test\".equals(projectPair.second.getName())) {\n            moduleDependencyData.setProductionOnTestDependency(true);\n          }\n          moduleDependencyData.setOrder(mergedDependency.getClasspathOrder());\n          moduleDependencyData.setExported(mergedDependency.getExported());\n          moduleDependencyData.setModuleDependencyArtifacts(ContainerUtil.map(\n            projectDependency.getProjectDependencyArtifacts(), new Function<File, String>() {\n              @Override\n              public String fun(File file) {\n                return file.getPath();\n              }\n            }));\n\n          depOwnerDataNode = ownerDataNode.createChild(ProjectKeys.MODULE_DEPENDENCY, moduleDependencyData);\n        }\n      }\n      else if (mergedDependency instanceof ExternalLibraryDependency) {\n        String libraryName = mergedDependency.getId().getPresentableName();\n        final LibraryLevel level = StringUtil.isNotEmpty(libraryName) ? LibraryLevel.PROJECT : LibraryLevel.MODULE;\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n        libraryDependencyData.setExported(mergedDependency.getExported());\n\n        library.addPath(LibraryPathType.BINARY, ((ExternalLibraryDependency)mergedDependency).getFile().getAbsolutePath());\n        File sourcePath = ((ExternalLibraryDependency)mergedDependency).getSource();\n        if (sourcePath != null) {\n          library.addPath(LibraryPathType.SOURCE, sourcePath.getAbsolutePath());\n        }\n        File javaDocPath = ((ExternalLibraryDependency)mergedDependency).getJavadoc();\n        if (javaDocPath != null) {\n          library.addPath(LibraryPathType.DOC, javaDocPath.getAbsolutePath());\n        }\n        depOwnerDataNode = ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n\n        if (StringUtil.isNotEmpty(libraryName)) {\n          linkProjectLibrary(ideProject, library);\n        }\n      }\n      else if (mergedDependency instanceof ExternalMultiLibraryDependency) {\n        final LibraryLevel level = LibraryLevel.MODULE;\n        String libraryName = mergedDependency.getId().getPresentableName();\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n        libraryDependencyData.setExported(mergedDependency.getExported());\n\n        for (File file : ((ExternalMultiLibraryDependency)mergedDependency).getFiles()) {\n          library.addPath(LibraryPathType.BINARY, file.getAbsolutePath());\n        }\n        for (File file : ((ExternalMultiLibraryDependency)mergedDependency).getSources()) {\n          library.addPath(LibraryPathType.SOURCE, file.getAbsolutePath());\n        }\n        for (File file : ((ExternalMultiLibraryDependency)mergedDependency).getJavadoc()) {\n          library.addPath(LibraryPathType.DOC, file.getAbsolutePath());\n        }\n\n        depOwnerDataNode = ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n      }\n      else if (mergedDependency instanceof FileCollectionDependency) {\n        final LibraryLevel level = LibraryLevel.MODULE;\n        String libraryName = \"\";\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        libraryDependencyData.setOrder(mergedDependency.getClasspathOrder());\n        libraryDependencyData.setExported(mergedDependency.getExported());\n\n        for (File file : ((FileCollectionDependency)mergedDependency).getFiles()) {\n          library.addPath(LibraryPathType.BINARY, file.getAbsolutePath());\n        }\n\n        ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n      }\n      else if (mergedDependency instanceof UnresolvedExternalDependency) {\n        final LibraryLevel level = LibraryLevel.PROJECT;\n        String libraryName = mergedDependency.getId().getPresentableName();\n        final LibraryData library = new LibraryData(GradleConstants.SYSTEM_ID, libraryName, true);\n        LibraryDependencyData libraryDependencyData = new LibraryDependencyData(ownerModule, library, level);\n        libraryDependencyData.setScope(dependencyScope);\n        final String failureMessage = ((UnresolvedExternalDependency)mergedDependency).getFailureMessage();\n        if (failureMessage != null) {\n          library.addPath(LibraryPathType.BINARY, failureMessage);\n        }\n        ownerDataNode.createChild(ProjectKeys.LIBRARY_DEPENDENCY, libraryDependencyData);\n        linkProjectLibrary(ideProject, library);\n      }\n\n      if (depOwnerDataNode != null) {\n        doBuildDependencies(sourceSetMap, mergedDependencyMap, depOwnerDataNode, dependency.getDependencies(), ideProject);\n      }\n    }\n  }","commit_id":"71f0b64e25981a6fc81cfbe8b2d2035b4d4928a0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void invalidResetPasswordFieldEntries() {\n        SignInPage signInPage =\n                new BasicWorkFlow().goToHome().clickSignInLink();\n        ResetPasswordPage resetPasswordPage = signInPage.goToResetPassword();\n        resetPasswordPage =\n                resetPasswordPage.enterUserName(\"b\").enterEmail(\"b\");\n        resetPasswordPage = resetPasswordPage.resetFailure();\n\n        assertThat(\"Invalid email error is displayed\",\n                resetPasswordPage.waitForErrors(),\n                hasItem(\"not a well-formed email address\"));\n\n        // Both are valid, but show seemingly at random\n        assertThat(\n                resetPasswordPage.getErrors().get(0),\n                either(equalTo(\"size must be between 3 and 20\")).or(\n                        equalTo(\"must match ^[a-z\\\\d_]{3,20}$\")));\n\n    }","id":9733,"modified_method":"@Feature(summary = \"The user must enter a valid account and email pair \" +\n            \"to reset their password\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void invalidResetPasswordFieldEntries() {\n        ResetPasswordPage resetPasswordPage = new BasicWorkFlow()\n                .goToHome()\n                .clickSignInLink()\n                .goToResetPassword()\n                .enterUserName(\"b\")\n                .enterEmail(\"b\")\n                .resetFailure();\n\n        assertThat(resetPasswordPage.waitForErrors())\n                .contains(\"not a well-formed email address\")\n                .as(\"Invalid email error is displayed\");\n\n        String error = resetPasswordPage.getErrors().get(0);\n        // Both are valid, but show seemingly at random\n        assertThat(error.equals(\"size must be between 3 and 20\") ||\n                error.equals(\"must match ^[a-z\\\\d_]{3,20}$\"))\n                .isTrue()\n                .as(\"Invalid email error is displayed\");\n    }","commit_id":"8a853f857180b709e6ae5434506168e8c327aee5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void resetPasswordFailureForInvalidAccount() {\n        SignInPage signInPage =\n                new BasicWorkFlow().goToHome().clickSignInLink();\n        ResetPasswordPage resetPasswordPage = signInPage.goToResetPassword();\n        resetPasswordPage =\n                resetPasswordPage.enterUserName(\"nosuchuser\").enterEmail(\n                        \"nosuchuser@nosuchdomain.com\");\n        resetPasswordPage = resetPasswordPage.resetFailure();\n        assertThat(\"A no such account message is displayed\",\n                resetPasswordPage.getNotificationMessage(),\n                equalTo(\"No such account found\"));\n    }","id":9734,"modified_method":"@Feature(summary = \"The user must enter a known account and email pair \" +\n            \"to reset their password\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void resetPasswordFailureForInvalidAccount() {\n        ResetPasswordPage resetPasswordPage = new BasicWorkFlow()\n                .goToHome()\n                .clickSignInLink()\n                .goToResetPassword()\n                .enterUserName(\"nosuchuser\")\n                .enterEmail(\"nosuchuser@nosuchdomain.com\")\n                .resetFailure();\n\n        assertThat(resetPasswordPage.getNotificationMessage())\n                .isEqualTo(\"No such account found\")\n                .as(\"A no such account message is displayed\");\n    }","commit_id":"8a853f857180b709e6ae5434506168e8c327aee5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void emptyResetPasswordFieldEntries() {\n        SignInPage signInPage =\n                new BasicWorkFlow().goToHome().clickSignInLink();\n        ResetPasswordPage resetPasswordPage = signInPage.goToResetPassword();\n        resetPasswordPage = resetPasswordPage.clearFields();\n        resetPasswordPage = resetPasswordPage.resetFailure();\n\n        assertThat(\"Empty email error is displayed\",\n                resetPasswordPage.waitForErrors(), hasItem(\"may not be empty\"));\n\n        // All are valid, but may show at random\n        assertThat(\n                resetPasswordPage.getErrors().get(0),\n                either(equalTo(\"size must be between 3 and 20\")).or(\n                        equalTo(\"may not be empty\")).or(\n                        equalTo(\"must match ^[a-z\\\\d_]{3,20}$\")));\n\n    }","id":9735,"modified_method":"@Feature(summary = \"The user must enter both an account name and email \" +\n            \"address to reset their password\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void emptyResetPasswordFieldEntries() {\n        ResetPasswordPage resetPasswordPage = new BasicWorkFlow()\n                .goToHome()\n                .clickSignInLink()\n                .goToResetPassword()\n                .clearFields()\n                .resetFailure();\n\n        assertThat(resetPasswordPage.waitForErrors())\n                .contains(\"may not be empty\")\n                .as(\"Empty email error is displayed\");\n\n        // All are valid, but may show at random\n        String error = resetPasswordPage.getErrors().get(0);\n        assertThat(error.equals(\"size must be between 3 and 20\") ||\n                error.equals(\"may not be empty\") ||\n                error.equals(\"must match ^[a-z\\\\d_]{3,20}$\"))\n                .as(\"The regex match for the reset password field has failed\");\n    }","commit_id":"8a853f857180b709e6ae5434506168e8c327aee5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Category(BasicAcceptanceTest.class)\n    public void signInSuccessful() {\n        DashboardBasePage dashboardPage =\n                new LoginWorkFlow().signIn(\"admin\", \"admin\");\n        assertThat(\"User is logged in\", dashboardPage.loggedInAs(),\n                equalTo(\"admin\"));\n    }","id":9736,"modified_method":"@Feature(summary = \"The user can log in\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 86815)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Category(BasicAcceptanceTest.class)\n    public void signInSuccessful() {\n        assertThat(new LoginWorkFlow()\n                .signIn(\"admin\", \"admin\")\n                .loggedInAs())\n                .isEqualTo(\"admin\")\n                .as(\"User can log in\");\n    }","commit_id":"8a853f857180b709e6ae5434506168e8c327aee5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Category(BasicAcceptanceTest.class)\n    public void signInFailure() {\n        SignInPage signInPage = new LoginWorkFlow()\n                .signInFailure(\"nosuchuser\", \"password\");\n\n        assertThat(\"Error message is shown\",\n                signInPage.waitForFieldErrors(),\n                Matchers.hasItem(\"Login failed\"));\n    }","id":9737,"modified_method":"@Feature(summary = \"The user must enter a correct username and \" +\n            \"password to log in\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 86815)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Category(BasicAcceptanceTest.class)\n    public void signInFailure() {\n        assertThat(new LoginWorkFlow()\n                .signInFailure(\"nosuchuser\", \"password\")\n                .waitForFieldErrors())\n                .contains(\"Login failed\")\n                .as(\"Log in error message is shown\");\n    }","commit_id":"8a853f857180b709e6ae5434506168e8c327aee5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Ignore(\"RHBZ-987707 | Cannot intercept email yet\")\n    public void resetPasswordSuccessful() {\n        SignInPage signInPage =\n                new BasicWorkFlow().goToHome().clickSignInLink();\n        ResetPasswordPage resetPasswordPage = signInPage.goToResetPassword();\n        resetPasswordPage =\n                resetPasswordPage.enterUserName(\"nosuchuser\").enterEmail(\n                        \"nosuchuser@nosuchdomain.com\");\n        resetPasswordPage = resetPasswordPage.resetPassword();\n        // TODO: Reset Success page\n    }","id":9738,"modified_method":"@Feature(summary = \"The user may reset their password via email\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    @Ignore(\"Rhbz-1114421\")\n    public void resetPasswordSuccessful() {\n        ResetPasswordPage resetPasswordPage = new BasicWorkFlow()\n                .goToHome()\n                .clickSignInLink()\n                .goToResetPassword()\n                .enterUserName(\"admin\")\n                .enterEmail(\"admin@example.com\")\n                .resetPassword();\n\n        assertThat(resetPasswordPage.getNotificationMessage())\n                .isEqualTo(\"You will soon receive an email with a link to \" +\n                        \"reset your password.\");\n\n        WiserMessage message = hasEmailRule.getMessages().get(0);\n        String emailContent = HasEmailRule.getEmailContent(message);\n\n        assertThat(message.getEnvelopeReceiver())\n                .isEqualTo(\"admin@example.com\")\n                .as(\"Zanata has sent an email to the user\");\n        assertThat(emailContent)\n                .contains(\"Please follow the link below to reset the \" +\n                        \"password for your account.\")\n                .as(\"The system has sent a reset password email to the user\");\n    }","commit_id":"8a853f857180b709e6ae5434506168e8c327aee5","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        final String mapName = \"testGetAsyncPopulatesNearCache\";\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        final IMap<Object, Object> map = instance1.getMap(mapName);\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        //populate near cache\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        //generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\"size below 400\", 400 < stats.getOwnedEntryCount());\n    }","id":9739,"modified_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheOwnedEntryCount = 400;\n        String mapName = \"testGetAsyncPopulatesNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        final IMap<Object, Object> map = instance1.getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n        }\n        //populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        //generate near cache hits\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\n                        \"Near cache owned entry count should be > %d but was %d\",\n                        expectedNearCacheOwnedEntryCount, stats.getOwnedEntryCount()\n                ),\n                stats.getOwnedEntryCount() > expectedNearCacheOwnedEntryCount\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAll() throws Exception {\n        final String mapName = \"testGetAllWithNearCache\";\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        //populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        final Map<Integer, Integer> all = map.getAll(keys);\n        NearCacheStats stats2 = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\"hits\", 400 < stats2.getHits());\n        for (int i = 0; i < size; i++) {\n            assertEquals(i,(int)all.get(i));\n        }\n\n    }","id":9740,"modified_method":"@Test\n    public void testGetAll() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 400;\n        String mapName = \"testGetAllWithNearCache\";\n\n        Config config = new Config();\n        NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n\n        TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = hazelcastInstanceFactory.newInstances(config);\n\n        // Populate map\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n        HashSet<Integer> keys = new HashSet<Integer>();\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n\n        // Populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        // Generate near cache hits\n        Map<Integer, Integer> allEntries = map.getAll(keys);\n        for (int i = 0; i < mapSize; i++) {\n            assertEquals(i, (int) allEntries.get(i));\n        }\n\n        // Check near cache hits\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache hits should be > %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                stats.getHits() > expectedNearCacheHits\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAllIssue1863() throws Exception {\n        final String mapName = \"testGetAllWithNearCacheIssue1863\";\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        //populate near cache with nulls -- cache local entries mode on.\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n        final Map<Integer, Integer> all = map.getAll(keys);\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(0, all.size());\n        assertEquals(size, stats.getHits());\n    }","id":9741,"modified_method":"@Test\n    public void testGetAllIssue1863() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 1000;\n        String mapName = \"testGetAllWithNearCacheIssue1863\";\n\n        Config config = new Config();\n        NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n\n        TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = hazelcastInstanceFactory.newInstances(config);\n\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        // Populate near cache with nulls (cache local entries mode on)\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n\n        // Generate near cache hits\n        Map<Integer, Integer> allEntries = map.getAll(keys);\n        assertEquals(0, allEntries.size());\n\n        // Check near cache hits\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(\n                String.format(\"Near cache hits should be %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                expectedNearCacheHits,\n                stats.getHits()\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheStats() throws Exception {\n        String mapName = randomMapName();\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = factory.newInstances(config);\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n\n        for (int i = 0; i < 1000; i++) {\n            map.put(i, i);\n        }\n        //populate near cache\n        for (int i = 0; i < 1000; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n\n        assertTrue(\"owned Entries\", 400 < stats.getOwnedEntryCount());\n        assertTrue(\"misses\", 1000 == stats.getMisses());\n        //make some hits\n        for (int i = 0; i < 1000; i++) {\n            map.get(i);\n        }\n        NearCacheStats stats2 = map.getLocalMapStats().getNearCacheStats();\n\n        assertTrue(\"hits\", 400 < stats2.getHits());\n        assertTrue(\"misses\", 400 < stats2.getMisses());\n        assertTrue(\"hits+misses\", 2000 == stats2.getHits() + stats2.getMisses());\n    }","id":9742,"modified_method":"@Test\n    public void testNearCacheStats() throws Exception {\n        int mapSize = 1000;\n        String mapName = randomMapName();\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = factory.newInstances(config);\n\n        // Populate map\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n        }\n\n        // Populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache misses should be > %d but were %d\", 400, stats.getOwnedEntryCount()),\n                stats.getOwnedEntryCount() > 400\n        );\n        assertEquals(\n                String.format(\"Near cache misses should be %d but were %d\", mapSize, stats.getMisses()),\n                mapSize,\n                stats.getMisses()\n        );\n\n        //make some hits\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache hits should be > %d but were %d\", 400, stats.getHits()),\n                stats.getHits() > 400\n        );\n        assertTrue(\n                String.format(\"Near cache misses should be > %d but were %d\", 400, stats.getMisses()),\n                stats.getMisses() > 400\n        );\n        long hitsAndMisses = stats.getHits() + stats.getMisses();\n        assertEquals(\n                String.format(\"Near cache hits + misses should be %s but were %d\", mapSize * 2, hitsAndMisses),\n                mapSize * 2,\n                hitsAndMisses\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsyncIssue1863() throws Exception {\n        final String mapName = \"testGetAsyncWithNearCacheIssue1863\";\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        //populate near cache   -- cache local entries mode on.\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n\n        for (int i = 0; i < size; i++) {\n            final Future<Integer> async = map.getAsync(i);\n            assertNull(async.get());\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getHits());\n\n    }","id":9743,"modified_method":"@Test\n    public void testGetAsyncIssue1863() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 1000;\n        String mapName = \"testGetAsyncWithNearCacheIssue1863\";\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        //populate near cache   -- cache local entries mode on.\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n\n        for (int i = 0; i < mapSize; i++) {\n            final Future<Integer> async = map.getAsync(i);\n            assertNull(async.get());\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(\n                String.format(\"Near cache hits should be %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                expectedNearCacheHits,\n                stats.getHits()\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNullValueNearCache() {\n        int n = 2;\n        String mapName = \"testNullValueNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());\n        HazelcastInstance instance = createHazelcastInstanceFactory(n).newInstances(config)[0];\n\n        IMap<String, String> map = instance.getMap(mapName);\n\n        int size = 100;\n\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        assertTrue(map.getLocalMapStats().getGetOperationCount() < size * 2);\n    }","id":9744,"modified_method":"@Test\n    public void testNullValueNearCache() {\n        int n = 2;\n        int mapSize = 100;\n        String mapName = \"testNullValueNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());\n        HazelcastInstance instance = createHazelcastInstanceFactory(n).newInstances(config)[0];\n\n        IMap<String, String> map = instance.getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        for (int i = 0; i < mapSize; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        assertTrue(\n                String.format(\n                        \"NearCache operation count should be < %d but was %d\",\n                        mapSize * 2,\n                        map.getLocalMapStats().getGetOperationCount()\n                ),\n                map.getLocalMapStats().getGetOperationCount() < mapSize * 2\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsync() throws Exception {\n        final String mapName = \"testGetAsyncWithNearCache\";\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        //populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n\n        for (int i = 0; i < size; i++) {\n            final Future<Integer> async = map.getAsync(i);\n        }\n\n        NearCacheStats stats2 = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\"hits\", 400 < stats2.getHits());\n\n    }","id":9745,"modified_method":"@Test\n    public void testGetAsync() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 400;\n        String mapName = \"testGetAsyncWithNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        //populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        for (int i = 0; i < mapSize; i++) {\n            final Future<Integer> async = map.getAsync(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache hits should be > %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                stats.getHits() > expectedNearCacheHits\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testCacheLocalEntries() {\n        int n = 2;\n        String mapName = \"test\";\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        nearCacheConfig.setInvalidateOnChange(false);\n        final MapConfig mapConfig = config.getMapConfig(mapName);\n        mapConfig.setNearCacheConfig(nearCacheConfig);\n        HazelcastInstance instance = createHazelcastInstanceFactory(n).newInstances(config)[0];\n\n        IMap<String, String> map = instance.getMap(mapName);\n\n        int noOfEntries = 100;\n\n        for (int i = 0; i < noOfEntries; i++) {\n            map.put(\"key\" + i, \"value\" + i);\n        }\n\n        //warm-up cache\n        for (int i = 0; i < noOfEntries; i++) {\n            map.get(\"key\" + i);\n        }\n\n        NearCache nearCache = getNearCache(mapName, instance);\n        assertEquals(noOfEntries, nearCache.size());\n    }","id":9746,"modified_method":"@Test\n    public void testCacheLocalEntries() {\n        int instanceCount = 2;\n        int mapSize = 100;\n        String mapName = \"testCacheLocalEntries\";\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        nearCacheConfig.setInvalidateOnChange(false);\n        final MapConfig mapConfig = config.getMapConfig(mapName);\n        mapConfig.setNearCacheConfig(nearCacheConfig);\n        HazelcastInstance[] instances = createHazelcastInstanceFactory(instanceCount).newInstances(config);\n\n        IMap<String, String> map = instances[0].getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            map.put(\"key\" + i, \"value\" + i);\n        }\n\n        //warm-up cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(\"key\" + i);\n        }\n\n        NearCache nearCache = getNearCache(mapName, instances[0]);\n        assertEquals(\n                String.format(\"Near cache size should be %d but was %d\", mapSize, nearCache.size()),\n                mapSize,\n                nearCache.size()\n        );\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testBasicUsage() throws Exception {\n        int n = 3;\n        String mapName = \"test\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(true));\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(n);\n\n        HazelcastInstance[] instances = factory.newInstances(config);\n        IMap<Object, Object> map = instances[0].getMap(mapName);\n\n        int count = 5000;\n        for (int i = 0; i < count; i++) {\n            map.put(i, i);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (int i = 0; i < count; i++) {\n            map.put(i, i * 2);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertTrue(\"NearCache Size: \" + size, size > 0);\n        }\n\n        map.clear();\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertEquals(0, size);\n        }\n\n    }","id":9747,"modified_method":"@Test\n    public void testBasicUsage() throws Exception {\n        int n = 3;\n        String mapName = \"test\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(true));\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(n);\n\n        HazelcastInstance[] instances = factory.newInstances(config);\n        IMap<Object, Object> map = instances[0].getMap(mapName);\n\n        int count = 5000;\n        for (int i = 0; i < count; i++) {\n            map.put(i, i);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (int i = 0; i < count; i++) {\n            map.put(i, i * 2);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertTrue(\"NearCache size should be > 0 but was \" + size, size > 0);\n        }\n\n        map.clear();\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertEquals(\"NearCache size should be 0 but was \" + size, 0, size);\n        }\n    }","commit_id":"7b452ffefadab8852af9a9c56780be3409431ce1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void assertNearCacheSize(final int expectedSize, final String mapName, final Map map) {\n\n        final AssertTask assertionTask = new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                final MapProxyImpl mapProxy = (MapProxyImpl) map;\n                final MapService mapService = (MapService) mapProxy.getService();\n                final MapServiceContext mapServiceContext = mapService.getMapServiceContext();\n                final NearCacheProvider nearCacheProvider = mapServiceContext.getNearCacheProvider();\n                final NearCache nearCache = nearCacheProvider.getNearCache(mapName);\n\n                assertEquals(expectedSize, nearCache.size());\n            }\n        };\n\n        assertTrueEventually(assertionTask);\n    }","id":9748,"modified_method":"private void assertNearCacheSize(final int expectedSize, final String mapName, final Map map) {\n\n        final AssertTask assertionTask = new AssertTask() {\n            @Override\n            public void run() throws Exception {\n                final MapProxyImpl mapProxy = (MapProxyImpl) map;\n                final MapService mapService = mapProxy.getService();\n                final MapServiceContext mapServiceContext = mapService.getMapServiceContext();\n                final NearCacheProvider nearCacheProvider = mapServiceContext.getNearCacheProvider();\n                final NearCache nearCache = nearCacheProvider.getNearCache(mapName);\n\n                assertEquals(expectedSize, nearCache.size());\n            }\n        };\n\n        assertTrueEventually(assertionTask);\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsyncIssue1863() throws Exception {\n        final String mapName = \"testGetAsyncWithNearCacheIssue1863\";\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        //populate near cache   -- cache local entries mode on.\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n\n        for (int i = 0; i < size; i++) {\n            final Future<Integer> async = map.getAsync(i);\n            assertNull(async.get());\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(size, stats.getHits());\n\n    }","id":9749,"modified_method":"@Test\n    public void testGetAsyncIssue1863() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 1000;\n        String mapName = \"testGetAsyncWithNearCacheIssue1863\";\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        //populate near cache -- cache local entries mode on\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n\n        for (int i = 0; i < mapSize; i++) {\n            final Future<Integer> async = map.getAsync(i);\n            assertNull(async.get());\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(\n                String.format(\"Near cache hits should be %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                expectedNearCacheHits,\n                stats.getHits()\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAll() throws Exception {\n        final String mapName = \"testGetAllWithNearCache\";\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        //populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        final Map<Integer, Integer> all = map.getAll(keys);\n        NearCacheStats stats2 = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\"hits\", 400 < stats2.getHits());\n        for (int i = 0; i < size; i++) {\n            assertEquals(i, (int) all.get(i));\n        }\n\n    }","id":9750,"modified_method":"@Test\n    public void testGetAll() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 400;\n        String mapName = \"testGetAllWithNearCache\";\n\n        Config config = new Config();\n        NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n\n        TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = hazelcastInstanceFactory.newInstances(config);\n\n        // Populate map\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n        HashSet<Integer> keys = new HashSet<Integer>();\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n\n        // Populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        // Generate near cache hits\n        Map<Integer, Integer> allEntries = map.getAll(keys);\n        for (int i = 0; i < mapSize; i++) {\n            assertEquals(i, (int) allEntries.get(i));\n        }\n\n        // Check near cache hits\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache hits should be > %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                stats.getHits() > expectedNearCacheHits\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNullValueNearCache() {\n        int n = 2;\n        String mapName = \"testNullValueNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());\n        HazelcastInstance instance = createHazelcastInstanceFactory(n).newInstances(config)[0];\n\n        IMap<String, String> map = instance.getMap(mapName);\n\n        int size = 100;\n\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        for (int i = 0; i < size; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        assertTrue(map.getLocalMapStats().getGetOperationCount() < size * 2);\n    }","id":9751,"modified_method":"@Test\n    public void testNullValueNearCache() {\n        int n = 2;\n        int mapSize = 100;\n        String mapName = \"testNullValueNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig());\n        HazelcastInstance instance = createHazelcastInstanceFactory(n).newInstances(config)[0];\n\n        IMap<String, String> map = instance.getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        for (int i = 0; i < mapSize; i++) {\n            assertNull(map.get(\"key\" + i));\n        }\n\n        assertTrue(\n                String.format(\n                        \"NearCache operation count should be < %d but was %d\",\n                        mapSize * 2,\n                        map.getLocalMapStats().getGetOperationCount()\n                ),\n                map.getLocalMapStats().getGetOperationCount() < mapSize * 2\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        final String mapName = \"testGetAsyncPopulatesNearCache\";\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        final IMap<Object, Object> map = instance1.getMap(mapName);\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n        }\n        //populate near cache\n        for (int i = 0; i < size; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        //generate near cache hits\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\"size below 400\", 400 < stats.getOwnedEntryCount());\n    }","id":9752,"modified_method":"@Test\n    public void testGetAsyncPopulatesNearCache() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheOwnedEntryCount = 400;\n        String mapName = \"testGetAsyncPopulatesNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        final IMap<Object, Object> map = instance1.getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n        }\n        //populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            Future async = map.getAsync(i);\n            async.get();\n        }\n        //generate near cache hits\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\n                        \"Near cache owned entry count should be > %d but was %d\",\n                        expectedNearCacheOwnedEntryCount, stats.getOwnedEntryCount()\n                ),\n                stats.getOwnedEntryCount() > expectedNearCacheOwnedEntryCount\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testBasicUsage() throws Exception {\n        int n = 3;\n        String mapName = \"test\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(true));\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(n);\n\n        HazelcastInstance[] instances = factory.newInstances(config);\n        IMap<Object, Object> map = instances[0].getMap(mapName);\n\n        int count = 5000;\n        for (int i = 0; i < count; i++) {\n            map.put(i, i);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (int i = 0; i < count; i++) {\n            map.put(i, i * 2);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertTrue(\"NearCache Size: \" + size, size > 0);\n        }\n\n        map.clear();\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertEquals(0, size);\n        }\n\n    }","id":9753,"modified_method":"@Test\n    public void testBasicUsage() throws Exception {\n        int n = 3;\n        String mapName = \"test\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(true));\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(n);\n\n        HazelcastInstance[] instances = factory.newInstances(config);\n        IMap<Object, Object> map = instances[0].getMap(mapName);\n\n        int count = 5000;\n        for (int i = 0; i < count; i++) {\n            map.put(i, i);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (int i = 0; i < count; i++) {\n            map.put(i, i * 2);\n        }\n\n        for (HazelcastInstance instance : instances) {\n            IMap<Object, Object> m = instance.getMap(mapName);\n            for (int i = 0; i < count; i++) {\n                Assert.assertNotNull(m.get(i));\n            }\n        }\n\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertTrue(\"NearCache size should be > 0 but was \" + size, size > 0);\n        }\n\n        map.clear();\n        for (HazelcastInstance instance : instances) {\n            NearCache nearCache = getNearCache(mapName, instance);\n            int size = nearCache.size();\n            assertEquals(\"NearCache size should be 0 but was \" + size, 0, size);\n        }\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAllIssue1863() throws Exception {\n        final String mapName = \"testGetAllWithNearCacheIssue1863\";\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        final HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        //populate near cache with nulls -- cache local entries mode on.\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n        final Map<Integer, Integer> all = map.getAll(keys);\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(0, all.size());\n        assertEquals(size, stats.getHits());\n    }","id":9754,"modified_method":"@Test\n    public void testGetAllIssue1863() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 1000;\n        String mapName = \"testGetAllWithNearCacheIssue1863\";\n\n        Config config = new Config();\n        NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        config.getMapConfig(mapName).setNearCacheConfig(nearCacheConfig);\n\n        TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = hazelcastInstanceFactory.newInstances(config);\n\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n        HashSet<Integer> keys = new HashSet<Integer>();\n\n        // Populate near cache with nulls (cache local entries mode on)\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n            keys.add(i);\n        }\n\n        // Generate near cache hits\n        Map<Integer, Integer> allEntries = map.getAll(keys);\n        assertEquals(0, allEntries.size());\n\n        // Check near cache hits\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertEquals(\n                String.format(\"Near cache hits should be %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                expectedNearCacheHits,\n                stats.getHits()\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testNearCacheStats() throws Exception {\n        String mapName = randomMapName();\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = factory.newInstances(config);\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n\n        for (int i = 0; i < 1000; i++) {\n            map.put(i, i);\n        }\n        //populate near cache\n        for (int i = 0; i < 1000; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n\n        assertTrue(\"owned Entries\", 400 < stats.getOwnedEntryCount());\n        assertTrue(\"misses\", 1000 == stats.getMisses());\n        //make some hits\n        for (int i = 0; i < 1000; i++) {\n            map.get(i);\n        }\n        NearCacheStats stats2 = map.getLocalMapStats().getNearCacheStats();\n\n        assertTrue(\"hits\", 400 < stats2.getHits());\n        assertTrue(\"misses\", 400 < stats2.getMisses());\n        assertTrue(\"hits+misses\", 2000 == stats2.getHits() + stats2.getMisses());\n    }","id":9755,"modified_method":"@Test\n    public void testNearCacheStats() throws Exception {\n        int mapSize = 1000;\n        String mapName = randomMapName();\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        HazelcastInstance[] instances = factory.newInstances(config);\n\n        // Populate map\n        IMap<Integer, Integer> map = instances[0].getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n        }\n\n        // Populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache misses should be > %d but were %d\", 400, stats.getOwnedEntryCount()),\n                stats.getOwnedEntryCount() > 400\n        );\n        assertEquals(\n                String.format(\"Near cache misses should be %d but were %d\", mapSize, stats.getMisses()),\n                mapSize,\n                stats.getMisses()\n        );\n\n        //make some hits\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache hits should be > %d but were %d\", 400, stats.getHits()),\n                stats.getHits() > 400\n        );\n        assertTrue(\n                String.format(\"Near cache misses should be > %d but were %d\", 400, stats.getMisses()),\n                stats.getMisses() > 400\n        );\n        long hitsAndMisses = stats.getHits() + stats.getMisses();\n        assertEquals(\n                String.format(\"Near cache hits + misses should be %s but were %d\", mapSize * 2, hitsAndMisses),\n                mapSize * 2,\n                hitsAndMisses\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testCacheLocalEntries() {\n        int n = 2;\n        String mapName = \"test\";\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        nearCacheConfig.setInvalidateOnChange(false);\n        final MapConfig mapConfig = config.getMapConfig(mapName);\n        mapConfig.setNearCacheConfig(nearCacheConfig);\n        HazelcastInstance instance = createHazelcastInstanceFactory(n).newInstances(config)[0];\n\n        IMap<String, String> map = instance.getMap(mapName);\n\n        int noOfEntries = 100;\n\n        for (int i = 0; i < noOfEntries; i++) {\n            map.put(\"key\" + i, \"value\" + i);\n        }\n\n        //warm-up cache\n        for (int i = 0; i < noOfEntries; i++) {\n            map.get(\"key\" + i);\n        }\n\n        NearCache nearCache = getNearCache(mapName, instance);\n        assertEquals(noOfEntries, nearCache.size());\n    }","id":9756,"modified_method":"@Test\n    public void testCacheLocalEntries() {\n        int instanceCount = 2;\n        int mapSize = 100;\n        String mapName = \"testCacheLocalEntries\";\n\n        Config config = new Config();\n        final NearCacheConfig nearCacheConfig = new NearCacheConfig();\n        nearCacheConfig.setCacheLocalEntries(true);\n        nearCacheConfig.setInvalidateOnChange(false);\n        final MapConfig mapConfig = config.getMapConfig(mapName);\n        mapConfig.setNearCacheConfig(nearCacheConfig);\n        HazelcastInstance[] instances = createHazelcastInstanceFactory(instanceCount).newInstances(config);\n\n        IMap<String, String> map = instances[0].getMap(mapName);\n        for (int i = 0; i < mapSize; i++) {\n            map.put(\"key\" + i, \"value\" + i);\n        }\n\n        //warm-up cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(\"key\" + i);\n        }\n\n        NearCache nearCache = getNearCache(mapName, instances[0]);\n        assertEquals(\n                String.format(\"Near cache size should be %d but was %d\", mapSize, nearCache.size()),\n                mapSize,\n                nearCache.size()\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testGetAsync() throws Exception {\n        final String mapName = \"testGetAsyncWithNearCache\";\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        int size = 1000;\n        for (int i = 0; i < size; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        //populate near cache\n        for (int i = 0; i < size; i++) {\n            map.get(i);\n        }\n\n\n        for (int i = 0; i < size; i++) {\n            final Future<Integer> async = map.getAsync(i);\n        }\n\n        NearCacheStats stats2 = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\"hits\", 400 < stats2.getHits());\n\n    }","id":9757,"modified_method":"@Test\n    public void testGetAsync() throws Exception {\n        int mapSize = 1000;\n        int expectedNearCacheHits = 400;\n        String mapName = \"testGetAsyncWithNearCache\";\n\n        Config config = new Config();\n        config.getMapConfig(mapName).setNearCacheConfig(new NearCacheConfig().setInvalidateOnChange(false));\n        final TestHazelcastInstanceFactory hazelcastInstanceFactory = createHazelcastInstanceFactory(2);\n        HazelcastInstance instance1 = hazelcastInstanceFactory.newHazelcastInstance(config);\n        HazelcastInstance instance2 = hazelcastInstanceFactory.newHazelcastInstance(config);\n\n        IMap<Integer, Integer> map = instance1.getMap(mapName);\n        HashSet keys = new HashSet();\n        for (int i = 0; i < mapSize; i++) {\n            map.put(i, i);\n            keys.add(i);\n        }\n        //populate near cache\n        for (int i = 0; i < mapSize; i++) {\n            map.get(i);\n        }\n\n        for (int i = 0; i < mapSize; i++) {\n            final Future<Integer> async = map.getAsync(i);\n        }\n\n        NearCacheStats stats = map.getLocalMapStats().getNearCacheStats();\n        assertTrue(\n                String.format(\"Near cache hits should be > %d but were %d\", expectedNearCacheHits, stats.getHits()),\n                stats.getHits() > expectedNearCacheHits\n        );\n    }","commit_id":"b3bac1650b282319ee8e13cba2bbf64729b9e70a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n  public boolean isEnabled(Editor editor, DataContext dataContext) {\n    return editor.getCaretModel().supportsMultipleCarets();\n  }","id":9758,"modified_method":"@Override\n  public boolean isEnabledForCaret(@NotNull Editor editor, @NotNull Caret caret, DataContext dataContext) {\n    return editor.getCaretModel().supportsMultipleCarets();\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSelectionWithKeyboardInEmptySpace() throws Exception {\n    init(\"\\n\\n\");\n    mouse().clickAt(1, 1);\n    verifyCaretsAndSelections(1, 1, 1, 1);\n\n    executeAction(\"EditorRightWithSelection\");\n    verifyCaretsAndSelections(1, 2, 1, 2);\n\n    executeAction(\"EditorDownWithSelection\");\n    verifyCaretsAndSelections(1, 2, 1, 2,\n                              2, 2, 1, 2);\n\n    executeAction(\"EditorLeftWithSelection\");\n    verifyCaretsAndSelections(1, 1, 1, 1,\n                              2, 1, 1, 1);\n\n    executeAction(\"EditorLeftWithSelection\");\n    verifyCaretsAndSelections(1, 0, 0, 1,\n                              2, 0, 0, 1);\n\n    executeAction(\"EditorUpWithSelection\");\n    verifyCaretsAndSelections(1, 0, 0, 1);\n\n    executeAction(\"EditorUpWithSelection\");\n    verifyCaretsAndSelections(0, 0, 0, 1,\n                              1, 0, 0, 1);\n\n    executeAction(\"EditorRightWithSelection\");\n    verifyCaretsAndSelections(0, 1, 1, 1,\n                              1, 1, 1, 1);\n\n    executeAction(\"EditorRightWithSelection\");\n    verifyCaretsAndSelections(0, 2, 1, 2,\n                              1, 2, 1, 2);\n\n    executeAction(\"EditorDownWithSelection\");\n    verifyCaretsAndSelections(1, 2, 1, 2);\n\n    executeAction(\"EditorLeftWithSelection\");\n    verifyCaretsAndSelections(1, 1, 1, 1);\n  }","id":9759,"modified_method":"public void testSelectionWithKeyboardInEmptySpace() throws Exception {\n    init(\"\\n\\n\");\n    mouse().clickAt(1, 1);\n    verifyCaretsAndSelections(1, 1, 1, 1);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 2, 1, 2);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 2, 1, 2,\n                              2, 2, 1, 2);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_LEFT_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 1, 1, 1,\n                              2, 1, 1, 1);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_LEFT_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 0, 0, 1,\n                              2, 0, 0, 1);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 0, 0, 1);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    verifyCaretsAndSelections(0, 0, 0, 1,\n                              1, 0, 0, 1);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    verifyCaretsAndSelections(0, 1, 1, 1,\n                              1, 1, 1, 1);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    verifyCaretsAndSelections(0, 2, 1, 2,\n                              1, 2, 1, 2);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 2, 1, 2);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_LEFT_WITH_SELECTION);\n    verifyCaretsAndSelections(1, 1, 1, 1);\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSelectNextPrevWord() throws Exception {\n    init(\"aaa aaa<caret>\\n\" +\n         \"bbbb bbbb\");\n    executeAction(\"EditorDownWithSelection\");\n    executeAction(\"EditorPreviousWordWithSelection\");\n    checkResultByText(\"aaa <selection><caret>aaa<\/selection>\\n\" +\n                      \"bbbb <selection><caret>bb<\/selection>bb\");\n    executeAction(\"EditorNextWordWithSelection\");\n    checkResultByText(\"aaa aaa<caret>\\n\" +\n                      \"bbbb bb<selection>bb<caret><\/selection>\");\n  }","id":9760,"modified_method":"public void testSelectNextPrevWord() throws Exception {\n    init(\"aaa aaa<caret>\\n\" +\n         \"bbbb bbbb\");\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    executeAction(\"EditorPreviousWordWithSelection\");\n    checkResultByText(\"aaa <selection><caret>aaa<\/selection>\\n\" +\n                      \"bbbb <selection><caret>bb<\/selection>bb\");\n    executeAction(\"EditorNextWordWithSelection\");\n    checkResultByText(\"aaa aaa<caret>\\n\" +\n                      \"bbbb bb<selection>bb<caret><\/selection>\");\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testUpDown() throws Exception {\n    init(\"line1\\n\" +\n         \"li<caret>ne2\\n\" +\n         \"line3\");\n\n    executeAction(\"EditorDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"li<caret>ne3\");\n\n    executeAction(\"EditorDownWithSelection\"); // hitting document bottom\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"li<caret>ne3\");\n\n    executeAction(\"EditorUpWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorUpWithSelection\"); // hitting document top\n    checkResultByText(\"li<caret>ne1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorUpWithSelection\");\n    checkResultByText(\"li<caret>ne1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n  }","id":9761,"modified_method":"public void testUpDown() throws Exception {\n    init(\"line1\\n\" +\n         \"li<caret>ne2\\n\" +\n         \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"li<caret>ne3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION); // hitting document bottom\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"li<caret>ne3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION); // hitting document top\n    checkResultByText(\"li<caret>ne1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    checkResultByText(\"li<caret>ne1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testReverseBlockSelection() throws Exception {\n    init(\"a\");\n    mouse().clickAt(0, 4).dragTo(0, 3).release();\n    verifyCaretsAndSelections(0, 3, 3, 4);\n\n    executeAction(\"EditorRightWithSelection\");\n    verifyCaretsAndSelections(0, 4, 4, 4);\n  }","id":9762,"modified_method":"public void testReverseBlockSelection() throws Exception {\n    init(\"a\");\n    mouse().clickAt(0, 4).dragTo(0, 3).release();\n    verifyCaretsAndSelections(0, 3, 3, 4);\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    verifyCaretsAndSelections(0, 4, 4, 4);\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSelectionWithKeyboard() throws Exception {\n    init(\"line1\\n\" +\n         \"li<caret>ne2\\n\" +\n         \"line3\");\n\n    executeAction(\"EditorRightWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"li<selection>n<caret><\/selection>e3\");\n\n    executeAction(\"EditorLeftWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"li<caret>ne3\");\n\n    executeAction(\"EditorLeftWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"l<selection><caret>i<\/selection>ne2\\n\" +\n                      \"l<selection><caret>i<\/selection>ne3\");\n\n    executeAction(\"EditorUpWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"l<selection><caret>i<\/selection>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorUpWithSelection\");\n    checkResultByText(\"l<selection><caret>i<\/selection>ne1\\n\" +\n                      \"l<selection><caret>i<\/selection>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorRightWithSelection\");\n    checkResultByText(\"li<caret>ne1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorRightWithSelection\");\n    checkResultByText(\"li<selection>n<caret><\/selection>e1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"line3\");\n\n    executeAction(\"EditorLeftWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n  }","id":9763,"modified_method":"public void testSelectionWithKeyboard() throws Exception {\n    init(\"line1\\n\" +\n         \"li<caret>ne2\\n\" +\n         \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"li<selection>n<caret><\/selection>e3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_LEFT_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"li<caret>ne3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_LEFT_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"l<selection><caret>i<\/selection>ne2\\n\" +\n                      \"l<selection><caret>i<\/selection>ne3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"l<selection><caret>i<\/selection>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    checkResultByText(\"l<selection><caret>i<\/selection>ne1\\n\" +\n                      \"l<selection><caret>i<\/selection>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    checkResultByText(\"li<caret>ne1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_RIGHT_WITH_SELECTION);\n    checkResultByText(\"li<selection>n<caret><\/selection>e1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_DOWN_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<selection>n<caret><\/selection>e2\\n\" +\n                      \"line3\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_LEFT_WITH_SELECTION);\n    checkResultByText(\"line1\\n\" +\n                      \"li<caret>ne2\\n\" +\n                      \"line3\");\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testPageUpDown() throws Exception {\n    init(\"line1\\n\" +\n         \"line2\\n\" +\n         \"line3\\n\" +\n         \"line4\\n\" +\n         \"line<caret>5\\n\" +\n         \"line6\\n\" +\n         \"line7\");\n    setEditorVisibleSize(1000, 3);\n\n    executeAction(\"EditorPageUpWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line<caret>2\\n\" +\n                      \"line<caret>3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n\n    executeAction(\"EditorUpWithSelection\");\n    checkResultByText(\"line<caret>1\\n\" +\n                      \"line<caret>2\\n\" +\n                      \"line<caret>3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n\n    executeAction(\"EditorPageDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line2\\n\" +\n                      \"line3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n\n    executeAction(\"EditorPageDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line2\\n\" +\n                      \"line3\\n\" +\n                      \"line4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line<caret>6\\n\" +\n                      \"line<caret>7\");\n\n    executeAction(\"EditorPageUpWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line2\\n\" +\n                      \"line3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n  }","id":9764,"modified_method":"public void testPageUpDown() throws Exception {\n    init(\"line1\\n\" +\n         \"line2\\n\" +\n         \"line3\\n\" +\n         \"line4\\n\" +\n         \"line<caret>5\\n\" +\n         \"line6\\n\" +\n         \"line7\");\n    setEditorVisibleSize(1000, 3);\n\n    executeAction(\"EditorPageUpWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line<caret>2\\n\" +\n                      \"line<caret>3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_CARET_UP_WITH_SELECTION);\n    checkResultByText(\"line<caret>1\\n\" +\n                      \"line<caret>2\\n\" +\n                      \"line<caret>3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n\n    executeAction(\"EditorPageDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line2\\n\" +\n                      \"line3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n\n    executeAction(\"EditorPageDownWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line2\\n\" +\n                      \"line3\\n\" +\n                      \"line4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line<caret>6\\n\" +\n                      \"line<caret>7\");\n\n    executeAction(\"EditorPageUpWithSelection\");\n    checkResultByText(\"line1\\n\" +\n                      \"line2\\n\" +\n                      \"line3\\n\" +\n                      \"line<caret>4\\n\" +\n                      \"line<caret>5\\n\" +\n                      \"line6\\n\" +\n                      \"line7\");\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static DataContext createEditorContext(@NotNull Editor editor) {\n    Object e = editor;\n    Object hostEditor = editor instanceof EditorWindow ? ((EditorWindow)editor).getDelegate() : editor;\n    Map<String, Object> map = ContainerUtil.newHashMap(Pair.create(CommonDataKeys.HOST_EDITOR.getName(), hostEditor),\n                                                       Pair.createNonNull(CommonDataKeys.EDITOR.getName(), e));\n    DataContext parent = DataManager.getInstance().getDataContext(editor.getContentComponent());\n    return SimpleDataContext.getSimpleContext(map, parent);\n  }","id":9765,"modified_method":"@NotNull\n  private static DataContext createEditorContext(@NotNull Editor editor) {\n    Object hostEditor = editor instanceof EditorWindow ? ((EditorWindow)editor).getDelegate() : editor;\n    Map<String, Object> map = ContainerUtil.newHashMap(Pair.create(CommonDataKeys.HOST_EDITOR.getName(), hostEditor),\n                                                       Pair.createNonNull(CommonDataKeys.EDITOR.getName(), editor));\n    DataContext parent = DataManager.getInstance().getDataContext(editor.getContentComponent());\n    return SimpleDataContext.getSimpleContext(map, parent);\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void executeAction(@NotNull Editor editor, @NotNull String actionId, boolean assertActionIsEnabled) {\n    AnAction action = ActionManager.getInstance().getAction(actionId);\n    assertNotNull(action);\n    AnActionEvent event = AnActionEvent.createFromAnAction(action, null, \"\", createEditorContext(editor));\n    action.beforeActionPerformedUpdate(event);\n    if (!event.getPresentation().isEnabled()) {\n      assertFalse(\"Action \" + actionId + \" is disabled\", assertActionIsEnabled);\n      return;\n    }\n    action.actionPerformed(event);\n  }","id":9766,"modified_method":"public static void executeAction(@NotNull Editor editor, @NotNull String actionId, boolean assertActionIsEnabled) {\n    ActionManagerEx actionManager = ActionManagerEx.getInstanceEx();\n    AnAction action = actionManager.getAction(actionId);\n    assertNotNull(action);\n    AnActionEvent event = AnActionEvent.createFromAnAction(action, null, \"\", createEditorContext(editor));\n    action.beforeActionPerformedUpdate(event);\n    if (!event.getPresentation().isEnabled()) {\n      assertFalse(\"Action \" + actionId + \" is disabled\", assertActionIsEnabled);\n      return;\n    }\n    actionManager.fireBeforeActionPerformed(action, event.getDataContext(), event);\n    action.actionPerformed(event);\n    actionManager.fireAfterActionPerformed(action, event.getDataContext(), event);\n  }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doExecute(final Editor editor, @Nullable Caret caret, DataContext dataContext) {\n      if (!editor.getCaretModel().supportsMultipleCarets()) {\n        editor.getCaretModel().moveCaretRelatively(0, 1, true, editor.isColumnMode(), true);\n        return;\n      }\n      if (editor.isColumnMode()) {\n        EditorActionUtil.cloneOrRemoveCaret(editor, caret == null ? editor.getCaretModel().getPrimaryCaret() : caret, false);\n      }\n      else {\n        CaretAction caretAction = new CaretAction() {\n          @Override\n          public void perform(Caret caret) {\n            caret.moveCaretRelatively(0, 1, true, caret == editor.getCaretModel().getPrimaryCaret());\n          }\n        };\n        if (caret == null) {\n          editor.getCaretModel().runForEachCaret(caretAction);\n        }\n        else {\n          caretAction.perform(caret);\n        }\n      }\n    }","id":9767,"modified_method":"@Override\n    public void doExecute(final Editor editor, @Nullable Caret caret, DataContext dataContext) {\n      if (!editor.getCaretModel().supportsMultipleCarets()) {\n        editor.getCaretModel().moveCaretRelatively(0, 1, true, editor.isColumnMode(), true);\n        return;\n      }\n      if (editor.isColumnMode()) {\n        new CloneCaretActionHandler(false).execute(editor, caret, dataContext);\n      }\n      else {\n        CaretAction caretAction = new CaretAction() {\n          @Override\n          public void perform(Caret caret) {\n            caret.moveCaretRelatively(0, 1, true, caret == editor.getCaretModel().getPrimaryCaret());\n          }\n        };\n        if (caret == null) {\n          editor.getCaretModel().runForEachCaret(caretAction);\n        }\n        else {\n          caretAction.perform(caret);\n        }\n      }\n    }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doExecute(final Editor editor, @Nullable Caret caret, DataContext dataContext) {\n      if (!editor.getCaretModel().supportsMultipleCarets()) {\n        editor.getCaretModel().moveCaretRelatively(0, -1, true, editor.isColumnMode(), true);\n        return;\n      }\n      if (editor.isColumnMode()) {\n        EditorActionUtil.cloneOrRemoveCaret(editor, caret == null ? editor.getCaretModel().getPrimaryCaret() : caret, true);\n      }\n      else {\n        CaretAction caretAction = new CaretAction() {\n          @Override\n          public void perform(Caret caret) {\n            caret.moveCaretRelatively(0, -1, true, caret == editor.getCaretModel().getPrimaryCaret());\n          }\n        };\n        if (caret == null) {\n          editor.getCaretModel().runForEachCaret(caretAction);\n        }\n        else {\n          caretAction.perform(caret);\n        }\n      }\n    }","id":9768,"modified_method":"@Override\n    public void doExecute(final Editor editor, @Nullable Caret caret, DataContext dataContext) {\n      if (!editor.getCaretModel().supportsMultipleCarets()) {\n        editor.getCaretModel().moveCaretRelatively(0, -1, true, editor.isColumnMode(), true);\n        return;\n      }\n      if (editor.isColumnMode()) {\n        new CloneCaretActionHandler(true).execute(editor, caret, dataContext);\n      }\n      else {\n        CaretAction caretAction = new CaretAction() {\n          @Override\n          public void perform(Caret caret) {\n            caret.moveCaretRelatively(0, -1, true, caret == editor.getCaretModel().getPrimaryCaret());\n          }\n        };\n        if (caret == null) {\n          editor.getCaretModel().runForEachCaret(caretAction);\n        }\n        else {\n          caretAction.perform(caret);\n        }\n      }\n    }","commit_id":"985ac70a98ca2632db01a66482f772d91762a7cc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Translates an array of {@link EOGlobalID} to primary key values. Returns null if the given\n     * global IDs are not EOKeyValueGlobalIDs and the primary keys are not single values.\n     * @param globalIDs\n     */\n    public static NSArray<Object> primaryKeyValuesWithGlobalIDs(NSArray<EOGlobalID> globalIDs) {\n    \tNSMutableArray<Object> result = new NSMutableArray<Object>();\n    \tif(globalIDs.count() > 0) {\n    \t\tNSDictionary gidsByEntity = globalIDsGroupedByEntityName(globalIDs);\n    \t\tfor(Enumeration e = gidsByEntity.keyEnumerator(); e.hasMoreElements();) {\n    \t\t\tString entityName = (String) e.nextElement();\n    \t\t\tNSArray gidsForEntity = (NSArray) gidsByEntity.objectForKey(entityName);\n    \t\t\t\n    \t\t\tfor (Enumeration gids = gidsForEntity.objectEnumerator(); gids.hasMoreElements();) {\n    \t\t\t\tEOKeyGlobalID keyGID = (EOKeyGlobalID) gids.nextElement();\n    \t\t\t\tif(keyGID.keyCount() == 1) {\n    \t\t\t\t\tresult.addObject(keyGID.keyValues()[0]);\n    \t\t\t\t} else {\n    \t\t\t\t\tthrow new IllegalArgumentException(\"GID has more than one key: \" + keyGID);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn result;\n    }","id":9769,"modified_method":"/**\n     * Translates an array of {@link EOGlobalID} to primary key values. Returns null if the given\n     * global IDs are not EOKeyValueGlobalIDs and the primary keys are not single values.\n     * @param globalIDs\n     */\n    public static NSArray<Object> primaryKeyValuesWithGlobalIDs(NSArray<EOGlobalID> globalIDs) {\n    \tNSMutableArray<Object> result = new NSMutableArray<Object>(globalIDs.count());\n    \tNSDictionary<String, NSArray<EOGlobalID>> gidsByEntity = globalIDsGroupedByEntityName(globalIDs);\n    \tfor (String entityName : gidsByEntity.keySet()) {\n    \t\tNSArray<EOGlobalID> gidsForEntity = gidsByEntity.objectForKey(entityName);\n    \t\tfor (EOGlobalID gid : gidsForEntity) {\n    \t\t\tif (gid instanceof EOKeyGlobalID) {\n    \t\t\t\tEOKeyGlobalID keyGID = (EOKeyGlobalID) gid;\n    \t\t\t\tif (keyGID.keyCount() == 1) {\n    \t\t\t\t\tresult.addObject(keyGID.keyValues()[0]);\n    \t\t\t\t} else {\n    \t\t\t\t\tthrow new IllegalArgumentException(\"GID has more than one key: \" + keyGID);\n    \t\t\t\t}\n    \t\t\t} else {\n    \t\t\t\tthrow new IllegalArgumentException(\"GID is not an EOKeyGlobalID: \" + gid);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn result;\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fetches an array of objects defined by the globalIDs in a single fetch per entity.\n     * \n     * @param ec the editing context to fetch within\n     * @param globalIDs the global ids to fetch\n     * @param refreshesRefetchedObjects whether or not to refresh refetched objects\n     * @return the fetched EO's\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic static NSMutableArray fetchObjectsWithGlobalIDs(EOEditingContext ec, NSArray globalIDs, boolean refreshesRefetchedObjects) {\n    \tNSMutableArray<EOEnterpriseObject> result = new NSMutableArray<EOEnterpriseObject>();\n\t\tec.lock();\n\t\tec.rootObjectStore().lock();\n\t\ttry {\n\t    \tNSDictionary gidsByEntity = globalIDsGroupedByEntityName(globalIDs);\n\t    \tfor(Enumeration e = gidsByEntity.keyEnumerator(); e.hasMoreElements();) {\n\t    \t\tString entityName = (String) e.nextElement();\n\t    \t\tNSArray gidsForEntity = (NSArray) gidsByEntity.objectForKey(entityName);\n\t    \t\t\n\t    \t\tNSMutableArray<EOQualifier> qualifiers = new NSMutableArray<EOQualifier>();\n\t        \tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n\t    \t\tfor (Enumeration gids = gidsForEntity.objectEnumerator(); gids.hasMoreElements();) {\n\t    \t\t\tEOGlobalID g = (EOGlobalID) gids.nextElement();\n\t    \t\t\tboolean fetch = refreshesRefetchedObjects;\n\t    \t\t\tif (!fetch) {\n\t    \t\t\t\tEOEnterpriseObject eo;\n\t\t\t\t\t\teo = ec.objectForGlobalID(g);\n\t    \t\t\t\tif (eo != null && !EOFaultHandler.isFault(eo)) {\n\t    \t\t\t\t\tresult.addObject(eo);\n\t    \t\t\t\t}\n\t    \t\t\t\telse {\n\t    \t\t\t\t\tNSDictionary row;\n\t    \t\t\t        EODatabaseContext databaseContext = (EODatabaseContext) ((EOObjectStoreCoordinator) ec.rootObjectStore()).objectStoreForGlobalID(g);\n\t    \t\t\t        databaseContext.lock();\n\t    \t\t\t        try {\n\t\t    \t\t\t\t\trow = databaseContext.snapshotForGlobalID(g, ec.fetchTimestamp());\n\t    \t\t\t        }\n\t    \t\t\t        finally {\n\t    \t\t\t        \tdatabaseContext.unlock();\n\t    \t\t\t        }\n\t    \t\t\t\t\tif (row == null) {\n\t    \t\t\t\t\t\tfetch = true;\n\t    \t\t\t\t\t}\n\t    \t\t\t\t\telse {\n\t\t    \t\t\t\t\teo = ec.faultForGlobalID(g, ec);\n\t\t    \t\t\t\t\tresult.addObject(eo);\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tif (fetch) {\n\t    \t\t\t\tEOQualifier qualifier = entity.qualifierForPrimaryKey(entity.primaryKeyForGlobalID(g));\n\t    \t\t\t\tqualifiers.addObject(qualifier);\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tif (qualifiers.count() > 0) {\n\t\t    \t\tEOQualifier qualifier = qualifiers.count() > 1 ? new EOOrQualifier(qualifiers) : qualifiers.lastObject();\n\t\t    \t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(entityName, qualifier, null);\n\t\t    \t\tfetchSpec.setRefreshesRefetchedObjects(refreshesRefetchedObjects);\n\t\t    \t\tNSArray<EOEnterpriseObject> details = ec.objectsWithFetchSpecification(fetchSpec);\n\t\t    \t\tresult.addObjectsFromArray(details);\n\t    \t\t}\n\t    \t}\n\t\t}\n\t\tfinally {\n\t\t\tec.rootObjectStore().unlock();\n\t\t\tec.unlock();\n\t\t}\n    \treturn result;\n    }","id":9770,"modified_method":"/**\n     * Fetches an array of objects defined by the globalIDs in a single fetch per entity.\n     * \n     * @param ec the editing context to fetch within\n     * @param globalIDs the global ids to fetch\n     * @param refreshesRefetchedObjects whether or not to refresh refetched objects\n     * @return the fetched EO's\n     */\n\tpublic static NSMutableArray<EOEnterpriseObject> fetchObjectsWithGlobalIDs(EOEditingContext ec, NSArray<EOGlobalID> globalIDs, boolean refreshesRefetchedObjects) {\n    \tNSMutableArray<EOEnterpriseObject> result = new NSMutableArray<EOEnterpriseObject>();\n\t\tec.lock();\n\t\tec.rootObjectStore().lock();\n\t\ttry {\n\t    \tNSDictionary<String, NSArray<EOGlobalID>> gidsByEntity = globalIDsGroupedByEntityName(globalIDs);\n\t    \tfor(String entityName : gidsByEntity.keySet()) {\n\t    \t\tNSArray<EOGlobalID> gidsForEntity = gidsByEntity.objectForKey(entityName);\n\t    \t\t\n\t    \t\tNSMutableArray<EOQualifier> qualifiers = new NSMutableArray<EOQualifier>();\n\t        \tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n\t    \t\tfor (EOGlobalID g : gidsForEntity) {\n\t    \t\t\tboolean fetch = refreshesRefetchedObjects;\n\t    \t\t\tif (!fetch) {\n\t    \t\t\t\tEOEnterpriseObject eo;\n\t\t\t\t\t\teo = ec.objectForGlobalID(g);\n\t    \t\t\t\tif (eo != null && !EOFaultHandler.isFault(eo)) {\n\t    \t\t\t\t\tresult.addObject(eo);\n\t    \t\t\t\t}\n\t    \t\t\t\telse {\n\t    \t\t\t\t\tNSDictionary row;\n\t    \t\t\t        EODatabaseContext databaseContext = (EODatabaseContext) ((EOObjectStoreCoordinator) ec.rootObjectStore()).objectStoreForGlobalID(g);\n\t    \t\t\t        databaseContext.lock();\n\t    \t\t\t        try {\n\t\t    \t\t\t\t\trow = databaseContext.snapshotForGlobalID(g, ec.fetchTimestamp());\n\t    \t\t\t        }\n\t    \t\t\t        finally {\n\t    \t\t\t        \tdatabaseContext.unlock();\n\t    \t\t\t        }\n\t    \t\t\t\t\tif (row == null) {\n\t    \t\t\t\t\t\tfetch = true;\n\t    \t\t\t\t\t}\n\t    \t\t\t\t\telse {\n\t\t    \t\t\t\t\teo = ec.faultForGlobalID(g, ec);\n\t\t    \t\t\t\t\tresult.addObject(eo);\n\t    \t\t\t\t\t}\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tif (fetch) {\n\t    \t\t\t\tEOQualifier qualifier = entity.qualifierForPrimaryKey(entity.primaryKeyForGlobalID(g));\n\t    \t\t\t\tqualifiers.addObject(qualifier);\n\t    \t\t\t}\n\t    \t\t}\n\t    \t\tif (qualifiers.count() > 0) {\n\t\t    \t\tEOQualifier qualifier = qualifiers.count() > 1 ? new EOOrQualifier(qualifiers) : qualifiers.lastObject();\n\t\t    \t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(entityName, qualifier, null);\n\t\t    \t\tfetchSpec.setRefreshesRefetchedObjects(refreshesRefetchedObjects);\n\t\t    \t\tNSArray<EOEnterpriseObject> details = ec.objectsWithFetchSpecification(fetchSpec);\n\t\t    \t\tresult.addObjectsFromArray(details);\n\t    \t\t}\n\t    \t}\n\t\t}\n\t\tfinally {\n\t\t\tec.rootObjectStore().unlock();\n\t\t\tec.unlock();\n\t\t}\n    \treturn result;\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fetches an object defined by gid without refreshing refetched objects.\n     * \n     * @param ec the editing context to fetch within\n     * @param gid the global id to fetch\n     * @return the fetched EO\n     */\n    public static EOEnterpriseObject fetchObjectWithGlobalID(EOEditingContext ec, EOGlobalID gid) {\n    \tNSArray results = ERXEOGlobalIDUtilities.fetchObjectsWithGlobalIDs(ec, new NSArray<EOGlobalID>(gid));\n    \tEOEnterpriseObject eo;\n    \tif (results.count() > 0) {\n    \t\teo = (EOEnterpriseObject) results.objectAtIndex(0);\n    \t}\n    \telse {\n    \t\teo = null;\n    \t}\n    \treturn eo;\n    }","id":9771,"modified_method":"/**\n     * Fetches an object defined by gid without refreshing refetched objects.\n     * \n     * @param ec the editing context to fetch within\n     * @param gid the global id to fetch\n     * @return the fetched EO\n     */\n    public static EOEnterpriseObject fetchObjectWithGlobalID(EOEditingContext ec, EOGlobalID gid) {\n    \tNSArray<EOEnterpriseObject> results = ERXEOGlobalIDUtilities.fetchObjectsWithGlobalIDs(ec, new NSArray<EOGlobalID>(gid));\n    \tEOEnterpriseObject eo = null;\n    \tif (results.count() > 0) {\n    \t\teo = results.objectAtIndex(0);\n    \t}\n    \treturn eo;\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Translates an array of single-value raw primary values to EOGlobalIDs.\n     * @param entityName\n     * @param values\n     */\n    public static NSArray<EOGlobalID> globalIDsWithPrimaryKeyValues(String entityName, NSArray<Object> values) {\n        NSMutableArray<EOGlobalID> result = new NSMutableArray<EOGlobalID>();\n        if(values.count() > 0) {\n            for (Enumeration pks = values.objectEnumerator(); pks.hasMoreElements();) {\n                Object value = pks.nextElement();\n                EOKeyGlobalID gid = EOKeyGlobalID.globalIDWithEntityName(entityName, new Object[] {value});\n                result.addObject(gid);\n            }\n        }\n        return result;\n    }","id":9772,"modified_method":"/**\n     * Translates an array of single-value raw primary values to EOGlobalIDs.\n     * @param entityName\n     * @param values\n     */\n    public static NSArray<EOGlobalID> globalIDsWithPrimaryKeyValues(String entityName, NSArray<Object> values) {\n        NSMutableArray<EOGlobalID> result = new NSMutableArray<EOGlobalID>(values.count());\n        for (Object value : values) {\n            EOKeyGlobalID gid = EOKeyGlobalID.globalIDWithEntityName(entityName, new Object[] {value});\n            result.addObject(gid);\n        }\n        return result;\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fetches an array of objects defined by the globalIDs in a single fetch per entity without\n     * refreshing refetched objects.\n     * \n     * @param ec the editing context to fetch within\n     * @param globalIDs the global ids to fetch\n     * @return the fetched EO's\n     */\n    public static NSMutableArray fetchObjectsWithGlobalIDs(EOEditingContext ec, NSArray globalIDs) {\n    \treturn ERXEOGlobalIDUtilities.fetchObjectsWithGlobalIDs(ec, globalIDs, false);\n    }","id":9773,"modified_method":"/**\n     * Fetches an array of objects defined by the globalIDs in a single fetch per entity without\n     * refreshing refetched objects.\n     * \n     * @param ec the editing context to fetch within\n     * @param globalIDs the global ids to fetch\n     * @return the fetched EO's\n     */\n    public static NSMutableArray<EOEnterpriseObject> fetchObjectsWithGlobalIDs(EOEditingContext ec, NSArray<EOGlobalID> globalIDs) {\n    \treturn ERXEOGlobalIDUtilities.fetchObjectsWithGlobalIDs(ec, globalIDs, false);\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Groups an array of global IDs by their entity name.\n     * @param globalIDs\n     */\n    public static NSDictionary globalIDsGroupedByEntityName(NSArray globalIDs) {\n        return ERXArrayUtilities.arrayGroupedByKeyPath(globalIDs, \"entityName\");\n    }","id":9774,"modified_method":"/**\n     * Groups an array of global IDs by their entity name.\n     * @param globalIDs\n     */\n    public static NSDictionary<String, NSArray<EOGlobalID>> globalIDsGroupedByEntityName(NSArray<EOGlobalID> globalIDs) {\n        return ERXArrayUtilities.arrayGroupedByKeyPath(globalIDs, \"entityName\");\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fires all faults in the given global IDs on one batch. This is much more efficient than\n     * triggering the individual faults later on. The method should use only 1 fetch for all objects per entity.\n     * @param ec\n     * @param globalIDs\n     */\n    public static NSArray fireFaultsForGlobalIDs(EOEditingContext ec, NSArray globalIDs) {\n        return fireFaultsForGlobalIDs(ec, globalIDs, NSArray.EmptyArray);\n    }","id":9775,"modified_method":"/**\n     * Fires all faults in the given global IDs on one batch. This is much more efficient than\n     * triggering the individual faults later on. The method should use only 1 fetch for all objects per entity.\n     * @param ec\n     * @param globalIDs\n     */\n    public static NSArray<EOEnterpriseObject> fireFaultsForGlobalIDs(EOEditingContext ec, NSArray<EOGlobalID> globalIDs) {\n        return fireFaultsForGlobalIDs(ec, globalIDs, NSArray.EmptyArray);\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Fires all faults in the given global IDs on one batch together with their relationships.\n     * This is much more efficient than triggering the individual faults and relationships later on. \n     * The method should use only 1 fetch for all objects per entity\n     * and then one for each relationship per entity.\n     * @param ec\n     * @param globalIDs\n     * @param prefetchingKeypaths\n     */\n    public static NSArray fireFaultsForGlobalIDs(EOEditingContext ec, NSArray globalIDs, NSArray prefetchingKeypaths) {\n    \tNSMutableArray<EOEnterpriseObject> result = new NSMutableArray<EOEnterpriseObject>(globalIDs.count());\n    \tif(globalIDs.count() > 0) {\n    \t\tNSMutableArray<EOGlobalID> faults = new NSMutableArray<EOGlobalID>(globalIDs.count());\n    \t\tfor (Enumeration ids = globalIDs.objectEnumerator(); ids.hasMoreElements();) {\n    \t\t\tEOGlobalID gid = (EOGlobalID) ids.nextElement();\n    \t\t\tEOEnterpriseObject eo = ec.faultForGlobalID(gid, ec);\n    \t\t\tif(EOFaultHandler.isFault(eo)) {\n    \t\t\t\tfaults.addObject(gid);\n    \t\t\t} else {\n    \t\t\t\tresult.addObject(eo);\n    \t\t\t}\n    \t\t}\n    \t\tNSArray<EOEnterpriseObject> loadedObjects = fetchObjectsWithGlobalIDs(ec, faults);\n    \t\tresult.addObjectsFromArray(loadedObjects);\n    \t\tif(prefetchingKeypaths != null && prefetchingKeypaths.count() > 0) {\n    \t\t\tNSDictionary objectsByEntity = ERXArrayUtilities.arrayGroupedByKeyPath(result, \"entityName\");\n    \t\t\tfor(Enumeration e = objectsByEntity.keyEnumerator(); e.hasMoreElements();) {\n    \t\t\t\tString entityName = (String) e.nextElement();\n    \t\t\t\tNSArray objects = (NSArray) objectsByEntity.objectForKey(entityName);\n    \t\t\t\tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n    \t\t\t\tfor (Enumeration keyPaths = prefetchingKeypaths.objectEnumerator(); keyPaths.hasMoreElements();) {\n    \t\t\t\t\tString keypath = (String) keyPaths.nextElement();\n    \t\t\t\t\tEORelationship relationship = entity.relationshipNamed(keypath);\n    \t\t\t\t\tEODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n    \t\t\t\t\tdbc.lock();\n    \t\t\t\t\ttry {\n    \t\t\t\t\t\tdbc.batchFetchRelationship(relationship, objects, ec);\n    \t\t\t\t\t} finally {\n    \t\t\t\t\t\tdbc.unlock();\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn result;\n    }","id":9776,"modified_method":"/**\n     * Fires all faults in the given global IDs on one batch together with their relationships.\n     * This is much more efficient than triggering the individual faults and relationships later on. \n     * The method should use only 1 fetch for all objects per entity\n     * and then one for each relationship per entity.\n     * @param ec\n     * @param globalIDs\n     * @param prefetchingKeypaths\n     */\n    public static NSArray<EOEnterpriseObject> fireFaultsForGlobalIDs(EOEditingContext ec, NSArray<EOGlobalID> globalIDs, NSArray<String> prefetchingKeypaths) {\n    \tNSMutableArray<EOEnterpriseObject> result = new NSMutableArray<EOEnterpriseObject>(globalIDs.count());\n    \tNSMutableArray<EOGlobalID> faults = new NSMutableArray<EOGlobalID>(globalIDs.count());\n    \tfor (EOGlobalID gid : globalIDs) {\n    \t\tEOEnterpriseObject eo = ec.faultForGlobalID(gid, ec);\n    \t\tif (EOFaultHandler.isFault(eo)) {\n    \t\t\tfaults.addObject(gid);\n    \t\t} else {\n    \t\t\tresult.addObject(eo);\n    \t\t}\n    \t}\n    \tNSArray<EOEnterpriseObject> loadedObjects = fetchObjectsWithGlobalIDs(ec, faults);\n    \tresult.addObjectsFromArray(loadedObjects);\n    \tif (prefetchingKeypaths != null && prefetchingKeypaths.count() > 0) {\n    \t\tNSDictionary<String, NSArray<EOEnterpriseObject>> objectsByEntity = ERXArrayUtilities.arrayGroupedByKeyPath(result, \"entityName\");\n    \t\tfor (String entityName : objectsByEntity.keySet()) {\n    \t\t\tNSArray<EOEnterpriseObject> objects = objectsByEntity.objectForKey(entityName);\n    \t\t\tEOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n    \t\t\tfor (String keypath : prefetchingKeypaths) {\n    \t\t\t\tEORelationship relationship = entity.relationshipNamed(keypath);\n    \t\t\t\tEODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n    \t\t\t\tdbc.lock();\n    \t\t\t\ttry {\n    \t\t\t\t\tdbc.batchFetchRelationship(relationship, objects, ec);\n    \t\t\t\t} finally {\n    \t\t\t\t\tdbc.unlock();\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn result;\n    }","commit_id":"3c28c1967d7df553dedc764ccb042bd50f527680","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateDefaultAdapterService(context, model, null);\n\n        return false;\n    }","id":9777,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateDefaultAdapterService(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updateDefaultAdapterService(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final ModelNode adapterNameNode = EJB3SubsystemRootResourceDefinition.DEFAULT_RESOURCE_ADAPTER_NAME.resolveModelAttribute(context, model);\n        final String adapterName =  adapterNameNode.isDefined() ? adapterNameNode.asString() : null;\n\n        final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n        ServiceController<DefaultResourceAdapterService> existingDefaultRANameService = (ServiceController<DefaultResourceAdapterService>) serviceRegistry.getService(DefaultResourceAdapterService.DEFAULT_RA_NAME_SERVICE_NAME);\n        // if a default RA name service is already installed then just update the resource adapter name\n        if (existingDefaultRANameService != null) {\n            existingDefaultRANameService.getValue().setResourceAdapterName(adapterName);\n        } else if (adapterName != null) {\n            // create a new one and install\n            final DefaultResourceAdapterService defaultResourceAdapterService = new DefaultResourceAdapterService(adapterName);\n            ServiceController<?> newController =\n                context.getServiceTarget().addService(DefaultResourceAdapterService.DEFAULT_RA_NAME_SERVICE_NAME, defaultResourceAdapterService)\n                    .install();\n            if (newControllers != null) {\n                newControllers.add(newController);\n            }\n        }\n\n    }","id":9778,"modified_method":"void updateDefaultAdapterService(final OperationContext context, final ModelNode model) throws OperationFailedException {\n\n        final ModelNode adapterNameNode = EJB3SubsystemRootResourceDefinition.DEFAULT_RESOURCE_ADAPTER_NAME.resolveModelAttribute(context, model);\n        final String adapterName =  adapterNameNode.isDefined() ? adapterNameNode.asString() : null;\n\n        final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n        ServiceController<DefaultResourceAdapterService> existingDefaultRANameService = (ServiceController<DefaultResourceAdapterService>) serviceRegistry.getService(DefaultResourceAdapterService.DEFAULT_RA_NAME_SERVICE_NAME);\n        // if a default RA name service is already installed then just update the resource adapter name\n        if (existingDefaultRANameService != null) {\n            existingDefaultRANameService.getValue().setResourceAdapterName(adapterName);\n        } else if (adapterName != null) {\n            // create a new one and install\n            final DefaultResourceAdapterService defaultResourceAdapterService = new DefaultResourceAdapterService(adapterName);\n            ServiceController<?> newController =\n                context.getServiceTarget().addService(DefaultResourceAdapterService.DEFAULT_RA_NAME_SERVICE_NAME, defaultResourceAdapterService)\n                    .install();\n        }\n\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateDefaultAdapterService(context, restored, null);\n    }","id":9779,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateDefaultAdapterService(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> voidHandbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateOrCreateDefaultSingletonBeanAccessTimeoutService(context, model, null);\n\n        return false;\n    }","id":9780,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> voidHandbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateOrCreateDefaultSingletonBeanAccessTimeoutService(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updateOrCreateDefaultSingletonBeanAccessTimeoutService(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final long defaultAccessTimeout = EJB3SubsystemRootResourceDefinition.DEFAULT_SINGLETON_BEAN_ACCESS_TIMEOUT.resolveModelAttribute(context, model).asLong();\n        final ServiceName serviceName = DefaultAccessTimeoutService.SINGLETON_SERVICE_NAME;\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceController sc = registry.getService(serviceName);\n        if (sc != null) {\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = DefaultAccessTimeoutService.class.cast(sc.getValue());\n            defaultAccessTimeoutService.setDefaultAccessTimeout(defaultAccessTimeout);\n        } else {\n            // create and install the service\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = new DefaultAccessTimeoutService(defaultAccessTimeout);\n            final ServiceController<?> newService = context.getServiceTarget().addService(serviceName, defaultAccessTimeoutService)\n                    .install();\n            if (newControllers != null) {\n                newControllers.add(newService);\n            }\n        }\n    }","id":9781,"modified_method":"void updateOrCreateDefaultSingletonBeanAccessTimeoutService(final OperationContext context, final ModelNode model) throws OperationFailedException {\n        final long defaultAccessTimeout = EJB3SubsystemRootResourceDefinition.DEFAULT_SINGLETON_BEAN_ACCESS_TIMEOUT.resolveModelAttribute(context, model).asLong();\n        final ServiceName serviceName = DefaultAccessTimeoutService.SINGLETON_SERVICE_NAME;\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceController sc = registry.getService(serviceName);\n        if (sc != null) {\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = DefaultAccessTimeoutService.class.cast(sc.getValue());\n            defaultAccessTimeoutService.setDefaultAccessTimeout(defaultAccessTimeout);\n        } else {\n            // create and install the service\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = new DefaultAccessTimeoutService(defaultAccessTimeout);\n            final ServiceController<?> newService = context.getServiceTarget().addService(serviceName, defaultAccessTimeoutService)\n                    .install();\n        }\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateOrCreateDefaultSingletonBeanAccessTimeoutService(context, restored, null);\n    }","id":9782,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateOrCreateDefaultSingletonBeanAccessTimeoutService(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> voidHandbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateOrCreateDefaultStatefulBeanAccessTimeoutService(context, model, null);\n\n        return false;\n    }","id":9783,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> voidHandbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateOrCreateDefaultStatefulBeanAccessTimeoutService(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateOrCreateDefaultStatefulBeanAccessTimeoutService(context, restored, null);\n    }","id":9784,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateOrCreateDefaultStatefulBeanAccessTimeoutService(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updateOrCreateDefaultStatefulBeanAccessTimeoutService(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final long defaultAccessTimeout = EJB3SubsystemRootResourceDefinition.DEFAULT_STATEFUL_BEAN_ACCESS_TIMEOUT.resolveModelAttribute(context, model).asLong();\n        final ServiceName serviceName = DefaultAccessTimeoutService.STATEFUL_SERVICE_NAME;\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceController sc = registry.getService(serviceName);\n        if (sc != null) {\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = DefaultAccessTimeoutService.class.cast(sc.getValue());\n            defaultAccessTimeoutService.setDefaultAccessTimeout(defaultAccessTimeout);\n        } else {\n            // create and install the service\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = new DefaultAccessTimeoutService(defaultAccessTimeout);\n            final ServiceController<?> newService = context.getServiceTarget().addService(serviceName, defaultAccessTimeoutService)\n                    .install();\n            if (newControllers != null) {\n                newControllers.add(newService);\n            }\n        }\n    }","id":9785,"modified_method":"void updateOrCreateDefaultStatefulBeanAccessTimeoutService(final OperationContext context, final ModelNode model) throws OperationFailedException {\n        final long defaultAccessTimeout = EJB3SubsystemRootResourceDefinition.DEFAULT_STATEFUL_BEAN_ACCESS_TIMEOUT.resolveModelAttribute(context, model).asLong();\n        final ServiceName serviceName = DefaultAccessTimeoutService.STATEFUL_SERVICE_NAME;\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceController sc = registry.getService(serviceName);\n        if (sc != null) {\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = DefaultAccessTimeoutService.class.cast(sc.getValue());\n            defaultAccessTimeoutService.setDefaultAccessTimeout(defaultAccessTimeout);\n        } else {\n            // create and install the service\n            final DefaultAccessTimeoutService defaultAccessTimeoutService = new DefaultAccessTimeoutService(defaultAccessTimeout);\n            final ServiceController<?> newService = context.getServiceTarget().addService(serviceName, defaultAccessTimeoutService)\n                    .install();\n        }\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void addClusteringServices(final OperationContext context, final List<ServiceController<?>> newControllers, final boolean appclient) {\n        if (appclient) {\n            return;\n        }\n        ServiceTarget target = context.getServiceTarget();\n        newControllers.add(target.addService(RegistryCollectorService.SERVICE_NAME, new RegistryCollectorService<>()).setInitialMode(ServiceController.Mode.ON_DEMAND).install());\n        newControllers.add(target.addService(CacheFactoryBuilderRegistryService.SERVICE_NAME, new CacheFactoryBuilderRegistryService<>()).setInitialMode(ServiceController.Mode.ON_DEMAND).install());\n    }","id":9786,"modified_method":"private static void addClusteringServices(final OperationContext context, final boolean appclient) {\n        if (appclient) {\n            return;\n        }\n        ServiceTarget target = context.getServiceTarget();\n        target.addService(RegistryCollectorService.SERVICE_NAME, new RegistryCollectorService<>()).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        target.addService(CacheFactoryBuilderRegistryService.SERVICE_NAME, new CacheFactoryBuilderRegistryService<>()).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        //setup IIOP related stuff\n        //This goes here rather than in EJB3IIOPAdd as it affects the server when it is acting as an iiop client\n        //setup our dynamic stub factory\n        DelegatingStubFactoryFactory.setOverriddenDynamicFactory(new DynamicStubFactoryFactory());\n\n        //setup the substitution service, that translates between ejb proxies and IIOP stubs\n        final RemoteObjectSubstitutionService substitutionService = new RemoteObjectSubstitutionService();\n        newControllers.add(context.getServiceTarget().addService(RemoteObjectSubstitutionService.SERVICE_NAME, substitutionService)\n                .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, substitutionService.getDeploymentRepositoryInjectedValue())\n                .install());\n\n        RemoteObjectSubstitutionManager.setRemoteObjectSubstitution(substitutionService);\n\n        //setup ejb: namespace\n        EjbNamingContextSetup.setupEjbNamespace();\n        //TODO: this is a bit of a hack\n        InitialContext.addUrlContextFactory(\"ejb\", new ejbURLContextFactory());\n        final boolean appclient = context.getProcessType() == ProcessType.APPLICATION_CLIENT;\n\n        final ModelNode defaultDistinctName = EJB3SubsystemRootResourceDefinition.DEFAULT_DISTINCT_NAME.resolveModelAttribute(context, model);\n        final DefaultDistinctNameService defaultDistinctNameService = new DefaultDistinctNameService(defaultDistinctName.isDefined() ? defaultDistinctName.asString() : null);\n        newControllers.add(context.getServiceTarget().addService(DefaultDistinctNameService.SERVICE_NAME, defaultDistinctNameService).install());\n\n        // set the default security domain name in the deployment unit processor, configured at the subsytem level\n        final ModelNode defaultSecurityDomainModelNode = EJB3SubsystemRootResourceDefinition.DEFAULT_SECURITY_DOMAIN.resolveModelAttribute(context, model);\n        final String defaultSecurityDomain = defaultSecurityDomainModelNode.isDefined() ? defaultSecurityDomainModelNode.asString() : null;\n        this.defaultSecurityDomainDeploymentProcessor.setDefaultSecurityDomainName(defaultSecurityDomain);\n\n        // set the default security domain name in the deployment unit processor, configured at the subsytem level\n        final ModelNode defaultMissingMethod = EJB3SubsystemRootResourceDefinition.DEFAULT_MISSING_METHOD_PERMISSIONS_DENY_ACCESS.resolveModelAttribute(context, model);\n        final boolean defaultMissingMethodValue = defaultMissingMethod.asBoolean();\n        this.missingMethodPermissionsDenyAccessMergingProcessor.setDenyAccessByDefault(defaultMissingMethodValue);\n\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                //DUP's that are used even for app client deployments\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_REGISTER_JBOSS_ALL_EJB, new JBossAllXmlParserRegisteringProcessor<EjbJarMetaData>(EjbJarJBossAllParser.ROOT_ELEMENT, EjbJarJBossAllParser.ATTACHMENT_KEY, new EjbJarJBossAllParser()));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_DEFAULT_DISTINCT_NAME, new EjbDefaultDistinctNameProcessor(defaultDistinctNameService));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_CONTEXT_BINDING, new EjbContextJndiBindingProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_DEPLOYMENT, new EjbJarParsingDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CREATE_COMPONENT_DESCRIPTIONS, new AnnotatedEJBComponentDescriptionDeploymentUnitProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_SESSION_BEAN_DD, new SessionBeanXmlDescriptorProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_ANNOTATION_EJB, new EjbAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_INJECTION_ANNOTATION, new EjbResourceInjectionAnnotationProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_ENTITY_BEAN_CREATE_COMPONENT_DESCRIPTIONS, new EntityBeanComponentDescriptionFactory(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_ASSEMBLY_DESC_DD, new AssemblyDescriptorProcessor());\n\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_EJB, new EjbDependencyDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_HOME_MERGE, new HomeViewMergingProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_REF, new EjbRefProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_BUSINESS_VIEW_ANNOTATION, new BusinessViewAnnotationProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_ORB_BIND, new IIOPJndiBindingProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_JNDI_BINDINGS, new EjbJndiBindingsDeploymentUnitProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CLIENT_METADATA, new EJBClientDescriptorMetaDataProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DEFAULT_SECURITY_DOMAIN, EJB3SubsystemAdd.this.defaultSecurityDomainDeploymentProcessor);\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EE_COMPONENT_SUSPEND, new EJBComponentSuspendDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EE_COMPONENT_SUSPEND + 1, new EjbClientContextSetupProcessor()); //TODO: real phase numbers\n\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EJB_JACC_PROCESSING, new JaccEjbDeploymentProcessor());\n\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.CLEANUP, Phase.CLEANUP_EJB, new EjbCleanUpProcessor());\n\n                if (!appclient) {\n                    // add the metadata parser deployment processor\n\n                    // Process @DependsOn after the @Singletons have been registered.\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_TIMERSERVICE_BINDING, new TimerServiceJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_APPLICATION_EXCEPTION_ANNOTATION, new ApplicationExceptionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_DD_INTERCEPTORS, new InterceptorClassDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_SECURITY_ROLE_REF_DD, new SecurityRoleRefDDProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_PASSIVATION_ANNOTATION, new PassivationAnnotationParsingProcessor());\n\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_IMPLICIT_NO_INTERFACE_VIEW, new ImplicitLocalViewProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_APPLICATION_EXCEPTIONS, new ApplicationExceptionMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_INTERCEPTORS, new DeploymentDescriptorInterceptorBindingsProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_METHOD_RESOLUTION, new DeploymentDescriptorMethodProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_TRANSACTION_MANAGEMENT, new TransactionManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MANAGEMENT_MERGE, new ConcurrencyManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MERGE, new EjbConcurrencyMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_TX_ATTR_MERGE, new TransactionAttributeMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_RUN_AS_MERGE, new RunAsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_RESOURCE_ADAPTER_MERGE, new ResourceAdaptorMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DELIVERY_ACTIVE_MERGE, new DeliveryActiveMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_REMOVE_METHOD, new RemoveMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_STARTUP_MERGE, new StartupMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_DOMAIN, new SecurityDomainMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_MISSING_METHOD_PERMISSIONS, missingMethodPermissionsDenyAccessMergingProcessor);\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_ROLES, new DeclareRolesMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_METHOD_PERMISSIONS, new MethodPermissionsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_STATEFUL_TIMEOUT, new StatefulTimeoutMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SESSION_SYNCHRONIZATION, new SessionSynchronizationMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_INIT_METHOD, new InitMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SESSION_BEAN, new SessionBeanMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_PRINCIPAL_ROLE_MAPPING_MERGE, new SecurityRolesMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_LOCAL_HOME, new SessionBeanHomeProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CACHE, new CacheMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SLSB_POOL_NAME_MERGE, new StatelessSessionBeanPoolMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_MDB_POOL_NAME_MERGE, new MessageDrivenBeanPoolMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_ENTITY_POOL_NAME_MERGE, new EntityBeanPoolMergingProcessor());\n                    // Add the deployment unit processor responsible for processing the user application specific container interceptors configured in jboss-ejb3.xml\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_USER_APP_SPECIFIC_CONTAINER_INTERCEPTORS, new ContainerInterceptorBindingsDDProcessor());\n\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEPENDS_ON_ANNOTATION, new EjbDependsOnMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEPLOYMENT_REPOSITORY, new DeploymentRepositoryProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EJB_MANAGEMENT_RESOURCES, new EjbManagementDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_CACHE_DEPENDENCIES, new CacheDependenciesProcessor());\n                }\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        //todo maybe needs EJB3SubsystemRootResourceDefinition.DEFAULT_MDB_INSTANCE_POOL.resolveModelAttribute(context,model).isDefined()\n        if (model.hasDefined(DEFAULT_MDB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.MDB_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_SLSB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.SLSB_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_ENTITY_BEAN_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.ENTITY_BEAN_POOL.updatePoolService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_SFSB_CACHE)) {\n            EJB3SubsystemDefaultCacheWriteHandler.SFSB_CACHE.updateCacheService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_SFSB_PASSIVATION_DISABLED_CACHE)) {\n            EJB3SubsystemDefaultCacheWriteHandler.SFSB_PASSIVATION_DISABLED_CACHE.updateCacheService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_RESOURCE_ADAPTER_NAME)) {\n            DefaultResourceAdapterWriteHandler.INSTANCE.updateDefaultAdapterService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_SINGLETON_BEAN_ACCESS_TIMEOUT)) {\n            DefaultSingletonBeanAccessTimeoutWriteHandler.INSTANCE.updateOrCreateDefaultSingletonBeanAccessTimeoutService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_STATEFUL_BEAN_ACCESS_TIMEOUT)) {\n            DefaultStatefulBeanAccessTimeoutWriteHandler.INSTANCE.updateOrCreateDefaultStatefulBeanAccessTimeoutService(context, model, newControllers);\n        }\n\n        if (model.hasDefined(DEFAULT_ENTITY_BEAN_OPTIMISTIC_LOCKING)) {\n            EJB3SubsystemDefaultEntityBeanOptimisticLockingWriteHandler.INSTANCE.updateOptimisticLocking(context, model, newControllers);\n        }\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        newControllers.add(context.getServiceTarget().addService(DeploymentRepository.SERVICE_NAME, new DeploymentRepository()).install());\n\n        addRemoteInvocationServices(context, newControllers, model, appclient);\n        // add clustering service\n        addClusteringServices(context, newControllers, appclient);\n\n        // add user transaction access control service\n        final EJB3UserTransactionAccessControlService userTxAccessControlService = new EJB3UserTransactionAccessControlService();\n        newControllers.add(context.getServiceTarget().addService(EJB3UserTransactionAccessControlService.SERVICE_NAME, userTxAccessControlService)\n                .addDependency(UserTransactionAccessControlService.SERVICE_NAME, UserTransactionAccessControlService.class, userTxAccessControlService.getUserTransactionAccessControlServiceInjector())\n                .install());\n\n        if (!appclient) {\n            final EJBUtilities utilities = new EJBUtilities();\n            newControllers.add(serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n                    .addDependency(SimpleSecurityManagerService.SERVICE_NAME, ServerSecurityManager.class, utilities.getSecurityManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION, UserTransaction.class, utilities.getUserTransactionInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n\n\n            // create the POA Registry use by iiop\n            final POARegistry poaRegistry = new POARegistry();\n            newControllers.add(context.getServiceTarget().addService(POARegistry.SERVICE_NAME, poaRegistry)\n                    .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, poaRegistry.getRootPOA())\n                    .setInitialMode(ServiceController.Mode.PASSIVE)\n                    .addListener(verificationHandler)\n                    .install());\n\n            EnableStatisticsWriteHandler.INSTANCE.updateToRuntime(context, model);\n        }\n    }","id":9787,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, ModelNode operation, final ModelNode model) throws OperationFailedException {\n\n        //setup IIOP related stuff\n        //This goes here rather than in EJB3IIOPAdd as it affects the server when it is acting as an iiop client\n        //setup our dynamic stub factory\n        DelegatingStubFactoryFactory.setOverriddenDynamicFactory(new DynamicStubFactoryFactory());\n\n        //setup the substitution service, that translates between ejb proxies and IIOP stubs\n        final RemoteObjectSubstitutionService substitutionService = new RemoteObjectSubstitutionService();\n        context.getServiceTarget().addService(RemoteObjectSubstitutionService.SERVICE_NAME, substitutionService)\n                .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, substitutionService.getDeploymentRepositoryInjectedValue())\n                .install();\n\n        RemoteObjectSubstitutionManager.setRemoteObjectSubstitution(substitutionService);\n\n        //setup ejb: namespace\n        EjbNamingContextSetup.setupEjbNamespace();\n        //TODO: this is a bit of a hack\n        InitialContext.addUrlContextFactory(\"ejb\", new ejbURLContextFactory());\n        final boolean appclient = context.getProcessType() == ProcessType.APPLICATION_CLIENT;\n\n        final ModelNode defaultDistinctName = EJB3SubsystemRootResourceDefinition.DEFAULT_DISTINCT_NAME.resolveModelAttribute(context, model);\n        final DefaultDistinctNameService defaultDistinctNameService = new DefaultDistinctNameService(defaultDistinctName.isDefined() ? defaultDistinctName.asString() : null);\n        context.getServiceTarget().addService(DefaultDistinctNameService.SERVICE_NAME, defaultDistinctNameService).install();\n\n        // set the default security domain name in the deployment unit processor, configured at the subsytem level\n        final ModelNode defaultSecurityDomainModelNode = EJB3SubsystemRootResourceDefinition.DEFAULT_SECURITY_DOMAIN.resolveModelAttribute(context, model);\n        final String defaultSecurityDomain = defaultSecurityDomainModelNode.isDefined() ? defaultSecurityDomainModelNode.asString() : null;\n        this.defaultSecurityDomainDeploymentProcessor.setDefaultSecurityDomainName(defaultSecurityDomain);\n\n        // set the default security domain name in the deployment unit processor, configured at the subsytem level\n        final ModelNode defaultMissingMethod = EJB3SubsystemRootResourceDefinition.DEFAULT_MISSING_METHOD_PERMISSIONS_DENY_ACCESS.resolveModelAttribute(context, model);\n        final boolean defaultMissingMethodValue = defaultMissingMethod.asBoolean();\n        this.missingMethodPermissionsDenyAccessMergingProcessor.setDenyAccessByDefault(defaultMissingMethodValue);\n\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                //DUP's that are used even for app client deployments\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_REGISTER_JBOSS_ALL_EJB, new JBossAllXmlParserRegisteringProcessor<EjbJarMetaData>(EjbJarJBossAllParser.ROOT_ELEMENT, EjbJarJBossAllParser.ATTACHMENT_KEY, new EjbJarJBossAllParser()));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_DEFAULT_DISTINCT_NAME, new EjbDefaultDistinctNameProcessor(defaultDistinctNameService));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_CONTEXT_BINDING, new EjbContextJndiBindingProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_DEPLOYMENT, new EjbJarParsingDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CREATE_COMPONENT_DESCRIPTIONS, new AnnotatedEJBComponentDescriptionDeploymentUnitProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_SESSION_BEAN_DD, new SessionBeanXmlDescriptorProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_ANNOTATION_EJB, new EjbAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_INJECTION_ANNOTATION, new EjbResourceInjectionAnnotationProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_ENTITY_BEAN_CREATE_COMPONENT_DESCRIPTIONS, new EntityBeanComponentDescriptionFactory(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_ASSEMBLY_DESC_DD, new AssemblyDescriptorProcessor());\n\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_EJB, new EjbDependencyDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_HOME_MERGE, new HomeViewMergingProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_REF, new EjbRefProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_BUSINESS_VIEW_ANNOTATION, new BusinessViewAnnotationProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_ORB_BIND, new IIOPJndiBindingProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_JNDI_BINDINGS, new EjbJndiBindingsDeploymentUnitProcessor(appclient));\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CLIENT_METADATA, new EJBClientDescriptorMetaDataProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DEFAULT_SECURITY_DOMAIN, EJB3SubsystemAdd.this.defaultSecurityDomainDeploymentProcessor);\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EE_COMPONENT_SUSPEND, new EJBComponentSuspendDeploymentUnitProcessor());\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EE_COMPONENT_SUSPEND + 1, new EjbClientContextSetupProcessor()); //TODO: real phase numbers\n\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EJB_JACC_PROCESSING, new JaccEjbDeploymentProcessor());\n\n                processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.CLEANUP, Phase.CLEANUP_EJB, new EjbCleanUpProcessor());\n\n                if (!appclient) {\n                    // add the metadata parser deployment processor\n\n                    // Process @DependsOn after the @Singletons have been registered.\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_TIMERSERVICE_BINDING, new TimerServiceJndiBindingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_APPLICATION_EXCEPTION_ANNOTATION, new ApplicationExceptionAnnotationProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_DD_INTERCEPTORS, new InterceptorClassDeploymentDescriptorProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EJB_SECURITY_ROLE_REF_DD, new SecurityRoleRefDDProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_PASSIVATION_ANNOTATION, new PassivationAnnotationParsingProcessor());\n\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_IMPLICIT_NO_INTERFACE_VIEW, new ImplicitLocalViewProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_APPLICATION_EXCEPTIONS, new ApplicationExceptionMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_INTERCEPTORS, new DeploymentDescriptorInterceptorBindingsProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DD_METHOD_RESOLUTION, new DeploymentDescriptorMethodProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_TRANSACTION_MANAGEMENT, new TransactionManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MANAGEMENT_MERGE, new ConcurrencyManagementMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CONCURRENCY_MERGE, new EjbConcurrencyMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_TX_ATTR_MERGE, new TransactionAttributeMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_RUN_AS_MERGE, new RunAsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_RESOURCE_ADAPTER_MERGE, new ResourceAdaptorMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_DELIVERY_ACTIVE_MERGE, new DeliveryActiveMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_REMOVE_METHOD, new RemoveMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_STARTUP_MERGE, new StartupMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_DOMAIN, new SecurityDomainMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_MISSING_METHOD_PERMISSIONS, missingMethodPermissionsDenyAccessMergingProcessor);\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_ROLES, new DeclareRolesMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_METHOD_PERMISSIONS, new MethodPermissionsMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_STATEFUL_TIMEOUT, new StatefulTimeoutMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SESSION_SYNCHRONIZATION, new SessionSynchronizationMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_INIT_METHOD, new InitMethodMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SESSION_BEAN, new SessionBeanMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SECURITY_PRINCIPAL_ROLE_MAPPING_MERGE, new SecurityRolesMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_LOCAL_HOME, new SessionBeanHomeProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_CACHE, new CacheMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_SLSB_POOL_NAME_MERGE, new StatelessSessionBeanPoolMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_MDB_POOL_NAME_MERGE, new MessageDrivenBeanPoolMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_ENTITY_POOL_NAME_MERGE, new EntityBeanPoolMergingProcessor());\n                    // Add the deployment unit processor responsible for processing the user application specific container interceptors configured in jboss-ejb3.xml\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EJB_USER_APP_SPECIFIC_CONTAINER_INTERCEPTORS, new ContainerInterceptorBindingsDDProcessor());\n\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEPENDS_ON_ANNOTATION, new EjbDependsOnMergingProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEPLOYMENT_REPOSITORY, new DeploymentRepositoryProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EJB_MANAGEMENT_RESOURCES, new EjbManagementDeploymentUnitProcessor());\n                    processorTarget.addDeploymentProcessor(EJB3Extension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_CACHE_DEPENDENCIES, new CacheDependenciesProcessor());\n                }\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        //todo maybe needs EJB3SubsystemRootResourceDefinition.DEFAULT_MDB_INSTANCE_POOL.resolveModelAttribute(context,model).isDefined()\n        if (model.hasDefined(DEFAULT_MDB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.MDB_POOL.updatePoolService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_SLSB_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.SLSB_POOL.updatePoolService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_ENTITY_BEAN_INSTANCE_POOL)) {\n            EJB3SubsystemDefaultPoolWriteHandler.ENTITY_BEAN_POOL.updatePoolService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_SFSB_CACHE)) {\n            EJB3SubsystemDefaultCacheWriteHandler.SFSB_CACHE.updateCacheService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_SFSB_PASSIVATION_DISABLED_CACHE)) {\n            EJB3SubsystemDefaultCacheWriteHandler.SFSB_PASSIVATION_DISABLED_CACHE.updateCacheService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_RESOURCE_ADAPTER_NAME)) {\n            DefaultResourceAdapterWriteHandler.INSTANCE.updateDefaultAdapterService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_SINGLETON_BEAN_ACCESS_TIMEOUT)) {\n            DefaultSingletonBeanAccessTimeoutWriteHandler.INSTANCE.updateOrCreateDefaultSingletonBeanAccessTimeoutService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_STATEFUL_BEAN_ACCESS_TIMEOUT)) {\n            DefaultStatefulBeanAccessTimeoutWriteHandler.INSTANCE.updateOrCreateDefaultStatefulBeanAccessTimeoutService(context, model);\n        }\n\n        if (model.hasDefined(DEFAULT_ENTITY_BEAN_OPTIMISTIC_LOCKING)) {\n            EJB3SubsystemDefaultEntityBeanOptimisticLockingWriteHandler.INSTANCE.updateOptimisticLocking(context, model);\n        }\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        context.getServiceTarget().addService(DeploymentRepository.SERVICE_NAME, new DeploymentRepository()).install();\n\n        addRemoteInvocationServices(context, model, appclient);\n        // add clustering service\n        addClusteringServices(context, appclient);\n\n        // add user transaction access control service\n        final EJB3UserTransactionAccessControlService userTxAccessControlService = new EJB3UserTransactionAccessControlService();\n        context.getServiceTarget().addService(EJB3UserTransactionAccessControlService.SERVICE_NAME, userTxAccessControlService)\n                .addDependency(UserTransactionAccessControlService.SERVICE_NAME, UserTransactionAccessControlService.class, userTxAccessControlService.getUserTransactionAccessControlServiceInjector())\n                .install();\n\n        if (!appclient) {\n            final EJBUtilities utilities = new EJBUtilities();\n            serviceTarget.addService(EJBUtilities.SERVICE_NAME, utilities)\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class, utilities.getResourceAdapterRepositoryInjector())\n                    .addDependency(SimpleSecurityManagerService.SERVICE_NAME, ServerSecurityManager.class, utilities.getSecurityManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, TransactionManager.class, utilities.getTransactionManagerInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_SYNCHRONIZATION_REGISTRY, TransactionSynchronizationRegistry.class, utilities.getTransactionSynchronizationRegistryInjector())\n                    .addDependency(TxnServices.JBOSS_TXN_USER_TRANSACTION, UserTransaction.class, utilities.getUserTransactionInjector())\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install();\n\n\n            // create the POA Registry use by iiop\n            final POARegistry poaRegistry = new POARegistry();\n            context.getServiceTarget().addService(POARegistry.SERVICE_NAME, poaRegistry)\n                    .addDependency(CorbaPOAService.ROOT_SERVICE_NAME, POA.class, poaRegistry.getRootPOA())\n                    .setInitialMode(ServiceController.Mode.PASSIVE)\n                    .install();\n\n            EnableStatisticsWriteHandler.INSTANCE.updateToRuntime(context, model);\n        }\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void addRemoteInvocationServices(final OperationContext context, final List<ServiceController<?>> newControllers,\n                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // Add the tccl based client context selector\n        final TCCLEJBClientContextSelectorService tcclBasedClientContextSelector = new TCCLEJBClientContextSelectorService();\n        context.getServiceTarget().addService(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        // EJB client context selector will be locked on the server if it's not application client container\n        final boolean lockEJBClientContextSelector = appclient ? false : true;\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService(lockEJBClientContextSelector);\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLEJBClientContextSelectorService.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        // add the EJB remote tx recovery service\n        newControllers.add(\n                Services.addServerExecutorDependency(\n                    serviceTarget.addService(EJBTransactionRecoveryService.SERVICE_NAME, EJBTransactionRecoveryService.INSTANCE),\n                        EJBTransactionRecoveryService.INSTANCE.getExecutorInjector(), false)\n                .addDependency(ArjunaRecoveryManagerService.SERVICE_NAME, RecoveryManagerService.class, EJBTransactionRecoveryService.INSTANCE.getRecoveryManagerServiceInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, CoreEnvironmentBean.class, EJBTransactionRecoveryService.INSTANCE.getCoreEnvironmentBeanInjector())\n                .install());\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = WildFlySecurityManager.getPropertyPrivileged(ServerEnvironment.NODE_NAME, null);\n            // check if dependencies are available for for remote invocations (WFLY-3438)\n            final boolean installRemoteInvocationDependencies = isEJBRemoteConnectorInstalled(context) ;\n\n            //the default spec compliant EJB receiver\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            ServiceBuilder<LocalEjbReceiver> byValueServiceBuilder = serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byValueLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND);\n            if (installRemoteInvocationDependencies)\n                byValueServiceBuilder.addDependency(DependencyType.REQUIRED, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byValueLocalEjbReceiver.getEndpointInjector())\n                                     .addDependency(DependencyType.REQUIRED, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byValueLocalEjbReceiver.getRemoteConnectorServiceInjector());\n            newControllers.add(byValueServiceBuilder.install());\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            ServiceBuilder byReferenceServiceBuilder = serviceTarget.addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byReferenceLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND);\n            if (installRemoteInvocationDependencies)\n                byReferenceServiceBuilder.addDependency(DependencyType.REQUIRED, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byReferenceLocalEjbReceiver.getEndpointInjector())\n                                         .addDependency(DependencyType.REQUIRED, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byReferenceLocalEjbReceiver.getRemoteConnectorServiceInjector());\n            newControllers.add(byReferenceServiceBuilder.install());\n\n            // setup the default local ejb receiver service\n            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel, newControllers);\n            // add the default local ejb receiver to the client context\n            clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n        }\n        // install the default EJB client context service\n        newControllers.add(clientContextServiceBuilder.install());\n    }","id":9788,"modified_method":"private static void addRemoteInvocationServices(final OperationContext context,\n                                             final ModelNode ejbSubsystemModel, final boolean appclient) throws OperationFailedException {\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // Add the tccl based client context selector\n        final TCCLEJBClientContextSelectorService tcclBasedClientContextSelector = new TCCLEJBClientContextSelectorService();\n        context.getServiceTarget().addService(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                tcclBasedClientContextSelector).install();\n\n        // EJB client context selector will be locked on the server if it's not application client container\n        final boolean lockEJBClientContextSelector = appclient ? false : true;\n        //add the default EjbClientContext\n        //TODO: This should be managed\n        final DefaultEjbClientContextService clientContextService = new DefaultEjbClientContextService(lockEJBClientContextSelector);\n        final ServiceBuilder<EJBClientContext> clientContextServiceBuilder = context.getServiceTarget().addService(DefaultEjbClientContextService.DEFAULT_SERVICE_NAME,\n                clientContextService).addDependency(TCCLEJBClientContextSelectorService.TCCL_BASED_EJB_CLIENT_CONTEXT_SELECTOR_SERVICE_NAME,\n                TCCLEJBClientContextSelectorService.class, clientContextService.getTCCLBasedEJBClientContextSelectorInjector());\n\n        // add the EJB remote tx recovery service\n\n                Services.addServerExecutorDependency(\n                    serviceTarget.addService(EJBTransactionRecoveryService.SERVICE_NAME, EJBTransactionRecoveryService.INSTANCE),\n                        EJBTransactionRecoveryService.INSTANCE.getExecutorInjector(), false)\n                .addDependency(ArjunaRecoveryManagerService.SERVICE_NAME, RecoveryManagerService.class, EJBTransactionRecoveryService.INSTANCE.getRecoveryManagerServiceInjector())\n                .addDependency(TxnServices.JBOSS_TXN_CORE_ENVIRONMENT, CoreEnvironmentBean.class, EJBTransactionRecoveryService.INSTANCE.getCoreEnvironmentBeanInjector())\n                .install();\n\n        if (!appclient) {\n            // get the node name\n            final String nodeName = WildFlySecurityManager.getPropertyPrivileged(ServerEnvironment.NODE_NAME, null);\n            // check if dependencies are available for for remote invocations (WFLY-3438)\n            final boolean installRemoteInvocationDependencies = isEJBRemoteConnectorInstalled(context) ;\n\n            //the default spec compliant EJB receiver\n            final LocalEjbReceiver byValueLocalEjbReceiver = new LocalEjbReceiver(nodeName, false);\n            ServiceBuilder<LocalEjbReceiver> byValueServiceBuilder = serviceTarget.addService(LocalEjbReceiver.BY_VALUE_SERVICE_NAME, byValueLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byValueLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byValueLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND);\n            if (installRemoteInvocationDependencies)\n                byValueServiceBuilder.addDependency(DependencyType.REQUIRED, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byValueLocalEjbReceiver.getEndpointInjector())\n                                     .addDependency(DependencyType.REQUIRED, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byValueLocalEjbReceiver.getRemoteConnectorServiceInjector());\n            byValueServiceBuilder.install();\n\n            //the receiver for invocations that allow pass by reference\n            final LocalEjbReceiver byReferenceLocalEjbReceiver = new LocalEjbReceiver(nodeName, true);\n            ServiceBuilder byReferenceServiceBuilder = serviceTarget.addService(LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME, byReferenceLocalEjbReceiver)\n                    .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, byReferenceLocalEjbReceiver.getDeploymentRepository())\n                    .addDependency(RegistryCollectorService.SERVICE_NAME, RegistryCollector.class, byReferenceLocalEjbReceiver.getClusterRegistryCollectorInjector())\n                    .setInitialMode(ServiceController.Mode.ON_DEMAND);\n            if (installRemoteInvocationDependencies)\n                byReferenceServiceBuilder.addDependency(DependencyType.REQUIRED, RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, byReferenceLocalEjbReceiver.getEndpointInjector())\n                                         .addDependency(DependencyType.REQUIRED, EJBRemoteConnectorService.SERVICE_NAME, EJBRemoteConnectorService.class, byReferenceLocalEjbReceiver.getRemoteConnectorServiceInjector());\n           byReferenceServiceBuilder.install();\n\n            // setup the default local ejb receiver service\n            EJBRemoteInvocationPassByValueWriteHandler.INSTANCE.updateDefaultLocalEJBReceiverService(context, ejbSubsystemModel);\n            // add the default local ejb receiver to the client context\n            clientContextServiceBuilder.addDependency(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, LocalEjbReceiver.class, clientContextService.getDefaultLocalEJBReceiverInjector());\n        }\n        // install the default EJB client context service\n        clientContextServiceBuilder.install();\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updateCacheService(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode cacheName = this.attribute.resolveModelAttribute(context, model);\n\n        ServiceRegistry registry = context.getServiceRegistry(true);\n        if (registry.getService(this.serviceName) != null) {\n            context.removeService(this.serviceName);\n        }\n        if (cacheName.isDefined()) {\n            ServiceController<?> controller = this.installValueService(context, this.serviceName, CacheFactoryBuilder.class, CacheFactoryBuilderService.getServiceName(cacheName.asString()));\n            if (newControllers != null) {\n                newControllers.add(controller);\n            }\n        }\n    }","id":9789,"modified_method":"void updateCacheService(final OperationContext context, final ModelNode model) throws OperationFailedException {\n\n        ModelNode cacheName = this.attribute.resolveModelAttribute(context, model);\n\n        ServiceRegistry registry = context.getServiceRegistry(true);\n        if (registry.getService(this.serviceName) != null) {\n            context.removeService(this.serviceName);\n        }\n        if (cacheName.isDefined()) {\n            ServiceController<?> controller = this.installValueService(context, this.serviceName, CacheFactoryBuilder.class, CacheFactoryBuilderService.getServiceName(cacheName.asString()));\n        }\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateCacheService(context, model, null);\n\n        return false;\n    }","id":9790,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateCacheService(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateCacheService(context, restored, null);\n    }","id":9791,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateCacheService(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateOptimisticLocking(context, restored, null);\n    }","id":9792,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateOptimisticLocking(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updateOptimisticLocking(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final ModelNode enabled = EJB3SubsystemRootResourceDefinition.DEFAULT_ENTITY_BEAN_OPTIMISTIC_LOCKING.resolveModelAttribute(context, model);\n\n        final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n        ServiceController existingService = serviceRegistry.getService(SERVICE_NAME);\n        // if a default optimistic locking config is installed, remove it\n        if (existingService != null) {\n            context.removeService(existingService);\n        }\n\n        if (enabled.isDefined()) {\n            final Service<Boolean> newDefaultPoolConfigService = new ValueService<Boolean>(new ImmediateValue(enabled.asBoolean()));\n            ServiceController<?> newController =\n                context.getServiceTarget().addService(SERVICE_NAME, newDefaultPoolConfigService)\n                    .install();\n            if (newControllers != null) {\n                newControllers.add(newController);\n            }\n        }\n\n    }","id":9793,"modified_method":"void updateOptimisticLocking(final OperationContext context, final ModelNode model) throws OperationFailedException {\n\n        final ModelNode enabled = EJB3SubsystemRootResourceDefinition.DEFAULT_ENTITY_BEAN_OPTIMISTIC_LOCKING.resolveModelAttribute(context, model);\n\n        final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n        ServiceController existingService = serviceRegistry.getService(SERVICE_NAME);\n        // if a default optimistic locking config is installed, remove it\n        if (existingService != null) {\n            context.removeService(existingService);\n        }\n\n        if (enabled.isDefined()) {\n            final Service<Boolean> newDefaultPoolConfigService = new ValueService<Boolean>(new ImmediateValue(enabled.asBoolean()));\n            ServiceController<?> newController =\n                context.getServiceTarget().addService(SERVICE_NAME, newDefaultPoolConfigService)\n                    .install();\n        }\n\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateOptimisticLocking(context, model, null);\n\n        return false;\n    }","id":9794,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateOptimisticLocking(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updatePoolService(context, model, null);\n\n        return false;\n    }","id":9795,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updatePoolService(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updatePoolService(context, restored, null);\n    }","id":9796,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updatePoolService(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updatePoolService(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final ModelNode poolName = poolAttribute.resolveModelAttribute(context, model);\n\n        final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n        ServiceController existingDefaultPoolConfigService = serviceRegistry.getService(poolConfigServiceName);\n        // if a default MDB pool is already installed, then remove it first\n        if (existingDefaultPoolConfigService != null) {\n            context.removeService(existingDefaultPoolConfigService);\n        }\n\n        if (poolName.isDefined()) {\n            // now install default pool config service which points to an existing pool config service\n            final ValueInjectionService<PoolConfig> newDefaultPoolConfigService = new ValueInjectionService<PoolConfig>();\n            ServiceController<?> newController =\n                context.getServiceTarget().addService(poolConfigServiceName, newDefaultPoolConfigService)\n                    .addDependency(PoolConfigService.EJB_POOL_CONFIG_BASE_SERVICE_NAME.append(poolName.asString()),\n                            PoolConfig.class, newDefaultPoolConfigService.getInjector())\n                    .install();\n            if (newControllers != null) {\n                newControllers.add(newController);\n            }\n        }\n\n    }","id":9797,"modified_method":"void updatePoolService(final OperationContext context, final ModelNode model) throws OperationFailedException {\n\n        final ModelNode poolName = poolAttribute.resolveModelAttribute(context, model);\n\n        final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n        ServiceController existingDefaultPoolConfigService = serviceRegistry.getService(poolConfigServiceName);\n        // if a default MDB pool is already installed, then remove it first\n        if (existingDefaultPoolConfigService != null) {\n            context.removeService(existingDefaultPoolConfigService);\n        }\n\n        if (poolName.isDefined()) {\n            // now install default pool config service which points to an existing pool config service\n            final ValueInjectionService<PoolConfig> newDefaultPoolConfigService = new ValueInjectionService<PoolConfig>();\n            ServiceController<?> newController =\n                context.getServiceTarget().addService(poolConfigServiceName, newDefaultPoolConfigService)\n                    .addDependency(PoolConfigService.EJB_POOL_CONFIG_BASE_SERVICE_NAME.append(poolName.asString()),\n                            PoolConfig.class, newDefaultPoolConfigService.getInjector())\n                    .install();\n        }\n\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateDefaultLocalEJBReceiverService(context, model, null);\n\n        return false;\n    }","id":9798,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                           ModelNode resolvedValue, ModelNode currentValue, HandbackHolder<Void> handbackHolder) throws OperationFailedException {\n        final ModelNode model = context.readResource(PathAddress.EMPTY_ADDRESS).getModel();\n        updateDefaultLocalEJBReceiverService(context, model);\n\n        return false;\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"void updateDefaultLocalEJBReceiverService(final OperationContext context, final ModelNode model, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final ModelNode passByValueModel = this.attributeDefinition.resolveModelAttribute(context, model);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceName localEJBReceiverServiceName;\n        if (passByValueModel.isDefined()) {\n            final boolean passByValue = passByValueModel.asBoolean(true);\n            if (passByValue) {\n                localEJBReceiverServiceName = LocalEjbReceiver.BY_VALUE_SERVICE_NAME;\n            } else {\n                localEJBReceiverServiceName = LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME;\n            }\n        } else {\n            localEJBReceiverServiceName = LocalEjbReceiver.BY_VALUE_SERVICE_NAME;\n        }\n        // uninstall the existing default local EJB receiver service\n        final ServiceController<?> existingDefaultLocalEJBReceiverServiceController = registry.getService(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME);\n        if (existingDefaultLocalEJBReceiverServiceController != null) {\n            context.removeService(existingDefaultLocalEJBReceiverServiceController);\n        }\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // now install the new default local EJB receiver service which points to an existing Local EJB receiver service\n        final ValueInjectionService<LocalEjbReceiver> newDefaultLocalEJBReceiverService = new ValueInjectionService<LocalEjbReceiver>();\n        final ServiceBuilder defaultLocalEJBReceiverServiceBuilder = serviceTarget.addService(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, newDefaultLocalEJBReceiverService);\n        defaultLocalEJBReceiverServiceBuilder.addDependency(localEJBReceiverServiceName, LocalEjbReceiver.class, newDefaultLocalEJBReceiverService.getInjector());\n        // install the service\n        final ServiceController defaultLocalEJBReceiverServiceController = defaultLocalEJBReceiverServiceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(defaultLocalEJBReceiverServiceController);\n        }\n    }","id":9799,"modified_method":"void updateDefaultLocalEJBReceiverService(final OperationContext context, final ModelNode model) throws OperationFailedException {\n\n        final ModelNode passByValueModel = this.attributeDefinition.resolveModelAttribute(context, model);\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceName localEJBReceiverServiceName;\n        if (passByValueModel.isDefined()) {\n            final boolean passByValue = passByValueModel.asBoolean(true);\n            if (passByValue) {\n                localEJBReceiverServiceName = LocalEjbReceiver.BY_VALUE_SERVICE_NAME;\n            } else {\n                localEJBReceiverServiceName = LocalEjbReceiver.BY_REFERENCE_SERVICE_NAME;\n            }\n        } else {\n            localEJBReceiverServiceName = LocalEjbReceiver.BY_VALUE_SERVICE_NAME;\n        }\n        // uninstall the existing default local EJB receiver service\n        final ServiceController<?> existingDefaultLocalEJBReceiverServiceController = registry.getService(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME);\n        if (existingDefaultLocalEJBReceiverServiceController != null) {\n            context.removeService(existingDefaultLocalEJBReceiverServiceController);\n        }\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        // now install the new default local EJB receiver service which points to an existing Local EJB receiver service\n        final ValueInjectionService<LocalEjbReceiver> newDefaultLocalEJBReceiverService = new ValueInjectionService<LocalEjbReceiver>();\n        final ServiceBuilder defaultLocalEJBReceiverServiceBuilder = serviceTarget.addService(LocalEjbReceiver.DEFAULT_LOCAL_EJB_RECEIVER_SERVICE_NAME, newDefaultLocalEJBReceiverService);\n        defaultLocalEJBReceiverServiceBuilder.addDependency(localEJBReceiverServiceName, LocalEjbReceiver.class, newDefaultLocalEJBReceiverService.getInjector());\n        // install the service\n        final ServiceController defaultLocalEJBReceiverServiceController = defaultLocalEJBReceiverServiceBuilder.install();\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateDefaultLocalEJBReceiverService(context, restored, null);\n    }","id":9800,"modified_method":"@Override\n    protected void revertUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName,\n                                         ModelNode valueToRestore, ModelNode valueToRevert, Void handback) throws OperationFailedException {\n        final ModelNode restored = context.readResource(PathAddress.EMPTY_ADDRESS).getModel().clone();\n        restored.get(attributeName).set(valueToRestore);\n        updateDefaultLocalEJBReceiverService(context, restored);\n    }","commit_id":"b164f01a4241acdcd682017fc26b666061bbfeb4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        final DsDeploymentActivator dsDeploymentActivator = new DsDeploymentActivator();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                dsDeploymentActivator.activateProcessors(processorTarget);\n                processorTarget.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_DATASOURCE_RESOURCE_INJECTION, new DefaultDataSourceResourceReferenceProcessor());\n                processorTarget.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEFAULT_BINDINGS_DATASOURCE, new DefaultDataSourceBindingProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n\n        dsDeploymentActivator.activateServices(context.getServiceTarget());\n    }","id":9801,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        final DsDeploymentActivator dsDeploymentActivator = new DsDeploymentActivator();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                dsDeploymentActivator.activateProcessors(processorTarget);\n                processorTarget.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_DATASOURCE_RESOURCE_INJECTION, new DefaultDataSourceResourceReferenceProcessor());\n                processorTarget.addDeploymentProcessor(DataSourcesExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_DEFAULT_BINDINGS_DATASOURCE, new DefaultDataSourceBindingProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n    }","commit_id":"947c94c46a6daa3f81a6384795e76535069416ff","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceBuilder process(final ConnectorXmlDescriptor connectorXmlDescriptor, final IronJacamarXmlDescriptor ironJacamarXmlDescriptor, final ClassLoader classLoader, final ServiceTarget serviceTarget, final Map<ResourceRoot, Index> annotationIndexes, final ServiceName duServiceName) throws DeploymentUnitProcessingException {\n\n        Connector cmd = connectorXmlDescriptor != null ? connectorXmlDescriptor.getConnector() : null;\n        final Activation activation = ironJacamarXmlDescriptor != null ? ironJacamarXmlDescriptor.getIronJacamar() : null;\n\n        try {\n            // Annotation merging\n            Annotations annotator = new Annotations();\n\n            if (annotationIndexes != null && annotationIndexes.size() > 0) {\n                DEPLOYMENT_CONNECTOR_LOGGER.debugf(\"ParsedRaDeploymentProcessor: Found %d annotationIndexes\", annotationIndexes.size());\n                for (Index index : annotationIndexes.values()) {\n                    // Don't apply any empty indexes, as IronJacamar doesn't like that atm.\n                    if (index.getKnownClasses() != null && index.getKnownClasses().size() > 0) {\n                        AnnotationRepository repository = new JandexAnnotationRepositoryImpl(index, classLoader);\n                        cmd = annotator.merge(cmd, repository, classLoader);\n                        DEPLOYMENT_CONNECTOR_LOGGER.debugf(\"ParsedRaDeploymentProcessor: CMD=%s\", cmd);\n                    }\n                }\n            }\n            if (annotationIndexes == null || annotationIndexes.size() == 0)\n                DEPLOYMENT_CONNECTOR_LOGGER.debugf(\"ParsedRaDeploymentProcessor: Found 0 annotationIndexes\");\n\n            // FIXME: when the connector is null the Iron Jacamar data is ignored\n            if (cmd != null) {\n                // Validate metadata\n                cmd.validate();\n\n                // Merge metadata\n                cmd = (new Merger()).mergeConnectorWithCommonIronJacamar(activation, cmd);\n            }\n\n            final ServiceName deployerServiceName = ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(connectorXmlDescriptor.getDeploymentName());\n            final ResourceAdapterDeploymentService raDeploymentService = new ResourceAdapterDeploymentService(connectorXmlDescriptor, cmd, activation, classLoader, deployerServiceName, duServiceName);\n\n\n            // Create the service\n            ServiceBuilder builder =\n                    Services.addServerExecutorDependency(\n                        serviceTarget.addService(deployerServiceName, raDeploymentService),\n                        raDeploymentService.getExecutorServiceInjector(), false)\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, AS7MetadataRepository.class, raDeploymentService.getMdrInjector())\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class, raDeploymentService.getRaRepositoryInjector())\n                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class, raDeploymentService.getManagementRepositoryInjector())\n                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, ResourceAdapterDeploymentRegistry.class, raDeploymentService.getRegistryInjector())\n                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class, raDeploymentService.getTxIntegrationInjector())\n                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE, JcaSubsystemConfiguration.class, raDeploymentService.getConfigInjector())\n                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class, raDeploymentService.getSubjectFactoryInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, raDeploymentService.getCcmInjector())\n                    .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                    .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                    .addDependency(NamingService.SERVICE_NAME);\n\n            return builder;\n        } catch (Throwable t) {\n            throw new DeploymentUnitProcessingException(t);\n        }\n    }","id":9802,"modified_method":"public static ServiceBuilder process(final ConnectorXmlDescriptor connectorXmlDescriptor, final IronJacamarXmlDescriptor ironJacamarXmlDescriptor, final ClassLoader classLoader, final ServiceTarget serviceTarget, final Map<ResourceRoot, Index> annotationIndexes, final ServiceName duServiceName) throws DeploymentUnitProcessingException {\n\n        Connector cmd = connectorXmlDescriptor != null ? connectorXmlDescriptor.getConnector() : null;\n        final Activation activation = ironJacamarXmlDescriptor != null ? ironJacamarXmlDescriptor.getIronJacamar() : null;\n\n        try {\n            // Annotation merging\n            Annotations annotator = new Annotations();\n\n            if (annotationIndexes != null && annotationIndexes.size() > 0) {\n                DEPLOYMENT_CONNECTOR_LOGGER.debugf(\"ParsedRaDeploymentProcessor: Found %d annotationIndexes\", annotationIndexes.size());\n                for (Index index : annotationIndexes.values()) {\n                    // Don't apply any empty indexes, as IronJacamar doesn't like that atm.\n                    if (index.getKnownClasses() != null && index.getKnownClasses().size() > 0) {\n                        AnnotationRepository repository = new JandexAnnotationRepositoryImpl(index, classLoader);\n                        cmd = annotator.merge(cmd, repository, classLoader);\n                        DEPLOYMENT_CONNECTOR_LOGGER.debugf(\"ParsedRaDeploymentProcessor: CMD=%s\", cmd);\n                    }\n                }\n            }\n            if (annotationIndexes == null || annotationIndexes.size() == 0)\n                DEPLOYMENT_CONNECTOR_LOGGER.debugf(\"ParsedRaDeploymentProcessor: Found 0 annotationIndexes\");\n\n            // FIXME: when the connector is null the Iron Jacamar data is ignored\n            if (cmd != null) {\n                // Validate metadata\n                cmd.validate();\n\n                // Merge metadata\n                cmd = (new Merger()).mergeConnectorWithCommonIronJacamar(activation, cmd);\n            }\n\n            final ServiceName deployerServiceName = ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(connectorXmlDescriptor.getDeploymentName());\n            final ResourceAdapterDeploymentService raDeploymentService = new ResourceAdapterDeploymentService(connectorXmlDescriptor, cmd, activation, classLoader, deployerServiceName, duServiceName);\n\n\n            // Create the service\n            return Services.addServerExecutorDependency(\n                        serviceTarget.addService(deployerServiceName, raDeploymentService),\n                        raDeploymentService.getExecutorServiceInjector(), false)\n                    .addDependency(ConnectorServices.IRONJACAMAR_MDR, AS7MetadataRepository.class, raDeploymentService.getMdrInjector())\n                    .addDependency(ConnectorServices.RA_REPOSITORY_SERVICE, ResourceAdapterRepository.class, raDeploymentService.getRaRepositoryInjector())\n                    .addDependency(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, ManagementRepository.class, raDeploymentService.getManagementRepositoryInjector())\n                    .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, ResourceAdapterDeploymentRegistry.class, raDeploymentService.getRegistryInjector())\n                    .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class, raDeploymentService.getTxIntegrationInjector())\n                    .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE, JcaSubsystemConfiguration.class, raDeploymentService.getConfigInjector())\n                    .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class, raDeploymentService.getSubjectFactoryInjector())\n                    .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, raDeploymentService.getCcmInjector())\n                    .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                    .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                    .addDependency(NamingService.SERVICE_NAME);\n        } catch (Throwable t) {\n            throw new DeploymentUnitProcessingException(t);\n        }\n    }","commit_id":"947c94c46a6daa3f81a6384795e76535069416ff","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Collection<ServiceController<?>> activateServices(final ServiceTarget serviceTarget) {\n        final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n        // add resources here\n\n        controllers.add(serviceTarget.addService(ConnectorServices.IRONJACAMAR_MDR, mdrService)\n            .install());\n\n        RaRepositoryService raRepositoryService = new RaRepositoryService();\n        controllers.add(serviceTarget.addService(ConnectorServices.RA_REPOSITORY_SERVICE, raRepositoryService)\n            .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, raRepositoryService.getMdrInjector())\n                .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                        raRepositoryService.getTransactionIntegrationInjector())\n            .install());\n\n        ManagementRepositoryService managementRepositoryService = new ManagementRepositoryService();\n        controllers.add(serviceTarget.addService(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, managementRepositoryService)\n            .install());\n\n        ResourceAdapterDeploymentRegistryService registryService = new ResourceAdapterDeploymentRegistryService();\n        controllers.add(serviceTarget.addService(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, registryService)\n            .addDependency(ConnectorServices.IRONJACAMAR_MDR)\n            .install());\n\n        return controllers;\n    }","id":9803,"modified_method":"public void activateServices(final ServiceTarget serviceTarget) {\n        // add resources here\n\n        serviceTarget.addService(ConnectorServices.IRONJACAMAR_MDR, mdrService)\n            .install();\n\n        RaRepositoryService raRepositoryService = new RaRepositoryService();\n        serviceTarget.addService(ConnectorServices.RA_REPOSITORY_SERVICE, raRepositoryService)\n            .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, raRepositoryService.getMdrInjector())\n                .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                        raRepositoryService.getTransactionIntegrationInjector())\n            .install();\n\n        ManagementRepositoryService managementRepositoryService = new ManagementRepositoryService();\n        serviceTarget.addService(ConnectorServices.MANAGEMENT_REPOSITORY_SERVICE, managementRepositoryService)\n            .install();\n\n        ResourceAdapterDeploymentRegistryService registryService = new ResourceAdapterDeploymentRegistryService();\n        serviceTarget.addService(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE, registryService)\n            .addDependency(ConnectorServices.IRONJACAMAR_MDR)\n            .install();\n    }","commit_id":"947c94c46a6daa3f81a6384795e76535069416ff","url":"https://github.com/wildfly/wildfly"},{"original_method":"public URI resolve(Object context, URI classpathUri) {\n        if (context instanceof Plugin) {\n            context = ((Plugin) context).getBundle();\n        }\n        if (!(context instanceof Bundle)) {\n            throw new IllegalArgumentException(\"Context must implement Bundle\");\n        }\n        Bundle bundle = (Bundle) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                return findResourceInBundle(bundle, classpathUri);\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","id":9804,"modified_method":"public URI resolve(Object context, URI classpathUri) {\n        if (context instanceof Plugin) {\n            context = ((Plugin) context).getBundle();\n        }\n        if (!(context instanceof Bundle)) {\n            throw new IllegalArgumentException(\"Context must implement Bundle\");\n        }\n        Bundle bundle = (Bundle) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                URI result = findResourceInBundle(bundle, classpathUri);\n \t\t\t\tif (classpathUri.fragment() != null)\n \t\t\t\t\tresult = result.appendFragment(classpathUri.fragment());\n \t\t\t\treturn result;\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","commit_id":"11da29d114831f7645e47ecaae236ffb5e9d529c","url":"https://github.com/eclipse/xtext"},{"original_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\tAbstractNode abstractNode = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(parseResult.getRootNode(),\n\t\t\t\t\t\tregion.getOffset());\n\t\t\t\tfinal Region location = new Region(abstractNode.getOffset(), abstractNode.getLength());\n\t\t\t\tList<EObject> crossLinkedEObjects = findCrossLinkedEObject(abstractNode);\n\t\t\t\tif (crossLinkedEObjects.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tList<IHyperlink> links = new ArrayList<IHyperlink>();\n\t\t\t\tfor (EObject crossReffed : crossLinkedEObjects) {\n\t\t\t\t\tfinal String label = labelProvider.getText(crossReffed);\n\t\t\t\t\tfinal URI uri = EcoreUtil.getURI(crossReffed);\n\t\t\t\t\tlinks.add(new IHyperlink() {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tpublic IRegion getHyperlinkRegion() {\n\t\t\t\t\t\t\t\treturn location;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getHyperlinkText() {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getTypeLabel() {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic void open() {\n\t\t\t\t\t\t\t\tnew OpenDeclarationAction(uri, locationProvider).run();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn links.toArray(new IHyperlink[links.size()]);\n\t\t\t}\n\t\t});\n\t}","id":9805,"modified_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\tAbstractNode abstractNode = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(parseResult.getRootNode(),\n\t\t\t\t\t\tregion.getOffset());\n\t\t\t\tfinal Region location = new Region(abstractNode.getOffset(), abstractNode.getLength());\n\t\t\t\tList<EObject> crossLinkedEObjects = findCrossLinkedEObject(abstractNode);\n\t\t\t\tif (crossLinkedEObjects.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tList<IHyperlink> links = new ArrayList<IHyperlink>();\n\t\t\t\tfor (EObject crossReffed : crossLinkedEObjects) {\n\t\t\t\t\tfinal String label = labelProvider.getText(crossReffed);\n\t\t\t\t\tfinal URI uri = EcoreUtil.getURI(crossReffed);\n\t\t\t\t\tfinal URI normalized = crossReffed.eResource().getResourceSet().getURIConverter().normalize(uri);\n\t\t\t\t\tlinks.add(new IHyperlink() {\n\n\t\t\t\t\t\t\tpublic IRegion getHyperlinkRegion() {\n\t\t\t\t\t\t\t\treturn location;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getHyperlinkText() {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getTypeLabel() {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic void open() {\n\t\t\t\t\t\t\t\tnew OpenDeclarationAction(normalized, locationProvider).run();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn links.toArray(new IHyperlink[links.size()]);\n\t\t\t}\n\t\t});\n\t}","commit_id":"11da29d114831f7645e47ecaae236ffb5e9d529c","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<EObject> findCrossLinkedEObject(AbstractNode node) {\n\t\tif (node instanceof LeafNode && node.getGrammarElement() instanceof CrossReference) {\n\t\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(node);\n\t\t\tEReference eReference = GrammarUtil.getReference((CrossReference) node.getGrammarElement(),\n\t\t\t\t\tsemanticModel.eClass());\n\t\t\ttry {\n\t\t\t\treturn linkingService.getLinkedObjects(semanticModel, eReference, node);\n\t\t\t} catch (IllegalNodeException ex) {\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","id":9806,"modified_method":"protected List<EObject> findCrossLinkedEObject(AbstractNode node) {\n\t\tAbstractNode nodeToCheck = node;\n\t\twhile(nodeToCheck != null && !(nodeToCheck.getGrammarElement() instanceof Assignment)) {\n\t\t\tif (nodeToCheck.getGrammarElement() instanceof CrossReference) {\n\t\t\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(nodeToCheck);\n\t\t\t\tEReference eReference = GrammarUtil.getReference((CrossReference) nodeToCheck.getGrammarElement(),\n\t\t\t\t\t\tsemanticModel.eClass());\n\t\t\t\ttry {\n\t\t\t\t\treturn linkingService.getLinkedObjects(semanticModel, eReference, nodeToCheck);\n\t\t\t\t} catch (IllegalNodeException ex) {\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeToCheck = nodeToCheck.getParent();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","commit_id":"11da29d114831f7645e47ecaae236ffb5e9d529c","url":"https://github.com/eclipse/xtext"},{"original_method":"public URI resolve(Object context, URI classpathUri) {\n\t\tif (!(context instanceof IJavaElement)) {\n\t\t\tthrow new IllegalArgumentException(\"Context must implement IResource\");\n\t\t}\n\t\tjavaElement = (IJavaElement) context;\n\t\ttry {\n\t\t\tif (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n\t\t\t\tIJavaProject javaProject = javaElement.getJavaProject();\n\t\t\t\treturn findResourceInWorkspace(javaProject, classpathUri);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception exc) {\n\t\t\tthrow new ClasspathUriResolutionException(exc);\n\t\t}\n\t\treturn classpathUri;\n\t}","id":9807,"modified_method":"public URI resolve(Object context, URI classpathUri) {\n\t\tif (!(context instanceof IJavaElement)) {\n\t\t\tthrow new IllegalArgumentException(\"Context must implement IResource\");\n\t\t}\n\t\tjavaElement = (IJavaElement) context;\n\t\ttry {\n\t\t\tif (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n\t\t\t\tIJavaProject javaProject = javaElement.getJavaProject();\n\t\t\t\tURI result = findResourceInWorkspace(javaProject, classpathUri);\n\t\t\t\tif (classpathUri.fragment() != null)\n\t\t\t\t\tresult = result.appendFragment(classpathUri.fragment());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception exc) {\n\t\t\tthrow new ClasspathUriResolutionException(exc);\n\t\t}\n\t\treturn classpathUri;\n\t}","commit_id":"11da29d114831f7645e47ecaae236ffb5e9d529c","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public URI resolve(Object context, URI classpathUri) {\n        if(!(context instanceof IResource)) {\n            throw new IllegalArgumentException(\"Context must implement IResource\");\n        }\n        IResource resource = (IResource) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                IProject project = resource.getProject();\n                IJavaProject javaProject = JavaCore.create(project);\n                return findResourceInWorkspace(javaProject, classpathUri);\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","id":9808,"modified_method":"@Override\n    public URI resolve(Object context, URI classpathUri) {\n        if(!(context instanceof IResource)) {\n            throw new IllegalArgumentException(\"Context must implement IResource\");\n        }\n        IResource resource = (IResource) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                IProject project = resource.getProject();\n                IJavaProject javaProject = JavaCore.create(project);\n                URI result = findResourceInWorkspace(javaProject, classpathUri);\n \t\t\t\tif (classpathUri.fragment() != null)\n \t\t\t\t\tresult = result.appendFragment(classpathUri.fragment());\n \t\t\t\treturn result;\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","commit_id":"11da29d114831f7645e47ecaae236ffb5e9d529c","url":"https://github.com/eclipse/xtext"},{"original_method":"public URI resolve(Object context, URI classpathUri) {\n        if (context instanceof Plugin) {\n            context = ((Plugin) context).getBundle();\n        }\n        if (!(context instanceof Bundle)) {\n            throw new IllegalArgumentException(\"Context must implement Bundle\");\n        }\n        Bundle bundle = (Bundle) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                return findResourceInBundle(bundle, classpathUri);\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","id":9809,"modified_method":"public URI resolve(Object context, URI classpathUri) {\n        if (context instanceof Plugin) {\n            context = ((Plugin) context).getBundle();\n        }\n        if (!(context instanceof Bundle)) {\n            throw new IllegalArgumentException(\"Context must implement Bundle\");\n        }\n        Bundle bundle = (Bundle) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                URI result = findResourceInBundle(bundle, classpathUri);\n \t\t\t\tif (classpathUri.fragment() != null)\n \t\t\t\t\tresult = result.appendFragment(classpathUri.fragment());\n \t\t\t\treturn result;\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","commit_id":"6686f44aa671906f3354705f150a9dc0405a93b1","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<EObject> findCrossLinkedEObject(AbstractNode node) {\n\t\tif (node instanceof LeafNode && node.getGrammarElement() instanceof CrossReference) {\n\t\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(node);\n\t\t\tEReference eReference = GrammarUtil.getReference((CrossReference) node.getGrammarElement(),\n\t\t\t\t\tsemanticModel.eClass());\n\t\t\ttry {\n\t\t\t\treturn linkingService.getLinkedObjects(semanticModel, eReference, node);\n\t\t\t} catch (IllegalNodeException ex) {\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","id":9810,"modified_method":"protected List<EObject> findCrossLinkedEObject(AbstractNode node) {\n\t\tAbstractNode nodeToCheck = node;\n\t\twhile(nodeToCheck != null && !(nodeToCheck.getGrammarElement() instanceof Assignment)) {\n\t\t\tif (nodeToCheck.getGrammarElement() instanceof CrossReference) {\n\t\t\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(nodeToCheck);\n\t\t\t\tEReference eReference = GrammarUtil.getReference((CrossReference) nodeToCheck.getGrammarElement(),\n\t\t\t\t\t\tsemanticModel.eClass());\n\t\t\t\ttry {\n\t\t\t\t\treturn linkingService.getLinkedObjects(semanticModel, eReference, nodeToCheck);\n\t\t\t\t} catch (IllegalNodeException ex) {\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeToCheck = nodeToCheck.getParent();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","commit_id":"6686f44aa671906f3354705f150a9dc0405a93b1","url":"https://github.com/eclipse/xtext"},{"original_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\tAbstractNode abstractNode = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(parseResult.getRootNode(),\n\t\t\t\t\t\tregion.getOffset());\n\t\t\t\tfinal Region location = new Region(abstractNode.getOffset(), abstractNode.getLength());\n\t\t\t\tList<EObject> crossLinkedEObjects = findCrossLinkedEObject(abstractNode);\n\t\t\t\tif (crossLinkedEObjects.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tList<IHyperlink> links = new ArrayList<IHyperlink>();\n\t\t\t\tfor (EObject crossReffed : crossLinkedEObjects) {\n\t\t\t\t\tfinal String label = labelProvider.getText(crossReffed);\n\t\t\t\t\tfinal URI uri = EcoreUtil.getURI(crossReffed);\n\t\t\t\t\tlinks.add(new IHyperlink() {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tpublic IRegion getHyperlinkRegion() {\n\t\t\t\t\t\t\t\treturn location;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getHyperlinkText() {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getTypeLabel() {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic void open() {\n\t\t\t\t\t\t\t\tnew OpenDeclarationAction(uri, locationProvider).run();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn links.toArray(new IHyperlink[links.size()]);\n\t\t\t}\n\t\t});\n\t}","id":9811,"modified_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\tAbstractNode abstractNode = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(parseResult.getRootNode(),\n\t\t\t\t\t\tregion.getOffset());\n\t\t\t\tfinal Region location = new Region(abstractNode.getOffset(), abstractNode.getLength());\n\t\t\t\tList<EObject> crossLinkedEObjects = findCrossLinkedEObject(abstractNode);\n\t\t\t\tif (crossLinkedEObjects.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tList<IHyperlink> links = new ArrayList<IHyperlink>();\n\t\t\t\tfor (EObject crossReffed : crossLinkedEObjects) {\n\t\t\t\t\tfinal String label = labelProvider.getText(crossReffed);\n\t\t\t\t\tfinal URI uri = EcoreUtil.getURI(crossReffed);\n\t\t\t\t\tfinal URI normalized = crossReffed.eResource().getResourceSet().getURIConverter().normalize(uri);\n\t\t\t\t\tlinks.add(new IHyperlink() {\n\n\t\t\t\t\t\t\tpublic IRegion getHyperlinkRegion() {\n\t\t\t\t\t\t\t\treturn location;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getHyperlinkText() {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getTypeLabel() {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic void open() {\n\t\t\t\t\t\t\t\tnew OpenDeclarationAction(normalized, locationProvider).run();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn links.toArray(new IHyperlink[links.size()]);\n\t\t\t}\n\t\t});\n\t}","commit_id":"6686f44aa671906f3354705f150a9dc0405a93b1","url":"https://github.com/eclipse/xtext"},{"original_method":"public URI resolve(Object context, URI classpathUri) {\n\t\tif (!(context instanceof IJavaElement)) {\n\t\t\tthrow new IllegalArgumentException(\"Context must implement IResource\");\n\t\t}\n\t\tjavaElement = (IJavaElement) context;\n\t\ttry {\n\t\t\tif (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n\t\t\t\tIJavaProject javaProject = javaElement.getJavaProject();\n\t\t\t\treturn findResourceInWorkspace(javaProject, classpathUri);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception exc) {\n\t\t\tthrow new ClasspathUriResolutionException(exc);\n\t\t}\n\t\treturn classpathUri;\n\t}","id":9812,"modified_method":"public URI resolve(Object context, URI classpathUri) {\n\t\tif (!(context instanceof IJavaElement)) {\n\t\t\tthrow new IllegalArgumentException(\"Context must implement IResource\");\n\t\t}\n\t\tjavaElement = (IJavaElement) context;\n\t\ttry {\n\t\t\tif (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n\t\t\t\tIJavaProject javaProject = javaElement.getJavaProject();\n\t\t\t\tURI result = findResourceInWorkspace(javaProject, classpathUri);\n\t\t\t\tif (classpathUri.fragment() != null)\n\t\t\t\t\tresult = result.appendFragment(classpathUri.fragment());\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception exc) {\n\t\t\tthrow new ClasspathUriResolutionException(exc);\n\t\t}\n\t\treturn classpathUri;\n\t}","commit_id":"6686f44aa671906f3354705f150a9dc0405a93b1","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public URI resolve(Object context, URI classpathUri) {\n        if(!(context instanceof IResource)) {\n            throw new IllegalArgumentException(\"Context must implement IResource\");\n        }\n        IResource resource = (IResource) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                IProject project = resource.getProject();\n                IJavaProject javaProject = JavaCore.create(project);\n                return findResourceInWorkspace(javaProject, classpathUri);\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","id":9813,"modified_method":"@Override\n    public URI resolve(Object context, URI classpathUri) {\n        if(!(context instanceof IResource)) {\n            throw new IllegalArgumentException(\"Context must implement IResource\");\n        }\n        IResource resource = (IResource) context;\n        try {\n            if (ClasspathUriUtil.isClasspathUri(classpathUri)) {\n                IProject project = resource.getProject();\n                IJavaProject javaProject = JavaCore.create(project);\n                URI result = findResourceInWorkspace(javaProject, classpathUri);\n \t\t\t\tif (classpathUri.fragment() != null)\n \t\t\t\t\tresult = result.appendFragment(classpathUri.fragment());\n \t\t\t\treturn result;\n            }\n        } catch (Exception exc) {\n            throw new ClasspathUriResolutionException(exc);\n        }\n        return classpathUri;\n    }","commit_id":"6686f44aa671906f3354705f150a9dc0405a93b1","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public DependencyPair executePlanFragment(final long planFragmentId, int outputDepId,\n            int inputDepIdfinal, ParameterSet parameterSet, final long txnId,\n            final long lastCommittedTxnId, final long undoToken) throws EEException\n    {\n        VoltTable vt;\n        // TestExecutionSite uses this mock site.\n        //\n        // For interesting things to happen, the first parameter used by the fuzz\n        // tester must be a string indicating what transaction outcome should be simulated\n        // by the mock EE.\n        //\n        // rollback_all : every execution site should throw an exception for rollback\n        // rollback_random : each execution site should randomly decide to rollback\n        //                   This includes the final aggregating execution site call.\n\n        if (parameterSet.toArray().length > 0 && parameterSet.toArray()[0] instanceof String)\n        {\n            String txn_outcome = (String)parameterSet.toArray()[0];\n\n            if (txn_outcome.equals(\"rollback_all\"))\n            {\n                //System.out.println(\"Throwing MASSIVE exception for rollback.\");\n                throwExceptionForError(ERRORCODE_ERROR);\n            }\n            else if (txn_outcome.equals(\"rollback_random\"))\n            {\n                Random rand = new Random(System.currentTimeMillis());\n                if (rand.nextInt(100) < 20)\n                {\n                    //System.out.println(\"Throwing exception for rollback\");\n                    //if (planFragmentId == 1)\n                    //{\n                    //    System.out.println(\"ROLLING BACK COORDINATOR\");\n                    //}\n                    throwExceptionForError(ERRORCODE_ERROR);\n                }\n            }\n        }\n        vt = new VoltTable(new VoltTable.ColumnInfo[] {\n                  new VoltTable.ColumnInfo(\"foo\", VoltType.INTEGER)\n        });\n        vt.addRow(new Integer(1));\n        return new DependencyPair(outputDepId, vt);\n    }","id":9814,"modified_method":"@Override\n    public DependencyPair executePlanFragment(final long planFragmentId, int outputDepId,\n            int inputDepIdfinal, ParameterSet parameterSet, final long txnId,\n            final long lastCommittedTxnId, final long undoToken) throws EEException\n    {\n        VoltTable vt;\n        // TestExecutionSite uses this mock site.\n        //\n        // For interesting things to happen, the fuzz tester must provide a parameter\n        // named 'txn_outcome'.  If this parameter is present, then the transaction\n        // result will be determined by the parameter which follows 'txn_outcome'\n        // according to:\n        //\n        // commit : every execution site will complete this transaction normally\n        // rollback_all : every execution site should throw an exception for rollback\n        // rollback_random : each execution site should randomly decide to rollback\n        //                   This includes the final aggregating execution site call.\n\n        ArrayList<Object> params = new ArrayList<Object>();\n\n        for (Object param : parameterSet.toArray())\n        {\n            params.add(param);\n        }\n\n        int txn_outcome_index = params.indexOf(\"txn_outcome\");\n        if (txn_outcome_index != -1)\n        {\n            String txn_outcome = (String)params.get(txn_outcome_index + 1);\n\n            if (txn_outcome.equals(\"rollback_all\"))\n            {\n                //System.out.println(\"Throwing MASSIVE exception for rollback.\");\n                throwExceptionForError(ERRORCODE_ERROR);\n            }\n            else if (txn_outcome.equals(\"rollback_random\"))\n            {\n                Random rand = new Random(System.currentTimeMillis());\n                if (rand.nextInt(100) < 20)\n                {\n                    //System.out.println(\"Throwing exception for rollback\");\n                    //if (planFragmentId == 1)\n                    //{\n                    //    System.out.println(\"ROLLING BACK COORDINATOR\");\n                    //}\n                    throwExceptionForError(ERRORCODE_ERROR);\n                }\n            }\n        }\n        vt = new VoltTable(new VoltTable.ColumnInfo[] {\n                  new VoltTable.ColumnInfo(\"foo\", VoltType.INTEGER)\n        });\n        vt.addRow(new Integer(1));\n        return new DependencyPair(outputDepId, vt);\n    }","commit_id":"effc5ee41c557ab212b06b124374c9a40dda96c9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a multiple partition transaction\n     */\n    private void createMPInitiation(\n            boolean rollback,\n            boolean rollback_all,\n            boolean readOnly,\n            long txn_id,\n            long safe_txn_id,\n            int initiator_id,\n            int partition_id,\n            int coordinator_id,\n            List<Integer> participants)\n    {\n        final StoredProcedureInvocation spi = new StoredProcedureInvocation();\n        if (!rollback) {\n            spi.setProcName(\"org.voltdb.TestExecutionSite$MockMPVoltProcedure\");\n            spi.setParams(\"commit\", new Integer(partition_id));\n        }\n        else {\n            if (rollback_all)\n            {\n                spi.setProcName(\"org.voltdb.TestExecutionSite$MockMPVoltProcedureRollbackParticipant\");\n                spi.setParams(\"rollback_all\", new Integer(partition_id));\n            }\n            else\n            {\n                spi.setProcName(\"org.voltdb.TestExecutionSite$MockMPVoltProcedureRollbackParticipant\");\n                spi.setParams(\"rollback_random\", new Integer(partition_id));\n            }\n        }\n\n        System.out.println(\"Creating MP proc, TXN ID: \" + txn_id + \", participants: \" + participants.toString());\n\n        final InitiateTaskMessage itm =\n            new InitiateTaskMessage(initiator_id,\n                                    coordinator_id,\n                                    txn_id,\n                                    readOnly,\n                                    false,         // multi-partition\n                                    spi,\n                                    safe_txn_id);  // last safe txnid\n\n        m_mboxes[coordinator_id].deliver(itm);\n\n        for (int participant : participants) {\n            final MultiPartitionParticipantMessage mppm =\n                new MultiPartitionParticipantMessage\n                (initiator_id, coordinator_id, txn_id, readOnly);\n            m_mboxes[participant].deliver(mppm);\n        }\n    }","id":9815,"modified_method":"/**\n     * Create a multiple partition transaction\n     */\n    private void createMPInitiation(\n            boolean rollback,\n            boolean rollback_all,\n            boolean readOnly,\n            int numberOfBatches,\n            long txn_id,\n            long safe_txn_id,\n            int initiator_id,\n            int partition_id,\n            int coordinator_id,\n            List<Integer> participants)\n    {\n        ArrayList<Object> params = new ArrayList<Object>();\n        params.add(\"number_of_batches\");\n        params.add(new Integer(numberOfBatches));\n        final StoredProcedureInvocation spi = new StoredProcedureInvocation();\n        if (!rollback) {\n            spi.setProcName(\"org.voltdb.TestExecutionSite$MockMPVoltProcedure\");\n            params.add(\"txn_outcome\");\n            params.add(\"commit\");\n            params.add(new Integer(partition_id));\n            spi.setParams(params.toArray());\n        }\n        else {\n            if (rollback_all)\n            {\n                spi.setProcName(\"org.voltdb.TestExecutionSite$MockMPVoltProcedureRollbackParticipant\");\n                params.add(\"txn_outcome\");\n                params.add(\"rollback_all\");\n                params.add(new Integer(partition_id));\n                spi.setParams(params.toArray());\n            }\n            else\n            {\n                spi.setProcName(\"org.voltdb.TestExecutionSite$MockMPVoltProcedureRollbackParticipant\");\n                params.add(\"txn_outcome\");\n                params.add(\"rollback_random\");\n                params.add(new Integer(partition_id));\n                spi.setParams(params.toArray());\n            }\n        }\n\n        System.out.println(\"Creating MP proc, TXN ID: \" + txn_id + \", participants: \" + participants.toString());\n\n        final InitiateTaskMessage itm =\n            new InitiateTaskMessage(initiator_id,\n                                    coordinator_id,\n                                    txn_id,\n                                    readOnly,\n                                    false,         // multi-partition\n                                    spi,\n                                    safe_txn_id);  // last safe txnid\n\n        m_mboxes[coordinator_id].deliver(itm);\n\n        for (int participant : participants) {\n            final MultiPartitionParticipantMessage mppm =\n                new MultiPartitionParticipantMessage\n                (initiator_id, coordinator_id, txn_id, readOnly);\n            m_mboxes[participant].deliver(mppm);\n        }\n    }","commit_id":"effc5ee41c557ab212b06b124374c9a40dda96c9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void queueTransactions(long firstTxnId, int totalTransactions, Random rand)\n    {\n        for (int i=0; i <= totalTransactions; ++i) {\n            boolean rollback = rand.nextBoolean();\n            // Disabling this as it results in too many all-failures currently\n            //boolean rollback_all = rand.nextBoolean();\n            boolean rollback_all = false;\n            boolean readOnly = rand.nextBoolean();\n            long txnid = i + firstTxnId;\n            long safe_txnid = txnid;\n            int initiator = selectRandomInitiator(rand);\n            int partition = i % PARTITION_COUNT;\n\n            int wheelOfDestiny = rand.nextInt(100);\n            if (i == totalTransactions) {\n                System.out.println(\"Queueing final heartbeat.\");\n                int offset = 0;\n                for (int inid : getInitiatorIds()) {\n                    createHeartBeat(txnid + offset, txnid + offset, inid);\n                    ++offset;\n                }\n            }\n            else if (wheelOfDestiny < 50) {\n                createSPInitiation(readOnly, txnid, safe_txnid, initiator, partition);\n            }\n            else if (wheelOfDestiny < 70) {\n                List<Integer> participants = new ArrayList<Integer>();\n                int coordinator = selectCoordinatorAndParticipants(rand, partition, initiator, participants);\n                createMPInitiation(rollback, rollback_all, readOnly, txnid,\n                                   safe_txnid, initiator, partition,\n                                   coordinator, participants);\n            }\n            else {\n                createHeartBeat(txnid, safe_txnid, initiator);\n            }\n        }\n    }","id":9816,"modified_method":"private void queueTransactions(long firstTxnId, int totalTransactions, Random rand)\n    {\n        for (int i=0; i <= totalTransactions; ++i) {\n            boolean rollback = rand.nextBoolean();\n            // Disabling this as it results in too many all-failures currently\n            //boolean rollback_all = rand.nextBoolean();\n            boolean rollback_all = false;\n            boolean readOnly = rand.nextBoolean();\n            long txnid = i + firstTxnId;\n            long safe_txnid = txnid;\n            int initiator = selectRandomInitiator(rand);\n            int partition = i % PARTITION_COUNT;\n\n            int wheelOfDestiny = rand.nextInt(100);\n            if (i == totalTransactions) {\n                System.out.println(\"Queueing final heartbeat.\");\n                int offset = 0;\n                for (int inid : getInitiatorIds()) {\n                    createHeartBeat(txnid + offset, txnid + offset, inid);\n                    ++offset;\n                }\n            }\n            else if (wheelOfDestiny < 50) {\n                createSPInitiation(readOnly, txnid, safe_txnid, initiator, partition);\n            }\n            else if (wheelOfDestiny < 70) {\n                int numberOfBatches = rand.nextInt(4) + 1;\n                List<Integer> participants = new ArrayList<Integer>();\n                int coordinator = selectCoordinatorAndParticipants(rand, partition, initiator, participants);\n                createMPInitiation(rollback, rollback_all, readOnly, numberOfBatches,\n                                   txnid, safe_txnid, initiator, partition,\n                                   coordinator, participants);\n            }\n            else {\n                createHeartBeat(txnid, safe_txnid, initiator);\n            }\n        }\n    }","commit_id":"effc5ee41c557ab212b06b124374c9a40dda96c9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        ClientResponseImpl call(TransactionState txnState, Object... paramList)\n        {\n            try {\n                ByteBuffer paramBuf = createParametersBuffer(paramList);\n\n                // Build the aggregator and the distributed tasks.\n                int localTask_startDep = txnState.getNextDependencyId() | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n                int localTask_outputDep = txnState.getNextDependencyId();\n\n                FragmentTaskMessage localTask =\n                    new FragmentTaskMessage(txnState.initiatorSiteId,\n                                            txnState.coordinatorSiteId,\n                                            txnState.txnId,\n                                            txnState.isReadOnly,\n                                            new long[] {1},\n                                            new int[] {localTask_outputDep},\n                                            new ByteBuffer[] {paramBuf},\n                                            finalTask());\n\n                localTask.addInputDepId(0, localTask_startDep);\n\n                FragmentTaskMessage distributedTask =\n                    new FragmentTaskMessage(txnState.initiatorSiteId,\n                                            txnState.coordinatorSiteId,\n                                            txnState.txnId,\n                                            txnState.isReadOnly,\n                                            new long[] {0},\n                                            new int[] {localTask_startDep},\n                                            new ByteBuffer[] {paramBuf},\n                                            finalTask());\n\n                txnState.createLocalFragmentWork(localTask, nonTransactional() && finalTask());\n                txnState.createAllParticipatingFragmentWork(distributedTask);\n                txnState.setupProcedureResume(finalTask(), new int[] {localTask_outputDep});\n\n                final Map<Integer, List<VoltTable>> resultDeps =\n                    m_site.recursableRun(txnState);\n                assertTrue(resultDeps != null);\n\n                ++m_called;\n\n                // simulate node failure: no commit sent to participant\n                if (simulate_coordinator_dies_during_commit) {\n                    // turn off the fault for the next time through\n                    simulate_coordinator_dies_during_commit = false;\n                    throw new ThreadDeath();\n                }\n\n                // Return a made up table (no EE interaction anyway.. )\n                VoltTable[] vta = new VoltTable[1];\n                vta[0] = new VoltTable(new VoltTable.ColumnInfo(\"\", VoltType.INTEGER));\n                vta[0].addRow(new Integer(1));\n\n                return new ClientResponseImpl(ClientResponse.SUCCESS, vta, null);\n            }\n            // VoltProcedure's call method converts invocation exceptions\n            // to this error path. Do the same here.\n            catch (SerializableException ex) {\n                byte status = 0;\n                return new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                              status, \"\", new VoltTable[0],\n                                              \"Intentional fuzz failure.\", ex);\n            }\n        }","id":9817,"modified_method":"@Override\n        ClientResponseImpl call(TransactionState txnState, Object... paramList)\n        {\n            try {\n                parseParamList(paramList);\n                ByteBuffer paramBuf = createParametersBuffer(paramList);\n\n                for (int i = 0; i < numberOfBatches(); i++)\n                {\n                    boolean finalTask = (i == numberOfBatches() - 1);\n\n                    // XXX-IZZY these will turn into arrays for multi-statement batches\n                    // Build the aggregator and the distributed tasks.\n                    int localTask_startDep = txnState.getNextDependencyId() | DtxnConstants.MULTIPARTITION_DEPENDENCY;\n                    int localTask_outputDep = txnState.getNextDependencyId();\n\n                    FragmentTaskMessage localTask =\n                        new FragmentTaskMessage(txnState.initiatorSiteId,\n                                                txnState.coordinatorSiteId,\n                                                txnState.txnId,\n                                                txnState.isReadOnly,\n                                                new long[] {1},\n                                                new int[] {localTask_outputDep},\n                                                new ByteBuffer[] {paramBuf},\n                                                false);\n\n                    localTask.addInputDepId(0, localTask_startDep);\n\n                    FragmentTaskMessage distributedTask =\n                        new FragmentTaskMessage(txnState.initiatorSiteId,\n                                                txnState.coordinatorSiteId,\n                                                txnState.txnId,\n                                                txnState.isReadOnly,\n                                                new long[] {0},\n                                                new int[] {localTask_startDep},\n                                                new ByteBuffer[] {paramBuf},\n                                                finalTask);\n\n                    txnState.createLocalFragmentWork(localTask, nonTransactional() && finalTask);\n                    txnState.createAllParticipatingFragmentWork(distributedTask);\n                    txnState.setupProcedureResume(finalTask, new int[] {localTask_outputDep});\n\n                    final Map<Integer, List<VoltTable>> resultDeps =\n                        m_site.recursableRun(txnState);\n                    assertTrue(resultDeps != null);\n                }\n\n                ++m_called;\n\n                // simulate node failure: no commit sent to participant\n                if (simulate_coordinator_dies_during_commit) {\n                    // turn off the fault for the next time through\n                    simulate_coordinator_dies_during_commit = false;\n                    throw new ThreadDeath();\n                }\n\n                // Return a made up table (no EE interaction anyway.. )\n                VoltTable[] vta = new VoltTable[1];\n                vta[0] = new VoltTable(new VoltTable.ColumnInfo(\"\", VoltType.INTEGER));\n                vta[0].addRow(new Integer(1));\n\n                return new ClientResponseImpl(ClientResponse.SUCCESS, vta, null);\n            }\n            // VoltProcedure's call method converts invocation exceptions\n            // to this error path. Do the same here.\n            catch (SerializableException ex) {\n                byte status = 0;\n                return new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                                              status, \"\", new VoltTable[0],\n                                              \"Intentional fuzz failure.\", ex);\n            }\n        }","commit_id":"effc5ee41c557ab212b06b124374c9a40dda96c9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"boolean nonTransactional()      { return false; }","id":9818,"modified_method":"boolean nonTransactional()      { return true; }","commit_id":"effc5ee41c557ab212b06b124374c9a40dda96c9","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Load the initial data, then run the simulation.\n     *\n     * @param args This program uses no command line arguments.\n     */\n    public static void main(String[] args) {\n        System.out.println(\"***************************************\");\n        System.out.println(\"* Welcome to Bobbi's Awesome Auctions *\");\n        System.out.println(\"*                                     *\");\n        System.out.println(\"* Connecting to Server...             *\");\n\n        // connect to VoltDB server\n        org.voltdb.client.Client client = null;\n        try {\n            ClientConfig config = new ClientConfig(\"program\", \"pass\");\n            client = ClientFactory.createClient(config);\n            client.createConnection(\"localhost\");\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        System.out.println(\"* Connected                           *\");\n        System.out.println(\"* Running loader                      *\");\n        System.out.println(\"***************************************\\n\");\n\n        // Load our starting data from our CSV files using the Loader class\n        try {\n            allAuctionIds = Loader.loadItems(client);\n            activeAuctionIds.addAll(allAuctionIds);\n            userIds = Loader.loadUsers(client);\n            Loader.loadCategories(client);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // since we create 1 bid per auction\n        nextBidId = allAuctionIds.size() + 1;\n\n        System.out.println(\"***************************************\");\n        System.out.println(\"* Finished running loader             *\");\n        System.out.println(\"* Running auctions                    *\");\n        System.out.println(\"***************************************\");\n\n        // create and start a thread that prints auction status every\n        // 10 seconds, ending when all auctions have closed\n        Thread statusThread = new Thread(new Runnable() {\n            public void run() { runStatusLoop(); }\n        });\n        statusThread.start();\n\n        // runloop executes bids until all auctions have ended\n        runBidLoop(client);\n\n        // wait for the status-printing thread to finish\n        try { statusThread.join(); } catch (Exception e) {}\n\n        // print out a joke with dramatic pauses\n        System.out.println(\"\\n***************************************\");\n        System.out.println(\"* Complete...                         *\");\n        System.out.println(\"*                                     *\");\n        try { Thread.sleep(1000); } catch (InterruptedException e) {}\n        System.out.println(\"* Where do ghosts shop?               *\");\n        System.out.println(\"*                                     *\");\n        try { Thread.sleep(3000); } catch (InterruptedException e) {}\n        System.out.println(\"* In Boo-tiques!                      *\");\n        System.out.println(\"***************************************\");\n        try {\n            client.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }","id":9819,"modified_method":"/**\n     * Load the initial data, then run the simulation.\n     *\n     * @param args This program uses no command line arguments.\n     */\n    public static void main(String[] args) {\n        System.out.println(\"***************************************\");\n        System.out.println(\"* Welcome to Bobbi's Awesome Auctions *\");\n        System.out.println(\"*                                     *\");\n        System.out.println(\"* Connecting to Server...             *\");\n\n        // connect to VoltDB server\n        org.voltdb.client.Client client = null;\n        ClientConfig config = new ClientConfig(\"program\", \"pass\");\n        client = ClientFactory.createClient(config);\n        int sleep = 1000;\n        while(true)\n        {\n            try\n            {\n                client.createConnection(\"localhost\");\n                break;\n            } catch (Exception e) {\n                System.out.println(\"Connection failed - retrying in \" + (sleep/1000) + \" second(s).\");\n                try {Thread.sleep(sleep);} catch(Exception tie){}\n                if (sleep < 8000)\n                    sleep += sleep;\n            }\n        }\n\n        System.out.println(\"* Connected                           *\");\n        System.out.println(\"* Running loader                      *\");\n        System.out.println(\"***************************************\\n\");\n\n        // Load our starting data from our CSV files using the Loader class\n        try {\n            allAuctionIds = Loader.loadItems(client);\n            activeAuctionIds.addAll(allAuctionIds);\n            userIds = Loader.loadUsers(client);\n            Loader.loadCategories(client);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // since we create 1 bid per auction\n        nextBidId = allAuctionIds.size() + 1;\n\n        System.out.println(\"***************************************\");\n        System.out.println(\"* Finished running loader             *\");\n        System.out.println(\"* Running auctions                    *\");\n        System.out.println(\"***************************************\");\n\n        // create and start a thread that prints auction status every\n        // 10 seconds, ending when all auctions have closed\n        Thread statusThread = new Thread(new Runnable() {\n            public void run() { runStatusLoop(); }\n        });\n        statusThread.start();\n\n        // runloop executes bids until all auctions have ended\n        runBidLoop(client);\n\n        // wait for the status-printing thread to finish\n        try { statusThread.join(); } catch (Exception e) {}\n\n        // print out a joke with dramatic pauses\n        System.out.println(\"\\n***************************************\");\n        System.out.println(\"* Complete...                         *\");\n        System.out.println(\"*                                     *\");\n        try { Thread.sleep(1000); } catch (InterruptedException e) {}\n        System.out.println(\"* Where do ghosts shop?               *\");\n        System.out.println(\"*                                     *\");\n        try { Thread.sleep(3000); } catch (InterruptedException e) {}\n        System.out.println(\"* In Boo-tiques!                      *\");\n        System.out.println(\"***************************************\");\n        try {\n            client.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"5db533eb8c5b85c32102f813e166cb86396a5d8c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        long transactions_per_second_requested = Long.valueOf(args[0]);\n        long transactions_per_second = transactions_per_second_requested;\n        long transactions_per_milli = transactions_per_second / 1000l;\n        long client_feedback_interval_secs = Long.valueOf(args[1]);\n        long test_duration_secs = Long.valueOf(args[2]);\n        long lag_latency_seconds = Long.valueOf(args[3]);\n        long lag_latency_millis = lag_latency_seconds * 1000l;\n        String serverList = args[4];\n        int key_size = Integer.valueOf(args[5]);\n        int min_value_size = Integer.valueOf(args[6]);\n        int max_value_size = Integer.valueOf(args[7]);\n        long initial_size = Long.valueOf(args[8]);\n        int percent_gets = Integer.valueOf(args[9]);\n        final int behavior_type = Integer.valueOf(args[10]);\n\n        boolean use_auto_tuning = Boolean.valueOf(args[11]) && (transactions_per_second > 1000);\n        double auto_tuning_target_latency_millis = Double.valueOf(args[12]);\n        double auto_tuning_adjustment_rate = Double.valueOf(args[13]);\n        if (auto_tuning_adjustment_rate > 1.0) {\n            auto_tuning_adjustment_rate = auto_tuning_adjustment_rate / 100.0;\n        }\n        long auto_tuning_interval_secs = Long.valueOf(args[14]);\n\n        long thisOutstanding = 0;\n        long lastOutstanding = 0;\n        long put_value_compressed_bytes = 0;\n        long put_value_uncompressed_bytes = 0;\n\n        m_logger.info(String.format(\"Submitting %,d Transactions/sec (TPS)\",transactions_per_second));\n        if (use_auto_tuning) {\n            m_logger.info(String.format(\"Auto-Tuning = ON\"));\n            m_logger.info(String.format(\" - Tuning interval = %,d second(s)\", auto_tuning_interval_secs));\n            m_logger.info(String.format(\" - Target latency = %.2f ms\", auto_tuning_target_latency_millis));\n            m_logger.info(String.format(\" - Adjustment rate = %.2f%%\", auto_tuning_adjustment_rate * 100.0));\n        }\n        m_logger.info(String.format(\"Feedback interval = %,d second(s)\",client_feedback_interval_secs));\n        m_logger.info(String.format(\"Running for %,d second(s)\",test_duration_secs));\n        m_logger.info(String.format(\"Latency not recorded for %d second(s)\",lag_latency_seconds));\n        m_logger.info(String.format(\"Key size = %,d\",key_size));\n        m_logger.info(String.format(\"Minimum Value size = %,d\",min_value_size));\n        m_logger.info(String.format(\"Maximum Value size = %,d\",max_value_size));\n        m_logger.info(String.format(\"Initial number of keys/values = %,d\",initial_size));\n        m_logger.info(String.format(\"Percentage Gets (vs. puts) = %,d\",percent_gets));\n        if (behavior_type == 1) {\n            m_logger.info(String.format(\"Payload stored as is.\"));\n            behavior = Behavior.NONE;\n        } else {\n            m_logger.info(String.format(\"Payload will be Gzipped.\"));\n            behavior = Behavior.GZIP;\n        }\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        ClientConfig config = new ClientConfig(\"program\", \"none\");\n        final org.voltdb.client.Client voltclient = ClientFactory.createClient(config);\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers) {\n            try {\n                thisServer = thisServer.trim();\n                m_logger.info(String.format(\"Connecting to server: %s\",thisServer));\n                voltclient.createConnection(thisServer);\n            } catch (IOException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            }\n        }\n\n        // make random object totally random (set my milliseconds) so we can have multiple clients running simultaneously\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        long lastAutoTuningTime = startTime;\n        long num_sp_calls = 0;\n        long cycle_num_sp_calls = 0;\n        long startRecordingLatency = startTime + lag_latency_millis;\n\n        long num_gets = 0;\n        long num_puts = 0;\n\n        String this_key;\n\n        byte[] baGenericValue = new byte[max_value_size];\n\n        for (int i=0; i < max_value_size; i++) {\n            // set the \"64\" to whatever number of \"values\" from 256 you want included in the payload, the lower the number the more compressible the payload\n            baGenericValue[i] = (byte) rand.nextInt(64);\n        }\n\n        // test if database needs initialization\n        int initialize_data = 0;\n\n        try {\n            String init_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", initial_size);\n            VoltTable[] vtInit = voltclient.callProcedure(\"Get\", init_key).getResults();\n            if (vtInit[0].getRowCount() == 0) {\n                // database is not fully initialized, do initialization\n                initialize_data = 1;\n            }\n        } catch (ProcCallException e) {\n            m_logger.error(\"ProcCallException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (IOException e) {\n            m_logger.error(\"IOException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        if (initialize_data == 1) {\n            // ***********************************************************************************************************************************************\n            // initial population\n            // ***********************************************************************************************************************************************\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            m_logger.info(String.format(\"Populating Initial Data\"));\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            while (num_puts < initial_size) {\n                num_puts++;\n\n                this_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", num_puts);\n                byte[] baThisValue = Arrays.copyOfRange(baGenericValue,0,min_value_size+rand.nextInt(max_value_size-min_value_size+1));\n                byte[] this_value = null;\n\n                if (behavior == Behavior.NONE) {\n                    // if not using compression\n                    this_value = baThisValue;\n                } else if (behavior == Behavior.GZIP) {\n                    // if using compression\n                    this_value = gzip(baThisValue);\n                } else {\n                    System.err.println(\"Unsupported behavior \" + behavior);\n                    System.exit(-1);\n                }\n\n                put_value_uncompressed_bytes += baThisValue.length;\n                put_value_compressed_bytes += this_value.length;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.PUT, this_key), \"Put\", this_key, this_value);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n\n                transactions_this_second++;\n                if (transactions_this_second >= transactions_per_milli) {\n                    this_millisecond = System.currentTimeMillis();\n                    while (this_millisecond <= last_millisecond) {\n                        this_millisecond = System.currentTimeMillis();\n                    }\n                    last_millisecond = this_millisecond;\n                    transactions_this_second = 0;\n                }\n\n                currentTime = System.currentTimeMillis();\n\n                if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                    // time to start recording latency information\n                    checkLatency = true;\n                }\n\n                if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                    synchronized(lockObject) {\n                        lastFeedbackTime = currentTime;\n\n                        long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                        float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n                        if (tot_executions_latency == 0) {\n                            tot_executions_latency = 1;\n                        }\n                        thisOutstanding = num_puts - tot_executions;\n\n                        double percentComplete = ((double) num_puts / (double) initial_size) * 100;\n                        if (percentComplete > 100.0) {\n                            percentComplete = 100.0;\n                        }\n\n                        // calculate IO statistics\n                        VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                        int vtRowCount = vtIOStats.getRowCount();\n                        long bytesRead = 0;\n                        long bytesWritten = 0;\n                        double readMBPerSecond = 0;\n                        double writeMBPerSecond = 0;\n\n                        if (vtRowCount > 0) {\n                            bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                            bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                            readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                            writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        } else {\n                            readMBPerSecond = -1.0;\n                            writeMBPerSecond = -1.0;\n                        }\n\n                        String currentDate = new Date().toString();\n                        m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\",currentDate, percentComplete, num_puts, (num_puts / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, ((double) tot_execution_milliseconds / (double) tot_executions_latency),readMBPerSecond,writeMBPerSecond));\n\n                        lastOutstanding = thisOutstanding;\n                    }\n                }\n            }\n\n            try {\n                voltclient.drain();\n            } catch (InterruptedException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            } catch (NoConnectionsException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            }\n\n            long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n            float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n            if (num_puts == 0) { num_puts = 1; };\n            if (num_gets == 0) { num_gets = 1; };\n            if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n            if (get_value_uncompressed_bytes == 0) { get_value_uncompressed_bytes = 1; };\n            if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n            if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\"Checking Results - Populating Initial Data\"));\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n            m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_gets + num_puts, num_gets, num_puts));\n            m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n            m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / (double) put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / (double) num_puts));\n            m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes,get_value_compressed_bytes,((double) get_value_compressed_bytes / (double) get_value_uncompressed_bytes) * 100.0, (double) get_value_uncompressed_bytes / (double) num_gets));\n            m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n            m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n            m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n            m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n            m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n            m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n            m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n            m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n            m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n            m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n        }\n\n\n        // ***********************************************************************************************************************************************\n        // gets and puts\n        // ***********************************************************************************************************************************************\n\n        thisOutstanding = 0;\n        lastOutstanding = 0;\n        put_value_compressed_bytes = 0;\n        put_value_uncompressed_bytes = 0;\n        get_value_compressed_bytes = 0;\n        get_value_uncompressed_bytes = 0;\n\n        min_execution_milliseconds = 999999999l;\n        max_execution_milliseconds = -1l;\n        tot_execution_milliseconds = 0;\n        tot_executions = 0;\n        tot_executions_latency = 0;\n        latency_counter = new long[] {0,0,0,0,0,0,0,0,0};\n        checkLatency = false;\n\n        cycle_min_execution_milliseconds = 999999999l;\n        cycle_max_execution_milliseconds = -1l;\n        cycle_tot_execution_milliseconds = 0;\n        cycle_tot_executions_latency = 0;\n\n        transactions_this_second = 0;\n        last_millisecond = System.currentTimeMillis();\n        this_millisecond = System.currentTimeMillis();\n\n        startTime = System.currentTimeMillis();\n        endTime = startTime + (1000l * test_duration_secs);\n        currentTime = startTime;\n        lastFeedbackTime = startTime;\n        lastAutoTuningTime = startTime;\n        num_sp_calls = 0;\n        cycle_num_sp_calls = 0;\n        startRecordingLatency = startTime + lag_latency_millis;\n\n        num_gets = 0;\n        num_puts = 0;\n\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n        m_logger.info(String.format(\"Running Get/Put Benchmark\"));\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n        while (currentTime < endTime) {\n            num_sp_calls++;\n            cycle_num_sp_calls++;\n\n            // determine if this is a get or a put\n            int getTest = rand.nextInt(99)+1;\n\n            this_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", (long) ((rand.nextDouble() * initial_size) + 1));\n\n            if (getTest <= percent_gets) {\n                // do a get\n                num_gets++;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.GET, this_key), \"Get\", this_key);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n            } else {\n                // do a put\n                num_puts++;\n                byte[] baThisValuePut = Arrays.copyOfRange(baGenericValue,0,min_value_size+rand.nextInt(max_value_size-min_value_size+1));\n                byte[] this_value = null;\n\n                if (behavior == Behavior.NONE) {\n                    // if not using compression\n                    this_value = baThisValuePut;\n                } else if (behavior == Behavior.GZIP) {\n                    // if using compression\n                    this_value = gzip(baThisValuePut);\n                } else {\n                    System.err.println(\"Unsupported behavior \" + behavior);\n                    System.exit(-1);\n                }\n\n                put_value_uncompressed_bytes += baThisValuePut.length;\n                put_value_compressed_bytes += this_value.length;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.PUT, this_key), \"Put\", this_key, this_value);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n            }\n\n            transactions_this_second++;\n            if (transactions_this_second >= transactions_per_milli) {\n                this_millisecond = System.currentTimeMillis();\n                while (this_millisecond <= last_millisecond) {\n                    this_millisecond = System.currentTimeMillis();\n                }\n                last_millisecond = this_millisecond;\n                transactions_this_second = 0;\n            }\n\n            currentTime = System.currentTimeMillis();\n\n            if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                // time to start recording latency information\n                checkLatency = true;\n            }\n\n            if (use_auto_tuning && (currentTime >= (lastAutoTuningTime + (auto_tuning_interval_secs * 1000)))) {\n                synchronized(lockObject) {\n\n                    long cycle_elapsedTimeMillis2 = System.currentTimeMillis()-lastAutoTuningTime;\n                    float cycle_elapsedTimeSec2 = cycle_elapsedTimeMillis2/1000F;\n\n                    lastAutoTuningTime = currentTime;\n\n                    // Only adjust if both the cycle and total was below request - avoid *some* random spike from downgrading the system too much\n                    if ((((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) > auto_tuning_target_latency_millis) && (((double) tot_execution_milliseconds / (double) tot_executions_latency) > auto_tuning_target_latency_millis))\n                    {\n                        long new_transactions_per_second = (((long)(Math.min(cycle_num_sp_calls / cycle_elapsedTimeSec2,transactions_per_second) * auto_tuning_adjustment_rate))/1000l)*1000l;\n                        String last_tuning_warning = \"\";\n                        if ((new_transactions_per_second <= 1000) || (new_transactions_per_second == transactions_per_second)) {\n                            use_auto_tuning = false;\n                            last_tuning_warning = \" | WARNING: Minimum load boundary reached.\";\n                        }\n\n                        m_logger.info(String.format(\"[%s] Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting DOWN: %,d TPS%s\"\n                                                   , new Date().toString()\n                                                   , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                                   , cycle_min_execution_milliseconds\n                                                   , cycle_max_execution_milliseconds\n                                                   , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                                   , new_transactions_per_second\n                                                   , last_tuning_warning\n                                                   )\n                                     );\n                        transactions_per_second = new_transactions_per_second;\n                        transactions_per_milli = transactions_per_second/1000l;\n                    }\n                    else if (((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) < 0.9d*auto_tuning_target_latency_millis)\n                    {\n                        long new_transactions_per_second = ((long)Math.max(1.05d*transactions_per_second, (double)(cycle_num_sp_calls / cycle_elapsedTimeSec2))/1000l) *1000l;\n                        if (new_transactions_per_second > transactions_per_second_requested)\n                            new_transactions_per_second = transactions_per_second_requested;\n                        if (new_transactions_per_second > transactions_per_second)\n                        {\n                            System.out.printf(\"Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting UP: %,d TPS\\n\"\n                                             , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                             , cycle_min_execution_milliseconds\n                                             , cycle_max_execution_milliseconds\n                                             , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                             , new_transactions_per_second\n                                             );\n                            transactions_per_second = new_transactions_per_second;\n                            transactions_per_milli = transactions_per_second/1000l;\n                        }\n                    }\n\n                    cycle_num_sp_calls = 0;\n\n                    cycle_min_execution_milliseconds = 999999999l;\n                    cycle_max_execution_milliseconds = -1l;\n                    cycle_tot_execution_milliseconds = 0;\n                    cycle_tot_executions_latency = 0;\n                }\n            }\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                synchronized(lockObject) {\n\n                    lastFeedbackTime = currentTime;\n\n                    long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                    float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n\n                    if (tot_executions_latency == 0) {\n                        tot_executions_latency = 1;\n                    }\n                    thisOutstanding = num_sp_calls - tot_executions;\n\n                    long runTimeMillis = endTime - startTime;\n\n                    double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                    if (percentComplete > 100.0) {\n                        percentComplete = 100.0;\n                    }\n\n                    // calculate IO statistics\n                    VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                    int vtRowCount = vtIOStats.getRowCount();\n                    long bytesRead = 0;\n                    long bytesWritten = 0;\n                    double readMBPerSecond = 0;\n                    double writeMBPerSecond = 0;\n\n                    if (vtRowCount > 0) {\n                        bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                        bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                        readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                    } else {\n                        readMBPerSecond = -1.0;\n                        writeMBPerSecond = -1.0;\n                    }\n\n                    String currentDate = new Date().toString();\n                    m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\"\n                                               , currentDate\n                                               , percentComplete\n                                               , num_sp_calls\n                                               , (num_sp_calls / elapsedTimeSec2)\n                                               , thisOutstanding\n                                               , (thisOutstanding - lastOutstanding)\n                                               , min_execution_milliseconds\n                                               , max_execution_milliseconds\n                                               , ((double) tot_execution_milliseconds / (double) tot_executions_latency)\n                                               , readMBPerSecond\n                                               , writeMBPerSecond\n                                               )\n                                 );\n                    lastOutstanding = thisOutstanding;\n\n                }\n            }\n        }\n\n        try {\n            voltclient.drain();\n        } catch (InterruptedException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (NoConnectionsException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        if (num_puts == 0) { num_puts = 1; };\n        if (num_gets == 0) { num_gets = 1; };\n        if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n        if (get_value_uncompressed_bytes == 0) { get_value_uncompressed_bytes = 1; };\n        if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n        if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\"Checking Results - Get/Put Benchmark\"));\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n        m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_sp_calls, num_gets, num_puts));\n        m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_sp_calls / elapsedTimeSec));\n        m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n        m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n        m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / (double) put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / (double) num_puts));\n        m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes,get_value_compressed_bytes,((double) get_value_compressed_bytes / (double) get_value_uncompressed_bytes) * 100.0, (double) get_value_uncompressed_bytes / (double) num_gets));\n        m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n        m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n        m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n        m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n        m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n        m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n        m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n        m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n        m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n        m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n        if (transactions_per_second < transactions_per_second_requested) {\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\"Auto-Tuning Results\"));\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\" - Optimal Load: %,d TPS to match/approach desired %.2f ms Latency\", transactions_per_second, auto_tuning_target_latency_millis));\n        }\n        try {\n            voltclient.close();\n        } catch (Exception e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n    }","id":9820,"modified_method":"public static void main(String args[]) {\n        long transactions_per_second_requested = Long.valueOf(args[0]);\n        long transactions_per_second = transactions_per_second_requested;\n        long transactions_per_milli = transactions_per_second / 1000l;\n        long client_feedback_interval_secs = Long.valueOf(args[1]);\n        long test_duration_secs = Long.valueOf(args[2]);\n        long lag_latency_seconds = Long.valueOf(args[3]);\n        long lag_latency_millis = lag_latency_seconds * 1000l;\n        String serverList = args[4];\n        int key_size = Integer.valueOf(args[5]);\n        int min_value_size = Integer.valueOf(args[6]);\n        int max_value_size = Integer.valueOf(args[7]);\n        long initial_size = Long.valueOf(args[8]);\n        int percent_gets = Integer.valueOf(args[9]);\n        final int behavior_type = Integer.valueOf(args[10]);\n\n        boolean use_auto_tuning = Boolean.valueOf(args[11]) && (transactions_per_second > 1000);\n        double auto_tuning_target_latency_millis = Double.valueOf(args[12]);\n        double auto_tuning_adjustment_rate = Double.valueOf(args[13]);\n        if (auto_tuning_adjustment_rate > 1.0) {\n            auto_tuning_adjustment_rate = auto_tuning_adjustment_rate / 100.0;\n        }\n        long auto_tuning_interval_secs = Long.valueOf(args[14]);\n\n        long thisOutstanding = 0;\n        long lastOutstanding = 0;\n        long put_value_compressed_bytes = 0;\n        long put_value_uncompressed_bytes = 0;\n\n        m_logger.info(String.format(\"Submitting %,d Transactions/sec (TPS)\",transactions_per_second));\n        if (use_auto_tuning) {\n            m_logger.info(String.format(\"Auto-Tuning = ON\"));\n            m_logger.info(String.format(\" - Tuning interval = %,d second(s)\", auto_tuning_interval_secs));\n            m_logger.info(String.format(\" - Target latency = %.2f ms\", auto_tuning_target_latency_millis));\n            m_logger.info(String.format(\" - Adjustment rate = %.2f%%\", auto_tuning_adjustment_rate * 100.0));\n        }\n        m_logger.info(String.format(\"Feedback interval = %,d second(s)\",client_feedback_interval_secs));\n        m_logger.info(String.format(\"Running for %,d second(s)\",test_duration_secs));\n        m_logger.info(String.format(\"Latency not recorded for %d second(s)\",lag_latency_seconds));\n        m_logger.info(String.format(\"Key size = %,d\",key_size));\n        m_logger.info(String.format(\"Minimum Value size = %,d\",min_value_size));\n        m_logger.info(String.format(\"Maximum Value size = %,d\",max_value_size));\n        m_logger.info(String.format(\"Initial number of keys/values = %,d\",initial_size));\n        m_logger.info(String.format(\"Percentage Gets (vs. puts) = %,d\",percent_gets));\n        if (behavior_type == 1) {\n            m_logger.info(String.format(\"Payload stored as is.\"));\n            behavior = Behavior.NONE;\n        } else {\n            m_logger.info(String.format(\"Payload will be Gzipped.\"));\n            behavior = Behavior.GZIP;\n        }\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        ClientConfig config = new ClientConfig(\"program\", \"none\");\n        final org.voltdb.client.Client voltclient = ClientFactory.createClient(config);\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers)\n        {\n            thisServer = thisServer.trim();\n            m_logger.info(String.format(\"Connecting to server: '%s'\\n\",thisServer));\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    voltclient.createConnection(thisServer);\n                    break;\n                } catch (IOException e) {\n                    m_logger.info(\"Connection failed - retrying in \" + (sleep/1000) + \" second(s).\");\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n        }\n\n        // make random object totally random (set my milliseconds) so we can have multiple clients running simultaneously\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        long lastAutoTuningTime = startTime;\n        long num_sp_calls = 0;\n        long cycle_num_sp_calls = 0;\n        long startRecordingLatency = startTime + lag_latency_millis;\n\n        long num_gets = 0;\n        long num_puts = 0;\n\n        String this_key;\n\n        byte[] baGenericValue = new byte[max_value_size];\n\n        for (int i=0; i < max_value_size; i++) {\n            // set the \"64\" to whatever number of \"values\" from 256 you want included in the payload, the lower the number the more compressible the payload\n            baGenericValue[i] = (byte) rand.nextInt(64);\n        }\n\n        // test if database needs initialization\n        int initialize_data = 0;\n\n        try {\n            String init_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", initial_size);\n            VoltTable[] vtInit = voltclient.callProcedure(\"Get\", init_key).getResults();\n            if (vtInit[0].getRowCount() == 0) {\n                // database is not fully initialized, do initialization\n                initialize_data = 1;\n            }\n        } catch (ProcCallException e) {\n            m_logger.error(\"ProcCallException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (IOException e) {\n            m_logger.error(\"IOException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        if (initialize_data == 1) {\n            // ***********************************************************************************************************************************************\n            // initial population\n            // ***********************************************************************************************************************************************\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            m_logger.info(String.format(\"Populating Initial Data\"));\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            while (num_puts < initial_size) {\n                num_puts++;\n\n                this_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", num_puts);\n                byte[] baThisValue = Arrays.copyOfRange(baGenericValue,0,min_value_size+rand.nextInt(max_value_size-min_value_size+1));\n                byte[] this_value = null;\n\n                if (behavior == Behavior.NONE) {\n                    // if not using compression\n                    this_value = baThisValue;\n                } else if (behavior == Behavior.GZIP) {\n                    // if using compression\n                    this_value = gzip(baThisValue);\n                } else {\n                    System.err.println(\"Unsupported behavior \" + behavior);\n                    System.exit(-1);\n                }\n\n                put_value_uncompressed_bytes += baThisValue.length;\n                put_value_compressed_bytes += this_value.length;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.PUT, this_key), \"Put\", this_key, this_value);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n\n                transactions_this_second++;\n                if (transactions_this_second >= transactions_per_milli) {\n                    this_millisecond = System.currentTimeMillis();\n                    while (this_millisecond <= last_millisecond) {\n                        this_millisecond = System.currentTimeMillis();\n                    }\n                    last_millisecond = this_millisecond;\n                    transactions_this_second = 0;\n                }\n\n                currentTime = System.currentTimeMillis();\n\n                if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                    // time to start recording latency information\n                    checkLatency = true;\n                }\n\n                if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                    synchronized(lockObject) {\n                        lastFeedbackTime = currentTime;\n\n                        long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                        float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n                        if (tot_executions_latency == 0) {\n                            tot_executions_latency = 1;\n                        }\n                        thisOutstanding = num_puts - tot_executions;\n\n                        double percentComplete = ((double) num_puts / (double) initial_size) * 100;\n                        if (percentComplete > 100.0) {\n                            percentComplete = 100.0;\n                        }\n\n                        // calculate IO statistics\n                        VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                        int vtRowCount = vtIOStats.getRowCount();\n                        long bytesRead = 0;\n                        long bytesWritten = 0;\n                        double readMBPerSecond = 0;\n                        double writeMBPerSecond = 0;\n\n                        if (vtRowCount > 0) {\n                            bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                            bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                            readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                            writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        } else {\n                            readMBPerSecond = -1.0;\n                            writeMBPerSecond = -1.0;\n                        }\n\n                        String currentDate = new Date().toString();\n                        m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\",currentDate, percentComplete, num_puts, (num_puts / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, ((double) tot_execution_milliseconds / (double) tot_executions_latency),readMBPerSecond,writeMBPerSecond));\n\n                        lastOutstanding = thisOutstanding;\n                    }\n                }\n            }\n\n            try {\n                voltclient.drain();\n            } catch (InterruptedException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            } catch (NoConnectionsException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            }\n\n            long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n            float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n            if (num_puts == 0) { num_puts = 1; };\n            if (num_gets == 0) { num_gets = 1; };\n            if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n            if (get_value_uncompressed_bytes == 0) { get_value_uncompressed_bytes = 1; };\n            if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n            if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\"Checking Results - Populating Initial Data\"));\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n            m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_gets + num_puts, num_gets, num_puts));\n            m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n            m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / (double) put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / (double) num_puts));\n            m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes,get_value_compressed_bytes,((double) get_value_compressed_bytes / (double) get_value_uncompressed_bytes) * 100.0, (double) get_value_uncompressed_bytes / (double) num_gets));\n            m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n            m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n            m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n            m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n            m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n            m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n            m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n            m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n            m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n            m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n        }\n\n\n        // ***********************************************************************************************************************************************\n        // gets and puts\n        // ***********************************************************************************************************************************************\n\n        thisOutstanding = 0;\n        lastOutstanding = 0;\n        put_value_compressed_bytes = 0;\n        put_value_uncompressed_bytes = 0;\n        get_value_compressed_bytes = 0;\n        get_value_uncompressed_bytes = 0;\n\n        min_execution_milliseconds = 999999999l;\n        max_execution_milliseconds = -1l;\n        tot_execution_milliseconds = 0;\n        tot_executions = 0;\n        tot_executions_latency = 0;\n        latency_counter = new long[] {0,0,0,0,0,0,0,0,0};\n        checkLatency = false;\n\n        cycle_min_execution_milliseconds = 999999999l;\n        cycle_max_execution_milliseconds = -1l;\n        cycle_tot_execution_milliseconds = 0;\n        cycle_tot_executions_latency = 0;\n\n        transactions_this_second = 0;\n        last_millisecond = System.currentTimeMillis();\n        this_millisecond = System.currentTimeMillis();\n\n        startTime = System.currentTimeMillis();\n        endTime = startTime + (1000l * test_duration_secs);\n        currentTime = startTime;\n        lastFeedbackTime = startTime;\n        lastAutoTuningTime = startTime;\n        num_sp_calls = 0;\n        cycle_num_sp_calls = 0;\n        startRecordingLatency = startTime + lag_latency_millis;\n\n        num_gets = 0;\n        num_puts = 0;\n\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n        m_logger.info(String.format(\"Running Get/Put Benchmark\"));\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n        while (currentTime < endTime) {\n            num_sp_calls++;\n            cycle_num_sp_calls++;\n\n            // determine if this is a get or a put\n            int getTest = rand.nextInt(99)+1;\n\n            this_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", (long) ((rand.nextDouble() * initial_size) + 1));\n\n            if (getTest <= percent_gets) {\n                // do a get\n                num_gets++;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.GET, this_key), \"Get\", this_key);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n            } else {\n                // do a put\n                num_puts++;\n                byte[] baThisValuePut = Arrays.copyOfRange(baGenericValue,0,min_value_size+rand.nextInt(max_value_size-min_value_size+1));\n                byte[] this_value = null;\n\n                if (behavior == Behavior.NONE) {\n                    // if not using compression\n                    this_value = baThisValuePut;\n                } else if (behavior == Behavior.GZIP) {\n                    // if using compression\n                    this_value = gzip(baThisValuePut);\n                } else {\n                    System.err.println(\"Unsupported behavior \" + behavior);\n                    System.exit(-1);\n                }\n\n                put_value_uncompressed_bytes += baThisValuePut.length;\n                put_value_compressed_bytes += this_value.length;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.PUT, this_key), \"Put\", this_key, this_value);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n            }\n\n            transactions_this_second++;\n            if (transactions_this_second >= transactions_per_milli) {\n                this_millisecond = System.currentTimeMillis();\n                while (this_millisecond <= last_millisecond) {\n                    this_millisecond = System.currentTimeMillis();\n                }\n                last_millisecond = this_millisecond;\n                transactions_this_second = 0;\n            }\n\n            currentTime = System.currentTimeMillis();\n\n            if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                // time to start recording latency information\n                checkLatency = true;\n            }\n\n            if (use_auto_tuning && (currentTime >= (lastAutoTuningTime + (auto_tuning_interval_secs * 1000)))) {\n                synchronized(lockObject) {\n\n                    long cycle_elapsedTimeMillis2 = System.currentTimeMillis()-lastAutoTuningTime;\n                    float cycle_elapsedTimeSec2 = cycle_elapsedTimeMillis2/1000F;\n\n                    lastAutoTuningTime = currentTime;\n\n                    // Only adjust if both the cycle and total was below request - avoid *some* random spike from downgrading the system too much\n                    if ((((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) > auto_tuning_target_latency_millis) && (((double) tot_execution_milliseconds / (double) tot_executions_latency) > auto_tuning_target_latency_millis))\n                    {\n                        long new_transactions_per_second = (((long)(Math.min(cycle_num_sp_calls / cycle_elapsedTimeSec2,transactions_per_second) * auto_tuning_adjustment_rate))/1000l)*1000l;\n                        String last_tuning_warning = \"\";\n                        if ((new_transactions_per_second <= 1000) || (new_transactions_per_second == transactions_per_second)) {\n                            use_auto_tuning = false;\n                            last_tuning_warning = \" | WARNING: Minimum load boundary reached.\";\n                        }\n\n                        m_logger.info(String.format(\"[%s] Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting DOWN: %,d TPS%s\"\n                                                   , new Date().toString()\n                                                   , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                                   , cycle_min_execution_milliseconds\n                                                   , cycle_max_execution_milliseconds\n                                                   , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                                   , new_transactions_per_second\n                                                   , last_tuning_warning\n                                                   )\n                                     );\n                        transactions_per_second = new_transactions_per_second;\n                        transactions_per_milli = transactions_per_second/1000l;\n                    }\n                    else if (((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) < 0.9d*auto_tuning_target_latency_millis)\n                    {\n                        long new_transactions_per_second = ((long)Math.max(1.05d*transactions_per_second, (double)(cycle_num_sp_calls / cycle_elapsedTimeSec2))/1000l) *1000l;\n                        if (new_transactions_per_second > transactions_per_second_requested)\n                            new_transactions_per_second = transactions_per_second_requested;\n                        if (new_transactions_per_second > transactions_per_second)\n                        {\n                            System.out.printf(\"Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting UP: %,d TPS\\n\"\n                                             , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                             , cycle_min_execution_milliseconds\n                                             , cycle_max_execution_milliseconds\n                                             , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                             , new_transactions_per_second\n                                             );\n                            transactions_per_second = new_transactions_per_second;\n                            transactions_per_milli = transactions_per_second/1000l;\n                        }\n                    }\n\n                    cycle_num_sp_calls = 0;\n\n                    cycle_min_execution_milliseconds = 999999999l;\n                    cycle_max_execution_milliseconds = -1l;\n                    cycle_tot_execution_milliseconds = 0;\n                    cycle_tot_executions_latency = 0;\n                }\n            }\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                synchronized(lockObject) {\n\n                    lastFeedbackTime = currentTime;\n\n                    long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                    float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n\n                    if (tot_executions_latency == 0) {\n                        tot_executions_latency = 1;\n                    }\n                    thisOutstanding = num_sp_calls - tot_executions;\n\n                    long runTimeMillis = endTime - startTime;\n\n                    double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                    if (percentComplete > 100.0) {\n                        percentComplete = 100.0;\n                    }\n\n                    // calculate IO statistics\n                    VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                    int vtRowCount = vtIOStats.getRowCount();\n                    long bytesRead = 0;\n                    long bytesWritten = 0;\n                    double readMBPerSecond = 0;\n                    double writeMBPerSecond = 0;\n\n                    if (vtRowCount > 0) {\n                        bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                        bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                        readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                    } else {\n                        readMBPerSecond = -1.0;\n                        writeMBPerSecond = -1.0;\n                    }\n\n                    String currentDate = new Date().toString();\n                    m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\"\n                                               , currentDate\n                                               , percentComplete\n                                               , num_sp_calls\n                                               , (num_sp_calls / elapsedTimeSec2)\n                                               , thisOutstanding\n                                               , (thisOutstanding - lastOutstanding)\n                                               , min_execution_milliseconds\n                                               , max_execution_milliseconds\n                                               , ((double) tot_execution_milliseconds / (double) tot_executions_latency)\n                                               , readMBPerSecond\n                                               , writeMBPerSecond\n                                               )\n                                 );\n                    lastOutstanding = thisOutstanding;\n\n                }\n            }\n        }\n\n        try {\n            voltclient.drain();\n        } catch (InterruptedException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (NoConnectionsException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        if (num_puts == 0) { num_puts = 1; };\n        if (num_gets == 0) { num_gets = 1; };\n        if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n        if (get_value_uncompressed_bytes == 0) { get_value_uncompressed_bytes = 1; };\n        if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n        if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\"Checking Results - Get/Put Benchmark\"));\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n        m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_sp_calls, num_gets, num_puts));\n        m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_sp_calls / elapsedTimeSec));\n        m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n        m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n        m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / (double) put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / (double) num_puts));\n        m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes,get_value_compressed_bytes,((double) get_value_compressed_bytes / (double) get_value_uncompressed_bytes) * 100.0, (double) get_value_uncompressed_bytes / (double) num_gets));\n        m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n        m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n        m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n        m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n        m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n        m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n        m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n        m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n        m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n        m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n        if (transactions_per_second < transactions_per_second_requested) {\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\"Auto-Tuning Results\"));\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\" - Optimal Load: %,d TPS to match/approach desired %.2f ms Latency\", transactions_per_second, auto_tuning_target_latency_millis));\n        }\n        try {\n            voltclient.close();\n        } catch (Exception e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n    }","commit_id":"5db533eb8c5b85c32102f813e166cb86396a5d8c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        final long transactions_per_second = Long.valueOf(args[0]);\n        final long transactions_per_milli = transactions_per_second / 1000l;\n        final long client_feedback_interval_secs = Long.valueOf(args[1]);\n        final long test_duration_secs = Long.valueOf(args[2]);\n        final long lag_latency_seconds = Long.valueOf(args[3]);\n        final long lag_latency_millis = lag_latency_seconds * 1000l;\n        String serverList = args[4];\n        final int key_size = Integer.valueOf(args[5]);\n        final int min_value_size = Integer.valueOf(args[6]);\n        final int max_value_size = Integer.valueOf(args[7]);\n        final long initial_size = Long.valueOf(args[8]);\n        final int percent_gets = Integer.valueOf(args[9]);\n        final int behavior_type = Integer.valueOf(args[10]);\n\n        m_logger.info(String.format(\"Submitting %,d Transactions/sec (TPS)\",transactions_per_second));\n        m_logger.info(String.format(\"Feedback interval = %,d second(s)\",client_feedback_interval_secs));\n        m_logger.info(String.format(\"Running for %,d second(s)\",test_duration_secs));\n        m_logger.info(String.format(\"Latency not recorded for %d second(s)\",lag_latency_seconds));\n        m_logger.info(String.format(\"Key size = %,d\",key_size));\n        m_logger.info(String.format(\"Minimum Value size = %,d\",min_value_size));\n        m_logger.info(String.format(\"Maximum Value size = %,d\",max_value_size));\n        m_logger.info(String.format(\"Initial number of keys/values = %,d\",initial_size));\n        m_logger.info(String.format(\"Percentage Gets (vs. puts) = %,d\",percent_gets));\n        if (behavior_type == 1) {\n            m_logger.info(String.format(\"Payload stored as is.\"));\n            behavior = Behavior.NONE;\n        } else {\n            m_logger.info(String.format(\"Payload will gzipped.\"));\n            behavior = Behavior.GZIP;\n        }\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers) {\n            try {\n                thisServer = thisServer.trim();\n                m_logger.info(String.format(\"Connecting to server: %s\",thisServer));\n                voltclient.createConnection(thisServer);\n            } catch (IOException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            }\n        }\n\n        // make random object totally random (set my milliseconds) so we can have multiple clients running simultaneously\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        startRecordingLatency = startTime + lag_latency_millis;\n\n        String this_key;\n        byte[] this_value;\n\n        final byte[] baGenericValue = new byte[max_value_size];\n\n        for (int i=0; i < max_value_size; i++) {\n                // set the \"64\" to whatever number of \"values\" from 256 you want included in the payload, the lower the number the more compressible the payload\n                baGenericValue[i] = (byte) rand.nextInt(64);\n        }\n\n        // test if database needs initialization\n        int initialize_data = 0;\n\n        try {\n            String init_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", initial_size);\n            VoltTable[] vtInit = voltclient.callProcedure(\"Get\", init_key).getResults();\n            if (vtInit[0].getRowCount() == 0) {\n                // database is not fully initialized, do initialization\n                initialize_data = 1;\n            }\n        } catch (ProcCallException e) {\n            m_logger.error(\"ProcCallException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (IOException e) {\n            m_logger.error(\"IOException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        if (initialize_data == 1) {\n            long num_gets = 0;\n            long num_puts = 0;\n            long thisOutstanding = 0;\n            long lastOutstanding = 0;\n            long put_value_compressed_bytes = 0;\n            long put_value_uncompressed_bytes = 0;\n\n            // ***********************************************************************************************************************************************\n            // initial population\n            // ***********************************************************************************************************************************************\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            m_logger.info(String.format(\"Populating Initial Data\"));\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            while (num_puts < initial_size) {\n                num_puts++;\n\n                this_key = String.format(\"K%1$#\" + (key_size-1) + \"s\",num_puts);\n                byte[] baThisValue = Arrays.copyOfRange(baGenericValue,0,min_value_size+rand.nextInt(max_value_size-min_value_size+1));\n                this_value = null;\n                if (behavior == Behavior.NONE) {\n                    // if not using compression\n                    this_value = baThisValue;\n                } else if (behavior == Behavior.GZIP) {\n                    // if using compression\n                    this_value = gzip(baThisValue);\n                } else {\n                    System.err.println(\"Unsupported behavior \" + behavior);\n                    System.exit(-1);\n                }\n\n                put_value_uncompressed_bytes += baThisValue.length;\n                put_value_compressed_bytes += this_value.length;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.PUT, this_key), this_value.length + 100, \"Put\", this_key, this_value);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n\n                transactions_this_second++;\n                if (transactions_this_second >= transactions_per_milli) {\n                    this_millisecond = System.currentTimeMillis();\n                    while (this_millisecond <= last_millisecond) {\n                        this_millisecond = System.currentTimeMillis();\n                    }\n                    last_millisecond = this_millisecond;\n                    transactions_this_second = 0;\n                }\n\n                currentTime = System.currentTimeMillis();\n\n                if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                    // time to start recording latency information\n                    checkLatency = true;\n                }\n\n                if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                    VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                    final long now = System.currentTimeMillis();\n                    synchronized(lockObject) {\n                        lastFeedbackTime = currentTime;\n\n                        long elapsedTimeMillis2 = now-startTime;\n                        float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n                        if (tot_executions_latency == 0) {\n                            tot_executions_latency = 1;\n                        }\n                        thisOutstanding = num_puts - tot_executions;\n\n                        double percentComplete = ((double) num_puts / (double) initial_size) * 100;\n                        if (percentComplete > 100.0) {\n                            percentComplete = 100.0;\n                        }\n\n                        // calculate IO statistics\n                        int vtRowCount = vtIOStats.getRowCount();\n                        long bytesRead = 0;\n                        long bytesWritten = 0;\n                        double readMBPerSecond = 0;\n                        double writeMBPerSecond = 0;\n\n                        if (vtRowCount > 0) {\n                            bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                            bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                            readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                            writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        } else {\n                            readMBPerSecond = -1.0;\n                            writeMBPerSecond = -1.0;\n                        }\n\n                        String currentDate = new Date().toString();\n                        m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\",currentDate, percentComplete, num_puts, (num_puts / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, ((double) tot_execution_milliseconds / (double) tot_executions_latency),readMBPerSecond,writeMBPerSecond));\n\n                        lastOutstanding = thisOutstanding;\n                    }\n                }\n            }\n\n            try {\n                voltclient.drain();\n            } catch (InterruptedException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            } catch (NoConnectionsException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            }\n\n            long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n            float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n            if (num_puts == 0) { num_puts = 1; };\n            if (num_gets == 0) { num_gets = 1; };\n            if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n            if (get_value_uncompressed_bytes.get() == 0) { get_value_uncompressed_bytes.set(1); };\n            if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n            if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\"Checking Results - Populating Initial Data\"));\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n            m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_gets + num_puts, num_gets, num_puts));\n            m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n            m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / (double) put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / (double) num_puts));\n            m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes.get(),get_value_compressed_bytes,(get_value_compressed_bytes / (double) get_value_uncompressed_bytes.get()) * 100.0, (double) get_value_uncompressed_bytes.get() / num_gets));\n            m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n            m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n            m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n            m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n            m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n            m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n            m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n            m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n            m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n            m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n        }\n\n\n        // ***********************************************************************************************************************************************\n        // gets and puts\n        // ***********************************************************************************************************************************************\n        get_value_compressed_bytes = 0;\n        get_value_uncompressed_bytes.set(0);\n\n        min_execution_milliseconds = 999999999l;\n        max_execution_milliseconds = -1l;\n        tot_execution_milliseconds = 0;\n        tot_executions = 0;\n        tot_executions_latency = 0;\n        latency_counter = new long[] {0,0,0,0,0,0,0,0,0};\n        checkLatency = false;\n\n        transactions_this_second = 0;\n        last_millisecond = System.currentTimeMillis();\n        this_millisecond = System.currentTimeMillis();\n\n        startTime = System.currentTimeMillis();\n        endTime = startTime + (1000l * test_duration_secs);\n        currentTime = startTime;\n        lastFeedbackTime = startTime;\n        startRecordingLatency = startTime + lag_latency_millis;\n\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n        m_logger.info(String.format(\"Running Get/Put Benchmark\"));\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n\n        ArrayList<Worker> workers = new ArrayList<Worker>();\n        ArrayList<Thread> workerThreads = new ArrayList<Thread>();\n        for (int ii = 0; ii < Runtime.getRuntime().availableProcessors(); ii++) {\n            m_logger.info(String.format(\"Creating Worker Thread %d\",ii+1));\n            final Worker worker = new Worker(percent_gets, initial_size, baGenericValue, min_value_size, max_value_size, key_size);\n            workers.add(worker);\n            final Thread workerThread = new Thread(worker);\n            workerThreads.add(workerThread);\n            workerThread.start();\n        }\n\n        long lastOutstanding = 0;\n        long lastPermitGenerationTime = System.currentTimeMillis();\n        while (currentTime < endTime) {\n            currentTime = System.currentTimeMillis();\n            long delta = currentTime - lastPermitGenerationTime;\n            if (delta > 0) {\n                lastPermitGenerationTime = currentTime;\n                if (workPermits.availablePermits() < 100000) {\n                    workPermits.release((int)(delta *  transactions_per_milli));\n                }\n            } else {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n            }\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                synchronized(lockObject) {\n                    long num_sp_calls = 0;\n                    for (Worker worker : workers) {\n                        num_sp_calls += worker.num_sp_calls.get();\n                    }\n                    lastFeedbackTime = currentTime;\n\n                    long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                    float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n                    if (tot_executions_latency == 0) {\n                        tot_executions_latency = 1;\n                    }\n                    long thisOutstanding = num_sp_calls - tot_executions;\n\n                    long runTimeMillis = endTime - startTime;\n\n                    double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                    if (percentComplete > 100.0) {\n                        percentComplete = 100.0;\n                    }\n\n                    // calculate IO statistics\n                    int vtRowCount = vtIOStats.getRowCount();\n                    long bytesRead = 0;\n                    long bytesWritten = 0;\n                    double readMBPerSecond = 0;\n                    double writeMBPerSecond = 0;\n\n                    if (vtRowCount > 0) {\n                        bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                        bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                        readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                    } else {\n                        readMBPerSecond = -1.0;\n                        writeMBPerSecond = -1.0;\n                    }\n\n                    String currentDate = new Date().toString();\n                    m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\",currentDate, percentComplete, num_sp_calls, (num_sp_calls / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, ((double) tot_execution_milliseconds / (double) tot_executions_latency), readMBPerSecond, writeMBPerSecond));\n\n                    lastOutstanding = thisOutstanding;\n                }\n            }\n        }\n\n        for (Thread t : workerThreads) {\n            t.interrupt();\n            try {\n                t.join();\n            } catch (InterruptedException e) {\n                m_logger.error(e);\n                System.exit(-1);\n            }\n        }\n\n        long num_sp_calls = 0;\n        long num_puts = 0;\n        long num_gets = 0;\n        long put_value_uncompressed_bytes = 0;\n        long put_value_compressed_bytes = 0;\n        for (Worker worker : workers) {\n            Counters counters = worker.getCounters();\n            num_sp_calls += counters.num_sp_calls;\n            num_puts += counters.num_puts;\n            num_gets += counters.num_gets;\n            put_value_uncompressed_bytes += counters.put_value_uncompressed_bytes;\n            put_value_compressed_bytes += counters.put_value_compressed_bytes;\n        }\n\n        try {\n            voltclient.drain();\n        } catch (InterruptedException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (NoConnectionsException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        if (num_puts == 0) { num_puts = 1; };\n        if (num_gets == 0) { num_gets = 1; };\n        if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n        if (get_value_uncompressed_bytes.get() == 0) { get_value_uncompressed_bytes.set(1); };\n        if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n        if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\"Checking Results - Get/Put Benchmark\"));\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n        m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_sp_calls, num_gets, num_puts));\n        m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_sp_calls / elapsedTimeSec));\n        m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n        m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n        m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / num_puts));\n        m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes.get(),get_value_compressed_bytes,(get_value_compressed_bytes / (double) get_value_uncompressed_bytes.get()) * 100.0, (double) get_value_uncompressed_bytes.get() / num_gets));\n        m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n        m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n        m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n        m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n        m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n        m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n        m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n        m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n        m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n        m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n\n        try {\n            voltclient.close();\n        } catch (Exception e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n    }","id":9821,"modified_method":"public static void main(String args[]) {\n        final long transactions_per_second = Long.valueOf(args[0]);\n        final long transactions_per_milli = transactions_per_second / 1000l;\n        final long client_feedback_interval_secs = Long.valueOf(args[1]);\n        final long test_duration_secs = Long.valueOf(args[2]);\n        final long lag_latency_seconds = Long.valueOf(args[3]);\n        final long lag_latency_millis = lag_latency_seconds * 1000l;\n        String serverList = args[4];\n        final int key_size = Integer.valueOf(args[5]);\n        final int min_value_size = Integer.valueOf(args[6]);\n        final int max_value_size = Integer.valueOf(args[7]);\n        final long initial_size = Long.valueOf(args[8]);\n        final int percent_gets = Integer.valueOf(args[9]);\n        final int behavior_type = Integer.valueOf(args[10]);\n\n        m_logger.info(String.format(\"Submitting %,d Transactions/sec (TPS)\",transactions_per_second));\n        m_logger.info(String.format(\"Feedback interval = %,d second(s)\",client_feedback_interval_secs));\n        m_logger.info(String.format(\"Running for %,d second(s)\",test_duration_secs));\n        m_logger.info(String.format(\"Latency not recorded for %d second(s)\",lag_latency_seconds));\n        m_logger.info(String.format(\"Key size = %,d\",key_size));\n        m_logger.info(String.format(\"Minimum Value size = %,d\",min_value_size));\n        m_logger.info(String.format(\"Maximum Value size = %,d\",max_value_size));\n        m_logger.info(String.format(\"Initial number of keys/values = %,d\",initial_size));\n        m_logger.info(String.format(\"Percentage Gets (vs. puts) = %,d\",percent_gets));\n        if (behavior_type == 1) {\n            m_logger.info(String.format(\"Payload stored as is.\"));\n            behavior = Behavior.NONE;\n        } else {\n            m_logger.info(String.format(\"Payload will gzipped.\"));\n            behavior = Behavior.GZIP;\n        }\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers)\n        {\n            thisServer = thisServer.trim();\n            m_logger.info(String.format(\"Connecting to server: '%s'\\n\",thisServer));\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    voltclient.createConnection(thisServer);\n                    break;\n                } catch (IOException e) {\n                    m_logger.info(\"Connection failed - retrying in \" + (sleep/1000) + \" second(s).\");\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n        }\n\n        // make random object totally random (set my milliseconds) so we can have multiple clients running simultaneously\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        startRecordingLatency = startTime + lag_latency_millis;\n\n        String this_key;\n        byte[] this_value;\n\n        final byte[] baGenericValue = new byte[max_value_size];\n\n        for (int i=0; i < max_value_size; i++) {\n                // set the \"64\" to whatever number of \"values\" from 256 you want included in the payload, the lower the number the more compressible the payload\n                baGenericValue[i] = (byte) rand.nextInt(64);\n        }\n\n        // test if database needs initialization\n        int initialize_data = 0;\n\n        try {\n            String init_key = String.format(\"K%1$#\" + (key_size-1) + \"s\", initial_size);\n            VoltTable[] vtInit = voltclient.callProcedure(\"Get\", init_key).getResults();\n            if (vtInit[0].getRowCount() == 0) {\n                // database is not fully initialized, do initialization\n                initialize_data = 1;\n            }\n        } catch (ProcCallException e) {\n            m_logger.error(\"ProcCallException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (IOException e) {\n            m_logger.error(\"IOException\");\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        if (initialize_data == 1) {\n            long num_gets = 0;\n            long num_puts = 0;\n            long thisOutstanding = 0;\n            long lastOutstanding = 0;\n            long put_value_compressed_bytes = 0;\n            long put_value_uncompressed_bytes = 0;\n\n            // ***********************************************************************************************************************************************\n            // initial population\n            // ***********************************************************************************************************************************************\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            m_logger.info(String.format(\"Populating Initial Data\"));\n            m_logger.info(String.format(\"******************************************************************************************************************************\"));\n            while (num_puts < initial_size) {\n                num_puts++;\n\n                this_key = String.format(\"K%1$#\" + (key_size-1) + \"s\",num_puts);\n                byte[] baThisValue = Arrays.copyOfRange(baGenericValue,0,min_value_size+rand.nextInt(max_value_size-min_value_size+1));\n                this_value = null;\n                if (behavior == Behavior.NONE) {\n                    // if not using compression\n                    this_value = baThisValue;\n                } else if (behavior == Behavior.GZIP) {\n                    // if using compression\n                    this_value = gzip(baThisValue);\n                } else {\n                    System.err.println(\"Unsupported behavior \" + behavior);\n                    System.exit(-1);\n                }\n\n                put_value_uncompressed_bytes += baThisValue.length;\n                put_value_compressed_bytes += this_value.length;\n\n                try {\n                    voltclient.callProcedure(new AsyncCallback(spName.PUT, this_key), this_value.length + 100, \"Put\", this_key, this_value);\n                } catch (IOException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n\n                transactions_this_second++;\n                if (transactions_this_second >= transactions_per_milli) {\n                    this_millisecond = System.currentTimeMillis();\n                    while (this_millisecond <= last_millisecond) {\n                        this_millisecond = System.currentTimeMillis();\n                    }\n                    last_millisecond = this_millisecond;\n                    transactions_this_second = 0;\n                }\n\n                currentTime = System.currentTimeMillis();\n\n                if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                    // time to start recording latency information\n                    checkLatency = true;\n                }\n\n                if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                    VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                    final long now = System.currentTimeMillis();\n                    synchronized(lockObject) {\n                        lastFeedbackTime = currentTime;\n\n                        long elapsedTimeMillis2 = now-startTime;\n                        float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n                        if (tot_executions_latency == 0) {\n                            tot_executions_latency = 1;\n                        }\n                        thisOutstanding = num_puts - tot_executions;\n\n                        double percentComplete = ((double) num_puts / (double) initial_size) * 100;\n                        if (percentComplete > 100.0) {\n                            percentComplete = 100.0;\n                        }\n\n                        // calculate IO statistics\n                        int vtRowCount = vtIOStats.getRowCount();\n                        long bytesRead = 0;\n                        long bytesWritten = 0;\n                        double readMBPerSecond = 0;\n                        double writeMBPerSecond = 0;\n\n                        if (vtRowCount > 0) {\n                            bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                            bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                            readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                            writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        } else {\n                            readMBPerSecond = -1.0;\n                            writeMBPerSecond = -1.0;\n                        }\n\n                        String currentDate = new Date().toString();\n                        m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\",currentDate, percentComplete, num_puts, (num_puts / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, ((double) tot_execution_milliseconds / (double) tot_executions_latency),readMBPerSecond,writeMBPerSecond));\n\n                        lastOutstanding = thisOutstanding;\n                    }\n                }\n            }\n\n            try {\n                voltclient.drain();\n            } catch (InterruptedException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            } catch (NoConnectionsException e) {\n                m_logger.error(e.toString());\n                System.exit(-1);\n            }\n\n            long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n            float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n            if (num_puts == 0) { num_puts = 1; };\n            if (num_gets == 0) { num_gets = 1; };\n            if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n            if (get_value_uncompressed_bytes.get() == 0) { get_value_uncompressed_bytes.set(1); };\n            if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n            if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\"Checking Results - Populating Initial Data\"));\n            m_logger.info(String.format(\"*************************************************************************\"));\n            m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n            m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_gets + num_puts, num_gets, num_puts));\n            m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n            m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n            m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / (double) put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / (double) num_puts));\n            m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes.get(),get_value_compressed_bytes,(get_value_compressed_bytes / (double) get_value_uncompressed_bytes.get()) * 100.0, (double) get_value_uncompressed_bytes.get() / num_gets));\n            m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n            m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n            m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n            m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n            m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n            m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n            m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n            m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n            m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n            m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n        }\n\n\n        // ***********************************************************************************************************************************************\n        // gets and puts\n        // ***********************************************************************************************************************************************\n        get_value_compressed_bytes = 0;\n        get_value_uncompressed_bytes.set(0);\n\n        min_execution_milliseconds = 999999999l;\n        max_execution_milliseconds = -1l;\n        tot_execution_milliseconds = 0;\n        tot_executions = 0;\n        tot_executions_latency = 0;\n        latency_counter = new long[] {0,0,0,0,0,0,0,0,0};\n        checkLatency = false;\n\n        transactions_this_second = 0;\n        last_millisecond = System.currentTimeMillis();\n        this_millisecond = System.currentTimeMillis();\n\n        startTime = System.currentTimeMillis();\n        endTime = startTime + (1000l * test_duration_secs);\n        currentTime = startTime;\n        lastFeedbackTime = startTime;\n        startRecordingLatency = startTime + lag_latency_millis;\n\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n        m_logger.info(String.format(\"Running Get/Put Benchmark\"));\n        m_logger.info(String.format(\"******************************************************************************************************************************\"));\n\n        ArrayList<Worker> workers = new ArrayList<Worker>();\n        ArrayList<Thread> workerThreads = new ArrayList<Thread>();\n        for (int ii = 0; ii < Runtime.getRuntime().availableProcessors(); ii++) {\n            m_logger.info(String.format(\"Creating Worker Thread %d\",ii+1));\n            final Worker worker = new Worker(percent_gets, initial_size, baGenericValue, min_value_size, max_value_size, key_size);\n            workers.add(worker);\n            final Thread workerThread = new Thread(worker);\n            workerThreads.add(workerThread);\n            workerThread.start();\n        }\n\n        long lastOutstanding = 0;\n        long lastPermitGenerationTime = System.currentTimeMillis();\n        while (currentTime < endTime) {\n            currentTime = System.currentTimeMillis();\n            long delta = currentTime - lastPermitGenerationTime;\n            if (delta > 0) {\n                lastPermitGenerationTime = currentTime;\n                if (workPermits.availablePermits() < 100000) {\n                    workPermits.release((int)(delta *  transactions_per_milli));\n                }\n            } else {\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    m_logger.error(e.toString());\n                    System.exit(-1);\n                }\n            }\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                VoltTable vtIOStats = voltclient.getIOStatsInterval();\n                synchronized(lockObject) {\n                    long num_sp_calls = 0;\n                    for (Worker worker : workers) {\n                        num_sp_calls += worker.num_sp_calls.get();\n                    }\n                    lastFeedbackTime = currentTime;\n\n                    long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                    float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n\n                    if (tot_executions_latency == 0) {\n                        tot_executions_latency = 1;\n                    }\n                    long thisOutstanding = num_sp_calls - tot_executions;\n\n                    long runTimeMillis = endTime - startTime;\n\n                    double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                    if (percentComplete > 100.0) {\n                        percentComplete = 100.0;\n                    }\n\n                    // calculate IO statistics\n                    int vtRowCount = vtIOStats.getRowCount();\n                    long bytesRead = 0;\n                    long bytesWritten = 0;\n                    double readMBPerSecond = 0;\n                    double writeMBPerSecond = 0;\n\n                    if (vtRowCount > 0) {\n                        bytesRead = vtIOStats.fetchRow(vtRowCount-1).getLong(9);\n                        bytesWritten = vtIOStats.fetchRow(vtRowCount-1).getLong(11);\n                        readMBPerSecond = (bytesRead / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                        writeMBPerSecond = (bytesWritten / 1024.0 / 1024.0) / client_feedback_interval_secs;\n                    } else {\n                        readMBPerSecond = -1.0;\n                        writeMBPerSecond = -1.0;\n                    }\n\n                    String currentDate = new Date().toString();\n                    m_logger.info(String.format(\"[%s] %.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f | Client MB in/out = %,.3f / %,.3f\",currentDate, percentComplete, num_sp_calls, (num_sp_calls / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, ((double) tot_execution_milliseconds / (double) tot_executions_latency), readMBPerSecond, writeMBPerSecond));\n\n                    lastOutstanding = thisOutstanding;\n                }\n            }\n        }\n\n        for (Thread t : workerThreads) {\n            t.interrupt();\n            try {\n                t.join();\n            } catch (InterruptedException e) {\n                m_logger.error(e);\n                System.exit(-1);\n            }\n        }\n\n        long num_sp_calls = 0;\n        long num_puts = 0;\n        long num_gets = 0;\n        long put_value_uncompressed_bytes = 0;\n        long put_value_compressed_bytes = 0;\n        for (Worker worker : workers) {\n            Counters counters = worker.getCounters();\n            num_sp_calls += counters.num_sp_calls;\n            num_puts += counters.num_puts;\n            num_gets += counters.num_gets;\n            put_value_uncompressed_bytes += counters.put_value_uncompressed_bytes;\n            put_value_compressed_bytes += counters.put_value_compressed_bytes;\n        }\n\n        try {\n            voltclient.drain();\n        } catch (InterruptedException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        } catch (NoConnectionsException e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        if (num_puts == 0) { num_puts = 1; };\n        if (num_gets == 0) { num_gets = 1; };\n        if (put_value_uncompressed_bytes == 0) { put_value_uncompressed_bytes = 1; };\n        if (get_value_uncompressed_bytes.get() == 0) { get_value_uncompressed_bytes.set(1); };\n        if (tot_executions_latency == 0) { tot_executions_latency = 1; };\n        if (elapsedTimeSec == 0) { elapsedTimeSec = 1; };\n\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\"Checking Results - Get/Put Benchmark\"));\n        m_logger.info(String.format(\"*************************************************************************\"));\n        m_logger.info(String.format(\" - System ran for %12.4f seconds\",elapsedTimeSec));\n        m_logger.info(String.format(\" - Transactions / GETS / PUTS   = %,d / %,d / %,d\",num_sp_calls, num_gets, num_puts));\n        m_logger.info(String.format(\" - Transactions per second = %,.2f\",num_sp_calls / elapsedTimeSec));\n        m_logger.info(String.format(\" -         GETS per second = %,.2f\",num_gets / elapsedTimeSec));\n        m_logger.info(String.format(\" -         PUTS per second = %,.2f\",num_puts / elapsedTimeSec));\n        m_logger.info(String.format(\" - PUTS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",put_value_uncompressed_bytes,put_value_compressed_bytes,((double) put_value_compressed_bytes / put_value_uncompressed_bytes) * 100.0, (double) put_value_uncompressed_bytes / num_puts));\n        m_logger.info(String.format(\" - GETS Uncompressed Bytes / Compressed Bytes / Compressed Size / Avg Value Size Bytes = %,d / %,d / %,.2f%% / %,.2f\",get_value_uncompressed_bytes.get(),get_value_compressed_bytes,(get_value_compressed_bytes / (double) get_value_uncompressed_bytes.get()) * 100.0, (double) get_value_uncompressed_bytes.get() / num_gets));\n        m_logger.info(String.format(\" - Average Latency = %.2f ms\",((double) tot_execution_milliseconds / (double) tot_executions_latency)));\n        m_logger.info(String.format(\" -   Latency   0ms -  25ms = %,d\",latency_counter[0]));\n        m_logger.info(String.format(\" -   Latency  25ms -  50ms = %,d\",latency_counter[1]));\n        m_logger.info(String.format(\" -   Latency  50ms -  75ms = %,d\",latency_counter[2]));\n        m_logger.info(String.format(\" -   Latency  75ms - 100ms = %,d\",latency_counter[3]));\n        m_logger.info(String.format(\" -   Latency 100ms - 125ms = %,d\",latency_counter[4]));\n        m_logger.info(String.format(\" -   Latency 125ms - 150ms = %,d\",latency_counter[5]));\n        m_logger.info(String.format(\" -   Latency 150ms - 175ms = %,d\",latency_counter[6]));\n        m_logger.info(String.format(\" -   Latency 175ms - 200ms = %,d\",latency_counter[7]));\n        m_logger.info(String.format(\" -   Latency 200ms+        = %,d\",latency_counter[8]));\n\n        try {\n            voltclient.close();\n        } catch (Exception e) {\n            m_logger.error(e.toString());\n            System.exit(-1);\n        }\n    }","commit_id":"5db533eb8c5b85c32102f813e166cb86396a5d8c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        if (args.length != 11) {\n            System.err.println(\"ClientVoter [number of contestants] [votes per phone number] \" +\n                    \"[transactions per second] [client feedback interval (seconds)] \" +\n                    \"[test duration (seconds)] [lag record delay (seconds)] [server list (comma separated)] [auto-tuning] [target latency ms] [adjustment rate] [adjustment interval]\");\n            System.exit(1);\n        }\n\n        int maxContestant = Integer.valueOf(args[0]);\n        if ((maxContestant < 1) || (maxContestant > 12)) {\n            System.err.println(\"Number of contestants must be between 1 and 12\");\n            System.exit(1);\n        }\n\n        long maxVotesPerPhoneNumber = Long.valueOf(args[1]);\n        long transactions_per_second_requested = Long.valueOf(args[2]);\n        long transactions_per_second = transactions_per_second_requested;\n        long transactions_per_milli = transactions_per_second / 1000l;\n        long client_feedback_interval_secs = Long.valueOf(args[3]);\n        long test_duration_secs = Long.valueOf(args[4]);\n        long lag_latency_seconds = Long.valueOf(args[5]);\n        String serverList = args[6];\n        long lag_latency_millis = lag_latency_seconds * 1000l;\n        long thisOutstanding = 0;\n        long lastOutstanding = 0;\n\n        boolean use_auto_tuning = Boolean.valueOf(args[7]) && (transactions_per_second > 1000);\n        double auto_tuning_target_latency_millis = Double.valueOf(args[8]);\n        double auto_tuning_adjustment_rate = Double.valueOf(args[9]);\n        if (auto_tuning_adjustment_rate > 1.0) {\n            auto_tuning_adjustment_rate = auto_tuning_adjustment_rate / 100.0;\n        }\n        long auto_tuning_interval_secs = Long.valueOf(args[10]);\n\n        String contestantNameList = \"Edwina Burnam,Tabatha Gehling,Kelly Clauss,Jessie Alloway,Alana Bregman,Jessie Eichman,Allie Rogalski,Nita Coster,Kurt Walser,Ericka Dieter,Loraine NygrenTania Mattioli\";\n        String[] contestantNames = contestantNameList.split(\",\");\n\n        System.out.printf(\"Allowing %d votes per phone number\\n\",maxVotesPerPhoneNumber);\n        System.out.printf(\"Submitting %,d Transactions/sec (TPS)\\n\",transactions_per_second);\n        System.out.printf(\"Feedback interval = %,d second(s)\\n\",client_feedback_interval_secs);\n        System.out.printf(\"Running for %,d second(s)\\n\",test_duration_secs);\n        System.out.printf(\"Latency not recorded for %d second(s)\\n\",lag_latency_seconds);\n        if (use_auto_tuning) {\n            System.out.println(\"Auto-Tuning = ON\");\n            System.out.printf(\" - Tuning interval = %,d second(s)\\n\", auto_tuning_interval_secs);\n            System.out.printf(\" - Target latency = %.2f ms\\n\", auto_tuning_target_latency_millis);\n            System.out.printf(\" - Adjustment rate = %.2f%%\\n\", auto_tuning_adjustment_rate * 100.0);\n        }\n\n        long phoneNumber;\n        byte contestantNumber;\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        ClientConfig config = new ClientConfig(\"program\", \"none\");\n        /*\n         * Allow a large number of outstanding txns in order to be able to drive a large\n         * cluster. Config must be modified before instantiating the client.\n         */\n        config.setMaxOutstandingTxns(6000);\n        final org.voltdb.client.Client voltclient = ClientFactory.createClient(config);\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers) {\n            try {\n                thisServer = thisServer.trim();\n                System.out.printf(\"Connecting to server: '%s'\\n\",thisServer);\n\n                voltclient.createConnection(thisServer);\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        }\n\n        try {\n            /*\n             * Initialize the database if this is the first connecting client,\n             *  otherwise get existing configuration information\n             */\n            VoltTable[] vtInitialize =\n                voltclient.callProcedure(\"Initialize\", maxContestant, contestantNameList, areaCodes, states).getResults();\n            maxContestant = (int) vtInitialize[0].fetchRow(0).getLong(0);\n            System.out.printf(\"Running for %d contestant(s)\\n\",maxContestant);\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        long lastAutoTuningTime = startTime;\n        long num_sp_calls = 0;\n        long cycle_num_sp_calls = 0;\n        long startRecordingLatency = startTime + lag_latency_millis;\n        int callIdx = 0;\n\n        AsyncCallback callBack = new AsyncCallback();\n\n        for(int i=0;i<votingMap.length;i++)\n            votingMap[i] = (short)(((rand.nextInt(maxContestant) * rand.nextInt(maxContestant) + (int)Math.floor(100*Math.sin((double)i))) % maxContestant) + 1);\n\n        while (endTime > currentTime) {\n            num_sp_calls++;\n            cycle_num_sp_calls++;\n            callIdx = (rand.nextInt(areaCodes.length) * rand.nextInt(areaCodes.length)) % areaCodes.length;\n            phoneNumber = areaCodes[callIdx]*10000000l + (Math.abs(rand.nextLong()) % 9999999l);\n            contestantNumber = (byte)(rand.nextInt(100) > 40 ? votingMap[callIdx] : ((rand.nextInt(maxContestant) % maxContestant) + 1));\n            if ((num_sp_calls % 100) == 0) {\n                // introduce a potentially bad contestant number every 100 votes\n                contestantNumber = (byte)((rand.nextInt(maxContestant) + 1) * 2);\n            }\n\n            try {\n                voltclient.callProcedure(callBack, \"Vote\", phoneNumber, contestantNumber, maxVotesPerPhoneNumber);\n            } catch (java.io.IOException e) {\n                e.printStackTrace();\n                if (e instanceof NoConnectionsException) {\n                    System.exit(-1);\n                }\n            }\n\n            transactions_this_second++;\n            if (transactions_this_second >= transactions_per_milli) {\n                this_millisecond = System.currentTimeMillis();\n                while (this_millisecond <= last_millisecond) {\n                    this_millisecond = System.currentTimeMillis();\n                }\n                last_millisecond = this_millisecond;\n                transactions_this_second = 0;\n            }\n\n            currentTime = System.currentTimeMillis();\n\n            if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                // time to start recording latency information\n                checkLatency = true;\n            }\n\n            if (use_auto_tuning && (currentTime >= (lastAutoTuningTime + (auto_tuning_interval_secs * 1000)))) {\n\n                long cycle_elapsedTimeMillis2 = System.currentTimeMillis()-lastAutoTuningTime;\n                float cycle_elapsedTimeSec2 = cycle_elapsedTimeMillis2/1000F;\n                lastAutoTuningTime = currentTime;\n\n                counterLock.lock();\n                try {\n                    // Only adjust if both the cycle and total was below request - avoid *some* random spike from downgrading the system too much\n                    if ((((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) > auto_tuning_target_latency_millis) && (((double) tot_execution_milliseconds / (double) tot_executions_latency) > auto_tuning_target_latency_millis))\n                    {\n                        long new_transactions_per_second = (((long)(Math.min(cycle_num_sp_calls / cycle_elapsedTimeSec2,transactions_per_second) * auto_tuning_adjustment_rate))/1000l)*1000l;\n                        String last_tuning_warning = \"\";\n                        if ((new_transactions_per_second <= 1000) || (new_transactions_per_second == transactions_per_second)) {\n                            use_auto_tuning = false;\n                            last_tuning_warning = \" | WARNING: Minimum load boundary reached.\";\n                        }\n\n                        System.out.printf(\"Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting DOWN: %,d TPS%s\\n\"\n                                         , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                         , cycle_min_execution_milliseconds\n                                         , cycle_max_execution_milliseconds\n                                         , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                         , new_transactions_per_second\n                                         , last_tuning_warning\n                                         );\n                        transactions_per_second = new_transactions_per_second;\n                        transactions_per_milli = transactions_per_second/1000l;\n                    }\n                    else if (((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) < 0.9d*auto_tuning_target_latency_millis)\n                    {\n                        long new_transactions_per_second = ((long)Math.max(1.05d*transactions_per_second, (double)(cycle_num_sp_calls / cycle_elapsedTimeSec2))/1000l) *1000l;\n                        if (new_transactions_per_second > transactions_per_second_requested)\n                            new_transactions_per_second = transactions_per_second_requested;\n                        if (new_transactions_per_second > transactions_per_second)\n                        {\n                            System.out.printf(\"Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting UP: %,d TPS\\n\"\n                                             , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                             , cycle_min_execution_milliseconds\n                                             , cycle_max_execution_milliseconds\n                                             , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                             , new_transactions_per_second\n                                             );\n                            transactions_per_second = new_transactions_per_second;\n                            transactions_per_milli = transactions_per_second/1000l;\n                        }\n                    }\n                    cycle_num_sp_calls = 0;\n\n                    cycle_min_execution_milliseconds = 999999999l;\n                    cycle_max_execution_milliseconds = -1l;\n                    cycle_tot_execution_milliseconds = 0;\n                    cycle_tot_executions_latency = 0;\n                } finally {\n                    counterLock.unlock();\n                }\n            }\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                final long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                lastFeedbackTime = currentTime;\n\n                final long runTimeMillis = endTime - startTime;\n\n                float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n                if (tot_executions_latency == 0) {\n                    tot_executions_latency = 1;\n                }\n\n                double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                if (percentComplete > 100.0) {\n                    percentComplete = 100.0;\n                }\n\n                counterLock.lock();\n                try {\n                    thisOutstanding = num_sp_calls - tot_executions;\n\n                    double avgLatency = (double) tot_execution_milliseconds / (double) tot_executions_latency;\n\n                    System.out.printf(\"%.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f\\n\",percentComplete, num_sp_calls, (num_sp_calls / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, avgLatency);\n\n                    lastOutstanding = thisOutstanding;\n                } finally {\n                    counterLock.unlock();\n                }\n            }\n        }\n\n        try {\n            voltclient.drain();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"Voting Results\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Accepted votes = %,d\\n\",vote_result_counter[0]);\n        System.out.printf(\" - Rejected votes (invalid contestant) = %,d\\n\",vote_result_counter[1]);\n        System.out.printf(\" - Rejected votes (voter over limit) = %,d\\n\\n\",vote_result_counter[2]);\n\n        String winnerName = \"<<UNKNOWN>>\";\n        int winnerId = 0;\n\n        try {\n            VoltTable[] vtResults = voltclient.callProcedure(\"Results\").getResults();\n\n            int rowCount = vtResults[0].getRowCount();\n            if (rowCount == 0) {\n                System.out.println(\" - No results to report.\");\n            } else {\n                for (int ii = 0; ii < rowCount; ii++) {\n                    VoltTableRow row = vtResults[0].fetchRow(ii);\n                    String resultName = row.getString(0);\n                    winnerId = (int)row.getLong(1);\n                    long resultVotes = row.getLong(2);\n                    System.out.printf(\" - Contestant %s received %,d vote(s)\\n\",resultName,resultVotes);\n                    winnerName = resultName;\n                }\n            }\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        System.out.printf(\"\\n - Contestant %s was the winner.\\n\",winnerName);\n\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"System Statistics\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Ran for %,.2f seconds\\n\",elapsedTimeSec);\n        System.out.printf(\" - Performed %,d Stored Procedure calls\\n\",num_sp_calls);\n        System.out.printf(\" - At %,.2f calls per second\\n\",num_sp_calls / elapsedTimeSec);\n        System.out.printf(\" - Average Latency = %.2f ms\\n\",((double) tot_execution_milliseconds / (double) tot_executions_latency));\n        System.out.printf(\" -   Latency   0ms -  25ms = %,d\\n\",latency_counter[0]);\n        System.out.printf(\" -   Latency  25ms -  50ms = %,d\\n\",latency_counter[1]);\n        System.out.printf(\" -   Latency  50ms -  75ms = %,d\\n\",latency_counter[2]);\n        System.out.printf(\" -   Latency  75ms - 100ms = %,d\\n\",latency_counter[3]);\n        System.out.printf(\" -   Latency 100ms - 125ms = %,d\\n\",latency_counter[4]);\n        System.out.printf(\" -   Latency 125ms - 150ms = %,d\\n\",latency_counter[5]);\n        System.out.printf(\" -   Latency 150ms - 175ms = %,d\\n\",latency_counter[6]);\n        System.out.printf(\" -   Latency 175ms - 200ms = %,d\\n\",latency_counter[7]);\n        System.out.printf(\" -   Latency 200ms+        = %,d\\n\",latency_counter[8]);\n        if (transactions_per_second < transactions_per_second_requested) {\n            System.out.println(\"*************************************************************************\");\n            System.out.println(\"Auto-Tuning Results\");\n            System.out.println(\"*************************************************************************\");\n            System.out.printf(\" - Optimal Load: %,d TPS to match/approach desired %.2f ms Latency\\n\", transactions_per_second, auto_tuning_target_latency_millis);\n        }\n\n        try {\n            voltclient.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }","id":9822,"modified_method":"public static void main(String args[]) {\n        if (args.length != 11) {\n            System.err.println(\"ClientVoter [number of contestants] [votes per phone number] \" +\n                    \"[transactions per second] [client feedback interval (seconds)] \" +\n                    \"[test duration (seconds)] [lag record delay (seconds)] [server list (comma separated)] [auto-tuning] [target latency ms] [adjustment rate] [adjustment interval]\");\n            System.exit(1);\n        }\n\n        int maxContestant = Integer.valueOf(args[0]);\n        if ((maxContestant < 1) || (maxContestant > 12)) {\n            System.err.println(\"Number of contestants must be between 1 and 12\");\n            System.exit(1);\n        }\n\n        long maxVotesPerPhoneNumber = Long.valueOf(args[1]);\n        long transactions_per_second_requested = Long.valueOf(args[2]);\n        long transactions_per_second = transactions_per_second_requested;\n        long transactions_per_milli = transactions_per_second / 1000l;\n        long client_feedback_interval_secs = Long.valueOf(args[3]);\n        long test_duration_secs = Long.valueOf(args[4]);\n        long lag_latency_seconds = Long.valueOf(args[5]);\n        String serverList = args[6];\n        long lag_latency_millis = lag_latency_seconds * 1000l;\n        long thisOutstanding = 0;\n        long lastOutstanding = 0;\n\n        boolean use_auto_tuning = Boolean.valueOf(args[7]) && (transactions_per_second > 1000);\n        double auto_tuning_target_latency_millis = Double.valueOf(args[8]);\n        double auto_tuning_adjustment_rate = Double.valueOf(args[9]);\n        if (auto_tuning_adjustment_rate > 1.0) {\n            auto_tuning_adjustment_rate = auto_tuning_adjustment_rate / 100.0;\n        }\n        long auto_tuning_interval_secs = Long.valueOf(args[10]);\n\n        String contestantNameList = \"Edwina Burnam,Tabatha Gehling,Kelly Clauss,Jessie Alloway,Alana Bregman,Jessie Eichman,Allie Rogalski,Nita Coster,Kurt Walser,Ericka Dieter,Loraine NygrenTania Mattioli\";\n        String[] contestantNames = contestantNameList.split(\",\");\n\n        System.out.printf(\"Allowing %d votes per phone number\\n\",maxVotesPerPhoneNumber);\n        System.out.printf(\"Submitting %,d Transactions/sec (TPS)\\n\",transactions_per_second);\n        System.out.printf(\"Feedback interval = %,d second(s)\\n\",client_feedback_interval_secs);\n        System.out.printf(\"Running for %,d second(s)\\n\",test_duration_secs);\n        System.out.printf(\"Latency not recorded for %d second(s)\\n\",lag_latency_seconds);\n        if (use_auto_tuning) {\n            System.out.println(\"Auto-Tuning = ON\");\n            System.out.printf(\" - Tuning interval = %,d second(s)\\n\", auto_tuning_interval_secs);\n            System.out.printf(\" - Target latency = %.2f ms\\n\", auto_tuning_target_latency_millis);\n            System.out.printf(\" - Adjustment rate = %.2f%%\\n\", auto_tuning_adjustment_rate * 100.0);\n        }\n\n        long phoneNumber;\n        byte contestantNumber;\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        ClientConfig config = new ClientConfig(\"program\", \"none\");\n        /*\n         * Allow a large number of outstanding txns in order to be able to drive a large\n         * cluster. Config must be modified before instantiating the client.\n         */\n        config.setMaxOutstandingTxns(6000);\n        final org.voltdb.client.Client voltclient = ClientFactory.createClient(config);\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers)\n        {\n            thisServer = thisServer.trim();\n            System.out.printf(\"Connecting to server: '%s'\\n\",thisServer);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    voltclient.createConnection(thisServer);\n                    break;\n                } catch (IOException e) {\n                    System.out.println(\"Connection failed - retrying in \" + (sleep/1000) + \" second(s).\");\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n        }\n\n        try {\n            /*\n             * Initialize the database if this is the first connecting client,\n             *  otherwise get existing configuration information\n             */\n            VoltTable[] vtInitialize =\n                voltclient.callProcedure(\"Initialize\", maxContestant, contestantNameList, areaCodes, states).getResults();\n            maxContestant = (int) vtInitialize[0].fetchRow(0).getLong(0);\n            System.out.printf(\"Running for %d contestant(s)\\n\",maxContestant);\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        long lastAutoTuningTime = startTime;\n        long num_sp_calls = 0;\n        long cycle_num_sp_calls = 0;\n        long startRecordingLatency = startTime + lag_latency_millis;\n        int callIdx = 0;\n\n        AsyncCallback callBack = new AsyncCallback();\n\n        for(int i=0;i<votingMap.length;i++)\n            votingMap[i] = (short)(((rand.nextInt(maxContestant) * rand.nextInt(maxContestant) + (int)Math.floor(100*Math.sin((double)i))) % maxContestant) + 1);\n\n        while (endTime > currentTime) {\n            num_sp_calls++;\n            cycle_num_sp_calls++;\n            callIdx = (rand.nextInt(areaCodes.length) * rand.nextInt(areaCodes.length)) % areaCodes.length;\n            phoneNumber = areaCodes[callIdx]*10000000l + (Math.abs(rand.nextLong()) % 9999999l);\n            contestantNumber = (byte)(rand.nextInt(100) > 40 ? votingMap[callIdx] : ((rand.nextInt(maxContestant) % maxContestant) + 1));\n            if ((num_sp_calls % 100) == 0) {\n                // introduce a potentially bad contestant number every 100 votes\n                contestantNumber = (byte)((rand.nextInt(maxContestant) + 1) * 2);\n            }\n\n            try {\n                voltclient.callProcedure(callBack, \"Vote\", phoneNumber, contestantNumber, maxVotesPerPhoneNumber);\n            } catch (java.io.IOException e) {\n                e.printStackTrace();\n                if (e instanceof NoConnectionsException) {\n                    System.exit(-1);\n                }\n            }\n\n            transactions_this_second++;\n            if (transactions_this_second >= transactions_per_milli) {\n                this_millisecond = System.currentTimeMillis();\n                while (this_millisecond <= last_millisecond) {\n                    this_millisecond = System.currentTimeMillis();\n                }\n                last_millisecond = this_millisecond;\n                transactions_this_second = 0;\n            }\n\n            currentTime = System.currentTimeMillis();\n\n            if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                // time to start recording latency information\n                checkLatency = true;\n            }\n\n            if (use_auto_tuning && (currentTime >= (lastAutoTuningTime + (auto_tuning_interval_secs * 1000)))) {\n\n                long cycle_elapsedTimeMillis2 = System.currentTimeMillis()-lastAutoTuningTime;\n                float cycle_elapsedTimeSec2 = cycle_elapsedTimeMillis2/1000F;\n                lastAutoTuningTime = currentTime;\n\n                counterLock.lock();\n                try {\n                    // Only adjust if both the cycle and total was below request - avoid *some* random spike from downgrading the system too much\n                    if ((((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) > auto_tuning_target_latency_millis) && (((double) tot_execution_milliseconds / (double) tot_executions_latency) > auto_tuning_target_latency_millis))\n                    {\n                        long new_transactions_per_second = (((long)(Math.min(cycle_num_sp_calls / cycle_elapsedTimeSec2,transactions_per_second) * auto_tuning_adjustment_rate))/1000l)*1000l;\n                        String last_tuning_warning = \"\";\n                        if ((new_transactions_per_second <= 1000) || (new_transactions_per_second == transactions_per_second)) {\n                            use_auto_tuning = false;\n                            last_tuning_warning = \" | WARNING: Minimum load boundary reached.\";\n                        }\n\n                        System.out.printf(\"Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting DOWN: %,d TPS%s\\n\"\n                                         , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                         , cycle_min_execution_milliseconds\n                                         , cycle_max_execution_milliseconds\n                                         , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                         , new_transactions_per_second\n                                         , last_tuning_warning\n                                         );\n                        transactions_per_second = new_transactions_per_second;\n                        transactions_per_milli = transactions_per_second/1000l;\n                    }\n                    else if (((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency) < 0.9d*auto_tuning_target_latency_millis)\n                    {\n                        long new_transactions_per_second = ((long)Math.max(1.05d*transactions_per_second, (double)(cycle_num_sp_calls / cycle_elapsedTimeSec2))/1000l) *1000l;\n                        if (new_transactions_per_second > transactions_per_second_requested)\n                            new_transactions_per_second = transactions_per_second_requested;\n                        if (new_transactions_per_second > transactions_per_second)\n                        {\n                            System.out.printf(\"Auto-Tuning | Observed: %,.2f TPS | Latency: min = %d | max = %d | avg = %.2f | Adjusting UP: %,d TPS\\n\"\n                                             , (cycle_num_sp_calls / cycle_elapsedTimeSec2)\n                                             , cycle_min_execution_milliseconds\n                                             , cycle_max_execution_milliseconds\n                                             , ((double) cycle_tot_execution_milliseconds / (double) cycle_tot_executions_latency)\n                                             , new_transactions_per_second\n                                             );\n                            transactions_per_second = new_transactions_per_second;\n                            transactions_per_milli = transactions_per_second/1000l;\n                        }\n                    }\n                    cycle_num_sp_calls = 0;\n\n                    cycle_min_execution_milliseconds = 999999999l;\n                    cycle_max_execution_milliseconds = -1l;\n                    cycle_tot_execution_milliseconds = 0;\n                    cycle_tot_executions_latency = 0;\n                } finally {\n                    counterLock.unlock();\n                }\n            }\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                final long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                lastFeedbackTime = currentTime;\n\n                final long runTimeMillis = endTime - startTime;\n\n                float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n                if (tot_executions_latency == 0) {\n                    tot_executions_latency = 1;\n                }\n\n                double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                if (percentComplete > 100.0) {\n                    percentComplete = 100.0;\n                }\n\n                counterLock.lock();\n                try {\n                    thisOutstanding = num_sp_calls - tot_executions;\n\n                    double avgLatency = (double) tot_execution_milliseconds / (double) tot_executions_latency;\n\n                    System.out.printf(\"%.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f\\n\",percentComplete, num_sp_calls, (num_sp_calls / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, avgLatency);\n\n                    lastOutstanding = thisOutstanding;\n                } finally {\n                    counterLock.unlock();\n                }\n            }\n        }\n\n        try {\n            voltclient.drain();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"Voting Results\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Accepted votes = %,d\\n\",vote_result_counter[0]);\n        System.out.printf(\" - Rejected votes (invalid contestant) = %,d\\n\",vote_result_counter[1]);\n        System.out.printf(\" - Rejected votes (voter over limit) = %,d\\n\\n\",vote_result_counter[2]);\n\n        String winnerName = \"<<UNKNOWN>>\";\n        int winnerId = 0;\n\n        try {\n            VoltTable[] vtResults = voltclient.callProcedure(\"Results\").getResults();\n\n            int rowCount = vtResults[0].getRowCount();\n            if (rowCount == 0) {\n                System.out.println(\" - No results to report.\");\n            } else {\n                for (int ii = 0; ii < rowCount; ii++) {\n                    VoltTableRow row = vtResults[0].fetchRow(ii);\n                    String resultName = row.getString(0);\n                    winnerId = (int)row.getLong(1);\n                    long resultVotes = row.getLong(2);\n                    System.out.printf(\" - Contestant %s received %,d vote(s)\\n\",resultName,resultVotes);\n                    winnerName = resultName;\n                }\n            }\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        System.out.printf(\"\\n - Contestant %s was the winner.\\n\",winnerName);\n\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"System Statistics\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Ran for %,.2f seconds\\n\",elapsedTimeSec);\n        System.out.printf(\" - Performed %,d Stored Procedure calls\\n\",num_sp_calls);\n        System.out.printf(\" - At %,.2f calls per second\\n\",num_sp_calls / elapsedTimeSec);\n        System.out.printf(\" - Average Latency = %.2f ms\\n\",((double) tot_execution_milliseconds / (double) tot_executions_latency));\n        System.out.printf(\" -   Latency   0ms -  25ms = %,d\\n\",latency_counter[0]);\n        System.out.printf(\" -   Latency  25ms -  50ms = %,d\\n\",latency_counter[1]);\n        System.out.printf(\" -   Latency  50ms -  75ms = %,d\\n\",latency_counter[2]);\n        System.out.printf(\" -   Latency  75ms - 100ms = %,d\\n\",latency_counter[3]);\n        System.out.printf(\" -   Latency 100ms - 125ms = %,d\\n\",latency_counter[4]);\n        System.out.printf(\" -   Latency 125ms - 150ms = %,d\\n\",latency_counter[5]);\n        System.out.printf(\" -   Latency 150ms - 175ms = %,d\\n\",latency_counter[6]);\n        System.out.printf(\" -   Latency 175ms - 200ms = %,d\\n\",latency_counter[7]);\n        System.out.printf(\" -   Latency 200ms+        = %,d\\n\",latency_counter[8]);\n        if (transactions_per_second < transactions_per_second_requested) {\n            System.out.println(\"*************************************************************************\");\n            System.out.println(\"Auto-Tuning Results\");\n            System.out.println(\"*************************************************************************\");\n            System.out.printf(\" - Optimal Load: %,d TPS to match/approach desired %.2f ms Latency\\n\", transactions_per_second, auto_tuning_target_latency_millis);\n        }\n\n        try {\n            voltclient.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }","commit_id":"5db533eb8c5b85c32102f813e166cb86396a5d8c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String args[]) {\n        if (args.length != 7) {\n            System.err.println(\"ClientVoter [number of contestants] [votes per phone number] \" +\n                    \"[transactions per second] [client feedback interval (seconds)] \" +\n                    \"[test duration (seconds)] [lag record delay (seconds)] [server list (comma separated)]\");\n            System.exit(1);\n        }\n\n        int maxContestant = Integer.valueOf(args[0]);\n        if ((maxContestant < 1) || (maxContestant > 12)) {\n            System.err.println(\"Number of contestants must be between 1 and 12\");\n            System.exit(1);\n        }\n\n        long maxVotesPerPhoneNumber = Long.valueOf(args[1]);\n        long transactions_per_second = Long.valueOf(args[2]);\n        long transactions_per_milli = transactions_per_second / 1000l;\n        long client_feedback_interval_secs = Long.valueOf(args[3]);\n        long test_duration_secs = Long.valueOf(args[4]);\n        long lag_latency_seconds = Long.valueOf(args[5]);\n        String serverList = args[6];\n        long lag_latency_millis = lag_latency_seconds * 1000l;\n        long thisOutstanding = 0;\n        long lastOutstanding = 0;\n\n        String contestantNameList = \"Edwina Burnam,Tabatha Gehling,Kelly Clauss,Jessie Alloway,Alana Bregman,Jessie Eichman,Allie Rogalski,Nita Coster,Kurt Walser,Ericka Dieter,Loraine NygrenTania Mattioli\";\n        String[] contestantNames = contestantNameList.split(\",\");\n\n        System.out.printf(\"Allowing %d votes per phone number\\n\",maxVotesPerPhoneNumber);\n        System.out.printf(\"Submitting %,d Transactions/sec (TPS)\\n\",transactions_per_second);\n        System.out.printf(\"Feedback interval = %,d second(s)\\n\",client_feedback_interval_secs);\n        System.out.printf(\"Running for %,d second(s)\\n\",test_duration_secs);\n        System.out.printf(\"Latency not recorded for %d second(s)\\n\",lag_latency_seconds);\n\n        long phoneNumber;\n        byte contestantNumber;\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        ClientConfig config = new ClientConfig(\"program\", \"none\");\n        /*\n         * Allow a large number of outstanding txns in order to be able to drive a large\n         * cluster. Config must be modified before instantiating the client.\n         */\n        config.setMaxOutstandingTxns(6000);\n        final org.voltdb.client.Client voltclient = ClientFactory.createClient(config);\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers) {\n            try {\n                thisServer = thisServer.trim();\n                System.out.printf(\"Connecting to server: '%s'\\n\",thisServer);\n\n                voltclient.createConnection(thisServer, 21212);\n            } catch (IOException e) {\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        }\n\n        try {\n            /*\n             * Initialize the database if this is the first connecting client,\n             *  otherwise get existing configuration information\n             */\n            VoltTable[] vtInitialize =\n                voltclient.callProcedure(\"Initialize\", maxContestant, contestantNameList, areaCodes, states).getResults();\n            maxContestant = (int) vtInitialize[0].fetchRow(0).getLong(0);\n            System.out.printf(\"Running for %d contestant(s)\\n\",maxContestant);\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        long lastAutoTuningTime = startTime;\n        long num_sp_calls = 0;\n        long startRecordingLatency = startTime + lag_latency_millis;\n        int callIdx = 0;\n\n        for(int i=0;i<votingMap.length;i++)\n            votingMap[i] = (short)(((rand.nextInt(maxContestant) * rand.nextInt(maxContestant) + (int)Math.floor(100*Math.sin((double)i))) % maxContestant) + 1);\n\n        while (endTime > currentTime) {\n            num_sp_calls++;\n            callIdx = (rand.nextInt(areaCodes.length) * rand.nextInt(areaCodes.length)) % areaCodes.length;\n            phoneNumber = areaCodes[callIdx]*10000000l + (Math.abs(rand.nextLong()) % 9999999l);\n            contestantNumber = (byte)(rand.nextInt(100) > 40 ? votingMap[callIdx] : ((rand.nextInt(maxContestant) % maxContestant) + 1));\n            if ((num_sp_calls % 100) == 0) {\n                // introduce a potentially bad contestant number every 100 votes\n                contestantNumber = (byte)((rand.nextInt(maxContestant) + 1) * 2);\n            }\n\n            try {\n                ClientResponse clientResponse = voltclient.callProcedure(\"Vote\", phoneNumber, contestantNumber, maxVotesPerPhoneNumber);\n                final byte status = clientResponse.getStatus();\n                if (status != ClientResponse.SUCCESS) {\n                    System.err.println(\"Failed to execute!!!\");\n                    System.err.println(clientResponse.getStatusString());\n                    System.err.println(clientResponse.getException());\n                    System.exit(-1);\n                } else {\n                    tot_executions++;\n                    VoltTable vtResults[] = clientResponse.getResults();\n                    int vote_result = (int) vtResults[0].fetchRow(0).getLong(0);\n\n                    vote_result_counter[vote_result]++;\n\n                    if (checkLatency) {\n                        long execution_time =  clientResponse.getClientRoundtrip();\n\n                        tot_executions_latency++;\n                        tot_execution_milliseconds += execution_time;\n\n                        if (execution_time < min_execution_milliseconds) {\n                            min_execution_milliseconds = execution_time;\n                        }\n\n                        if (execution_time > max_execution_milliseconds) {\n                            max_execution_milliseconds = execution_time;\n                        }\n\n                        // change latency to bucket\n                        int latency_bucket = (int) (execution_time / 25l);\n                        if (latency_bucket > 8) {\n                            latency_bucket = 8;\n                        }\n                        latency_counter[latency_bucket]++;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                if (e instanceof NoConnectionsException) {\n                    System.exit(-1);\n                }\n            }\n\n            transactions_this_second++;\n            if (transactions_this_second >= transactions_per_milli) {\n                this_millisecond = System.currentTimeMillis();\n                while (this_millisecond <= last_millisecond) {\n                    this_millisecond = System.currentTimeMillis();\n                }\n                last_millisecond = this_millisecond;\n                transactions_this_second = 0;\n            }\n\n            currentTime = System.currentTimeMillis();\n\n            if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                // time to start recording latency information\n                checkLatency = true;\n            }\n\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                final long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                lastFeedbackTime = currentTime;\n\n                final long runTimeMillis = endTime - startTime;\n\n                float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n                if (tot_executions_latency == 0) {\n                    tot_executions_latency = 1;\n                }\n\n                double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                if (percentComplete > 100.0) {\n                    percentComplete = 100.0;\n                }\n\n                thisOutstanding = num_sp_calls - tot_executions;\n\n                double avgLatency = (double) tot_execution_milliseconds / (double) tot_executions_latency;\n\n                System.out.printf(\"%.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f\\n\",percentComplete, num_sp_calls, (num_sp_calls / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, avgLatency);\n\n                lastOutstanding = thisOutstanding;\n            }\n        }\n\n        try {\n            voltclient.drain();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"Voting Results\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Accepted votes = %,d\\n\",vote_result_counter[0]);\n        System.out.printf(\" - Rejected votes (invalid contestant) = %,d\\n\",vote_result_counter[1]);\n        System.out.printf(\" - Rejected votes (voter over limit) = %,d\\n\\n\",vote_result_counter[2]);\n\n        String winnerName = \"<<UNKNOWN>>\";\n        int winnerId = 0;\n\n        try {\n            VoltTable[] vtResults = voltclient.callProcedure(\"Results\").getResults();\n\n            int rowCount = vtResults[0].getRowCount();\n            if (rowCount == 0) {\n                System.out.println(\" - No results to report.\");\n            } else {\n                for (int ii = 0; ii < rowCount; ii++) {\n                    VoltTableRow row = vtResults[0].fetchRow(ii);\n                    String resultName = row.getString(0);\n                    winnerId = (int)row.getLong(1);\n                    long resultVotes = row.getLong(2);\n                    System.out.printf(\" - Contestant %s received %,d vote(s)\\n\",resultName,resultVotes);\n                    winnerName = resultName;\n                }\n            }\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        System.out.printf(\"\\n - Contestant %s was the winner.\\n\",winnerName);\n\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"System Statistics\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Ran for %,.2f seconds\\n\",elapsedTimeSec);\n        System.out.printf(\" - Performed %,d Stored Procedure calls\\n\",num_sp_calls);\n        System.out.printf(\" - At %,.2f calls per second\\n\",num_sp_calls / elapsedTimeSec);\n        System.out.printf(\" - Average Latency = %.2f ms\\n\",((double) tot_execution_milliseconds / (double) tot_executions_latency));\n        System.out.printf(\" -   Latency   0ms -  25ms = %,d\\n\",latency_counter[0]);\n        System.out.printf(\" -   Latency  25ms -  50ms = %,d\\n\",latency_counter[1]);\n        System.out.printf(\" -   Latency  50ms -  75ms = %,d\\n\",latency_counter[2]);\n        System.out.printf(\" -   Latency  75ms - 100ms = %,d\\n\",latency_counter[3]);\n        System.out.printf(\" -   Latency 100ms - 125ms = %,d\\n\",latency_counter[4]);\n        System.out.printf(\" -   Latency 125ms - 150ms = %,d\\n\",latency_counter[5]);\n        System.out.printf(\" -   Latency 150ms - 175ms = %,d\\n\",latency_counter[6]);\n        System.out.printf(\" -   Latency 175ms - 200ms = %,d\\n\",latency_counter[7]);\n        System.out.printf(\" -   Latency 200ms+        = %,d\\n\",latency_counter[8]);\n\n        try {\n            voltclient.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }","id":9823,"modified_method":"public static void main(String args[]) {\n        if (args.length != 7) {\n            System.err.println(\"ClientVoter [number of contestants] [votes per phone number] \" +\n                    \"[transactions per second] [client feedback interval (seconds)] \" +\n                    \"[test duration (seconds)] [lag record delay (seconds)] [server list (comma separated)]\");\n            System.exit(1);\n        }\n\n        int maxContestant = Integer.valueOf(args[0]);\n        if ((maxContestant < 1) || (maxContestant > 12)) {\n            System.err.println(\"Number of contestants must be between 1 and 12\");\n            System.exit(1);\n        }\n\n        long maxVotesPerPhoneNumber = Long.valueOf(args[1]);\n        long transactions_per_second = Long.valueOf(args[2]);\n        long transactions_per_milli = transactions_per_second / 1000l;\n        long client_feedback_interval_secs = Long.valueOf(args[3]);\n        long test_duration_secs = Long.valueOf(args[4]);\n        long lag_latency_seconds = Long.valueOf(args[5]);\n        String serverList = args[6];\n        long lag_latency_millis = lag_latency_seconds * 1000l;\n        long thisOutstanding = 0;\n        long lastOutstanding = 0;\n\n        String contestantNameList = \"Edwina Burnam,Tabatha Gehling,Kelly Clauss,Jessie Alloway,Alana Bregman,Jessie Eichman,Allie Rogalski,Nita Coster,Kurt Walser,Ericka Dieter,Loraine NygrenTania Mattioli\";\n        String[] contestantNames = contestantNameList.split(\",\");\n\n        System.out.printf(\"Allowing %d votes per phone number\\n\",maxVotesPerPhoneNumber);\n        System.out.printf(\"Submitting %,d Transactions/sec (TPS)\\n\",transactions_per_second);\n        System.out.printf(\"Feedback interval = %,d second(s)\\n\",client_feedback_interval_secs);\n        System.out.printf(\"Running for %,d second(s)\\n\",test_duration_secs);\n        System.out.printf(\"Latency not recorded for %d second(s)\\n\",lag_latency_seconds);\n\n        long phoneNumber;\n        byte contestantNumber;\n\n        long transactions_this_second = 0;\n        long last_millisecond = System.currentTimeMillis();\n        long this_millisecond = System.currentTimeMillis();\n\n        ClientConfig config = new ClientConfig(\"program\", \"none\");\n        /*\n         * Allow a large number of outstanding txns in order to be able to drive a large\n         * cluster. Config must be modified before instantiating the client.\n         */\n        config.setMaxOutstandingTxns(6000);\n        final org.voltdb.client.Client voltclient = ClientFactory.createClient(config);\n\n        String[] voltServers = serverList.split(\",\");\n\n        for (String thisServer : voltServers)\n        {\n            thisServer = thisServer.trim();\n            System.out.printf(\"Connecting to server: '%s'\\n\",thisServer);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    voltclient.createConnection(thisServer);\n                    break;\n                } catch (IOException e) {\n                    System.out.println(\"Connection failed - retrying in \" + (sleep/1000) + \" second(s).\");\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n        }\n\n        try {\n            /*\n             * Initialize the database if this is the first connecting client,\n             *  otherwise get existing configuration information\n             */\n            VoltTable[] vtInitialize =\n                voltclient.callProcedure(\"Initialize\", maxContestant, contestantNameList, areaCodes, states).getResults();\n            maxContestant = (int) vtInitialize[0].fetchRow(0).getLong(0);\n            System.out.printf(\"Running for %d contestant(s)\\n\",maxContestant);\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        java.util.Random rand = new java.util.Random();\n\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + (1000l * test_duration_secs);\n        long currentTime = startTime;\n        long lastFeedbackTime = startTime;\n        long lastAutoTuningTime = startTime;\n        long num_sp_calls = 0;\n        long startRecordingLatency = startTime + lag_latency_millis;\n        int callIdx = 0;\n\n        for(int i=0;i<votingMap.length;i++)\n            votingMap[i] = (short)(((rand.nextInt(maxContestant) * rand.nextInt(maxContestant) + (int)Math.floor(100*Math.sin((double)i))) % maxContestant) + 1);\n\n        while (endTime > currentTime) {\n            num_sp_calls++;\n            callIdx = (rand.nextInt(areaCodes.length) * rand.nextInt(areaCodes.length)) % areaCodes.length;\n            phoneNumber = areaCodes[callIdx]*10000000l + (Math.abs(rand.nextLong()) % 9999999l);\n            contestantNumber = (byte)(rand.nextInt(100) > 40 ? votingMap[callIdx] : ((rand.nextInt(maxContestant) % maxContestant) + 1));\n            if ((num_sp_calls % 100) == 0) {\n                // introduce a potentially bad contestant number every 100 votes\n                contestantNumber = (byte)((rand.nextInt(maxContestant) + 1) * 2);\n            }\n\n            try {\n                ClientResponse clientResponse = voltclient.callProcedure(\"Vote\", phoneNumber, contestantNumber, maxVotesPerPhoneNumber);\n                final byte status = clientResponse.getStatus();\n                if (status != ClientResponse.SUCCESS) {\n                    System.err.println(\"Failed to execute!!!\");\n                    System.err.println(clientResponse.getStatusString());\n                    System.err.println(clientResponse.getException());\n                    System.exit(-1);\n                } else {\n                    tot_executions++;\n                    VoltTable vtResults[] = clientResponse.getResults();\n                    int vote_result = (int) vtResults[0].fetchRow(0).getLong(0);\n\n                    vote_result_counter[vote_result]++;\n\n                    if (checkLatency) {\n                        long execution_time =  clientResponse.getClientRoundtrip();\n\n                        tot_executions_latency++;\n                        tot_execution_milliseconds += execution_time;\n\n                        if (execution_time < min_execution_milliseconds) {\n                            min_execution_milliseconds = execution_time;\n                        }\n\n                        if (execution_time > max_execution_milliseconds) {\n                            max_execution_milliseconds = execution_time;\n                        }\n\n                        // change latency to bucket\n                        int latency_bucket = (int) (execution_time / 25l);\n                        if (latency_bucket > 8) {\n                            latency_bucket = 8;\n                        }\n                        latency_counter[latency_bucket]++;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                if (e instanceof NoConnectionsException) {\n                    System.exit(-1);\n                }\n            }\n\n            transactions_this_second++;\n            if (transactions_this_second >= transactions_per_milli) {\n                this_millisecond = System.currentTimeMillis();\n                while (this_millisecond <= last_millisecond) {\n                    this_millisecond = System.currentTimeMillis();\n                }\n                last_millisecond = this_millisecond;\n                transactions_this_second = 0;\n            }\n\n            currentTime = System.currentTimeMillis();\n\n            if ((!checkLatency) && (currentTime >= startRecordingLatency)) {\n                // time to start recording latency information\n                checkLatency = true;\n            }\n\n            if (currentTime >= (lastFeedbackTime + (client_feedback_interval_secs * 1000))) {\n                final long elapsedTimeMillis2 = System.currentTimeMillis()-startTime;\n                lastFeedbackTime = currentTime;\n\n                final long runTimeMillis = endTime - startTime;\n\n                float elapsedTimeSec2 = elapsedTimeMillis2/1000F;\n                if (tot_executions_latency == 0) {\n                    tot_executions_latency = 1;\n                }\n\n                double percentComplete = ((double) elapsedTimeMillis2 / (double) runTimeMillis) * 100;\n                if (percentComplete > 100.0) {\n                    percentComplete = 100.0;\n                }\n\n                thisOutstanding = num_sp_calls - tot_executions;\n\n                double avgLatency = (double) tot_execution_milliseconds / (double) tot_executions_latency;\n\n                System.out.printf(\"%.3f%% Complete | Transactions: %,d at %,.2f TPS | outstanding = %d (%d) | min = %d | max = %d | avg = %.2f\\n\",percentComplete, num_sp_calls, (num_sp_calls / elapsedTimeSec2), thisOutstanding,(thisOutstanding - lastOutstanding), min_execution_milliseconds, max_execution_milliseconds, avgLatency);\n\n                lastOutstanding = thisOutstanding;\n            }\n        }\n\n        try {\n            voltclient.drain();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        long elapsedTimeMillis = System.currentTimeMillis()-startTime;\n        float elapsedTimeSec = elapsedTimeMillis/1000F;\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"Voting Results\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Accepted votes = %,d\\n\",vote_result_counter[0]);\n        System.out.printf(\" - Rejected votes (invalid contestant) = %,d\\n\",vote_result_counter[1]);\n        System.out.printf(\" - Rejected votes (voter over limit) = %,d\\n\\n\",vote_result_counter[2]);\n\n        String winnerName = \"<<UNKNOWN>>\";\n        int winnerId = 0;\n\n        try {\n            VoltTable[] vtResults = voltclient.callProcedure(\"Results\").getResults();\n\n            int rowCount = vtResults[0].getRowCount();\n            if (rowCount == 0) {\n                System.out.println(\" - No results to report.\");\n            } else {\n                for (int ii = 0; ii < rowCount; ii++) {\n                    VoltTableRow row = vtResults[0].fetchRow(ii);\n                    String resultName = row.getString(0);\n                    winnerId = (int)row.getLong(1);\n                    long resultVotes = row.getLong(2);\n                    System.out.printf(\" - Contestant %s received %,d vote(s)\\n\",resultName,resultVotes);\n                    winnerName = resultName;\n                }\n            }\n        } catch (ProcCallException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n\n        System.out.printf(\"\\n - Contestant %s was the winner.\\n\",winnerName);\n\n\n        System.out.println(\"\\n\");\n        System.out.println(\"*************************************************************************\");\n        System.out.println(\"System Statistics\");\n        System.out.println(\"*************************************************************************\");\n\n        System.out.printf(\" - Ran for %,.2f seconds\\n\",elapsedTimeSec);\n        System.out.printf(\" - Performed %,d Stored Procedure calls\\n\",num_sp_calls);\n        System.out.printf(\" - At %,.2f calls per second\\n\",num_sp_calls / elapsedTimeSec);\n        System.out.printf(\" - Average Latency = %.2f ms\\n\",((double) tot_execution_milliseconds / (double) tot_executions_latency));\n        System.out.printf(\" -   Latency   0ms -  25ms = %,d\\n\",latency_counter[0]);\n        System.out.printf(\" -   Latency  25ms -  50ms = %,d\\n\",latency_counter[1]);\n        System.out.printf(\" -   Latency  50ms -  75ms = %,d\\n\",latency_counter[2]);\n        System.out.printf(\" -   Latency  75ms - 100ms = %,d\\n\",latency_counter[3]);\n        System.out.printf(\" -   Latency 100ms - 125ms = %,d\\n\",latency_counter[4]);\n        System.out.printf(\" -   Latency 125ms - 150ms = %,d\\n\",latency_counter[5]);\n        System.out.printf(\" -   Latency 150ms - 175ms = %,d\\n\",latency_counter[6]);\n        System.out.printf(\" -   Latency 175ms - 200ms = %,d\\n\",latency_counter[7]);\n        System.out.printf(\" -   Latency 200ms+        = %,d\\n\",latency_counter[8]);\n\n        try {\n            voltclient.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }","commit_id":"5db533eb8c5b85c32102f813e166cb86396a5d8c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void printIfThenElse(final AST literalIf) throws RunnerException {\n    out.print(literalIf.getText());\n    dumpHiddenAfter(literalIf);\n\n    final AST condition = literalIf.getFirstChild();\n    print(condition); // the \"if\" condition: an EXPR\n\n    // the \"then\" clause is either an SLIST or an EXPR\n    final AST thenPath = condition.getNextSibling();\n    print(thenPath);\n\n    // optional \"else\" clause: an SLIST or an EXPR\n    final AST elsePath = thenPath.getNextSibling();\n    if (elsePath != null) {\n      out.print(\"else\");\n      dumpHiddenBefore(getBestPrintableNode(elsePath, true));\n      print(elsePath);\n    }\n  }","id":9824,"modified_method":"private void printIfThenElse(final AST literalIf) throws RunnerException {\n    out.print(literalIf.getText());\n    dumpHiddenAfter(literalIf);\n\n    final AST condition = literalIf.getFirstChild();\n    print(condition); // the \"if\" condition: an EXPR\n\n    // the \"then\" clause is either an SLIST or an EXPR\n    final AST thenPath = condition.getNextSibling();\n    print(thenPath);\n\n    // optional \"else\" clause: an SLIST or an EXPR\n    // what could be simpler?\n    final AST elsePath = thenPath.getNextSibling();\n    if (elsePath != null) {\n      out.print(\"else\");\n      final AST bestPrintableNode = getBestPrintableNode(elsePath, true);\n      dumpHiddenBefore(bestPrintableNode);\n      final CommonHiddenStreamToken hiddenBefore =\n        ((CommonASTWithHiddenTokens) elsePath).getHiddenBefore();\n      if (elsePath.getType() == PdeTokenTypes.SLIST && elsePath.getNumberOfChildren() == 0 && \n          hiddenBefore == null) {\n        out.print(\"{\");\n        final CommonHiddenStreamToken hiddenAfter = \n          ((CommonASTWithHiddenTokens) elsePath).getHiddenAfter();\n        if (hiddenAfter == null) {\n          out.print(\"}\");\n        } else {\n          dumpHiddenTokens(hiddenAfter);\n        }\n      } else {\n        print(elsePath);\n      }\n    }\n  }","commit_id":"83d62d4da88d01024f63abf56c7dace4ebd0bc11","url":"https://github.com/processing/processing"},{"original_method":"public void doStartTag() {\n        String test = (String) attributes.get(ATTRIBUTE_TEST);\n        if(StringUtils.isBlank(test))\n            throw new GrailsTagException(\"Tag [\"+TAG_NAME+\"] missing required attribute [\"+ATTRIBUTE_TEST+\"]\");\n        out.print(\"else if(\");\n        out.print(test);\n        out.println(\") {\");\n    }","id":9825,"modified_method":"public void doStartTag() {\n        String env = (String) attributes.get(ATTRIBUTE_ENV);\n        String test = (String) attributes.get(ATTRIBUTE_TEST);\n        env = StringUtils.isBlank(env) ? null : env;\n        test = StringUtils.isBlank(test) ? null : test; \n        if((env == null) && (test == null))\n            throw new GrailsTagException(\n                \"Tag [\"+TAG_NAME+\"] must have one or both of the attributes [\"+ATTRIBUTE_TEST+\"] or [\"+ATTRIBUTE_ENV+\"]\");\n        if (env != null) {\n            env = calculateExpression(env);\n        }\n        if ((env != null) && (test != null)) {\n            out.print(\"else if((GrailsUtil.environment == '\"+env+\"') && (\");\n            out.print(test);\n            out.println(\")) {\");\n        } else if (env != null) {\n            // double (( is deliberate... to avoid thorny logic\n            out.print(\"else if(GrailsUtil.environment == '\"+env+\"') {\");\n        } else {\n            out.print(\"else if(\");\n            out.print(test);\n            out.println(\") {\");\n        }\n    }","commit_id":"ef20749ad08f7a1754218109cf88e0b2fcdb60b3","url":"https://github.com/grails/grails-core"},{"original_method":"public void doStartTag() {\n        String test = (String) attributes.get(ATTRIBUTE_TEST);\n        if(StringUtils.isBlank(test))\n            throw new GrailsTagException(\"Tag [\"+TAG_NAME+\"] missing required attribute [\"+ATTRIBUTE_TEST+\"]\");\n        out.print(\"if(\");\n        out.print(test);\n        out.println(\") {\");\n    }","id":9826,"modified_method":"public void doStartTag() {\n        String env = (String) attributes.get(ATTRIBUTE_ENV);\n        String test = (String) attributes.get(ATTRIBUTE_TEST);\n        env = StringUtils.isBlank(env) ? null : env;\n        test = StringUtils.isBlank(test) ? null : test;\n        if((env == null) && (test == null))\n            throw new GrailsTagException(\n                \"Tag [\"+TAG_NAME+\"] must have one or both of the attributes [\"+ATTRIBUTE_TEST+\"] or [\"+ATTRIBUTE_ENV+\"]\");\n        if (env != null) {\n            env = calculateExpression(env);\n        }\n        if ((env != null) && (test != null)) {\n            out.print(\"if((GrailsUtil.environment == '\"+env+\"') && (\");\n            out.print(test);\n            out.println(\")) {\");\n        } else if (env != null) {\n            // double (( is deliberate... to avoid thorny logic\n            out.print(\"if(GrailsUtil.environment == '\"+env+\"') {\");\n        } else {\n            out.print(\"if(\");\n            out.print(test);\n            out.println(\") {\");\n        }\n    }","commit_id":"ef20749ad08f7a1754218109cf88e0b2fcdb60b3","url":"https://github.com/grails/grails-core"},{"original_method":"private void page() {\n        if (LOG.isDebugEnabled()) LOG.debug(\"parse: page\");\n        if (finalPass) {\n            out.println();\n            out.print(\"class \");\n            out.print(className);\n            out.println(\" extends GroovyPage {\");\n            out.println(\"public Object run() {\");            \n\n        } else {\n            out.println(\"import org.codehaus.groovy.grails.web.pages.GroovyPage\");\n            out.println(\"import org.codehaus.groovy.grails.web.taglib.*\");\n        }\n        loop: for (;;) {\n            if(doNextScan)\n                state = scan.nextToken();\n            else\n                doNextScan = true;\n\n            switch (state) {\n                case EOF: break loop;\n                case HTML: html(); break;\n                case JEXPR: expr(); break;\n                case JSCRIPT: script(false); break;\n                case JDIRECT: direct(); break;\n                case JDECLAR: declare(false); break;\n                case GEXPR: expr(); break;\n                case GSCRIPT: script(true); break;\n                case GDIRECT: direct(); break;\n                case GDECLAR: declare(true); break;\n                case GSTART_TAG: startTag(); break;\n                case GEND_TAG: endTag(); break;\n            }\n        }\n\n        if (finalPass) {\n            out.println(\"}\");\n            for (Iterator i = constants.keySet().iterator(); i.hasNext();) {\n                String name = (String) i.next();\n                out.println(\"static final \" + name + \" = \" + constants.get(name));\n            }\n            out.println(\"}\");\n        }\n    }","id":9827,"modified_method":"private void page() {\n        if (LOG.isDebugEnabled()) LOG.debug(\"parse: page\");\n        if (finalPass) {\n            out.println();\n            out.print(\"class \");\n            out.print(className);\n            out.println(\" extends GroovyPage {\");\n            out.println(\"public Object run() {\");            \n\n        } else {\n            for (int i = 0; i < DEFAULT_IMPORTS.length; i++) {\n                out.print(\"import \");\n                out.println(DEFAULT_IMPORTS[i]);\n\n            }\n        }\n        loop: for (;;) {\n            if(doNextScan)\n                state = scan.nextToken();\n            else\n                doNextScan = true;\n\n            switch (state) {\n                case EOF: break loop;\n                case HTML: html(); break;\n                case JEXPR: expr(); break;\n                case JSCRIPT: script(false); break;\n                case JDIRECT: direct(); break;\n                case JDECLAR: declare(false); break;\n                case GEXPR: expr(); break;\n                case GSCRIPT: script(true); break;\n                case GDIRECT: direct(); break;\n                case GDECLAR: declare(true); break;\n                case GSTART_TAG: startTag(); break;\n                case GEND_TAG: endTag(); break;\n            }\n        }\n\n        if (finalPass) {\n            out.println(\"}\");\n            for (Iterator i = constants.keySet().iterator(); i.hasNext();) {\n                String name = (String) i.next();\n                out.println(\"static final \" + name + \" = \" + constants.get(name));\n            }\n            out.println(\"}\");\n        }\n    }","commit_id":"ef20749ad08f7a1754218109cf88e0b2fcdb60b3","url":"https://github.com/grails/grails-core"},{"original_method":"/** Update my own digest from a digest received by somebody else. Returns the number of elements updated\n     *  Needs to be called with a lock on digest */\n    private int updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return 0;\n\n        Address mbr;\n        long highest_seqno, my_highest_seqno;\n        long highest_seen_seqno, my_highest_seen_seqno;\n        Map.Entry entry;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        int num_elements_updated=0;\n\n        StringBuffer sb=new StringBuffer(\"my [\").append(local_addr).append(\"] digest before: \").append(digest).\n                append(\"\\ndigest from \").append(sender).append(\": \").append(d).append(\"\\n\");\n\n        for(Iterator it=d.senders.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            mbr=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            if(!digest.contains(mbr)) {\n                digest.add(mbr, val.low_seqno, val.high_seqno,  val.high_seqno_seen);\n            }\n            else {\n                highest_seqno=val.high_seqno;\n                highest_seen_seqno=val.high_seqno_seen;\n\n                // compute the minimum of the highest seqnos deliverable (for garbage collection)\n                my_highest_seqno=digest.highSeqnoAt(mbr);\n                digest.setHighSeqnoAt(mbr, Math.min(my_highest_seqno, highest_seqno));\n\n                // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n                my_highest_seen_seqno=digest.highSeqnoSeenAt(mbr);\n                digest.setHighSeqnoSeenAt(mbr, Math.max(my_highest_seen_seqno, highest_seen_seqno));\n            }\n            num_elements_updated++;\n        }\n\n        sb.append(\"\\nmy [\").append(local_addr).append(\"] digest after: \").append(digest).append(\"\\n\");\n        sb.append(\"\\n\").append(num_elements_updated).append(\" elements were updated\\n\");\n        if(log.isTraceEnabled()) // todo: remove\n            log.trace(sb);\n\n        return num_elements_updated;\n    }","id":9828,"modified_method":"/** Update my own digest from a digest received by somebody else. Returns whether the update was successful.\n     *  Needs to be called with a lock on digest */\n    private boolean updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return false;\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return false;\n        }\n\n//        if(self) {\n//            if(heard_from.contains(sender)) {\n//                resetHeardFromList(mbrs);\n//                digest.replace(d);\n//                if(log.isTraceEnabled())\n//                    log.trace(\"initialized digest from \" + d);\n//                return true;\n//            }\n//            else\n//                return false;\n//        }\n\n        if(!digest.sameSenders(d)) {\n            if(log.isTraceEnabled())\n                log.trace(new StringBuffer(\"received a digest \").append(d.printHighSeqnos()).append(\" from \").\n                          append(sender).append(\" which has different members than mine (\").\n                          append(digest.printHighSeqnos()).append(\"), discarding it and resetting heard_from list\"));\n            // to avoid sending incorrect stability/stable msgs, we simply reset our heard_from list, see DESIGN\n            resetDigest(mbrs);\n            return false;\n        }\n\n        StringBuffer sb=null;\n        if(log.isTraceEnabled())\n            sb=new StringBuffer(\"my [\").append(local_addr).append(\"] digest before: \").append(digest).\n                    append(\"\\ndigest from \").append(sender).append(\": \").append(d).append(\"\\n\");\n        Address mbr;\n        long highest_seqno, my_highest_seqno, new_highest_seqno;\n        long highest_seen_seqno, my_highest_seen_seqno, new_highest_seen_seqno;\n        Map.Entry entry;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        for(Iterator it=d.senders.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            mbr=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            highest_seqno=val.high_seqno;\n            highest_seen_seqno=val.high_seqno_seen;\n\n            // compute the minimum of the highest seqnos deliverable (for garbage collection)\n            my_highest_seqno=digest.highSeqnoAt(mbr);\n            // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n            my_highest_seen_seqno=digest.highSeqnoSeenAt(mbr);\n\n            new_highest_seqno=Math.min(my_highest_seqno, highest_seqno);\n            new_highest_seen_seqno=Math.max(my_highest_seen_seqno, highest_seen_seqno);\n            digest.setHighestDeliveredAndSeenSeqnos(mbr, new_highest_seqno, new_highest_seen_seqno);\n        }\n        if(log.isTraceEnabled()) {\n            sb.append(\"\\nmy [\").append(local_addr).append(\"] digest after: \").append(digest).append(\"\\n\");\n            log.trace(sb);\n        }\n        return true;\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"public void up(Event evt) {\n        Message msg;\n        StableHeader hdr;\n        int type=evt.getType();\n\n        switch(type) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            if(max_bytes > 0) {  // message counting is enabled\n                long size=Math.max(msg.getLength(), 24);\n                num_bytes_received+=size;\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"max_bytes has been reached (max_bytes=\");\n                        sb.append(max_bytes).append(\", number of bytes received=\");\n                        sb.append(num_bytes_received).append(\"): triggers stable msg\");\n                        log.trace(sb.toString());\n                    }\n                    // asks the NAKACK protocol for the current digest, reply event is GET_DIGEST_STABLE_OK (arg=digest)\n                    passDown(new Event(Event.GET_DIGEST_STABLE));\n                    num_bytes_received=0;\n                }\n            }\n\n\n            hdr=(StableHeader)msg.removeHeader(name);\n            if(hdr == null)\n                break;\n            switch(hdr.type) {\n            case StableHeader.STABLE_GOSSIP:\n                handleStableGossip(msg.getSrc(), hdr.stableDigest);\n                break;\n            case StableHeader.STABILITY:\n                handleStabilityMessage(hdr.stableDigest, msg.getSrc());\n                break;\n            default:\n                if(log.isErrorEnabled()) log.error(\"StableHeader type \" + hdr.type + \" not known\");\n            }\n            return;  // don't pass STABLE or STABILITY messages up the stack\n\n        case Event.VIEW_CHANGE:\n            View view=(View)evt.getArg();\n            handleViewChange(view);\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.GET_DIGEST_STABLE_OK:\n            Digest d=(Digest)evt.getArg(), copy=null;\n            synchronized(digest) {\n                int num_elements_expected=digest.size(), num_elements_updated;\n                num_elements_updated=updateLocalDigest(d, local_addr);\n                if(num_elements_updated == num_elements_expected)\n                    copy=digest.copy();\n            }\n            if(copy != null)\n                sendStableMessage(copy);\n            break;\n        }\n\n        passUp(evt);\n    }","id":9829,"modified_method":"public void up(Event evt) {\n        Message msg;\n        StableHeader hdr;\n        int type=evt.getType();\n\n        switch(type) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            if(max_bytes > 0) {  // message counting is enabled\n                long size=Math.max(msg.getLength(), 24);\n                num_bytes_received+=size;\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"max_bytes has been reached (max_bytes=\");\n                        sb.append(max_bytes).append(\", number of bytes received=\");\n                        sb.append(num_bytes_received).append(\"): triggers stable msg\");\n                        log.trace(sb.toString());\n                    }\n                    // asks the NAKACK protocol for the current digest, reply event is GET_DIGEST_STABLE_OK (arg=digest)\n                    passDown(new Event(Event.GET_DIGEST_STABLE));\n                    num_bytes_received=0;\n                }\n            }\n\n\n            hdr=(StableHeader)msg.removeHeader(name);\n            if(hdr == null)\n                break;\n            switch(hdr.type) {\n            case StableHeader.STABLE_GOSSIP:\n                handleStableMessage(msg.getSrc(), hdr.stableDigest);\n                break;\n            case StableHeader.STABILITY:\n                handleStabilityMessage(hdr.stableDigest, msg.getSrc());\n                break;\n            default:\n                if(log.isErrorEnabled()) log.error(\"StableHeader type \" + hdr.type + \" not known\");\n            }\n            return;  // don't pass STABLE or STABILITY messages up the stack\n\n        case Event.VIEW_CHANGE:\n            View view=(View)evt.getArg();\n            handleViewChange(view);\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.GET_DIGEST_STABLE_OK:\n            Digest d=(Digest)evt.getArg(), copy=null;\n\n            synchronized(latest_local_digest) {\n                latest_local_digest.replace(d);\n                if(heard_from.contains(local_addr))\n                    copy=digest.copy();\n            }\n\n//            synchronized(digest) {\n//                boolean success=updateLocalDigest(d, local_addr, true);\n//                if(!success)\n//                    break;\n//                copy=digest.copy();\n//            }\n\n            if(copy != null)\n                sendStableMessage(copy);\n\n            break;\n        }\n\n        passUp(evt);\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"private void resetHeardFromList(Vector new_members) {\n        if(new_members == null || new_members.size() == 0)\n            return;\n        synchronized(heard_from) {\n            heard_from.clear();\n            heard_from.addAll(new_members);\n            // heard_from.remove(local_addr); // I don't need to hear from myself\n        }\n    }","id":9830,"modified_method":"private void resetDigest(Vector new_members) {\n        if(new_members == null || new_members.size() == 0)\n            return;\n        synchronized(heard_from) {\n            heard_from.clear();\n            heard_from.addAll(new_members);\n        }\n        synchronized(digest) {\n            digest.replace(latest_local_digest);\n        }\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean removeFromHeardFromList(Address mbr) {\n        synchronized(heard_from) {\n            heard_from.remove(mbr);\n            if(heard_from.size() == 0) {\n                resetHeardFromList(this.mbrs);\n                return true;\n            }\n        }\n        return false;\n    }","id":9831,"modified_method":"private boolean removeFromHeardFromList(Address mbr) {\n        synchronized(heard_from) {\n            heard_from.remove(mbr);\n            if(heard_from.size() == 0) {\n                resetDigest(this.mbrs);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v) {\n        Vector tmp=v.getMembers();\n        mbrs.clear();\n        mbrs.addAll(tmp);\n        synchronized(digest) {\n            // 1. remove all members from digest who are not in the view\n            Iterator it=digest.senders.keySet().iterator();\n            Address mbr;\n            while(it.hasNext()) {\n                mbr=(Address)it.next();\n                if(!tmp.contains(mbr))\n                    it.remove();\n            }\n            // 2. add members to digest which are in the new view but not in the digest\n            for(int i=0; i < tmp.size(); i++) {\n                mbr=(Address)tmp.get(i);\n                if(!digest.contains(mbr))\n                    digest.add(mbr, -1, -1);\n            }\n        }\n        resetHeardFromList(tmp);\n    }","id":9832,"modified_method":"private void handleViewChange(View v) {\n        Vector tmp=v.getMembers();\n        mbrs.clear();\n        mbrs.addAll(tmp);\n        adjustSenders(digest, tmp);\n        adjustSenders(latest_local_digest, tmp);\n        resetDigest(tmp);\n        if(!initialized)\n            initialized=true;\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableGossip(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stable msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        if(!heard_from.contains(sender)) {  // already received gossip from sender; discard it\n            if(log.isTraceEnabled()) log.trace(\"already received stable msg from \" + sender);\n            return;\n        }\n\n        Digest copy;\n        synchronized(digest) {\n            int num_elements_expected=digest.size(), num_elements_updated;\n            num_elements_updated=updateLocalDigest(d, sender);\n            // we can only remove the sender from heard_from if *all* elements of my digest were updated\n            if(num_elements_updated != num_elements_expected)\n                return;\n            copy=digest.copy();\n        }\n\n        boolean was_last=removeFromHeardFromList(sender);\n        if(was_last) {\n            sendStabilityMessage(copy);\n        }\n    }","id":9833,"modified_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableMessage(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stable msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        if(!heard_from.contains(sender)) {  // already received gossip from sender; discard it\n            if(log.isTraceEnabled()) log.trace(\"already received stable msg from \" + sender);\n            return;\n        }\n\n        Digest copy;\n        synchronized(digest) {\n            boolean success=updateLocalDigest(d, sender);\n            if(!success) // we can only remove the sender from heard_from if *all* elements of my digest were updated\n                return;\n            copy=digest.copy();\n        }\n\n        boolean was_last=removeFromHeardFromList(sender);\n        if(was_last) {\n            sendStabilityMessage(copy);\n        }\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"void handleStabilityMessage(Digest d, Address sender) {\n        if(d == null) {\n            if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"stability message will not be handled as I'm suspended\");\n            }\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        stopStabilityTask();\n\n        // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n        // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n        if(!this.digest.sameSenders(d)) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"received digest (digest=\" + d + \") which does not match my own digest (\"+\n                        this.digest + \"): ignoring digest and re-initializing own digest\");\n            }\n            resetHeardFromList(mbrs);\n            return;\n        }\n\n        // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n        passDown(new Event(Event.STABLE, d));\n    }","id":9834,"modified_method":"void handleStabilityMessage(Digest d, Address sender) {\n        if(d == null) {\n            if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"stability message will not be handled as I'm suspended\");\n            }\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        stopStabilityTask();\n\n        // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n        // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n        if(!this.digest.sameSenders(d)) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"received digest (digest=\" + d + \") which does not match my own digest (\"+\n                        this.digest + \"): ignoring digest and re-initializing own digest\");\n            }\n            return;\n        }\n\n        resetDigest(mbrs);\n\n        // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n        passDown(new Event(Event.STABLE, d));\n    }","commit_id":"a0be9fa02c96e7741ce1d16da86458a36bb93b30","url":"https://github.com/belaban/JGroups"},{"original_method":"void handleStabilityMessage(Digest d, Address sender) {\n        if(d == null) {\n            if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"stability message will not be handled as I'm suspended\");\n            }\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        stopStabilityTask();\n\n        // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n        // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n        if(!this.digest.sameSenders(d)) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"received digest (digest=\" + d + \") which does not match my own digest (\"+\n                        this.digest + \"): ignoring digest and re-initializing own digest\");\n            }\n            resetHeardFromList(mbrs);\n            return;\n        }\n\n        // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n        passDown(new Event(Event.STABLE, d));\n    }","id":9835,"modified_method":"void handleStabilityMessage(Digest d, Address sender) {\n        if(d == null) {\n            if(log.isErrorEnabled()) log.error(\"stability digest is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"stability message will not be handled as I'm suspended\");\n            }\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stability msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        stopStabilityTask();\n\n        // we won't handle the gossip d, if d's members don't match the membership in my own digest,\n        // this is part of the fix for the NAKACK problem (bugs #943480 and #938584)\n        if(!this.digest.sameSenders(d)) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"received digest (digest=\" + d + \") which does not match my own digest (\"+\n                        this.digest + \"): ignoring digest and re-initializing own digest\");\n            }\n            return;\n        }\n\n        resetDigest(mbrs);\n\n        // pass STABLE event down the stack, so NAKACK can garbage collect old messages\n        passDown(new Event(Event.STABLE, d));\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableGossip(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stable msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        if(!heard_from.contains(sender)) {  // already received gossip from sender; discard it\n            if(log.isTraceEnabled()) log.trace(\"already received stable msg from \" + sender);\n            return;\n        }\n\n        Digest copy;\n        synchronized(digest) {\n            int num_elements_expected=digest.size(), num_elements_updated;\n            num_elements_updated=updateLocalDigest(d, sender);\n            // we can only remove the sender from heard_from if *all* elements of my digest were updated\n            if(num_elements_updated != num_elements_expected)\n                return;\n            copy=digest.copy();\n        }\n\n        boolean was_last=removeFromHeardFromList(sender);\n        if(was_last) {\n            sendStabilityMessage(copy);\n        }\n    }","id":9836,"modified_method":"/**\n     Digest d contains (a) the highest seqnos <em>deliverable<\/em> for each sender and (b) the highest seqnos\n     <em>seen<\/em> for each member. (Difference: with 1,2,4,5, the highest seqno seen is 5, whereas the highest\n     seqno deliverable is 2). The minimum of all highest seqnos deliverable will be taken to send a stability\n     message, which results in garbage collection of messages lower than the ones in the stability vector. The\n     maximum of all seqnos will be taken to trigger possible retransmission of last missing seqno (see DESIGN\n     for details).\n     */\n    private void handleStableMessage(Address sender, Digest d) {\n        if(d == null || sender == null) {\n            if(log.isErrorEnabled()) log.error(\"digest or sender is null\");\n            return;\n        }\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return;\n        }\n\n        if(suspended) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm suspended\");\n            return;\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(new StringBuffer(\"received stable msg from \").append(sender).append(\": \").append(d.printHighSeqnos()));\n        if(!heard_from.contains(sender)) {  // already received gossip from sender; discard it\n            if(log.isTraceEnabled()) log.trace(\"already received stable msg from \" + sender);\n            return;\n        }\n\n        Digest copy;\n        synchronized(digest) {\n            boolean success=updateLocalDigest(d, sender);\n            if(!success) // we can only remove the sender from heard_from if *all* elements of my digest were updated\n                return;\n            copy=digest.copy();\n        }\n\n        boolean was_last=removeFromHeardFromList(sender);\n        if(was_last) {\n            sendStabilityMessage(copy);\n        }\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void resetHeardFromList(Vector new_members) {\n        if(new_members == null || new_members.size() == 0)\n            return;\n        synchronized(heard_from) {\n            heard_from.clear();\n            heard_from.addAll(new_members);\n            // heard_from.remove(local_addr); // I don't need to hear from myself\n        }\n    }","id":9837,"modified_method":"private void resetDigest(Vector new_members) {\n        if(new_members == null || new_members.size() == 0)\n            return;\n        synchronized(heard_from) {\n            heard_from.clear();\n            heard_from.addAll(new_members);\n        }\n        synchronized(digest) {\n            digest.replace(latest_local_digest);\n        }\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Update my own digest from a digest received by somebody else. Returns the number of elements updated\n     *  Needs to be called with a lock on digest */\n    private int updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return 0;\n\n        Address mbr;\n        long highest_seqno, my_highest_seqno;\n        long highest_seen_seqno, my_highest_seen_seqno;\n        Map.Entry entry;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        int num_elements_updated=0;\n\n        StringBuffer sb=new StringBuffer(\"my [\").append(local_addr).append(\"] digest before: \").append(digest).\n                append(\"\\ndigest from \").append(sender).append(\": \").append(d).append(\"\\n\");\n\n        for(Iterator it=d.senders.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            mbr=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            if(!digest.contains(mbr)) {\n                digest.add(mbr, val.low_seqno, val.high_seqno,  val.high_seqno_seen);\n            }\n            else {\n                highest_seqno=val.high_seqno;\n                highest_seen_seqno=val.high_seqno_seen;\n\n                // compute the minimum of the highest seqnos deliverable (for garbage collection)\n                my_highest_seqno=digest.highSeqnoAt(mbr);\n                digest.setHighSeqnoAt(mbr, Math.min(my_highest_seqno, highest_seqno));\n\n                // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n                my_highest_seen_seqno=digest.highSeqnoSeenAt(mbr);\n                digest.setHighSeqnoSeenAt(mbr, Math.max(my_highest_seen_seqno, highest_seen_seqno));\n            }\n            num_elements_updated++;\n        }\n\n        sb.append(\"\\nmy [\").append(local_addr).append(\"] digest after: \").append(digest).append(\"\\n\");\n        sb.append(\"\\n\").append(num_elements_updated).append(\" elements were updated\\n\");\n        if(log.isTraceEnabled()) // todo: remove\n            log.trace(sb);\n\n        return num_elements_updated;\n    }","id":9838,"modified_method":"/** Update my own digest from a digest received by somebody else. Returns whether the update was successful.\n     *  Needs to be called with a lock on digest */\n    private boolean updateLocalDigest(Digest d, Address sender) {\n        if(d == null || d.size() == 0)\n            return false;\n\n        if(!initialized) {\n            if(log.isTraceEnabled())\n                log.trace(\"STABLE message will not be handled as I'm not yet initialized\");\n            return false;\n        }\n\n//        if(self) {\n//            if(heard_from.contains(sender)) {\n//                resetHeardFromList(mbrs);\n//                digest.replace(d);\n//                if(log.isTraceEnabled())\n//                    log.trace(\"initialized digest from \" + d);\n//                return true;\n//            }\n//            else\n//                return false;\n//        }\n\n        if(!digest.sameSenders(d)) {\n            if(log.isTraceEnabled())\n                log.trace(new StringBuffer(\"received a digest \").append(d.printHighSeqnos()).append(\" from \").\n                          append(sender).append(\" which has different members than mine (\").\n                          append(digest.printHighSeqnos()).append(\"), discarding it and resetting heard_from list\"));\n            // to avoid sending incorrect stability/stable msgs, we simply reset our heard_from list, see DESIGN\n            resetDigest(mbrs);\n            return false;\n        }\n\n        StringBuffer sb=null;\n        if(log.isTraceEnabled())\n            sb=new StringBuffer(\"my [\").append(local_addr).append(\"] digest before: \").append(digest).\n                    append(\"\\ndigest from \").append(sender).append(\": \").append(d).append(\"\\n\");\n        Address mbr;\n        long highest_seqno, my_highest_seqno, new_highest_seqno;\n        long highest_seen_seqno, my_highest_seen_seqno, new_highest_seen_seqno;\n        Map.Entry entry;\n        org.jgroups.protocols.pbcast.Digest.Entry val;\n        for(Iterator it=d.senders.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            mbr=(Address)entry.getKey();\n            val=(org.jgroups.protocols.pbcast.Digest.Entry)entry.getValue();\n            highest_seqno=val.high_seqno;\n            highest_seen_seqno=val.high_seqno_seen;\n\n            // compute the minimum of the highest seqnos deliverable (for garbage collection)\n            my_highest_seqno=digest.highSeqnoAt(mbr);\n            // compute the maximum of the highest seqnos seen (for retransmission of last missing message)\n            my_highest_seen_seqno=digest.highSeqnoSeenAt(mbr);\n\n            new_highest_seqno=Math.min(my_highest_seqno, highest_seqno);\n            new_highest_seen_seqno=Math.max(my_highest_seen_seqno, highest_seen_seqno);\n            digest.setHighestDeliveredAndSeenSeqnos(mbr, new_highest_seqno, new_highest_seen_seqno);\n        }\n        if(log.isTraceEnabled()) {\n            sb.append(\"\\nmy [\").append(local_addr).append(\"] digest after: \").append(digest).append(\"\\n\");\n            log.trace(sb);\n        }\n        return true;\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void up(Event evt) {\n        Message msg;\n        StableHeader hdr;\n        int type=evt.getType();\n\n        switch(type) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            if(max_bytes > 0) {  // message counting is enabled\n                long size=Math.max(msg.getLength(), 24);\n                num_bytes_received+=size;\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"max_bytes has been reached (max_bytes=\");\n                        sb.append(max_bytes).append(\", number of bytes received=\");\n                        sb.append(num_bytes_received).append(\"): triggers stable msg\");\n                        log.trace(sb.toString());\n                    }\n                    // asks the NAKACK protocol for the current digest, reply event is GET_DIGEST_STABLE_OK (arg=digest)\n                    passDown(new Event(Event.GET_DIGEST_STABLE));\n                    num_bytes_received=0;\n                }\n            }\n\n\n            hdr=(StableHeader)msg.removeHeader(name);\n            if(hdr == null)\n                break;\n            switch(hdr.type) {\n            case StableHeader.STABLE_GOSSIP:\n                handleStableGossip(msg.getSrc(), hdr.stableDigest);\n                break;\n            case StableHeader.STABILITY:\n                handleStabilityMessage(hdr.stableDigest, msg.getSrc());\n                break;\n            default:\n                if(log.isErrorEnabled()) log.error(\"StableHeader type \" + hdr.type + \" not known\");\n            }\n            return;  // don't pass STABLE or STABILITY messages up the stack\n\n        case Event.VIEW_CHANGE:\n            View view=(View)evt.getArg();\n            handleViewChange(view);\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.GET_DIGEST_STABLE_OK:\n            Digest d=(Digest)evt.getArg(), copy=null;\n            synchronized(digest) {\n                int num_elements_expected=digest.size(), num_elements_updated;\n                num_elements_updated=updateLocalDigest(d, local_addr);\n                if(num_elements_updated == num_elements_expected)\n                    copy=digest.copy();\n            }\n            if(copy != null)\n                sendStableMessage(copy);\n            break;\n        }\n\n        passUp(evt);\n    }","id":9839,"modified_method":"public void up(Event evt) {\n        Message msg;\n        StableHeader hdr;\n        int type=evt.getType();\n\n        switch(type) {\n\n        case Event.MSG:\n            msg=(Message)evt.getArg();\n            if(max_bytes > 0) {  // message counting is enabled\n                long size=Math.max(msg.getLength(), 24);\n                num_bytes_received+=size;\n                if(num_bytes_received >= max_bytes) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"max_bytes has been reached (max_bytes=\");\n                        sb.append(max_bytes).append(\", number of bytes received=\");\n                        sb.append(num_bytes_received).append(\"): triggers stable msg\");\n                        log.trace(sb.toString());\n                    }\n                    // asks the NAKACK protocol for the current digest, reply event is GET_DIGEST_STABLE_OK (arg=digest)\n                    passDown(new Event(Event.GET_DIGEST_STABLE));\n                    num_bytes_received=0;\n                }\n            }\n\n\n            hdr=(StableHeader)msg.removeHeader(name);\n            if(hdr == null)\n                break;\n            switch(hdr.type) {\n            case StableHeader.STABLE_GOSSIP:\n                handleStableMessage(msg.getSrc(), hdr.stableDigest);\n                break;\n            case StableHeader.STABILITY:\n                handleStabilityMessage(hdr.stableDigest, msg.getSrc());\n                break;\n            default:\n                if(log.isErrorEnabled()) log.error(\"StableHeader type \" + hdr.type + \" not known\");\n            }\n            return;  // don't pass STABLE or STABILITY messages up the stack\n\n        case Event.VIEW_CHANGE:\n            View view=(View)evt.getArg();\n            handleViewChange(view);\n            break;\n\n        case Event.SET_LOCAL_ADDRESS:\n            local_addr=(Address)evt.getArg();\n            break;\n\n        case Event.GET_DIGEST_STABLE_OK:\n            Digest d=(Digest)evt.getArg(), copy=null;\n\n            synchronized(latest_local_digest) {\n                latest_local_digest.replace(d);\n                if(heard_from.contains(local_addr))\n                    copy=digest.copy();\n            }\n\n//            synchronized(digest) {\n//                boolean success=updateLocalDigest(d, local_addr, true);\n//                if(!success)\n//                    break;\n//                copy=digest.copy();\n//            }\n\n            if(copy != null)\n                sendStableMessage(copy);\n\n            break;\n        }\n\n        passUp(evt);\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleViewChange(View v) {\n        Vector tmp=v.getMembers();\n        mbrs.clear();\n        mbrs.addAll(tmp);\n        synchronized(digest) {\n            // 1. remove all members from digest who are not in the view\n            Iterator it=digest.senders.keySet().iterator();\n            Address mbr;\n            while(it.hasNext()) {\n                mbr=(Address)it.next();\n                if(!tmp.contains(mbr))\n                    it.remove();\n            }\n            // 2. add members to digest which are in the new view but not in the digest\n            for(int i=0; i < tmp.size(); i++) {\n                mbr=(Address)tmp.get(i);\n                if(!digest.contains(mbr))\n                    digest.add(mbr, -1, -1);\n            }\n        }\n        resetHeardFromList(tmp);\n    }","id":9840,"modified_method":"private void handleViewChange(View v) {\n        Vector tmp=v.getMembers();\n        mbrs.clear();\n        mbrs.addAll(tmp);\n        adjustSenders(digest, tmp);\n        adjustSenders(latest_local_digest, tmp);\n        resetDigest(tmp);\n        if(!initialized)\n            initialized=true;\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean removeFromHeardFromList(Address mbr) {\n        synchronized(heard_from) {\n            heard_from.remove(mbr);\n            if(heard_from.size() == 0) {\n                resetHeardFromList(this.mbrs);\n                return true;\n            }\n        }\n        return false;\n    }","id":9841,"modified_method":"private boolean removeFromHeardFromList(Address mbr) {\n        synchronized(heard_from) {\n            heard_from.remove(mbr);\n            if(heard_from.size() == 0) {\n                resetDigest(this.mbrs);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"b2b91091ee7908c11c297280af6edda797eac00b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends all messages currently in forward_table to the new coordinator (changing the dest field).\n     * This needs to be done, so the underlying reliable unicast protocol (e.g. UNICAST) adds these messages\n     * to its retransmission mechanism<br/>\n     * Note that we need to resend the messages in order of their seqnos ! We also need to prevent other message\n     * from being inserted until we're done, that's why there's synchronization.\n     */\n    private void resendMessagesInForwardTable() {\n        Map<Long,Message> copy;\n        synchronized(forward_table) {\n            copy=new TreeMap<Long,Message>(forward_table);\n        }\n        for(Message msg: copy.values()) {\n            msg.setDest(coord);\n            if (log.isTraceEnabled()) {\n                log.trace(\"resending msg \" + msg + \" to coord (\" + coord + \")\");\n            }\n            down_prot.down(new Event(Event.MSG, msg));\n        }\n    }","id":9842,"modified_method":"/**\n     * Sends all messages currently in forward_table to the new coordinator (changing the dest field).\n     * This needs to be done, so the underlying reliable unicast protocol (e.g. UNICAST) adds these messages\n     * to its retransmission mechanism<br/>\n     * Note that we need to resend the messages in order of their seqnos ! We also need to prevent other message\n     * from being inserted until we're done, that's why there's synchronization.\n     */\n    private void resendMessagesInForwardTable() {\n        Map<Long,byte[]> copy;\n        synchronized(forward_table) {\n            copy=new TreeMap<Long,byte[]>(forward_table);\n        }\n        for(Map.Entry<Long,byte[]> entry: copy.entrySet()) {\n            Long key=entry.getKey();\n            byte[] val=entry.getValue();\n\n            Message forward_msg=new Message(coord, null, val);\n            SequencerHeader hdr=new SequencerHeader(SequencerHeader.FORWARD, local_addr, key);\n            forward_msg.putHeader(name, hdr);\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"resending msg \" + local_addr + \"::\" + key + \" to coord (\" + coord + \")\");\n            }\n            down_prot.down(new Event(Event.MSG, forward_msg));\n        }\n    }","commit_id":"3ca908f9f1300986264f71eef1e388359ddc9982","url":"https://github.com/belaban/JGroups"},{"original_method":"private void forwardToCoord(Message msg, long seqno) {\n        if(log.isTraceEnabled())\n            log.trace(\"forwarding msg \" + msg + \" (seqno \" + seqno + \") to coord (\" + coord + \")\");\n\n        msg.setDest(coord);  // we change the message dest from multicast to unicast (to coord)\n        synchronized(forward_table) {\n            forward_table.put(seqno, msg);\n        }\n        down_prot.down(new Event(Event.MSG, msg));\n        forwarded_msgs++;\n    }","id":9843,"modified_method":"private void forwardToCoord(final Message msg, long seqno) {\n        msg.setSrc(local_addr);\n        if(log.isTraceEnabled())\n            log.trace(\"forwarding msg \" + msg + \" (seqno \" + seqno + \") to coord (\" + coord + \")\");\n\n        byte[] marshalled_msg;\n        try {\n            marshalled_msg=Util.objectToByteBuffer(msg);\n            synchronized(forward_table) {\n                forward_table.put(seqno, marshalled_msg);\n            }\n            Message forward_msg=new Message(coord, null, marshalled_msg);\n            SequencerHeader hdr=new SequencerHeader(SequencerHeader.FORWARD, local_addr, seqno);\n            forward_msg.putHeader(name, hdr);\n            down_prot.down(new Event(Event.MSG, forward_msg));\n            forwarded_msgs++;\n        }\n        catch(Exception e) {\n            log.error(\"failed marshalling message\", e);\n        }\n    }","commit_id":"3ca908f9f1300986264f71eef1e388359ddc9982","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        SequencerHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                hdr=(SequencerHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break; // pass up\n\n                switch(hdr.type) {\n                    case SequencerHeader.FORWARD:\n                        if(!is_coord) {\n                            if(log.isErrorEnabled())\n                                log.error(local_addr + \": non-coord; dropping FORWARD request from \" + msg.getSrc());\n                            return null;\n                        }\n                        broadcast(msg, true); // do copy the message\n                        received_forwards++;\n                        return null;\n                    case SequencerHeader.BCAST:\n                        deliver(msg, hdr);  // deliver a copy and return (discard the original msg)\n                        received_bcasts++;\n                        return null;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n        }\n\n        return up_prot.up(evt);\n    }","id":9844,"modified_method":"public Object up(Event evt) {\n        Message msg;\n        SequencerHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                hdr=(SequencerHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break; // pass up\n\n                switch(hdr.type) {\n                    case SequencerHeader.FORWARD:\n                        if(!is_coord) {\n                            if(log.isErrorEnabled())\n                                log.error(local_addr + \": non-coord; dropping FORWARD request from \" + msg.getSrc());\n                            return null;\n                        }\n                        broadcast(msg, true); // do copy the message\n                        received_forwards++;\n                        return null;\n\n                    case SequencerHeader.BCAST:\n                        deliver(msg, hdr, false);  // deliver a copy and return (discard the original msg)\n                        received_bcasts++;\n                        return null;\n\n                    case SequencerHeader.WRAPPED_BCAST:\n                        deliver(msg, hdr, true);  // unwrap the original message (in the payload) and deliver it\n                        received_bcasts++;\n                        return null;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"3ca908f9f1300986264f71eef1e388359ddc9982","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * We copy the message in order to change the sender's address. If we did this on the original message,\n     * retransmission would likely run into problems, and possibly also stability (STABLE) of messages\n     * @param msg\n     * @param hdr\n     */\n    private void deliver(Message msg, SequencerHeader hdr) {\n        Address original_sender=hdr.getOriginalSender();\n        if(original_sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"original sender is null, cannot swap sender's address back to original sender\");\n            return;\n        }\n        long msg_seqno=hdr.getSeqno();\n        if (log.isTraceEnabled()) {\n            log.trace(\"delivering msg \" + msg + \" (seqno \" + msg_seqno + \"), original sender \" + original_sender);\n        }\n\n        // this is the ack for the message sent by myself\n        if(original_sender.equals(local_addr)) {\n            synchronized(forward_table) {\n                forward_table.remove(msg_seqno);\n            }\n        }\n\n        // if msg was already delivered, discard it\n        boolean added=received_table.add(original_sender, msg_seqno);\n        if(!added) {\n            if(log.isWarnEnabled())\n                log.warn(\"seqno (\" + original_sender + \"::\" + msg_seqno + \" has already been received \" +\n                        \"(highest received=\" + received_table.getHighestReceived(original_sender) +\n                        \"); discarding duplicate message\");\n            return;\n        }\n\n        // pass a copy of the message up the stack\n        Message tmp=msg.copy(true);\n        tmp.setSrc(original_sender);\n        up_prot.up(new Event(Event.MSG, tmp));\n    }","id":9845,"modified_method":"/**\n     * We copy the message in order to change the sender's address. If we did this on the original message,\n     * retransmission would likely run into problems, and possibly also stability (STABLE) of messages\n     * @param msg\n     * @param hdr\n     */\n    private void deliver(Message msg, SequencerHeader hdr, boolean unwrap) {\n        if(unwrap) {\n            try {\n                hdr=(SequencerHeader)msg.getHeader(name);\n                long msg_seqno=hdr.getSeqno();\n                Message msg_to_deliver=(Message)Util.objectFromByteBuffer(msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n\n                if(!canDeliver(msg_to_deliver.getSrc(), msg_seqno))\n                    return;\n                if(log.isTraceEnabled())\n                    log.trace(\"delivering msg \" + msg + \" (seqno \" + msg_seqno + \"), original sender \" + msg.getSrc());\n\n                up_prot.up(new Event(Event.MSG, msg_to_deliver));\n            }\n            catch(Exception e) {\n                log.error(\"failure unmarshalling buffer\", e);\n            }\n            return;\n        }\n\n\n        Address original_sender=hdr.getOriginalSender();\n        if(original_sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"original sender is null, cannot swap sender's address back to original sender\");\n            return;\n        }\n        long msg_seqno=hdr.getSeqno();\n        if(!canDeliver(original_sender, msg_seqno))\n            return;\n        if(log.isTraceEnabled())\n            log.trace(\"delivering msg \" + msg + \" (seqno \" + msg_seqno + \"), original sender \" + original_sender);\n\n        // pass a copy of the message up the stack\n        Message tmp=msg.copy(true);\n        tmp.setSrc(original_sender);\n        up_prot.up(new Event(Event.MSG, tmp));\n    }","commit_id":"3ca908f9f1300986264f71eef1e388359ddc9982","url":"https://github.com/belaban/JGroups"},{"original_method":"private void broadcast(final Message msg, boolean copy) {\n        Message bcast_msg=null;\n        final SequencerHeader hdr=(SequencerHeader)msg.getHeader(name);\n\n        if(!copy) {\n            bcast_msg=msg;\n        }\n        else {\n            bcast_msg=new Message(null, local_addr, msg.getBuffer(), msg.getOffset(), msg.getLength());\n            SequencerHeader new_hdr=new SequencerHeader(SequencerHeader.BCAST, hdr.getOriginalSender(), hdr.getSeqno());\n            bcast_msg.putHeader(name, new_hdr);\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"broadcasting msg \" + bcast_msg + \" (seqno \" + hdr.getSeqno() + \")\");\n\n        down_prot.down(new Event(Event.MSG, bcast_msg));\n        bcast_msgs++;\n    }","id":9846,"modified_method":"private void broadcast(final Message msg, boolean copy) {\n        Message bcast_msg=null;\n        final SequencerHeader hdr=(SequencerHeader)msg.getHeader(name);\n\n        if(!copy) {\n            bcast_msg=msg; // no need to add a header, message already has one\n        }\n        else {\n            bcast_msg=new Message(null, local_addr, msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n            SequencerHeader new_hdr=new SequencerHeader(SequencerHeader.WRAPPED_BCAST, hdr.getOriginalSender(), hdr.getSeqno());\n            bcast_msg.putHeader(name, new_hdr);\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"broadcasting msg \" + bcast_msg + \" (seqno \" + hdr.getSeqno() + \")\");\n\n        down_prot.down(new Event(Event.MSG, bcast_msg));\n        bcast_msgs++;\n    }","commit_id":"3ca908f9f1300986264f71eef1e388359ddc9982","url":"https://github.com/belaban/JGroups"},{"original_method":"private final String printType() {\n            switch(type) {\n                case FORWARD: return \"FORWARD\";\n                case BCAST:   return \"BCAST\";\n                default:      return \"n/a\";\n            }\n        }","id":9847,"modified_method":"private final String printType() {\n            switch(type) {\n                case FORWARD:        return \"FORWARD\";\n                case BCAST:          return \"BCAST\";\n                case WRAPPED_BCAST:  return \"WRAPPED_BCAST\";\n                default:             return \"n/a\";\n            }\n        }","commit_id":"3ca908f9f1300986264f71eef1e388359ddc9982","url":"https://github.com/belaban/JGroups"},{"original_method":"private void forwardToCoord(Message msg, long seqno) {\n        if(log.isTraceEnabled())\n            log.trace(\"forwarding msg \" + msg + \" (seqno \" + seqno + \") to coord (\" + coord + \")\");\n\n        msg.setDest(coord);  // we change the message dest from multicast to unicast (to coord)\n        synchronized(forward_table) {\n            forward_table.put(seqno, msg);\n        }\n        down_prot.down(new Event(Event.MSG, msg));\n        forwarded_msgs++;\n    }","id":9848,"modified_method":"private void forwardToCoord(final Message msg, long seqno) {\n        msg.setSrc(local_addr);\n        if(log.isTraceEnabled())\n            log.trace(\"forwarding msg \" + msg + \" (seqno \" + seqno + \") to coord (\" + coord + \")\");\n\n        byte[] marshalled_msg;\n        try {\n            marshalled_msg=Util.objectToByteBuffer(msg);\n            synchronized(forward_table) {\n                forward_table.put(seqno, marshalled_msg);\n            }\n            Message forward_msg=new Message(coord, null, marshalled_msg);\n            SequencerHeader hdr=new SequencerHeader(SequencerHeader.FORWARD, local_addr, seqno);\n            forward_msg.putHeader(name, hdr);\n            down_prot.down(new Event(Event.MSG, forward_msg));\n            forwarded_msgs++;\n        }\n        catch(Exception e) {\n            log.error(\"failed marshalling message\", e);\n        }\n    }","commit_id":"85608a5c55f5e0b9490325567ba38740eaf8a7ec","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Sends all messages currently in forward_table to the new coordinator (changing the dest field).\n     * This needs to be done, so the underlying reliable unicast protocol (e.g. UNICAST) adds these messages\n     * to its retransmission mechanism<br/>\n     * Note that we need to resend the messages in order of their seqnos ! We also need to prevent other message\n     * from being inserted until we're done, that's why there's synchronization.\n     */\n    private void resendMessagesInForwardTable() {\n        Map<Long,Message> copy;\n        synchronized(forward_table) {\n            copy=new TreeMap<Long,Message>(forward_table);\n        }\n        for(Message msg: copy.values()) {\n            msg.setDest(coord);\n            if (log.isTraceEnabled()) {\n                log.trace(\"resending msg \" + msg + \" to coord (\" + coord + \")\");\n            }\n            down_prot.down(new Event(Event.MSG, msg));\n        }\n    }","id":9849,"modified_method":"/**\n     * Sends all messages currently in forward_table to the new coordinator (changing the dest field).\n     * This needs to be done, so the underlying reliable unicast protocol (e.g. UNICAST) adds these messages\n     * to its retransmission mechanism<br/>\n     * Note that we need to resend the messages in order of their seqnos ! We also need to prevent other message\n     * from being inserted until we're done, that's why there's synchronization.\n     */\n    private void resendMessagesInForwardTable() {\n        Map<Long,byte[]> copy;\n        synchronized(forward_table) {\n            copy=new TreeMap<Long,byte[]>(forward_table);\n        }\n        for(Map.Entry<Long,byte[]> entry: copy.entrySet()) {\n            Long key=entry.getKey();\n            byte[] val=entry.getValue();\n\n            Message forward_msg=new Message(coord, null, val);\n            SequencerHeader hdr=new SequencerHeader(SequencerHeader.FORWARD, local_addr, key);\n            forward_msg.putHeader(name, hdr);\n\n            if (log.isTraceEnabled()) {\n                log.trace(\"resending msg \" + local_addr + \"::\" + key + \" to coord (\" + coord + \")\");\n            }\n            down_prot.down(new Event(Event.MSG, forward_msg));\n        }\n    }","commit_id":"85608a5c55f5e0b9490325567ba38740eaf8a7ec","url":"https://github.com/belaban/JGroups"},{"original_method":"private final String printType() {\n            switch(type) {\n                case FORWARD: return \"FORWARD\";\n                case BCAST:   return \"BCAST\";\n                default:      return \"n/a\";\n            }\n        }","id":9850,"modified_method":"private final String printType() {\n            switch(type) {\n                case FORWARD:        return \"FORWARD\";\n                case BCAST:          return \"BCAST\";\n                case WRAPPED_BCAST:  return \"WRAPPED_BCAST\";\n                default:             return \"n/a\";\n            }\n        }","commit_id":"85608a5c55f5e0b9490325567ba38740eaf8a7ec","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * We copy the message in order to change the sender's address. If we did this on the original message,\n     * retransmission would likely run into problems, and possibly also stability (STABLE) of messages\n     * @param msg\n     * @param hdr\n     */\n    private void deliver(Message msg, SequencerHeader hdr) {\n        Address original_sender=hdr.getOriginalSender();\n        if(original_sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"original sender is null, cannot swap sender's address back to original sender\");\n            return;\n        }\n        long msg_seqno=hdr.getSeqno();\n        if (log.isTraceEnabled()) {\n            log.trace(\"delivering msg \" + msg + \" (seqno \" + msg_seqno + \"), original sender \" + original_sender);\n        }\n\n        // this is the ack for the message sent by myself\n        if(original_sender.equals(local_addr)) {\n            synchronized(forward_table) {\n                forward_table.remove(msg_seqno);\n            }\n        }\n\n        // if msg was already delivered, discard it\n        boolean added=received_table.add(original_sender, msg_seqno);\n        if(!added) {\n            if(log.isWarnEnabled())\n                log.warn(\"seqno (\" + original_sender + \"::\" + msg_seqno + \" has already been received \" +\n                        \"(highest received=\" + received_table.getHighestReceived(original_sender) +\n                        \"); discarding duplicate message\");\n            return;\n        }\n\n        // pass a copy of the message up the stack\n        Message tmp=msg.copy(true);\n        tmp.setSrc(original_sender);\n        up_prot.up(new Event(Event.MSG, tmp));\n    }","id":9851,"modified_method":"/**\n     * We copy the message in order to change the sender's address. If we did this on the original message,\n     * retransmission would likely run into problems, and possibly also stability (STABLE) of messages\n     * @param msg\n     * @param hdr\n     */\n    private void deliver(Message msg, SequencerHeader hdr, boolean unwrap) {\n        if(unwrap) {\n            try {\n                hdr=(SequencerHeader)msg.getHeader(name);\n                long msg_seqno=hdr.getSeqno();\n                Message msg_to_deliver=(Message)Util.objectFromByteBuffer(msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n\n                if(!canDeliver(msg_to_deliver.getSrc(), msg_seqno))\n                    return;\n                if(log.isTraceEnabled())\n                    log.trace(\"delivering msg \" + msg + \" (seqno \" + msg_seqno + \"), original sender \" + msg.getSrc());\n\n                up_prot.up(new Event(Event.MSG, msg_to_deliver));\n            }\n            catch(Exception e) {\n                log.error(\"failure unmarshalling buffer\", e);\n            }\n            return;\n        }\n\n\n        Address original_sender=hdr.getOriginalSender();\n        if(original_sender == null) {\n            if(log.isErrorEnabled())\n                log.error(\"original sender is null, cannot swap sender's address back to original sender\");\n            return;\n        }\n        long msg_seqno=hdr.getSeqno();\n        if(!canDeliver(original_sender, msg_seqno))\n            return;\n        if(log.isTraceEnabled())\n            log.trace(\"delivering msg \" + msg + \" (seqno \" + msg_seqno + \"), original sender \" + original_sender);\n\n        // pass a copy of the message up the stack\n        Message tmp=msg.copy(true);\n        tmp.setSrc(original_sender);\n        up_prot.up(new Event(Event.MSG, tmp));\n    }","commit_id":"85608a5c55f5e0b9490325567ba38740eaf8a7ec","url":"https://github.com/belaban/JGroups"},{"original_method":"private void broadcast(final Message msg, boolean copy) {\n        Message bcast_msg=null;\n        final SequencerHeader hdr=(SequencerHeader)msg.getHeader(name);\n\n        if(!copy) {\n            bcast_msg=msg;\n        }\n        else {\n            bcast_msg=new Message(null, local_addr, msg.getBuffer(), msg.getOffset(), msg.getLength());\n            SequencerHeader new_hdr=new SequencerHeader(SequencerHeader.BCAST, hdr.getOriginalSender(), hdr.getSeqno());\n            bcast_msg.putHeader(name, new_hdr);\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"broadcasting msg \" + bcast_msg + \" (seqno \" + hdr.getSeqno() + \")\");\n\n        down_prot.down(new Event(Event.MSG, bcast_msg));\n        bcast_msgs++;\n    }","id":9852,"modified_method":"private void broadcast(final Message msg, boolean copy) {\n        Message bcast_msg=null;\n        final SequencerHeader hdr=(SequencerHeader)msg.getHeader(name);\n\n        if(!copy) {\n            bcast_msg=msg; // no need to add a header, message already has one\n        }\n        else {\n            bcast_msg=new Message(null, local_addr, msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n            SequencerHeader new_hdr=new SequencerHeader(SequencerHeader.WRAPPED_BCAST, hdr.getOriginalSender(), hdr.getSeqno());\n            bcast_msg.putHeader(name, new_hdr);\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"broadcasting msg \" + bcast_msg + \" (seqno \" + hdr.getSeqno() + \")\");\n\n        down_prot.down(new Event(Event.MSG, bcast_msg));\n        bcast_msgs++;\n    }","commit_id":"85608a5c55f5e0b9490325567ba38740eaf8a7ec","url":"https://github.com/belaban/JGroups"},{"original_method":"public Object up(Event evt) {\n        Message msg;\n        SequencerHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                hdr=(SequencerHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break; // pass up\n\n                switch(hdr.type) {\n                    case SequencerHeader.FORWARD:\n                        if(!is_coord) {\n                            if(log.isErrorEnabled())\n                                log.error(local_addr + \": non-coord; dropping FORWARD request from \" + msg.getSrc());\n                            return null;\n                        }\n                        broadcast(msg, true); // do copy the message\n                        received_forwards++;\n                        return null;\n                    case SequencerHeader.BCAST:\n                        deliver(msg, hdr);  // deliver a copy and return (discard the original msg)\n                        received_bcasts++;\n                        return null;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n        }\n\n        return up_prot.up(evt);\n    }","id":9853,"modified_method":"public Object up(Event evt) {\n        Message msg;\n        SequencerHeader hdr;\n\n        switch(evt.getType()) {\n            case Event.MSG:\n                msg=(Message)evt.getArg();\n                hdr=(SequencerHeader)msg.getHeader(name);\n                if(hdr == null)\n                    break; // pass up\n\n                switch(hdr.type) {\n                    case SequencerHeader.FORWARD:\n                        if(!is_coord) {\n                            if(log.isErrorEnabled())\n                                log.error(local_addr + \": non-coord; dropping FORWARD request from \" + msg.getSrc());\n                            return null;\n                        }\n                        broadcast(msg, true); // do copy the message\n                        received_forwards++;\n                        return null;\n\n                    case SequencerHeader.BCAST:\n                        deliver(msg, hdr, false);  // deliver a copy and return (discard the original msg)\n                        received_bcasts++;\n                        return null;\n\n                    case SequencerHeader.WRAPPED_BCAST:\n                        deliver(msg, hdr, true);  // unwrap the original message (in the payload) and deliver it\n                        received_bcasts++;\n                        return null;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                handleViewChange((View)evt.getArg());\n                break;\n        }\n\n        return up_prot.up(evt);\n    }","commit_id":"85608a5c55f5e0b9490325567ba38740eaf8a7ec","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      GridBagLayout layout = new GridBagLayout();\n      JPanel pagePanel = new JPanel(layout);\n      Insets insets = new Insets(0,0,0,0);\n      GridBagConstraints gbc = new GridBagConstraints(0,0,1,1,1.,1.,GridBagConstraints.FIRST_LINE_START, GridBagConstraints.BOTH, insets, 0, 0);\n\n      final JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));\n\n      final JTextArea info = new JTextArea(\n        \"Some models in this project are stored in the persistence version that is no longer supported.\" +\n          \"\\n\\n\" +\n          \"You have to manually upgrade persistence of these models using a previous version of MPS.\" +\n          \"\\n\\n\" +\n          \"The migration cannot proceed.\",\n        10, 40);\n      info.setLineWrap(true);\n      info.setWrapStyleWord(true);\n      info.setEditable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      pagePanel.add(infoHolder);\n      layout.setConstraints(infoHolder, gbc);\n\n      gbc.gridy++;\n      gbc.anchor = GridBagConstraints.LAST_LINE_START;\n      gbc.weightx = 0.;\n\n      myList = new JBList(getModelPaths());\n\n      JPanel listPanel = new JPanel(new BorderLayout(5, 5)) {\n        @Override\n        public Dimension getPreferredSize() {\n          Dimension preferredSize = super.getPreferredSize();\n          return new Dimension(infoHolder.getPreferredSize().width, preferredSize.height);\n        }\n      };\n      listPanel.setBorder(BorderFactory.createCompoundBorder(\n        BorderFactory.createEmptyBorder(2, 2, 2, 2),\n        BorderFactory.createEtchedBorder()));\n      listPanel.add(new JBScrollPane(myList), BorderLayout.CENTER);\n\n      pagePanel.add(listPanel);\n      layout.setConstraints(listPanel, gbc);\n\n      myComponent.add(pagePanel, BorderLayout.CENTER);\n    }","id":9854,"modified_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      GridBagLayout layout = new GridBagLayout();\n      JPanel pagePanel = new JPanel(layout);\n      Insets insets = new Insets(0,0,0,0);\n      GridBagConstraints gbc = new GridBagConstraints(0,0,1,1,1.,1.,GridBagConstraints.FIRST_LINE_START, GridBagConstraints.BOTH, insets, 0, 0);\n\n      final JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));\n\n      JTextPane info = new JTextPane();\n      info.setContentType(\"text/html\");\n      info.setText(\"Some models in this project are stored in the persistence version that is no longer supported.\" +\n        \"<br><br>\" +\n        \"You have to manually upgrade persistence of these models using a previous version of MPS.\" +\n        \"<br><br>\" +\n        \"The migration cannot proceed.\");\n      info.setEditable(false);\n      info.setFocusable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n      info.setPreferredSize(new Dimension(300, 160));\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      pagePanel.add(infoHolder);\n      layout.setConstraints(infoHolder, gbc);\n\n      gbc.gridy++;\n      gbc.anchor = GridBagConstraints.LAST_LINE_START;\n      gbc.weightx = 0.;\n\n      myList = new JBList(getModelPaths());\n\n      JPanel listPanel = new JPanel(new BorderLayout(5, 5)) {\n        @Override\n        public Dimension getPreferredSize() {\n          Dimension preferredSize = super.getPreferredSize();\n          return new Dimension(infoHolder.getPreferredSize().width, preferredSize.height);\n        }\n      };\n      listPanel.setBorder(BorderFactory.createCompoundBorder(\n        BorderFactory.createEmptyBorder(2, 2, 2, 2),\n        BorderFactory.createEtchedBorder()));\n      listPanel.add(new JBScrollPane(myList), BorderLayout.CENTER);\n\n      pagePanel.add(listPanel);\n      layout.setConstraints(listPanel, gbc);\n\n      myComponent.add(pagePanel, BorderLayout.CENTER);\n    }","commit_id":"6f0b0f66bf199a439e40eae81d4bad3018a6d1e3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      GridBagLayout layout = new GridBagLayout();\n      JPanel pagePanel = new JPanel(layout);\n      Insets insets = new Insets(0,0,0,0);\n      GridBagConstraints gbc = new GridBagConstraints(0,0,1,1,1.,1.,GridBagConstraints.FIRST_LINE_START, GridBagConstraints.BOTH, insets, 0, 0);\n\n      JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n\n      JTextArea info = new JTextArea(\n        \"Welcome to Migration Assistant!\" +\n          \"\\n\\n\" +\n          \"MPS has detected that your project requires migration before it can be used with this version of the product.\" +\n          \"\\n\\n\" +\n          \"This wizard will guide you through the migration process. It's going to take a while.\" +\n          \"\\n\\n\" +\n          \"Select Next to proceed with migration or Cancel if you wish to postpone it.\",\n        15, 40);\n      info.setLineWrap(true);\n      info.setWrapStyleWord(true);\n      info.setEditable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      pagePanel.add(infoHolder);\n      layout.setConstraints(infoHolder, gbc);\n\n      gbc.gridy++;\n      gbc.anchor = GridBagConstraints.LAST_LINE_START;\n      gbc.weightx = 0.;\n      gbc.weighty = 0.;\n\n      mySelectActions = new JBCheckBox(\"Select Migration Actions\");\n      mySelectActions.setSelected(false);\n\n      pagePanel.add(mySelectActions);\n      layout.setConstraints(mySelectActions, gbc);\n\n      myComponent.add(pagePanel, BorderLayout.CENTER);\n    }","id":9855,"modified_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      GridBagLayout layout = new GridBagLayout();\n      JPanel pagePanel = new JPanel(layout);\n      Insets insets = new Insets(0,0,0,0);\n      GridBagConstraints gbc = new GridBagConstraints(0,0,1,1,1.,1.,GridBagConstraints.FIRST_LINE_START, GridBagConstraints.BOTH, insets, 0, 0);\n\n      JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n\n      JTextPane info = new JTextPane();\n      info.setContentType(\"text/html\");\n      info.setText(\"Welcome to Migration Assistant!\" +\n        \"<br><br>\" +\n        \"MPS has detected that your project requires migration before it can be used with this version of the product.\" +\n        \"<br><br>\" +\n        \"This wizard will guide you through the migration process. It's going to take a while.\" +\n        \"<br><br>\" +\n        \"Select Next to proceed with migration or Cancel if you wish to postpone it.\");\n      info.setEditable(false);\n      info.setFocusable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n      info.setPreferredSize(new Dimension(300, 160));\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      pagePanel.add(infoHolder);\n      layout.setConstraints(infoHolder, gbc);\n\n      gbc.gridy++;\n      gbc.anchor = GridBagConstraints.LAST_LINE_START;\n      gbc.weightx = 0.;\n      gbc.weighty = 0.;\n\n      mySelectActions = new JBCheckBox(\"Select Migration Actions\");\n      mySelectActions.setSelected(false);\n\n      pagePanel.add(mySelectActions);\n      layout.setConstraints(mySelectActions, gbc);\n\n      myComponent.add(pagePanel, BorderLayout.CENTER);\n    }","commit_id":"6f0b0f66bf199a439e40eae81d4bad3018a6d1e3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n\n      JTextArea info = new JTextArea(\n        \"Warning! Although migration has completed, there were some errors during the process. Please review the errors log.\" +\n          \"\\n\\n\" +\n          \"Your project files have been upgraded to be used with the latest version of MPS.\" +\n          \"\\n\\n\" +\n          \"The wizard can now be closed and your project will be loaded.\",\n        15, 40);\n      info.setLineWrap(true);\n      info.setWrapStyleWord(true);\n      info.setEditable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      myComponent.add(infoHolder, BorderLayout.CENTER);\n    }","id":9856,"modified_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n\n      JTextPane info = new JTextPane();\n      info.setContentType(\"text/html\");\n      info.setText(\"Warning! Although migration has completed, there were some errors during the process. Please review the errors log.\" +\n        \"<br><br>\" +\n        \"Your project files have been upgraded to be used with the latest version of MPS.\" +\n        \"<br><br>\" +\n        \"The wizard can now be closed and your project will be loaded.\" +\n        \"<br><br>\" +\n        \"Now we recommend reading MPS 2.5 Migration Guide document at: \" +\n        \"<a href=\\\"http://confluence.jetbrains.com/display/MPS/Migration+to+MPS+2.5\\\">http://confluence.jetbrains.com/display/MPS/Migration+to+MPS+2.5<\/a> \" +\n        \"to control the project structure manually and ensure no more \" +\n        \"modifications are required.\");\n      info.setEditable(false);\n      info.addHyperlinkListener(new HyperlinkListener() {\n        public void hyperlinkUpdate(HyperlinkEvent e) {\n          if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n            BrowserUtil.launchBrowser(e.getURL().toString());\n          }\n        }\n      });\n      info.setFocusable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n      info.setPreferredSize(new Dimension(300, 160));\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      myComponent.add(infoHolder, BorderLayout.CENTER);\n    }","commit_id":"6f0b0f66bf199a439e40eae81d4bad3018a6d1e3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n\n      JTextArea info = new JTextArea(\n        \"Congratulations! Migration has completed successfully.\" +\n          \"\\n\\n\" +\n          \"Your project files have been upgraded to be used with the latest version of MPS.\" +\n          \"\\n\\n\" +\n          \"The wizard can now be closed and your project will be loaded.\",\n        15, 40);\n      info.setLineWrap(true);\n      info.setWrapStyleWord(true);\n      info.setEditable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      myComponent.add(infoHolder, BorderLayout.CENTER);\n    }","id":9857,"modified_method":"@Override\n    protected final void createComponent() {\n      super.createComponent();\n\n      JPanel infoHolder = new JPanel(new BorderLayout());\n      infoHolder.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));\n\n      JTextPane info = new JTextPane();\n      info.setContentType(\"text/html\");\n      info.setText(\"Congratulations! Migration has completed successfully.\" +\n        \"<br><br>\" +\n        \"Your project files have been upgraded to be used with the latest version of MPS.\" +\n        \"<br><br>\" +\n        \"The wizard can now be closed and your project will be loaded.\" +\n        \"<br><br>\" +\n        \"Now we recommend reading MPS 2.5 Migration Guide document at: \" +\n        \"<a href=\\\"http://confluence.jetbrains.com/display/MPS/Migration+to+MPS+2.5\\\">http://confluence.jetbrains.com/display/MPS/Migration+to+MPS+2.5<\/a> \" +\n        \"to control the project structure manually and ensure no more \" +\n        \"modifications are required.\");\n      info.setEditable(false);\n      info.addHyperlinkListener(new HyperlinkListener() {\n        public void hyperlinkUpdate(HyperlinkEvent e) {\n          if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n            BrowserUtil.launchBrowser(e.getURL().toString());\n          }\n        }\n      });\n      info.setFocusable(false);\n      info.setBorder(BorderFactory.createLoweredBevelBorder());\n      info.setPreferredSize(new Dimension(300, 160));\n\n      infoHolder.add(info, BorderLayout.CENTER);\n\n      myComponent.add(infoHolder, BorderLayout.CENTER);\n    }","commit_id":"6f0b0f66bf199a439e40eae81d4bad3018a6d1e3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void parseHeaders(HttpResponse response, ByteBuf buffer) {\n    StringBuilder builder = new StringBuilder();\n    while (buffer.isReadable()) {\n      builder.setLength(0);\n\n      String key = null;\n      boolean valueExpected = true;\n      while (true) {\n        int b = buffer.readByte();\n        if (b < 0 || b == '\\n') {\n          break;\n        }\n\n        if (b != '\\r') {\n          if (valueExpected && b == ':') {\n            valueExpected = false;\n\n            key = builder.toString();\n            builder.setLength(0);\n            skipWhitespace(buffer);\n          }\n          else {\n            builder.append((char)b);\n          }\n        }\n      }\n\n      if (builder.length() == 0) {\n        // end of headers\n        return;\n      }\n\n      // skip standard headers\n      if (StringUtil.isEmpty(key) || StringUtilRt.startsWithIgnoreCase(key, \"http\") || StringUtilRt.startsWithIgnoreCase(key, \"X-Accel-\")) {\n        continue;\n      }\n\n      String value = builder.toString();\n      if (key.equalsIgnoreCase(\"status\")) {\n        response.setStatus(HttpResponseStatus.valueOf(Integer.parseInt(value.substring(0, value.indexOf(' ')))));\n      }\n      else if (!(key.startsWith(\"http\") || key.startsWith(\"HTTP\"))) {\n        response.headers().add(key, value);\n      }\n    }\n  }","id":9858,"modified_method":"private static void parseHeaders(HttpResponse response, ByteBuf buffer) {\n    StringBuilder builder = new StringBuilder();\n    while (buffer.isReadable()) {\n      builder.setLength(0);\n\n      String key = null;\n      boolean valueExpected = true;\n      while (true) {\n        int b = buffer.readByte();\n        if (b < 0 || b == '\\n') {\n          break;\n        }\n\n        if (b != '\\r') {\n          if (valueExpected && b == ':') {\n            valueExpected = false;\n\n            key = builder.toString();\n            builder.setLength(0);\n            skipWhitespace(buffer);\n          }\n          else {\n            builder.append((char)b);\n          }\n        }\n      }\n\n      if (builder.length() == 0) {\n        // end of headers\n        return;\n      }\n\n      // skip standard headers\n      if (StringUtil.isEmpty(key) || StringUtilRt.startsWithIgnoreCase(key, \"http\") || StringUtilRt.startsWithIgnoreCase(key, \"X-Accel-\")) {\n        continue;\n      }\n\n      String value = builder.toString();\n      if (key.equalsIgnoreCase(\"status\")) {\n        int index = value.indexOf(' ');\n        if (index == -1) {\n          LOG.warn(\"Cannot parse status: \" + value);\n          response.setStatus(HttpResponseStatus.OK);\n        }\n        else {\n          response.setStatus(HttpResponseStatus.valueOf(Integer.parseInt(value.substring(0, index))));\n        }\n      }\n      else if (!(key.startsWith(\"http\") || key.startsWith(\"HTTP\"))) {\n        response.headers().add(key, value);\n      }\n    }\n  }","commit_id":"a367187f318986eaf35e2e84bf3bd0a98fdbc6c8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        // update an index with number of replicas based on data nodes if possible\n        if (!event.state().nodes().localNodeMaster()) {\n            return;\n        }\n\n        Map<Integer, List<String>> nrReplicasChanged = new HashMap<>();\n\n        // we need to do this each time in case it was changed by update settings\n        for (final IndexMetaData indexMetaData : event.state().metaData()) {\n            String autoExpandReplicas = indexMetaData.settings().get(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS);\n            if (autoExpandReplicas != null && Booleans.parseBoolean(autoExpandReplicas, true)) { // Booleans only work for false values, just as we want it here\n                try {\n                    int min;\n                    int max;\n                    try {\n                        min = Integer.parseInt(autoExpandReplicas.substring(0, autoExpandReplicas.indexOf('-')));\n                        String sMax = autoExpandReplicas.substring(autoExpandReplicas.indexOf('-') + 1);\n                        if (sMax.equals(\"all\")) {\n                            max = event.state().nodes().dataNodes().size() - 1;\n                        } else {\n                            max = Integer.parseInt(sMax);\n                        }\n                    } catch (Exception e) {\n                        logger.warn(\"failed to set [{}], wrong format [{}]\", e, IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, autoExpandReplicas);\n                        continue;\n                    }\n\n                    int numberOfReplicas = event.state().nodes().dataNodes().size() - 1;\n                    if (numberOfReplicas < min) {\n                        numberOfReplicas = min;\n                    } else if (numberOfReplicas > max) {\n                        numberOfReplicas = max;\n                    }\n\n                    // same value, nothing to do there\n                    if (numberOfReplicas == indexMetaData.numberOfReplicas()) {\n                        continue;\n                    }\n\n                    if (numberOfReplicas >= min && numberOfReplicas <= max) {\n\n                        if (!nrReplicasChanged.containsKey(numberOfReplicas)) {\n                            nrReplicasChanged.put(numberOfReplicas, new ArrayList<String>());\n                        }\n\n                        nrReplicasChanged.get(numberOfReplicas).add(indexMetaData.index());\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"[{}] failed to parse auto expand replicas\", e, indexMetaData.index());\n                }\n            }\n        }\n\n        if (nrReplicasChanged.size() > 0) {\n            for (final Integer fNumberOfReplicas : nrReplicasChanged.keySet()) {\n                Settings settings = ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, fNumberOfReplicas).build();\n                final List<String> indices = nrReplicasChanged.get(fNumberOfReplicas);\n\n                UpdateSettingsClusterStateUpdateRequest updateRequest = new UpdateSettingsClusterStateUpdateRequest()\n                        .indices(indices.toArray(new String[indices.size()])).settings(settings)\n                        .ackTimeout(TimeValue.timeValueMillis(0)) //no need to wait for ack here\n                        .masterNodeTimeout(TimeValue.timeValueMinutes(10));\n\n                updateSettings(updateRequest, new ClusterStateUpdateListener() {\n                    @Override\n                    public void onResponse(ClusterStateUpdateResponse response) {\n                        for (String index : indices) {\n                            logger.info(\"[{}] auto expanded replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n\n                    @Override\n                    public void onFailure(Throwable t) {\n                        for (String index : indices) {\n                            logger.warn(\"[{}] fail to auto expand replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n                });\n            }\n        }\n    }","id":9859,"modified_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        // update an index with number of replicas based on data nodes if possible\n        if (!event.state().nodes().localNodeMaster()) {\n            return;\n        }\n        // we will want to know this for translating \"all\" to a number\n        final int dataNodeCount = event.state().nodes().dataNodes().size();\n\n        Map<Integer, List<String>> nrReplicasChanged = new HashMap<>();\n\n        // we need to do this each time in case it was changed by update settings\n        for (final IndexMetaData indexMetaData : event.state().metaData()) {\n            String autoExpandReplicas = indexMetaData.settings().get(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS);\n            if (autoExpandReplicas != null && Booleans.parseBoolean(autoExpandReplicas, true)) { // Booleans only work for false values, just as we want it here\n                try {\n                    final int min;\n                    final int max;\n\n                    final int dash = autoExpandReplicas.indexOf('-');\n                    if (-1 == dash) {\n                        logger.warn(\"Unexpected value [{}] for setting [{}]; it should be dash delimited\",\n                                autoExpandReplicas, IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS);\n                        continue;\n                    }\n                    final String sMin = autoExpandReplicas.substring(0, dash);\n                    try {\n                        min = Integer.parseInt(sMin);\n                    } catch (NumberFormatException e) {\n                        logger.warn(\"failed to set [{}], minimum value is not a number [{}]\",\n                                e, IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, sMin);\n                        continue;\n                    }\n                    String sMax = autoExpandReplicas.substring(dash + 1);\n                    if (sMax.equals(ALL_NODES_VALUE)) {\n                        max = dataNodeCount - 1;\n                    } else {\n                        try {\n                            max = Integer.parseInt(sMax);\n                        } catch (NumberFormatException e) {\n                            logger.warn(\"failed to set [{}], maximum value is neither [{}] nor a number [{}]\",\n                                    e, IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, ALL_NODES_VALUE, sMax);\n                            continue;\n                        }\n                    }\n\n                    int numberOfReplicas = dataNodeCount - 1;\n                    if (numberOfReplicas < min) {\n                        numberOfReplicas = min;\n                    } else if (numberOfReplicas > max) {\n                        numberOfReplicas = max;\n                    }\n\n                    // same value, nothing to do there\n                    if (numberOfReplicas == indexMetaData.numberOfReplicas()) {\n                        continue;\n                    }\n\n                    if (numberOfReplicas >= min && numberOfReplicas <= max) {\n\n                        if (!nrReplicasChanged.containsKey(numberOfReplicas)) {\n                            nrReplicasChanged.put(numberOfReplicas, new ArrayList<String>());\n                        }\n\n                        nrReplicasChanged.get(numberOfReplicas).add(indexMetaData.index());\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"[{}] failed to parse auto expand replicas\", e, indexMetaData.index());\n                }\n            }\n        }\n\n        if (nrReplicasChanged.size() > 0) {\n            for (final Integer fNumberOfReplicas : nrReplicasChanged.keySet()) {\n                Settings settings = ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, fNumberOfReplicas).build();\n                final List<String> indices = nrReplicasChanged.get(fNumberOfReplicas);\n\n                UpdateSettingsClusterStateUpdateRequest updateRequest = new UpdateSettingsClusterStateUpdateRequest()\n                        .indices(indices.toArray(new String[indices.size()])).settings(settings)\n                        .ackTimeout(TimeValue.timeValueMillis(0)) //no need to wait for ack here\n                        .masterNodeTimeout(TimeValue.timeValueMinutes(10));\n\n                updateSettings(updateRequest, new ClusterStateUpdateListener() {\n                    @Override\n                    public void onResponse(ClusterStateUpdateResponse response) {\n                        for (String index : indices) {\n                            logger.info(\"[{}] auto expanded replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n\n                    @Override\n                    public void onFailure(Throwable t) {\n                        for (String index : indices) {\n                            logger.warn(\"[{}] fail to auto expand replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n                });\n            }\n        }\n    }","commit_id":"b0a85f6ca38ff741f3d9d89e7cac8be38d970ed8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void fillColorRange(@NotNull final Runnable returnToMain) {\n    Consumer<PyDebugValue> callback = new Consumer<PyDebugValue>() {\n      @Override\n      public void consume(@NotNull PyDebugValue result) {\n        String rawValue = result.getValue();\n        double min;\n        double max;\n        String minValue = rawValue.substring(1, rawValue.indexOf(\",\"));\n        String maxValue = rawValue.substring(rawValue.indexOf(\", \") + 2, rawValue.length() - 1);\n        if (\"c\".equals(myDtypeKind)) {\n          min = 0;\n          max = 1;\n          myTableCellRenderer.setComplexMin(minValue);\n          myTableCellRenderer.setComplexMax(maxValue);\n        }\n        else if (\"b\".equals(myDtypeKind)) {\n          min = minValue.equals(\"True\") ? 1 : 0;\n          max = maxValue.equals(\"True\") ? 1 : 0;\n        }\n        else {\n          min = Double.parseDouble(minValue);\n          max = Double.parseDouble(maxValue);\n        }\n\n        myTableCellRenderer.setMin(min);\n        myTableCellRenderer.setMax(max);\n        returnToMain.run();\n      }\n    };\n\n    if (getMaxRow(myShape) * getMaxColumn(myShape) > HUGE_ARRAY_SIZE) {\n      disableColor();\n      returnToMain.run();\n    }\n\n    String evalTypeCommand = \"[\" + getNodeName() + \".min(), \" + getNodeName() + \".max()]\";\n    try {\n      PyDebugValue value = getEvaluator().evaluate(evalTypeCommand, true, false);\n      callback.consume(value);\n    }\n    catch (PyDebuggerException e) {\n      showError(e.getMessage());\n    }\n  }","id":9860,"modified_method":"private void fillColorRange(@NotNull final Runnable returnToMain) {\n    Consumer<PyDebugValue> callback = new Consumer<PyDebugValue>() {\n      @Override\n      public void consume(@NotNull PyDebugValue result) {\n        String rawValue = result.getValue();\n        double min;\n        double max;\n        String minValue = rawValue.substring(1, rawValue.indexOf(\",\"));\n        String maxValue = rawValue.substring(rawValue.indexOf(\", \") + 2, rawValue.length() - 1);\n        if (\"c\".equals(myDtypeKind)) {\n          min = 0;\n          max = 1;\n          myTableCellRenderer.setComplexMin(minValue);\n          myTableCellRenderer.setComplexMax(maxValue);\n        }\n        else if (\"b\".equals(myDtypeKind)) {\n          min = minValue.equals(\"True\") ? 1 : 0;\n          max = maxValue.equals(\"True\") ? 1 : 0;\n        }\n        else {\n          min = Double.parseDouble(minValue);\n          max = Double.parseDouble(maxValue);\n        }\n\n        myTableCellRenderer.setMin(min);\n        myTableCellRenderer.setMax(max);\n        returnToMain.run();\n      }\n    };\n\n    if (getMaxRow(myShape) * getMaxColumn(myShape) > HUGE_ARRAY_SIZE) {\n      disableColor();\n      returnToMain.run();\n    }\n\n    String evalTypeCommand = \"[\" + getNodeName() + \".min(), \" + getNodeName() + \".max()]\";\n    try {\n      PyDebugValue value = getEvaluator().evaluate(evalTypeCommand, false, false);\n      callback.consume(value);\n    }\n    catch (PyDebuggerException e) {\n      showError(e.getMessage());\n    }\n  }","commit_id":"197a04127938fd6ad028f6037a39affe5003707e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillShape(@NotNull final Runnable returnToMain) {\n    String evalShapeCommand = getEvalShapeCommand(getNodeName());\n    try {\n      PyDebugValue value = getEvaluator().evaluate(evalShapeCommand, true, false);\n      setShape(parseShape(value.getValue()));\n      returnToMain.run();\n    }\n    catch (Exception e) {\n      showError(e.getMessage());\n    }\n  }","id":9861,"modified_method":"private void fillShape(@NotNull final Runnable returnToMain) {\n    String evalShapeCommand = getEvalShapeCommand(getNodeName());\n    try {\n      PyDebugValue value = getEvaluator().evaluate(evalShapeCommand, false, false);\n      setShape(parseShape(value.getValue()));\n      returnToMain.run();\n    }\n    catch (Exception e) {\n      showError(e.getMessage());\n    }\n  }","commit_id":"197a04127938fd6ad028f6037a39affe5003707e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int[] parseShape(String value) throws InvalidAttributeValueException {\n    String shape = value.substring(0, value.indexOf('#'));\n    if (shape.equals(\"()\")) {\n      return new int[]{1, 1};\n    }\n\n    String[] dimensions = shape.substring(1, shape.length() - 1).trim().split(\",\");\n    if (dimensions.length > 1) {\n      int[] result = new int[dimensions.length];\n      for (int i = 0; i < dimensions.length; i++) {\n        result[i] = Integer.parseInt(dimensions[i].trim());\n      }\n      return result;\n    }\n    else if (dimensions.length == 1) {\n\n      //special case with 1D arrays arr[i, :] - row,\n      //but arr[:, i] - column with equal shape and ndim\n      //http://stackoverflow.com/questions/16837946/numpy-a-2-rows-1-column-file-loadtxt-returns-1row-2-columns\n      //explanation: http://stackoverflow.com/questions/15165170/how-do-i-maintain-row-column-orientation-of-vectors-in-numpy?rq=1\n      //we use kind of a hack - use information about memory from C_CONTIGUOUS\n\n      boolean isRow = value.substring(value.indexOf(\"#\") + 1).equals(\"True\");\n      int[] result = new int[2];\n      if (isRow) {\n        result[0] = 1;\n        result[1] = Integer.parseInt(dimensions[0].trim());\n      }\n      else {\n        result[1] = 1;\n        result[0] = Integer.parseInt(dimensions[0].trim());\n      }\n      return result;\n    }\n    else {\n      throw new InvalidAttributeValueException(\"Invalid shape string for \" + getNodeName() + \".\");\n    }\n  }","id":9862,"modified_method":"private int[] parseShape(String value) throws InvalidAttributeValueException {\n    int index = value.indexOf('#');\n    if (index == -1) {\n      LOG.error(\"Wrong shape format: \" + value);\n      return new int[]{0, 0};\n    }\n    String shape = value.substring(0, index);\n    if (shape.equals(\"()\")) {\n      return new int[]{1, 1};\n    }\n\n    String[] dimensions = shape.substring(1, shape.length() - 1).trim().split(\",\");\n    if (dimensions.length > 1) {\n      int[] result = new int[dimensions.length];\n      for (int i = 0; i < dimensions.length; i++) {\n        result[i] = Integer.parseInt(dimensions[i].trim());\n      }\n      return result;\n    }\n    else if (dimensions.length == 1) {\n\n      //special case with 1D arrays arr[i, :] - row,\n      //but arr[:, i] - column with equal shape and ndim\n      //http://stackoverflow.com/questions/16837946/numpy-a-2-rows-1-column-file-loadtxt-returns-1row-2-columns\n      //explanation: http://stackoverflow.com/questions/15165170/how-do-i-maintain-row-column-orientation-of-vectors-in-numpy?rq=1\n      //we use kind of a hack - use information about memory from C_CONTIGUOUS\n\n      boolean isRow = value.substring(value.indexOf(\"#\") + 1).equals(\"True\");\n      int[] result = new int[2];\n      if (isRow) {\n        result[0] = 1;\n        result[1] = Integer.parseInt(dimensions[0].trim());\n      }\n      else {\n        result[1] = 1;\n        result[0] = Integer.parseInt(dimensions[0].trim());\n      }\n      return result;\n    }\n    else {\n      throw new InvalidAttributeValueException(\"Invalid shape string for \" + getNodeName() + \".\");\n    }\n  }","commit_id":"197a04127938fd6ad028f6037a39affe5003707e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doReslice(final String newSlice, int[] shape) {\n    if (shape == null) {\n      String evalShapeCommand = getEvalShapeCommand(newSlice);\n      try {\n        PyDebugValue result = getEvaluator().evaluate(evalShapeCommand, true, false);\n        shape = parseShape(((PyDebugValue)result).getValue());\n        if (!is2DShape(shape)) {\n          showError(\"Incorrect slice shape \" + ((PyDebugValue)result).getValue() + \".\");\n        }\n        doReslice(newSlice, shape);\n      }\n      catch (Exception e) {\n        showError(e.getMessage());\n      }\n      return;\n    }\n\n    myShape = shape;\n    reset();\n  }","id":9863,"modified_method":"private void doReslice(final String newSlice, int[] shape) {\n    if (shape == null) {\n      String evalShapeCommand = getEvalShapeCommand(newSlice);\n      try {\n        PyDebugValue result = getEvaluator().evaluate(evalShapeCommand, false, false);\n        shape = parseShape(((PyDebugValue)result).getValue());\n        if (!is2DShape(shape)) {\n          showError(\"Incorrect slice shape \" + ((PyDebugValue)result).getValue() + \".\");\n        }\n        doReslice(newSlice, shape);\n      }\n      catch (Exception e) {\n        showError(e.getMessage());\n      }\n      return;\n    }\n\n    myShape = shape;\n    reset();\n  }","commit_id":"197a04127938fd6ad028f6037a39affe5003707e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fillType(@NotNull final Runnable returnToMain) {\n    String evalTypeCommand = getNodeName() + \".dtype.kind\";\n    try {\n      PyDebugValue value = getEvaluator().evaluate(evalTypeCommand, true, false);\n      setDtypeKind(value.getValue());\n      returnToMain.run();\n    }\n    catch (PyDebuggerException e) {\n      showError(e.getMessage());\n    }\n  }","id":9864,"modified_method":"private void fillType(@NotNull final Runnable returnToMain) {\n    String evalTypeCommand = getNodeName() + \".dtype.kind\";\n    try {\n      PyDebugValue value = getEvaluator().evaluate(evalTypeCommand, false, false);\n      setDtypeKind(value.getValue());\n      returnToMain.run();\n    }\n    catch (PyDebuggerException e) {\n      showError(e.getMessage());\n    }\n  }","commit_id":"197a04127938fd6ad028f6037a39affe5003707e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Long extractPIDFromVMName() {\n        try {\n            //This works on Solaris and should work with any Java VM\n            String vmName = ManagementFactory.getRuntimeMXBean().getName();\n            return Long.parseLong(vmName.substring(0, vmName.indexOf(\"@\")));\n        } catch (RuntimeException e) {\n            LOGGER.debug(\"Native-platform process: failed to parse PID from Java VM name - \" + e.getMessage());\n            return null;\n        }\n    }","id":9865,"modified_method":"private Long extractPIDFromVMName() {\n        //This works on Solaris and should work with any Java VM\n        String vmName = ManagementFactory.getRuntimeMXBean().getName();\n        int separatorPos = vmName.indexOf('@');\n        if (separatorPos > -1) {\n            return Long.parseLong(vmName.substring(0, separatorPos));\n        } else {\n            LOGGER.debug(\"Native-platform process: failed to parse PID from Java VM name\");\n            return null;\n        }\n    }","commit_id":"1ee4a7e8fd3302266615db72aa88a696b16b0b1a","url":"https://github.com/gradle/gradle"},{"original_method":"@DB\n    @Override\n    @ActionEvent(eventType = EventTypes.EVENT_LB_CERT_UPLOAD, eventDescription = \"Uploading a certificate to cloudstack\", async = false)\n    public SslCertResponse uploadSslCert(UploadSslCertCmd certCmd) {\n        try {\n\n            String cert = URLDecoder.decode(certCmd.getCert(), \"UTF-8\");\n            String key = URLDecoder.decode(certCmd.getKey(), \"UTF-8\");\n            String password = certCmd.getPassword();\n            String chain = certCmd.getChain() == null ? null : URLDecoder.decode(certCmd.getChain(), \"UTF-8\");\n\n            validate(cert, key, password, chain);\n            s_logger.debug(\"Certificate Validation succeeded\");\n\n            String fingerPrint = generateFingerPrint(parseCertificate(cert));\n\n            Long accountId = CallContext.current().getCallingAccount().getId();\n            Long domainId = CallContext.current().getCallingAccount().getDomainId();\n\n            SslCertVO certVO = new SslCertVO(cert, key, password, chain, accountId, domainId, fingerPrint);\n            _sslCertDao.persist(certVO);\n\n            return createCertResponse(certVO, null);\n\n        } catch (UnsupportedEncodingException e) {\n            throw new CloudRuntimeException(\"Error decoding certificate data\");\n        }\n\n    }","id":9866,"modified_method":"@DB\n    @Override\n    @ActionEvent(eventType = EventTypes.EVENT_LB_CERT_UPLOAD, eventDescription = \"Uploading a certificate to cloudstack\", async = false)\n    public SslCertResponse uploadSslCert(UploadSslCertCmd certCmd) {\n        try {\n\n            String cert = certCmd.getCert();\n            String key = certCmd.getKey();\n            String password = certCmd.getPassword();\n            String chain = certCmd.getChain();\n\n            validate(cert, key, password, chain);\n            s_logger.debug(\"Certificate Validation succeeded\");\n\n            String fingerPrint = generateFingerPrint(parseCertificate(cert));\n\n            Long accountId = CallContext.current().getCallingAccount().getId();\n            Long domainId = CallContext.current().getCallingAccount().getDomainId();\n\n            SslCertVO certVO = new SslCertVO(cert, key, password, chain, accountId, domainId, fingerPrint);\n            _sslCertDao.persist(certVO);\n\n            return createCertResponse(certVO, null);\n\n        } catch (Exception e) {\n            throw new CloudRuntimeException(\"Error parsing certificate data \" + e.getMessage());\n        }\n\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"public Certificate parseCertificate(String cert) {\n        PEMReader certPem = new PEMReader(new StringReader(cert));\n        try {\n            return (Certificate)certPem.readObject();\n        } catch (Exception e) {\n            throw new InvalidParameterValueException(\"Invalid Certificate format. Expected X509 certificate\");\n        } finally {\n            IOUtils.closeQuietly(certPem);\n        }\n    }","id":9867,"modified_method":"public Certificate parseCertificate(String cert) {\n        PEMReader certPem = new PEMReader(new StringReader(cert));\n        try {\n            return (Certificate)certPem.readObject();\n        } catch (Exception e) {\n            throw new InvalidParameterValueException(\"Invalid Certificate format. Expected X509 certificate. Failed due to \" + e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(certPem);\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertNoChain() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String password = \"user\";\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"If no chain is given, the certificate should be self signed. Else, uploadShould Fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"No chain given and certificate not self signed\"));\n        }\n\n    }","id":9868,"modified_method":"@Test\n    public void runUploadSslCertNoChain() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String password = \"user\";\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"If no chain is given, the certificate should be self signed. Else, uploadShould Fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"No chain given and certificate not self signed\"));\n        }\n\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertNotX509() throws IOException, IllegalAccessException, NoSuchFieldException {\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/non_x509_pem.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given a Certificate which is not X509, upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Expected X509 certificate\"));\n        }\n    }","id":9869,"modified_method":"@Test\n    public void runUploadSslCertNotX509() throws IOException, IllegalAccessException, NoSuchFieldException {\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/non_x509_pem.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given a Certificate which is not X509, upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Expected X509 certificate\"));\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertBadChain() throws IOException, IllegalAccessException, NoSuchFieldException {\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String chainFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String password = \"user\";\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n        String chain = URLEncoder.encode(readFileToString(new File(chainFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        Field chainField = _class.getDeclaredField(\"chain\");\n        chainField.setAccessible(true);\n        chainField.set(uploadCmd, chain);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"The chain given is not the correct chain for the certificate\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Invalid certificate chain\"));\n        }\n    }","id":9870,"modified_method":"@Test\n    public void runUploadSslCertBadChain() throws IOException, IllegalAccessException, NoSuchFieldException {\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String chainFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String password = \"user\";\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n        String chain = readFileToString(new File(chainFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        Field chainField = _class.getDeclaredField(\"chain\");\n        chainField.setAccessible(true);\n        chainField.set(uploadCmd, chain);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"The chain given is not the correct chain for the certificate\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Invalid certificate chain\"));\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertExpiredCert() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/expired_cert.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given an expired certificate, upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Certificate expired\"));\n        }\n    }","id":9871,"modified_method":"@Test\n    public void runUploadSslCertExpiredCert() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/expired_cert.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given an expired certificate, upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Certificate expired\"));\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertBadkeyPair() throws IOException, IllegalAccessException, NoSuchFieldException {\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_random_pkey.key\").getFile();\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Bad public-private key\"));\n        }\n    }","id":9872,"modified_method":"@Test\n    public void runUploadSslCertBadkeyPair() throws IOException, IllegalAccessException, NoSuchFieldException {\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_random_pkey.key\").getFile();\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Bad public-private key\"));\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    /**\n     * Given a certificate signed by a CA and a valid CA chain, upload should succeed\n     */\n    public void runUploadSslCertWithCAChain() throws Exception {\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        TransactionLegacy txn = TransactionLegacy.open(\"runUploadSslCertWithCAChain\");\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String chainFile = getClass().getResource(\"/certs/root_chain.crt\").getFile();\n        String password = \"user\";\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n        String chain = URLEncoder.encode(readFileToString(new File(chainFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        certService._accountDao = Mockito.mock(AccountDao.class);\n        when(certService._accountDao.findByIdIncludingRemoved(anyLong())).thenReturn((AccountVO)account);\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        Field chainField = _class.getDeclaredField(\"chain\");\n        chainField.setAccessible(true);\n        chainField.set(uploadCmd, chain);\n\n        certService.uploadSslCert(uploadCmd);\n    }","id":9873,"modified_method":"@Test\n    /**\n     * Given a certificate signed by a CA and a valid CA chain, upload should succeed\n     */\n    public void runUploadSslCertWithCAChain() throws Exception {\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        TransactionLegacy txn = TransactionLegacy.open(\"runUploadSslCertWithCAChain\");\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String chainFile = getClass().getResource(\"/certs/root_chain.crt\").getFile();\n        String password = \"user\";\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n        String chain = readFileToString(new File(chainFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        certService._accountDao = Mockito.mock(AccountDao.class);\n        when(certService._accountDao.findByIdIncludingRemoved(anyLong())).thenReturn((AccountVO)account);\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        Field chainField = _class.getDeclaredField(\"chain\");\n        chainField.setAccessible(true);\n        chainField.set(uploadCmd, chain);\n\n        certService.uploadSslCert(uploadCmd);\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertBadFormat() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/bad_format_cert.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given a Certificate in bad format (Not PEM), upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Invalid certificate format\"));\n        }\n    }","id":9874,"modified_method":"@Test\n    public void runUploadSslCertBadFormat() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/bad_format_cert.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given a Certificate in bad format (Not PEM), upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Invalid certificate format\"));\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertBadkeyAlgo() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/dsa_self_signed.key\").getFile();\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given a private key which has a different algorithm than the certificate, upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Public and private key have different algorithms\"));\n        }\n    }","id":9875,"modified_method":"@Test\n    public void runUploadSslCertBadkeyAlgo() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        // Reading appropritate files\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/dsa_self_signed.key\").getFile();\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given a private key which has a different algorithm than the certificate, upload should fail\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Public and private key have different algorithms\"));\n        }\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertNoRootCert() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String chainFile = getClass().getResource(\"/certs/rsa_ca_signed2.crt\").getFile();\n        String password = \"user\";\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n        String chain = URLEncoder.encode(readFileToString(new File(chainFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        Field chainField = _class.getDeclaredField(\"chain\");\n        chainField.setAccessible(true);\n        chainField.set(uploadCmd, chain);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Chain is given but does not have root certificate\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"No root certificates found\"));\n        }\n\n    }","id":9876,"modified_method":"@Test\n    public void runUploadSslCertNoRootCert() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        Assume.assumeTrue(isOpenJdk() || isJCEInstalled());\n\n        String certFile = getClass().getResource(\"/certs/rsa_ca_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_ca_signed.key\").getFile();\n        String chainFile = getClass().getResource(\"/certs/rsa_ca_signed2.crt\").getFile();\n        String password = \"user\";\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n        String chain = readFileToString(new File(chainFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        Field chainField = _class.getDeclaredField(\"chain\");\n        chainField.setAccessible(true);\n        chainField.set(uploadCmd, chain);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Chain is given but does not have root certificate\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"No root certificates found\"));\n        }\n\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    /**\n     * Given a Self-signed Certificate with non-encrypted key, upload should succeed\n     */\n    public void runUploadSslCertSelfSignedWithPassword() throws Exception {\n\n        TransactionLegacy txn = TransactionLegacy.open(\"runUploadSslCertSelfSignedWithPassword\");\n\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.key\").getFile();\n        String password = \"test\";\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        certService._accountDao = Mockito.mock(AccountDao.class);\n        when(certService._accountDao.findByIdIncludingRemoved(anyLong())).thenReturn((AccountVO)account);\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        certService.uploadSslCert(uploadCmd);\n    }","id":9877,"modified_method":"@Test\n    /**\n     * Given a Self-signed Certificate with non-encrypted key, upload should succeed\n     */\n    public void runUploadSslCertSelfSignedWithPassword() throws Exception {\n\n        TransactionLegacy txn = TransactionLegacy.open(\"runUploadSslCertSelfSignedWithPassword\");\n\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.key\").getFile();\n        String password = \"test\";\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        certService._accountDao = Mockito.mock(AccountDao.class);\n        when(certService._accountDao.findByIdIncludingRemoved(anyLong())).thenReturn((AccountVO)account);\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        certService.uploadSslCert(uploadCmd);\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void runUploadSslCertBadPassword() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.key\").getFile();\n        String password = \"bad_password\";\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given an encrypted private key with a bad password. Upload should fail.\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"please check password and data\"));\n        }\n\n    }","id":9878,"modified_method":"@Test\n    public void runUploadSslCertBadPassword() throws IOException, IllegalAccessException, NoSuchFieldException {\n\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed_with_pwd.key\").getFile();\n        String password = \"bad_password\";\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        Field passField = _class.getDeclaredField(\"password\");\n        passField.setAccessible(true);\n        passField.set(uploadCmd, password);\n\n        try {\n            certService.uploadSslCert(uploadCmd);\n            fail(\"Given an encrypted private key with a bad password. Upload should fail.\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"please check password and data\"));\n        }\n\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    /**\n     * Given a Self-signed Certificate with encrypted key, upload should succeed\n     */\n    public void runUploadSslCertSelfSignedNoPassword() throws Exception {\n\n        TransactionLegacy txn = TransactionLegacy.open(\"runUploadSslCertSelfSignedNoPassword\");\n\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = URLEncoder.encode(readFileToString(new File(certFile)), \"UTF-8\");\n        String key = URLEncoder.encode(readFileToString(new File(keyFile)), \"UTF-8\");\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        certService._accountDao = Mockito.mock(AccountDao.class);\n        when(certService._accountDao.findByIdIncludingRemoved(anyLong())).thenReturn((AccountVO)account);\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        certService.uploadSslCert(uploadCmd);\n    }","id":9879,"modified_method":"@Test\n    /**\n     * Given a Self-signed Certificate with encrypted key, upload should succeed\n     */\n    public void runUploadSslCertSelfSignedNoPassword() throws Exception {\n\n        TransactionLegacy txn = TransactionLegacy.open(\"runUploadSslCertSelfSignedNoPassword\");\n\n        String certFile = getClass().getResource(\"/certs/rsa_self_signed.crt\").getFile();\n        String keyFile = getClass().getResource(\"/certs/rsa_self_signed.key\").getFile();\n\n        String cert = readFileToString(new File(certFile));\n        String key = readFileToString(new File(keyFile));\n\n        CertServiceImpl certService = new CertServiceImpl();\n\n        //setting mock objects\n        certService._accountMgr = Mockito.mock(AccountManager.class);\n        Account account = new AccountVO(\"testaccount\", 1, \"networkdomain\", (short)0, UUID.randomUUID().toString());\n        when(certService._accountMgr.getAccount(anyLong())).thenReturn(account);\n\n        certService._sslCertDao = Mockito.mock(SslCertDao.class);\n        when(certService._sslCertDao.persist(any(SslCertVO.class))).thenReturn(new SslCertVO());\n\n        certService._accountDao = Mockito.mock(AccountDao.class);\n        when(certService._accountDao.findByIdIncludingRemoved(anyLong())).thenReturn((AccountVO)account);\n\n        //creating the command\n        UploadSslCertCmd uploadCmd = new UploadSslCertCmdExtn();\n        Class<?> _class = uploadCmd.getClass().getSuperclass();\n\n        Field certField = _class.getDeclaredField(\"cert\");\n        certField.setAccessible(true);\n        certField.set(uploadCmd, cert);\n\n        Field keyField = _class.getDeclaredField(\"key\");\n        keyField.setAccessible(true);\n        keyField.set(uploadCmd, key);\n\n        certService.uploadSslCert(uploadCmd);\n    }","commit_id":"f2464e418284d366bbe09dced9084966d17ce265","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n  public void find_by_component_key_and_metric_key() throws Exception {\n    setupData(\"shared\");\n\n    MeasureDataDto result = dao.findByComponentKeyAndMetricKey(\"org.sonar.core.measure.db.MeasureData\", \"authors_by_line\");\n    assertThat(result.getId()).isEqualTo(20);\n    assertThat(result.getSnapshotId()).isEqualTo(5);\n    assertThat(result.getText()).isNotNull();\n    assertThat(result.getData()).isNotNull();\n\n    assertThat(result.getText()).isEqualTo(\"0123456789012345678901234567890123456789\");\n  }","id":9880,"modified_method":"@Test\n  public void find_data_by_component_key_and_metric_key() throws Exception {\n    setupData(\"shared\");\n\n    MeasureDataDto result = dao.findByComponentKeyAndMetricKey(\"org.sonar.core.measure.db.MeasureData\", \"authors_by_line\");\n    assertThat(result.getId()).isEqualTo(20);\n    assertThat(result.getSnapshotId()).isEqualTo(5);\n    assertThat(result.getData()).isNotNull();\n\n    assertThat(result.getData()).isEqualTo(\"0123456789012345678901234567890123456789\");\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void find_by_component_key_and_metric_key_without_text() throws Exception {\n    setupData(\"find_by_component_key_and_metric_key_without_text\");\n\n    MeasureDataDto result = dao.findByComponentKeyAndMetricKey(\"org.sonar.core.measure.db.MeasureData\", \"authors_by_line\");\n    assertThat(result.getId()).isEqualTo(20);\n    assertThat(result.getSnapshotId()).isEqualTo(5);\n    assertThat(result.getText()).isNull();\n    assertThat(result.getData()).isNull();\n  }","id":9881,"modified_method":"@Test\n  public void find_text_value_by_component_key_and_metric_key() throws Exception {\n    setupData(\"shared\");\n\n    MeasureDataDto result = dao.findByComponentKeyAndMetricKey(\"org.sonar.core.measure.db.MeasureData\", \"coverage_line_hits_data\");\n    assertThat(result.getId()).isEqualTo(21);\n    assertThat(result.getSnapshotId()).isEqualTo(5);\n    assertThat(result.getData()).isEqualTo(\"36=1;37=1;38=1;39=1;43=1;48=1;53=1\");\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public byte[] getData() {\n    return data;\n  }","id":9882,"modified_method":"@CheckForNull\n  public String getData() {\n    if (data != null) {\n      return new String(data, Charsets.UTF_8);\n    }\n    return textValue;\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private MockUserSession() {\n    globalPermissions = Collections.emptyList();\n    projectKeyByPermission = HashMultimap.create();\n  }","id":9883,"modified_method":"private MockUserSession() {\n    globalPermissions = Collections.emptyList();\n    projectKeyByPermission = HashMultimap.create();\n    authorizationDao = mock(AuthorizationDao.class);\n    resourceDao = mock(ResourceDao.class);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  AuthorizationDao authorizationDao() {\n    return mock(AuthorizationDao.class);\n  }","id":9884,"modified_method":"@Override\n  AuthorizationDao authorizationDao() {\n    return authorizationDao;\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"scm\")\n      .setDescription(\"Get SCM information of source files\")\n      .setSince(\"4.4\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-scm.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1.\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n\n    action\n      .createParam(\"group_commits\")\n      .setDescription(\"Group lines by SCM commit\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"true\");\n  }","id":9885,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"scm\")\n      .setDescription(\"Get SCM information of source files. Require Browse permission on file's project\")\n      .setSince(\"4.4\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-scm.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n\n    action\n      .createParam(\"group_commits\")\n      .setDescription(\"Group lines by SCM commit\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"true\");\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void write(@Nullable String authorsData, @Nullable String datesDate, int from, int to, boolean group, JsonWriter json) {\n    json.name(\"scm\").beginArray();\n    if (authorsData != null) {\n      List<String> authors = splitLine(authorsData);\n      List<String> dates = splitLine(datesDate);\n\n      String previousAuthor = null;\n      String previousDate = null;\n      boolean started = false;\n      for (int i = 0; i < authors.size(); i++) {\n        String[] authorWithLine = splitColumn(authors.get(i));\n        Integer line = Integer.parseInt(authorWithLine[0]);\n        String author = authorWithLine[1];\n\n        String[] dateWithLine = splitColumn(dates.get(i));\n        String date = dateWithLine[1];\n        String formattedDate = DateUtils.formatDate(DateUtils.parseDateTime(date));\n        if (line >= from && line <= to) {\n          if (!started || !group || !isSameCommit(date, previousDate, author, previousAuthor)) {\n            json.beginArray();\n            json.value(line);\n            json.value(author);\n            json.value(formattedDate);\n            json.endArray();\n            started = true;\n          }\n        }\n        previousAuthor = author;\n        previousDate = date;\n      }\n    }\n    json.endArray();\n  }","id":9886,"modified_method":"void write(@Nullable String authorsData, @Nullable String datesData, int from, int to, boolean group, JsonWriter json) {\n    json.name(\"scm\").beginArray();\n    if (authorsData != null) {\n      Map<Integer, String> authors = KeyValueFormat.parseIntString(authorsData);\n      Map<Integer, String> dates = KeyValueFormat.parseIntString(datesData);\n\n      String previousAuthor = null;\n      String previousDate = null;\n      boolean started = false;\n      for (Map.Entry<Integer, String> entry : authors.entrySet()) {\n        Integer line = entry.getKey();\n        String author = entry.getValue();\n        String date = dates.get(line);\n        String formattedDate = DateUtils.formatDate(DateUtils.parseDateTime(date));\n        if (line >= from && line <= to) {\n          if (!started || !group || !isSameCommit(date, previousDate, author, previousAuthor)) {\n            json.beginArray();\n            json.value(line);\n            json.value(author);\n            json.value(formattedDate);\n            json.endArray();\n            started = true;\n          }\n        }\n        previousAuthor = author;\n        previousDate = date;\n      }\n    }\n    json.endArray();\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void startLevel4Components(ComponentContainer pico) {\n    pico.addSingleton(ESIndex.class);\n    pico.addSingleton(PluginDownloader.class);\n    pico.addSingleton(ChartFactory.class);\n    pico.addSingleton(Languages.class);\n    pico.addSingleton(Views.class);\n    pico.addSingleton(CodeColorizers.class);\n    pico.addSingleton(ResourceTypes.class);\n    pico.addSingleton(SettingsChangeNotifier.class);\n    pico.addSingleton(PageDecorations.class);\n    pico.addSingleton(PreviewCache.class);\n    pico.addSingleton(DefaultResourcePermissions.class);\n    pico.addSingleton(Periods.class);\n    pico.addSingleton(ServerWs.class);\n\n    // update center\n    pico.addSingleton(UpdateCenterClient.class);\n    pico.addSingleton(UpdateCenterMatrixFactory.class);\n    pico.addSingleton(UpdateCenterWs.class);\n\n    // quality profile\n    pico.addSingleton(XMLProfileParser.class);\n    pico.addSingleton(XMLProfileSerializer.class);\n    pico.addComponent(ProfilesDao.class, false);\n    pico.addComponent(ProfilesManager.class, false);\n    pico.addSingleton(AnnotationProfileParser.class);\n    pico.addSingleton(QProfileRuleLookup.class);\n    pico.addSingleton(QProfiles.class);\n    pico.addSingleton(QProfileLookup.class);\n    pico.addSingleton(QProfileOperations.class);\n    pico.addSingleton(QProfileActiveRuleOperations.class);\n    pico.addSingleton(QProfileProjectOperations.class);\n    pico.addSingleton(QProfileProjectLookup.class);\n    pico.addSingleton(QProfileBackup.class);\n    pico.addSingleton(QProfileRepositoryExporter.class);\n    pico.addSingleton(DefaultProfilesCache.class);\n    pico.addSingleton(ESActiveRule.class);\n    pico.addSingleton(QProfileRecreateBuiltInAction.class);\n    pico.addSingleton(QProfilesWs.class);\n    pico.addSingleton(ProfilesWs.class);\n    pico.addSingleton(RuleActivationActions.class);\n    pico.addSingleton(ActiveRuleService.class);\n    pico.addSingleton(RuleActivationContextFactory.class);\n\n    // rule\n    pico.addSingleton(AnnotationRuleParser.class);\n    pico.addSingleton(XMLRuleParser.class);\n    pico.addComponent(RulesDao.class, false);\n    pico.addSingleton(DefaultRuleFinder.class);\n    pico.addSingleton(Rules.class);\n    pico.addSingleton(RuleOperations.class);\n    pico.addSingleton(RuleRegistry.class);\n    pico.addSingleton(RubyRuleService.class);\n    pico.addSingleton(RuleRepositories.class);\n    pico.addSingleton(DeprecatedRulesDefinition.class);\n    pico.addSingleton(RuleDefinitionsLoader.class);\n    pico.addSingleton(RulesWs.class);\n    pico.addSingleton(RuleShowWsHandler.class);\n    pico.addSingleton(RuleSearchWsHandler.class);\n    pico.addSingleton(AddTagsWsHandler.class);\n    pico.addSingleton(RemoveTagsWsHandler.class);\n    pico.addSingleton(RulesDefinitionXmlLoader.class);\n\n    // experimental rules\n    pico.addSingleton(RuleService.class);\n    pico.addSingleton(RulesWebService.class);\n    pico.addSingleton(SearchAction.class);\n    pico.addSingleton(org.sonar.server.rule2.ws.ShowAction.class);\n    pico.addSingleton(TagsAction.class);\n    pico.addSingleton(SetTagsAction.class);\n\n    // rule tags\n    pico.addSingleton(ESRuleTags.class);\n    pico.addSingleton(RuleTagLookup.class);\n    pico.addSingleton(RuleTagOperations.class);\n    pico.addSingleton(RuleTags.class);\n    pico.addSingleton(RuleTagsWs.class);\n\n    // measure\n    pico.addComponent(MeasuresDao.class, false);\n    pico.addSingleton(MeasureFilterFactory.class);\n    pico.addSingleton(MeasureFilterExecutor.class);\n    pico.addSingleton(MeasureFilterEngine.class);\n    pico.addSingleton(DefaultMetricFinder.class);\n    pico.addSingleton(ServerLifecycleNotifier.class);\n    pico.addSingleton(TimeMachineWs.class);\n\n    // quality gates\n    pico.addSingleton(QualityGateDao.class);\n    pico.addSingleton(QualityGateConditionDao.class);\n    pico.addSingleton(QualityGates.class);\n    pico.addSingleton(ProjectQgateAssociationDao.class);\n    pico.addSingleton(QgateProjectFinder.class);\n\n    pico.addSingleton(QGatesListAction.class);\n    pico.addSingleton(QGatesSearchAction.class);\n    pico.addSingleton(QGatesShowAction.class);\n    pico.addSingleton(QGatesCreateAction.class);\n    pico.addSingleton(QGatesRenameAction.class);\n    pico.addSingleton(QGatesCopyAction.class);\n    pico.addSingleton(QGatesDestroyAction.class);\n    pico.addSingleton(QGatesSetAsDefaultAction.class);\n    pico.addSingleton(QGatesUnsetDefaultAction.class);\n    pico.addSingleton(QGatesSelectAction.class);\n    pico.addSingleton(QGatesDeselectAction.class);\n    pico.addSingleton(QGatesCreateConditionAction.class);\n    pico.addSingleton(QGatesDeleteConditionAction.class);\n    pico.addSingleton(QGatesUpdateConditionAction.class);\n    pico.addSingleton(QGatesAppAction.class);\n    pico.addSingleton(QGatesWs.class);\n\n    // web services\n    pico.addSingleton(WebServiceEngine.class);\n    pico.addSingleton(ListingWs.class);\n\n    // authentication\n    pico.addSingleton(AuthenticationWs.class);\n\n    // users\n    pico.addSingleton(SecurityRealmFactory.class);\n    pico.addSingleton(HibernateUserFinder.class);\n    pico.addSingleton(NewUserNotifier.class);\n    pico.addSingleton(DefaultUserFinder.class);\n    pico.addSingleton(DefaultUserService.class);\n    pico.addSingleton(UsersWs.class);\n\n    // groups\n    pico.addSingleton(GroupMembershipService.class);\n    pico.addSingleton(GroupMembershipFinder.class);\n\n    // permissions\n    pico.addSingleton(PermissionFacade.class);\n    pico.addSingleton(InternalPermissionService.class);\n    pico.addSingleton(InternalPermissionTemplateService.class);\n    pico.addSingleton(PermissionFinder.class);\n    pico.addSingleton(PermissionsWs.class);\n\n    // components\n    pico.addSingleton(DefaultComponentFinder.class);\n    pico.addSingleton(DefaultRubyComponentService.class);\n    pico.addSingleton(ComponentDao.class);\n    pico.addSingleton(ResourcesWs.class);\n    pico.addSingleton(ComponentsWs.class);\n    pico.addSingleton(ProjectsWs.class);\n\n    // issues\n    pico.addSingleton(ServerIssueStorage.class);\n    pico.addSingleton(IssueUpdater.class);\n    pico.addSingleton(FunctionExecutor.class);\n    pico.addSingleton(IssueWorkflow.class);\n    pico.addSingleton(IssueService.class);\n    pico.addSingleton(IssueCommentService.class);\n    pico.addSingleton(DefaultIssueFinder.class);\n    pico.addSingleton(IssueStatsFinder.class);\n    pico.addSingleton(PublicRubyIssueService.class);\n    pico.addSingleton(InternalRubyIssueService.class);\n    pico.addSingleton(IssueChangelogService.class);\n    pico.addSingleton(IssueNotifications.class);\n    pico.addSingleton(ActionService.class);\n    pico.addSingleton(Actions.class);\n    pico.addSingleton(IssueBulkChangeService.class);\n    pico.addSingleton(IssueChangelogFormatter.class);\n    pico.addSingleton(IssueShowAction.class);\n    pico.addSingleton(IssuesWs.class);\n\n    // issue filters\n    pico.addSingleton(IssueFilterService.class);\n    pico.addSingleton(IssueFilterSerializer.class);\n    pico.addSingleton(IssueFilterWs.class);\n    pico.addSingleton(IssueFilterWriter.class);\n    pico.addSingleton(org.sonar.server.issue.filter.AppAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.ShowAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.FavoritesAction.class);\n\n    // action plan\n    pico.addSingleton(ActionPlanWs.class);\n    pico.addSingleton(ActionPlanService.class);\n\n    // issues actions\n    pico.addSingleton(AssignAction.class);\n    pico.addSingleton(PlanAction.class);\n    pico.addSingleton(SetSeverityAction.class);\n    pico.addSingleton(CommentAction.class);\n    pico.addSingleton(TransitionAction.class);\n\n    // technical debt\n    pico.addSingleton(DebtModelService.class);\n    pico.addSingleton(DebtModelOperations.class);\n    pico.addSingleton(DebtModelLookup.class);\n    pico.addSingleton(DebtModelBackup.class);\n    pico.addSingleton(DebtModelPluginRepository.class);\n    pico.addSingleton(DebtModelXMLExporter.class);\n    pico.addSingleton(DebtRulesXMLImporter.class);\n    pico.addSingleton(DebtCharacteristicsXMLImporter.class);\n\n    // source\n    pico.addSingleton(HtmlSourceDecorator.class);\n    pico.addSingleton(DeprecatedSourceDecorator.class);\n    pico.addSingleton(SourceService.class);\n    pico.addSingleton(SourcesWs.class);\n    pico.addSingleton(ShowAction.class);\n    pico.addSingleton(ScmWriter.class);\n    pico.addSingleton(ScmAction.class);\n\n    // text\n    pico.addSingleton(MacroInterpreter.class);\n    pico.addSingleton(RubyTextService.class);\n\n    // Notifications\n    pico.addSingleton(EmailSettings.class);\n    pico.addSingleton(NotificationService.class);\n    pico.addSingleton(NotificationCenter.class);\n    pico.addSingleton(DefaultNotificationManager.class);\n\n    // Tests\n    pico.addSingleton(TestsWs.class);\n\n    // graphs and perspective related classes\n    pico.addSingleton(TestablePerspectiveLoader.class);\n    pico.addSingleton(TestPlanPerspectiveLoader.class);\n    pico.addSingleton(SnapshotPerspectives.class);\n\n    // Type validation\n    pico.addSingleton(TypeValidations.class);\n    pico.addSingleton(IntegerTypeValidation.class);\n    pico.addSingleton(FloatTypeValidation.class);\n    pico.addSingleton(BooleanTypeValidation.class);\n    pico.addSingleton(TextTypeValidation.class);\n    pico.addSingleton(StringTypeValidation.class);\n    pico.addSingleton(StringListTypeValidation.class);\n\n    for (Object components : level4AddedComponents) {\n      pico.addSingleton(components);\n    }\n\n\n    ServerExtensionInstaller extensionInstaller = pico.getComponentByType(ServerExtensionInstaller.class);\n    extensionInstaller.installExtensions(pico);\n\n    pico.startComponents();\n    executeStartupTaks(pico);\n  }","id":9887,"modified_method":"void startLevel4Components(ComponentContainer pico) {\n    pico.addSingleton(ESIndex.class);\n    pico.addSingleton(PluginDownloader.class);\n    pico.addSingleton(ChartFactory.class);\n    pico.addSingleton(Languages.class);\n    pico.addSingleton(Views.class);\n    pico.addSingleton(CodeColorizers.class);\n    pico.addSingleton(ResourceTypes.class);\n    pico.addSingleton(SettingsChangeNotifier.class);\n    pico.addSingleton(PageDecorations.class);\n    pico.addSingleton(PreviewCache.class);\n    pico.addSingleton(DefaultResourcePermissions.class);\n    pico.addSingleton(Periods.class);\n    pico.addSingleton(ServerWs.class);\n\n    // update center\n    pico.addSingleton(UpdateCenterClient.class);\n    pico.addSingleton(UpdateCenterMatrixFactory.class);\n    pico.addSingleton(UpdateCenterWs.class);\n\n    // quality profile\n    pico.addSingleton(XMLProfileParser.class);\n    pico.addSingleton(XMLProfileSerializer.class);\n    pico.addComponent(ProfilesDao.class, false);\n    pico.addComponent(ProfilesManager.class, false);\n    pico.addSingleton(AnnotationProfileParser.class);\n    pico.addSingleton(QProfileRuleLookup.class);\n    pico.addSingleton(QProfiles.class);\n    pico.addSingleton(QProfileLookup.class);\n    pico.addSingleton(QProfileOperations.class);\n    pico.addSingleton(QProfileActiveRuleOperations.class);\n    pico.addSingleton(QProfileProjectOperations.class);\n    pico.addSingleton(QProfileProjectLookup.class);\n    pico.addSingleton(QProfileBackup.class);\n    pico.addSingleton(QProfileRepositoryExporter.class);\n    pico.addSingleton(DefaultProfilesCache.class);\n    pico.addSingleton(ESActiveRule.class);\n    pico.addSingleton(QProfileRecreateBuiltInAction.class);\n    pico.addSingleton(QProfilesWs.class);\n    pico.addSingleton(ProfilesWs.class);\n    pico.addSingleton(RuleActivationActions.class);\n    pico.addSingleton(ActiveRuleService.class);\n    pico.addSingleton(RuleActivationContextFactory.class);\n\n    // rule\n    pico.addSingleton(AnnotationRuleParser.class);\n    pico.addSingleton(XMLRuleParser.class);\n    pico.addComponent(RulesDao.class, false);\n    pico.addSingleton(DefaultRuleFinder.class);\n    pico.addSingleton(Rules.class);\n    pico.addSingleton(RuleOperations.class);\n    pico.addSingleton(RuleRegistry.class);\n    pico.addSingleton(RubyRuleService.class);\n    pico.addSingleton(RuleRepositories.class);\n    pico.addSingleton(DeprecatedRulesDefinition.class);\n    pico.addSingleton(RuleDefinitionsLoader.class);\n    pico.addSingleton(RulesWs.class);\n    pico.addSingleton(RuleShowWsHandler.class);\n    pico.addSingleton(RuleSearchWsHandler.class);\n    pico.addSingleton(AddTagsWsHandler.class);\n    pico.addSingleton(RemoveTagsWsHandler.class);\n    pico.addSingleton(RulesDefinitionXmlLoader.class);\n\n    // experimental rules\n    pico.addSingleton(RuleService.class);\n    pico.addSingleton(RulesWebService.class);\n    pico.addSingleton(SearchAction.class);\n    pico.addSingleton(org.sonar.server.rule2.ws.ShowAction.class);\n    pico.addSingleton(TagsAction.class);\n    pico.addSingleton(SetTagsAction.class);\n\n    // rule tags\n    pico.addSingleton(ESRuleTags.class);\n    pico.addSingleton(RuleTagLookup.class);\n    pico.addSingleton(RuleTagOperations.class);\n    pico.addSingleton(RuleTags.class);\n    pico.addSingleton(RuleTagsWs.class);\n\n    // measure\n    pico.addComponent(MeasuresDao.class, false);\n    pico.addSingleton(MeasureFilterFactory.class);\n    pico.addSingleton(MeasureFilterExecutor.class);\n    pico.addSingleton(MeasureFilterEngine.class);\n    pico.addSingleton(DefaultMetricFinder.class);\n    pico.addSingleton(ServerLifecycleNotifier.class);\n    pico.addSingleton(TimeMachineWs.class);\n\n    // quality gates\n    pico.addSingleton(QualityGateDao.class);\n    pico.addSingleton(QualityGateConditionDao.class);\n    pico.addSingleton(QualityGates.class);\n    pico.addSingleton(ProjectQgateAssociationDao.class);\n    pico.addSingleton(QgateProjectFinder.class);\n\n    pico.addSingleton(QGatesListAction.class);\n    pico.addSingleton(QGatesSearchAction.class);\n    pico.addSingleton(QGatesShowAction.class);\n    pico.addSingleton(QGatesCreateAction.class);\n    pico.addSingleton(QGatesRenameAction.class);\n    pico.addSingleton(QGatesCopyAction.class);\n    pico.addSingleton(QGatesDestroyAction.class);\n    pico.addSingleton(QGatesSetAsDefaultAction.class);\n    pico.addSingleton(QGatesUnsetDefaultAction.class);\n    pico.addSingleton(QGatesSelectAction.class);\n    pico.addSingleton(QGatesDeselectAction.class);\n    pico.addSingleton(QGatesCreateConditionAction.class);\n    pico.addSingleton(QGatesDeleteConditionAction.class);\n    pico.addSingleton(QGatesUpdateConditionAction.class);\n    pico.addSingleton(QGatesAppAction.class);\n    pico.addSingleton(QGatesWs.class);\n\n    // web services\n    pico.addSingleton(WebServiceEngine.class);\n    pico.addSingleton(ListingWs.class);\n\n    // authentication\n    pico.addSingleton(AuthenticationWs.class);\n\n    // users\n    pico.addSingleton(SecurityRealmFactory.class);\n    pico.addSingleton(HibernateUserFinder.class);\n    pico.addSingleton(NewUserNotifier.class);\n    pico.addSingleton(DefaultUserFinder.class);\n    pico.addSingleton(DefaultUserService.class);\n    pico.addSingleton(UsersWs.class);\n\n    // groups\n    pico.addSingleton(GroupMembershipService.class);\n    pico.addSingleton(GroupMembershipFinder.class);\n\n    // permissions\n    pico.addSingleton(PermissionFacade.class);\n    pico.addSingleton(InternalPermissionService.class);\n    pico.addSingleton(InternalPermissionTemplateService.class);\n    pico.addSingleton(PermissionFinder.class);\n    pico.addSingleton(PermissionsWs.class);\n\n    // components\n    pico.addSingleton(DefaultComponentFinder.class);\n    pico.addSingleton(DefaultRubyComponentService.class);\n    pico.addSingleton(ComponentDao.class);\n    pico.addSingleton(ResourcesWs.class);\n    pico.addSingleton(ComponentsWs.class);\n    pico.addSingleton(ProjectsWs.class);\n\n    // issues\n    pico.addSingleton(ServerIssueStorage.class);\n    pico.addSingleton(IssueUpdater.class);\n    pico.addSingleton(FunctionExecutor.class);\n    pico.addSingleton(IssueWorkflow.class);\n    pico.addSingleton(IssueService.class);\n    pico.addSingleton(IssueCommentService.class);\n    pico.addSingleton(DefaultIssueFinder.class);\n    pico.addSingleton(IssueStatsFinder.class);\n    pico.addSingleton(PublicRubyIssueService.class);\n    pico.addSingleton(InternalRubyIssueService.class);\n    pico.addSingleton(IssueChangelogService.class);\n    pico.addSingleton(IssueNotifications.class);\n    pico.addSingleton(ActionService.class);\n    pico.addSingleton(Actions.class);\n    pico.addSingleton(IssueBulkChangeService.class);\n    pico.addSingleton(IssueChangelogFormatter.class);\n    pico.addSingleton(IssueShowAction.class);\n    pico.addSingleton(IssuesWs.class);\n\n    // issue filters\n    pico.addSingleton(IssueFilterService.class);\n    pico.addSingleton(IssueFilterSerializer.class);\n    pico.addSingleton(IssueFilterWs.class);\n    pico.addSingleton(IssueFilterWriter.class);\n    pico.addSingleton(org.sonar.server.issue.filter.AppAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.ShowAction.class);\n    pico.addSingleton(org.sonar.server.issue.filter.FavoritesAction.class);\n\n    // action plan\n    pico.addSingleton(ActionPlanWs.class);\n    pico.addSingleton(ActionPlanService.class);\n\n    // issues actions\n    pico.addSingleton(AssignAction.class);\n    pico.addSingleton(PlanAction.class);\n    pico.addSingleton(SetSeverityAction.class);\n    pico.addSingleton(CommentAction.class);\n    pico.addSingleton(TransitionAction.class);\n\n    // technical debt\n    pico.addSingleton(DebtModelService.class);\n    pico.addSingleton(DebtModelOperations.class);\n    pico.addSingleton(DebtModelLookup.class);\n    pico.addSingleton(DebtModelBackup.class);\n    pico.addSingleton(DebtModelPluginRepository.class);\n    pico.addSingleton(DebtModelXMLExporter.class);\n    pico.addSingleton(DebtRulesXMLImporter.class);\n    pico.addSingleton(DebtCharacteristicsXMLImporter.class);\n\n    // source\n    pico.addSingleton(HtmlSourceDecorator.class);\n    pico.addSingleton(DeprecatedSourceDecorator.class);\n    pico.addSingleton(SourceService.class);\n    pico.addSingleton(SourcesWs.class);\n    pico.addSingleton(ShowAction.class);\n    pico.addSingleton(ScmWriter.class);\n    pico.addSingleton(ScmAction.class);\n\n    // text\n    pico.addSingleton(MacroInterpreter.class);\n    pico.addSingleton(RubyTextService.class);\n\n    // Notifications\n    pico.addSingleton(EmailSettings.class);\n    pico.addSingleton(NotificationService.class);\n    pico.addSingleton(NotificationCenter.class);\n    pico.addSingleton(DefaultNotificationManager.class);\n\n    // Tests\n    pico.addSingleton(TestsWs.class);\n    pico.addSingleton(CoverageService.class);\n    pico.addSingleton(CoverageWs.class);\n    pico.addSingleton(CoverageShowAction.class);\n\n    // graphs and perspective related classes\n    pico.addSingleton(TestablePerspectiveLoader.class);\n    pico.addSingleton(TestPlanPerspectiveLoader.class);\n    pico.addSingleton(SnapshotPerspectives.class);\n\n    // Type validation\n    pico.addSingleton(TypeValidations.class);\n    pico.addSingleton(IntegerTypeValidation.class);\n    pico.addSingleton(FloatTypeValidation.class);\n    pico.addSingleton(BooleanTypeValidation.class);\n    pico.addSingleton(TextTypeValidation.class);\n    pico.addSingleton(StringTypeValidation.class);\n    pico.addSingleton(StringListTypeValidation.class);\n\n    for (Object components : level4AddedComponents) {\n      pico.addSingleton(components);\n    }\n\n\n    ServerExtensionInstaller extensionInstaller = pico.getComponentByType(ServerExtensionInstaller.class);\n    extensionInstaller.installExtensions(pico);\n\n    pico.startComponents();\n    executeStartupTaks(pico);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"show\")\n      .setDescription(\"Get source code\")\n      .setSince(\"4.4\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-show.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n  }","id":9888,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"show\")\n      .setDescription(\"Get source code. Require Browse permission on file's project\")\n      .setSince(\"4.4\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-show.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(\"key\")\n      .setRequired(true)\n      .setDescription(\"File key\")\n      .setExampleValue(\"my_project:/src/foo/Bar.php\");\n\n    action\n      .createParam(\"from\")\n      .setDescription(\"First line to return. Starts at 1\")\n      .setExampleValue(\"10\")\n      .setDefaultValue(\"1\");\n\n    action\n      .createParam(\"to\")\n      .setDescription(\"Last line to return (inclusive)\")\n      .setExampleValue(\"20\");\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  private String findDataFromComponent(String fileKey, String metricKey) {\n    MeasureDataDto data = measureDataDao.findByComponentKeyAndMetricKey(fileKey, metricKey);\n    if (data != null) {\n      return data.getText();\n    }\n    return null;\n  }","id":9889,"modified_method":"@CheckForNull\n  private String findDataFromComponent(String fileKey, String metricKey) {\n    MeasureDataDto data = measureDataDao.findByComponentKeyAndMetricKey(fileKey, metricKey);\n    if (data != null) {\n      return data.getData();\n    }\n    return null;\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void checkPermission(String fileKey) {\n    ResourceDto project = resourceDao.getRootProjectByComponentKey(fileKey);\n    if (project == null) {\n      throw new NotFoundException(\"File does not exist\");\n    }\n    UserSession.get().checkProjectPermission(UserRole.CODEVIEWER, project.getKey());\n  }","id":9890,"modified_method":"public void checkPermission(String fileKey) {\n    UserSession.get().checkComponentPermission(UserRole.CODEVIEWER, fileKey);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public SourceService(HtmlSourceDecorator sourceDecorator, DeprecatedSourceDecorator deprecatedSourceDecorator, ResourceDao resourceDao, MeasureDataDao measureDataDao) {\n    this.sourceDecorator = sourceDecorator;\n    this.deprecatedSourceDecorator = deprecatedSourceDecorator;\n    this.resourceDao = resourceDao;\n    this.measureDataDao = measureDataDao;\n  }","id":9891,"modified_method":"public SourceService(HtmlSourceDecorator sourceDecorator, DeprecatedSourceDecorator deprecatedSourceDecorator, MeasureDataDao measureDataDao) {\n    this.sourceDecorator = sourceDecorator;\n    this.deprecatedSourceDecorator = deprecatedSourceDecorator;\n    this.measureDataDao = measureDataDao;\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void get_lines() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey);\n    when(resourceDao.getRootProjectByComponentKey(componentKey)).thenReturn(new ResourceDto().setKey(projectKey));\n\n    service.getLinesAsHtml(componentKey);\n\n    verify(sourceDecorator).getDecoratedSourceAsHtml(componentKey, null, null);\n  }","id":9892,"modified_method":"@Test\n  public void get_lines() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey).addComponent(componentKey, projectKey);\n\n    service.getLinesAsHtml(componentKey);\n\n    verify(sourceDecorator).getDecoratedSourceAsHtml(componentKey, null, null);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() throws Exception {\n    service = new SourceService(sourceDecorator, deprecatedSourceDecorator, resourceDao, measureDataDao);\n  }","id":9893,"modified_method":"@Before\n  public void setUp() throws Exception {\n    service = new SourceService(sourceDecorator, deprecatedSourceDecorator, measureDataDao);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void get_lines_from_deprecated_source_decorator_when_no_data_from_new_decorator() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey);\n    when(resourceDao.getRootProjectByComponentKey(componentKey)).thenReturn(new ResourceDto().setKey(projectKey));\n    when(sourceDecorator.getDecoratedSourceAsHtml(eq(componentKey), anyInt(), anyInt())).thenReturn(Collections.<String>emptyList());\n\n    service.getLinesAsHtml(componentKey, 1, 2);\n\n    verify(deprecatedSourceDecorator).getSourceAsHtml(componentKey, 1, 2);\n  }","id":9894,"modified_method":"@Test\n  public void get_lines_from_deprecated_source_decorator_when_no_data_from_new_decorator() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey).addComponent(componentKey, projectKey);;\n    when(sourceDecorator.getDecoratedSourceAsHtml(eq(componentKey), anyInt(), anyInt())).thenReturn(Collections.<String>emptyList());\n\n    service.getLinesAsHtml(componentKey, 1, 2);\n\n    verify(deprecatedSourceDecorator).getSourceAsHtml(componentKey, 1, 2);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_get_lines_if_file_not_found() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey);\n    when(resourceDao.getRootProjectByComponentKey(componentKey)).thenReturn(null);\n\n    try {\n      service.getLinesAsHtml(componentKey);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(NotFoundException.class);\n    }\n\n    verifyZeroInteractions(sourceDecorator);\n  }","id":9895,"modified_method":"@Test\n  public void fail_to_get_lines_if_file_not_found() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey);\n\n    try {\n      service.getLinesAsHtml(componentKey);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(NotFoundException.class);\n    }\n\n    verifyZeroInteractions(sourceDecorator);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void get_block_of_lines() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey);\n    when(resourceDao.getRootProjectByComponentKey(componentKey)).thenReturn(new ResourceDto().setKey(projectKey));\n\n    service.getLinesAsHtml(componentKey, 1, 2);\n\n    verify(sourceDecorator).getDecoratedSourceAsHtml(componentKey, 1, 2);\n  }","id":9896,"modified_method":"@Test\n  public void get_block_of_lines() throws Exception {\n    String projectKey = \"org.sonar.sample\";\n    String componentKey = \"org.sonar.sample:Sample\";\n    MockUserSession.set().addProjectPermissions(UserRole.CODEVIEWER, projectKey).addComponent(componentKey, projectKey);;\n\n    service.getLinesAsHtml(componentKey, 1, 2);\n\n    verify(sourceDecorator).getDecoratedSourceAsHtml(componentKey, 1, 2);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineTestableAction(NewController controller) {\n    NewAction action = controller.createAction(\"testable\")\n      .setDescription(\"Get the details of a given resource : test plan, test cases covering lines. Requires Browse permission on resource\")\n      .setSince(\"3.5\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-testable.json\"));\n\n    action.createParam(\"resource\")\n      .setRequired(true)\n      .setDescription(\"id or key of the resource\")\n      .setExampleValue(\"org.codehaus.sonar.plugins:sonar-cpd-plugin:src/main/java/org/sonar/plugins/cpd/SonarBridgeEngine.java\");\n    RailsHandler.addJsonOnlyFormatParam(action);\n  }","id":9897,"modified_method":"private void defineTestableAction(NewController controller) {\n    NewAction action = controller.createAction(\"testable\")\n      .setDescription(\"Get the details of a given resource : test plan, test cases covering lines. Requires Browse permission on resource\")\n      .setSince(\"3.5\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"tests-example-testable.json\"));\n\n    action.createParam(\"resource\")\n      .setRequired(true)\n      .setDescription(\"id or key of the resource\")\n      .setExampleValue(\"org.codehaus.sonar.plugins:sonar-cpd-plugin:src/main/java/org/sonar/plugins/cpd/SonarBridgeEngine.java\");\n    RailsHandler.addJsonOnlyFormatParam(action);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void definePlanAction(NewController controller) {\n    NewAction action = controller.createAction(\"plan\")\n      .setDescription(\"Get the details of a given test plan : test cases, resources covered by test cases. Requires Browse permission on resource\")\n      .setSince(\"3.5\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-plan.json\"));\n\n    action.createParam(\"resource\")\n      .setRequired(true)\n      .setDescription(\"id or key of the test resource\")\n      .setExampleValue(\"org.codehaus.sonar.plugins:sonar-cpd-plugin:src/test/java/org/sonar/plugins/cpd/SonarBridgeEngineTest.java\");\n    RailsHandler.addJsonOnlyFormatParam(action);\n  }","id":9898,"modified_method":"private void definePlanAction(NewController controller) {\n    NewAction action = controller.createAction(\"plan\")\n      .setDescription(\"Get the details of a given test plan : test cases, resources covered by test cases. Requires Browse permission on resource\")\n      .setSince(\"3.5\")\n      .setInternal(true)\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"tests-example-plan.json\"));\n\n    action.createParam(\"resource\")\n      .setRequired(true)\n      .setDescription(\"id or key of the test resource\")\n      .setExampleValue(\"org.codehaus.sonar.plugins:sonar-cpd-plugin:src/test/java/org/sonar/plugins/cpd/SonarBridgeEngineTest.java\");\n    RailsHandler.addJsonOnlyFormatParam(action);\n  }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"SpyUserSession(String login, AuthorizationDao authorizationDao) {\n      this.authorizationDao = authorizationDao;\n      setLogin(login);\n    }","id":9899,"modified_method":"SpyUserSession(String login, AuthorizationDao authorizationDao) {\n      this(login, authorizationDao, null);\n    }","commit_id":"09cd04981a52c1ba35d7d59dfa1d86db73544bca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void displayRelationships( NodeOrRelationship thing,\n        Output out, boolean verbose, Direction direction, String prefixString,\n        String postfixString, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws ShellException, RemoteException\n    {\n        for ( Relationship rel : thing.getRelationships( direction ) )\n        {\n            String type = rel.getType().name();\n            boolean matches = filterMap.isEmpty();\n            for ( String filter : filterMap.keySet() )\n            {\n                if ( matches( newPattern( filter, caseInsensitiveFilters ),\n                    type, caseInsensitiveFilters, looseFilters ) )\n                {\n                    matches = true;\n                    break;\n                }\n            }\n            \n            if ( !matches )\n            {\n                continue;\n            }\n            \n            StringBuffer buf = new StringBuffer(\n                getDisplayNameForCurrentNode() );\n            buf.append( \" \" + prefixString ).append( rel.getType().name() );\n            if ( verbose )\n            {\n                buf.append( \", \" ).append( rel.getId() );\n            }\n            buf.append( postfixString + \" \" );\n            buf.append( getDisplayNameForNode( direction == Direction.OUTGOING ?\n                rel.getEndNode() : rel.getStartNode() ) );\n            out.println( buf );\n        }\n    }","id":9900,"modified_method":"private void displayRelationships( NodeOrRelationship thing,\n        Output out, boolean verbose, Direction direction, String prefixString,\n        String postfixString, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws ShellException, RemoteException\n    {\n        for ( Relationship rel : sortRelationships(\n            thing.getRelationships( direction ) ) )\n        {\n            String type = rel.getType().name();\n            boolean matches = filterMap.isEmpty();\n            for ( String filter : filterMap.keySet() )\n            {\n                if ( matches( newPattern( filter, caseInsensitiveFilters ),\n                    type, caseInsensitiveFilters, looseFilters ) )\n                {\n                    matches = true;\n                    break;\n                }\n            }\n            \n            if ( !matches )\n            {\n                continue;\n            }\n            \n            StringBuffer buf = new StringBuffer(\n                getDisplayNameForCurrentNode() );\n            buf.append( \" \" + prefixString ).append( rel.getType().name() );\n            if ( verbose )\n            {\n                buf.append( \", \" ).append( rel.getId() );\n            }\n            buf.append( postfixString + \" \" );\n            buf.append( getDisplayNameForNode( direction == Direction.OUTGOING ?\n                rel.getEndNode() : rel.getStartNode() ) );\n            out.println( buf );\n        }\n    }","commit_id":"68707f1e93c4e4c72a36fce4aea4cb42f322763c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getNiceType( Object value )\n    {\n        String cls = value.getClass().getName();\n        return cls.substring(\n            String.class.getPackage().getName().length() + 1 );\n    }","id":9901,"modified_method":"private static String getNiceType( Object value )\n    {\n        return Set.getValueTypeName( value.getClass() );\n    }","commit_id":"68707f1e93c4e4c72a36fce4aea4cb42f322763c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws RemoteException\n    {\n        int longestKey = this.findLongestKey( thing );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            boolean matches = filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n            {\n                if ( matches( newPattern( filter.getKey(),\n                    caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                    looseFilters ) )\n                {\n                    String filterValue = filter.getValue() != null ?\n                        filter.getValue().toString() : null;\n                    if ( matches( newPattern( filterValue,\n                        caseInsensitiveFilters ), value.toString(),\n                        caseInsensitiveFilters, looseFilters ) )\n                    {\n                        matches = true;\n                        break;\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n            \n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","id":9902,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws RemoteException\n    {\n        int longestKey = findLongestKey( thing );\n        for ( String key : sortKeys( thing.getPropertyKeys() ) )\n        {\n            boolean matches = filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n            {\n                if ( matches( newPattern( filter.getKey(),\n                    caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                    looseFilters ) )\n                {\n                    String filterValue = filter.getValue() != null ?\n                        filter.getValue().toString() : null;\n                    if ( matches( newPattern( filterValue,\n                        caseInsensitiveFilters ), value.toString(),\n                        caseInsensitiveFilters, looseFilters ) )\n                    {\n                        matches = true;\n                        break;\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n            \n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=\" + format( value ) );\n                if ( verbose )\n                {\n                    out.print( \" (\" + getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","commit_id":"68707f1e93c4e4c72a36fce4aea4cb42f322763c","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException\n    {\n        if ( parser.arguments().size() < 2 )\n        {\n            throw new ShellException( \"Must supply key and value, \"\n                + \"like: set -t String title \\\"This is a neo node\\\"\" );\n        }\n\n        String key = parser.arguments().get( 0 );\n        Class<?> type = this.getValueType( parser );\n        Object value = null;\n        try\n        {\n            value = type.getConstructor( String.class ).newInstance(\n                parser.arguments().get( 1 ) );\n        }\n        catch ( Exception e )\n        {\n            throw new ShellException( e );\n        }\n\n        Node node = this.getCurrentNode( session );\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        thing.setProperty( key, value );\n        return null;\n    }","id":9903,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException\n    {\n        if ( parser.arguments().size() < 2 )\n        {\n            throw new ShellException( \"Must supply key and value, \" +\n                \"like: set title \\\"This is a neo node\\\"\" );\n        }\n\n        String key = parser.arguments().get( 0 );\n        ValueType valueType = getValueType( parser );\n        Object value = parseValue( parser.arguments().get( 1 ), valueType );\n\n        Node node = this.getCurrentNode( session );\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        thing.setProperty( key, value );\n        return null;\n    }","commit_id":"68707f1e93c4e4c72a36fce4aea4cb42f322763c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Class<?> getValueType( AppCommandParser parser )\n        throws ShellException\n    {\n        String type = parser.options().containsKey( \"t\" ) ? parser.options()\n            .get( \"t\" ) : String.class.getName();\n        Class<?> cls = VALUE_TYPE_NAMES.get( type );\n        \n        if ( cls == null )\n        {\n            try\n            {\n                cls = Class.forName( type );\n            }\n            catch ( ClassNotFoundException e )\n            {\n                // Ok\n            }\n        }\n\n        if ( cls == null )\n        {\n            try\n            {\n                cls = Class.forName( String.class.getPackage().getName() + \".\" +\n                    type );\n            }\n            catch ( ClassNotFoundException e )\n            {\n                // Ok\n            }\n        }\n\n        if ( cls == null )\n        {\n            throw new ShellException( \"Invalid value type '\" + type + \"'\" );\n        }\n        return cls;\n    }","id":9904,"modified_method":"private static ValueType getValueType( AppCommandParser parser )\n        throws ShellException\n    {\n        String type = parser.options().containsKey( \"t\" ) ?\n            parser.options().get( \"t\" ) : String.class.getSimpleName();\n        ValueType valueType = NAME_TO_VALUE_TYPE.get( type );\n        \n        if ( valueType == null )\n        {\n            throw new ShellException( \"Invalid value type '\" + type + \"'\" );\n        }\n        return valueType;\n    }","commit_id":"68707f1e93c4e4c72a36fce4aea4cb42f322763c","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new \"set\" application.\n     */\n    public Set()\n    {\n        super();\n        this.addValueType( \"t\", new OptionContext( OptionValueType.MUST,\n            \"Value type, String, int, long, byte a.s.o. Default is String\" ) );\n    }","id":9905,"modified_method":"/**\n     * Constructs a new \"set\" application.\n     */\n    public Set()\n    {\n        super();\n        this.addValueType( \"t\", new OptionContext( OptionValueType.MUST,\n            \"Value type, f.ex: String, String[], int, long[], byte a.s.o.\\n\" +\n            \"If an array type is supplied the value(s) are given in a \" +\n            \"JSON-style\\n\" +\n            \"array format, f.ex:\\n\" +\n            \"[321,45324] for an int[] or\\n\" +\n            \"\\\"['The first string','The second string here']\\\" for a \" +\n            \"String[]\" ) );\n    }","commit_id":"68707f1e93c4e4c72a36fce4aea4cb42f322763c","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getNiceType( Object value )\n    {\n        String cls = value.getClass().getName();\n        return cls.substring(\n            String.class.getPackage().getName().length() + 1 );\n    }","id":9906,"modified_method":"private static String getNiceType( Object value )\n    {\n        return Set.getValueTypeName( value.getClass() );\n    }","commit_id":"771b9a92eecc9b00c9d2ae5a86fc64c911bcbfc1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws RemoteException\n    {\n        int longestKey = this.findLongestKey( thing );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            boolean matches = filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n            {\n                if ( matches( newPattern( filter.getKey(),\n                    caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                    looseFilters ) )\n                {\n                    String filterValue = filter.getValue() != null ?\n                        filter.getValue().toString() : null;\n                    if ( matches( newPattern( filterValue,\n                        caseInsensitiveFilters ), value.toString(),\n                        caseInsensitiveFilters, looseFilters ) )\n                    {\n                        matches = true;\n                        break;\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n            \n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","id":9907,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws RemoteException\n    {\n        int longestKey = findLongestKey( thing );\n        for ( String key : sortKeys( thing.getPropertyKeys() ) )\n        {\n            boolean matches = filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n            {\n                if ( matches( newPattern( filter.getKey(),\n                    caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                    looseFilters ) )\n                {\n                    String filterValue = filter.getValue() != null ?\n                        filter.getValue().toString() : null;\n                    if ( matches( newPattern( filterValue,\n                        caseInsensitiveFilters ), value.toString(),\n                        caseInsensitiveFilters, looseFilters ) )\n                    {\n                        matches = true;\n                        break;\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n            \n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=\" + format( value ) );\n                if ( verbose )\n                {\n                    out.print( \" (\" + getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","commit_id":"771b9a92eecc9b00c9d2ae5a86fc64c911bcbfc1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayRelationships( NodeOrRelationship thing,\n        Output out, boolean verbose, Direction direction, String prefixString,\n        String postfixString, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws ShellException, RemoteException\n    {\n        for ( Relationship rel : thing.getRelationships( direction ) )\n        {\n            String type = rel.getType().name();\n            boolean matches = filterMap.isEmpty();\n            for ( String filter : filterMap.keySet() )\n            {\n                if ( matches( newPattern( filter, caseInsensitiveFilters ),\n                    type, caseInsensitiveFilters, looseFilters ) )\n                {\n                    matches = true;\n                    break;\n                }\n            }\n            \n            if ( !matches )\n            {\n                continue;\n            }\n            \n            StringBuffer buf = new StringBuffer(\n                getDisplayNameForCurrentNode() );\n            buf.append( \" \" + prefixString ).append( rel.getType().name() );\n            if ( verbose )\n            {\n                buf.append( \", \" ).append( rel.getId() );\n            }\n            buf.append( postfixString + \" \" );\n            buf.append( getDisplayNameForNode( direction == Direction.OUTGOING ?\n                rel.getEndNode() : rel.getStartNode() ) );\n            out.println( buf );\n        }\n    }","id":9908,"modified_method":"private void displayRelationships( NodeOrRelationship thing,\n        Output out, boolean verbose, Direction direction, String prefixString,\n        String postfixString, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws ShellException, RemoteException\n    {\n        for ( Relationship rel : sortRelationships(\n            thing.getRelationships( direction ) ) )\n        {\n            String type = rel.getType().name();\n            boolean matches = filterMap.isEmpty();\n            for ( String filter : filterMap.keySet() )\n            {\n                if ( matches( newPattern( filter, caseInsensitiveFilters ),\n                    type, caseInsensitiveFilters, looseFilters ) )\n                {\n                    matches = true;\n                    break;\n                }\n            }\n            \n            if ( !matches )\n            {\n                continue;\n            }\n            \n            StringBuffer buf = new StringBuffer(\n                getDisplayNameForCurrentNode() );\n            buf.append( \" \" + prefixString ).append( rel.getType().name() );\n            if ( verbose )\n            {\n                buf.append( \", \" ).append( rel.getId() );\n            }\n            buf.append( postfixString + \" \" );\n            buf.append( getDisplayNameForNode( direction == Direction.OUTGOING ?\n                rel.getEndNode() : rel.getStartNode() ) );\n            out.println( buf );\n        }\n    }","commit_id":"771b9a92eecc9b00c9d2ae5a86fc64c911bcbfc1","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new \"set\" application.\n     */\n    public Set()\n    {\n        super();\n        this.addValueType( \"t\", new OptionContext( OptionValueType.MUST,\n            \"Value type, String, int, long, byte a.s.o. Default is String\" ) );\n    }","id":9909,"modified_method":"/**\n     * Constructs a new \"set\" application.\n     */\n    public Set()\n    {\n        super();\n        this.addValueType( \"t\", new OptionContext( OptionValueType.MUST,\n            \"Value type, f.ex: String, String[], int, long[], byte a.s.o.\\n\" +\n            \"If an array type is supplied the value(s) are given in a \" +\n            \"JSON-style\\n\" +\n            \"array format, f.ex:\\n\" +\n            \"[321,45324] for an int[] or\\n\" +\n            \"\\\"['The first string','The second string here']\\\" for a \" +\n            \"String[]\" ) );\n    }","commit_id":"771b9a92eecc9b00c9d2ae5a86fc64c911bcbfc1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Class<?> getValueType( AppCommandParser parser )\n        throws ShellException\n    {\n        String type = parser.options().containsKey( \"t\" ) ? parser.options()\n            .get( \"t\" ) : String.class.getName();\n        Class<?> cls = VALUE_TYPE_NAMES.get( type );\n        \n        if ( cls == null )\n        {\n            try\n            {\n                cls = Class.forName( type );\n            }\n            catch ( ClassNotFoundException e )\n            {\n                // Ok\n            }\n        }\n\n        if ( cls == null )\n        {\n            try\n            {\n                cls = Class.forName( String.class.getPackage().getName() + \".\" +\n                    type );\n            }\n            catch ( ClassNotFoundException e )\n            {\n                // Ok\n            }\n        }\n\n        if ( cls == null )\n        {\n            throw new ShellException( \"Invalid value type '\" + type + \"'\" );\n        }\n        return cls;\n    }","id":9910,"modified_method":"private static ValueType getValueType( AppCommandParser parser )\n        throws ShellException\n    {\n        String type = parser.options().containsKey( \"t\" ) ?\n            parser.options().get( \"t\" ) : String.class.getSimpleName();\n        ValueType valueType = NAME_TO_VALUE_TYPE.get( type );\n        \n        if ( valueType == null )\n        {\n            throw new ShellException( \"Invalid value type '\" + type + \"'\" );\n        }\n        return valueType;\n    }","commit_id":"771b9a92eecc9b00c9d2ae5a86fc64c911bcbfc1","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException\n    {\n        if ( parser.arguments().size() < 2 )\n        {\n            throw new ShellException( \"Must supply key and value, \"\n                + \"like: set -t String title \\\"This is a neo node\\\"\" );\n        }\n\n        String key = parser.arguments().get( 0 );\n        Class<?> type = this.getValueType( parser );\n        Object value = null;\n        try\n        {\n            value = type.getConstructor( String.class ).newInstance(\n                parser.arguments().get( 1 ) );\n        }\n        catch ( Exception e )\n        {\n            throw new ShellException( e );\n        }\n\n        Node node = this.getCurrentNode( session );\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        thing.setProperty( key, value );\n        return null;\n    }","id":9911,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException\n    {\n        if ( parser.arguments().size() < 2 )\n        {\n            throw new ShellException( \"Must supply key and value, \" +\n                \"like: set title \\\"This is a neo node\\\"\" );\n        }\n\n        String key = parser.arguments().get( 0 );\n        ValueType valueType = getValueType( parser );\n        Object value = parseValue( parser.arguments().get( 1 ), valueType );\n\n        Node node = this.getCurrentNode( session );\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        thing.setProperty( key, value );\n        return null;\n    }","commit_id":"771b9a92eecc9b00c9d2ae5a86fc64c911bcbfc1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private String getNiceType( Object value )\n    {\n        String cls = value.getClass().getName();\n        return cls.substring(\n            String.class.getPackage().getName().length() + 1 );\n    }","id":9912,"modified_method":"private static String getNiceType( Object value )\n    {\n        return Set.getValueTypeName( value.getClass() );\n    }","commit_id":"d2f21fc6343d795f9684378e9fbe62373b106eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws RemoteException\n    {\n        int longestKey = this.findLongestKey( thing );\n        for ( String key : thing.getPropertyKeys() )\n        {\n            boolean matches = filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n            {\n                if ( matches( newPattern( filter.getKey(),\n                    caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                    looseFilters ) )\n                {\n                    String filterValue = filter.getValue() != null ?\n                        filter.getValue().toString() : null;\n                    if ( matches( newPattern( filterValue,\n                        caseInsensitiveFilters ), value.toString(),\n                        caseInsensitiveFilters, looseFilters ) )\n                    {\n                        matches = true;\n                        break;\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n            \n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=[\" + value + \"]\" );\n                if ( verbose )\n                {\n                    out.print( \" (\" + this.getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","id":9913,"modified_method":"private void displayProperties( NodeOrRelationship thing, Output out,\n        boolean displayValues, boolean verbose, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws RemoteException\n    {\n        int longestKey = findLongestKey( thing );\n        for ( String key : sortKeys( thing.getPropertyKeys() ) )\n        {\n            boolean matches = filterMap.isEmpty();\n            Object value = thing.getProperty( key );\n            for ( Map.Entry<String, Object> filter : filterMap.entrySet() )\n            {\n                if ( matches( newPattern( filter.getKey(),\n                    caseInsensitiveFilters ), key, caseInsensitiveFilters,\n                    looseFilters ) )\n                {\n                    String filterValue = filter.getValue() != null ?\n                        filter.getValue().toString() : null;\n                    if ( matches( newPattern( filterValue,\n                        caseInsensitiveFilters ), value.toString(),\n                        caseInsensitiveFilters, looseFilters ) )\n                    {\n                        matches = true;\n                        break;\n                    }\n                }\n            }\n            if ( !matches )\n            {\n                continue;\n            }\n            \n            out.print( \"*\" + key );\n            if ( displayValues )\n            {\n                this.printMany( out, \" \", longestKey - key.length() + 1 );\n                out.print( \"=\" + format( value ) );\n                if ( verbose )\n                {\n                    out.print( \" (\" + getNiceType( value ) + \")\" );\n                }\n            }\n            out.println( \"\" );\n        }\n    }","commit_id":"d2f21fc6343d795f9684378e9fbe62373b106eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void displayRelationships( NodeOrRelationship thing,\n        Output out, boolean verbose, Direction direction, String prefixString,\n        String postfixString, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws ShellException, RemoteException\n    {\n        for ( Relationship rel : thing.getRelationships( direction ) )\n        {\n            String type = rel.getType().name();\n            boolean matches = filterMap.isEmpty();\n            for ( String filter : filterMap.keySet() )\n            {\n                if ( matches( newPattern( filter, caseInsensitiveFilters ),\n                    type, caseInsensitiveFilters, looseFilters ) )\n                {\n                    matches = true;\n                    break;\n                }\n            }\n            \n            if ( !matches )\n            {\n                continue;\n            }\n            \n            StringBuffer buf = new StringBuffer(\n                getDisplayNameForCurrentNode() );\n            buf.append( \" \" + prefixString ).append( rel.getType().name() );\n            if ( verbose )\n            {\n                buf.append( \", \" ).append( rel.getId() );\n            }\n            buf.append( postfixString + \" \" );\n            buf.append( getDisplayNameForNode( direction == Direction.OUTGOING ?\n                rel.getEndNode() : rel.getStartNode() ) );\n            out.println( buf );\n        }\n    }","id":9914,"modified_method":"private void displayRelationships( NodeOrRelationship thing,\n        Output out, boolean verbose, Direction direction, String prefixString,\n        String postfixString, Map<String, Object> filterMap,\n        boolean caseInsensitiveFilters, boolean looseFilters )\n        throws ShellException, RemoteException\n    {\n        for ( Relationship rel : sortRelationships(\n            thing.getRelationships( direction ) ) )\n        {\n            String type = rel.getType().name();\n            boolean matches = filterMap.isEmpty();\n            for ( String filter : filterMap.keySet() )\n            {\n                if ( matches( newPattern( filter, caseInsensitiveFilters ),\n                    type, caseInsensitiveFilters, looseFilters ) )\n                {\n                    matches = true;\n                    break;\n                }\n            }\n            \n            if ( !matches )\n            {\n                continue;\n            }\n            \n            StringBuffer buf = new StringBuffer(\n                getDisplayNameForCurrentNode() );\n            buf.append( \" \" + prefixString ).append( rel.getType().name() );\n            if ( verbose )\n            {\n                buf.append( \", \" ).append( rel.getId() );\n            }\n            buf.append( postfixString + \" \" );\n            buf.append( getDisplayNameForNode( direction == Direction.OUTGOING ?\n                rel.getEndNode() : rel.getStartNode() ) );\n            out.println( buf );\n        }\n    }","commit_id":"d2f21fc6343d795f9684378e9fbe62373b106eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected String exec( AppCommandParser parser, Session session, Output out )\n        throws ShellException\n    {\n        if ( parser.arguments().size() < 2 )\n        {\n            throw new ShellException( \"Must supply key and value, \"\n                + \"like: set -t String title \\\"This is a neo node\\\"\" );\n        }\n\n        String key = parser.arguments().get( 0 );\n        Class<?> type = this.getValueType( parser );\n        Object value = null;\n        try\n        {\n            value = type.getConstructor( String.class ).newInstance(\n                parser.arguments().get( 1 ) );\n        }\n        catch ( Exception e )\n        {\n            throw new ShellException( e );\n        }\n\n        Node node = this.getCurrentNode( session );\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        thing.setProperty( key, value );\n        return null;\n    }","id":9915,"modified_method":"@Override\n    protected String exec( AppCommandParser parser, Session session,\n        Output out ) throws ShellException\n    {\n        if ( parser.arguments().size() < 2 )\n        {\n            throw new ShellException( \"Must supply key and value, \" +\n                \"like: set title \\\"This is a neo node\\\"\" );\n        }\n\n        String key = parser.arguments().get( 0 );\n        ValueType valueType = getValueType( parser );\n        Object value = parseValue( parser.arguments().get( 1 ), valueType );\n\n        Node node = this.getCurrentNode( session );\n        NodeOrRelationship thing = getNodeOrRelationship( node, parser );\n        thing.setProperty( key, value );\n        return null;\n    }","commit_id":"d2f21fc6343d795f9684378e9fbe62373b106eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Constructs a new \"set\" application.\n     */\n    public Set()\n    {\n        super();\n        this.addValueType( \"t\", new OptionContext( OptionValueType.MUST,\n            \"Value type, String, int, long, byte a.s.o. Default is String\" ) );\n    }","id":9916,"modified_method":"/**\n     * Constructs a new \"set\" application.\n     */\n    public Set()\n    {\n        super();\n        this.addValueType( \"t\", new OptionContext( OptionValueType.MUST,\n            \"Value type, f.ex: String, String[], int, long[], byte a.s.o.\\n\" +\n            \"If an array type is supplied the value(s) are given in a \" +\n            \"JSON-style\\n\" +\n            \"array format, f.ex:\\n\" +\n            \"[321,45324] for an int[] or\\n\" +\n            \"\\\"['The first string','The second string here']\\\" for a \" +\n            \"String[]\" ) );\n    }","commit_id":"d2f21fc6343d795f9684378e9fbe62373b106eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Class<?> getValueType( AppCommandParser parser )\n        throws ShellException\n    {\n        String type = parser.options().containsKey( \"t\" ) ? parser.options()\n            .get( \"t\" ) : String.class.getName();\n        Class<?> cls = VALUE_TYPE_NAMES.get( type );\n        \n        if ( cls == null )\n        {\n            try\n            {\n                cls = Class.forName( type );\n            }\n            catch ( ClassNotFoundException e )\n            {\n                // Ok\n            }\n        }\n\n        if ( cls == null )\n        {\n            try\n            {\n                cls = Class.forName( String.class.getPackage().getName() + \".\" +\n                    type );\n            }\n            catch ( ClassNotFoundException e )\n            {\n                // Ok\n            }\n        }\n\n        if ( cls == null )\n        {\n            throw new ShellException( \"Invalid value type '\" + type + \"'\" );\n        }\n        return cls;\n    }","id":9917,"modified_method":"private static ValueType getValueType( AppCommandParser parser )\n        throws ShellException\n    {\n        String type = parser.options().containsKey( \"t\" ) ?\n            parser.options().get( \"t\" ) : String.class.getSimpleName();\n        ValueType valueType = NAME_TO_VALUE_TYPE.get( type );\n        \n        if ( valueType == null )\n        {\n            throw new ShellException( \"Invalid value type '\" + type + \"'\" );\n        }\n        return valueType;\n    }","commit_id":"d2f21fc6343d795f9684378e9fbe62373b106eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player sourcePlayer = game.getPlayer(source.getControllerId());\r\n        for (UUID playerId: sourcePlayer.getInRange()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                player.getLibrary().addAll(player.getHand().getCards(game), game);\r\n                player.getLibrary().addAll(player.getGraveyard().getCards(game), game);\r\n                player.shuffleLibrary(game);\r\n                player.getHand().clear();\r\n                player.getGraveyard().clear();\r\n                player.drawCards(7, game);\r\n            }\r\n        }\r\n        return true;\r\n    }","id":9918,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player sourcePlayer = game.getPlayer(source.getControllerId());\r\n        for (UUID playerId: sourcePlayer.getInRange()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                for (Card card: player.getHand().getCards(game)) {\r\n                    card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                }\r\n                for (Card card: player.getGraveyard().getCards(game)) {\r\n                    card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                }\r\n                player.shuffleLibrary(game);\r\n                \r\n            }\r\n        }\r\n        game.getState().handleSimultaneousEvent(game); // needed here so state based triggered effects \r\n        for (UUID playerId: sourcePlayer.getInRange()) {\r\n            Player player = game.getPlayer(playerId);\r\n            if (player != null) {\r\n                player.drawCards(7, game);\r\n            }            \r\n        }\r\n        return true;\r\n    }","commit_id":"f4166ac3b32fc526bcff4f7dba9fd17d556cf706","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int amount = game.getPermanent(source.getSourceId()).getCounters().getCount(CounterType.CHARGE);\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n\t\tCard card;\r\n\t\tfor (int i = 0; i < amount; i++) {\r\n\t\t\tcard = player.getLibrary().removeFromTop(game);\r\n\t\t\tif (card != null)\r\n\t\t\t\tplayer.getGraveyard().add(card);\r\n\t\t\telse\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn true;\r\n    }","id":9919,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int amount = game.getPermanent(source.getSourceId()).getCounters().getCount(CounterType.CHARGE);\r\n        Player player = game.getPlayer(source.getFirstTarget());\r\n\t\tCard card;\r\n\t\tfor (int i = 0; i < amount; i++) {\r\n\t\t\tcard = player.getLibrary().removeFromTop(game);\r\n\t\t\tif (card != null) {\r\n\t\t\t\tcard.moveToZone(Zone.GRAVEYARD, source.getId(), game, false);\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n    }","commit_id":"1fa084fad0d97f46e384c5324a496505d9a622c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tExileZone exile = game.getExile().getPermanentExile();\n\t\tif (player != null) {\n\t\t\twhile (true) {\n\t\t\t\tif (player.getLibrary().getFromTop(game) == null)\n\t\t\t\t\tbreak;\n\t\t\t\tCard card = player.getLibrary().removeFromTop(game);\n\t\t\t\texile.add(card);\n\t\t\t}\n\t\t\tplayer.getLibrary().addAll(player.getHand().getCards(game), game);\n\t\t\tplayer.getLibrary().shuffle();\n\t\t\tplayer.getHand().clear();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":9920,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tExileZone exile = game.getExile().getPermanentExile();\n\t\tif (player != null) {\n\t\t\twhile (true) {\n\t\t\t\tif (player.getLibrary().getFromTop(game) == null)\n\t\t\t\t\tbreak;\n\t\t\t\tCard card = player.getLibrary().removeFromTop(game);\n\t\t\t\texile.add(card);\n\t\t\t\tgame.setZone(card.getId(), Zone.EXILED);\n\t\t\t}\n\t\t\tfor (Card card : player.getHand().getCards(game)) {\n\t\t\t\tcard.moveToZone(Zone.LIBRARY, source.getId(), game, false);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"1fa084fad0d97f46e384c5324a496505d9a622c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tif (player != null) {\n\t\t\t// putting cards to grave shouldn't end the game, so getting minimun available\n\t\t\tint cardsCount = Math.min(amount, player.getLibrary().size());\n\t\t\tfor (int i = 0; i < cardsCount; i++) {\n\t\t\t\tCard card = player.getLibrary().removeFromTop(game);\n\t\t\t\tif (card != null)\n\t\t\t\t\tplayer.getGraveyard().add(card);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":9921,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tif (player != null) {\n\t\t\t// putting cards to grave shouldn't end the game, so getting minimun available\n\t\t\tint cardsCount = Math.min(amount, player.getLibrary().size());\n\t\t\tfor (int i = 0; i < cardsCount; i++) {\n\t\t\t\tCard card = player.getLibrary().removeFromTop(game);\n\t\t\t\tif (card != null)\n\t\t\t\t\tcard.moveToZone(Zone.GRAVEYARD, source.getId(), game, false);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"1fa084fad0d97f46e384c5324a496505d9a622c2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tCard card;\n\t\tint amount = player.getLibrary().size() / 2;\n\t\tfor (int i = 0; i < amount; i++) {\n\t\t\tcard = player.getLibrary().removeFromTop(game);\n\t\t\tif (card != null)\n\t\t\t\tplayer.getGraveyard().add(card);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}","id":9922,"modified_method":"@Override\n\tpublic boolean apply(Game game, Ability source) {\n\t\tPlayer player = game.getPlayer(source.getFirstTarget());\n\t\tCard card;\n\t\tint amount = player.getLibrary().size() / 2;\n\t\tfor (int i = 0; i < amount; i++) {\n\t\t\tcard = player.getLibrary().removeFromTop(game);\n\t\t\tif (card != null) {\n\t\t\t\tcard.moveToZone(Zone.GRAVEYARD, source.getId(), game, false);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"1fa084fad0d97f46e384c5324a496505d9a622c2","url":"https://github.com/magefree/mage"},{"original_method":"protected FileEntry addBlogsEntryAttachmentFileEntry(\n\t\t\tlong groupId, long userId, long blogsEntryId, String fileName,\n\t\t\tString mimeType, InputStream is)\n\t\tthrows PortalException {\n\n\t\tFolder folder = BlogsEntryLocalServiceUtil.addAttachmentsFolder(\n\t\t\tuserId, groupId);\n\n\t\tfileName = FileUtil.stripParentheticalSuffix(fileName);\n\n\t\tString uniqueFileName = getUniqueFileName(groupId, fileName, folder);\n\n\t\treturn PortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\tgroupId, userId, BlogsEntry.class.getName(), blogsEntryId,\n\t\t\tBlogsConstants.SERVICE_NAME, folder.getFolderId(), is,\n\t\t\tuniqueFileName, mimeType, true);\n\t}","id":9923,"modified_method":"public FileEntry addBlogsEntryAttachmentFileEntry(\n\t\t\tlong groupId, long userId, long blogsEntryId, Folder folder,\n\t\t\tString fileName, String mimeType, InputStream is)\n\t\tthrows PortalException {\n\n\t\tString uniqueFileName = getUniqueFileName(groupId, fileName, folder);\n\n\t\treturn PortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\tgroupId, userId, BlogsEntry.class.getName(), blogsEntryId,\n\t\t\tBlogsConstants.SERVICE_NAME, folder.getFolderId(), is,\n\t\t\tuniqueFileName, mimeType, true);\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getUniqueFileName(\n\t\t\tlong groupId, String fileName, Folder folder)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = _fetchPortletFileEntry(groupId, fileName, folder);\n\n\t\tif (fileEntry == null) {\n\t\t\treturn fileName;\n\t\t}\n\n\t\tint suffix = 1;\n\n\t\tfor (int i = 0; i < _UNIQUE_FILE_NAME_TRIES; i++) {\n\t\t\tString curFileName = FileUtil.appendParentheticalSuffix(\n\t\t\t\tfileName, String.valueOf(suffix));\n\n\t\t\tfileEntry = _fetchPortletFileEntry(groupId, curFileName, folder);\n\n\t\t\tif (fileEntry == null) {\n\t\t\t\treturn curFileName;\n\t\t\t}\n\n\t\t\tsuffix++;\n\t\t}\n\n\t\tthrow new PortalException(\n\t\t\t\"Unable to get a unique file name for \" + fileName + \" in folder \" +\n\t\t\t\tfolder.getFolderId());\n\t}","id":9924,"modified_method":"protected String getUniqueFileName(\n\t\t\tlong groupId, String fileName, Folder folder)\n\t\tthrows PortalException {\n\n\t\tfileName = FileUtil.stripParentheticalSuffix(fileName);\n\n\t\tFileEntry fileEntry = _fetchPortletFileEntry(groupId, fileName, folder);\n\n\t\tif (fileEntry == null) {\n\t\t\treturn fileName;\n\t\t}\n\n\t\tint suffix = 1;\n\n\t\tfor (int i = 0; i < _UNIQUE_FILE_NAME_TRIES; i++) {\n\t\t\tString curFileName = FileUtil.appendParentheticalSuffix(\n\t\t\t\tfileName, String.valueOf(suffix));\n\n\t\t\tfileEntry = _fetchPortletFileEntry(groupId, curFileName, folder);\n\n\t\t\tif (fileEntry == null) {\n\t\t\t\treturn curFileName;\n\t\t\t}\n\n\t\t\tsuffix++;\n\t\t}\n\n\t\tthrow new PortalException(\n\t\t\t\"Unable to get a unique file name for \" + fileName + \" in folder \" +\n\t\t\t\tfolder.getFolderId());\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<BlogsEntryAttachmentFileEntryReference>\n\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\tlong groupId, long userId, long blogsEntryId,\n\t\t\tList<FileEntry> tempFileEntries)\n\t\tthrows PortalException {\n\n\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\tblogsEntryAttachmentFileEntryReferences = new ArrayList<>();\n\n\t\tfor (FileEntry tempFileEntry : tempFileEntries) {\n\t\t\tFileEntry blogsEntryAttachmentFileEntry =\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, blogsEntryId, tempFileEntry.getTitle(),\n\t\t\t\t\ttempFileEntry.getMimeType(),\n\t\t\t\t\ttempFileEntry.getContentStream());\n\n\t\t\tblogsEntryAttachmentFileEntryReferences.add(\n\t\t\t\tnew BlogsEntryAttachmentFileEntryReference(\n\t\t\t\t\ttempFileEntry.getFileEntryId(),\n\t\t\t\t\tblogsEntryAttachmentFileEntry));\n\t\t}\n\n\t\treturn blogsEntryAttachmentFileEntryReferences;\n\t}","id":9925,"modified_method":"public List<BlogsEntryAttachmentFileEntryReference>\n\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\tlong groupId, long userId, long blogsEntryId, Folder folder,\n\t\t\tList<FileEntry> tempFileEntries)\n\t\tthrows PortalException {\n\n\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\tblogsEntryAttachmentFileEntryReferences = new ArrayList<>();\n\n\t\tfor (FileEntry tempFileEntry : tempFileEntries) {\n\t\t\tFileEntry blogsEntryAttachmentFileEntry =\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, blogsEntryId, folder,\n\t\t\t\t\ttempFileEntry.getTitle(), tempFileEntry.getMimeType(),\n\t\t\t\t\ttempFileEntry.getContentStream());\n\n\t\t\tblogsEntryAttachmentFileEntryReferences.add(\n\t\t\t\tnew BlogsEntryAttachmentFileEntryReference(\n\t\t\t\t\ttempFileEntry.getFileEntryId(),\n\t\t\t\t\tblogsEntryAttachmentFileEntry));\n\t\t}\n\n\t\treturn blogsEntryAttachmentFileEntryReferences;\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addCoverImage(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector coverImageImageSelector)\n\t\tthrows PortalException {\n\n\t\tlong coverImageId = 0;\n\n\t\tbyte[] bytes = null;\n\n\t\ttry {\n\t\t\tbytes = coverImageImageSelector.getCroppedImageBytes();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\n\t\tif (bytes == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = coverImageImageSelector.getTitle();\n\t\t\tString mimeType = coverImageImageSelector.getMimeType();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempCroppedImage_\" + entryId;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tFileEntry fileEntry = PortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\t\tgroupId, userId, BlogsEntry.class.getName(), entryId,\n\t\t\t\tBlogsConstants.SERVICE_NAME, folder.getFolderId(), file, title,\n\t\t\t\tmimeType, false);\n\n\t\t\tcoverImageId = fileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\n\t\treturn coverImageId;\n\t}","id":9926,"modified_method":"protected long addCoverImage(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector coverImageImageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\tcoverImageImageSelector.getImageId());\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tif (fileEntry.isRepositoryCapabilityProvided(\n\t\t\t\tTemporaryFileEntriesCapability.class)) {\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder, fileEntry.getTitle(),\n\t\t\t\t\tfileEntry.getMimeType(), fileEntry.getContentStream());\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tbyte[] bytes = coverImageImageSelector.getCroppedImageBytes();\n\n\t\t\tif (bytes == null) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = fileEntry.getTitle();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempCroppedImage_\" + entryId;\n\t\t\t}\n\n\t\t\tFolder folder = addCoverImageFolder(userId, groupId);\n\n\t\t\tFileEntry coverImageFileEntry =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\t\tgroupId, userId, entryId, folder, title,\n\t\t\t\t\t\tfileEntry.getMimeType(), file);\n\n\t\t\treturn coverImageFileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\n\t\treturn 0;\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Folder addAttachmentsFolder(long userId, long groupId)\n\t\tthrows PortalException {\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tRepository repository = PortletFileRepositoryUtil.addPortletRepository(\n\t\t\tgroupId, BlogsConstants.SERVICE_NAME, serviceContext);\n\n\t\tFolder folder = PortletFileRepositoryUtil.addPortletFolder(\n\t\t\tuserId, repository.getRepositoryId(),\n\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tBlogsConstants.SERVICE_NAME, serviceContext);\n\n\t\treturn folder;\n\t}","id":9927,"modified_method":"@Override\n\tpublic Folder addAttachmentsFolder(long userId, long groupId)\n\t\tthrows PortalException {\n\n\t\treturn doAddFolder(userId, groupId, BlogsConstants.SERVICE_NAME);\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addSmallImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId, String mimeType,\n\t\t\tString title, InputStream is)\n\t\tthrows PortalException {\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\tgroupId, userId, BlogsEntry.class.getName(), entryId,\n\t\t\tBlogsConstants.SERVICE_NAME, folder.getFolderId(), is, title,\n\t\t\tmimeType, false);\n\n\t\treturn fileEntry.getFileEntryId();\n\t}","id":9928,"modified_method":"protected long addSmallImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId, String mimeType,\n\t\t\tString title, InputStream is)\n\t\tthrows PortalException {\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\tFileEntry fileEntry =\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder, title, mimeType, is);\n\n\t\treturn fileEntry.getFileEntryId();\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object[] updateEntry(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong entryId = ParamUtil.getLong(actionRequest, \"entryId\");\n\n\t\tString title = ParamUtil.getString(actionRequest, \"title\");\n\t\tString subtitle = ParamUtil.getString(actionRequest, \"subtitle\");\n\n\t\tString description = StringPool.BLANK;\n\n\t\tboolean customAbstract = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"customAbstract\");\n\n\t\tif (customAbstract) {\n\t\t\tdescription = ParamUtil.getString(actionRequest, \"description\");\n\n\t\t\tif (Validator.isNull(description)) {\n\t\t\t\tthrow new EntryDescriptionException();\n\t\t\t}\n\t\t}\n\n\t\tString content = ParamUtil.getString(actionRequest, \"content\");\n\n\t\tint displayDateMonth = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateMonth\");\n\t\tint displayDateDay = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateDay\");\n\t\tint displayDateYear = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateYear\");\n\t\tint displayDateHour = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateHour\");\n\t\tint displayDateMinute = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateMinute\");\n\t\tint displayDateAmPm = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateAmPm\");\n\n\t\tif (displayDateAmPm == Calendar.PM) {\n\t\t\tdisplayDateHour += 12;\n\t\t}\n\n\t\tboolean allowPingbacks = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowPingbacks\");\n\t\tboolean allowTrackbacks = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowTrackbacks\");\n\t\tString[] trackbacks = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"trackbacks\"));\n\n\t\tlong coverImageFileEntryId = ParamUtil.getLong(\n\t\t\tactionRequest, \"coverImageFileEntryId\");\n\t\tString coverImageURL = ParamUtil.getString(\n\t\t\tactionRequest, \"coverImageURL\");\n\t\tString coverImageFileEntryCropRegion = ParamUtil.getString(\n\t\t\tactionRequest, \"coverImageFileEntryCropRegion\");\n\n\t\tString coverImageCaption = ParamUtil.getString(\n\t\t\tactionRequest, \"coverImageCaption\");\n\n\t\tImageSelector coverImageImageSelector = new ImageSelector(\n\t\t\tcoverImageFileEntryId, coverImageURL,\n\t\t\tcoverImageFileEntryCropRegion);\n\n\t\tlong smallImageFileEntryId = ParamUtil.getLong(\n\t\t\tactionRequest, \"smallImageFileEntryId\");\n\t\tString smallImageURL = ParamUtil.getString(\n\t\t\tactionRequest, \"smallImageURL\");\n\n\t\tImageSelector smallImageImageSelector = new ImageSelector(\n\t\t\tsmallImageFileEntryId, smallImageURL, null);\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tBlogsEntry.class.getName(), actionRequest);\n\n\t\tBlogsEntry entry = null;\n\t\tString oldUrlTitle = StringPool.BLANK;\n\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\tblogsEntryAttachmentFileEntryReferences = new ArrayList<>();\n\n\t\tif (entryId <= 0) {\n\n\t\t\t// Add entry\n\n\t\t\tentry = BlogsEntryServiceUtil.addEntry(\n\t\t\t\ttitle, subtitle, description, content, displayDateMonth,\n\t\t\t\tdisplayDateDay, displayDateYear, displayDateHour,\n\t\t\t\tdisplayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\tcoverImageCaption, coverImageImageSelector,\n\t\t\t\tsmallImageImageSelector, serviceContext);\n\n\t\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\t\tList<FileEntry> tempBlogsEntryAttachments =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntries(content);\n\n\t\t\tif (!tempBlogsEntryAttachments.isEmpty()) {\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\t\t\t\t\tentry.getGroupId(), themeDisplay.getUserId(),\n\t\t\t\t\t\t\tentry.getEntryId(), tempBlogsEntryAttachments);\n\n\t\t\t\tcontent = blogsEntryAttachmentFileEntryHelper.updateContent(\n\t\t\t\t\tcontent, blogsEntryAttachmentFileEntryReferences);\n\n\t\t\t\tentry.setContent(content);\n\n\t\t\t\tBlogsEntryLocalServiceUtil.updateBlogsEntry(entry);\n\t\t\t}\n\n\t\t\tfor (FileEntry tempBlogsEntryAttachment :\n\t\t\t\t\ttempBlogsEntryAttachments) {\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempBlogsEntryAttachment.getFileEntryId());\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Update entry\n\n\t\t\tboolean sendEmailEntryUpdated = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"sendEmailEntryUpdated\");\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\t\"sendEmailEntryUpdated\", sendEmailEntryUpdated);\n\n\t\t\tString emailEntryUpdatedComment = ParamUtil.getString(\n\t\t\t\tactionRequest, \"emailEntryUpdatedComment\");\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\t\"emailEntryUpdatedComment\", emailEntryUpdatedComment);\n\n\t\t\tentry = BlogsEntryLocalServiceUtil.getEntry(entryId);\n\n\t\t\tString tempOldUrlTitle = entry.getUrlTitle();\n\n\t\t\tBlogsEntryAttachmentFileEntryHelper blogsEntryAttachmentHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\t\tList<FileEntry> tempBlogsEntryAttachmentFileEntries =\n\t\t\t\tblogsEntryAttachmentHelper.\n\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntries(content);\n\n\t\t\tif (!tempBlogsEntryAttachmentFileEntries.isEmpty()) {\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\tblogsEntryAttachmentHelper.\n\t\t\t\t\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\t\t\t\t\tentry.getGroupId(), themeDisplay.getUserId(),\n\t\t\t\t\t\t\tentry.getEntryId(),\n\t\t\t\t\t\t\ttempBlogsEntryAttachmentFileEntries);\n\n\t\t\t\tcontent = blogsEntryAttachmentHelper.updateContent(\n\t\t\t\t\tcontent, blogsEntryAttachmentFileEntryReferences);\n\t\t\t}\n\n\t\t\tentry = BlogsEntryServiceUtil.updateEntry(\n\t\t\t\tentryId, title, subtitle, description, content,\n\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\tallowTrackbacks, trackbacks, coverImageCaption,\n\t\t\t\tcoverImageImageSelector, smallImageImageSelector,\n\t\t\t\tserviceContext);\n\n\t\t\tfor (FileEntry tempBlogsEntryAttachmentFileEntry :\n\t\t\t\t\ttempBlogsEntryAttachmentFileEntries) {\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempBlogsEntryAttachmentFileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (!tempOldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\t\toldUrlTitle = tempOldUrlTitle;\n\t\t\t}\n\t\t}\n\n\t\treturn new Object[] {\n\t\t\tentry, oldUrlTitle, blogsEntryAttachmentFileEntryReferences\n\t\t};\n\t}","id":9929,"modified_method":"protected Object[] updateEntry(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong entryId = ParamUtil.getLong(actionRequest, \"entryId\");\n\n\t\tString title = ParamUtil.getString(actionRequest, \"title\");\n\t\tString subtitle = ParamUtil.getString(actionRequest, \"subtitle\");\n\n\t\tString description = StringPool.BLANK;\n\n\t\tboolean customAbstract = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"customAbstract\");\n\n\t\tif (customAbstract) {\n\t\t\tdescription = ParamUtil.getString(actionRequest, \"description\");\n\n\t\t\tif (Validator.isNull(description)) {\n\t\t\t\tthrow new EntryDescriptionException();\n\t\t\t}\n\t\t}\n\n\t\tString content = ParamUtil.getString(actionRequest, \"content\");\n\n\t\tint displayDateMonth = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateMonth\");\n\t\tint displayDateDay = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateDay\");\n\t\tint displayDateYear = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateYear\");\n\t\tint displayDateHour = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateHour\");\n\t\tint displayDateMinute = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateMinute\");\n\t\tint displayDateAmPm = ParamUtil.getInteger(\n\t\t\tactionRequest, \"displayDateAmPm\");\n\n\t\tif (displayDateAmPm == Calendar.PM) {\n\t\t\tdisplayDateHour += 12;\n\t\t}\n\n\t\tboolean allowPingbacks = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowPingbacks\");\n\t\tboolean allowTrackbacks = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"allowTrackbacks\");\n\t\tString[] trackbacks = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"trackbacks\"));\n\n\t\tlong coverImageFileEntryId = ParamUtil.getLong(\n\t\t\tactionRequest, \"coverImageFileEntryId\");\n\t\tString coverImageURL = ParamUtil.getString(\n\t\t\tactionRequest, \"coverImageURL\");\n\t\tString coverImageFileEntryCropRegion = ParamUtil.getString(\n\t\t\tactionRequest, \"coverImageFileEntryCropRegion\");\n\n\t\tString coverImageCaption = ParamUtil.getString(\n\t\t\tactionRequest, \"coverImageCaption\");\n\n\t\tImageSelector coverImageImageSelector = new ImageSelector(\n\t\t\tcoverImageFileEntryId, coverImageURL,\n\t\t\tcoverImageFileEntryCropRegion);\n\n\t\tlong smallImageFileEntryId = ParamUtil.getLong(\n\t\t\tactionRequest, \"smallImageFileEntryId\");\n\t\tString smallImageURL = ParamUtil.getString(\n\t\t\tactionRequest, \"smallImageURL\");\n\n\t\tImageSelector smallImageImageSelector = new ImageSelector(\n\t\t\tsmallImageFileEntryId, smallImageURL, null);\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tBlogsEntry.class.getName(), actionRequest);\n\n\t\tBlogsEntry entry = null;\n\t\tString oldUrlTitle = StringPool.BLANK;\n\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\tblogsEntryAttachmentFileEntryReferences = new ArrayList<>();\n\n\t\tif (entryId <= 0) {\n\n\t\t\t// Add entry\n\n\t\t\tentry = BlogsEntryServiceUtil.addEntry(\n\t\t\t\ttitle, subtitle, description, content, displayDateMonth,\n\t\t\t\tdisplayDateDay, displayDateYear, displayDateHour,\n\t\t\t\tdisplayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\tcoverImageCaption, coverImageImageSelector,\n\t\t\t\tsmallImageImageSelector, serviceContext);\n\n\t\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\t\tList<FileEntry> tempBlogsEntryAttachments =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntries(content);\n\n\t\t\tFolder folder = BlogsEntryLocalServiceUtil.addAttachmentsFolder(\n\t\t\t\tthemeDisplay.getUserId(), entry.getGroupId());\n\n\t\t\tif (!tempBlogsEntryAttachments.isEmpty()) {\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\t\t\t\t\tentry.getGroupId(), themeDisplay.getUserId(),\n\t\t\t\t\t\t\tentry.getEntryId(), folder,\n\t\t\t\t\t\t\ttempBlogsEntryAttachments);\n\n\t\t\t\tcontent = blogsEntryAttachmentFileEntryHelper.updateContent(\n\t\t\t\t\tcontent, blogsEntryAttachmentFileEntryReferences);\n\n\t\t\t\tentry.setContent(content);\n\n\t\t\t\tBlogsEntryLocalServiceUtil.updateBlogsEntry(entry);\n\t\t\t}\n\n\t\t\tfor (FileEntry tempBlogsEntryAttachment :\n\t\t\t\t\ttempBlogsEntryAttachments) {\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempBlogsEntryAttachment.getFileEntryId());\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t// Update entry\n\n\t\t\tboolean sendEmailEntryUpdated = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"sendEmailEntryUpdated\");\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\t\"sendEmailEntryUpdated\", sendEmailEntryUpdated);\n\n\t\t\tString emailEntryUpdatedComment = ParamUtil.getString(\n\t\t\t\tactionRequest, \"emailEntryUpdatedComment\");\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\t\"emailEntryUpdatedComment\", emailEntryUpdatedComment);\n\n\t\t\tentry = BlogsEntryLocalServiceUtil.getEntry(entryId);\n\n\t\t\tString tempOldUrlTitle = entry.getUrlTitle();\n\n\t\t\tBlogsEntryAttachmentFileEntryHelper blogsEntryAttachmentHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\t\tList<FileEntry> tempBlogsEntryAttachmentFileEntries =\n\t\t\t\tblogsEntryAttachmentHelper.\n\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntries(content);\n\n\t\t\tFolder folder = BlogsEntryLocalServiceUtil.addAttachmentsFolder(\n\t\t\t\tthemeDisplay.getUserId(), entry.getGroupId());\n\n\t\t\tif (!tempBlogsEntryAttachmentFileEntries.isEmpty()) {\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\tblogsEntryAttachmentHelper.\n\t\t\t\t\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\t\t\t\t\tentry.getGroupId(), themeDisplay.getUserId(),\n\t\t\t\t\t\t\tentry.getEntryId(), folder,\n\t\t\t\t\t\t\ttempBlogsEntryAttachmentFileEntries);\n\n\t\t\t\tcontent = blogsEntryAttachmentHelper.updateContent(\n\t\t\t\t\tcontent, blogsEntryAttachmentFileEntryReferences);\n\t\t\t}\n\n\t\t\tentry = BlogsEntryServiceUtil.updateEntry(\n\t\t\t\tentryId, title, subtitle, description, content,\n\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\tallowTrackbacks, trackbacks, coverImageCaption,\n\t\t\t\tcoverImageImageSelector, smallImageImageSelector,\n\t\t\t\tserviceContext);\n\n\t\t\tfor (FileEntry tempBlogsEntryAttachmentFileEntry :\n\t\t\t\t\ttempBlogsEntryAttachmentFileEntries) {\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempBlogsEntryAttachmentFileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (!tempOldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\t\toldUrlTitle = tempOldUrlTitle;\n\t\t\t}\n\t\t}\n\n\t\treturn new Object[] {\n\t\t\tentry, oldUrlTitle, blogsEntryAttachmentFileEntryReferences\n\t\t};\n\t}","commit_id":"7c0387acddd893838b8b14f4a9d9440971298185","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List<BlogsEntryAttachmentFileEntryReference>\n\t\tgetBlogsEntryAttachmentFileEntryReferences(\n\t\t\tFileEntry tempFileEntry)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\t_group.getGroupId(), _user.getUserId());\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t_user.getUserId(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), serviceContext);\n\n\t\tList<FileEntry> tempFileEntries = new ArrayList<>();\n\n\t\ttempFileEntries.add(tempFileEntry);\n\n\t\treturn\n\t\t\t_blogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\t\t\t_group.getGroupId(), _user.getUserId(), entry.getEntryId(),\n\t\t\t\t\ttempFileEntries);\n\t}","id":9930,"modified_method":"protected List<BlogsEntryAttachmentFileEntryReference>\n\t\tgetBlogsEntryAttachmentFileEntryReferences(\n\t\t\tFileEntry tempFileEntry)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextTestUtil.getServiceContext(\n\t\t\t\t_group.getGroupId(), _user.getUserId());\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t_user.getUserId(), RandomTestUtil.randomString(),\n\t\t\tRandomTestUtil.randomString(), serviceContext);\n\n\t\tList<FileEntry> tempFileEntries = new ArrayList<>();\n\n\t\ttempFileEntries.add(tempFileEntry);\n\n\t\tFolder folder = BlogsEntryLocalServiceUtil.addAttachmentsFolder(\n\t\t\t_user.getUserId(), _group.getGroupId());\n\n\t\treturn\n\t\t\t_blogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntries(\n\t\t\t\t\t_group.getGroupId(), _user.getUserId(), entry.getEntryId(),\n\t\t\t\t\tfolder, tempFileEntries);\n\t}","commit_id":"65e53a14cdc36f149ad17383c97d2e0f77a06e26","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void getLldpLinks() {\n        List<LldpLink> allLinks = m_lldpLinkDao.findAll();\n        Set<LldpLinkDetail> combinedLinkDetails = new HashSet<LldpLinkDetail>();\n        Set<Integer> parsed = new HashSet<Integer>();\n        for (LldpLink sourceLink : allLinks) {\n            LOG.debug(\"loadtopology: parsing source link: \" + sourceLink);\n            if (parsed.contains(sourceLink.getId())) {\n                LOG.debug(\"loadtopology: already parsed: source link: \" + sourceLink);\n                continue;\n            }\n            parsed.add(sourceLink.getId());\n            OnmsNode sourceNode = sourceLink.getNode();\n            LldpElement sourceElement = sourceNode.getLldpElement();\n            LOG.debug(\"loadtopology: found source node: \" + sourceNode.getLabel());\n            Vertex source = getVertex(getVertexNamespace(), sourceNode.getNodeId());\n            if (source == null) {\n                LOG.debug(\"loadtopology: adding source node as vertex: \" + sourceNode.getLabel());\n                source = getVertex(sourceNode);\n                addVertices(source);\n            }\n\n            LldpLink targetLink = null;\n            for (LldpLink link : allLinks) {\n                LOG.debug(\"loadtopology: try target link: \" + sourceLink);\n                if (parsed.contains(link.getId())) {\n                    LOG.debug(\"loadtopology: already parsed: target link: \" + sourceLink);\n                    continue;\n                }\n                LldpElement element = link.getNode().getLldpElement();\n                //Compare the remote data to the targetNode element data\n                if (!sourceLink.getLldpRemChassisId().equals(element.getLldpChassisId()) || !link.getLldpRemChassisId().equals(sourceElement.getLldpChassisId())) \n                    continue;\n                boolean bool1 = sourceLink.getLldpRemPortId().equals(link.getLldpPortId()) && link.getLldpRemPortId().equals(sourceLink.getLldpPortId());\n                boolean bool2 = sourceLink.getLldpRemPortDescr().equals(link.getLldpPortDescr()) && link.getLldpRemPortDescr().equals(sourceLink.getLldpPortDescr());\n                boolean bool3 = sourceLink.getLldpRemPortIdSubType() == link.getLldpPortIdSubType() && link.getLldpRemPortIdSubType() == sourceLink.getLldpPortIdSubType();\n\n                if (bool1 && bool2 && bool3) {\n                    targetLink=link;\n                    parsed.add(targetLink.getId());\n                    LOG.debug(\"loadtopology: found target link: \" + targetLink);\n                    break;\n                }\n            }\n            \n            if (targetLink == null) {\n                final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsNode.class).addRestriction(new EqRestriction(\"sysName\", sourceLink.getLldpRemSysname()));\n                List<OnmsNode> nodes = m_nodeDao.findMatching(criteria);\n                if (nodes.size() == 1) {\n                    targetLink = reverseLldpLink(nodes.get(0), sourceLink.getNode().getLldpElement(), sourceLink); \n                    LOG.debug(\"loadtopology: found target link using sysname: \" + targetLink);\n                }\n            }\n            \n            if (targetLink == null) {\n                LOG.debug(\"loadtopology: cannot found target for link: \" + sourceLink);\n                continue;\n            }\n                \n            OnmsNode targetNode = targetLink.getNode();\n            Vertex target = getVertex(getVertexNamespace(), targetNode.getNodeId());\n            if (target == null) {\n                LOG.debug(\"loadtopology: adding target node as vertex: \" + targetNode.getLabel());\n                target = getVertex(targetNode);\n                addVertices(target);\n            }\n            combinedLinkDetails.add(new LldpLinkDetail(Math.min(sourceLink.getId(), targetLink.getId()) + \"|\" + Math.max(sourceLink.getId(), targetLink.getId()),\n                                                       source, sourceLink, target, targetLink));\n\n        }\n\n        for (LldpLinkDetail linkDetail : combinedLinkDetails) {\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), LLDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","id":9931,"modified_method":"private void getLldpLinks() {\n        List<LldpLink> allLinks = m_lldpLinkDao.findAll();\n        Set<LldpLinkDetail> combinedLinkDetails = new HashSet<LldpLinkDetail>();\n        Set<Integer> parsed = new HashSet<Integer>();\n        for (LldpLink sourceLink : allLinks) {\n            LOG.debug(\"loadtopology: parsing lldp link with id '{}' link '{}' \", sourceLink.getId(), sourceLink);\n            if (parsed.contains(sourceLink.getId())) {\n                LOG.debug(\"loadtopology: lldp link with id '{]' already parsed, skipping\", sourceLink.getId());\n                continue;\n            }\n            parsed.add(sourceLink.getId());\n            OnmsNode sourceNode = sourceLink.getNode();\n            LldpElement sourceElement = sourceNode.getLldpElement();\n            Vertex source = getVertex(getVertexNamespace(), sourceNode.getNodeId());\n            if (source == null) {\n                source = getVertex(sourceNode);\n                addVertices(source);\n            }\n\n            LldpLink targetLink = null;\n            for (LldpLink link : allLinks) {\n                LOG.debug(\"loadtopology: parsing lldp link with id '{}' link '{}' \", link.getId(), link);\n                if (parsed.contains(link.getId())) {\n                    LOG.debug(\"loadtopology: lldp link with id '{]' already parsed, skipping\", link.getId());\n                    continue;\n                }\n                LldpElement element = link.getNode().getLldpElement();\n                //Compare the remote data to the targetNode element data\n                if (!sourceLink.getLldpRemChassisId().equals(element.getLldpChassisId()) || !link.getLldpRemChassisId().equals(sourceElement.getLldpChassisId())) \n                    continue;\n                boolean bool1 = sourceLink.getLldpRemPortId().equals(link.getLldpPortId()) && link.getLldpRemPortId().equals(sourceLink.getLldpPortId());\n                boolean bool2 = sourceLink.getLldpRemPortDescr().equals(link.getLldpPortDescr()) && link.getLldpRemPortDescr().equals(sourceLink.getLldpPortDescr());\n                boolean bool3 = sourceLink.getLldpRemPortIdSubType() == link.getLldpPortIdSubType() && link.getLldpRemPortIdSubType() == sourceLink.getLldpPortIdSubType();\n\n                if (bool1 && bool2 && bool3) {\n                    targetLink=link;\n                    parsed.add(targetLink.getId());\n                    LOG.debug(\"loadtopology: found lldp mutual link: '{}' and '{}' \", sourceLink,targetLink);\n                    break;\n                }\n            }\n            \n            if (targetLink == null) {\n                final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsNode.class).addRestriction(new EqRestriction(\"sysName\", sourceLink.getLldpRemSysname()));\n                List<OnmsNode> nodes = m_nodeDao.findMatching(criteria);\n                if (nodes.size() == 1) {\n                    targetLink = reverseLldpLink(nodes.get(0), sourceLink.getNode().getLldpElement(), sourceLink); \n                    LOG.debug(\"loadtopology: found lldp link using lldp rem sysname: '{}' and '{}'\", sourceLink, targetLink);\n                }\n            }\n            \n            if (targetLink == null) {\n                LOG.debug(\"loadtopology: cannot found target node for link: '{}'\", sourceLink);\n                continue;\n            }\n                \n            OnmsNode targetNode = targetLink.getNode();\n            Vertex target = getVertex(getVertexNamespace(), targetNode.getNodeId());\n            if (target == null) {\n                target = getVertex(targetNode);\n                addVertices(target);\n            }\n            combinedLinkDetails.add(new LldpLinkDetail(Math.min(sourceLink.getId(), targetLink.getId()) + \"|\" + Math.max(sourceLink.getId(), targetLink.getId()),\n                                                       source, sourceLink, target, targetLink));\n\n        }\n\n        for (LldpLinkDetail linkDetail : combinedLinkDetails) {\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), LLDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","commit_id":"41bebca8a99c786a527ae2ef63c8ed7250471d3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private LldpLink reverseLldpLink(OnmsNode sourcenode, LldpElement element, LldpLink link) {\n        LldpLink reverseLink = new LldpLink();\n        reverseLink.setNode(sourcenode);\n        \n        reverseLink.setLldpLocalPortNum(0);\n        reverseLink.setLldpPortId(link.getLldpRemPortId());\n        reverseLink.setLldpPortIdSubType(link.getLldpRemPortIdSubType());\n        if (link.getLldpRemPortIdSubType() == LldpPortIdSubType.LLDP_PORTID_SUBTYPE_LOCAL) {\n            try {\n                Integer remIfIndex = Integer.getInteger(link.getLldpRemPortId());\n                reverseLink.setLldpPortIfindex(remIfIndex);\n            } catch (Exception e) {\n            }\n        }\n\n        reverseLink.setLldpPortDescr(link.getLldpRemPortDescr());\n        reverseLink.setLldpRemChassisId(element.getLldpChassisId());\n        reverseLink.setLldpRemChassisIdSubType(element.getLldpChassisIdSubType());\n        reverseLink.setLldpRemSysname(element.getLldpSysname());\n        \n        reverseLink.setLldpRemPortId(link.getLldpPortId());\n        reverseLink.setLldpRemPortIdSubType(link.getLldpPortIdSubType());\n        reverseLink.setLldpRemPortDescr(link.getLldpPortDescr());\n        \n        reverseLink.setLldpLinkCreateTime(link.getLldpLinkCreateTime());\n        reverseLink.setLldpLinkLastPollTime(link.getLldpLinkLastPollTime());\n        \n        return reverseLink;\n    }","id":9932,"modified_method":"private LldpLink reverseLldpLink(OnmsNode sourcenode, LldpElement element, LldpLink link) {\n        LldpLink reverseLink = new LldpLink();\n        reverseLink.setId(-link.getId());\n        reverseLink.setNode(sourcenode);\n        \n        reverseLink.setLldpLocalPortNum(0);\n        reverseLink.setLldpPortId(link.getLldpRemPortId());\n        reverseLink.setLldpPortIdSubType(link.getLldpRemPortIdSubType());\n        reverseLink.setLldpPortDescr(link.getLldpRemPortDescr());\n        if (link.getLldpRemPortIdSubType() == LldpPortIdSubType.LLDP_PORTID_SUBTYPE_LOCAL) {\n            try {\n                reverseLink.setLldpPortIfindex(Integer.getInteger(link.getLldpRemPortId()));\n            } catch (Exception e) {\n                LOG.debug(\"reverseLldpLink: cannot create ifindex from  LldpRemPortId '{}'\", link.getLldpRemPortId());\n            }\n        }\n\n        reverseLink.setLldpRemChassisId(element.getLldpChassisId());\n        reverseLink.setLldpRemChassisIdSubType(element.getLldpChassisIdSubType());\n        reverseLink.setLldpRemSysname(element.getLldpSysname());\n        \n        reverseLink.setLldpRemPortId(link.getLldpPortId());\n        reverseLink.setLldpRemPortIdSubType(link.getLldpPortIdSubType());\n        reverseLink.setLldpRemPortDescr(link.getLldpPortDescr());\n        \n        reverseLink.setLldpLinkCreateTime(link.getLldpLinkCreateTime());\n        reverseLink.setLldpLinkLastPollTime(link.getLldpLinkLastPollTime());\n        \n        return reverseLink;\n    }","commit_id":"41bebca8a99c786a527ae2ef63c8ed7250471d3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    @Transactional\n    public void load(String filename) throws MalformedURLException, JAXBException {\n        if (filename != null) {\n            LOG.warn(\"Filename that was specified for linkd topology will be ignored: \" + filename + \", using \" + getConfigurationFile() + \" instead\");\n        }\n        try{\n            //TODO: change to one query from the database that will return all links plus elements joined\n            //This reset container is set in here for the demo, don't commit\n\n            resetContainer();\n\n            getLldpLinks();\n            getOspfLinks();\n            getIsIsLinks();\n            getBridgeLinks();\n            getCdpLinks();\n\n\n        } catch (Exception e){\n            LOG.debug(e.getStackTrace().toString());\n        }\n\n        LOG.debug(\"loadtopology: adding nodes without links: \" + isAddNodeWithoutLink());\n        if (isAddNodeWithoutLink()) {\n            addNodesWithoutLinks();\n        }\n\n        File configFile = new File(getConfigurationFile());\n        if (configFile.exists() && configFile.canRead()) {\n            LOG.debug(\"loadtopology: loading topology from configuration file: \" + getConfigurationFile());\n            WrappedGraph graph = getGraphFromFile(configFile);\n\n            // Add all groups to the topology\n            for (WrappedVertex eachVertexInFile: graph.m_vertices) {\n                if (eachVertexInFile.group) {\n                    LOG.debug(\"loadtopology: adding group to topology: \" + eachVertexInFile.id);\n                    if (eachVertexInFile.namespace == null) {\n                        eachVertexInFile.namespace = getVertexNamespace();\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Setting namespace on vertex to default: {}\", eachVertexInFile);\n                    }\n                    if (eachVertexInFile.id == null) {\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Invalid vertex unmarshalled from {}: {}\", getConfigurationFile(), eachVertexInFile);\n                    }\n                    AbstractVertex newGroupVertex = addGroup(eachVertexInFile.id, eachVertexInFile.iconKey, eachVertexInFile.label);\n                    newGroupVertex.setIpAddress(eachVertexInFile.ipAddr);\n                    newGroupVertex.setLocked(eachVertexInFile.locked);\n                    if (eachVertexInFile.nodeID != null) newGroupVertex.setNodeID(eachVertexInFile.nodeID);\n                    if (!newGroupVertex.equals(eachVertexInFile.parent)) newGroupVertex.setParent(eachVertexInFile.parent);\n                    newGroupVertex.setSelected(eachVertexInFile.selected);\n                    newGroupVertex.setStyleName(eachVertexInFile.styleName);\n                    newGroupVertex.setTooltipText(eachVertexInFile.tooltipText);\n                    if (eachVertexInFile.x != null) newGroupVertex.setX(eachVertexInFile.x);\n                    if (eachVertexInFile.y != null) newGroupVertex.setY(eachVertexInFile.y);\n                }\n            }\n            for (Vertex vertex: getVertices()) {\n                if (vertex.getParent() != null && !vertex.equals(vertex.getParent())) {\n                    LOG.debug(\"loadtopology: setting parent of \" + vertex + \" to \" + vertex.getParent());\n                    setParent(vertex, vertex.getParent());\n                }\n            }\n            // Add all children to the specific group\n            // Attention: We ignore all other attributes, they do not need to be merged!\n            for (WrappedVertex eachVertexInFile : graph.m_vertices) {\n                if (!eachVertexInFile.group && eachVertexInFile.parent != null) {\n                    final Vertex child = getVertex(eachVertexInFile);\n                    final Vertex parent = getVertex(eachVertexInFile.parent);\n                    if (child == null || parent == null) continue;\n                    LOG.debug(\"loadtopology: setting parent of \" + child + \" to \" + parent);\n                    if (!child.equals(parent)) setParent(child, parent);\n                }\n            }\n        } else {\n            LOG.debug(\"loadtopology: could not load topology configFile:\" + getConfigurationFile());\n        }\n        LOG.debug(\"Found \" + getGroups().size() + \" groups\");\n        LOG.debug(\"Found \" + getVerticesWithoutGroups().size() + \" vertices\");\n        LOG.debug(\"Found \" + getEdges().size() + \" edges\");\n\n\n\n    }","id":9933,"modified_method":"@Override\n    @Transactional\n    public void load(String filename) throws MalformedURLException, JAXBException {\n        if (filename != null) {\n            LOG.warn(\"Filename that was specified for linkd topology will be ignored: \" + filename + \", using \" + getConfigurationFile() + \" instead\");\n        }\n        try{\n            //TODO: change to one query from the database that will return all links plus elements joined\n            //This reset container is set in here for the demo, don't commit\n\n            resetContainer();\n        } catch (Exception e){\n            LOG.error(\"Exception reset Container: \"+e.getMessage(),e);\n        }\n\n        try{\n            getLldpLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Lldp link: \"+e.getMessage(),e);\n        }\n        try{\n            getOspfLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Ospf link: \"+e.getMessage(),e);\n        }\n        try{\n            getIsIsLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting IsIs link: \"+e.getMessage(),e);\n        }\n        try{\n            getBridgeLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Bridge link: \"+e.getMessage(),e);\n        }\n        try{\n            getCdpLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Cdp link: \"+e.getMessage(),e);\n        }\n\n        LOG.debug(\"loadtopology: adding nodes without links: \" + isAddNodeWithoutLink());\n        if (isAddNodeWithoutLink()) {\n            addNodesWithoutLinks();\n        }\n\n        File configFile = new File(getConfigurationFile());\n        if (configFile.exists() && configFile.canRead()) {\n            LOG.debug(\"loadtopology: loading topology from configuration file: \" + getConfigurationFile());\n            WrappedGraph graph = getGraphFromFile(configFile);\n\n            // Add all groups to the topology\n            for (WrappedVertex eachVertexInFile: graph.m_vertices) {\n                if (eachVertexInFile.group) {\n                    LOG.debug(\"loadtopology: adding group to topology: \" + eachVertexInFile.id);\n                    if (eachVertexInFile.namespace == null) {\n                        eachVertexInFile.namespace = getVertexNamespace();\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Setting namespace on vertex to default: {}\", eachVertexInFile);\n                    }\n                    if (eachVertexInFile.id == null) {\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Invalid vertex unmarshalled from {}: {}\", getConfigurationFile(), eachVertexInFile);\n                    }\n                    AbstractVertex newGroupVertex = addGroup(eachVertexInFile.id, eachVertexInFile.iconKey, eachVertexInFile.label);\n                    newGroupVertex.setIpAddress(eachVertexInFile.ipAddr);\n                    newGroupVertex.setLocked(eachVertexInFile.locked);\n                    if (eachVertexInFile.nodeID != null) newGroupVertex.setNodeID(eachVertexInFile.nodeID);\n                    if (!newGroupVertex.equals(eachVertexInFile.parent)) newGroupVertex.setParent(eachVertexInFile.parent);\n                    newGroupVertex.setSelected(eachVertexInFile.selected);\n                    newGroupVertex.setStyleName(eachVertexInFile.styleName);\n                    newGroupVertex.setTooltipText(eachVertexInFile.tooltipText);\n                    if (eachVertexInFile.x != null) newGroupVertex.setX(eachVertexInFile.x);\n                    if (eachVertexInFile.y != null) newGroupVertex.setY(eachVertexInFile.y);\n                }\n            }\n            for (Vertex vertex: getVertices()) {\n                if (vertex.getParent() != null && !vertex.equals(vertex.getParent())) {\n                    LOG.debug(\"loadtopology: setting parent of \" + vertex + \" to \" + vertex.getParent());\n                    setParent(vertex, vertex.getParent());\n                }\n            }\n            // Add all children to the specific group\n            // Attention: We ignore all other attributes, they do not need to be merged!\n            for (WrappedVertex eachVertexInFile : graph.m_vertices) {\n                if (!eachVertexInFile.group && eachVertexInFile.parent != null) {\n                    final Vertex child = getVertex(eachVertexInFile);\n                    final Vertex parent = getVertex(eachVertexInFile.parent);\n                    if (child == null || parent == null) continue;\n                    LOG.debug(\"loadtopology: setting parent of \" + child + \" to \" + parent);\n                    if (!child.equals(parent)) setParent(child, parent);\n                }\n            }\n        } else {\n            LOG.debug(\"loadtopology: could not load topology configFile:\" + getConfigurationFile());\n        }\n        LOG.debug(\"Found \" + getGroups().size() + \" groups\");\n        LOG.debug(\"Found \" + getVerticesWithoutGroups().size() + \" vertices\");\n        LOG.debug(\"Found \" + getEdges().size() + \" edges\");\n\n\n\n    }","commit_id":"41bebca8a99c786a527ae2ef63c8ed7250471d3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getIsIsLinks(){\n        List<Object[]> isislinks = m_isisLinkDao.getLinksForTopology();\n\n        for (Object[] linkObj : isislinks) {\n            Integer link1Id = (Integer) linkObj[1];\n            Integer link1Nodeid = (Integer) linkObj[2];\n            Integer link1IfIndex = (Integer) linkObj[3];\n            Integer link2Id = (Integer) linkObj[4];\n            Integer link2Nodeid = (Integer) linkObj[5];\n            Integer link2IfIndex = (Integer) linkObj[6];\n            IsIsLinkDetail linkDetail = new IsIsLinkDetail(\n                    Math.min(link1Id, link2Id) + \"|\" + Math.max(link1Id, link2Id),\n                    getVertex(m_nodeDao.get(link1Nodeid)),\n                    link1Id,\n                    link1IfIndex,\n                    getVertex(m_nodeDao.get(link2Nodeid)),\n                    link2Id,\n                    link2IfIndex\n            );\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), ISIS_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","id":9934,"modified_method":"private void getIsIsLinks(){\n        List<Object[]> isislinks = m_isisLinkDao.getLinksForTopology();\n\n        for (Object[] linkObj : isislinks) {\n            LOG.debug(\"loadtopology: adding isis link: '{}'\", linkObj );\n            Integer link1Id = (Integer) linkObj[1];\n            Integer link1Nodeid = (Integer) linkObj[2];\n            Integer link1IfIndex = (Integer) linkObj[3];\n            Integer link2Id = (Integer) linkObj[4];\n            Integer link2Nodeid = (Integer) linkObj[5];\n            Integer link2IfIndex = (Integer) linkObj[6];\n            IsIsLinkDetail linkDetail = new IsIsLinkDetail(\n                    Math.min(link1Id, link2Id) + \"|\" + Math.max(link1Id, link2Id),\n                    getVertex(m_nodeDao.get(link1Nodeid)),\n                    link1Id,\n                    link1IfIndex,\n                    getVertex(m_nodeDao.get(link2Nodeid)),\n                    link2Id,\n                    link2IfIndex\n            );\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), ISIS_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","commit_id":"41bebca8a99c786a527ae2ef63c8ed7250471d3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getCdpLinks() {\n        List<CdpTopologyLink> cdpLinks = m_cdpLinkDao.findLinksForTopology();\n\n        for (CdpTopologyLink link : cdpLinks) {\n            String id = Math.min(link.getSourceId(), link.getTargetId()) + \"|\" + Math.max(link.getSourceId(), link.getTargetId());\n            CdpLinkDetail linkDetail = new CdpLinkDetail(id,\n                    getVertex(m_nodeDao.get(link.getSrcNodeId())),\n                    link.getSrcIfIndex(),\n                    link.getSrcIfName(),\n                    getVertex(m_nodeDao.get(link.getTargetNodeId())),\n                    link.getTargetIfName());\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), CDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n\n        }\n    }","id":9935,"modified_method":"private void getCdpLinks() {\n        List<CdpTopologyLink> cdpLinks = m_cdpLinkDao.findLinksForTopology();\n\n        for (CdpTopologyLink link : cdpLinks) {\n            LOG.debug(\"loadtopology: adding cdp link: '{}'\", link );\n            String id = Math.min(link.getSourceId(), link.getTargetId()) + \"|\" + Math.max(link.getSourceId(), link.getTargetId());\n            CdpLinkDetail linkDetail = new CdpLinkDetail(id,\n                    getVertex(m_nodeDao.get(link.getSrcNodeId())),\n                    link.getSrcIfIndex(),\n                    link.getSrcIfName(),\n                    getVertex(m_nodeDao.get(link.getTargetNodeId())),\n                    link.getTargetIfName());\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), CDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n\n        }\n    }","commit_id":"41bebca8a99c786a527ae2ef63c8ed7250471d3b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getIsIsLinks(){\n        List<Object[]> isislinks = m_isisLinkDao.getLinksForTopology();\n\n        for (Object[] linkObj : isislinks) {\n            Integer link1Id = (Integer) linkObj[1];\n            Integer link1Nodeid = (Integer) linkObj[2];\n            Integer link1IfIndex = (Integer) linkObj[3];\n            Integer link2Id = (Integer) linkObj[4];\n            Integer link2Nodeid = (Integer) linkObj[5];\n            Integer link2IfIndex = (Integer) linkObj[6];\n            IsIsLinkDetail linkDetail = new IsIsLinkDetail(\n                    Math.min(link1Id, link2Id) + \"|\" + Math.max(link1Id, link2Id),\n                    getVertex(m_nodeDao.get(link1Nodeid)),\n                    link1Id,\n                    link1IfIndex,\n                    getVertex(m_nodeDao.get(link2Nodeid)),\n                    link2Id,\n                    link2IfIndex\n            );\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), ISIS_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","id":9936,"modified_method":"private void getIsIsLinks(){\n        List<Object[]> isislinks = m_isisLinkDao.getLinksForTopology();\n\n        for (Object[] linkObj : isislinks) {\n            LOG.debug(\"loadtopology: adding isis link: '{}'\", linkObj );\n            Integer link1Id = (Integer) linkObj[1];\n            Integer link1Nodeid = (Integer) linkObj[2];\n            Integer link1IfIndex = (Integer) linkObj[3];\n            Integer link2Id = (Integer) linkObj[4];\n            Integer link2Nodeid = (Integer) linkObj[5];\n            Integer link2IfIndex = (Integer) linkObj[6];\n            IsIsLinkDetail linkDetail = new IsIsLinkDetail(\n                    Math.min(link1Id, link2Id) + \"|\" + Math.max(link1Id, link2Id),\n                    getVertex(m_nodeDao.get(link1Nodeid)),\n                    link1Id,\n                    link1IfIndex,\n                    getVertex(m_nodeDao.get(link2Nodeid)),\n                    link2Id,\n                    link2IfIndex\n            );\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), ISIS_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","commit_id":"3e4b6a1bd25e4ed8af2dbf9d515020e532b7e13b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    @Transactional\n    public void load(String filename) throws MalformedURLException, JAXBException {\n        if (filename != null) {\n            LOG.warn(\"Filename that was specified for linkd topology will be ignored: \" + filename + \", using \" + getConfigurationFile() + \" instead\");\n        }\n        try{\n            //TODO: change to one query from the database that will return all links plus elements joined\n            //This reset container is set in here for the demo, don't commit\n\n            resetContainer();\n\n            getLldpLinks();\n            getOspfLinks();\n            getIsIsLinks();\n            getBridgeLinks();\n            getCdpLinks();\n\n\n        } catch (Exception e){\n            LOG.debug(e.getStackTrace().toString());\n        }\n\n        LOG.debug(\"loadtopology: adding nodes without links: \" + isAddNodeWithoutLink());\n        if (isAddNodeWithoutLink()) {\n            addNodesWithoutLinks();\n        }\n\n        File configFile = new File(getConfigurationFile());\n        if (configFile.exists() && configFile.canRead()) {\n            LOG.debug(\"loadtopology: loading topology from configuration file: \" + getConfigurationFile());\n            WrappedGraph graph = getGraphFromFile(configFile);\n\n            // Add all groups to the topology\n            for (WrappedVertex eachVertexInFile: graph.m_vertices) {\n                if (eachVertexInFile.group) {\n                    LOG.debug(\"loadtopology: adding group to topology: \" + eachVertexInFile.id);\n                    if (eachVertexInFile.namespace == null) {\n                        eachVertexInFile.namespace = getVertexNamespace();\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Setting namespace on vertex to default: {}\", eachVertexInFile);\n                    }\n                    if (eachVertexInFile.id == null) {\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Invalid vertex unmarshalled from {}: {}\", getConfigurationFile(), eachVertexInFile);\n                    }\n                    AbstractVertex newGroupVertex = addGroup(eachVertexInFile.id, eachVertexInFile.iconKey, eachVertexInFile.label);\n                    newGroupVertex.setIpAddress(eachVertexInFile.ipAddr);\n                    newGroupVertex.setLocked(eachVertexInFile.locked);\n                    if (eachVertexInFile.nodeID != null) newGroupVertex.setNodeID(eachVertexInFile.nodeID);\n                    if (!newGroupVertex.equals(eachVertexInFile.parent)) newGroupVertex.setParent(eachVertexInFile.parent);\n                    newGroupVertex.setSelected(eachVertexInFile.selected);\n                    newGroupVertex.setStyleName(eachVertexInFile.styleName);\n                    newGroupVertex.setTooltipText(eachVertexInFile.tooltipText);\n                    if (eachVertexInFile.x != null) newGroupVertex.setX(eachVertexInFile.x);\n                    if (eachVertexInFile.y != null) newGroupVertex.setY(eachVertexInFile.y);\n                }\n            }\n            for (Vertex vertex: getVertices()) {\n                if (vertex.getParent() != null && !vertex.equals(vertex.getParent())) {\n                    LOG.debug(\"loadtopology: setting parent of \" + vertex + \" to \" + vertex.getParent());\n                    setParent(vertex, vertex.getParent());\n                }\n            }\n            // Add all children to the specific group\n            // Attention: We ignore all other attributes, they do not need to be merged!\n            for (WrappedVertex eachVertexInFile : graph.m_vertices) {\n                if (!eachVertexInFile.group && eachVertexInFile.parent != null) {\n                    final Vertex child = getVertex(eachVertexInFile);\n                    final Vertex parent = getVertex(eachVertexInFile.parent);\n                    if (child == null || parent == null) continue;\n                    LOG.debug(\"loadtopology: setting parent of \" + child + \" to \" + parent);\n                    if (!child.equals(parent)) setParent(child, parent);\n                }\n            }\n        } else {\n            LOG.debug(\"loadtopology: could not load topology configFile:\" + getConfigurationFile());\n        }\n        LOG.debug(\"Found \" + getGroups().size() + \" groups\");\n        LOG.debug(\"Found \" + getVerticesWithoutGroups().size() + \" vertices\");\n        LOG.debug(\"Found \" + getEdges().size() + \" edges\");\n\n\n\n    }","id":9937,"modified_method":"@Override\n    @Transactional\n    public void load(String filename) throws MalformedURLException, JAXBException {\n        if (filename != null) {\n            LOG.warn(\"Filename that was specified for linkd topology will be ignored: \" + filename + \", using \" + getConfigurationFile() + \" instead\");\n        }\n        try{\n            //TODO: change to one query from the database that will return all links plus elements joined\n            //This reset container is set in here for the demo, don't commit\n\n            resetContainer();\n        } catch (Exception e){\n            LOG.error(\"Exception reset Container: \"+e.getMessage(),e);\n        }\n\n        try{\n            getLldpLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Lldp link: \"+e.getMessage(),e);\n        }\n        try{\n            getOspfLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Ospf link: \"+e.getMessage(),e);\n        }\n        try{\n            getIsIsLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting IsIs link: \"+e.getMessage(),e);\n        }\n        try{\n            getBridgeLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Bridge link: \"+e.getMessage(),e);\n        }\n        try{\n            getCdpLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Cdp link: \"+e.getMessage(),e);\n        }\n\n        LOG.debug(\"loadtopology: adding nodes without links: \" + isAddNodeWithoutLink());\n        if (isAddNodeWithoutLink()) {\n            addNodesWithoutLinks();\n        }\n\n        File configFile = new File(getConfigurationFile());\n        if (configFile.exists() && configFile.canRead()) {\n            LOG.debug(\"loadtopology: loading topology from configuration file: \" + getConfigurationFile());\n            WrappedGraph graph = getGraphFromFile(configFile);\n\n            // Add all groups to the topology\n            for (WrappedVertex eachVertexInFile: graph.m_vertices) {\n                if (eachVertexInFile.group) {\n                    LOG.debug(\"loadtopology: adding group to topology: \" + eachVertexInFile.id);\n                    if (eachVertexInFile.namespace == null) {\n                        eachVertexInFile.namespace = getVertexNamespace();\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Setting namespace on vertex to default: {}\", eachVertexInFile);\n                    }\n                    if (eachVertexInFile.id == null) {\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Invalid vertex unmarshalled from {}: {}\", getConfigurationFile(), eachVertexInFile);\n                    }\n                    AbstractVertex newGroupVertex = addGroup(eachVertexInFile.id, eachVertexInFile.iconKey, eachVertexInFile.label);\n                    newGroupVertex.setIpAddress(eachVertexInFile.ipAddr);\n                    newGroupVertex.setLocked(eachVertexInFile.locked);\n                    if (eachVertexInFile.nodeID != null) newGroupVertex.setNodeID(eachVertexInFile.nodeID);\n                    if (!newGroupVertex.equals(eachVertexInFile.parent)) newGroupVertex.setParent(eachVertexInFile.parent);\n                    newGroupVertex.setSelected(eachVertexInFile.selected);\n                    newGroupVertex.setStyleName(eachVertexInFile.styleName);\n                    newGroupVertex.setTooltipText(eachVertexInFile.tooltipText);\n                    if (eachVertexInFile.x != null) newGroupVertex.setX(eachVertexInFile.x);\n                    if (eachVertexInFile.y != null) newGroupVertex.setY(eachVertexInFile.y);\n                }\n            }\n            for (Vertex vertex: getVertices()) {\n                if (vertex.getParent() != null && !vertex.equals(vertex.getParent())) {\n                    LOG.debug(\"loadtopology: setting parent of \" + vertex + \" to \" + vertex.getParent());\n                    setParent(vertex, vertex.getParent());\n                }\n            }\n            // Add all children to the specific group\n            // Attention: We ignore all other attributes, they do not need to be merged!\n            for (WrappedVertex eachVertexInFile : graph.m_vertices) {\n                if (!eachVertexInFile.group && eachVertexInFile.parent != null) {\n                    final Vertex child = getVertex(eachVertexInFile);\n                    final Vertex parent = getVertex(eachVertexInFile.parent);\n                    if (child == null || parent == null) continue;\n                    LOG.debug(\"loadtopology: setting parent of \" + child + \" to \" + parent);\n                    if (!child.equals(parent)) setParent(child, parent);\n                }\n            }\n        } else {\n            LOG.debug(\"loadtopology: could not load topology configFile:\" + getConfigurationFile());\n        }\n        LOG.debug(\"Found \" + getGroups().size() + \" groups\");\n        LOG.debug(\"Found \" + getVerticesWithoutGroups().size() + \" vertices\");\n        LOG.debug(\"Found \" + getEdges().size() + \" edges\");\n\n\n\n    }","commit_id":"3e4b6a1bd25e4ed8af2dbf9d515020e532b7e13b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getCdpLinks() {\n        List<CdpTopologyLink> cdpLinks = m_cdpLinkDao.findLinksForTopology();\n\n        for (CdpTopologyLink link : cdpLinks) {\n            String id = Math.min(link.getSourceId(), link.getTargetId()) + \"|\" + Math.max(link.getSourceId(), link.getTargetId());\n            CdpLinkDetail linkDetail = new CdpLinkDetail(id,\n                    getVertex(m_nodeDao.get(link.getSrcNodeId())),\n                    link.getSrcIfIndex(),\n                    link.getSrcIfName(),\n                    getVertex(m_nodeDao.get(link.getTargetNodeId())),\n                    link.getTargetIfName());\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), CDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n\n        }\n    }","id":9938,"modified_method":"private void getCdpLinks() {\n        List<CdpTopologyLink> cdpLinks = m_cdpLinkDao.findLinksForTopology();\n\n        for (CdpTopologyLink link : cdpLinks) {\n            LOG.debug(\"loadtopology: adding cdp link: '{}'\", link );\n            String id = Math.min(link.getSourceId(), link.getTargetId()) + \"|\" + Math.max(link.getSourceId(), link.getTargetId());\n            CdpLinkDetail linkDetail = new CdpLinkDetail(id,\n                    getVertex(m_nodeDao.get(link.getSrcNodeId())),\n                    link.getSrcIfIndex(),\n                    link.getSrcIfName(),\n                    getVertex(m_nodeDao.get(link.getTargetNodeId())),\n                    link.getTargetIfName());\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), CDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n\n        }\n    }","commit_id":"3e4b6a1bd25e4ed8af2dbf9d515020e532b7e13b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private LldpLink reverseLldpLink(OnmsNode sourcenode, LldpElement element, LldpLink link) {\n        LldpLink reverseLink = new LldpLink();\n        reverseLink.setNode(sourcenode);\n        \n        reverseLink.setLldpLocalPortNum(0);\n        reverseLink.setLldpPortId(link.getLldpRemPortId());\n        reverseLink.setLldpPortIdSubType(link.getLldpRemPortIdSubType());\n        if (link.getLldpRemPortIdSubType() == LldpPortIdSubType.LLDP_PORTID_SUBTYPE_LOCAL) {\n            try {\n                Integer remIfIndex = Integer.getInteger(link.getLldpRemPortId());\n                reverseLink.setLldpPortIfindex(remIfIndex);\n            } catch (Exception e) {\n            }\n        }\n\n        reverseLink.setLldpPortDescr(link.getLldpRemPortDescr());\n        reverseLink.setLldpRemChassisId(element.getLldpChassisId());\n        reverseLink.setLldpRemChassisIdSubType(element.getLldpChassisIdSubType());\n        reverseLink.setLldpRemSysname(element.getLldpSysname());\n        \n        reverseLink.setLldpRemPortId(link.getLldpPortId());\n        reverseLink.setLldpRemPortIdSubType(link.getLldpPortIdSubType());\n        reverseLink.setLldpRemPortDescr(link.getLldpPortDescr());\n        \n        reverseLink.setLldpLinkCreateTime(link.getLldpLinkCreateTime());\n        reverseLink.setLldpLinkLastPollTime(link.getLldpLinkLastPollTime());\n        \n        return reverseLink;\n    }","id":9939,"modified_method":"private LldpLink reverseLldpLink(OnmsNode sourcenode, LldpElement element, LldpLink link) {\n        LldpLink reverseLink = new LldpLink();\n        reverseLink.setId(-link.getId());\n        reverseLink.setNode(sourcenode);\n        \n        reverseLink.setLldpLocalPortNum(0);\n        reverseLink.setLldpPortId(link.getLldpRemPortId());\n        reverseLink.setLldpPortIdSubType(link.getLldpRemPortIdSubType());\n        reverseLink.setLldpPortDescr(link.getLldpRemPortDescr());\n        if (link.getLldpRemPortIdSubType() == LldpPortIdSubType.LLDP_PORTID_SUBTYPE_LOCAL) {\n            try {\n                reverseLink.setLldpPortIfindex(Integer.getInteger(link.getLldpRemPortId()));\n            } catch (Exception e) {\n                LOG.debug(\"reverseLldpLink: cannot create ifindex from  LldpRemPortId '{}'\", link.getLldpRemPortId());\n            }\n        }\n\n        reverseLink.setLldpRemChassisId(element.getLldpChassisId());\n        reverseLink.setLldpRemChassisIdSubType(element.getLldpChassisIdSubType());\n        reverseLink.setLldpRemSysname(element.getLldpSysname());\n        \n        reverseLink.setLldpRemPortId(link.getLldpPortId());\n        reverseLink.setLldpRemPortIdSubType(link.getLldpPortIdSubType());\n        reverseLink.setLldpRemPortDescr(link.getLldpPortDescr());\n        \n        reverseLink.setLldpLinkCreateTime(link.getLldpLinkCreateTime());\n        reverseLink.setLldpLinkLastPollTime(link.getLldpLinkLastPollTime());\n        \n        return reverseLink;\n    }","commit_id":"3e4b6a1bd25e4ed8af2dbf9d515020e532b7e13b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getLldpLinks() {\n        List<LldpLink> allLinks = m_lldpLinkDao.findAll();\n        Set<LldpLinkDetail> combinedLinkDetails = new HashSet<LldpLinkDetail>();\n        Set<Integer> parsed = new HashSet<Integer>();\n        for (LldpLink sourceLink : allLinks) {\n            LOG.debug(\"loadtopology: parsing source link: \" + sourceLink);\n            if (parsed.contains(sourceLink.getId())) {\n                LOG.debug(\"loadtopology: already parsed: source link: \" + sourceLink);\n                continue;\n            }\n            parsed.add(sourceLink.getId());\n            OnmsNode sourceNode = sourceLink.getNode();\n            LldpElement sourceElement = sourceNode.getLldpElement();\n            LOG.debug(\"loadtopology: found source node: \" + sourceNode.getLabel());\n            Vertex source = getVertex(getVertexNamespace(), sourceNode.getNodeId());\n            if (source == null) {\n                LOG.debug(\"loadtopology: adding source node as vertex: \" + sourceNode.getLabel());\n                source = getVertex(sourceNode);\n                addVertices(source);\n            }\n\n            LldpLink targetLink = null;\n            for (LldpLink link : allLinks) {\n                LOG.debug(\"loadtopology: try target link: \" + sourceLink);\n                if (parsed.contains(link.getId())) {\n                    LOG.debug(\"loadtopology: already parsed: target link: \" + sourceLink);\n                    continue;\n                }\n                LldpElement element = link.getNode().getLldpElement();\n                //Compare the remote data to the targetNode element data\n                if (!sourceLink.getLldpRemChassisId().equals(element.getLldpChassisId()) || !link.getLldpRemChassisId().equals(sourceElement.getLldpChassisId())) \n                    continue;\n                boolean bool1 = sourceLink.getLldpRemPortId().equals(link.getLldpPortId()) && link.getLldpRemPortId().equals(sourceLink.getLldpPortId());\n                boolean bool2 = sourceLink.getLldpRemPortDescr().equals(link.getLldpPortDescr()) && link.getLldpRemPortDescr().equals(sourceLink.getLldpPortDescr());\n                boolean bool3 = sourceLink.getLldpRemPortIdSubType() == link.getLldpPortIdSubType() && link.getLldpRemPortIdSubType() == sourceLink.getLldpPortIdSubType();\n\n                if (bool1 && bool2 && bool3) {\n                    targetLink=link;\n                    parsed.add(targetLink.getId());\n                    LOG.debug(\"loadtopology: found target link: \" + targetLink);\n                    break;\n                }\n            }\n            \n            if (targetLink == null) {\n                final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsNode.class).addRestriction(new EqRestriction(\"sysName\", sourceLink.getLldpRemSysname()));\n                List<OnmsNode> nodes = m_nodeDao.findMatching(criteria);\n                if (nodes.size() == 1) {\n                    targetLink = reverseLldpLink(nodes.get(0), sourceLink.getNode().getLldpElement(), sourceLink); \n                    LOG.debug(\"loadtopology: found target link using sysname: \" + targetLink);\n                }\n            }\n            \n            if (targetLink == null) {\n                LOG.debug(\"loadtopology: cannot found target for link: \" + sourceLink);\n                continue;\n            }\n                \n            OnmsNode targetNode = targetLink.getNode();\n            Vertex target = getVertex(getVertexNamespace(), targetNode.getNodeId());\n            if (target == null) {\n                LOG.debug(\"loadtopology: adding target node as vertex: \" + targetNode.getLabel());\n                target = getVertex(targetNode);\n                addVertices(target);\n            }\n            combinedLinkDetails.add(new LldpLinkDetail(Math.min(sourceLink.getId(), targetLink.getId()) + \"|\" + Math.max(sourceLink.getId(), targetLink.getId()),\n                                                       source, sourceLink, target, targetLink));\n\n        }\n\n        for (LldpLinkDetail linkDetail : combinedLinkDetails) {\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), LLDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","id":9940,"modified_method":"private void getLldpLinks() {\n        List<LldpLink> allLinks = m_lldpLinkDao.findAll();\n        Set<LldpLinkDetail> combinedLinkDetails = new HashSet<LldpLinkDetail>();\n        Set<Integer> parsed = new HashSet<Integer>();\n        for (LldpLink sourceLink : allLinks) {\n            LOG.debug(\"loadtopology: parsing lldp link with id '{}' link '{}' \", sourceLink.getId(), sourceLink);\n            if (parsed.contains(sourceLink.getId())) {\n                LOG.debug(\"loadtopology: lldp link with id '{]' already parsed, skipping\", sourceLink.getId());\n                continue;\n            }\n            parsed.add(sourceLink.getId());\n            OnmsNode sourceNode = sourceLink.getNode();\n            LldpElement sourceElement = sourceNode.getLldpElement();\n            Vertex source = getVertex(getVertexNamespace(), sourceNode.getNodeId());\n            if (source == null) {\n                source = getVertex(sourceNode);\n                addVertices(source);\n            }\n\n            LldpLink targetLink = null;\n            for (LldpLink link : allLinks) {\n                LOG.debug(\"loadtopology: parsing lldp link with id '{}' link '{}' \", link.getId(), link);\n                if (parsed.contains(link.getId())) {\n                    LOG.debug(\"loadtopology: lldp link with id '{]' already parsed, skipping\", link.getId());\n                    continue;\n                }\n                LldpElement element = link.getNode().getLldpElement();\n                //Compare the remote data to the targetNode element data\n                if (!sourceLink.getLldpRemChassisId().equals(element.getLldpChassisId()) || !link.getLldpRemChassisId().equals(sourceElement.getLldpChassisId())) \n                    continue;\n                boolean bool1 = sourceLink.getLldpRemPortId().equals(link.getLldpPortId()) && link.getLldpRemPortId().equals(sourceLink.getLldpPortId());\n                boolean bool2 = sourceLink.getLldpRemPortDescr().equals(link.getLldpPortDescr()) && link.getLldpRemPortDescr().equals(sourceLink.getLldpPortDescr());\n                boolean bool3 = sourceLink.getLldpRemPortIdSubType() == link.getLldpPortIdSubType() && link.getLldpRemPortIdSubType() == sourceLink.getLldpPortIdSubType();\n\n                if (bool1 && bool2 && bool3) {\n                    targetLink=link;\n                    parsed.add(targetLink.getId());\n                    LOG.debug(\"loadtopology: found lldp mutual link: '{}' and '{}' \", sourceLink,targetLink);\n                    break;\n                }\n            }\n            \n            if (targetLink == null) {\n                final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsNode.class).addRestriction(new EqRestriction(\"sysName\", sourceLink.getLldpRemSysname()));\n                List<OnmsNode> nodes = m_nodeDao.findMatching(criteria);\n                if (nodes.size() == 1) {\n                    targetLink = reverseLldpLink(nodes.get(0), sourceLink.getNode().getLldpElement(), sourceLink); \n                    LOG.debug(\"loadtopology: found lldp link using lldp rem sysname: '{}' and '{}'\", sourceLink, targetLink);\n                }\n            }\n            \n            if (targetLink == null) {\n                LOG.debug(\"loadtopology: cannot found target node for link: '{}'\", sourceLink);\n                continue;\n            }\n                \n            OnmsNode targetNode = targetLink.getNode();\n            Vertex target = getVertex(getVertexNamespace(), targetNode.getNodeId());\n            if (target == null) {\n                target = getVertex(targetNode);\n                addVertices(target);\n            }\n            combinedLinkDetails.add(new LldpLinkDetail(Math.min(sourceLink.getId(), targetLink.getId()) + \"|\" + Math.max(sourceLink.getId(), targetLink.getId()),\n                                                       source, sourceLink, target, targetLink));\n\n        }\n\n        for (LldpLinkDetail linkDetail : combinedLinkDetails) {\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), LLDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","commit_id":"3e4b6a1bd25e4ed8af2dbf9d515020e532b7e13b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getLldpLinks() {\n        List<LldpLink> allLinks = m_lldpLinkDao.findAll();\n        Set<LldpLinkDetail> combinedLinkDetails = new HashSet<LldpLinkDetail>();\n        Set<Integer> parsed = new HashSet<Integer>();\n        for (LldpLink sourceLink : allLinks) {\n            LOG.debug(\"loadtopology: parsing source link: \" + sourceLink);\n            if (parsed.contains(sourceLink.getId())) {\n                LOG.debug(\"loadtopology: already parsed: source link: \" + sourceLink);\n                continue;\n            }\n            parsed.add(sourceLink.getId());\n            OnmsNode sourceNode = sourceLink.getNode();\n            LldpElement sourceElement = sourceNode.getLldpElement();\n            LOG.debug(\"loadtopology: found source node: \" + sourceNode.getLabel());\n            Vertex source = getVertex(getVertexNamespace(), sourceNode.getNodeId());\n            if (source == null) {\n                LOG.debug(\"loadtopology: adding source node as vertex: \" + sourceNode.getLabel());\n                source = getVertex(sourceNode);\n                addVertices(source);\n            }\n\n            LldpLink targetLink = null;\n            for (LldpLink link : allLinks) {\n                LOG.debug(\"loadtopology: try target link: \" + sourceLink);\n                if (parsed.contains(link.getId())) {\n                    LOG.debug(\"loadtopology: already parsed: target link: \" + sourceLink);\n                    continue;\n                }\n                LldpElement element = link.getNode().getLldpElement();\n                //Compare the remote data to the targetNode element data\n                if (!sourceLink.getLldpRemChassisId().equals(element.getLldpChassisId()) || !link.getLldpRemChassisId().equals(sourceElement.getLldpChassisId())) \n                    continue;\n                boolean bool1 = sourceLink.getLldpRemPortId().equals(link.getLldpPortId()) && link.getLldpRemPortId().equals(sourceLink.getLldpPortId());\n                boolean bool2 = sourceLink.getLldpRemPortDescr().equals(link.getLldpPortDescr()) && link.getLldpRemPortDescr().equals(sourceLink.getLldpPortDescr());\n                boolean bool3 = sourceLink.getLldpRemPortIdSubType() == link.getLldpPortIdSubType() && link.getLldpRemPortIdSubType() == sourceLink.getLldpPortIdSubType();\n\n                if (bool1 && bool2 && bool3) {\n                    targetLink=link;\n                    parsed.add(targetLink.getId());\n                    LOG.debug(\"loadtopology: found target link: \" + targetLink);\n                    break;\n                }\n            }\n            \n            if (targetLink == null) {\n                final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsNode.class).addRestriction(new EqRestriction(\"sysName\", sourceLink.getLldpRemSysname()));\n                List<OnmsNode> nodes = m_nodeDao.findMatching(criteria);\n                if (nodes.size() == 1) {\n                    targetLink = reverseLldpLink(nodes.get(0), sourceLink.getNode().getLldpElement(), sourceLink); \n                    LOG.debug(\"loadtopology: found target link using sysname: \" + targetLink);\n                }\n            }\n            \n            if (targetLink == null) {\n                LOG.debug(\"loadtopology: cannot found target for link: \" + sourceLink);\n                continue;\n            }\n                \n            OnmsNode targetNode = targetLink.getNode();\n            Vertex target = getVertex(getVertexNamespace(), targetNode.getNodeId());\n            if (target == null) {\n                LOG.debug(\"loadtopology: adding target node as vertex: \" + targetNode.getLabel());\n                target = getVertex(targetNode);\n                addVertices(target);\n            }\n            combinedLinkDetails.add(new LldpLinkDetail(Math.min(sourceLink.getId(), targetLink.getId()) + \"|\" + Math.max(sourceLink.getId(), targetLink.getId()),\n                                                       source, sourceLink, target, targetLink));\n\n        }\n\n        for (LldpLinkDetail linkDetail : combinedLinkDetails) {\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), LLDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","id":9941,"modified_method":"private void getLldpLinks() {\n        List<LldpLink> allLinks = m_lldpLinkDao.findAll();\n        Set<LldpLinkDetail> combinedLinkDetails = new HashSet<LldpLinkDetail>();\n        Set<Integer> parsed = new HashSet<Integer>();\n        for (LldpLink sourceLink : allLinks) {\n            LOG.debug(\"loadtopology: parsing lldp link with id '{}' link '{}' \", sourceLink.getId(), sourceLink);\n            if (parsed.contains(sourceLink.getId())) {\n                LOG.debug(\"loadtopology: lldp link with id '{]' already parsed, skipping\", sourceLink.getId());\n                continue;\n            }\n            parsed.add(sourceLink.getId());\n            OnmsNode sourceNode = sourceLink.getNode();\n            LldpElement sourceElement = sourceNode.getLldpElement();\n            Vertex source = getVertex(getVertexNamespace(), sourceNode.getNodeId());\n            if (source == null) {\n                source = getVertex(sourceNode);\n                addVertices(source);\n            }\n\n            LldpLink targetLink = null;\n            for (LldpLink link : allLinks) {\n                LOG.debug(\"loadtopology: parsing lldp link with id '{}' link '{}' \", link.getId(), link);\n                if (parsed.contains(link.getId())) {\n                    LOG.debug(\"loadtopology: lldp link with id '{]' already parsed, skipping\", link.getId());\n                    continue;\n                }\n                LldpElement element = link.getNode().getLldpElement();\n                //Compare the remote data to the targetNode element data\n                if (!sourceLink.getLldpRemChassisId().equals(element.getLldpChassisId()) || !link.getLldpRemChassisId().equals(sourceElement.getLldpChassisId())) \n                    continue;\n                boolean bool1 = sourceLink.getLldpRemPortId().equals(link.getLldpPortId()) && link.getLldpRemPortId().equals(sourceLink.getLldpPortId());\n                boolean bool2 = sourceLink.getLldpRemPortDescr().equals(link.getLldpPortDescr()) && link.getLldpRemPortDescr().equals(sourceLink.getLldpPortDescr());\n                boolean bool3 = sourceLink.getLldpRemPortIdSubType() == link.getLldpPortIdSubType() && link.getLldpRemPortIdSubType() == sourceLink.getLldpPortIdSubType();\n\n                if (bool1 && bool2 && bool3) {\n                    targetLink=link;\n                    parsed.add(targetLink.getId());\n                    LOG.debug(\"loadtopology: found lldp mutual link: '{}' and '{}' \", sourceLink,targetLink);\n                    break;\n                }\n            }\n            \n            if (targetLink == null) {\n                final org.opennms.core.criteria.Criteria criteria = new org.opennms.core.criteria.Criteria(OnmsNode.class).addRestriction(new EqRestriction(\"sysName\", sourceLink.getLldpRemSysname()));\n                List<OnmsNode> nodes = m_nodeDao.findMatching(criteria);\n                if (nodes.size() == 1) {\n                    targetLink = reverseLldpLink(nodes.get(0), sourceLink.getNode().getLldpElement(), sourceLink); \n                    LOG.debug(\"loadtopology: found lldp link using lldp rem sysname: '{}' and '{}'\", sourceLink, targetLink);\n                }\n            }\n            \n            if (targetLink == null) {\n                LOG.debug(\"loadtopology: cannot found target node for link: '{}'\", sourceLink);\n                continue;\n            }\n                \n            OnmsNode targetNode = targetLink.getNode();\n            Vertex target = getVertex(getVertexNamespace(), targetNode.getNodeId());\n            if (target == null) {\n                target = getVertex(targetNode);\n                addVertices(target);\n            }\n            combinedLinkDetails.add(new LldpLinkDetail(Math.min(sourceLink.getId(), targetLink.getId()) + \"|\" + Math.max(sourceLink.getId(), targetLink.getId()),\n                                                       source, sourceLink, target, targetLink));\n\n        }\n\n        for (LldpLinkDetail linkDetail : combinedLinkDetails) {\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), LLDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","commit_id":"c531d68e35c9d8016350105d864e658412439e3d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    @Transactional\n    public void load(String filename) throws MalformedURLException, JAXBException {\n        if (filename != null) {\n            LOG.warn(\"Filename that was specified for linkd topology will be ignored: \" + filename + \", using \" + getConfigurationFile() + \" instead\");\n        }\n        try{\n            //TODO: change to one query from the database that will return all links plus elements joined\n            //This reset container is set in here for the demo, don't commit\n\n            resetContainer();\n\n            getLldpLinks();\n            getOspfLinks();\n            getIsIsLinks();\n            getBridgeLinks();\n            getCdpLinks();\n\n\n        } catch (Exception e){\n            LOG.debug(e.getStackTrace().toString());\n        }\n\n        LOG.debug(\"loadtopology: adding nodes without links: \" + isAddNodeWithoutLink());\n        if (isAddNodeWithoutLink()) {\n            addNodesWithoutLinks();\n        }\n\n        File configFile = new File(getConfigurationFile());\n        if (configFile.exists() && configFile.canRead()) {\n            LOG.debug(\"loadtopology: loading topology from configuration file: \" + getConfigurationFile());\n            WrappedGraph graph = getGraphFromFile(configFile);\n\n            // Add all groups to the topology\n            for (WrappedVertex eachVertexInFile: graph.m_vertices) {\n                if (eachVertexInFile.group) {\n                    LOG.debug(\"loadtopology: adding group to topology: \" + eachVertexInFile.id);\n                    if (eachVertexInFile.namespace == null) {\n                        eachVertexInFile.namespace = getVertexNamespace();\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Setting namespace on vertex to default: {}\", eachVertexInFile);\n                    }\n                    if (eachVertexInFile.id == null) {\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Invalid vertex unmarshalled from {}: {}\", getConfigurationFile(), eachVertexInFile);\n                    }\n                    AbstractVertex newGroupVertex = addGroup(eachVertexInFile.id, eachVertexInFile.iconKey, eachVertexInFile.label);\n                    newGroupVertex.setIpAddress(eachVertexInFile.ipAddr);\n                    newGroupVertex.setLocked(eachVertexInFile.locked);\n                    if (eachVertexInFile.nodeID != null) newGroupVertex.setNodeID(eachVertexInFile.nodeID);\n                    if (!newGroupVertex.equals(eachVertexInFile.parent)) newGroupVertex.setParent(eachVertexInFile.parent);\n                    newGroupVertex.setSelected(eachVertexInFile.selected);\n                    newGroupVertex.setStyleName(eachVertexInFile.styleName);\n                    newGroupVertex.setTooltipText(eachVertexInFile.tooltipText);\n                    if (eachVertexInFile.x != null) newGroupVertex.setX(eachVertexInFile.x);\n                    if (eachVertexInFile.y != null) newGroupVertex.setY(eachVertexInFile.y);\n                }\n            }\n            for (Vertex vertex: getVertices()) {\n                if (vertex.getParent() != null && !vertex.equals(vertex.getParent())) {\n                    LOG.debug(\"loadtopology: setting parent of \" + vertex + \" to \" + vertex.getParent());\n                    setParent(vertex, vertex.getParent());\n                }\n            }\n            // Add all children to the specific group\n            // Attention: We ignore all other attributes, they do not need to be merged!\n            for (WrappedVertex eachVertexInFile : graph.m_vertices) {\n                if (!eachVertexInFile.group && eachVertexInFile.parent != null) {\n                    final Vertex child = getVertex(eachVertexInFile);\n                    final Vertex parent = getVertex(eachVertexInFile.parent);\n                    if (child == null || parent == null) continue;\n                    LOG.debug(\"loadtopology: setting parent of \" + child + \" to \" + parent);\n                    if (!child.equals(parent)) setParent(child, parent);\n                }\n            }\n        } else {\n            LOG.debug(\"loadtopology: could not load topology configFile:\" + getConfigurationFile());\n        }\n        LOG.debug(\"Found \" + getGroups().size() + \" groups\");\n        LOG.debug(\"Found \" + getVerticesWithoutGroups().size() + \" vertices\");\n        LOG.debug(\"Found \" + getEdges().size() + \" edges\");\n\n\n\n    }","id":9942,"modified_method":"@Override\n    @Transactional\n    public void load(String filename) throws MalformedURLException, JAXBException {\n        if (filename != null) {\n            LOG.warn(\"Filename that was specified for linkd topology will be ignored: \" + filename + \", using \" + getConfigurationFile() + \" instead\");\n        }\n        try{\n            //TODO: change to one query from the database that will return all links plus elements joined\n            //This reset container is set in here for the demo, don't commit\n\n            resetContainer();\n        } catch (Exception e){\n            LOG.error(\"Exception reset Container: \"+e.getMessage(),e);\n        }\n\n        try{\n            getLldpLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Lldp link: \"+e.getMessage(),e);\n        }\n        try{\n            getOspfLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Ospf link: \"+e.getMessage(),e);\n        }\n        try{\n            getIsIsLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting IsIs link: \"+e.getMessage(),e);\n        }\n        try{\n            getBridgeLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Bridge link: \"+e.getMessage(),e);\n        }\n        try{\n            getCdpLinks();\n        } catch (Exception e){\n            LOG.error(\"Exception getting Cdp link: \"+e.getMessage(),e);\n        }\n\n        LOG.debug(\"loadtopology: adding nodes without links: \" + isAddNodeWithoutLink());\n        if (isAddNodeWithoutLink()) {\n            addNodesWithoutLinks();\n        }\n\n        File configFile = new File(getConfigurationFile());\n        if (configFile.exists() && configFile.canRead()) {\n            LOG.debug(\"loadtopology: loading topology from configuration file: \" + getConfigurationFile());\n            WrappedGraph graph = getGraphFromFile(configFile);\n\n            // Add all groups to the topology\n            for (WrappedVertex eachVertexInFile: graph.m_vertices) {\n                if (eachVertexInFile.group) {\n                    LOG.debug(\"loadtopology: adding group to topology: \" + eachVertexInFile.id);\n                    if (eachVertexInFile.namespace == null) {\n                        eachVertexInFile.namespace = getVertexNamespace();\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Setting namespace on vertex to default: {}\", eachVertexInFile);\n                    }\n                    if (eachVertexInFile.id == null) {\n                        LoggerFactory.getLogger(this.getClass()).warn(\"Invalid vertex unmarshalled from {}: {}\", getConfigurationFile(), eachVertexInFile);\n                    }\n                    AbstractVertex newGroupVertex = addGroup(eachVertexInFile.id, eachVertexInFile.iconKey, eachVertexInFile.label);\n                    newGroupVertex.setIpAddress(eachVertexInFile.ipAddr);\n                    newGroupVertex.setLocked(eachVertexInFile.locked);\n                    if (eachVertexInFile.nodeID != null) newGroupVertex.setNodeID(eachVertexInFile.nodeID);\n                    if (!newGroupVertex.equals(eachVertexInFile.parent)) newGroupVertex.setParent(eachVertexInFile.parent);\n                    newGroupVertex.setSelected(eachVertexInFile.selected);\n                    newGroupVertex.setStyleName(eachVertexInFile.styleName);\n                    newGroupVertex.setTooltipText(eachVertexInFile.tooltipText);\n                    if (eachVertexInFile.x != null) newGroupVertex.setX(eachVertexInFile.x);\n                    if (eachVertexInFile.y != null) newGroupVertex.setY(eachVertexInFile.y);\n                }\n            }\n            for (Vertex vertex: getVertices()) {\n                if (vertex.getParent() != null && !vertex.equals(vertex.getParent())) {\n                    LOG.debug(\"loadtopology: setting parent of \" + vertex + \" to \" + vertex.getParent());\n                    setParent(vertex, vertex.getParent());\n                }\n            }\n            // Add all children to the specific group\n            // Attention: We ignore all other attributes, they do not need to be merged!\n            for (WrappedVertex eachVertexInFile : graph.m_vertices) {\n                if (!eachVertexInFile.group && eachVertexInFile.parent != null) {\n                    final Vertex child = getVertex(eachVertexInFile);\n                    final Vertex parent = getVertex(eachVertexInFile.parent);\n                    if (child == null || parent == null) continue;\n                    LOG.debug(\"loadtopology: setting parent of \" + child + \" to \" + parent);\n                    if (!child.equals(parent)) setParent(child, parent);\n                }\n            }\n        } else {\n            LOG.debug(\"loadtopology: could not load topology configFile:\" + getConfigurationFile());\n        }\n        LOG.debug(\"Found \" + getGroups().size() + \" groups\");\n        LOG.debug(\"Found \" + getVerticesWithoutGroups().size() + \" vertices\");\n        LOG.debug(\"Found \" + getEdges().size() + \" edges\");\n\n\n\n    }","commit_id":"c531d68e35c9d8016350105d864e658412439e3d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getIsIsLinks(){\n        List<Object[]> isislinks = m_isisLinkDao.getLinksForTopology();\n\n        for (Object[] linkObj : isislinks) {\n            Integer link1Id = (Integer) linkObj[1];\n            Integer link1Nodeid = (Integer) linkObj[2];\n            Integer link1IfIndex = (Integer) linkObj[3];\n            Integer link2Id = (Integer) linkObj[4];\n            Integer link2Nodeid = (Integer) linkObj[5];\n            Integer link2IfIndex = (Integer) linkObj[6];\n            IsIsLinkDetail linkDetail = new IsIsLinkDetail(\n                    Math.min(link1Id, link2Id) + \"|\" + Math.max(link1Id, link2Id),\n                    getVertex(m_nodeDao.get(link1Nodeid)),\n                    link1Id,\n                    link1IfIndex,\n                    getVertex(m_nodeDao.get(link2Nodeid)),\n                    link2Id,\n                    link2IfIndex\n            );\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), ISIS_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","id":9943,"modified_method":"private void getIsIsLinks(){\n        List<Object[]> isislinks = m_isisLinkDao.getLinksForTopology();\n\n        for (Object[] linkObj : isislinks) {\n            LOG.debug(\"loadtopology: adding isis link: '{}'\", linkObj );\n            Integer link1Id = (Integer) linkObj[1];\n            Integer link1Nodeid = (Integer) linkObj[2];\n            Integer link1IfIndex = (Integer) linkObj[3];\n            Integer link2Id = (Integer) linkObj[4];\n            Integer link2Nodeid = (Integer) linkObj[5];\n            Integer link2IfIndex = (Integer) linkObj[6];\n            IsIsLinkDetail linkDetail = new IsIsLinkDetail(\n                    Math.min(link1Id, link2Id) + \"|\" + Math.max(link1Id, link2Id),\n                    getVertex(m_nodeDao.get(link1Nodeid)),\n                    link1Id,\n                    link1IfIndex,\n                    getVertex(m_nodeDao.get(link2Nodeid)),\n                    link2Id,\n                    link2IfIndex\n            );\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), ISIS_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n        }\n    }","commit_id":"c531d68e35c9d8016350105d864e658412439e3d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void getCdpLinks() {\n        List<CdpTopologyLink> cdpLinks = m_cdpLinkDao.findLinksForTopology();\n\n        for (CdpTopologyLink link : cdpLinks) {\n            String id = Math.min(link.getSourceId(), link.getTargetId()) + \"|\" + Math.max(link.getSourceId(), link.getTargetId());\n            CdpLinkDetail linkDetail = new CdpLinkDetail(id,\n                    getVertex(m_nodeDao.get(link.getSrcNodeId())),\n                    link.getSrcIfIndex(),\n                    link.getSrcIfName(),\n                    getVertex(m_nodeDao.get(link.getTargetNodeId())),\n                    link.getTargetIfName());\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), CDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n\n        }\n    }","id":9944,"modified_method":"private void getCdpLinks() {\n        List<CdpTopologyLink> cdpLinks = m_cdpLinkDao.findLinksForTopology();\n\n        for (CdpTopologyLink link : cdpLinks) {\n            LOG.debug(\"loadtopology: adding cdp link: '{}'\", link );\n            String id = Math.min(link.getSourceId(), link.getTargetId()) + \"|\" + Math.max(link.getSourceId(), link.getTargetId());\n            CdpLinkDetail linkDetail = new CdpLinkDetail(id,\n                    getVertex(m_nodeDao.get(link.getSrcNodeId())),\n                    link.getSrcIfIndex(),\n                    link.getSrcIfName(),\n                    getVertex(m_nodeDao.get(link.getTargetNodeId())),\n                    link.getTargetIfName());\n\n            AbstractEdge edge = connectVertices(linkDetail.getId(), linkDetail.getSource(), linkDetail.getTarget(), CDP_EDGE_NAMESPACE);\n            edge.setTooltipText(getEdgeTooltipText(linkDetail));\n\n        }\n    }","commit_id":"c531d68e35c9d8016350105d864e658412439e3d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private LldpLink reverseLldpLink(OnmsNode sourcenode, LldpElement element, LldpLink link) {\n        LldpLink reverseLink = new LldpLink();\n        reverseLink.setNode(sourcenode);\n        \n        reverseLink.setLldpLocalPortNum(0);\n        reverseLink.setLldpPortId(link.getLldpRemPortId());\n        reverseLink.setLldpPortIdSubType(link.getLldpRemPortIdSubType());\n        if (link.getLldpRemPortIdSubType() == LldpPortIdSubType.LLDP_PORTID_SUBTYPE_LOCAL) {\n            try {\n                Integer remIfIndex = Integer.getInteger(link.getLldpRemPortId());\n                reverseLink.setLldpPortIfindex(remIfIndex);\n            } catch (Exception e) {\n            }\n        }\n\n        reverseLink.setLldpPortDescr(link.getLldpRemPortDescr());\n        reverseLink.setLldpRemChassisId(element.getLldpChassisId());\n        reverseLink.setLldpRemChassisIdSubType(element.getLldpChassisIdSubType());\n        reverseLink.setLldpRemSysname(element.getLldpSysname());\n        \n        reverseLink.setLldpRemPortId(link.getLldpPortId());\n        reverseLink.setLldpRemPortIdSubType(link.getLldpPortIdSubType());\n        reverseLink.setLldpRemPortDescr(link.getLldpPortDescr());\n        \n        reverseLink.setLldpLinkCreateTime(link.getLldpLinkCreateTime());\n        reverseLink.setLldpLinkLastPollTime(link.getLldpLinkLastPollTime());\n        \n        return reverseLink;\n    }","id":9945,"modified_method":"private LldpLink reverseLldpLink(OnmsNode sourcenode, LldpElement element, LldpLink link) {\n        LldpLink reverseLink = new LldpLink();\n        reverseLink.setId(-link.getId());\n        reverseLink.setNode(sourcenode);\n        \n        reverseLink.setLldpLocalPortNum(0);\n        reverseLink.setLldpPortId(link.getLldpRemPortId());\n        reverseLink.setLldpPortIdSubType(link.getLldpRemPortIdSubType());\n        reverseLink.setLldpPortDescr(link.getLldpRemPortDescr());\n        if (link.getLldpRemPortIdSubType() == LldpPortIdSubType.LLDP_PORTID_SUBTYPE_LOCAL) {\n            try {\n                reverseLink.setLldpPortIfindex(Integer.getInteger(link.getLldpRemPortId()));\n            } catch (Exception e) {\n                LOG.debug(\"reverseLldpLink: cannot create ifindex from  LldpRemPortId '{}'\", link.getLldpRemPortId());\n            }\n        }\n\n        reverseLink.setLldpRemChassisId(element.getLldpChassisId());\n        reverseLink.setLldpRemChassisIdSubType(element.getLldpChassisIdSubType());\n        reverseLink.setLldpRemSysname(element.getLldpSysname());\n        \n        reverseLink.setLldpRemPortId(link.getLldpPortId());\n        reverseLink.setLldpRemPortIdSubType(link.getLldpPortIdSubType());\n        reverseLink.setLldpRemPortDescr(link.getLldpPortDescr());\n        \n        reverseLink.setLldpLinkCreateTime(link.getLldpLinkCreateTime());\n        reverseLink.setLldpLinkLastPollTime(link.getLldpLinkLastPollTime());\n        \n        return reverseLink;\n    }","commit_id":"c531d68e35c9d8016350105d864e658412439e3d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * get transformed document\n   * @param context\n   * @return transformed document\n   */\n  public static String getTransformedDocument(ServletContext context,\n      HelpManager helpManager, Resource resource)\n  {\n    \n\tLong now = new Long((new Date()).getTime());\n\t  \n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"getTransformedDocument(ServletContext \" + context\n          + \", HelpManager \" + helpManager + \"String \" + resource.getDocId() + \")\");\n    }\n    \n    // test if resource is cached\n    if (resource.getTstamp() != null){\n      if ((now.longValue() - resource.getTstamp().longValue()) < helpManager.getRestConfiguration().getCacheInterval()){\n        if (LOG.isDebugEnabled()){\n          LOG.debug(\"retrieving document: \" + resource.getDocId() + \" from cache\");                \n        }\n        return resource.getSource();\n      }\n    }\n        \n    URL url = null;\n    String transformedString = null;\n    try\n    {\n      url = new URL(helpManager.getStaticRestUrl() + resource.getDocId() + \"?domain=\"\n          + helpManager.getRestConfiguration().getRestDomain());\n      URLConnection urlConnection = url.openConnection();\n\n      String basicAuthUserPass = helpManager.getRestConfiguration()\n          .getRestCredentials();\n      String encoding = new BASE64Encoder()\n          .encode(basicAuthUserPass.getBytes());\n\n      urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n\n      StringBuffer sBuffer = new StringBuffer();\n\n      BufferedReader br = new BufferedReader(new InputStreamReader(\n          urlConnection.getInputStream()), 512);\n      int readReturn = 0;\n      char[] cbuf = new char[512];\n      while ((readReturn = br.read(cbuf, 0, 512)) != -1)\n      {\n        sBuffer.append(cbuf, 0, readReturn);\n      }\n\n      Document transformedDocument = getTransformedDocument(context, sBuffer);\n      transformedString = serializeDocument(transformedDocument);            \n    }\n    catch (MalformedURLException e)\n    {\n      LOG.error(\"Malformed URL in REST document: \" + url.getPath());\n    }\n    catch (IOException e)\n    {\n      LOG.error(\"Could not open connection to REST document: \" + url.getPath());\n    }\n        \n    resource.setSource(transformedString);\n    resource.setTstamp(now);\n    helpManager.storeResource(resource);\n    \n    return transformedString;\n  }","id":9946,"modified_method":"/**\n   * get transformed document\n   * @param context\n   * @return transformed document\n   */\n  public static String getTransformedDocument(ServletContext context,\n      HelpManager helpManager, Resource resource)\n  {\n    \n\tLong now = new Long((new Date()).getTime());\n\t  \n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"getTransformedDocument(ServletContext \" + context\n          + \", HelpManager \" + helpManager + \"String \" + resource.getDocId() + \")\");\n    }\n    \n    // test if resource is cached\n    if (resource.getTstamp() != null){\n      if ((now.longValue() - resource.getTstamp().longValue()) < helpManager.getRestConfiguration().getCacheInterval()){\n        if (LOG.isDebugEnabled()){\n          LOG.debug(\"retrieving document: \" + resource.getDocId() + \" from cache\");                \n        }\n        return resource.getSource();\n      }\n    }\n        \n    URL url = null;\n    String transformedString = null;\n    try\n    {\n      url = new URL(helpManager.getRestConfiguration().getRestUrlInDomain() + resource.getDocId() + \"?domain=\"\n          + helpManager.getRestConfiguration().getRestDomain());\n      URLConnection urlConnection = url.openConnection();\n\n      String basicAuthUserPass = helpManager.getRestConfiguration()\n          .getRestCredentials();\n      String encoding = new BASE64Encoder()\n          .encode(basicAuthUserPass.getBytes());\n\n      urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n\n      StringBuffer sBuffer = new StringBuffer();\n\n      BufferedReader br = new BufferedReader(new InputStreamReader(\n          urlConnection.getInputStream()), 512);\n      int readReturn = 0;\n      char[] cbuf = new char[512];\n      while ((readReturn = br.read(cbuf, 0, 512)) != -1)\n      {\n        sBuffer.append(cbuf, 0, readReturn);\n      }\n\n      Document transformedDocument = getTransformedDocument(context, sBuffer);\n      transformedString = serializeDocument(transformedDocument);            \n    }\n    catch (MalformedURLException e)\n    {\n      LOG.error(\"Malformed URL in REST document: \" + url.getPath());\n    }\n    catch (IOException e)\n    {\n      LOG.error(\"Could not open connection to REST document: \" + url.getPath());\n    }\n        \n    resource.setSource(transformedString);\n    resource.setTstamp(now);\n    helpManager.storeResource(resource);\n    \n    return transformedString;\n  }","commit_id":"356c4f09588ce2c3169b5398523063fef279bd0f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * @param htmlDocument\n   * @return document with css link\n   */\n  private static void addLinkToCss(Document htmlDocument)\n  {\n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"addLinkToCss(Document \" + htmlDocument + \")\");\n    }\n        \n    String skinRoot = ServerConfigurationService.getString(\"skin.repo\",\n        \"/library/skin\");\n    String skin = ServerConfigurationService.getString(\"skin.default\",\n        \"default\");\n    NodeList nodes = htmlDocument.getElementsByTagName(\"head\");\n    Node node = nodes.item(0);\n    \n    Element linkNodeBase = htmlDocument.createElement(\"link\");\n    linkNodeBase.setAttribute(\"href\", skinRoot + \"/tool_base.css\");\n    linkNodeBase.setAttribute(\"rel\", \"stylesheet\");\n    linkNodeBase.setAttribute(\"content-type\", \"text/css\");\n    \n    Element linkNodeDefault = htmlDocument.createElement(\"link\");\n    linkNodeDefault.setAttribute(\"href\", skinRoot + \"/\" + skin + \"/tool.css\");\n    linkNodeDefault.setAttribute(\"rel\", \"stylesheet\");\n    linkNodeDefault.setAttribute(\"content-type\", \"text/css\");\n    \n    if (node.getFirstChild() == null\n        || !(node.getFirstChild().getNodeName().equals(\"link\")))\n    {\n      node.appendChild(linkNodeBase);\n      node.appendChild(linkNodeDefault);\n    }    \n  }","id":9947,"modified_method":"/**\n   * @param htmlDocument\n   * @return document with css link\n   */\n  private static void addLinkToCss(Document htmlDocument)\n  {\n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"addLinkToCss(Document \" + htmlDocument + \")\");\n    }\n        \n    String skinRoot = ServerConfigurationService.getString(\"skin.repo\",\n        \"/library/skin\");\n    String skin = ServerConfigurationService.getString(\"skin.default\",\n        \"default\");\n    \n    NodeList nodes = htmlDocument.getElementsByTagName(\"head\");\n    Node node = nodes.item(0);\n        \n    Element linkNodeBase = htmlDocument.createElement(\"link\");\n    linkNodeBase.setAttribute(\"href\", skinRoot + \"/tool_base.css\");\n    linkNodeBase.setAttribute(\"rel\", \"stylesheet\");\n    linkNodeBase.setAttribute(\"content-type\", \"text/css\");\n    \n    Element linkNodeDefault = htmlDocument.createElement(\"link\");\n    linkNodeDefault.setAttribute(\"href\", skinRoot + \"/\" + skin + \"/tool.css\");\n    linkNodeDefault.setAttribute(\"rel\", \"stylesheet\");\n    linkNodeDefault.setAttribute(\"content-type\", \"text/css\");\n    \n    Element linkNodeREST = htmlDocument.createElement(\"link\");\n    linkNodeREST.setAttribute(\"href\", \"css/REST.css\");\n    linkNodeREST.setAttribute(\"rel\", \"stylesheet\");\n    linkNodeREST.setAttribute(\"content-type\", \"text/css\");\n    \n    if (node.getFirstChild() == null\n        || !(node.getFirstChild().getNodeName().equals(\"link\")))\n    {\n      //node.appendChild(linkNodeBase);\n      //node.appendChild(linkNodeDefault);\n      node.appendChild(linkNodeREST);\n    }    \n  }","commit_id":"356c4f09588ce2c3169b5398523063fef279bd0f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * synchronize initialization of caching XSL\n   * @param context\n   */\n  public static void initializeXsl(ServletContext context)\n  {\n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"initializeXsl(ServletContext \" + context + \")\");\n    }\n    \n    if (XSL_INITIALIZED.booleanValue())\n    {\n      return;\n    }\n    else\n    {\n      synchronized (XSL_INITIALIZED)\n      {\n        if (!XSL_INITIALIZED.booleanValue())\n        {\n          //read in and parse xsl\n          InputStream iStream = null;\n          try\n          {\n            iStream = context.getResourceAsStream(XML_TO_HTML_XSL);\n\n            DocumentBuilderFactory builderFactory = DocumentBuilderFactory\n                .newInstance();\n            builderFactory.setNamespaceAware(true);\n            DocumentBuilder documentBuilder = builderFactory\n                .newDocumentBuilder();\n            xslDocument = documentBuilder.parse(iStream);\n          }\n          catch (ParserConfigurationException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n          catch (IOException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n          catch (SAXException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n          try\n          {\n            iStream.close();\n          }\n          catch (IOException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n\n          XSL_INITIALIZED = Boolean.TRUE;\n        }\n      }\n    }\n  }","id":9948,"modified_method":"/**\n   * synchronize initialization of caching XSL\n   * @param context\n   */\n  public static void initializeXsl(ServletContext context)\n  {\n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"initializeXsl(ServletContext \" + context + \")\");\n    }\n    \n    if (XSL_INITIALIZED.booleanValue())\n    {\n      return;\n    }\n    else\n    {\n      synchronized (XSL_INITIALIZED)\n      {\n        if (!XSL_INITIALIZED.booleanValue())\n        {\n          //read in and parse xsl\n          InputStream iStreamPreprocess = null;\n          InputStream iStreamAllInOne = null;\n          try\n          {\n            iStreamPreprocess = context.getResourceAsStream(XML_PREPROCESS_XSL);\n            iStreamAllInOne = context.getResourceAsStream(XML_KB_XSL);           \n            \n            DocumentBuilderFactory builderFactory = DocumentBuilderFactory\n                .newInstance();\n            builderFactory.setNamespaceAware(true);\n            DocumentBuilder documentBuilder = builderFactory\n                .newDocumentBuilder();\n            xslDocumentPreprocess = documentBuilder.parse(iStreamPreprocess);\n            xslDocumentAllInOne = documentBuilder.parse(iStreamAllInOne);            \n          }\n          catch (ParserConfigurationException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n          catch (IOException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n          catch (SAXException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n          try\n          {\n            iStreamPreprocess.close();\n            iStreamAllInOne.close();\n          }\n          catch (IOException e)\n          {\n            LOG.error(e.getMessage(), e);\n          }\n\n          XSL_INITIALIZED = Boolean.TRUE;\n        }\n      }\n    }\n  }","commit_id":"356c4f09588ce2c3169b5398523063fef279bd0f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * get transformed document\n   * @param servlet context\n   * @param sBuffer\n   * @return\n   */\n  private static Document getTransformedDocument(ServletContext context,\n      StringBuffer sBuffer)\n  {\n\n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"getTransformedDocument(ServletContext \" + context\n          + \", StringBuffer \" + sBuffer + \")\");\n    }\n\n    initializeXsl(context);\n\n    Document htmlDocument = null;\n    try\n    {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      StringReader sReader = new StringReader(sBuffer.toString());\n      InputSource is = new org.xml.sax.InputSource(sReader);\n      Document xmlDocument = builder.parse(is);\n      \n      // test for kb error condition\n      if (xmlDocument.getElementsByTagName(\"kberror\").getLength() > 0){        \n        htmlDocument = createErrorDocument();\n      }\n      else{\n        htmlDocument = transformDocument(xmlDocument, xslDocument);  \n      }      \n      addLinkToCss(htmlDocument);\n\n    }\n    catch (ParserConfigurationException e)\n    {\n      LOG.error(e.getMessage(), e);\n    }\n    catch (IOException e)\n    {\n      LOG.error(e.getMessage(), e);\n    }\n    catch (SAXException e)\n    {\n      LOG.error(e.getMessage(), e);\n    }\n    return htmlDocument;\n  }","id":9949,"modified_method":"/**\n   * get transformed document\n   * @param servlet context\n   * @param sBuffer\n   * @return\n   */\n  private static Document getTransformedDocument(ServletContext context,\n      StringBuffer sBuffer)\n  {\n\n    if (LOG.isDebugEnabled())\n    {\n      LOG.debug(\"getTransformedDocument(ServletContext \" + context\n          + \", StringBuffer \" + sBuffer + \")\");\n    }\n\n    initializeXsl(context);\n\n    Document result = null;\n    try\n    {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      StringReader sReader = new StringReader(sBuffer.toString());\n      InputSource is = new org.xml.sax.InputSource(sReader);\n      Document xmlDocument = builder.parse(is);\n      \n      // test for kb error condition\n      if (xmlDocument.getElementsByTagName(\"kberror\").getLength() > 0){        \n        result = createErrorDocument();\n      }\n      else{\n        /** debugging\n        OutputFormat format = new OutputFormat(xmlDocument);\n        XMLSerializer output = new XMLSerializer(System.out, format);\n        output.serialize(xmlDocument);\n        */\n        \n        result = transformDocument(xmlDocument, xslDocumentPreprocess);  \n        result = transformDocument(result, xslDocumentAllInOne);\n      } \n      \n      /** debugging  \n      OutputFormat format = new OutputFormat(result);\n      XMLSerializer output = new XMLSerializer(System.out, format);\n      output.serialize(result);\n      */\n           \n      addLinkToCss(result);\n\n    }\n    catch (ParserConfigurationException e)\n    {\n      LOG.error(e.getMessage(), e);\n    }\n    catch (IOException e)\n    {\n      LOG.error(e.getMessage(), e);\n    }\n    catch (SAXException e)\n    {\n      LOG.error(e.getMessage(), e);\n    }\n    return result;\n  }","commit_id":"356c4f09588ce2c3169b5398523063fef279bd0f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void setRuntimeData (ChannelRuntimeData rd) throws PortalException\n    {\n      runtimeData = rd;\n\n      // If the user hasn't clicked on a tab, get persisted active tab\n      if (activeTab.equals(\"none\"))\n        activeTab = getActiveTab();\n\n      action = runtimeData.getParameter(\"action\");\n\n      if (action != null)\n      {\n        // Select tab\n        if (action.equals(\"selectTab\"))\n          activeTab = runtimeData.getParameter(\"activeTab\");\n        // Set active tab\n        else if (action.equals(\"setActiveTab\"))\n        {\n          try\n          {\n            setActiveTab(activeTab);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageSetActiveTab;\n          }\n        }\n        // Rename tab\n        else if (action.equals(\"renameTab\"))\n        {\n          String tabId = runtimeData.getParameter(\"elementID\");\n          String tabName = runtimeData.getParameter(\"tabName\");\n\n          System.out.println(tabId);\n          System.out.println(tabName);\n\n          try\n          {\n            renameTab(tabId, tabName);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageRenameTab;\n          }\n        }\n        // Move tab\n        else if (action.equals(\"moveTab\"))\n        {\n          String methodAndID = runtimeData.getParameter(\"method_ID\");\n          String tabFromId = runtimeData.getParameter(\"elementID\");\n          int indexOf_ = methodAndID.indexOf(\"_\");\n          String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n          String tabToId = methodAndID.substring(indexOf_ + 1);\n\n          try\n          {\n            moveTab(tabFromId, method, tabToId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveTab;\n          }\n        }\n        // Add tab\n        else if (action.equals(\"addTab\"))\n        {\n          String tabName = runtimeData.getParameter(\"tabName\");\n          String methodAndID = runtimeData.getParameter(\"method_ID\");\n          int indexOf_ = methodAndID.indexOf(\"_\");\n          String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n          String tabToId = methodAndID.substring(indexOf_ + 1);\n\n          try\n          {\n            addTab(tabName, method, tabToId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageAddTab;\n          }\n        }\n        // Delete tab\n        else if (action.equals(\"deleteTab\"))\n        {\n          String tabId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(tabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteTab;\n          }\n        }\n        // Select column\n        else if (action.equals(\"selectColumn\"))\n          elementID = runtimeData.getParameter(\"elementID\");\n        // Move column\n        else if (action.equals(\"moveColumn\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move column here\n        else if (action.equals(\"moveColumnHere\"))\n        {\n          String method = runtimeData.getParameter(\"method\");\n          String destinationId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            moveColumn(elementID, method, destinationId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveColumn;\n          }\n        }\n        // Delete column\n        else if (action.equals(\"deleteColumn\"))\n        {\n          String columnId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(columnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteColumn;\n          }\n        }\n        // Select channel\n        else if (action.equals(\"selectChannel\"))\n        {\n          elementID = runtimeData.getParameter(\"elementID\");\n        }\n       }\n      else\n        action = \"none\";\n    }","id":9950,"modified_method":"public void setRuntimeData (ChannelRuntimeData rd) throws PortalException\n    {\n      runtimeData = rd;\n\n      // If the user hasn't clicked on a tab, get persisted active tab\n      if (activeTab.equals(\"none\"))\n        activeTab = getActiveTab();\n\n      action = runtimeData.getParameter(\"action\");\n\n      if (action != null)\n      {\n        // Select tab\n        if (action.equals(\"selectTab\"))\n          activeTab = runtimeData.getParameter(\"activeTab\");\n        // Set active tab\n        else if (action.equals(\"setActiveTab\"))\n        {\n          try\n          {\n            setActiveTab(activeTab);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageSetActiveTab;\n          }\n        }\n        // Rename tab\n        else if (action.equals(\"renameTab\"))\n        {\n          String tabId = runtimeData.getParameter(\"elementID\");\n          String tabName = runtimeData.getParameter(\"tabName\");\n\n          try\n          {\n            renameTab(tabId, tabName);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageRenameTab;\n          }\n        }\n        // Move tab\n        else if (action.equals(\"moveTab\"))\n        {\n          String methodAndID = runtimeData.getParameter(\"method_ID\");\n          String sourceTabId = runtimeData.getParameter(\"elementID\");\n          int indexOf_ = methodAndID.indexOf(\"_\");\n          String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n          String destinationTabId = methodAndID.substring(indexOf_ + 1);\n\n          try\n          {\n            moveTab(sourceTabId, method, destinationTabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveTab;\n          }\n        }\n        // Add tab\n        else if (action.equals(\"addTab\"))\n        {\n          String tabName = runtimeData.getParameter(\"tabName\");\n          String methodAndID = runtimeData.getParameter(\"method_ID\");\n          int indexOf_ = methodAndID.indexOf(\"_\");\n          String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n          String destinationTabId = methodAndID.substring(indexOf_ + 1);\n\n          try\n          {\n            addFolder(tabName, method, destinationTabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageAddTab;\n          }\n        }\n        // Delete tab\n        else if (action.equals(\"deleteTab\"))\n        {\n          String tabId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(tabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteTab;\n          }\n        }\n        // Select column\n        else if (action.equals(\"selectColumn\"))\n          elementID = runtimeData.getParameter(\"elementID\");\n        // Change column width(s)\n        else if (action.equals(\"columnWidth\"))\n        {\n          HashMap columnWidths = new HashMap();\n          Enumeration eParams = runtimeData.getParameterNames();\n          while (eParams.hasMoreElements())\n          {\n            String param = (String)eParams.nextElement();\n            String prefix = \"columnWidth_\";\n\n            if (param.startsWith(prefix))\n            {\n              String folderId = param.substring(prefix.length());\n              String newWidth = runtimeData.getParameter(prefix + folderId);\n              columnWidths.put(folderId, newWidth);\n            }\n          }\n\n          try\n          {\n            changeColumnWidths(columnWidths);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageChangeColumnWidths;\n          }\n        }\n        // Move column\n        else if (action.equals(\"moveColumn\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move column here\n        else if (action.equals(\"moveColumnHere\"))\n        {\n          String method = runtimeData.getParameter(\"method\");\n          String destinationId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            moveColumn(elementID, method, destinationId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveColumn;\n          }\n        }\n        // New column\n        else if (action.equals(\"newColumn\"))\n        {\n          String columnName = \"\";\n          String method = runtimeData.getParameter(\"method\");\n          elementID = runtimeData.getParameter(\"elementID\");\n          String destinationColumnId = elementID;\n\n          try\n          {\n            addFolder(columnName, method, destinationColumnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageNewColumn;\n          }\n        }\n        // Add column\n        else if (action.equals(\"addColumn\"))\n        {\n          // Currently not implemented...\n          // We need to assign widths to columns.\n          // The action addColumn isn't in the stylesheet yet.\n        }\n        // Delete column\n        else if (action.equals(\"deleteColumn\"))\n        {\n          String columnId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(columnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteColumn;\n          }\n        }\n        // Select channel\n        else if (action.equals(\"selectChannel\"))\n        {\n          elementID = runtimeData.getParameter(\"elementID\");\n        }\n        // Move channel\n        else if (action.equals(\"moveChannel\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move channel here\n        else if (action.equals(\"moveChannelHere\"))\n        {\n          String method = runtimeData.getParameter(\"method\");\n          String destinationId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            moveChannel(elementID, method, destinationId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveChannel;\n          }\n        }\n        // Delete channel\n        else if (action.equals(\"deleteChannel\"))\n        {\n          String channelId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(channelId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteChannel;\n          }\n        }\n       }\n      else\n        action = \"none\";\n    }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void moveColumn(String sourceId, String method, String destinationId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n    Document doc = layout.getOwnerDocument();\n\n    Element source = userLayout.getElementById(sourceId);\n    Element destination = userLayout.getElementById(destinationId);\n    Element sourceColumn = source;\n    Element destinationColumn = destination;\n\n    // Check if source is a tab (its parent is the layout element)\n    boolean sourceIsATab = source.getParentNode().getNodeName().equals(\"layout\");\n\n    // If source is a tab, create a column, move the tab's children channels to this column,\n    // and use this new column as the source\n    if (sourceIsATab)\n    {\n      sourceColumn = doc.createElement(\"folder\");\n      sourceColumn.setAttribute(\"name\", \"\");\n      sourceColumn.setAttribute(\"ID\", String.valueOf(GenericPortalBean.getUserLayoutStore().getNextStructFolderId(staticData.getPerson().getID())));\n      sourceColumn.setAttribute(\"type\", \"regular\");\n      sourceColumn.setAttribute(\"hidden\", \"false\");\n      sourceColumn.setAttribute(\"unremovable\", \"false\");\n      sourceColumn.setAttribute(\"immutable\", \"false\");\n\n      NodeList channels = source.getElementsByTagName(\"channel\");\n      int numChannels = channels.getLength();\n      for (int nodeIndex = 0; nodeIndex < numChannels; nodeIndex++)\n      {\n        Node channel = channels.item(0); // The index is 0 because after each move, the channel positions move up a notch\n        boolean moveSuccessful = context.getUserLayoutManager().moveNode(channel, sourceColumn, null);\n        // Need to deal with case when move isn't successful!!!\n      }\n\n      source.appendChild(sourceColumn);\n    }\n\n    // Check if destination is a tab (its parent is the layout element)\n    boolean destinationIsATab = destination.getParentNode().getNodeName().equals(\"layout\");\n\n    // If destination is a tab, create a column, move the tab's children channels to this column,\n    // and use this new column as the destination\n    if (destinationIsATab)\n    {\n      destinationColumn = doc.createElement(\"folder\");\n      destinationColumn.setAttribute(\"name\", \"\");\n      destinationColumn.setAttribute(\"ID\", String.valueOf(GenericPortalBean.getUserLayoutStore().getNextStructFolderId(staticData.getPerson().getID())));\n      destinationColumn.setAttribute(\"type\", \"regular\");\n      destinationColumn.setAttribute(\"hidden\", \"false\");\n      destinationColumn.setAttribute(\"unremovable\", \"false\");\n      destinationColumn.setAttribute(\"immutable\", \"false\");\n\n      NodeList channels = destination.getElementsByTagName(\"channel\");\n      int numChannels = channels.getLength();\n      for (int nodeIndex = 0; nodeIndex < numChannels; nodeIndex++)\n      {\n        Node channel = channels.item(0); // The index is 0 because after each move, the channel positions move up a notch\n        boolean moveSuccessful = context.getUserLayoutManager().moveNode(channel, destinationColumn, null);\n        // Need to deal with case when move isn't successful!!!\n      }\n\n      destination.appendChild(destinationColumn);\n    }\n\n    // Move the source column before the destination column or at the end\n    Node targetTab = destinationColumn.getParentNode();\n    Node siblingColumn = method.equals(\"insertBefore\") ? destinationColumn : null;\n    context.getUserLayoutManager().moveNode(sourceColumn, targetTab, siblingColumn);\n\n    // Delete the source column from its tab\n    //sourceColumn.getParentNode().removeChild(sourceColumn);\n\n    // And insert before the destination column or at the end\n    //if (method.equals(\"insertBefore\"))\n    //  destinationColumn.getParentNode().insertBefore(sourceColumn, destinationColumn);\n    //else // method equals \"appendAfter\"\n    //  destinationColumn.getParentNode().appendChild(sourceColumn);\n\n    saveLayout();\n  }","id":9951,"modified_method":"/**\n   * Moves a column from one position in the layout to another.  Before the move is performed,\n   * a check is done to see whether the source and/or destination elements are tabs.  If either\n   * is a tab, a new column is inserted between it and the channels that it contains before the\n   * move is carried out.\n   * @param sourceId the column to move (may actually be a tab)\n   * @param method either <code>insertBefore<\/code> or <code>appendAfter<\/code>\n   * @param destinationId the column to insert the new column before or append after (may actually be a tab)\n   * @throws Exception\n   */\n  private final void moveColumn(String sourceId, String method, String destinationId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n    Document doc = layout.getOwnerDocument();\n\n    Element source = userLayout.getElementById(sourceId);\n    Element destination = userLayout.getElementById(destinationId);\n    Element sourceColumn = source;\n    Element destinationColumn = destination;\n\n    // If source is a tab, create a column, move the tab's children channels to this column,\n    // and use this new column as the source\n    if (isTab(source))\n    {\n      sourceColumn = createFolder(\"\");\n      NodeList channels = source.getElementsByTagName(\"channel\");\n      int numChannels = channels.getLength();\n      for (int nodeIndex = 0; nodeIndex < numChannels; nodeIndex++)\n      {\n        Node channel = channels.item(0); // The index is 0 because after each move, the channel positions move up a notch\n        boolean moveSuccessful = context.getUserLayoutManager().moveNode(channel, sourceColumn, null);\n        // Not done yet: Need to deal with case when move isn't successful!!!\n      }\n\n      source.appendChild(sourceColumn);\n    }\n\n    // If destination is a tab, create a column, move the tab's children channels to this column,\n    // and use this new column as the destination\n    if (isTab(destination))\n    {\n      destinationColumn = createFolder(\"\");\n      NodeList channels = destination.getElementsByTagName(\"channel\");\n      int numChannels = channels.getLength();\n      for (int nodeIndex = 0; nodeIndex < numChannels; nodeIndex++)\n      {\n        Node channel = channels.item(0); // The index is 0 because after each move, the channel positions move up a notch\n        boolean moveSuccessful = context.getUserLayoutManager().moveNode(channel, destinationColumn, null);\n        // Not done yet: Need to deal with case when move isn't successful!!!\n      }\n\n      destination.appendChild(destinationColumn);\n    }\n\n    // Move the source column before the destination column or at the end\n    Node targetTab = destinationColumn.getParentNode();\n    Node siblingColumn = method.equals(\"insertBefore\") ? destinationColumn : null;\n    context.getUserLayoutManager().moveNode(sourceColumn, targetTab, siblingColumn);\n\n    saveLayout();\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private String getActiveTab()\n  {\n    String activeTab = \"none\";\n\n    try\n    {\n      // Get the profile associated with the layout currently being modified\n      UserPreferences userPrefsFromStore = context.getUserPreferencesFromStore(context.getCurrentUserPreferences().getProfile());\n      userPrefsFromStore = new GPreferencesState(context).getUserPreferences();\n      activeTab = userPrefsFromStore.getStructureStylesheetUserPreferences().getParameterValue(\"activeTab\");\n      System.out.println(\"activeTabFromDB=\"+activeTab);\n    }\n    catch (Exception e)\n    {\n      Logger.log(Logger.ERROR, \"TabColumnPrefsState::getAcctiveTab : Unable to retrieve active tab.\");\n    }\n\n    return activeTab;\n  }","id":9952,"modified_method":"private final String getActiveTab()\n  {\n    String activeTab = \"none\";\n\n    try\n    {\n      // Get the profile associated with the layout currently being modified\n      UserPreferences userPrefsFromStore = context.getUserPreferencesFromStore(context.getCurrentUserPreferences().getProfile());\n      activeTab = userPrefsFromStore.getStructureStylesheetUserPreferences().getParameterValue(\"activeTab\");\n    }\n    catch (Exception e)\n    {\n      Logger.log(Logger.ERROR, \"TabColumnPrefsState::getAcctiveTab : Unable to retrieve active tab.\");\n    }\n\n    return activeTab;\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void deleteElement(String elementId) throws Exception\n  {\n    Element element = userLayout.getElementById(elementId);\n    element.getParentNode().removeChild(element);\n    saveLayout();\n  }","id":9953,"modified_method":"/**\n   * Removes a tab, column, or channel element from the layout\n   * @param elementId the ID attribute of the element to remove\n   */\n  private final void deleteElement(String elementId) throws Exception\n  {\n    Element element = userLayout.getElementById(elementId);\n    // for some reason I am getting a null here for any newly added element\n    // I remember some other people mentioning this problem\n    boolean deleteSuccessful = context.getUserLayoutManager().deleteNode(element);\n    if (deleteSuccessful)\n      saveLayout();\n    else\n      throw new Exception(\"Element \" + elementId + \" cannot be removed because it is either unremovable or it or one of its parent elements is immutable.\");\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void addTab(String tabName, String method, String tabToId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n    Document doc = layout.getOwnerDocument();\n    Element newTab = doc.createElement(\"folder\");\n    newTab.setAttribute(\"name\", tabName);\n    newTab.setAttribute(\"ID\", String.valueOf(GenericPortalBean.getUserLayoutStore().getNextStructFolderId(staticData.getPerson().getID())));\n    newTab.setAttribute(\"type\", \"regular\");\n    newTab.setAttribute(\"hidden\", \"false\");\n    newTab.setAttribute(\"unremovable\", \"false\");\n    newTab.setAttribute(\"immutable\", \"false\");\n    Node tabTo = userLayout.getElementById(tabToId);\n\n    if (method.equals(\"insertBefore\"))\n      layout.insertBefore(newTab, tabTo);\n    else // method = \"appendAfter\"\n      layout.appendChild(newTab);\n\n    saveLayout();\n  }","id":9954,"modified_method":"private final void addFolder(String folderName, String method, String destinationFolderId) throws Exception\n  {\n    Element newFolder = createFolder(folderName);\n    Node destinationFolder = userLayout.getElementById(destinationFolderId);\n    Node parent = destinationFolder.getParentNode();\n    Node siblingFolder = method.equals(\"insertBefore\") ? destinationFolder : null;\n    context.getUserLayoutManager().moveNode(newFolder, parent, siblingFolder);\n\n    saveLayout();\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void moveTab(String tabFromId, String method, String tabToId) throws Exception\n  {\n    Element tabFrom = userLayout.getElementById(tabFromId);\n    Element tabTo = userLayout.getElementById(tabToId);\n    Element layout = userLayout.getDocumentElement();\n    layout.removeChild(tabFrom);\n\n    if (method.equals(\"insertBefore\"))\n      layout.insertBefore(tabFrom, tabTo);\n    else // method = \"appendAfter\"\n      layout.appendChild(tabFrom);\n\n    saveLayout();\n  }","id":9955,"modified_method":"private final void moveTab(String sourceTabId, String method, String destinationTabId) throws Exception\n  {\n    Element sourceTab = userLayout.getElementById(sourceTabId);\n    Element destinationTab = userLayout.getElementById(destinationTabId);\n    Element layout = userLayout.getDocumentElement();\n    Node siblingTab = method.equals(\"insertBefore\") ? destinationTab : null;\n    context.getUserLayoutManager().moveNode(sourceTab, layout, siblingTab);\n\n    saveLayout();\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private Document getUserLayout() throws Exception\n  {\n    // Get the profile currently being used\n    UserLayoutManager ulm = context.getUserLayoutManager();\n    int currentProfileId = ulm.getCurrentProfile().getProfileId();\n\n    // Get the profile associated with the layout currently being modified\n    UserPreferences currentUserPrefs = context.getCurrentUserPreferences();\n    int editedProfileId = currentUserPrefs.getProfile().getProfileId();\n\n    // If the we are editing the current profile, get a copy of the current user layout,\n    // otherwise get it from the database or other persistant storage\n    Document userLayout = null;\n    if (currentProfileId == editedProfileId)\n      userLayout = ulm.getUserLayoutCopy();\n    else\n      userLayout = GenericPortalBean.getUserLayoutStore().getUserLayout(ulm.getPerson().getID(), editedProfileId);\n\n    return userLayout;\n  }","id":9956,"modified_method":"private final Document getUserLayout() throws Exception\n  {\n    // Get the profile currently being used\n    UserLayoutManager ulm = context.getUserLayoutManager();\n    int currentProfileId = ulm.getCurrentProfile().getProfileId();\n\n    // Get the profile associated with the layout currently being modified\n    UserPreferences currentUserPrefs = context.getCurrentUserPreferences();\n    int editedProfileId = currentUserPrefs.getProfile().getProfileId();\n\n    // If the we are editing the current profile, get a copy of the current user layout,\n    // otherwise get it from the database or other persistant storage\n    Document userLayout = null;\n    if (currentProfileId == editedProfileId)\n      userLayout = ulm.getUserLayoutCopy();\n    else\n      userLayout = GenericPortalBean.getUserLayoutStore().getUserLayout(ulm.getPerson().getID(), editedProfileId);\n\n    return userLayout;\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void setActiveTab(String activeTab) throws Exception\n  {\n    UserPreferences userPrefsFromStore = context.getUserPreferencesFromStore(context.getCurrentUserPreferences().getProfile());\n    StructureStylesheetUserPreferences ssup = userPrefsFromStore.getStructureStylesheetUserPreferences();\n    ssup.putParameterValue(\"activeTab\", activeTab);\n\n    // Persist user preferences\n    int userId = staticData.getPerson().getID();\n    int profileId = context.getCurrentUserPreferences().getProfile().getProfileId();\n    upStore.setStructureStylesheetUserPreferences(userId, profileId, ssup);\n  }","id":9957,"modified_method":"private final void setActiveTab(String activeTab) throws Exception\n  {\n    //UserPreferences userPrefsFromStore = context.getUserPreferencesFromStore(context.getCurrentUserPreferences().getProfile());\n    //StructureStylesheetUserPreferences ssup = userPrefsFromStore.getStructureStylesheetUserPreferences();\n    StructureStylesheetUserPreferences ssup = userPrefs.getStructureStylesheetUserPreferences();\n    ssup.putParameterValue(\"activeTab\", activeTab);\n\n    // Persist structure stylesheet user preferences\n    int userId = staticData.getPerson().getID();\n    int profileId = context.getCurrentUserPreferences().getProfile().getProfileId();\n    upStore.setStructureStylesheetUserPreferences(userId, profileId, ssup);\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setRuntimeData (ChannelRuntimeData rd) throws PortalException\n  {\n    this.runtimeData = rd;\n    this.internalState.setRuntimeData(rd);\n\n    try\n    {\n      userLayout = getUserLayout();\n    }\n    catch (Exception e)\n    {\n      throw new GeneralRenderingException(e.getMessage());\n    }\n  }","id":9958,"modified_method":"public void setRuntimeData (ChannelRuntimeData rd) throws PortalException\n  {\n    this.runtimeData = rd;\n    this.internalState.setRuntimeData(rd);\n\n    try\n    {\n      userLayout = getUserLayout();\n      userPrefs = context.getCurrentUserPreferences();\n    }\n    catch (Exception e)\n    {\n      throw new GeneralRenderingException(e.getMessage());\n    }\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void renameTab(String tabId, String tabName) throws Exception\n  {\n    Element tab = userLayout.getElementById(tabId);\n    tab.setAttribute(\"name\", tabName);\n    saveLayout();\n  }","id":9959,"modified_method":"private final void renameTab(String tabId, String tabName) throws Exception\n  {\n    Element tab = userLayout.getElementById(tabId);\n    tab.setAttribute(\"name\", tabName);\n    saveLayout();\n  }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void renderXML (DocumentHandler out) throws PortalException\n    {\n      Hashtable ssParams = new Hashtable(5);\n      ssParams.put(\"baseActionURL\", runtimeData.getBaseActionURL());\n      ssParams.put(\"activeTab\", activeTab);\n      ssParams.put(\"action\", action);\n      ssParams.put(\"elementID\", elementID);\n      ssParams.put(\"errorMessage\", errorMessage);\n      String media = runtimeData.getMedia();\n\n      try\n      {\n        //System.out.println(UtilitiesBean.dom2PrettyString(userLayout));\n        XSLT.transform(userLayout, new URL(sslLocation), out, ssParams, media);\n      }\n      catch (Exception e)\n      {\n        throw new GeneralRenderingException(e.getMessage());\n      }\n    }","id":9960,"modified_method":"public void renderXML (DocumentHandler out) throws PortalException\n    {\n      try\n      {\n        // Set up chain: userLayout --> Structure Attributes Incorp. Filter --> out\n        // Currently this code assumes the use of Xalan as does much of the framework\n        org.apache.xalan.xslt.XSLTProcessor processor = org.apache.xalan.xslt.XSLTProcessorFactory.getProcessor();\n        String xslUri = new org.jasig.portal.StylesheetSet(sslLocation).getStylesheetURI(runtimeData.getMedia());\n        org.apache.xalan.xslt.StylesheetRoot ssRoot = XSLT.getStylesheetRoot(xslUri);\n        processor.setStylesheet(ssRoot);\n        processor.setDocumentHandler(out);\n        processor.setStylesheetParam(\"baseActionURL\", processor.createXString(runtimeData.getBaseActionURL()));\n        processor.setStylesheetParam(\"activeTab\", processor.createXString(activeTab));\n        processor.setStylesheetParam(\"action\", processor.createXString(action));\n        processor.setStylesheetParam(\"elementID\", processor.createXString(elementID));\n        processor.setStylesheetParam(\"errorMessage\", processor.createXString(errorMessage));\n\n        StructureStylesheetUserPreferences ssup = userPrefs.getStructureStylesheetUserPreferences();\n        StructureAttributesIncorporationFilter saif = new StructureAttributesIncorporationFilter(processor, ssup);\n\n        // Begin SAX chain\n        UtilitiesBean.node2SAX(userLayout, saif);\n\n        //if (action.equals(\"deleteColumn\"))\n        //  System.out.println(UtilitiesBean.dom2PrettyString(userLayout));\n      }\n      catch (Exception e)\n      {\n        throw new GeneralRenderingException(e.getMessage());\n      }\n    }","commit_id":"e0ec5df6b46ebaecc8807016cd0b84db05da57dc","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean onTouchEvent(MotionEvent event){\n    \tif(!isMultiTouchSupported()){\n    \t\treturn false;\n    \t}\n    \tint actionCode = event.getAction() & ACTION_MASK;\n    \ttry {\n\t\t\tInteger pointCount = (Integer) getPointerCount.invoke(event);\n\t\t\tif(pointCount < 2){\n\t\t\t\tif(inZoomMode){\n\t\t\t\t\tlistener.onZoomEnded(zoomRelative, angleRelative);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tFloat x1 = (Float) getX.invoke(event, 0);\n\t\t\tFloat x2 = (Float) getX.invoke(event, 1);\n\t\t\tFloat y1 = (Float) getY.invoke(event, 0);\n\t\t\tFloat y2 = (Float) getY.invoke(event, 1);\n\t\t\tfloat distance = FloatMath.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\t\t    float angle = 0;\n\t\t    boolean angleDefined = false;\n\t\t    if(x1 != x2 || y1 != y2) {\n\t\t\t    angleDefined = true;\n\t\t\t    angle = (float) (Math.atan2(y2 - y1, x2 -x1) * 180 / Math.PI);\n\t\t    }\n\t\t\tif (actionCode == ACTION_POINTER_DOWN) {\n\t\t\t\tcenterPoint = new PointF((x1 + x2) / 2, (y1 + y2) / 2);\n\t\t\t\tlistener.onGestureInit(x1, y1, x2, y2);\n\t\t\t\tlistener.onZoomStarted(centerPoint);\n\t\t\t\tzoomStartedDistance = distance;\n\t\t\t\tangleStarted = angle;\n\t\t\t\tinZoomMode = true;\n\t\t\t\treturn true;\n\t\t\t} else if(actionCode == ACTION_POINTER_UP){\n\t\t\t\tif(inZoomMode){\n\t\t\t\t\tlistener.onZoomEnded(zoomRelative, angleRelative);\n\t\t\t\t\tinZoomMode = false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if(inZoomMode && actionCode == MotionEvent.ACTION_MOVE){\n\t\t\t\tif(angleDefined) {\n\t\t\t\t\tangleRelative = MapUtils.unifyRotationTo360(angle - angleStarted);\n\t\t\t\t}\n\t\t\t\tzoomRelative = distance / zoomStartedDistance;\n\t\t\t\tlistener.onZoomingOrRotating(zoomRelative, angleRelative);\n\t\t\t\treturn true;\n\t\t\t}\n    \t} catch (Exception e) {\n    \t\tlog.debug(\"Multi touch exception\" , e); //$NON-NLS-1$\n\t\t}\n    \treturn false;\n    }","id":9961,"modified_method":"public boolean onTouchEvent(MotionEvent event){\n    \tif(!isMultiTouchSupported()){\n    \t\treturn false;\n    \t}\n    \tint actionCode = event.getAction() & ACTION_MASK;\n    \ttry {\n\t\t\tInteger pointCount = (Integer) getPointerCount.invoke(event);\n\t\t\tif(pointCount < 2){\n\t\t\t\tif(inZoomMode){\n\t\t\t\t\tlistener.onZoomEnded(zoomRelative, angleRelative);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tFloat x1 = (Float) getX.invoke(event, 0);\n\t\t\tFloat x2 = (Float) getX.invoke(event, 1);\n\t\t\tFloat y1 = (Float) getY.invoke(event, 0);\n\t\t\tFloat y2 = (Float) getY.invoke(event, 1);\n\t\t\tfloat distance = (float) Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\t\t    float angle = 0;\n\t\t    boolean angleDefined = false;\n\t\t    if(x1 != x2 || y1 != y2) {\n\t\t\t    angleDefined = true;\n\t\t\t    angle = (float) (Math.atan2(y2 - y1, x2 -x1) * 180 / Math.PI);\n\t\t    }\n\t\t\tif (actionCode == ACTION_POINTER_DOWN) {\n\t\t\t\tcenterPoint = new PointF((x1 + x2) / 2, (y1 + y2) / 2);\n\t\t\t\tlistener.onGestureInit(x1, y1, x2, y2);\n\t\t\t\tlistener.onZoomStarted(centerPoint);\n\t\t\t\tzoomStartedDistance = distance;\n\t\t\t\tangleStarted = angle;\n\t\t\t\tinZoomMode = true;\n\t\t\t\treturn true;\n\t\t\t} else if(actionCode == ACTION_POINTER_UP){\n\t\t\t\tif(inZoomMode){\n\t\t\t\t\tlistener.onZoomEnded(zoomRelative, angleRelative);\n\t\t\t\t\tinZoomMode = false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if(inZoomMode && actionCode == MotionEvent.ACTION_MOVE){\n\t\t\t\tif(angleDefined) {\n\t\t\t\t\tangleRelative = MapUtils.unifyRotationTo360(angle - angleStarted);\n\t\t\t\t}\n\t\t\t\tzoomRelative = distance / zoomStartedDistance;\n\t\t\t\tlistener.onZoomingOrRotating(zoomRelative, angleRelative);\n\t\t\t\treturn true;\n\t\t\t}\n    \t} catch (Exception e) {\n    \t\tlog.debug(\"Multi touch exception\" , e); //$NON-NLS-1$\n\t\t}\n    \treturn false;\n    }","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * @return if map could be replaced\n\t */\n\tpublic void generateNewBitmapNative(RenderingContext rc, NativeOsmandLibrary library, \n\t\t\tNativeSearchResult searchResultHandler, \n\t\t\tBitmap bmp, RenderingRuleSearchRequest render, final MapTileDownloader mapTileDownloader) {\n\t\tlong now = System.currentTimeMillis();\n\t\tif (rc.width > 0 && rc.height > 0 && searchResultHandler != null) {\n\t\t\trc.cosRotateTileSize = FloatMath.cos((float) Math.toRadians(rc.rotate)) * TILE_SIZE;\n\t\t\trc.sinRotateTileSize = FloatMath.sin((float) Math.toRadians(rc.rotate)) * TILE_SIZE;\n\t\t\ttry {\n\t\t\t\tif(Looper.getMainLooper() != null && library.useDirectRendering()) {\n\t\t\t\t\tfinal Handler h = new Handler(Looper.getMainLooper());\n\t\t\t\t\tnotifyListenersWithDelay(rc, mapTileDownloader, h);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Native library will decide on it's own best way of rendering\n\t\t\t\t// If res.bitmapBuffer is null, it indicates that rendering was done directly to\n\t\t\t\t// memory of passed bitmap, but this is supported only on Android >= 2.2\n\t\t\t\tfinal NativeLibrary.RenderingGenerationResult res = library.generateRendering(\n\t\t\t\t\trc, searchResultHandler, bmp, bmp.hasAlpha(), render);\n\t\t\t\trc.ended = true;\n\t\t\t\tnotifyListeners(mapTileDownloader);\n\t\t\t\tlong time = System.currentTimeMillis() - now;\n\t\t\t\trc.renderingDebugInfo = String.format(\"Rendering: %s ms  (%s text)\\n\"\n\t\t\t\t\t\t+ \"(%s points, %s points inside, %s of %s objects visible)\\n\",//$NON-NLS-1$\n\t\t\t\t\t\ttime, rc.textRenderingTime, rc.pointCount, rc.pointInsideCount, rc.visible, rc.allObjects);\n\t\t\t\t\n\t\t\t\t// See upper note\n\t\t\t\tif(res.bitmapBuffer != null) {\n\t\t\t\t\tbmp.copyPixelsFromBuffer(res.bitmapBuffer);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":9962,"modified_method":"/**\n\t * @return if map could be replaced\n\t */\n\tpublic void generateNewBitmapNative(RenderingContext rc, NativeOsmandLibrary library, \n\t\t\tNativeSearchResult searchResultHandler, \n\t\t\tBitmap bmp, RenderingRuleSearchRequest render, final MapTileDownloader mapTileDownloader) {\n\t\tlong now = System.currentTimeMillis();\n\t\tif (rc.width > 0 && rc.height > 0 && searchResultHandler != null) {\n\t\t\trc.cosRotateTileSize = (float) (Math.cos(Math.toRadians(rc.rotate)) * TILE_SIZE);\n\t\t\trc.sinRotateTileSize = (float) (Math.sin(Math.toRadians(rc.rotate)) * TILE_SIZE);\n\t\t\ttry {\n\t\t\t\tif(Looper.getMainLooper() != null && library.useDirectRendering()) {\n\t\t\t\t\tfinal Handler h = new Handler(Looper.getMainLooper());\n\t\t\t\t\tnotifyListenersWithDelay(rc, mapTileDownloader, h);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Native library will decide on it's own best way of rendering\n\t\t\t\t// If res.bitmapBuffer is null, it indicates that rendering was done directly to\n\t\t\t\t// memory of passed bitmap, but this is supported only on Android >= 2.2\n\t\t\t\tfinal NativeLibrary.RenderingGenerationResult res = library.generateRendering(\n\t\t\t\t\trc, searchResultHandler, bmp, bmp.hasAlpha(), render);\n\t\t\t\trc.ended = true;\n\t\t\t\tnotifyListeners(mapTileDownloader);\n\t\t\t\tlong time = System.currentTimeMillis() - now;\n\t\t\t\trc.renderingDebugInfo = String.format(\"Rendering: %s ms  (%s text)\\n\"\n\t\t\t\t\t\t+ \"(%s points, %s points inside, %s of %s objects visible)\\n\",//$NON-NLS-1$\n\t\t\t\t\t\ttime, rc.textRenderingTime, rc.pointCount, rc.pointInsideCount, rc.visible, rc.allObjects);\n\t\t\t\t\n\t\t\t\t// See upper note\n\t\t\t\tif(res.bitmapBuffer != null) {\n\t\t\t\t\tbmp.copyPixelsFromBuffer(res.bitmapBuffer);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void generateNewBitmap(RenderingContext rc, List<BinaryMapDataObject> objects, Bitmap bmp, \n\t\t\t\tRenderingRuleSearchRequest render, final MapTileDownloader mapTileDownloader) {\n\t\tlong now = System.currentTimeMillis();\n\t\t// fill area\n\t\tCanvas cv = new Canvas(bmp);\n\t\tif (rc.defaultColor != 0) {\n\t\t\tcv.drawColor(rc.defaultColor);\n\t\t}\n\t\tif (objects != null && !objects.isEmpty() && rc.width > 0 && rc.height > 0) {\n\t\t\trc.cosRotateTileSize = FloatMath.cos((float) Math.toRadians(rc.rotate)) * TILE_SIZE;\n\t\t\trc.sinRotateTileSize = FloatMath.sin((float) Math.toRadians(rc.rotate)) * TILE_SIZE;\n\t\t\t\n\t\t\t// put in order map\n\t\t\tList<MapDataObjectPrimitive>  pointsArray = new ArrayList<OsmandRenderer.MapDataObjectPrimitive>();\n\t\t\tList<MapDataObjectPrimitive> polygonsArray = new ArrayList<OsmandRenderer.MapDataObjectPrimitive>();\n\t\t\tList<MapDataObjectPrimitive>  linesArray = new ArrayList<OsmandRenderer.MapDataObjectPrimitive>();\n\t\t\tsortObjectsByProperOrder(rc, objects, render, pointsArray, polygonsArray, linesArray);\n\n\t\t\trc.lastRenderedKey = 0;\n\n\t\t\tdrawObject(rc, cv, render, polygonsArray, 0);\n\t\t\trc.lastRenderedKey = 5;\n\t\t\tif (rc.shadowRenderingMode > 1) {\n\t\t\t\tdrawObject(rc, cv, render, linesArray, 1);\n\t\t\t}\n\t\t\trc.lastRenderedKey = 40;\n\t\t\tdrawObject(rc, cv, render, linesArray, 2);\n\t\t\trc.lastRenderedKey = 60;\n\n\t\t\tdrawObject(rc, cv, render, pointsArray, 3);\n\t\t\trc.lastRenderedKey = 125;\n\n\n\t\t\tlong beforeIconTextTime = System.currentTimeMillis() - now;\n\t\t\tnotifyListeners(mapTileDownloader);\n\t\t\tdrawIconsOverCanvas(rc, cv);\n\n\t\t\tnotifyListeners(mapTileDownloader);\n\t\t\ttextRenderer.drawTextOverCanvas(rc, cv, rc.preferredLocale);\n\n\t\t\tlong time = System.currentTimeMillis() - now;\n\t\t\trc.renderingDebugInfo = String.format(\"Rendering: %s ms  (%s text)\\n\"\n\t\t\t\t\t+ \"(%s points, %s points inside, %s of %s objects visible)\",//$NON-NLS-1$\n\t\t\t\t\ttime, time - beforeIconTextTime, rc.pointCount, rc.pointInsideCount, rc.visible, rc.allObjects);\n\t\t\tlog.info(rc.renderingDebugInfo);\n\n\t\t}\n\t}","id":9963,"modified_method":"public void generateNewBitmap(RenderingContext rc, List<BinaryMapDataObject> objects, Bitmap bmp, \n\t\t\t\tRenderingRuleSearchRequest render, final MapTileDownloader mapTileDownloader) {\n\t\tlong now = System.currentTimeMillis();\n\t\t// fill area\n\t\tCanvas cv = new Canvas(bmp);\n\t\tif (rc.defaultColor != 0) {\n\t\t\tcv.drawColor(rc.defaultColor);\n\t\t}\n\t\tif (objects != null && !objects.isEmpty() && rc.width > 0 && rc.height > 0) {\n\t\t\trc.cosRotateTileSize = (float) (Math.cos((float) Math.toRadians(rc.rotate)) * TILE_SIZE);\n\t\t\trc.sinRotateTileSize = (float) (Math.sin((float) Math.toRadians(rc.rotate)) * TILE_SIZE);\n\t\t\t\n\t\t\t// put in order map\n\t\t\tList<MapDataObjectPrimitive>  pointsArray = new ArrayList<OsmandRenderer.MapDataObjectPrimitive>();\n\t\t\tList<MapDataObjectPrimitive> polygonsArray = new ArrayList<OsmandRenderer.MapDataObjectPrimitive>();\n\t\t\tList<MapDataObjectPrimitive>  linesArray = new ArrayList<OsmandRenderer.MapDataObjectPrimitive>();\n\t\t\tsortObjectsByProperOrder(rc, objects, render, pointsArray, polygonsArray, linesArray);\n\n\t\t\trc.lastRenderedKey = 0;\n\n\t\t\tdrawObject(rc, cv, render, polygonsArray, 0);\n\t\t\trc.lastRenderedKey = 5;\n\t\t\tif (rc.shadowRenderingMode > 1) {\n\t\t\t\tdrawObject(rc, cv, render, linesArray, 1);\n\t\t\t}\n\t\t\trc.lastRenderedKey = 40;\n\t\t\tdrawObject(rc, cv, render, linesArray, 2);\n\t\t\trc.lastRenderedKey = 60;\n\n\t\t\tdrawObject(rc, cv, render, pointsArray, 3);\n\t\t\trc.lastRenderedKey = 125;\n\n\n\t\t\tlong beforeIconTextTime = System.currentTimeMillis() - now;\n\t\t\tnotifyListeners(mapTileDownloader);\n\t\t\tdrawIconsOverCanvas(rc, cv);\n\n\t\t\tnotifyListeners(mapTileDownloader);\n\t\t\ttextRenderer.drawTextOverCanvas(rc, cv, rc.preferredLocale);\n\n\t\t\tlong time = System.currentTimeMillis() - now;\n\t\t\trc.renderingDebugInfo = String.format(\"Rendering: %s ms  (%s text)\\n\"\n\t\t\t\t\t+ \"(%s points, %s points inside, %s of %s objects visible)\",//$NON-NLS-1$\n\t\t\t\t\ttime, time - beforeIconTextTime, rc.pointCount, rc.pointInsideCount, rc.visible, rc.allObjects);\n\t\t\tlog.info(rc.renderingDebugInfo);\n\n\t\t}\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawAction(RotatedTileBox tb, Canvas canvas) {\n\t\tif (actionPoints.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\ttry {\n\t\t\t\tPath pth = new Path();\n\t\t\t\tMatrix matrix = new Matrix();\n\t\t\t\tboolean first = true;\n\t\t\t\tint x = 0, px = 0, py = 0, y = 0;\n\t\t\t\tfor (int i = 0; i < actionPoints.size(); i++) {\n\t\t\t\t\tLocation o = actionPoints.get(i);\n\t\t\t\t\tif (o == null) {\n\t\t\t\t\t\tfirst = true;\n\t\t\t\t\t\tcanvas.drawPath(pth, actionPaint);\n\t\t\t\t\t\tdouble angleRad = Math.atan2(y - py, x - px);\n\t\t\t\t\t\tdouble angle = (angleRad * 180 / Math.PI) + 90f;\n\t\t\t\t\t\tdouble distSegment = FloatMath.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\t\t\t\tif (distSegment == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// int len = (int) (distSegment / pxStep);\n\t\t\t\t\t\tfloat pdx = x - px;\n\t\t\t\t\t\tfloat pdy = y - py;\n\t\t\t\t\t\tmatrix.reset();\n\t\t\t\t\t\tmatrix.postTranslate(0, -actionArrow.getHeight() / 2);\n\t\t\t\t\t\tmatrix.postRotate((float) angle, actionArrow.getWidth() / 2, 0);\n\t\t\t\t\t\tmatrix.postTranslate(px + pdx - actionArrow.getWidth() / 2, py + pdy);\n\t\t\t\t\t\tcanvas.drawBitmap(actionArrow, matrix, paintIconAction);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpx = x;\n\t\t\t\t\t\tpy = y;\n\t\t\t\t\t\tx = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\ty = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tpth.reset();\n\t\t\t\t\t\t\tpth.moveTo(x, y);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpth.lineTo(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} finally {\n\t\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\t}\n\t\t}\n\t}","id":9964,"modified_method":"private void drawAction(RotatedTileBox tb, Canvas canvas) {\n\t\tif (actionPoints.size() > 0) {\n\t\t\tcanvas.rotate(-tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\ttry {\n\t\t\t\tPath pth = new Path();\n\t\t\t\tMatrix matrix = new Matrix();\n\t\t\t\tboolean first = true;\n\t\t\t\tint x = 0, px = 0, py = 0, y = 0;\n\t\t\t\tfor (int i = 0; i < actionPoints.size(); i++) {\n\t\t\t\t\tLocation o = actionPoints.get(i);\n\t\t\t\t\tif (o == null) {\n\t\t\t\t\t\tfirst = true;\n\t\t\t\t\t\tcanvas.drawPath(pth, actionPaint);\n\t\t\t\t\t\tdouble angleRad = Math.atan2(y - py, x - px);\n\t\t\t\t\t\tdouble angle = (angleRad * 180 / Math.PI) + 90f;\n\t\t\t\t\t\tdouble distSegment = Math.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\t\t\t\tif (distSegment == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// int len = (int) (distSegment / pxStep);\n\t\t\t\t\t\tfloat pdx = x - px;\n\t\t\t\t\t\tfloat pdy = y - py;\n\t\t\t\t\t\tmatrix.reset();\n\t\t\t\t\t\tmatrix.postTranslate(0, -actionArrow.getHeight() / 2);\n\t\t\t\t\t\tmatrix.postRotate((float) angle, actionArrow.getWidth() / 2, 0);\n\t\t\t\t\t\tmatrix.postTranslate(px + pdx - actionArrow.getWidth() / 2, py + pdy);\n\t\t\t\t\t\tcanvas.drawBitmap(actionArrow, matrix, paintIconAction);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpx = x;\n\t\t\t\t\t\tpy = y;\n\t\t\t\t\t\tx = (int) tb.getPixXFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\ty = (int) tb.getPixYFromLatLon(o.getLatitude(), o.getLongitude());\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tpth.reset();\n\t\t\t\t\t\t\tpth.moveTo(x, y);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpth.lineTo(x, y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} finally {\n\t\t\t\tcanvas.rotate(tb.getRotate(), tb.getCenterPixelX(), tb.getCenterPixelY());\n\t\t\t}\n\t\t}\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void drawArrowsOverPath(Canvas canvas, TIntArrayList lst, Bitmap arrow) {\n\t\tfloat pxStep = arrow.getHeight() * 4f;\n\t\tMatrix matrix = new Matrix();\n\t\tfloat dist = 0;\n\t\tfor (int i = 0; i < lst.size(); i += 4) {\n\t\t\tint px = lst.get(i);\n\t\t\tint py = lst.get(i + 1);\n\t\t\tint x = lst.get(i + 2);\n\t\t\tint y = lst.get(i + 3);\n\t\t\tfloat angleRad = (float) Math.atan2(y - py, x - px);\n\t\t\tfloat angle = (float) (angleRad * 180 / Math.PI) + 90f;\n\t\t\tfloat distSegment = FloatMath.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\tif(distSegment == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint len = (int) (distSegment / pxStep);\n\t\t\tif (len > 0) {\n\t\t\t\tfloat pdx = ((x - px) / len);\n\t\t\t\tfloat pdy = ((y - py) / len);\n\t\t\t\tfor (int k = 1; k <= len; k++) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + k * pdx- arrow.getWidth() / 2 , py + pdy * k);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(dist > pxStep) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + (x - px) / 2 - arrow.getWidth() / 2, py + (y - py) / 2);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist += distSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":9965,"modified_method":"private void drawArrowsOverPath(Canvas canvas, TIntArrayList lst, Bitmap arrow) {\n\t\tfloat pxStep = arrow.getHeight() * 4f;\n\t\tMatrix matrix = new Matrix();\n\t\tfloat dist = 0;\n\t\tfor (int i = 0; i < lst.size(); i += 4) {\n\t\t\tint px = lst.get(i);\n\t\t\tint py = lst.get(i + 1);\n\t\t\tint x = lst.get(i + 2);\n\t\t\tint y = lst.get(i + 3);\n\t\t\tfloat angleRad = (float) Math.atan2(y - py, x - px);\n\t\t\tfloat angle = (float) (angleRad * 180 / Math.PI) + 90f;\n\t\t\tfloat distSegment = (float) Math.sqrt((y - py) * (y - py) + (x - px) * (x - px));\n\t\t\tif(distSegment == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint len = (int) (distSegment / pxStep);\n\t\t\tif (len > 0) {\n\t\t\t\tfloat pdx = ((x - px) / len);\n\t\t\t\tfloat pdy = ((y - py) / len);\n\t\t\t\tfor (int k = 1; k <= len; k++) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + k * pdx- arrow.getWidth() / 2 , py + pdy * k);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(dist > pxStep) {\n\t\t\t\t\tmatrix.reset();\n\t\t\t\t\tmatrix.postTranslate(0, -arrow.getHeight() / 2);\n\t\t\t\t\tmatrix.postRotate(angle, arrow.getWidth() / 2, 0);\n\t\t\t\t\tmatrix.postTranslate(px + (x - px) / 2 - arrow.getWidth() / 2, py + (y - py) / 2);\n\t\t\t\t\tcanvas.drawBitmap(arrow, matrix, paintIcon);\n\t\t\t\t\tdist = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist += distSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"boolean intersects(QuadRect tRect, float tRot, QuadRect sRect, float sRot) {\n\t\tif (Math.abs(tRot) < Math.PI / 15 && Math.abs(sRot) < Math.PI / 15) {\n\t\t\treturn QuadRect.intersects(tRect, sRect);\n\t\t}\n\t\tdouble dist = Math.sqrt(sqr(tRect.centerX() - sRect.centerX()) + sqr(tRect.centerY() - sRect.centerY()));\n\t\tif (dist < 3) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// difference close to 90/270 degrees\n\t\tif (Math.abs(Math.cos(tRot - sRot)) < 0.3) {\n\t\t\t// rotate one rectangle to 90 degrees\n\t\t\ttRot += Math.PI / 2;\n\t\t\tdouble l = tRect.centerX() - tRect.height() / 2;\n\t\t\tdouble t = tRect.centerY() - tRect.width() / 2;\n\t\t\ttRect = new QuadRect(l, t, l + tRect.height(), t + tRect.width());\n\t\t}\n\n\t\t// determine difference close to 180/0 degrees\n\t\tif (Math.abs(FloatMath.sin(tRot - sRot)) < 0.3) {\n\t\t\t// rotate t box\n\t\t\t// (calculate offset for t center suppose we rotate around s center)\n\t\t\tfloat diff = (float) (-Math.atan2(tRect.centerX() - sRect.centerX(), tRect.centerY() - sRect.centerY()) + Math.PI / 2);\n\t\t\tdiff -= sRot;\n\t\t\tdouble left = sRect.centerX() + dist * FloatMath.cos(diff) - tRect.width() / 2;\n\t\t\tdouble top = sRect.centerY() - dist * FloatMath.sin(diff) - tRect.height() / 2;\n\t\t\tQuadRect nRect = new QuadRect(left, top, left + tRect.width(), top + tRect.height());\n\t\t\treturn QuadRect.intersects(nRect, sRect);\n\t\t}\n\n\t\t// TODO other cases not covered\n\t\treturn QuadRect.intersects(tRect, sRect);\n\t}","id":9966,"modified_method":"boolean intersects(QuadRect tRect, float tRot, QuadRect sRect, float sRot) {\n\t\tif (Math.abs(tRot) < Math.PI / 15 && Math.abs(sRot) < Math.PI / 15) {\n\t\t\treturn QuadRect.intersects(tRect, sRect);\n\t\t}\n\t\tdouble dist = Math.sqrt(sqr(tRect.centerX() - sRect.centerX()) + sqr(tRect.centerY() - sRect.centerY()));\n\t\tif (dist < 3) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// difference close to 90/270 degrees\n\t\tif (Math.abs(Math.cos(tRot - sRot)) < 0.3) {\n\t\t\t// rotate one rectangle to 90 degrees\n\t\t\ttRot += Math.PI / 2;\n\t\t\tdouble l = tRect.centerX() - tRect.height() / 2;\n\t\t\tdouble t = tRect.centerY() - tRect.width() / 2;\n\t\t\ttRect = new QuadRect(l, t, l + tRect.height(), t + tRect.width());\n\t\t}\n\n\t\t// determine difference close to 180/0 degrees\n\t\tif (Math.abs(Math.sin(tRot - sRot)) < 0.3) {\n\t\t\t// rotate t box\n\t\t\t// (calculate offset for t center suppose we rotate around s center)\n\t\t\tfloat diff = (float) (-Math.atan2(tRect.centerX() - sRect.centerX(), tRect.centerY() - sRect.centerY()) + Math.PI / 2);\n\t\t\tdiff -= sRot;\n\t\t\tdouble left = sRect.centerX() + dist * Math.cos(diff) - tRect.width() / 2;\n\t\t\tdouble top = sRect.centerY() - dist * Math.sin(diff) - tRect.height() / 2;\n\t\t\tQuadRect nRect = new QuadRect(left, top, left + tRect.width(), top + tRect.height());\n\t\t\treturn QuadRect.intersects(nRect, sRect);\n\t\t}\n\n\t\t// TODO other cases not covered\n\t\treturn QuadRect.intersects(tRect, sRect);\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] points, boolean drawOnPath) {\n\t\tint len = points.length;\n\t\tif (!drawOnPath) {\n\t\t\tp.drawOnPath = null;\n\t\t\t// simply calculate rotation of path used for shields\n\t\t\tfloat px = 0;\n\t\t\tfloat py = 0;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tpx += points[i].x - points[i - 1].x;\n\t\t\t\tpy += points[i].y - points[i - 1].y;\n\t\t\t}\n\t\t\tif (px != 0 || py != 0) {\n\t\t\t\tp.pathRotate = (float) (-Math.atan2(px, py) + Math.PI / 2);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tboolean inverse = false;\n\t\tfloat roadLength = 0;\n\t\tboolean prevInside = false;\n\t\tfloat visibleRoadLength = 0;\n\t\tfloat textw = (float) p.bounds.width();\n\t\tint last = 0;\n\t\tint startVisible = 0;\n\t\tfloat[] distances = new float[points.length - 1];\n\n\t\tfloat normalTextLen = 1.5f * textw;\n\t\tfor (int i = 0; i < len; i++, last++) {\n\t\t\tboolean inside = points[i].x >= 0 && points[i].x <= rc.width &&\n\t\t\t\t\tpoints[i].x >= 0 && points[i].y <= rc.height;\n\t\t\tif (i > 0) {\n\t\t\t\tfloat d = FloatMath.sqrt(fsqr(points[i].x - points[i - 1].x) + \n\t\t\t\t\t\tfsqr(points[i].y - points[i - 1].y));\n\t\t\t\tdistances[i-1]= d;\n\t\t\t\troadLength += d;\n\t\t\t\tif(inside) {\n\t\t\t\t\tvisibleRoadLength += d;\n\t\t\t\t\tif(!prevInside) {\n\t\t\t\t\t\tstartVisible = i - 1;\n\t\t\t\t\t}\n\t\t\t\t} else if(prevInside) {\n\t\t\t\t\tif(visibleRoadLength >= normalTextLen) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvisibleRoadLength = 0;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tprevInside = inside;\n\t\t}\n\t\tif (textw >= roadLength) {\n\t\t\treturn false;\n\t\t}\n\t\tint startInd = 0;\n\t\tint endInd = len;\n\n\t\tif(textw < visibleRoadLength &&  last - startVisible > 1) {\n\t\t\tstartInd = startVisible;\n\t\t\tendInd = last;\n\t\t\t// display long road name in center\n\t\t\tif (visibleRoadLength > 3 * textw) {\n\t\t\t\tboolean ch ;\n\t\t\t\tdo {\n\t\t\t\t\tch = false;\n\t\t\t\t\tif(endInd - startInd > 2 && visibleRoadLength - distances[startInd] > normalTextLen){\n\t\t\t\t\t\tvisibleRoadLength -= distances[startInd];\n\t\t\t\t\t\tstartInd++;\n\t\t\t\t\t\tch = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(endInd - startInd > 2 && visibleRoadLength - distances[endInd - 2] > normalTextLen){\n\t\t\t\t\t\tvisibleRoadLength -= distances[endInd - 2];\n\t\t\t\t\t\tendInd--;\n\t\t\t\t\t\tch = true;\n\t\t\t\t\t}\n\t\t\t\t} while(ch);\n\t\t\t}\n\t\t}\n\t\t// shrink path to display more text\n\t\tif (startInd > 0 || endInd < len) {\n\t\t\t// find subpath\n\t\t\tPath path = new Path(); \n\t\t\tfor (int i = startInd; i < endInd; i++) {\n\t\t\t\tif (i == startInd) {\n\t\t\t\t\tpath.moveTo(points[i].x, points[i].y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(points[i].x, points[i].y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.drawOnPath = path;\n\t\t}\n\t\t// calculate vector of the road (px, py) to proper rotate it\n\t\tfloat px = 0;\n\t\tfloat py = 0;\n\t\tfor (int i = startInd + 1; i < endInd; i++) {\n\t\t\tpx += points[i].x - points[i - 1].x;\n\t\t\tpy += points[i].y - points[i - 1].y;\n\t\t}\n\t\tfloat scale = 0.5f;\n\t\tfloat plen = (float) Math.sqrt(px * px + py * py);\n\t\t// vector ox,oy orthogonal to px,py to measure height\n\t\tfloat ox = -py;\n\t\tfloat oy = px;\n\t\tif(plen > 0) {\n\t\t\tfloat rot = (float) (-Math.atan2(px, py) + Math.PI / 2);\n\t\t\tif (rot < 0) rot += Math.PI * 2;\n\t\t\tif (rot > Math.PI / 2f && rot < 3 * Math.PI / 2f) {\n\t\t\t\trot += Math.PI;\n\t\t\t\tinverse = true;\n\t\t\t\tox = -ox;\n\t\t\t\toy = -oy;\n\t\t\t}\n\t\t\tp.pathRotate = rot;\n\t\t\tox *= (p.bounds.height() / plen) / 2;\n\t\t\toy *= (p.bounds.height() / plen) / 2;\n\t\t}\n\n\t\tp.centerX = points[startInd].x + scale * px + ox;\n\t\tp.centerY = points[startInd].y + scale * py + oy;\n//\t\tp.hOffset = 0;\n\n\t\tif (inverse) {\n\t\t\tPath path = new Path();\n\t\t\tfor (int i = endInd - 1; i >= startInd; i--) {\n\t\t\t\tif (i == endInd - 1) {\n\t\t\t\t\tpath.moveTo(points[i].x, points[i].y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(points[i].x, points[i].y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.drawOnPath = path;\n\t\t}\n\t\treturn true;\n\t}","id":9967,"modified_method":"boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] points, boolean drawOnPath) {\n\t\tint len = points.length;\n\t\tif (!drawOnPath) {\n\t\t\tp.drawOnPath = null;\n\t\t\t// simply calculate rotation of path used for shields\n\t\t\tfloat px = 0;\n\t\t\tfloat py = 0;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tpx += points[i].x - points[i - 1].x;\n\t\t\t\tpy += points[i].y - points[i - 1].y;\n\t\t\t}\n\t\t\tif (px != 0 || py != 0) {\n\t\t\t\tp.pathRotate = (float) (-Math.atan2(px, py) + Math.PI / 2);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tboolean inverse = false;\n\t\tfloat roadLength = 0;\n\t\tboolean prevInside = false;\n\t\tfloat visibleRoadLength = 0;\n\t\tfloat textw = (float) p.bounds.width();\n\t\tint last = 0;\n\t\tint startVisible = 0;\n\t\tfloat[] distances = new float[points.length - 1];\n\n\t\tfloat normalTextLen = 1.5f * textw;\n\t\tfor (int i = 0; i < len; i++, last++) {\n\t\t\tboolean inside = points[i].x >= 0 && points[i].x <= rc.width &&\n\t\t\t\t\tpoints[i].x >= 0 && points[i].y <= rc.height;\n\t\t\tif (i > 0) {\n\t\t\t\tfloat d = (float) Math.sqrt(fsqr(points[i].x - points[i - 1].x) + \n\t\t\t\t\t\tfsqr(points[i].y - points[i - 1].y));\n\t\t\t\tdistances[i-1]= d;\n\t\t\t\troadLength += d;\n\t\t\t\tif(inside) {\n\t\t\t\t\tvisibleRoadLength += d;\n\t\t\t\t\tif(!prevInside) {\n\t\t\t\t\t\tstartVisible = i - 1;\n\t\t\t\t\t}\n\t\t\t\t} else if(prevInside) {\n\t\t\t\t\tif(visibleRoadLength >= normalTextLen) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvisibleRoadLength = 0;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tprevInside = inside;\n\t\t}\n\t\tif (textw >= roadLength) {\n\t\t\treturn false;\n\t\t}\n\t\tint startInd = 0;\n\t\tint endInd = len;\n\n\t\tif(textw < visibleRoadLength &&  last - startVisible > 1) {\n\t\t\tstartInd = startVisible;\n\t\t\tendInd = last;\n\t\t\t// display long road name in center\n\t\t\tif (visibleRoadLength > 3 * textw) {\n\t\t\t\tboolean ch ;\n\t\t\t\tdo {\n\t\t\t\t\tch = false;\n\t\t\t\t\tif(endInd - startInd > 2 && visibleRoadLength - distances[startInd] > normalTextLen){\n\t\t\t\t\t\tvisibleRoadLength -= distances[startInd];\n\t\t\t\t\t\tstartInd++;\n\t\t\t\t\t\tch = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(endInd - startInd > 2 && visibleRoadLength - distances[endInd - 2] > normalTextLen){\n\t\t\t\t\t\tvisibleRoadLength -= distances[endInd - 2];\n\t\t\t\t\t\tendInd--;\n\t\t\t\t\t\tch = true;\n\t\t\t\t\t}\n\t\t\t\t} while(ch);\n\t\t\t}\n\t\t}\n\t\t// shrink path to display more text\n\t\tif (startInd > 0 || endInd < len) {\n\t\t\t// find subpath\n\t\t\tPath path = new Path(); \n\t\t\tfor (int i = startInd; i < endInd; i++) {\n\t\t\t\tif (i == startInd) {\n\t\t\t\t\tpath.moveTo(points[i].x, points[i].y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(points[i].x, points[i].y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.drawOnPath = path;\n\t\t}\n\t\t// calculate vector of the road (px, py) to proper rotate it\n\t\tfloat px = 0;\n\t\tfloat py = 0;\n\t\tfor (int i = startInd + 1; i < endInd; i++) {\n\t\t\tpx += points[i].x - points[i - 1].x;\n\t\t\tpy += points[i].y - points[i - 1].y;\n\t\t}\n\t\tfloat scale = 0.5f;\n\t\tfloat plen = (float) Math.sqrt(px * px + py * py);\n\t\t// vector ox,oy orthogonal to px,py to measure height\n\t\tfloat ox = -py;\n\t\tfloat oy = px;\n\t\tif(plen > 0) {\n\t\t\tfloat rot = (float) (-Math.atan2(px, py) + Math.PI / 2);\n\t\t\tif (rot < 0) rot += Math.PI * 2;\n\t\t\tif (rot > Math.PI / 2f && rot < 3 * Math.PI / 2f) {\n\t\t\t\trot += Math.PI;\n\t\t\t\tinverse = true;\n\t\t\t\tox = -ox;\n\t\t\t\toy = -oy;\n\t\t\t}\n\t\t\tp.pathRotate = rot;\n\t\t\tox *= (p.bounds.height() / plen) / 2;\n\t\t\toy *= (p.bounds.height() / plen) / 2;\n\t\t}\n\n\t\tp.centerX = points[startInd].x + scale * px + ox;\n\t\tp.centerY = points[startInd].y + scale * py + oy;\n//\t\tp.hOffset = 0;\n\n\t\tif (inverse) {\n\t\t\tPath path = new Path();\n\t\t\tfor (int i = endInd - 1; i >= startInd; i--) {\n\t\t\t\tif (i == endInd - 1) {\n\t\t\t\t\tpath.moveTo(points[i].x, points[i].y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(points[i].x, points[i].y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.drawOnPath = path;\n\t\t}\n\t\treturn true;\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void calcTurnPath(Path pathForTurn, TurnType turnType, Matrix transform) {\n\t\tif(turnType == null){\n\t\t\treturn;\n\t\t}\n\t\tpathForTurn.reset();\n\t\tint ha = 72;\n\t\tint wa = 72;\n\n\t\tint th = 12; // thickness\n\t\tpathForTurn.moveTo(wa / 2, ha - 1);\n\t\tfloat sarrowL = 22; // side of arrow ?\n\t\tfloat harrowL = (float) Math.sqrt(2) * sarrowL; // hypotenuse of arrow\n\t\tfloat spartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\tfloat hpartArrowL = (float) (harrowL - th) / 2;\n\n\t\tif (TurnType.C == turnType.getValue()) {\n\t\t\tint h = (int) (ha - hpartArrowL - 16);\n\t\t\tpathForTurn.rMoveTo(th, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TR == turnType.getValue()|| TurnType.TL == turnType.getValue()) {\n\t\t\tint b = TurnType.TR == turnType.getValue()? 1 : -1;\n\t\t\tfloat quadShiftX = 18;\n\t\t\tfloat quadShiftY = 18;\n\t\t\tint wl = 10; // width\n\t\t\tint h = (int) (ha - quadShiftY - harrowL + hpartArrowL - 5);\n\t\t\tint sl = wl + th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * sl, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rLineTo(b * wl, 0);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\tpathForTurn.rLineTo(b * harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b * harrowL / 2, -harrowL / 2);\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(-b * wl, 0);\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.KL == turnType.getValue() || TurnType.KR == turnType.getValue()) {\n\t\t\tint b = TurnType.KR == turnType.getValue()? 1 : -1;\n\t\t\tfloat quadShiftX = 14;\n\t\t\tfloat quadShiftY = 14;\n\t\t\tth = 10;\n\t\t\tspartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\t\thpartArrowL = (float) (harrowL - th) / 2;\n\t\t\tint h = 12;\n\t\t\tint lh = 15;\n\t\t\tint sl = th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * (sl + 10), 0);\n\t\t\tpathForTurn.rLineTo(0, -lh);\n\t\t\t// 1st arc\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, -quadShiftY);\n\t\t\t// center\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h );\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(0, quadShiftY - th, -b * (quadShiftX - th), quadShiftY- th);\n\t\t\t//1st arc\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th ), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, lh );\n\n\t\t} else if (TurnType.TSLR == turnType.getValue() || TurnType.TSLL == turnType.getValue()) {\n\t\t\tint b = TurnType.TSLR == turnType.getValue() ? 1 : -1;\n\t\t\tint h = 24;\n\t\t\tint quadShiftY = 22;\n\t\t\tfloat quadShiftX = (float) (quadShiftY / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = (sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShifty = quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * 4, 0);\n\t\t\tpathForTurn.rLineTo(0, -h /* + partArrowL */);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY + quadShiftX /*- partArrowL*/, b * quadShiftX, -quadShiftY /*- partArrowL*/);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(0, -sarrowL); // center\n\t\t\tpathForTurn.rLineTo(-b * sarrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rQuadTo(b * nQuadShiftX, -nQuadShiftX, b * nQuadShiftX, nQuadShifty);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TSHR == turnType.getValue() || TurnType.TSHL == turnType.getValue()) {\n\t\t\tint b = TurnType.TSHR == turnType.getValue() ? 1 : -1;\n\t\t\tint h = 28;\n\t\t\tfloat quadShiftX = 22;\n\t\t\tint sh = 10;\n\t\t\tfloat quadShiftY = -(float) (quadShiftX / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = -(sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShiftY = -quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * sh, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftX - quadShiftY), b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(b * sarrowL, 0); // center\n\t\t\tpathForTurn.rLineTo(0, -sarrowL);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rCubicTo(b * nQuadShiftX / 2, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if(TurnType.TU == turnType.getValue() || TurnType.TRU == turnType.getValue()) {\n\t\t\tint h = 40;\n\t\t\t// right left\n\t\t\tint b = TurnType.TU == turnType.getValue() ? 1 : -1;\n\t\t\tfloat quadShiftX = 10; // 13\n\t\t\tfloat quadShiftY = 10; // 13\n\t\t\tint sm = 10;\n\n\t\t\tpathForTurn.rMoveTo(b * 28, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftY+th), -b * (quadShiftX+th), -(quadShiftY+th));\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX+th), 0, -b * (quadShiftX+th), (quadShiftY+th));\n\t\t\tpathForTurn.rLineTo(0, sm);\n\n\t\t\tpathForTurn.rLineTo(-b * hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, harrowL/2); // center\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, -harrowL/2);\n\t\t\tpathForTurn.rLineTo(-b  *hpartArrowL, 0);\n\n\t\t\tpathForTurn.rLineTo(0, -sm);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftX, b *quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.OFFR == turnType.getValue()){\n\t\t\tint h = (int) (ha - hpartArrowL - 16);\n\t\t\tpathForTurn.rMoveTo(th, 0); //12 0\n\t\t\t//first square\n\t\t\tpathForTurn.rLineTo(0, -h / 4); //0 -7\n\t\t\tpathForTurn.rLineTo(-th, 0); //-12 0\n\t\t\tpathForTurn.rLineTo(0, h / 4); //0 7\n\t\t\tpathForTurn.rLineTo(th, 0); //12 0\n\t\t\tpathForTurn.rMoveTo(0, -h / 2); //12 0\n\t\t\t//second square\n\t\t\tpathForTurn.rLineTo(0, -h / 4); //0 -7\n\t\t\tpathForTurn.rLineTo(-th, 0); //-12 0\n\t\t\tpathForTurn.rLineTo(0, h / 4); //0 7\n\t\t\tpathForTurn.rLineTo(th, 0); //12 0\n\t\t\tpathForTurn.rMoveTo(0, -h / 2 + 1); //31 0\n\t\t\t//arrow\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0); //9 0\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, -harrowL / 2); // center -15 -15\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, harrowL / 2); // -15 15\n\t\t\tpathForTurn.rLineTo(hpartArrowL + th, 0); //9 0\n\t\t} else if (turnType != null && turnType.isRoundAbout()) {\n\t\t\tfloat t = turnType.getTurnAngle();\n\t\t\tif (t >= 170 && t < 220) {\n\t\t\t\tt = 220;\n\t\t\t} else if (t > 160 && t < 170) {\n\t\t\t\tt = 160;\n\t\t\t}\n\t\t\tboolean leftSide = turnType.isLeftSide();\n\t\t\tfloat sweepAngle = (t - 360) - 180;\n\t\t\tif (sweepAngle < -360) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\tif(leftSide && sweepAngle < 0) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\t\n\t\t\tfloat r1 = ha / 3f - 1;\n\t\t\tfloat r2 = r1 - 9;\n\t\t\tfloat angleToRot = leftSide ? -0.3f : 0.3f;\n\t\t\tint cx = wa / 2 ;\n\t\t\tint cy = ha / 2 - 2;\n\t\t\tif (leftSide) {\n\t\t\t\tpathForTurn.moveTo(cx - 8, ha - 1);\n\t\t\t\tpathForTurn.lineTo(cx - 8, cy + r1);\n\t\t\t} else {\n\t\t\t\tpathForTurn.moveTo(cx, ha - 1);\n\t\t\t\tpathForTurn.lineTo(cx, cy + r1);\n\t\t\t}\n\t\t\tRectF r = new RectF(cx - r1, cy - r1, cx + r1, cy + r1);\n\t\t\t\n\t\t\tint out = turnType.getExitOut();\n\t\t\tif (out < 1) {\n\t\t\t\tout = 1;\n\t\t\t}\n\t\t\tfloat prev = 90;\n\t\t\tfloat init = 90;\n\t\t\t\n\t\t\tfloat step = sweepAngle / out;\n\t\t\tfor (int i = 1; i <= out; i++) {\n\t\t\t\tfloat to = step * i;\n\t\t\t\tif (i == out) {\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - prev + init);\n\t\t\t\t} else {\n\t\t\t\t\tfloat tsRad = (float) ((to - step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tfloat tsRad2 = (float) ((to + step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - step / 6 - prev + init );\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * FloatMath.sin(tsRad), cy - (r1 + 10) * FloatMath.cos(tsRad));\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * FloatMath.sin(tsRad2), cy - (r1 + 10) * FloatMath.cos(tsRad2));\n\t\t\t\t\t// not necessary for next arcTo\n\t\t\t\t\t//pathForTurn.lineTo(cx + (r1 + 0) * FloatMath.sin(tsRad2), cy - (r1 + 0) * FloatMath.cos(tsRad2));\n\t\t\t\t\tprev = to + step / 6 + init;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfloat angleRad = (float) ((180 + sweepAngle) * Math.PI / 180f);\n\t\t\t\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * FloatMath.sin(angleRad), cy - (r1 + 4) * FloatMath.cos(angleRad));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * FloatMath.sin(angleRad + angleToRot/2), cy - (r1 + 6) * FloatMath.cos(angleRad + angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 14) * FloatMath.sin(angleRad - angleToRot/2), cy - (r1 + 12) * FloatMath.cos(angleRad - angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * FloatMath.sin(angleRad - 3*angleToRot/2), cy - (r1 + 6) * FloatMath.cos(angleRad - 3*angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * FloatMath.sin(angleRad - angleToRot), cy - (r1 + 4) * FloatMath.cos(angleRad - angleToRot));\n\t\t\tpathForTurn.lineTo(cx + r2 * FloatMath.sin(angleRad - angleToRot), cy - r2 * FloatMath.cos(angleRad - angleToRot));\n\t\t\t\n\t\t\tr.set(cx - r2, cy - r2, cx + r2, cy + r2);\n\t\t\tpathForTurn.arcTo(r, 360 + sweepAngle + 90, -sweepAngle);\n\t\t\tif (leftSide) {\n\t\t\t\tpathForTurn.lineTo(cx, cy + r2);\n\t\t\t\tpathForTurn.lineTo(cx, ha - 1);\n\t\t\t} else {\n\t\t\t\tpathForTurn.lineTo(cx - 8, cy + r2);\n\t\t\t\tpathForTurn.lineTo(cx - 8, ha - 1);\n\t\t\t}\n\t\t\tpathForTurn.close();\n\t\t}\n\t\tpathForTurn.close();\n\t\tif(transform != null){\n\t\t\tpathForTurn.transform(transform);\n\t\t}\n\t}","id":9968,"modified_method":"public static void calcTurnPath(Path pathForTurn, TurnType turnType, Matrix transform) {\n\t\tif(turnType == null){\n\t\t\treturn;\n\t\t}\n\t\tpathForTurn.reset();\n\t\tint ha = 72;\n\t\tint wa = 72;\n\n\t\tint th = 12; // thickness\n\t\tpathForTurn.moveTo(wa / 2, ha - 1);\n\t\tfloat sarrowL = 22; // side of arrow ?\n\t\tfloat harrowL = (float) Math.sqrt(2) * sarrowL; // hypotenuse of arrow\n\t\tfloat spartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\tfloat hpartArrowL = (float) (harrowL - th) / 2;\n\n\t\tif (TurnType.C == turnType.getValue()) {\n\t\t\tint h = (int) (ha - hpartArrowL - 16);\n\t\t\tpathForTurn.rMoveTo(th, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TR == turnType.getValue()|| TurnType.TL == turnType.getValue()) {\n\t\t\tint b = TurnType.TR == turnType.getValue()? 1 : -1;\n\t\t\tfloat quadShiftX = 18;\n\t\t\tfloat quadShiftY = 18;\n\t\t\tint wl = 10; // width\n\t\t\tint h = (int) (ha - quadShiftY - harrowL + hpartArrowL - 5);\n\t\t\tint sl = wl + th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * sl, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rLineTo(b * wl, 0);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\tpathForTurn.rLineTo(b * harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b * harrowL / 2, -harrowL / 2);\n\t\t\tpathForTurn.rLineTo(0, hpartArrowL);\n\t\t\t\n\t\t\tpathForTurn.rLineTo(-b * wl, 0);\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.KL == turnType.getValue() || TurnType.KR == turnType.getValue()) {\n\t\t\tint b = TurnType.KR == turnType.getValue()? 1 : -1;\n\t\t\tfloat quadShiftX = 14;\n\t\t\tfloat quadShiftY = 14;\n\t\t\tth = 10;\n\t\t\tspartArrowL = (float) ((sarrowL - th / Math.sqrt(2)) / 2);\n\t\t\thpartArrowL = (float) (harrowL - th) / 2;\n\t\t\tint h = 12;\n\t\t\tint lh = 15;\n\t\t\tint sl = th / 2;\n\t\t\t\n\t\t\tpathForTurn.rMoveTo(-b * (sl + 10), 0);\n\t\t\tpathForTurn.rLineTo(0, -lh);\n\t\t\t// 1st arc\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY, b * quadShiftX, -quadShiftY);\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, -quadShiftY);\n\t\t\t// center\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, -harrowL / 2); // center\n\t\t\tpathForTurn.rLineTo(-b*harrowL / 2, harrowL / 2);\n\t\t\tpathForTurn.rLineTo(b*hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(0, h );\n\t\t\t// 2nd arc\n\t\t\tpathForTurn.rQuadTo(0, quadShiftY - th, -b * (quadShiftX - th), quadShiftY- th);\n\t\t\t//1st arc\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX + th), 0, -b * (quadShiftX + th ), quadShiftY + th);\n\t\t\tpathForTurn.rLineTo(0, lh );\n\n\t\t} else if (TurnType.TSLR == turnType.getValue() || TurnType.TSLL == turnType.getValue()) {\n\t\t\tint b = TurnType.TSLR == turnType.getValue() ? 1 : -1;\n\t\t\tint h = 24;\n\t\t\tint quadShiftY = 22;\n\t\t\tfloat quadShiftX = (float) (quadShiftY / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = (sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShifty = quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * 4, 0);\n\t\t\tpathForTurn.rLineTo(0, -h /* + partArrowL */);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftY + quadShiftX /*- partArrowL*/, b * quadShiftX, -quadShiftY /*- partArrowL*/);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(0, -sarrowL); // center\n\t\t\tpathForTurn.rLineTo(-b * sarrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rQuadTo(b * nQuadShiftX, -nQuadShiftX, b * nQuadShiftX, nQuadShifty);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.TSHR == turnType.getValue() || TurnType.TSHL == turnType.getValue()) {\n\t\t\tint b = TurnType.TSHR == turnType.getValue() ? 1 : -1;\n\t\t\tint h = 28;\n\t\t\tfloat quadShiftX = 22;\n\t\t\tint sh = 10;\n\t\t\tfloat quadShiftY = -(float) (quadShiftX / (1 + Math.sqrt(2)));\n\t\t\tfloat nQuadShiftX = -(sarrowL - 2 * spartArrowL) - quadShiftX - th;\n\t\t\tfloat nQuadShiftY = -quadShiftY + (sarrowL - 2 * spartArrowL);\n\n\t\t\tpathForTurn.rMoveTo(-b * sh, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftX - quadShiftY), b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rLineTo(b * sarrowL, 0); // center\n\t\t\tpathForTurn.rLineTo(0, -sarrowL);\n\t\t\tpathForTurn.rLineTo(-b * spartArrowL, spartArrowL);\n\t\t\tpathForTurn.rCubicTo(b * nQuadShiftX / 2, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftX / 2, b * nQuadShiftX, nQuadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if(TurnType.TU == turnType.getValue() || TurnType.TRU == turnType.getValue()) {\n\t\t\tint h = 40;\n\t\t\t// right left\n\t\t\tint b = TurnType.TU == turnType.getValue() ? 1 : -1;\n\t\t\tfloat quadShiftX = 10; // 13\n\t\t\tfloat quadShiftY = 10; // 13\n\t\t\tint sm = 10;\n\n\t\t\tpathForTurn.rMoveTo(b * 28, 0);\n\t\t\tpathForTurn.rLineTo(0, -h);\n\t\t\tpathForTurn.rQuadTo(0, -(quadShiftY+th), -b * (quadShiftX+th), -(quadShiftY+th));\n\t\t\tpathForTurn.rQuadTo(-b * (quadShiftX+th), 0, -b * (quadShiftX+th), (quadShiftY+th));\n\t\t\tpathForTurn.rLineTo(0, sm);\n\n\t\t\tpathForTurn.rLineTo(-b * hpartArrowL, 0);\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, harrowL/2); // center\n\t\t\tpathForTurn.rLineTo(b * harrowL/2, -harrowL/2);\n\t\t\tpathForTurn.rLineTo(-b  *hpartArrowL, 0);\n\n\t\t\tpathForTurn.rLineTo(0, -sm);\n\t\t\tpathForTurn.rQuadTo(0, -quadShiftX, b *quadShiftX, -quadShiftY);\n\t\t\tpathForTurn.rQuadTo(b * quadShiftX, 0, b * quadShiftX, quadShiftY);\n\t\t\tpathForTurn.rLineTo(0, h);\n\t\t} else if (TurnType.OFFR == turnType.getValue()){\n\t\t\tint h = (int) (ha - hpartArrowL - 16);\n\t\t\tpathForTurn.rMoveTo(th, 0); //12 0\n\t\t\t//first square\n\t\t\tpathForTurn.rLineTo(0, -h / 4); //0 -7\n\t\t\tpathForTurn.rLineTo(-th, 0); //-12 0\n\t\t\tpathForTurn.rLineTo(0, h / 4); //0 7\n\t\t\tpathForTurn.rLineTo(th, 0); //12 0\n\t\t\tpathForTurn.rMoveTo(0, -h / 2); //12 0\n\t\t\t//second square\n\t\t\tpathForTurn.rLineTo(0, -h / 4); //0 -7\n\t\t\tpathForTurn.rLineTo(-th, 0); //-12 0\n\t\t\tpathForTurn.rLineTo(0, h / 4); //0 7\n\t\t\tpathForTurn.rLineTo(th, 0); //12 0\n\t\t\tpathForTurn.rMoveTo(0, -h / 2 + 1); //31 0\n\t\t\t//arrow\n\t\t\tpathForTurn.rLineTo(hpartArrowL, 0); //9 0\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, -harrowL / 2); // center -15 -15\n\t\t\tpathForTurn.rLineTo(-harrowL / 2, harrowL / 2); // -15 15\n\t\t\tpathForTurn.rLineTo(hpartArrowL + th, 0); //9 0\n\t\t} else if (turnType != null && turnType.isRoundAbout()) {\n\t\t\tfloat t = turnType.getTurnAngle();\n\t\t\tif (t >= 170 && t < 220) {\n\t\t\t\tt = 220;\n\t\t\t} else if (t > 160 && t < 170) {\n\t\t\t\tt = 160;\n\t\t\t}\n\t\t\tboolean leftSide = turnType.isLeftSide();\n\t\t\tfloat sweepAngle = (t - 360) - 180;\n\t\t\tif (sweepAngle < -360) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\tif(leftSide && sweepAngle < 0) {\n\t\t\t\tsweepAngle += 360;\n\t\t\t}\n\t\t\t\n\t\t\tfloat r1 = ha / 3f - 1;\n\t\t\tfloat r2 = r1 - 9;\n\t\t\tfloat angleToRot = leftSide ? -0.3f : 0.3f;\n\t\t\tint cx = wa / 2 ;\n\t\t\tint cy = ha / 2 - 2;\n\t\t\tif (leftSide) {\n\t\t\t\tpathForTurn.moveTo(cx - 8, ha - 1);\n\t\t\t\tpathForTurn.lineTo(cx - 8, cy + r1);\n\t\t\t} else {\n\t\t\t\tpathForTurn.moveTo(cx, ha - 1);\n\t\t\t\tpathForTurn.lineTo(cx, cy + r1);\n\t\t\t}\n\t\t\tRectF r = new RectF(cx - r1, cy - r1, cx + r1, cy + r1);\n\t\t\t\n\t\t\tint out = turnType.getExitOut();\n\t\t\tif (out < 1) {\n\t\t\t\tout = 1;\n\t\t\t}\n\t\t\tfloat prev = 90;\n\t\t\tfloat init = 90;\n\t\t\t\n\t\t\tfloat step = sweepAngle / out;\n\t\t\tfor (int i = 1; i <= out; i++) {\n\t\t\t\tfloat to = step * i;\n\t\t\t\tif (i == out) {\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - prev + init);\n\t\t\t\t} else {\n\t\t\t\t\tfloat tsRad = (float) ((to - step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tfloat tsRad2 = (float) ((to + step / 8 + 180) * Math.PI / 180f);\n\t\t\t\t\tpathForTurn.arcTo(r, prev, to - step / 6 - prev + init );\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * (float) Math.sin(tsRad), cy - (r1 + 10) * (float) Math.cos(tsRad));\n\t\t\t\t\tpathForTurn.lineTo(cx + (r1 + 10) * (float) Math.sin(tsRad2), cy - (r1 + 10) * (float) Math.cos(tsRad2));\n\t\t\t\t\t// not necessary for next arcTo\n\t\t\t\t\t//pathForTurn.lineTo(cx + (r1 + 0) * (float) Math.sin(tsRad2), cy - (r1 + 0) * (float) Math.cos(tsRad2));\n\t\t\t\t\tprev = to + step / 6 + init;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tfloat angleRad = (float) ((180 + sweepAngle) * Math.PI / 180f);\n\t\t\t\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * (float) Math.sin(angleRad), cy - (r1 + 4) * (float) Math.cos(angleRad));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * (float) Math.sin(angleRad + angleToRot/2), cy - (r1 + 6) * (float) Math.cos(angleRad + angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 14) * (float) Math.sin(angleRad - angleToRot/2), cy - (r1 + 12) * (float) Math.cos(angleRad - angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 6) * (float) Math.sin(angleRad - 3*angleToRot/2), cy - (r1 + 6) * (float) Math.cos(angleRad - 3*angleToRot/2));\n\t\t\tpathForTurn.lineTo(cx + (r1 + 4) * (float) Math.sin(angleRad - angleToRot), cy - (r1 + 4) * (float) Math.cos(angleRad - angleToRot));\n\t\t\tpathForTurn.lineTo(cx + r2 * (float) Math.sin(angleRad - angleToRot), cy - r2 * (float) Math.cos(angleRad - angleToRot));\n\t\t\t\n\t\t\tr.set(cx - r2, cy - r2, cx + r2, cy + r2);\n\t\t\tpathForTurn.arcTo(r, 360 + sweepAngle + 90, -sweepAngle);\n\t\t\tif (leftSide) {\n\t\t\t\tpathForTurn.lineTo(cx, cy + r2);\n\t\t\t\tpathForTurn.lineTo(cx, ha - 1);\n\t\t\t} else {\n\t\t\t\tpathForTurn.lineTo(cx - 8, cy + r2);\n\t\t\t\tpathForTurn.lineTo(cx - 8, ha - 1);\n\t\t\t}\n\t\t\tpathForTurn.close();\n\t\t}\n\t\tpathForTurn.close();\n\t\tif(transform != null){\n\t\t\tpathForTurn.transform(transform);\n\t\t}\n\t}","commit_id":"f80f6338dd20f6914835daa77da006d265d01f13","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/** \n     * An annotation has been parsed. Always invoked AFTER the \"method\"/\"field\"/\"classBegin\" callbacks. \n     */\n    @Override\n    public void annotation(Annotation annotation)\n    {\n        m_reporter.trace(\"Parsed annotation: %s\", annotation);\n\n        if (annotation.getName().equals(A_SERVICE))\n        {\n            parseServiceAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_ASPECT_SERVICE))\n        {\n            parseAspectService(annotation);\n        }\n        else if (annotation.getName().equals(A_ADAPTER_SERVICE))\n        {\n            parseAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_BUNDLE_ADAPTER_SERVICE))\n        {\n            parseBundleAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_RESOURCE_ADAPTER_SERVICE))\n        {\n            parseResourceAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_FACTORYCONFIG_ADAPTER_SERVICE))\n        {\n            parseFactoryConfigurationAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_INIT))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_initMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_START))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_startMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_STOP))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_stopMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_DESTROY))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_destroyMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_COMPOSITION))\n        {\n            Patterns.parseMethod(m_method, m_descriptor, Patterns.COMPOSITION);\n            m_compositionMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_SERVICE_DEP))\n        {\n            parseServiceDependencyAnnotation(annotation, false);\n        }\n        else if (annotation.getName().equals(A_CONFIGURATION_DEPENDENCY))\n        {\n            parseConfigurationDependencyAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_TEMPORAL_SERVICE_DEPENDENCY))\n        {\n            parseServiceDependencyAnnotation(annotation, true);\n        }\n        else if (annotation.getName().equals(A_BUNDLE_DEPENDENCY))\n        {\n            parseBundleDependencyAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_RESOURCE_DEPENDENCY))\n        {\n            parseRersourceDependencyAnnotation(annotation);\n        }\n    }","id":9969,"modified_method":"/** \n     * An annotation has been parsed. Always invoked AFTER the \"method\"/\"field\"/\"classBegin\" callbacks. \n     */\n    @Override\n    public void annotation(Annotation annotation)\n    {\n        m_reporter.trace(\"Parsed annotation: %s\", annotation);\n\n        if (annotation.getName().equals(A_SERVICE))\n        {\n            parseServiceAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_ASPECT_SERVICE))\n        {\n            parseAspectService(annotation);\n        }\n        else if (annotation.getName().equals(A_ADAPTER_SERVICE))\n        {\n            parseAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_BUNDLE_ADAPTER_SERVICE))\n        {\n            parseBundleAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_RESOURCE_ADAPTER_SERVICE))\n        {\n            parseResourceAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_FACTORYCONFIG_ADAPTER_SERVICE))\n        {\n            parseFactoryConfigurationAdapterService(annotation);\n        }\n        else if (annotation.getName().equals(A_INIT))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_initMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_START))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_startMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_STOP))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_stopMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_DESTROY))\n        {\n            //Patterns.parseMethod(m_method, m_descriptor, Patterns.VOID);\n            // TODO check if method takes optional params like Service, DependencyManager, etc ...\n            m_destroyMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_COMPOSITION))\n        {\n            Patterns.parseMethod(m_method, m_descriptor, Patterns.COMPOSITION);\n            m_compositionMethod = m_method;\n        }\n        else if (annotation.getName().equals(A_SERVICE_DEP))\n        {\n            parseServiceDependencyAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_CONFIGURATION_DEPENDENCY))\n        {\n            parseConfigurationDependencyAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_BUNDLE_DEPENDENCY))\n        {\n            parseBundleDependencyAnnotation(annotation);\n        }\n        else if (annotation.getName().equals(A_RESOURCE_DEPENDENCY))\n        {\n            parseRersourceDependencyAnnotation(annotation);\n        }\n    }","commit_id":"4e06b5a41e0148b800bbea7759d81320eeb251d7","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses a ServiceDependency or a TemporalServiceDependency Annotation.\n     * @param annotation the ServiceDependency Annotation.\n     */\n    private void parseServiceDependencyAnnotation(Annotation annotation, boolean temporal)\n    {\n        EntryWriter writer = new EntryWriter(temporal ? EntryType.TemporalServiceDependency\n            : EntryType.ServiceDependency);\n        m_writers.add(writer);\n\n        // service attribute\n        String service = annotation.get(EntryParam.service.toString());\n        if (service != null)\n        {\n            service = Patterns.parseClass(service, Patterns.CLASS, 1);\n        }\n        else\n        {\n            if (m_isField)\n            {\n                service = Patterns.parseClass(m_descriptor, Patterns.CLASS, 1);\n            }\n            else\n            {\n                service = Patterns.parseClass(m_descriptor, Patterns.BIND_CLASS, 2);\n            }\n        }\n        writer.put(EntryParam.service, service);\n\n        // autoConfig attribute\n        if (m_isField)\n        {\n            writer.put(EntryParam.autoConfig, m_field);\n        }\n\n        // filter attribute\n        String filter = annotation.get(EntryParam.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            writer.put(EntryParam.filter, filter);\n        }\n\n        // defaultImpl attribute\n        writer.putClass(annotation, EntryParam.defaultImpl, null);\n\n        // added callback\n        writer.putString(annotation, EntryParam.added, (!m_isField) ? m_method : null);\n\n        if (temporal)\n        {\n            // timeout attribute (only valid if parsing a temporal service dependency)\n            writer.putString(annotation, EntryParam.timeout, null);\n        }\n        else\n        {\n            // required attribute (not valid if parsing a temporal service dependency)\n            writer.putString(annotation, EntryParam.required, null);\n\n            // changed callback\n            writer.putString(annotation, EntryParam.changed, null);\n\n            // removed callback\n            writer.putString(annotation, EntryParam.removed, null);\n        }\n    }","id":9970,"modified_method":"/**\n     * Parses a ServiceDependency Annotation.\n     * @param annotation the ServiceDependency Annotation.\n     */\n    private void parseServiceDependencyAnnotation(Annotation annotation)\n    {\n        EntryWriter writer = new EntryWriter(EntryType.ServiceDependency);\n        m_writers.add(writer);\n\n        // service attribute\n        String service = annotation.get(EntryParam.service.toString());\n        if (service != null)\n        {\n            service = Patterns.parseClass(service, Patterns.CLASS, 1);\n        }\n        else\n        {\n            if (m_isField)\n            {\n                service = Patterns.parseClass(m_descriptor, Patterns.CLASS, 1);\n            }\n            else\n            {\n                service = Patterns.parseClass(m_descriptor, Patterns.BIND_CLASS, 2);\n            }\n        }\n        writer.put(EntryParam.service, service);\n\n        // autoConfig attribute\n        if (m_isField)\n        {\n            writer.put(EntryParam.autoConfig, m_field);\n        }\n\n        // filter attribute\n        String filter = annotation.get(EntryParam.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            writer.put(EntryParam.filter, filter);\n        }\n\n        // defaultImpl attribute\n        writer.putClass(annotation, EntryParam.defaultImpl, null);\n\n        // added callback\n        writer.putString(annotation, EntryParam.added, (!m_isField) ? m_method : null);\n\n        // timeout parameter\n        writer.putString(annotation, EntryParam.timeout, null);\n        Long t = (Long) annotation.get(EntryParam.timeout.toString());\n        if (t != null && t.longValue() < -1)\n        {\n            throw new IllegalArgumentException(\"Invalid timeout value \" + t + \" in ServiceDependency annotation in class \" + m_className);\n        }\n        \n        // required attribute (not valid if parsing a temporal service dependency)\n        writer.putString(annotation, EntryParam.required, null);\n\n        // changed callback\n        writer.putString(annotation, EntryParam.changed, null);\n\n        // removed callback\n        writer.putString(annotation, EntryParam.removed, null);       \n    }","commit_id":"4e06b5a41e0148b800bbea7759d81320eeb251d7","url":"https://github.com/apache/felix"},{"original_method":"private Dependency createServiceDependency(DependencyManager dm, boolean temporal,\n        Class<?> serviceClass, String serviceFilter, Class<?> defaultServiceImplClass, String added,\n        String changed, String removed, String autoConfigField, String timeout, boolean required,\n        boolean instanceBound)\n    {\n        ServiceDependency sd = temporal ? dm.createTemporalServiceDependency()\n            : dm.createServiceDependency();\n        sd.setService(serviceClass, serviceFilter);\n        if (defaultServiceImplClass != null)\n        {\n            sd.setDefaultImplementation(defaultServiceImplClass);\n        }\n        sd.setCallbacks(added, changed, removed);\n        if (autoConfigField != null)\n        {\n            sd.setAutoConfig(autoConfigField);\n        }\n        if (temporal)\n        {\n            // Set the timeout value for a temporal service dependency\n            if (timeout != null)\n            {\n                ((TemporalServiceDependency) sd).setTimeout(Long.parseLong(timeout));\n            }\n            // Set required flag (always true for a temporal dependency)\n            sd.setRequired(true);\n        }\n        else\n        {\n            // for ServiceDependency, get required flag.\n            sd.setRequired(required);\n        }\n        \n        sd.setInstanceBound(instanceBound);\n        return sd;\n    }","id":9971,"modified_method":"private Dependency createServiceDependency(DependencyManager dm, Class<?> serviceClass, \n        String serviceFilter, Class<?> defaultServiceImplClass, String added,\n        String changed, String removed, String autoConfigField, long timeout, boolean required,\n        boolean instanceBound)\n    {\n        ServiceDependency sd = timeout != -1 ? dm.createTemporalServiceDependency()\n            : dm.createServiceDependency();\n        sd.setService(serviceClass, serviceFilter);\n        if (defaultServiceImplClass != null)\n        {\n            sd.setDefaultImplementation(defaultServiceImplClass);\n        }\n        sd.setCallbacks(added, changed, removed);\n        if (autoConfigField != null)\n        {\n            sd.setAutoConfig(autoConfigField);\n        }\n        if (timeout != -1)\n        {\n            ((TemporalServiceDependency) sd).setTimeout(timeout);\n            // Set required flag (always true for a temporal dependency)\n            sd.setRequired(true);\n        }\n        else\n        {\n            // for ServiceDependency, get required flag.\n            sd.setRequired(required);\n        }\n        \n        sd.setInstanceBound(instanceBound);\n        return sd;\n    }","commit_id":"4e06b5a41e0148b800bbea7759d81320eeb251d7","url":"https://github.com/apache/felix"},{"original_method":"private Dependency createServiceDependency(Bundle b, DependencyManager dm, boolean temporal,\n        boolean instanceBound)\n        throws ClassNotFoundException\n    {\n        String service = m_metaData.getString(Params.service);\n        Class<?> serviceClass = b.loadClass(service);\n        String serviceFilter = m_metaData.getString(Params.filter, null);\n        String defaultServiceImpl = m_metaData.getString(Params.defaultImpl, null);\n        Class<?> defaultServiceImplClass =\n            (defaultServiceImpl != null) ? b.loadClass(defaultServiceImpl) : null;\n        String added = m_metaData.getString(Params.added, null);\n        String changed = temporal ? null : m_metaData.getString(Params.changed, null);\n        String removed = temporal ? null : m_metaData.getString(Params.removed, null);\n        String autoConfigField = m_metaData.getString(Params.autoConfig, null);\n        boolean required = \"true\".equals(m_metaData.getString(Params.required, \"true\"));\n        String timeout = m_metaData.getString(Params.timeout, null);\n\n        Dependency dp = createServiceDependency(dm, temporal, serviceClass,\n            serviceFilter, defaultServiceImplClass, added, changed,\n            removed, autoConfigField, timeout, required, instanceBound);\n        return dp;\n    }","id":9972,"modified_method":"private Dependency createServiceDependency(Bundle b, DependencyManager dm, boolean instanceBound)\n        throws ClassNotFoundException\n    {\n        String service = m_metaData.getString(Params.service);\n        Class<?> serviceClass = b.loadClass(service);\n        String serviceFilter = m_metaData.getString(Params.filter, null);\n        String defaultServiceImpl = m_metaData.getString(Params.defaultImpl, null);\n        Class<?> defaultServiceImplClass =\n            (defaultServiceImpl != null) ? b.loadClass(defaultServiceImpl) : null;\n        String added = m_metaData.getString(Params.added, null);\n        long timeout = m_metaData.getLong(Params.timeout, -1L);\n        String changed = timeout != -1 ? null : m_metaData.getString(Params.changed, null);\n        String removed = timeout != -1 ? null : m_metaData.getString(Params.removed, null);\n        String autoConfigField = m_metaData.getString(Params.autoConfig, null);\n        boolean required = \"true\".equals(m_metaData.getString(Params.required, \"true\"));\n\n        Dependency dp = createServiceDependency(dm, serviceClass,\n            serviceFilter, defaultServiceImplClass, added, changed,\n            removed, autoConfigField, timeout, required, instanceBound);\n        return dp;\n    }","commit_id":"4e06b5a41e0148b800bbea7759d81320eeb251d7","url":"https://github.com/apache/felix"},{"original_method":"public Dependency build(Bundle b, DependencyManager dm, boolean instanceBound)\n        throws Exception\n    {\n        Dependency dp = null;\n        DependencyType type;\n\n        try\n        {\n            type = DependencyType.valueOf(m_metaData.getString(Params.type));\n        }\n        catch (IllegalArgumentException e)\n        {\n            throw new IllegalArgumentException(\"no \\\"type\\\" parameter found from metaData: \" + m_metaData);\n        }\n\n        switch (type)\n        {\n            case ServiceDependency:\n                dp = createServiceDependency(b, dm, false, instanceBound);\n                break;\n\n            case TemporalServiceDependency:\n                dp = createServiceDependency(b, dm, true, instanceBound);\n                break;\n\n            case ConfigurationDependency:\n                dp = createConfigurationDependency(dm, instanceBound);\n                break;\n\n            case BundleDependency:\n                dp = createBundleDependency(dm, instanceBound);\n                break;\n\n            case ResourceDependency:\n                dp = createResourceDependency(dm, instanceBound);\n                break;\n        }\n        return dp;\n    }","id":9973,"modified_method":"public Dependency build(Bundle b, DependencyManager dm, boolean instanceBound)\n        throws Exception\n    {\n        Dependency dp = null;\n        DependencyType type;\n\n        try\n        {\n            type = DependencyType.valueOf(m_metaData.getString(Params.type));\n        }\n        catch (IllegalArgumentException e)\n        {\n            throw new IllegalArgumentException(\"no \\\"type\\\" parameter found from metaData: \" + m_metaData);\n        }\n\n        switch (type)\n        {\n            case ServiceDependency:\n                dp = createServiceDependency(b, dm, instanceBound);\n                break;\n\n            case ConfigurationDependency:\n                dp = createConfigurationDependency(dm, instanceBound);\n                break;\n\n            case BundleDependency:\n                dp = createBundleDependency(dm, instanceBound);\n                break;\n\n            case ResourceDependency:\n                dp = createResourceDependency(dm, instanceBound);\n                break;\n        }\n        return dp;\n    }","commit_id":"4e06b5a41e0148b800bbea7759d81320eeb251d7","url":"https://github.com/apache/felix"},{"original_method":"protected EOModel dbUpdaterModelWithModel(EOModel model, JDBCAdaptor adaptor) {\n\t\tEOModel dbUpdaterModel;\n\t\tif (_lastUpdatedModel == model) {\n\t\t\tdbUpdaterModel = _dbUpdaterModelCache;\n\t\t}\n\t\telse {\n\t\t\tdbUpdaterModel = new EOModel();\n\t\t\tdbUpdaterModel.setConnectionDictionary(model.connectionDictionary());\n\t\t\tdbUpdaterModel.setAdaptorName(model.adaptorName());\n\n\t\t\tEOEntity dbUpdaterEntity = new EOEntity();\n\t\t\tdbUpdaterEntity.setExternalName(_dbUpdaterTableName);\n\t\t\tdbUpdaterEntity.setName(_dbUpdaterTableName);\n\t\t\tdbUpdaterModel.addEntity(dbUpdaterEntity);\n\n\t\t\tEOAttribute modelNameAttribute = new EOAttribute();\n\t\t\tmodelNameAttribute.setName(\"modelName\");\n\t\t\tmodelNameAttribute.setColumnName(\"modelname\");\n\t\t\tmodelNameAttribute.setClassName(\"java.lang.String\");\n\t\t\tmodelNameAttribute.setWidth(100);\n\t\t\tmodelNameAttribute.setAllowsNull(false);\n\t\t\t\n\t\t\tmodelNameAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.VARCHAR));\n\t\t\tdbUpdaterEntity.addAttribute(modelNameAttribute);\n\n\t\t\tEOAttribute versionAttribute = new EOAttribute();\n\t\t\tversionAttribute.setName(\"version\");\n\t\t\tversionAttribute.setColumnName(\"version\");\n\t\t\tversionAttribute.setClassName(\"java.lang.Number\");\n\t\t\tversionAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.INTEGER));\n\t\t\tversionAttribute.setAllowsNull(false);\n\n\t\t\tdbUpdaterEntity.addAttribute(versionAttribute);\n\n\t\t\tEOAttribute updateLockAttribute = new EOAttribute();\n\t\t\tupdateLockAttribute.setName(\"updateLock\");\n\t\t\tupdateLockAttribute.setColumnName(\"updatelock\");\n\t\t\tupdateLockAttribute.setClassName(\"java.lang.Number\");\n\t\t\tupdateLockAttribute.setAllowsNull(false);\n\t\t\tupdateLockAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.INTEGER));\n\t\t\tdbUpdaterEntity.addAttribute(updateLockAttribute);\n\n\t\t\tEOAttribute lockOwnerAttribute = new EOAttribute();\n\t\t\tlockOwnerAttribute.setName(\"lockOwner\");\n\t\t\tlockOwnerAttribute.setColumnName(\"lockowner\");\n\t\t\tlockOwnerAttribute.setClassName(\"java.lang.String\");\n\t\t\tlockOwnerAttribute.setWidth(100);\n\t\t\tlockOwnerAttribute.setAllowsNull(true);\n\t\t\tlockOwnerAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.VARCHAR));\n\t\t\tdbUpdaterEntity.addAttribute(lockOwnerAttribute);\n\n\t\t\t_lastUpdatedModel = model;\n\t\t\t_dbUpdaterModelCache = dbUpdaterModel;\n\t\t}\n\t\treturn dbUpdaterModel;\n\t}","id":9974,"modified_method":"protected EOModel dbUpdaterModelWithModel(EOModel model, JDBCAdaptor adaptor) {\n\t\tEOModel dbUpdaterModel;\n\t\tif (_lastUpdatedModel == model) {\n\t\t\tdbUpdaterModel = _dbUpdaterModelCache;\n\t\t}\n\t\telse {\n\t\t\tERXModelGroup modelGroup = (ERXModelGroup) model.modelGroup();\n\t\t\tEOEntity prototypeEntity = modelGroup.entityNamed(modelGroup.prototypeEntityNameForModel(model));\n\t\t\tboolean isWonderPrototype = (prototypeEntity != null && prototypeEntity.model().name().equals(\"erprototypes\"));\n\n\t\t\tdbUpdaterModel = new EOModel();\n\t\t\tdbUpdaterModel.setConnectionDictionary(model.connectionDictionary());\n\t\t\tdbUpdaterModel.setAdaptorName(model.adaptorName());\n\n\t\t\tEOEntity dbUpdaterEntity = new EOEntity();\n\t\t\tdbUpdaterEntity.setExternalName(_dbUpdaterTableName);\n\t\t\tdbUpdaterEntity.setName(_dbUpdaterTableName);\n\t\t\tdbUpdaterModel.addEntity(dbUpdaterEntity);\n\n\t\t\tEOAttribute modelNameAttribute = new EOAttribute();\n\t\t\tif (isWonderPrototype) {\n\t\t\t\tmodelNameAttribute.setExternalType(prototypeEntity.attributeNamed(\"varchar100\").externalType());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmodelNameAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.VARCHAR));\n\t\t\t}\n\t\t\tmodelNameAttribute.setName(\"modelName\");\n\t\t\tmodelNameAttribute.setColumnName(\"modelname\");\n\t\t\tmodelNameAttribute.setClassName(\"java.lang.String\");\n\t\t\tmodelNameAttribute.setWidth(100);\n\t\t\tmodelNameAttribute.setAllowsNull(false);\n\t\t\tdbUpdaterEntity.addAttribute(modelNameAttribute);\n\n\t\t\tEOAttribute versionAttribute = new EOAttribute();\n\t\t\tif (isWonderPrototype) {\n\t\t\t\tversionAttribute.setExternalType(prototypeEntity.attributeNamed(\"intNumber\").externalType());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tversionAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.INTEGER));\n\t\t\t}\n\t\t\tversionAttribute.setName(\"version\");\n\t\t\tversionAttribute.setColumnName(\"version\");\n\t\t\tversionAttribute.setClassName(\"java.lang.Number\");\n\t\t\tversionAttribute.setAllowsNull(false);\n\t\t\tdbUpdaterEntity.addAttribute(versionAttribute);\n\n\t\t\tEOAttribute updateLockAttribute = new EOAttribute();\n\t\t\tif (isWonderPrototype) {\n\t\t\t\tupdateLockAttribute.setExternalType(prototypeEntity.attributeNamed(\"intNumber\").externalType());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tupdateLockAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.INTEGER));\n\t\t\t}\n\t\t\tupdateLockAttribute.setName(\"updateLock\");\n\t\t\tupdateLockAttribute.setColumnName(\"updatelock\");\n\t\t\tupdateLockAttribute.setClassName(\"java.lang.Number\");\n\t\t\tupdateLockAttribute.setAllowsNull(false);\n\t\t\tdbUpdaterEntity.addAttribute(updateLockAttribute);\n\n\t\t\tEOAttribute lockOwnerAttribute = new EOAttribute();\n\t\t\tif (isWonderPrototype) {\n\t\t\t\tlockOwnerAttribute.setExternalType(prototypeEntity.attributeNamed(\"varchar100\").externalType());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlockOwnerAttribute.setExternalType(adaptor.externalTypeForJDBCType(Types.VARCHAR));\n\t\t\t}\n\t\t\tlockOwnerAttribute.setName(\"lockOwner\");\n\t\t\tlockOwnerAttribute.setColumnName(\"lockowner\");\n\t\t\tlockOwnerAttribute.setClassName(\"java.lang.String\");\n\t\t\tlockOwnerAttribute.setWidth(100);\n\t\t\tlockOwnerAttribute.setAllowsNull(true);\n\t\t\tdbUpdaterEntity.addAttribute(lockOwnerAttribute);\n\n\t\t\t_lastUpdatedModel = model;\n\t\t\t_dbUpdaterModelCache = dbUpdaterModel;\n\t\t}\n\t\treturn dbUpdaterModel;\n\t}","commit_id":"d575f0023d8278f66c99b902343f9d9a2aacbcab","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     *\n     */\n    public void testProblemFinder()\n    {\n        final MarkupParser parser = new MarkupParser(null, new XmlPullParser(null))\n        {\n            public void initFilterChain()\n            {\n                appendMarkupFilter(new HtmlProblemFinder(HtmlProblemFinder.ERR_THROW_EXCEPTION));\n            }\n        };\n\t    \n\t    try\n\t    {\n\t        parser.parse(\"<img src=\\\"\\\"/>\");\n\t        assertTrue(\"Should have thrown an exception\", false);\n\t    }\n\t    catch (Exception ex)\n\t    {\n\t        // ignore\n\t    }\n    }","id":9975,"modified_method":"/**\n     *\n     */\n    public void testProblemFinder()\n    {\n        final MarkupParser parser = new MarkupParser(null, new XmlPullParser())\n        {\n            public void initFilterChain()\n            {\n                appendMarkupFilter(new HtmlProblemFinder(HtmlProblemFinder.ERR_THROW_EXCEPTION));\n            }\n        };\n\t    \n\t    try\n\t    {\n\t        parser.parse(\"<img src=\\\"\\\"/>\");\n\t        assertTrue(\"Should have thrown an exception\", false);\n\t    }\n\t    catch (Exception ex)\n\t    {\n\t        // ignore\n\t    }\n    }","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Reads and parses markup from a file.\n\t * \n\t * @param resource\n\t *            The file\n\t * @return The markup\n\t * @throws IOException\n\t * @throws ResourceStreamNotFoundException\n\t */\n\tfinal Markup readAndParse(final MarkupResourceStream resource) throws IOException, \n\t\t\tResourceStreamNotFoundException\n\t{\n\t\t// Remove all existing markup elements\n\t\tthis.markup.reset();\n\n\t\t// For diagnostic purposes\n\t\tthis.markup.setResource(resource);\n\n\t\t// Initialize the xml parser\n\t\tthis.xmlParser.parse(resource);\n\n\t\t// parse the xml markup and tokenize it into wicket relevant markup\n\t\t// elements\n\t\tparseMarkup();\n\n\t\tthis.markup.setEncoding(xmlParser.getEncoding());\n\t\tthis.markup.setXmlDeclaration(xmlParser.getXmlDeclaration());\n\n\t\treturn this.markup;\n\t}","id":9976,"modified_method":"/**\n\t * Reads and parses markup from a file.\n\t * \n\t * @param resource\n\t *            The file\n\t * @return The markup\n\t * @throws IOException\n\t * @throws ResourceStreamNotFoundException\n\t */\n\tfinal Markup readAndParse(final MarkupResourceStream resource) throws IOException,\n\t\t\tResourceStreamNotFoundException\n\t{\n\t\t// Remove all existing markup elements\n\t\tthis.markup.reset();\n\n\t\t// For diagnostic purposes\n\t\tthis.markup.setResource(resource);\n\n\t\t// Initialize the xml parser\n\t\tthis.xmlParser.parse(resource, this.application.getMarkupSettings().getDefaultMarkupEncoding());\n\n\t\t// parse the xml markup and tokenize it into wicket relevant markup\n\t\t// elements\n\t\tparseMarkup();\n\n\t\tthis.markup.setEncoding(xmlParser.getEncoding());\n\t\tthis.markup.setXmlDeclaration(xmlParser.getXmlDeclaration());\n\n\t\treturn this.markup;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.IMarkupParserFactory#newMarkupParser()\n\t */\n\tpublic MarkupParser newMarkupParser()\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(application\n\t\t\t\t.getMarkupSettings().getDefaultMarkupEncoding()))\n\t\t{\n\t\t\tpublic void initFilterChain()\n\t\t\t{\n\t\t\t\tif (filters != null)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < filters.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendMarkupFilter(filters[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn parser;\n\t}","id":9977,"modified_method":"/**\n\t * @see wicket.markup.IMarkupParserFactory#newMarkupParser()\n\t */\n\tpublic MarkupParser newMarkupParser()\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser())\n\t\t{\n\t\t\tpublic void initFilterChain()\n\t\t\t{\n\t\t\t\tif (filters != null)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i < filters.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendMarkupFilter(filters[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn parser;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test &lt;wicket: .\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testScript() throws ParseException, ResourceStreamNotFoundException,\n\t\t\tIOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\n\t\tMarkup markup = parser\n\t\t\t\t.parse(\"<html wicket:id=\\\"test\\\"><script language=\\\"JavaScript\\\">... <x a> ...<\/script><\/html>\");\n\t\tassertEquals(3, markup.size());\n\t\tassertEquals(\"html\", ((ComponentTag)markup.get(0)).getName());\n\t\tassertEquals(\"html\", ((ComponentTag)markup.get(2)).getName());\n\t\tassertEquals(true, markup.get(1) instanceof RawMarkup);\n\t\tassertEquals(\"<script language=\\\"JavaScript\\\">... <x a> ...<\/script>\", ((RawMarkup)markup\n\t\t\t\t.get(1)).toString());\n\t}","id":9978,"modified_method":"/**\n\t * Test &lt;wicket: .\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testScript() throws ParseException, ResourceStreamNotFoundException,\n\t\t\tIOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\n\t\tMarkup markup = parser\n\t\t\t\t.parse(\"<html wicket:id=\\\"test\\\"><script language=\\\"JavaScript\\\">... <x a> ...<\/script><\/html>\");\n\t\tassertEquals(3, markup.size());\n\t\tassertEquals(\"html\", ((ComponentTag)markup.get(0)).getName());\n\t\tassertEquals(\"html\", ((ComponentTag)markup.get(2)).getName());\n\t\tassertEquals(true, markup.get(1) instanceof RawMarkup);\n\t\tassertEquals(\"<script language=\\\"JavaScript\\\">... <x a> ...<\/script>\", ((RawMarkup)markup\n\t\t\t\t.get(1)).toString());\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test &lt;wicket: .\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testDefaultWicketTag() throws ParseException,\n\t\t\tResourceStreamNotFoundException, IOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\t\tparser.setWicketNamespace(\"wcn\");\n\n\t\tMarkup markup = parser.parse(\"<span wcn:id=\\\"test\\\"/>\");\n\t\tassertEquals(1, markup.size());\n\n\t\tmarkup = parser.parse(\"<span wicket:id=\\\"test\\\"/>\");\n\t\tassertEquals(1, markup.size());\n\n\t\tmarkup = parser.parse(\"<wcn:xxx>  <\/wcn:xxx>\");\n\t\tassertEquals(3, markup.size());\n\t}","id":9979,"modified_method":"/**\n\t * Test &lt;wicket: .\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testDefaultWicketTag() throws ParseException,\n\t\t\tResourceStreamNotFoundException, IOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\t\tparser.setWicketNamespace(\"wcn\");\n\n\t\tMarkup markup = parser.parse(\"<span wcn:id=\\\"test\\\"/>\");\n\t\tassertEquals(1, markup.size());\n\n\t\tmarkup = parser.parse(\"<span wicket:id=\\\"test\\\"/>\");\n\t\tassertEquals(1, markup.size());\n\n\t\tmarkup = parser.parse(\"<wcn:xxx>  <\/wcn:xxx>\");\n\t\tassertEquals(3, markup.size());\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testFileDocument() throws ParseException, ResourceStreamNotFoundException,\n\t\t\tIOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\t\tparser.setWicketNamespace(\"wcn\");\n\n\t\tIResourceStreamLocator locator = new ClassLoaderResourceStreamLocator();\n\n\t\tMarkupResourceStream resource = newMarkupResourceStream(locator, this.getClass(), \"1\", null, \"html\");\n\n\t\tMarkup tokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"2\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"3\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"4\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\t// File from jar (URL resource)\n\t\tresource = newMarkupResourceStream(locator, PageExpiredErrorPage.class, null, null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"5\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"6\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"7\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"8\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\t}","id":9980,"modified_method":"/**\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testFileDocument() throws ParseException, ResourceStreamNotFoundException,\n\t\t\tIOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\t\tparser.setWicketNamespace(\"wcn\");\n\n\t\tIResourceStreamLocator locator = new ClassLoaderResourceStreamLocator();\n\n\t\tMarkupResourceStream resource = newMarkupResourceStream(locator, this.getClass(), \"1\", null, \"html\");\n\n\t\tMarkup tokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"2\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"3\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"4\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\t// File from jar (URL resource)\n\t\tresource = newMarkupResourceStream(locator, PageExpiredErrorPage.class, null, null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"5\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"6\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"7\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\n\t\tresource = newMarkupResourceStream(locator, this.getClass(), \"8\", null, \"html\");\n\t\ttokens = parser.readAndParse(resource);\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\t// Assert.assertEquals(docText, tokens.get(0).toString());\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @throws Exception\n\t */\n\tpublic final void test() throws Exception\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\t\tparser.setWicketNamespace(\"componentName\");\n\t\tfinal Markup tokens = parser\n\t\t\t\t.parse(\"This is a test <a componentName:id=9> <b>bold<\/b> <b componentName:id=10/><\/a> of the emergency broadcasting system\");\n\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\tlog.info(\"tok(1)=\" + tokens.get(1));\n\t\tlog.info(\"tok(2)=\" + tokens.get(2));\n\t\tlog.info(\"tok(3)=\" + tokens.get(3));\n\t\tlog.info(\"tok(4)=\" + tokens.get(4));\n\t\tlog.info(\"tok(5)=\" + tokens.get(5));\n\n\t\tAssert.assertTrue(tokens.get(0).equals(\"This is a test \"));\n\n\t\tfinal ComponentTag a = (ComponentTag)tokens.get(1);\n\n\t\tAssert.assertEquals(9, a.getAttributes().getInt(\"componentName:id\"));\n\t\tAssert.assertTrue(tokens.get(2).equals(\" <b>bold<\/b> \"));\n\n\t\tfinal ComponentTag b = (ComponentTag)tokens.get(3);\n\n\t\tAssert.assertEquals(10, b.getAttributes().getInt(\"componentName:id\"));\n\n\t\tfinal ComponentTag closeA = (ComponentTag)tokens.get(4);\n\n\t\tAssert.assertEquals(\"a\", closeA.getName());\n\t\tAssert.assertTrue(tokens.get(5).equals(\" of the emergency broadcasting system\"));\n\t}","id":9981,"modified_method":"/**\n\t * \n\t * @throws Exception\n\t */\n\tpublic final void test() throws Exception\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\t\tparser.setWicketNamespace(\"componentName\");\n\t\tfinal Markup tokens = parser\n\t\t\t\t.parse(\"This is a test <a componentName:id=9> <b>bold<\/b> <b componentName:id=10/><\/a> of the emergency broadcasting system\");\n\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\t\tlog.info(\"tok(1)=\" + tokens.get(1));\n\t\tlog.info(\"tok(2)=\" + tokens.get(2));\n\t\tlog.info(\"tok(3)=\" + tokens.get(3));\n\t\tlog.info(\"tok(4)=\" + tokens.get(4));\n\t\tlog.info(\"tok(5)=\" + tokens.get(5));\n\n\t\tAssert.assertTrue(tokens.get(0).equals(\"This is a test \"));\n\n\t\tfinal ComponentTag a = (ComponentTag)tokens.get(1);\n\n\t\tAssert.assertEquals(9, a.getAttributes().getInt(\"componentName:id\"));\n\t\tAssert.assertTrue(tokens.get(2).equals(\" <b>bold<\/b> \"));\n\n\t\tfinal ComponentTag b = (ComponentTag)tokens.get(3);\n\n\t\tAssert.assertEquals(10, b.getAttributes().getInt(\"componentName:id\"));\n\n\t\tfinal ComponentTag closeA = (ComponentTag)tokens.get(4);\n\n\t\tAssert.assertEquals(\"a\", closeA.getName());\n\t\tAssert.assertTrue(tokens.get(5).equals(\" of the emergency broadcasting system\"));\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @throws StringValueConversionException\n\t * @throws Exception\n\t */\n\tpublic final void testTagParsing() throws Exception\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\t\tparser.setWicketNamespace(\"componentName\");\n\t\t\n\t\tfinal Markup markup = parser\n\t\t\t\t.parse(\"This is a test <a componentName:id=\\\"a\\\" href=\\\"foo.html\\\"> <b componentName:id=\\\"b\\\">Bold!<\/b> \"\n\t\t\t\t\t\t+ \"<img componentName:id=\\\"img\\\" width=9 height=10 src=\\\"foo\\\"> <marker componentName:id=\\\"marker\\\"/> <\/a>\");\n\n\t\tfinal MarkupStream markupStream = new MarkupStream(markup);\n\n\t\tfinal ComponentTag aOpen = (ComponentTag)markupStream.next();\n\n\t\tlog.info(aOpen);\n\t\tAssert.assertTrue(aOpen.getName().equals(\"a\"));\n\t\tAssert.assertEquals(\"foo.html\", aOpen.getAttributes().getString(\"href\"));\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag boldOpen = (ComponentTag)markupStream.next();\n\n\t\tlog.info(boldOpen);\n\t\tAssert.assertTrue(boldOpen.getName().equals(\"b\"));\n\t\tAssert.assertEquals(XmlTag.OPEN, boldOpen.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag boldClose = (ComponentTag)markupStream.next();\n\n\t\tlog.info(boldClose);\n\t\tAssert.assertTrue(boldClose.getName().equals(\"b\"));\n\t\tAssert.assertEquals(XmlTag.CLOSE, boldClose.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag img = (ComponentTag)markupStream.next();\n\n\t\tlog.info(img);\n\t\tAssert.assertTrue(img.getName().equals(\"img\"));\n\t\tAssert.assertEquals(9, img.getAttributes().getInt(\"width\"));\n\t\tAssert.assertEquals(10, img.getAttributes().getInt(\"height\"));\n\t\tAssert.assertEquals(XmlTag.OPEN, img.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag marker = (ComponentTag)markupStream.next();\n\n\t\tlog.info(marker);\n\t\tAssert.assertTrue(marker.getName().equals(\"marker\"));\n\t\tAssert.assertEquals(XmlTag.OPEN_CLOSE, marker.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag aClose = (ComponentTag)markupStream.next();\n\n\t\tlog.info(aClose);\n\t\tAssert.assertTrue(aClose.getName().equals(\"a\"));\n\n\t\tAssert.assertNull(markupStream.next());\n\t}","id":9982,"modified_method":"/**\n\t * \n\t * @throws StringValueConversionException\n\t * @throws Exception\n\t */\n\tpublic final void testTagParsing() throws Exception\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\t\tparser.setWicketNamespace(\"componentName\");\n\t\t\n\t\tfinal Markup markup = parser\n\t\t\t\t.parse(\"This is a test <a componentName:id=\\\"a\\\" href=\\\"foo.html\\\"> <b componentName:id=\\\"b\\\">Bold!<\/b> \"\n\t\t\t\t\t\t+ \"<img componentName:id=\\\"img\\\" width=9 height=10 src=\\\"foo\\\"> <marker componentName:id=\\\"marker\\\"/> <\/a>\");\n\n\t\tfinal MarkupStream markupStream = new MarkupStream(markup);\n\n\t\tfinal ComponentTag aOpen = (ComponentTag)markupStream.next();\n\n\t\tlog.info(aOpen);\n\t\tAssert.assertTrue(aOpen.getName().equals(\"a\"));\n\t\tAssert.assertEquals(\"foo.html\", aOpen.getAttributes().getString(\"href\"));\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag boldOpen = (ComponentTag)markupStream.next();\n\n\t\tlog.info(boldOpen);\n\t\tAssert.assertTrue(boldOpen.getName().equals(\"b\"));\n\t\tAssert.assertEquals(XmlTag.OPEN, boldOpen.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag boldClose = (ComponentTag)markupStream.next();\n\n\t\tlog.info(boldClose);\n\t\tAssert.assertTrue(boldClose.getName().equals(\"b\"));\n\t\tAssert.assertEquals(XmlTag.CLOSE, boldClose.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag img = (ComponentTag)markupStream.next();\n\n\t\tlog.info(img);\n\t\tAssert.assertTrue(img.getName().equals(\"img\"));\n\t\tAssert.assertEquals(9, img.getAttributes().getInt(\"width\"));\n\t\tAssert.assertEquals(10, img.getAttributes().getInt(\"height\"));\n\t\tAssert.assertEquals(XmlTag.OPEN, img.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag marker = (ComponentTag)markupStream.next();\n\n\t\tlog.info(marker);\n\t\tAssert.assertTrue(marker.getName().equals(\"marker\"));\n\t\tAssert.assertEquals(XmlTag.OPEN_CLOSE, marker.getType());\n\n\t\tmarkupStream.next();\n\n\t\tfinal ComponentTag aClose = (ComponentTag)markupStream.next();\n\n\t\tlog.info(aClose);\n\t\tAssert.assertTrue(aClose.getName().equals(\"a\"));\n\n\t\tAssert.assertNull(markupStream.next());\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * \n\t * @throws Exception\n\t */\n\tpublic final void testXhtmlDocument() throws Exception\n\t{\n\t\tfinal String docText = \"\"\n\t\t\t\t+ \"<?xml version='1.0' encoding='iso-8859-1' ?>\"\n\t\t\t\t+ \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\"\n\t\t\t\t+ \"<html>\" + \"<head><title>Some Page<\/title><\/head>\"\n\t\t\t\t+ \"<body><h1>XHTML Test<\/h1><\/body>\" + \"<\/html>\";\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\t\tparser.setWicketNamespace(\"componentName\");\n\t\tfinal Markup tokens = parser.parse(docText);\n\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\n\t\t// without HtmlHeaderSectionHandler\n\t\tAssert.assertEquals(docText.substring(44), tokens.get(0).toString());\n\t\t// with HtmlHeaderSectionHandler\n\t\t// Assert.assertEquals(docText.substring(44, 147),\n\t\t// tokens.get(0).toString());\n\t}","id":9983,"modified_method":"/**\n\t * \n\t * @throws Exception\n\t */\n\tpublic final void testXhtmlDocument() throws Exception\n\t{\n\t\tfinal String docText = \"\"\n\t\t\t\t+ \"<?xml version='1.0' encoding='iso-8859-1' ?>\"\n\t\t\t\t+ \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\"\n\t\t\t\t+ \"<html>\" + \"<head><title>Some Page<\/title><\/head>\"\n\t\t\t\t+ \"<body><h1>XHTML Test<\/h1><\/body>\" + \"<\/html>\";\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\t\tparser.setWicketNamespace(\"componentName\");\n\t\tfinal Markup tokens = parser.parse(docText);\n\n\t\tlog.info(\"tok(0)=\" + tokens.get(0));\n\n\t\t// without HtmlHeaderSectionHandler\n\t\tAssert.assertEquals(docText.substring(44), tokens.get(0).toString());\n\t\t// with HtmlHeaderSectionHandler\n\t\t// Assert.assertEquals(docText.substring(44, 147),\n\t\t// tokens.get(0).toString());\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test &lt;wicket: .\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testWicketTag() throws ParseException, ResourceStreamNotFoundException,\n\t\t\tIOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser(null));\n\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/>\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\">Body<\/span>\");\n\t\tparser.parse(\"This is a test <span wicket:id=\\\"test\\\"/>\");\n\t\tparser.parse(\"This is a test <span wicket:id=\\\"test\\\">Body<\/span>\");\n\t\tparser.parse(\"<a wicket:id=\\\"[autolink]\\\" href=\\\"test.html\\\">Home<\/a>\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param key=value/>\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param key=\\\"value\\\" />\");\n\n\t\ttry\n\t\t{\n\t\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/>whatever<wicket:param key=\\\"value\\\" />\");\n\t\t\tassertTrue(\"Should have thrown an exception\", false);\n\t\t}\n\t\tcatch (MarkupException ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param key=\\\"value\\\" /><wicket:param key2=\\\"value2\\\" />\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/>   <wicket:param key=\\\"value\\\" />   <wicket:param key2=\\\"value2\\\" />\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/> \\n\\r   <wicket:param key=\\\"value\\\" />\\n\\r\\t   <wicket:param key2=\\\"value2\\\" />\");\n\n\t\t// parser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param\n\t\t// name=myParam>value<\/wicket>\", null);\n\n\t\tparser.parse(\"<wicket:body/>\");\n\t\tparser.parse(\"<wicket:border/>\");\n\t\tparser.parse(\"<wicket:panel/>\");\n\n\t\ttry\n\t\t{\n\t\t\tparser.parse(\"<wicket:remove/>\");\n\t\t\tassertTrue(\"Should have thrown an exception\", false);\n\t\t}\n\t\tcatch (MarkupException ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tMarkup markup = parser.parse(\"<wicket:remove>  <\/wicket:remove>\");\n\t\tassertEquals(0, markup.size());\n\n\t\tmarkup = parser.parse(\"<wicket:remove> <span id=\\\"test\\\"/> <\/wicket:remove>\");\n\t\tassertEquals(0, markup.size());\n\n\t\tmarkup = parser.parse(\"<div><wicket:remove> <span id=\\\"test\\\"/> <\/wicket:remove><\/div>\");\n\t\tassertEquals(2, markup.size());\n\t\tassertEquals(\"<div>\", ((RawMarkup)markup.get(0)).toString());\n\t\tassertEquals(\"<\/div>\", ((RawMarkup)markup.get(1)).toString());\n\n\t\ttry\n\t\t{\n\t\t\tparser.parse(\"<wicket:remove> <wicket:remove> <\/wicket:remove> <\/wicket:remove>\");\n\t\t\tassertTrue(\n\t\t\t\t\t\"Should have thrown an exception: remove regions must not contain wicket-components\",\n\t\t\t\t\tfalse);\n\t\t}\n\t\tcatch (MarkupException ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tparser.parse(\"<wicket:component name = \\\"componentName\\\" class = \\\"classname\\\" param1 = \\\"value1\\\"/>\");\n\t\tparser.parse(\"<wicket:component name = \\\"componentName\\\" class = \\\"classname\\\" param1 = \\\"value1\\\">    <\/wicket:component>\");\n\t\tparser.parse(\"<wicket:component name = \\\"componentName\\\" class = \\\"classname\\\" param1 = \\\"value1\\\">  <span wicket:id=\\\"msg\\\">hello world!<\/span><\/wicket:component>\");\n\t\tparser.parse(\"<wicket:panel><div id=\\\"definitionsContentBox\\\"><span wicket:id=\\\"contentPanel\\\"/><\/div><\/wicket:panel>\");\n\t}","id":9984,"modified_method":"/**\n\t * Test &lt;wicket: .\n\t * \n\t * @throws ParseException\n\t * @throws ResourceStreamNotFoundException\n\t * @throws IOException\n\t */\n\tpublic final void testWicketTag() throws ParseException, ResourceStreamNotFoundException,\n\t\t\tIOException\n\t{\n\t\tfinal MarkupParser parser = new MarkupParser(application, new XmlPullParser());\n\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/>\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\">Body<\/span>\");\n\t\tparser.parse(\"This is a test <span wicket:id=\\\"test\\\"/>\");\n\t\tparser.parse(\"This is a test <span wicket:id=\\\"test\\\">Body<\/span>\");\n\t\tparser.parse(\"<a wicket:id=\\\"[autolink]\\\" href=\\\"test.html\\\">Home<\/a>\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param key=value/>\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param key=\\\"value\\\" />\");\n\n\t\ttry\n\t\t{\n\t\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/>whatever<wicket:param key=\\\"value\\\" />\");\n\t\t\tassertTrue(\"Should have thrown an exception\", false);\n\t\t}\n\t\tcatch (MarkupException ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param key=\\\"value\\\" /><wicket:param key2=\\\"value2\\\" />\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/>   <wicket:param key=\\\"value\\\" />   <wicket:param key2=\\\"value2\\\" />\");\n\t\tparser.parse(\"<span wicket:id=\\\"test\\\"/> \\n\\r   <wicket:param key=\\\"value\\\" />\\n\\r\\t   <wicket:param key2=\\\"value2\\\" />\");\n\n\t\t// parser.parse(\"<span wicket:id=\\\"test\\\"/><wicket:param\n\t\t// name=myParam>value<\/wicket>\", null);\n\n\t\tparser.parse(\"<wicket:body/>\");\n\t\tparser.parse(\"<wicket:border/>\");\n\t\tparser.parse(\"<wicket:panel/>\");\n\n\t\ttry\n\t\t{\n\t\t\tparser.parse(\"<wicket:remove/>\");\n\t\t\tassertTrue(\"Should have thrown an exception\", false);\n\t\t}\n\t\tcatch (MarkupException ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tMarkup markup = parser.parse(\"<wicket:remove>  <\/wicket:remove>\");\n\t\tassertEquals(0, markup.size());\n\n\t\tmarkup = parser.parse(\"<wicket:remove> <span id=\\\"test\\\"/> <\/wicket:remove>\");\n\t\tassertEquals(0, markup.size());\n\n\t\tmarkup = parser.parse(\"<div><wicket:remove> <span id=\\\"test\\\"/> <\/wicket:remove><\/div>\");\n\t\tassertEquals(2, markup.size());\n\t\tassertEquals(\"<div>\", ((RawMarkup)markup.get(0)).toString());\n\t\tassertEquals(\"<\/div>\", ((RawMarkup)markup.get(1)).toString());\n\n\t\ttry\n\t\t{\n\t\t\tparser.parse(\"<wicket:remove> <wicket:remove> <\/wicket:remove> <\/wicket:remove>\");\n\t\t\tassertTrue(\n\t\t\t\t\t\"Should have thrown an exception: remove regions must not contain wicket-components\",\n\t\t\t\t\tfalse);\n\t\t}\n\t\tcatch (MarkupException ex)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tparser.parse(\"<wicket:component name = \\\"componentName\\\" class = \\\"classname\\\" param1 = \\\"value1\\\"/>\");\n\t\tparser.parse(\"<wicket:component name = \\\"componentName\\\" class = \\\"classname\\\" param1 = \\\"value1\\\">    <\/wicket:component>\");\n\t\tparser.parse(\"<wicket:component name = \\\"componentName\\\" class = \\\"classname\\\" param1 = \\\"value1\\\">  <span wicket:id=\\\"msg\\\">hello world!<\/span><\/wicket:component>\");\n\t\tparser.parse(\"<wicket:panel><div id=\\\"definitionsContentBox\\\"><span wicket:id=\\\"contentPanel\\\"/><\/div><\/wicket:panel>\");\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Handle wicket param tags.\n\t * \n\t * @param tag\n\t *            The current tag\n\t * @return The next MarkupElement to be processed\n\t * @throws ParseException\n\t */\n\tprivate ComponentTag handleNext(ComponentTag tag) throws ParseException\n\t{\n\t\t// Ignore all close tags. Wicket params tags must not be close tags\n\t\t// and components preceding the param tag can not be close tags\n\t\t// either.\n\t\tif (tag.isClose())\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\t// Wicket component tags will have a component name assigned.\n\t\t// Ignore all none wicket components.\n\t\tif (tag.getId() == null)\n\t\t{\n\t\t\t// Reset the last tag seen. Null meaning: the last tag was\n\t\t\t// no wicket tag.\n\t\t\treturn tag;\n\t\t}\n\n\t\t// By now we know it is a wicket component tag. If it is no\n\t\t// wicket param tag, than remember it and we are done.\n\t\tif (!(tag instanceof WicketTag) || !((WicketTag)tag).isParamTag())\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\t// By now we know it is a Wicket param tag.\n\t\t// Only empty TEXT is allowed in between the preceding component\n\t\t// tag and the param tag.\n\t\tfinal CharSequence rawMarkup = xmlParser.getInputSubsequence(lastTag.getPos()\n\t\t\t\t+ lastTag.getLength(), tag.getPos());\n\n\t\tif (rawMarkup.length() > 0)\n\t\t{\n\t\t\tString text = rawMarkup.toString();\n\t\t\ttext = text.replaceAll(\"[\\\\r\\\\n]+\", \"\").trim();\n\n\t\t\tif (text.length() > 0)\n\t\t\t{\n\t\t\t\tthrow new ParseException(\"There must not be any text between a component tag and \"\n\t\t\t\t\t\t+ \"it's related param tag. Only spaces and line breaks are allowed.\", tag\n\t\t\t\t\t\t.getPos());\n\t\t\t}\n\t\t}\n\n\t\t// TODO Enhancement: <wicket:params name = \"myProperty\">My completely\n\t\t// free text that can contain everything<\/wicket:params> is currently\n\t\t// not supported\n\n\t\t// Add the parameters to the previous component tag\n\t\tlastTag.getAdditionalAttributes().putAll(tag.getAttributes());\n\n\t\t// If wicket param tags shall not be included in the output, than\n\t\t// go ahead and process the next one.\n\t\tif (stripWicketTag == true)\n\t\t{\n\t\t\ttag = (ComponentTag)getParent().nextTag();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// E.g. An \"expected close tag\" exception will be thrown if the\n\t\t\t// component uses replaceComponentTagBody() to replace the body\n\t\t\t// of the component (see src/test/.../MyLabel.html).\n\t\t\tlog\n\t\t\t\t\t.warn(\"Be careful. Not stripping <wicket:param> from output may cause subtle errors.\");\n\t\t}\n\n\t\treturn tag;\n\t}","id":9985,"modified_method":"/**\n\t * Handle wicket param tags.\n\t * \n\t * @param tag\n\t *            The current tag\n\t * @return The next MarkupElement to be processed\n\t * @throws ParseException\n\t */\n\tprivate ComponentTag handleNext(ComponentTag tag) throws ParseException\n\t{\n\t\t// Ignore all close tags. Wicket params tags must not be close tags\n\t\t// and components preceding the param tag can not be close tags\n\t\t// either.\n\t\tif (tag.isClose())\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\t// Wicket component tags will have a component name assigned.\n\t\t// Ignore all none wicket components.\n\t\tif (tag.getId() == null)\n\t\t{\n\t\t\t// Reset the last tag seen. Null meaning: the last tag was\n\t\t\t// no wicket tag.\n\t\t\treturn tag;\n\t\t}\n\n\t\t// By now we know it is a wicket component tag. If it is no\n\t\t// wicket param tag, than remember it and we are done.\n\t\tif (!(tag instanceof WicketTag) || !((WicketTag)tag).isParamTag())\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\t// By now we know it is a Wicket param tag.\n\t\t// Only empty TEXT is allowed in between the preceding component\n\t\t// tag and the param tag.\n\t\tfinal CharSequence rawMarkup = xmlParser.getInput(lastTag.getPos()\n\t\t\t\t+ lastTag.getLength(), tag.getPos());\n\n\t\tif (rawMarkup.length() > 0)\n\t\t{\n\t\t\tString text = rawMarkup.toString();\n\t\t\ttext = text.replaceAll(\"[\\\\r\\\\n]+\", \"\").trim();\n\n\t\t\tif (text.length() > 0)\n\t\t\t{\n\t\t\t\tthrow new ParseException(\"There must not be any text between a component tag and \"\n\t\t\t\t\t\t+ \"it's related param tag. Only spaces and line breaks are allowed.\", tag\n\t\t\t\t\t\t.getPos());\n\t\t\t}\n\t\t}\n\n\t\t// TODO Enhancement: <wicket:params name = \"myProperty\">My completely\n\t\t// free text that can contain everything<\/wicket:params> is currently\n\t\t// not supported\n\n\t\t// Add the parameters to the previous component tag\n\t\tlastTag.getAdditionalAttributes().putAll(tag.getAttributes());\n\n\t\t// If wicket param tags shall not be included in the output, than\n\t\t// go ahead and process the next one.\n\t\tif (stripWicketTag == true)\n\t\t{\n\t\t\ttag = (ComponentTag)getParent().nextTag();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// E.g. An \"expected close tag\" exception will be thrown if the\n\t\t\t// component uses replaceComponentTagBody() to replace the body\n\t\t\t// of the component (see src/test/.../MyLabel.html).\n\t\t\tlog\n\t\t\t\t\t.warn(\"Be careful. Not stripping <wicket:param> from output may cause subtle errors.\");\n\t\t}\n\n\t\treturn tag;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Return the encoding used while reading the markup file.\n\t *\n\t * @return if null, than JVM default\n\t */\n\tpublic String getEncoding()\n\t{\n\t\treturn encoding;\n\t}","id":9986,"modified_method":"/**\n\t * \n\t * @see wicket.markup.parser.IXmlPullParser#getEncoding()\n\t */\n\tpublic String getEncoding()\n\t{\n\t\treturn this.xmlReader.getEncoding();\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The markup to be parsed\n\t */\n\tpublic String toString()\n\t{\n\t\treturn this.input;\n\t}","id":9987,"modified_method":"/**\n\t * \n\t * @see java.lang.Object#toString()\n\t */\n\tpublic String toString()\n\t{\n\t\treturn this.input.toString();\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Reads and parses markup from a resource such as file.\n\t *\n\t * @param resource\n\t *            The resource to read and parse\n\t * @throws IOException\n\t * @throws ResourceStreamNotFoundException\n\t */\n\tpublic void parse(final IResourceStream resource) throws IOException, ResourceStreamNotFoundException\n\t{\n\t\t// reset: Must come from markup\n\t\tthis.encoding = null;\n\n\t\ttry\n\t\t{\n\t\t\tfinal BufferedInputStream bin = new BufferedInputStream(resource.getInputStream(), 4000);\n\t\t\tif (!bin.markSupported())\n\t\t\t{\n\t\t\t\tthrow new IOException(\"BufferedInputStream does not support mark/reset\");\n\t\t\t}\n\n\t\t\t// read ahead buffer required for the first line of the markup\n\t\t\t// (encoding)\n\t\t\tfinal int readAheadSize = 80;\n\t\t\tbin.mark(readAheadSize);\n\n\t\t\t// read-ahead the input stream if it starts with <?xml\n\t\t\t// encoding=\"..\"?>. If yes, set this.encoding.\n\t\t\t// If no, return the whole line. determineEncoding will read-ahead\n\t\t\t// at max. the very first line of the markup.\n\t\t\tfinal String encoding = determineEncoding(bin, readAheadSize);\n\t\t\tif (encoding != null)\n\t\t\t{\n\t\t\t    this.encoding = encoding;\n\t\t\t}\n\n\t\t\t// Depending on the encoding determined from the markup-file, read\n\t\t\t// the rest either with specific encoding or JVM default\n\t\t\tfinal String markup;\n\t\t\tif (this.encoding == null)\n\t\t\t{\n\t\t\t\t// Use JVM default\n\t\t\t\tbin.reset();\n\t\t\t\tmarkup = Streams.readString(bin);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Use the encoding as specified in <?xml encoding=\"..\" ?>\n\t\t\t\t// Don't re-read <?xml ..> again\n\t\t\t    // Ignore ALL characters preceding <?xml>\n\t\t\t\tmarkup = Streams.readString(bin, encoding);\n\t\t\t}\n\n\t\t\tsetInput(markup);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tresource.close();\n\t\t}\n\t}","id":9988,"modified_method":"/**\n\t * Reads and parses markup from a resource such as file.\n\t * \n\t * @param resource\n\t *            The resource to read and parse\n\t * @param encoding\n\t *            The default character encoding of the input\n\t * @throws IOException\n\t * @throws ResourceStreamNotFoundException\n\t */\n\tpublic void parse(final IResourceStream resource, final String encoding) throws IOException,\n\t\t\tResourceStreamNotFoundException\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.xmlReader = new XmlReader(\n\t\t\t\t\tnew BufferedInputStream(resource.getInputStream(), 4000), encoding);\n\t\t\tthis.input = new FullyBufferedReader(this.xmlReader);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tresource.close();\n\t\t\tthis.xmlReader.close();\n\t\t}\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param defaultEncoding\n\t */\n\tpublic XmlPullParser(final String defaultEncoding)\n\t{\n\t    // The xml parser does not have a parent filter\n\t    super(null);\n\t    \n\t    this.encoding = defaultEncoding;\n\t}","id":9989,"modified_method":"/**\n\t * Construct.\n\t */\n\tpublic XmlPullParser()\n\t{\n\t\t// The xml parser does not have a parent filter\n\t\tsuper(null);\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Return the XML declaration string, in case if found in the\n\t * markup.\n\t * \n\t * @return Null, if not found.\n\t */\n\tpublic String getXmlDeclaration()\n\t{\n\t    return this.xmlDeclarationString;\n\t}","id":9990,"modified_method":"/**\n\t * \n\t * @see wicket.markup.parser.IXmlPullParser#getXmlDeclaration()\n\t */\n\tpublic String getXmlDeclaration()\n\t{\n\t\treturn this.xmlReader.getXmlDeclaration();\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the character sequence from the position marker to toPos.\n\t *\n\t * @param toPos\n\t *            index of first character not included\n\t * @return Raw markup (a string) in between these two positions.\n\t */\n\tpublic final CharSequence getInputFromPositionMarker(int toPos)\n\t{\n\t    if (toPos < 0)\n\t    {\n\t        toPos = this.input.length();\n\t    }\n\t    else if (toPos < this.positionMarker)\n\t    {\n\t        return \"\";\n\t    }\n\t\treturn this.input.subSequence(this.positionMarker, toPos);\n\t}","id":9991,"modified_method":"/**\n\t * \n\t * @see wicket.markup.parser.IXmlPullParser#getInputFromPositionMarker(int)\n\t */\n\tpublic final CharSequence getInputFromPositionMarker(int toPos)\n\t{\n\t\treturn this.input.getSubstring(toPos);\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Remember the current position in markup\n\t */\n\tpublic final void setPositionMarker()\n\t{\n\t\tthis.positionMarker = this.inputPosition;\n\t}","id":9992,"modified_method":"/**\n\t * \n\t * @see wicket.markup.parser.IXmlPullParser#setPositionMarker()\n\t */\n\tpublic final void setPositionMarker()\n\t{\n\t\tthis.input.setPositionMarker(this.input.getPosition());\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Parses the text between tags. For example, \"a href=foo.html\".\n\t *\n\t * @param tagText\n\t *            The text between tags\n\t * @return A new Tag object or null if the tag is invalid\n\t * @throws ParseException\n\t */\n\tprivate XmlTag parseTagText(final String tagText) throws ParseException\n\t{\n\t\t// Get the length of the tagtext\n\t\tfinal int tagTextLength = tagText.length();\n\n\t\t// If we match tagname pattern\n\t\tfinal TagNameParser tagnameParser = new TagNameParser(tagText);\n\n\t\tif (tagnameParser.matcher().lookingAt())\n\t\t{\n\t\t\tfinal XmlTag tag = new XmlTag();\n\n\t\t\t// Extract the tag from the pattern matcher\n\t\t\ttag.name = tagnameParser.getName();\n\t\t\ttag.namespace = tagnameParser.getNamespace();\n\n\t\t\t// Are we at the end? Then there are no attributes, so we just\n\t\t\t// return the tag\n\t\t\tint pos = tagnameParser.matcher().end(0);\n\t\t\tif (pos == tagTextLength)\n\t\t\t{\n\t\t\t\treturn tag;\n\t\t\t}\n\n\t\t\t// Extract attributes\n\t\t\tfinal VariableAssignmentParser attributeParser = new VariableAssignmentParser(tagText);\n\n\t\t\twhile (attributeParser.matcher().find(pos))\n\t\t\t{\n\t\t\t\t// Get key and value using attribute pattern\n\t\t\t\tString value = attributeParser.getValue();\n\n\t\t\t\t// In case like <html xmlns:wicket> will the value be null\n\t\t\t\tif (value == null)\n\t\t\t\t{\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set new position to end of attribute\n\t\t\t\tpos = attributeParser.matcher().end(0);\n\n\t\t\t\t// Chop off double quotes or single quotes\n\t\t\t\tif (value.startsWith(\"\\\"\") || value.startsWith(\"\\'\"))\n\t\t\t\t{\n\t\t\t\t\tvalue = value.substring(1, value.length() - 1);\n\t\t\t\t}\n\n\t\t\t\t// Trim trailing whitespace\n\t\t\t\tvalue = value.trim();\n\n\t\t\t\t// Get key\n\t\t\t\tfinal String key = attributeParser.getKey();\n\n\t\t\t\t// Put the attribute in the attributes hash\n\t\t\t\tif (null != tag.put(key, value))\n\t\t\t\t{\n\t\t\t\t    throw new ParseException(\"Same attribute found twice: \" \n\t\t\t\t            + key, this.inputPosition);\n\t\t\t\t}\n\n\t\t\t\t// The input has to match exactly (no left over junk after\n\t\t\t\t// attributes)\n\t\t\t\tif (pos == tagTextLength)\n\t\t\t\t{\n\t\t\t\t\treturn tag;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn null;\n\t}","id":9993,"modified_method":"/**\n\t * Parses the text between tags. For example, \"a href=foo.html\".\n\t * \n\t * @param tagText\n\t *            The text between tags\n\t * @return A new Tag object or null if the tag is invalid\n\t * @throws ParseException\n\t */\n\tprivate XmlTag parseTagText(final String tagText) throws ParseException\n\t{\n\t\t// Get the length of the tagtext\n\t\tfinal int tagTextLength = tagText.length();\n\n\t\t// If we match tagname pattern\n\t\tfinal TagNameParser tagnameParser = new TagNameParser(tagText);\n\t\tif (tagnameParser.matcher().lookingAt())\n\t\t{\n\t\t\tfinal XmlTag tag = new XmlTag();\n\n\t\t\t// Extract the tag from the pattern matcher\n\t\t\ttag.name = tagnameParser.getName();\n\t\t\ttag.namespace = tagnameParser.getNamespace();\n\n\t\t\t// Are we at the end? Then there are no attributes, so we just\n\t\t\t// return the tag\n\t\t\tint pos = tagnameParser.matcher().end(0);\n\t\t\tif (pos == tagTextLength)\n\t\t\t{\n\t\t\t\treturn tag;\n\t\t\t}\n\n\t\t\t// Extract attributes\n\t\t\tfinal VariableAssignmentParser attributeParser = new VariableAssignmentParser(tagText);\n\n\t\t\twhile (attributeParser.matcher().find(pos))\n\t\t\t{\n\t\t\t\t// Get key and value using attribute pattern\n\t\t\t\tString value = attributeParser.getValue();\n\n\t\t\t\t// In case like <html xmlns:wicket> will the value be null\n\t\t\t\tif (value == null)\n\t\t\t\t{\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set new position to end of attribute\n\t\t\t\tpos = attributeParser.matcher().end(0);\n\n\t\t\t\t// Chop off double quotes or single quotes\n\t\t\t\tif (value.startsWith(\"\\\"\") || value.startsWith(\"\\'\"))\n\t\t\t\t{\n\t\t\t\t\tvalue = value.substring(1, value.length() - 1);\n\t\t\t\t}\n\n\t\t\t\t// Trim trailing whitespace\n\t\t\t\tvalue = value.trim();\n\n\t\t\t\t// Get key\n\t\t\t\tfinal String key = attributeParser.getKey();\n\n\t\t\t\t// Put the attribute in the attributes hash\n\t\t\t\tif (null != tag.put(key, value))\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"Same attribute found twice: \" + key, this.input\n\t\t\t\t\t\t\t.getPosition());\n\t\t\t\t}\n\n\t\t\t\t// The input has to match exactly (no left over junk after\n\t\t\t\t// attributes)\n\t\t\t\tif (pos == tagTextLength)\n\t\t\t\t{\n\t\t\t\t\treturn tag;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the next tag from the input string.\n\t *\n\t * @return The extracted tag (will always be of type XmlTag).\n\t * @throws ParseException\n\t */\n\tpublic final MarkupElement nextTag() throws ParseException\n\t{\n\t    if (this.skipUntilText != null)\n\t    {\n\t        skipUntil();\n\t    }\n\t    \n\t\t// Index of open bracket\n\t\tint openBracketIndex = input.indexOf('<', this.inputPosition);\n\n\t\t// While we can find an open tag, parse the tag\n\t\tif (openBracketIndex != -1)\n\t\t{\n\t\t\t// Determine line number\n\t\t\tcountLinesTo(input, openBracketIndex);\n\n\t\t\t// Get index of closing tag and advance past the tag\n\t\t\tint closeBracketIndex = input.indexOf('>', openBracketIndex);\n\n\t\t\tif (closeBracketIndex == -1)\n\t\t\t{\n\t\t\t\tthrow new ParseException(\"No matching close bracket at position \"\n\t\t\t\t\t\t+ openBracketIndex, this.inputPosition);\n\t\t\t}\n\n\t\t\t// Get the tagtext between open and close brackets\n\t\t\tString tagText = input.substring(openBracketIndex + 1, closeBracketIndex);\n\n\t\t\t// Handle comments\n\t\t\tif (tagText.startsWith(\"!--\"))\n\t\t\t{\n\t\t\t\t// Skip ahead to -->\n\t\t\t\tthis.inputPosition = input.indexOf(\"-->\", openBracketIndex + 4) + 3;\n\n\t\t\t\tif (this.inputPosition == -1)\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"Unclosed comment beginning at \" + openBracketIndex,\n\t\t\t\t\t\t\topenBracketIndex);\n\t\t\t\t}\n\n\t\t\t\treturn nextTag();\n\t\t\t}\n\t\t\t\n\t\t\t// CDATA sections might contain \"<\" which is not part of an XML tag.\n\t\t\t// Make sure escaped \"<\" are treated right\n\t\t\tfinal String startText = (tagText.length() <= 8 ? tagText : tagText.substring(0, 8));\n\t\t\tif (startText.toUpperCase().equals(\"![CDATA[\"))\n\t\t\t{\n\t\t\t\t// Get index of closing tag and advance past the tag\n\t\t\t\tcloseBracketIndex = findCloseBracket(input, '>', openBracketIndex);\n\n\t\t\t\tif (closeBracketIndex == -1)\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"No matching close bracket at position \"\n\t\t\t\t\t\t\t+ openBracketIndex, this.inputPosition);\n\t\t\t\t}\n\n\t\t\t\t// Get the tagtext between open and close brackets\n\t\t\t\ttagText = input.substring(openBracketIndex + 1, closeBracketIndex);\n\t\t\t}\n\t\t\t\n\t\t\t{\n\t\t\t\t// Type of tag\n\t\t\t\tXmlTag.Type type = XmlTag.OPEN;\n\n\t\t\t\t// If the tag ends in '/', it's a \"simple\" tag like <foo/>\n\t\t\t\tif (tagText.endsWith(\"/\"))\n\t\t\t\t{\n\t\t\t\t\ttype = XmlTag.OPEN_CLOSE;\n\t\t\t\t\ttagText = tagText.substring(0, tagText.length() - 1);\n\t\t\t\t}\n\t\t\t\telse if (tagText.startsWith(\"/\"))\n\t\t\t\t{\n\t\t\t\t\t// The tag text starts with a '/', it's a simple close tag\n\t\t\t\t\ttype = XmlTag.CLOSE;\n\t\t\t\t\ttagText = tagText.substring(1);\n\t\t\t\t}\n\n\t\t\t\t// We don't deeply parse tags like DOCTYPE that start with !\n\t\t\t\t// or XML document definitions that start with ?\n\t\t\t\tif (tagText.startsWith(\"!\") || tagText.startsWith(\"?\"))\n\t\t\t\t{\n\t\t\t\t\t// Move to position after the tag\n\t\t\t\t\tthis.inputPosition = closeBracketIndex + 1;\n\n\t\t\t\t\t// Return next tag\n\t\t\t\t\treturn nextTag();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tString lowerCase = tagText.toLowerCase();\n\n\t\t\t\t\t// Often save a (longer) comparison at the expense of a extra shorter one for 's' tags\n\t\t\t\t\tif ((type == XmlTag.OPEN) && lowerCase.startsWith(\"s\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lowerCase.startsWith(\"script\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t    \tthis.skipUntilText = \"script\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (lowerCase.startsWith(\"style\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.skipUntilText = \"style\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t// Parse remaining tag text, obtaining a tag object or null\n\t\t\t\t\t// if it's invalid\n\t\t\t\t\tfinal XmlTag tag = parseTagText(tagText);\n\n\t\t\t\t\tif (tag != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Populate tag fields\n\t\t\t\t\t\ttag.type = type;\n\t\t\t\t\t\ttag.pos = openBracketIndex;\n\t\t\t\t\t\ttag.length = (closeBracketIndex + 1) - openBracketIndex;\n\t\t\t\t\t\ttag.text = input.substring(openBracketIndex, closeBracketIndex + 1);\n\t\t\t\t\t\ttag.lineNumber = lineNumber;\n\t\t\t\t\t\ttag.columnNumber = columnNumber;\n\n\t\t\t\t\t\t// Move to position after the tag\n\t\t\t\t\t\tthis.inputPosition = closeBracketIndex + 1;\n\n\t\t\t\t\t\t// Return the tag we found!\n\t\t\t\t\t\treturn tag;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ParseException(\"Malformed tag (line \" + lineNumber + \", column \"\n\t\t\t\t\t\t\t\t+ columnNumber + \")\", openBracketIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// There is no next matching tag\n\t\treturn null;\n\t}","id":9994,"modified_method":"/**\n\t * Gets the next tag from the input string.\n\t * \n\t * @return The extracted tag (will always be of type XmlTag).\n\t * @throws ParseException\n\t */\n\tpublic final MarkupElement nextTag() throws ParseException\n\t{\n\t\tif (this.skipUntilText != null)\n\t\t{\n\t\t\tskipUntil();\n\t\t}\n\n\t\t// Index of open bracket\n\t\tint openBracketIndex = this.input.find('<');\n\n\t\t// While we can find an open tag, parse the tag\n\t\tif (openBracketIndex != -1)\n\t\t{\n\t\t\t// Determine line number\n\t\t\tthis.input.countLinesTo(openBracketIndex);\n\n\t\t\t// Get index of closing tag and advance past the tag\n\t\t\tint closeBracketIndex = this.input.find('>', openBracketIndex + 1);\n\n\t\t\tif (closeBracketIndex == -1)\n\t\t\t{\n\t\t\t\tthrow new ParseException(\"No matching close bracket at position \"\n\t\t\t\t\t\t+ openBracketIndex, this.input.getPosition());\n\t\t\t}\n\n\t\t\t// Get the tagtext between open and close brackets\n\t\t\tString tagText = this.input.getSubstring(openBracketIndex + 1, closeBracketIndex)\n\t\t\t\t\t.toString();\n\n\t\t\t// Handle comments\n\t\t\tif (tagText.startsWith(\"!--\"))\n\t\t\t{\n\t\t\t\t// Skip ahead to \"-->\". Note that you can not simply test for\n\t\t\t\t// tagText.endsWith(\"--\") as the comment might contain a '>'\n\t\t\t\t// inside.\n\t\t\t\tint pos = this.input.find(\"-->\", openBracketIndex + 1);\n\t\t\t\tif (pos == -1)\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"Unclosed comment beginning at line:\"\n\t\t\t\t\t\t\t+ input.getLineNumber() + \" column:\" + input.getColumnNumber(),\n\t\t\t\t\t\t\topenBracketIndex);\n\t\t\t\t}\n\n\t\t\t\tthis.input.setPosition(pos + 3);\n\t\t\t\treturn nextTag();\n\t\t\t}\n\n\t\t\t// CDATA sections might contain \"<\" which is not part of an XML tag.\n\t\t\t// Make sure escaped \"<\" are treated right\n\t\t\tfinal String startText = (tagText.length() <= 8 ? tagText : tagText.substring(0, 8));\n\t\t\tif (startText.toUpperCase().equals(\"![CDATA[\"))\n\t\t\t{\n\t\t\t\t// Get index of closing tag and advance past the tag\n\t\t\t\tcloseBracketIndex = findCloseBracket('>', openBracketIndex);\n\n\t\t\t\tif (closeBracketIndex == -1)\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"No matching close bracket at position \"\n\t\t\t\t\t\t\t+ openBracketIndex, this.input.getPosition());\n\t\t\t\t}\n\n\t\t\t\t// Get the tagtext between open and close brackets\n\t\t\t\ttagText = this.input.getSubstring(openBracketIndex + 1, closeBracketIndex)\n\t\t\t\t\t\t.toString();\n\t\t\t}\n\n\t\t\t{\n\t\t\t\t// Type of tag\n\t\t\t\tXmlTag.Type type = XmlTag.OPEN;\n\n\t\t\t\t// If the tag ends in '/', it's a \"simple\" tag like <foo/>\n\t\t\t\tif (tagText.endsWith(\"/\"))\n\t\t\t\t{\n\t\t\t\t\ttype = XmlTag.OPEN_CLOSE;\n\t\t\t\t\ttagText = tagText.substring(0, tagText.length() - 1);\n\t\t\t\t}\n\t\t\t\telse if (tagText.startsWith(\"/\"))\n\t\t\t\t{\n\t\t\t\t\t// The tag text starts with a '/', it's a simple close tag\n\t\t\t\t\ttype = XmlTag.CLOSE;\n\t\t\t\t\ttagText = tagText.substring(1);\n\t\t\t\t}\n\n\t\t\t\t// We don't deeply parse tags like DOCTYPE that start with !\n\t\t\t\t// or XML document definitions that start with ?\n\t\t\t\tif (tagText.startsWith(\"!\") || tagText.startsWith(\"?\"))\n\t\t\t\t{\n\t\t\t\t\t// Move to position after the tag\n\t\t\t\t\tthis.input.setPosition(closeBracketIndex + 1);\n\n\t\t\t\t\t// Return next tag\n\t\t\t\t\treturn nextTag();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tString lowerCase = tagText.toLowerCase();\n\n\t\t\t\t\t// Often save a (longer) comparison at the expense of a\n\t\t\t\t\t// extra shorter one for 's' tags\n\t\t\t\t\tif ((type == XmlTag.OPEN) && lowerCase.startsWith(\"s\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (lowerCase.startsWith(\"script\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.skipUntilText = \"script\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (lowerCase.startsWith(\"style\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.skipUntilText = \"style\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Parse remaining tag text, obtaining a tag object or null\n\t\t\t\t\t// if it's invalid\n\t\t\t\t\tfinal XmlTag tag = parseTagText(tagText);\n\t\t\t\t\tif (tag != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Populate tag fields\n\t\t\t\t\t\ttag.type = type;\n\t\t\t\t\t\ttag.pos = openBracketIndex;\n\t\t\t\t\t\ttag.length = (closeBracketIndex + 1) - openBracketIndex;\n\t\t\t\t\t\ttag.text = this.input.getSubstring(openBracketIndex, closeBracketIndex + 1)\n\t\t\t\t\t\t\t\t.toString();\n\t\t\t\t\t\ttag.lineNumber = this.input.getLineNumber();\n\t\t\t\t\t\ttag.columnNumber = this.input.getColumnNumber();\n\n\t\t\t\t\t\t// Move to position after the tag\n\t\t\t\t\t\tthis.input.setPosition(closeBracketIndex + 1);\n\n\t\t\t\t\t\t// Return the tag we found!\n\t\t\t\t\t\treturn tag;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ParseException(\"Malformed tag (line \"\n\t\t\t\t\t\t\t\t+ this.input.getLineNumber() + \", column \"\n\t\t\t\t\t\t\t\t+ this.input.getColumnNumber() + \")\", openBracketIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// There is no next matching tag\n\t\treturn null;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Parse the given string.\n\t * <p>\n\t * Note: xml character encoding is NOT applied. It is assumed the input\n\t * provided does have the correct encoding already.\n\t *\n\t * @param string\n\t *            The input string\n\t * @throws IOException\n\t *             Error while reading the resource\n\t * @throws ResourceStreamNotFoundException\n\t *             Resource not found\n\t */\n\tpublic void parse(final CharSequence string) throws IOException, ResourceStreamNotFoundException\n\t{\n\t\tparse(new StringResourceStream(string));\n\t}","id":9995,"modified_method":"/**\n\t * Parse the given string.\n\t * <p>\n\t * Note: xml character encoding is NOT applied. It is assumed the input\n\t * provided does have the correct encoding already.\n\t * \n\t * @param string\n\t *            The input string\n\t * @throws IOException\n\t *             Error while reading the resource\n\t * @throws ResourceStreamNotFoundException\n\t *             Resource not found\n\t */\n\tpublic void parse(final CharSequence string) throws IOException,\n\t\t\tResourceStreamNotFoundException\n\t{\n\t\tparse(new StringResourceStream(string), null);\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Find the char but ignore any text within \"..\" and '..'\n\t * \n\t * @param input The markup string\n\t * @param ch The character to search\n\t * @param startIndex Start index\n\t * @return -1 if not found, else the index\n\t */\n\tprivate int findCloseBracket(final String input, final char ch, int startIndex)\n\t{\n\t    char quote = 0;\n\t    \n\t    for (; startIndex < input.length(); startIndex++)\n\t    {\n\t        char charAt = input.charAt(startIndex);\n\t        if (quote != 0)\n\t        {\n\t            if (quote == charAt)\n\t            {\n\t                quote = 0;\n\t            }\n\t        }\n\t        else if ((charAt == '\"') || (charAt == '\\''))\n\t        {\n\t            quote = charAt;\n\t        }\n\t        else if (charAt == ch)\n\t        {\n\t            return startIndex;\n\t        }\n\t    }\n\t\t\n\t    return -1;\n\t}","id":9996,"modified_method":"/**\n\t * Find the char but ignore any text within \"..\" and '..'\n\t * \n\t * @param ch\n\t *            The character to search\n\t * @param startIndex\n\t *            Start index\n\t * @return -1 if not found, else the index\n\t */\n\tprivate int findCloseBracket(final char ch, int startIndex)\n\t{\n\t\tchar quote = 0;\n\n\t\tfor (; startIndex < this.input.size(); startIndex++)\n\t\t{\n\t\t\tchar charAt = this.input.charAt(startIndex);\n\t\t\tif (quote != 0)\n\t\t\t{\n\t\t\t\tif (quote == charAt)\n\t\t\t\t{\n\t\t\t\t\tquote = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((charAt == '\"') || (charAt == '\\''))\n\t\t\t{\n\t\t\t\tquote = charAt;\n\t\t\t}\n\t\t\telse if (charAt == ch)\n\t\t\t{\n\t\t\t\treturn startIndex;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Remember the current position in markup\n\t * \n\t * @param pos\n\t */\n\tpublic final void setPositionMarker(final int pos)\n\t{\n\t\tthis.positionMarker = pos;\n\t}","id":9997,"modified_method":"/**\n\t * \n\t * @see wicket.markup.parser.IXmlPullParser#setPositionMarker(int)\n\t */\n\tpublic final void setPositionMarker(final int pos)\n\t{\n\t\tthis.input.setPositionMarker(pos);\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the character sequence in between both positions.\n\t *\n\t * @param fromPos\n\t *            first index\n\t * @param toPos\n\t *            second index\n\t * @return the string (raw markup) in between both positions\n\t */\n\tpublic final CharSequence getInputSubsequence(final int fromPos, final int toPos)\n\t{\n\t\treturn this.input.subSequence(fromPos, toPos);\n\t}","id":9998,"modified_method":"/**\n\t * \n\t * @see wicket.markup.parser.IXmlPullParser#getInput(int, int)\n\t */\n\tpublic final CharSequence getInput(final int fromPos, final int toPos)\n\t{\n\t\treturn this.input.getSubstring(fromPos, toPos);\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Whatever will be in between the current index and the closing tag,\n\t * will be ignored (and thus treated as raw markup (text). This is useful\n\t * for tags like 'script'.\n\t *  \n\t * @throws ParseException\n\t */\n\tprivate final void skipUntil() throws ParseException\n\t{\n\t\t// this is a tag with non-XHTML text as body - skip this until the skipUntilText is found.\n\t\tfinal int startIndex = this.inputPosition;\n\n\t\tint tagNameLen = skipUntilText.length();\n\t\tint lastPos;\n\t\twhile (true)\n\t\t{\n\t\t\tthis.inputPosition = input.indexOf(\"<\/\", this.inputPosition);\n\n\t\t\tif ((this.inputPosition == -1) || ((this.inputPosition + (tagNameLen+2)) >= input.length()))\n\t\t\t{\n\t\t\t\tthrow new ParseException(skipUntilText + \" tag not closed (line \" + lineNumber + \", column \"\n\t\t\t\t\t\t+ columnNumber + \")\", startIndex);\n\t\t\t}\n\n\t\t\tlastPos = this.inputPosition + 2;\n\t\t\tfinal String endTagText = input.substring(lastPos, lastPos + tagNameLen);\n\t\t\tif (endTagText.toLowerCase().equals(skipUntilText))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.inputPosition = lastPos;\n\t\t}\n\t\t\n\t\t// Get index of closing tag and advance past the tag\n\t\tlastPos = input.indexOf('>', lastPos + tagNameLen);\n\t\t\n\t\tif (lastPos == -1)\n\t\t{\n\t\t\tthrow new ParseException(\"Script tag not closed (line \" + lineNumber + \", column \"\n\t\t\t\t\t+ columnNumber + \")\", startIndex);\t\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\t// Reset the state variable\n\t\tthis.skipUntilText = null;\n\t}","id":9999,"modified_method":"/**\n\t * Whatever will be in between the current index and the closing tag, will\n\t * be ignored (and thus treated as raw markup (text). This is useful for\n\t * tags like 'script'.\n\t * \n\t * @throws ParseException\n\t */\n\tprivate final void skipUntil() throws ParseException\n\t{\n\t\t// this is a tag with non-XHTML text as body - skip this until the\n\t\t// skipUntilText is found.\n\t\tfinal int startIndex = this.input.getPosition();\n\t\tfinal int tagNameLen = this.skipUntilText.length();\n\n\t\tint pos = this.input.getPosition() - 1;\n\t\tString endTagText = null;\n\t\tint lastPos = 0;\n\t\twhile (!skipUntilText.equalsIgnoreCase(endTagText))\n\t\t{\n\t\t\tpos = this.input.find(\"<\/\", pos + 1);\n\t\t\tif ((pos == -1) || ((pos + (tagNameLen + 2)) >= this.input.size()))\n\t\t\t{\n\t\t\t\tthrow new ParseException(skipUntilText + \" tag not closed (line \"\n\t\t\t\t\t\t+ this.input.getLineNumber() + \", column \" + this.input.getColumnNumber()\n\t\t\t\t\t\t+ \")\", startIndex);\n\t\t\t}\n\n\t\t\tlastPos = pos + 2;\n\t\t\tendTagText = this.input.getSubstring(lastPos, lastPos + tagNameLen).toString();\n\t\t}\n\n\t\tthis.input.setPosition(pos);\n\n\t\t// Get index of closing tag and advance past the tag\n\t\tlastPos = this.input.find('>', lastPos + tagNameLen);\n\t\tif (lastPos == -1)\n\t\t{\n\t\t\tthrow new ParseException(\"Script tag not closed (line \" + this.input.getLineNumber()\n\t\t\t\t\t+ \", column \" + this.input.getColumnNumber() + \")\", startIndex);\n\t\t}\n\n\t\t// Reset the state variable\n\t\tthis.skipUntilText = null;\n\t}","commit_id":"1d9e3f86003812b0e963e2334c831949898ea9b4","url":"https://github.com/apache/wicket"}]